From c2ea6185bf39e38b7eb65cee612b8bf163ebfe5b Mon Sep 17 00:00:00 2001
From: yaozenhu <yaozenhu@realtek.com>
Date: Thu, 13 Mar 2025 22:55:09 -0400
Subject: [PATCH] realtek minigbm implementation

---
 drv.c                  |   3 +-
 dumb_driver.c          |   3 +
 external/realtek_drm.h |  60 ++++++++++++
 minigbm_helpers.c      |   2 +
 realtek.c              | 205 +++++++++++++++++++++++++++++++++++++++++
 5 files changed, 272 insertions(+), 1 deletion(-)
 create mode 100644 external/realtek_drm.h
 create mode 100644 realtek.c

diff --git a/drv.c b/drv.c
index 7fd2250..d4a9fb1 100644
--- a/drv.c
+++ b/drv.c
@@ -55,6 +55,7 @@ extern const struct backend backend_synaptics;
 extern const struct backend backend_virtgpu;
 extern const struct backend backend_udl;
 extern const struct backend backend_vkms;
+extern const struct backend backend_realtek;
 
 extern const struct backend backend_mock;
 
@@ -74,7 +75,7 @@ static const struct backend *drv_backend_list[] = {
 	&backend_evdi,	    &backend_komeda,	&backend_marvell, &backend_mediatek,
 	&backend_meson,	    &backend_nouveau,	&backend_radeon,  &backend_rockchip,
 	&backend_sun4i_drm, &backend_synaptics, &backend_udl,	  &backend_virtgpu,
-	&backend_vkms,	    &backend_mock
+	&backend_vkms,	    &backend_mock,      &backend_realtek
 };
 
 void drv_preload(bool load)
diff --git a/dumb_driver.c b/dumb_driver.c
index f74d237..1dc9bea 100644
--- a/dumb_driver.c
+++ b/dumb_driver.c
@@ -75,6 +75,9 @@ INIT_DUMB_DRIVER(synaptics)
 INIT_DUMB_DRIVER(udl)
 INIT_DUMB_DRIVER(vkms)
 
+#ifndef DRV_REALTEK
+INIT_DUMB_DRIVER(realtek)
+#endif
 #ifndef DRV_ROCKCHIP
 INIT_DUMB_DRIVER(rockchip)
 #endif
diff --git a/external/realtek_drm.h b/external/realtek_drm.h
new file mode 100644
index 0000000..e7a3574
--- /dev/null
+++ b/external/realtek_drm.h
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2019 Realtek Inc.
+ * Author: Simon Hsu <simon_hsu@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI_REALTEK_DRM_H
+#define _UAPI_REALTEK_DRM_H
+
+#include <drm/drm.h>
+
+/**
+ * User-desired buffer creation information structure.
+ *
+ * @size: user-desired memory allocation size.
+ *	- this size value would be page-aligned internally.
+ * @flags: user request for setting memory type or cache attributes.
+ * @handle: returned a handle to created gem object.
+ *	- this handle will be set by gem module of kernel side.
+ */
+struct drm_rtk_gem_create {
+	uint64_t size;
+	uint32_t flags;
+	uint32_t handle;
+};
+
+/**
+ * A structure for getting buffer offset.
+ *
+ * @handle: a pointer to gem object created.
+ * @pad: just padding to be 64-bit aligned.
+ * @offset: relatived offset value of the memory region allocated.
+ *     - this value should be set by user.
+ */
+struct drm_rtk_gem_map_off {
+	uint32_t handle;
+	uint32_t pad;
+	uint64_t offset;
+};
+
+#define DRM_RTK_GEM_CREATE		0x00
+#define DRM_RTK_GEM_MAP_OFFSET		0x01
+
+#define DRM_IOCTL_RTK_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_RTK_GEM_CREATE, struct drm_rtk_gem_create)
+
+#define DRM_IOCTL_RTK_GEM_MAP_OFFSET	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_RTK_GEM_MAP_OFFSET, struct drm_rtk_gem_map_off)
+
+
+#endif /* _UAPI_REALTEK_DRM_H */
diff --git a/minigbm_helpers.c b/minigbm_helpers.c
index d1da7c4..69f0380 100644
--- a/minigbm_helpers.c
+++ b/minigbm_helpers.c
@@ -204,6 +204,8 @@ static int detect_device_info(unsigned int detect_flags, int fd, struct gbm_devi
 	} else if (strncmp("udl", version->name, version->name_len) == 0) {
 		info->dev_type_flags |=
 		    GBM_DEV_TYPE_FLAG_DISPLAY | GBM_DEV_TYPE_FLAG_USB | GBM_DEV_TYPE_FLAG_BLOCKED;
+	} else if (strncmp("realtek", version->name, version->name_len) == 0) {
+		info->dev_type_flags |= GBM_DEV_TYPE_FLAG_DISPLAY | GBM_DEV_TYPE_FLAG_ARMSOC;
 	}
 
 done:
diff --git a/realtek.c b/realtek.c
new file mode 100644
index 0000000..b9b0394
--- /dev/null
+++ b/realtek.c
@@ -0,0 +1,205 @@
+#ifdef DRV_REALTEK
+
+#include <errno.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <xf86drm.h>
+
+#include "drv_helpers.h"
+#include "drv_priv.h"
+#include "util.h"
+#include "external/realtek_drm.h"
+
+#define RTK_AFBC_ENABLE 1
+
+#define DRM_FORMAT_MOD_REALTEK_AFBC \
+    DRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_BLOCK_SIZE_16x16 | AFBC_FORMAT_MOD_YTR) \
+
+static const uint32_t scanout_render_formats[] = { DRM_FORMAT_ARGB8888, DRM_FORMAT_XRGB8888,
+				DRM_FORMAT_ABGR8888, DRM_FORMAT_XBGR8888,
+				DRM_FORMAT_BGR888, DRM_FORMAT_RGB565 };
+
+static const uint32_t texture_only_formats[] = { DRM_FORMAT_R8, DRM_FORMAT_NV12, DRM_FORMAT_NV21,
+				DRM_FORMAT_YVU420, DRM_FORMAT_YVU420_ANDROID };
+
+
+static int realtek_driver_init(struct driver *drv)
+{
+	drv_add_combinations(drv, scanout_render_formats, ARRAY_SIZE(scanout_render_formats),
+					&LINEAR_METADATA, BO_USE_RENDER_MASK | BO_USE_SCANOUT);
+
+	drv_add_combinations(drv, texture_only_formats, ARRAY_SIZE(texture_only_formats),
+					&LINEAR_METADATA, BO_USE_TEXTURE_MASK);
+
+	drv_modify_combination(drv, DRM_FORMAT_R8, &LINEAR_METADATA,
+					BO_USE_CAMERA_READ | BO_USE_CAMERA_WRITE | BO_USE_SW_MASK |
+					BO_USE_LINEAR | BO_USE_HW_VIDEO_DECODER | BO_USE_HW_VIDEO_ENCODER |
+					BO_USE_GPU_DATA_BUFFER | BO_USE_SENSOR_DIRECT_DATA);
+
+	drv_modify_combination(drv, DRM_FORMAT_NV12, &LINEAR_METADATA,
+					BO_USE_CAMERA_READ | BO_USE_CAMERA_WRITE | BO_USE_SCANOUT |
+					BO_USE_HW_VIDEO_DECODER | BO_USE_HW_VIDEO_ENCODER);
+
+	drv_modify_combination(drv, DRM_FORMAT_ARGB8888, &LINEAR_METADATA, BO_USE_CURSOR | BO_USE_SCANOUT);
+	drv_modify_combination(drv, DRM_FORMAT_XRGB8888, &LINEAR_METADATA, BO_USE_CURSOR | BO_USE_SCANOUT);
+
+	return drv_modify_linear_combinations(drv);
+}
+
+#ifdef RTK_AFBC_ENABLE
+static int afbc_bo_from_format(struct bo *bo, uint32_t width, uint32_t height, uint32_t format,
+                   uint64_t modifier)
+{
+    /* We've restricted ourselves to four bytes per pixel. */
+	const uint32_t pixel_size = 4;
+
+	const uint32_t clump_width = 4;
+	const uint32_t clump_height = 4;
+
+#define AFBC_NARROW 1
+#if AFBC_NARROW == 1
+	const uint32_t block_width = 4 * clump_width;
+	const uint32_t block_height = 4 * clump_height;
+#else
+	const uint32_t block_width = 8 * clump_width;
+	const uint32_t block_height = 2 * clump_height;
+#endif
+
+	const uint32_t header_block_size = 16;
+	const uint32_t body_block_size = block_width * block_height * pixel_size;
+	const uint32_t width_in_blocks = DIV_ROUND_UP(width, block_width);
+	const uint32_t height_in_blocks = DIV_ROUND_UP(height, block_height);
+	const uint32_t total_blocks = width_in_blocks * height_in_blocks;
+
+	const uint32_t header_plane_size = total_blocks * header_block_size;
+	const uint32_t body_plane_size = total_blocks * body_block_size;
+
+	/* GPU requires 64 bytes, but EGL import code expects 1024 byte
+	 * alignement for the body plane. */
+	const uint32_t body_plane_alignment = 1024;
+
+	const uint32_t body_plane_offset = ALIGN(header_plane_size, body_plane_alignment);
+	const uint32_t total_size = body_plane_offset + body_plane_size;
+
+	bo->meta.strides[0] = width_in_blocks * block_width * pixel_size;
+	bo->meta.sizes[0] = total_size;
+	bo->meta.offsets[0] = 0;
+	bo->meta.total_size = total_size;
+
+	bo->meta.format_modifier = modifier;
+
+	return 0;
+}
+
+static int afbc_support_format(uint32_t format)
+{
+	int ret = -1;
+	switch (format) {
+		case DRM_FORMAT_ARGB8888:
+		case DRM_FORMAT_XRGB8888:
+		case DRM_FORMAT_ABGR8888:
+		case DRM_FORMAT_XBGR8888:
+			ret = 0;
+			break;
+		default:
+			ret = -1;
+			break;
+	}
+	return ret;
+}
+#endif
+
+static int realtek_bo_create_with_modifiers(struct bo *bo, uint32_t width, uint32_t height,
+           uint32_t format, const uint64_t *modifiers, uint32_t count)
+{
+	int ret;
+	struct drm_rtk_gem_create args = { 0 };
+#ifdef RTK_AFBC_ENABLE
+	uint64_t afbc_modifier;
+    if (afbc_support_format(format) >= 0 && drv_has_modifier(modifiers, count, DRM_FORMAT_MOD_REALTEK_AFBC)) {
+        afbc_modifier = DRM_FORMAT_MOD_REALTEK_AFBC;
+    } else {
+        afbc_modifier = 0;
+	}
+#endif
+
+	if (format == DRM_FORMAT_NV12) {
+		uint32_t w_mbs = DIV_ROUND_UP(width, 16);
+		uint32_t h_mbs = DIV_ROUND_UP(height, 16);
+		uint32_t aligned_width = w_mbs * 16;
+		uint32_t aligned_height = h_mbs * 16; 
+		drv_bo_from_format(bo, aligned_width, 1, aligned_height, format);
+		bo->meta.total_size += w_mbs * h_mbs * 128;
+#ifdef RTK_AFBC_ENABLE
+	} else if (afbc_modifier) {
+		afbc_bo_from_format(bo, width, height, format, afbc_modifier);
+#endif
+	} else {
+		if (!drv_has_modifier(modifiers, count, DRM_FORMAT_MOD_LINEAR)) {
+			errno = EINVAL;
+			drv_loge("no usable modifier found\n");
+			return -errno;
+		}
+
+		uint32_t stride;
+		stride = drv_stride_from_format(format, width, 0);
+		if (format == DRM_FORMAT_YVU420 || format == DRM_FORMAT_YVU420_ANDROID)
+			stride = ALIGN(stride, 128);
+		else
+			stride = ALIGN(stride, 64);
+		drv_bo_from_format(bo, stride, 1, height, format);
+	} 
+
+	args.size = bo->meta.total_size;
+	ret = drmCommandWriteRead(bo->drv->fd, DRM_RTK_GEM_CREATE , &args, sizeof(args));
+
+	if (ret) {
+		drv_loge("DRM_RTK_GEM_CREATE failed (size=%zu) ret:%d\n", bo->meta.total_size, ret);
+		return -errno;
+	} 
+	bo->handle.u32 = args.handle;
+    return 0;
+}
+
+static int realtek_bo_create(struct bo *bo, uint32_t width, uint32_t height, uint32_t format,
+					uint64_t use_flags)
+{
+	uint64_t modifiers[] = { DRM_FORMAT_MOD_LINEAR };
+	return realtek_bo_create_with_modifiers(bo, width, height, format, modifiers, ARRAY_SIZE(modifiers));
+}
+
+static void * realtek_bo_map(struct bo *bo, struct vma *vma, uint32_t map_flags)
+{
+	int ret;
+	struct drm_rtk_gem_map_off args = { 0 };
+#ifdef RTK_AFBC_ENABLE
+    if (bo->meta.format_modifier == DRM_FORMAT_MOD_REALTEK_AFBC)
+        return MAP_FAILED;
+#endif
+
+	args.handle = bo->handle.u32;
+	ret = drmCommandWriteRead(bo->drv->fd, DRM_RTK_GEM_MAP_OFFSET, &args, sizeof(args));
+	if (ret) {
+		drv_loge("DRM_RTK_GEM_MAP_OFFSET failed\n");
+		return MAP_FAILED;
+	}
+
+	vma->length = bo->meta.total_size;
+	return mmap(NULL, bo->meta.total_size, drv_get_prot(map_flags), MAP_SHARED, bo->drv->fd,
+							args.offset);
+}
+
+const struct backend backend_realtek = {
+	.name = "realtek",
+	.init = realtek_driver_init,
+	.bo_create = realtek_bo_create,
+	.bo_create_with_modifiers = realtek_bo_create_with_modifiers,
+	.bo_destroy = drv_gem_bo_destroy,
+	.bo_import = drv_prime_bo_import,
+	.bo_map = realtek_bo_map,
+	.bo_unmap = drv_bo_munmap,
+	.resolve_format_and_use_flags = drv_resolve_format_and_use_flags_helper,
+};
+#endif //DRV_REALTEK
-- 
2.34.1

