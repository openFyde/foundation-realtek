From 8618927d6a19eee3abdb60f17924db91087912df Mon Sep 17 00:00:00 2001
From: yaozenhu <yaozenhu@realtek.com>
Date: Tue, 5 Nov 2024 10:42:23 +0800
Subject: [PATCH] provide dma_contig allocator to uvcvideo driver

---
 drivers/media/usb/uvc/Kconfig      |  2 ++
 drivers/media/usb/uvc/uvc_driver.c |  2 +-
 drivers/media/usb/uvc/uvc_queue.c  | 24 +++++++++++++++++++++---
 drivers/media/usb/uvc/uvcvideo.h   |  4 ++--
 4 files changed, 26 insertions(+), 6 deletions(-)

--- a/drivers/media/usb/uvc/Kconfig
+++ b/drivers/media/usb/uvc/Kconfig
@@ -2,8 +2,10 @@
 config USB_VIDEO_CLASS
 	tristate "USB Video Class (UVC)"
 	depends on VIDEO_DEV
+	depends on HAS_DMA
 	select VIDEOBUF2_VMALLOC
 	select UVC_COMMON
+	select VIDEOBUF2_DMA_CONTIG
 	help
 	  Support for the USB Video Class (UVC).  Currently only video
 	  input devices, such as webcams, are supported.
--- a/drivers/media/usb/uvc/uvc_driver.c
+++ b/drivers/media/usb/uvc/uvc_driver.c
@@ -2025,7 +2025,7 @@
 	int ret;
 
 	/* Initialize the video buffers queue. */
-	ret = uvc_queue_init(queue, type, !uvc_no_drop_param);
+	ret = uvc_queue_init(dev, queue, type, !uvc_no_drop_param);
 	if (ret)
 		return ret;
 
--- a/drivers/media/usb/uvc/uvc_queue.c
+++ b/drivers/media/usb/uvc/uvc_queue.c
@@ -17,6 +17,7 @@
 #include <linux/wait.h>
 #include <media/videobuf2-v4l2.h>
 #include <media/videobuf2-vmalloc.h>
+#include <media/videobuf2-dma-contig.h>
 
 #include "uvcvideo.h"
 
@@ -32,6 +33,13 @@
  * the driver.
  */
 
+static unsigned int allocators = 1;
+module_param(allocators, uint, 0644);
+MODULE_PARM_DESC(allocators, " memory allocator selection, default is 0.\n"
+				"\t\t    0 == vmalloc\n"
+				"\t\t    1 == dma-contig");
+
+
 static inline struct uvc_buffer *uvc_vbuf_to_buffer(struct vb2_v4l2_buffer *buf)
 {
 	return container_of(buf, struct uvc_buffer, buf);
@@ -212,19 +220,29 @@
 	.stop_streaming = uvc_stop_streaming,
 };
 
-int uvc_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type,
-		    int drop_corrupted)
+int uvc_queue_init(struct uvc_device *dev, struct uvc_video_queue *queue,
+					enum v4l2_buf_type type, int drop_corrupted)
 {
 	int ret;
+	static const struct vb2_mem_ops * const uvc_mem_ops[2] = {
+		&vb2_vmalloc_memops,
+		&vb2_dma_contig_memops,
+	};
+
+	if (allocators == 1)
+		dma_coerce_mask_and_coherent(dev->vdev.dev, DMA_BIT_MASK(32));
+	else if (allocators >= ARRAY_SIZE(uvc_mem_ops))
+		allocators = 0;
 
 	queue->queue.type = type;
 	queue->queue.io_modes = VB2_MMAP | VB2_USERPTR;
 	queue->queue.drv_priv = queue;
 	queue->queue.buf_struct_size = sizeof(struct uvc_buffer);
-	queue->queue.mem_ops = &vb2_vmalloc_memops;
+	queue->queue.mem_ops = uvc_mem_ops[allocators];
 	queue->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC
 		| V4L2_BUF_FLAG_TSTAMP_SRC_SOE;
 	queue->queue.lock = &queue->mutex;
+	queue->queue.dev = dev->vdev.dev;
 
 	switch (type) {
 	case V4L2_BUF_TYPE_META_CAPTURE:
--- a/drivers/media/usb/uvc/uvcvideo.h
+++ b/drivers/media/usb/uvc/uvcvideo.h
@@ -704,8 +704,8 @@
 struct uvc_entity *uvc_entity_by_id(struct uvc_device *dev, int id);
 
 /* Video buffers queue management. */
-int uvc_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type,
-		   int drop_corrupted);
+extern int uvc_queue_init(struct uvc_device *dev, struct uvc_video_queue *queue,
+			enum v4l2_buf_type type, int drop_corrupted);
 void uvc_queue_release(struct uvc_video_queue *queue);
 int uvc_request_buffers(struct uvc_video_queue *queue,
 			struct v4l2_requestbuffers *rb);
