From 4415ce681f51e2b62f40fbcbd83f3a0e68643bd1 Mon Sep 17 00:00:00 2001
From: Wei <wei@fydeos.io>
Date: Tue, 23 Sep 2025 16:21:58 +0800
Subject: [PATCH] add-rtk-vdec-driver

Change-Id: I1016f873febd4f0c72d7804c33092ada83a84b55
---
 drivers/media/platform/realtek/Makefile       |   50 +
 .../realtek/coda/rtk_jcodec/rtk_jcodec_drv.c  | 2644 +++++++
 .../realtek/coda/rtk_jcodec/rtk_jcodec_drv.h  |  486 ++
 .../realtek/coda/rtk_jcodec/rtk_jcodec_jpeg.c | 2778 +++++++
 .../realtek/coda/rtk_jcodec/rtk_jcodec_regs.h |  136 +
 .../realtek/coda/rtk_jcodec/ve_common.h       |  189 +
 drivers/media/platform/realtek/legacy/debug.h |   67 +
 .../media/platform/realtek/legacy/drv_if.c    | 1752 +++++
 .../media/platform/realtek/legacy/drv_if.h    |  133 +
 .../platform/realtek/legacy/rtkve1_common.c   |  828 +++
 .../realtek/legacy/rtkve1_regdefine.h         |  599 ++
 .../realtek/legacy/rtkve1enc_common.h         |  288 +
 .../platform/realtek/legacy/rtkve1enc_enc.c   | 2244 ++++++
 .../platform/realtek/legacy/rtkve1enc_v4l2.c  |  685 ++
 .../platform/realtek/legacy/ve1_config.h      |   61 +
 .../platform/realtek/legacy/ve1_decode.c      |  651 ++
 .../media/platform/realtek/legacy/ve1_mem.c   |  324 +
 .../media/platform/realtek/legacy/ve1_mem.h   |   26 +
 .../platform/realtek/legacy/ve1_mem_compat.c  |   69 +
 .../platform/realtek/legacy/ve1_mem_compat.h  |   14 +
 .../platform/realtek/legacy/ve1_mem_uapi.h    |   17 +
 .../media/platform/realtek/legacy/ve1_mm.c    |  580 ++
 .../media/platform/realtek/legacy/ve1_mm.h    |   70 +
 .../platform/realtek/legacy/ve1_product.c     | 1138 +++
 .../platform/realtek/legacy/ve1_product.h     |  220 +
 .../platform/realtek/legacy/ve1_regdefine.h   |  595 ++
 .../media/platform/realtek/legacy/ve1_v4l2.c  | 1542 ++++
 .../media/platform/realtek/legacy/ve1_v4l2.h  |  498 ++
 .../realtek/legacy/ve1_v4l2_drv_ops.h         |   36 +
 .../media/platform/realtek/legacy/ve1_vdi.c   | 3241 ++++++++
 .../media/platform/realtek/legacy/ve1_vdi.h   |  213 +
 .../platform/realtek/legacy/ve1_vdi_osal.c    |  310 +
 .../platform/realtek/legacy/ve1_vdi_osal.h    |  130 +
 .../media/platform/realtek/legacy/ve1_vpu.c   | 4544 ++++++++++++
 .../media/platform/realtek/legacy/ve1_vpu.h   |   97 +
 .../platform/realtek/legacy/ve1_vpu_md5.h     |   15 +
 .../platform/realtek/legacy/ve1_vpuapi.c      | 5006 +++++++++++++
 .../platform/realtek/legacy/ve1_vpuapi.h      | 6535 +++++++++++++++++
 .../platform/realtek/legacy/ve1_vpuapifunc.c  | 5174 +++++++++++++
 .../platform/realtek/legacy/ve1_vpuapifunc.h  |  751 ++
 .../platform/realtek/legacy/ve1_vpuconfig.h   |  147 +
 .../platform/realtek/legacy/ve1_vpuerror.h    |  229 +
 .../platform/realtek/legacy/ve1_vputypes.h    |  104 +
 .../platform/realtek/legacy/ve1_wrapper.c     | 4268 +++++++++++
 .../platform/realtek/legacy/ve1_wrapper.h     |   82 +
 drivers/media/platform/realtek/legacy/ve2.c   | 1331 ++++
 drivers/media/platform/realtek/legacy/ve2.h   |   31 +
 .../media/platform/realtek/legacy/ve2_frame.h |  216 +
 .../media/platform/realtek/legacy/ve2rpc.c    | 3116 ++++++++
 .../media/platform/realtek/legacy/ve2rpc.h    |  304 +
 .../platform/realtek/legacy/ve2rpc_cmd.h      |  581 ++
 .../media/platform/realtek/legacy/ve_common.h |  189 +
 .../platform/realtek/legacy/video_engine.h    |   17 +
 drivers/media/platform/realtek/legacy/vpu.c   | 1841 +++++
 drivers/media/platform/realtek/legacy/vpu.h   |  176 +
 .../platform/realtek/rtkve/enc/rtkve-common.c |  110 +
 .../platform/realtek/rtkve/enc/rtkve-common.h |  211 +
 .../realtek/rtkve/enc/rtkve-enc-drv.c         |  308 +
 .../realtek/rtkve/enc/rtkve-enc-v4l2.c        |  609 ++
 .../realtek/rtkve/enc/rtkve-rpc-def.h         |  498 ++
 .../platform/realtek/rtkve/enc/rtkve-rpc.c    | 1090 +++
 .../platform/realtek/rtkve/enc/rtkve-rpc.h    |  105 +
 .../rtkve/enc/rtkve-stateful-vpu-enc.c        | 1179 +++
 .../platform/realtek/rtkve/enc/rtkve-vpu.h    |   87 +
 64 files changed, 61565 insertions(+)
 create mode 100644 drivers/media/platform/realtek/Makefile
 create mode 100644 drivers/media/platform/realtek/coda/rtk_jcodec/rtk_jcodec_drv.c
 create mode 100644 drivers/media/platform/realtek/coda/rtk_jcodec/rtk_jcodec_drv.h
 create mode 100644 drivers/media/platform/realtek/coda/rtk_jcodec/rtk_jcodec_jpeg.c
 create mode 100644 drivers/media/platform/realtek/coda/rtk_jcodec/rtk_jcodec_regs.h
 create mode 100644 drivers/media/platform/realtek/coda/rtk_jcodec/ve_common.h
 create mode 100644 drivers/media/platform/realtek/legacy/debug.h
 create mode 100644 drivers/media/platform/realtek/legacy/drv_if.c
 create mode 100644 drivers/media/platform/realtek/legacy/drv_if.h
 create mode 100644 drivers/media/platform/realtek/legacy/rtkve1_common.c
 create mode 100755 drivers/media/platform/realtek/legacy/rtkve1_regdefine.h
 create mode 100644 drivers/media/platform/realtek/legacy/rtkve1enc_common.h
 create mode 100755 drivers/media/platform/realtek/legacy/rtkve1enc_enc.c
 create mode 100755 drivers/media/platform/realtek/legacy/rtkve1enc_v4l2.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_config.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_decode.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_mem.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_mem.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_mem_compat.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_mem_compat.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_mem_uapi.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_mm.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_mm.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_product.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_product.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_regdefine.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_v4l2.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_v4l2.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_v4l2_drv_ops.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_vdi.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_vdi.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_vdi_osal.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_vdi_osal.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_vpu.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_vpu.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_vpu_md5.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_vpuapi.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_vpuapi.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_vpuapifunc.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_vpuapifunc.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_vpuconfig.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_vpuerror.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_vputypes.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_wrapper.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve1_wrapper.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve2.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve2.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve2_frame.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve2rpc.c
 create mode 100644 drivers/media/platform/realtek/legacy/ve2rpc.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve2rpc_cmd.h
 create mode 100644 drivers/media/platform/realtek/legacy/ve_common.h
 create mode 100644 drivers/media/platform/realtek/legacy/video_engine.h
 create mode 100644 drivers/media/platform/realtek/legacy/vpu.c
 create mode 100644 drivers/media/platform/realtek/legacy/vpu.h
 create mode 100644 drivers/media/platform/realtek/rtkve/enc/rtkve-common.c
 create mode 100644 drivers/media/platform/realtek/rtkve/enc/rtkve-common.h
 create mode 100644 drivers/media/platform/realtek/rtkve/enc/rtkve-enc-drv.c
 create mode 100644 drivers/media/platform/realtek/rtkve/enc/rtkve-enc-v4l2.c
 create mode 100644 drivers/media/platform/realtek/rtkve/enc/rtkve-rpc-def.h
 create mode 100644 drivers/media/platform/realtek/rtkve/enc/rtkve-rpc.c
 create mode 100644 drivers/media/platform/realtek/rtkve/enc/rtkve-rpc.h
 create mode 100644 drivers/media/platform/realtek/rtkve/enc/rtkve-stateful-vpu-enc.c
 create mode 100644 drivers/media/platform/realtek/rtkve/enc/rtkve-vpu.h

--- /dev/null
+++ b/drivers/media/platform/realtek/Makefile
@@ -0,0 +1,50 @@
+rtkvdec-y := legacy/drv_if.o \
+	legacy/vpu.o \
+	legacy/rtkve1enc_v4l2.o \
+	legacy/rtkve1enc_enc.o \
+	legacy/rtkve1_common.o
+rtkve1-y := legacy/ve1_v4l2.o \
+	legacy/ve1_decode.o \
+	legacy/ve1_mem.o \
+	legacy/ve1_mm.o \
+	legacy/ve1_vdi.o \
+	legacy/ve1_vdi_osal.o \
+	legacy/ve1_vpu.o \
+	legacy/ve1_product.o \
+	legacy/ve1_vpuapifunc.o \
+	legacy/ve1_vpuapi.o \
+	legacy/ve1_wrapper.o
+rtkve2-y := legacy/ve2.o \
+	legacy/ve2rpc.o
+rtkve_enc-y := rtkve/enc/rtkve-common.o        \
+	rtkve/enc/rtkve-rpc.o   \
+	rtkve/enc/rtkve-stateful-vpu-enc.o      \
+	rtkve/enc/rtkve-enc-v4l2.o      \
+	rtkve/enc/rtkve-enc-drv.o
+ifeq ($(CONFIG_RTK_IMAGE_CODEC), y)
+rtkjpeg-y := coda/rtk_jcodec/rtk_jcodec_drv.o      \
+	coda/rtk_jcodec/rtk_jcodec_jpeg.o
+endif
+
+ifeq ($(CONFIG_RTK_V4L2_VDEC), y)
+obj-m += rtkvdec.o rtkve1.o rtkve2.o
+endif
+ifeq ($(CONFIG_RTK_IMAGE_CODEC), y)
+obj-m += rtkjpeg.o
+endif
+
+ifeq ($(CONFIG_RTK_V4L2_VENC), y)
+obj-m += rtkve_enc.o
+endif
+
+ifdef CONFIG_COMPAT
+	rtkve1-y       += legacy/ve1_mem_compat.o
+endif
+
+EXTRA_CFLAGS = -DANDROID
+#EXTRA_CFLAGS += -Werror -Wuninitialized  -Wmaybe-uninitialized -Wstrict-prototypes
+EXTRA_CFLAGS += -I$(src) -I$(srctree)/drivers/soc/realtek/rtd16xxb/rtk_ve/ve1
+
+ifeq ($(CONFIG_ENABLE_CC), y)
+	EXTRA_CFLAGS += -DVPU_GET_CC
+endif
--- /dev/null
+++ b/drivers/media/platform/realtek/coda/rtk_jcodec/rtk_jcodec_drv.c
@@ -0,0 +1,2644 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/gcd.h>
+#include <linux/genalloc.h>
+#include <linux/idr.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/kfifo.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/videodev2.h>
+#include <linux/of.h>
+#include <linux/ratelimit.h>
+#include <linux/reset.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-v4l2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/videobuf2-vmalloc.h>
+
+#include <linux/dma-map-ops.h>
+#include <soc/realtek/memory.h>
+#include <soc/realtek/rtk_media_heap.h>
+
+#include "rtk_jcodec_drv.h"
+#include "rtk_jcodec_regs.h"
+
+#include <linux/of_address.h>
+
+#define RTK_JCODEC_NAME "rtk-jcodec"
+
+#define RTK_JCODEC_MAX_FORMATS 10
+
+#define RTK_COD_STD_DECODE_JPEG 0
+#define RTK_COD_STD_ENCODE_JPEG 1
+
+// TODO: reference to ve1_vdi.c
+#define RTK_SRAM_SIZE 0x1D000
+#define FRATE_RES_MASK 0xffff
+#define FRATE_DIV_OFFSET 16
+
+#define TEMP_BUF_SIZE (204 * 1024)
+#define WORK_BUF_SIZE (80 * 1024)
+
+#define MAX_4K_WIDTH 4096
+#define MAX_4K_HEIGHT 2304
+
+#define MAX_2K_WIDTH 1920
+#define MAX_2K_HEIGHT 1088
+
+#define MIN_WIDTH 64
+#define MIN_HEIGHT 64
+
+#define MIN_W 48
+#define MIN_H 16
+
+#define S_ALIGN 0
+#define W_ALIGN 0
+#define H_ALIGN 0
+//#define S_ALIGN 1 /* multiple of 2 */
+//#define W_ALIGN 1 /* multiple of 2 */
+//#define H_ALIGN 1 /* multiple of 2 */
+
+#define CODA7_STREAM_BUF_PIC_FLUSH (1 << 3)
+#define CODA9_FRAME_ENABLE_BWB (1 << 12)
+#define RTK_REG_RESET_ENABLE (1 << 0)
+#define RTK_REG_RUN_ENABLE (1 << 0)
+#define RTK_REG_INT_CLEAR_ENABLE 0x1
+
+#define VE_CTRL_REG (0x3000)
+#define VE_CTI_GRP_REG (0x3004)
+#define VE_MBIST_CTRL (0x3C08)
+#define VE_BISR_POWER_RESET (0x3CB0)
+
+#define RTK_COMMAND_FIRMWARE_GET 0xf
+
+#define RTK_FIRMWARE_PRODUCT(x) (((x) >> 16) & 0xffff)
+#define RTK_FIRMWARE_MAJOR(x) (((x) >> 12) & 0x0f)
+#define RTK_FIRMWARE_MINOR(x) (((x) >> 8) & 0x0f)
+#define RTK_FIRMWARE_RELEASE(x) ((x)&0xff)
+
+// #define CODA_ROT_MIR_ENABLE	(1 << 4)
+// #define CODA_ROT_0			(0x0 << 0)
+// #define CODA_ROT_90			(0x1 << 0)
+// #define CODA_ROT_180		(0x2 << 0)
+// #define CODA_ROT_270		(0x3 << 0)
+// #define CODA_MIR_NONE		(0x0 << 2)
+#define CODA_MIR_VER (0x1 << 2)
+#define CODA_MIR_HOR (0x2 << 2)
+// #define CODA_MIR_VER_HOR	(0x3 << 2)
+
+#define MIN_BITRATE (64)
+#define MAX_BITRATE (40 * 1024 * 1024)
+#define DEF_BITRATE (5 * 1024 * 1024)
+
+static int dbus_en = 1;
+
+#define fh_to_ctx(__fh) container_of(__fh, struct rtk_jcodec_ctx, fh)
+
+int rtk_jcodec_debug;
+module_param(rtk_jcodec_debug, int, 0644);
+MODULE_PARM_DESC(rtk_jcodec_debug, "Debug level (0-2)");
+
+static int disable_tiling;
+module_param(disable_tiling, int, 0644);
+MODULE_PARM_DESC(disable_tiling, "Disable tiled frame buffers");
+
+static ssize_t get_instance_info(struct device *dev, struct device_attribute *attr,
+			 char *buf);
+
+static DEVICE_ATTR(instance_info, S_IRUSR, get_instance_info, NULL);
+
+#define RTK_CODEC(mode, src_fourcc, dst_fourcc, max_w, max_h)                  \
+	{                                                                      \
+		mode, src_fourcc, dst_fourcc, max_w, max_h                     \
+	}
+
+static const struct rtk_codec rtk_video_codecs[] = {
+	RTK_CODEC(RTK_COD_STD_DECODE_JPEG, V4L2_PIX_FMT_JPEG, V4L2_PIX_FMT_NV12,
+		  MAX_4K_WIDTH, MAX_4K_HEIGHT),
+	RTK_CODEC(RTK_COD_STD_DECODE_JPEG, V4L2_PIX_FMT_JPEG, V4L2_PIX_FMT_NV16,
+		  MAX_4K_WIDTH, MAX_4K_HEIGHT),
+	RTK_CODEC(RTK_COD_STD_DECODE_JPEG, V4L2_PIX_FMT_JPEG, V4L2_PIX_FMT_NV24,
+		  MAX_4K_WIDTH, MAX_4K_HEIGHT),
+	RTK_CODEC(RTK_COD_STD_DECODE_JPEG, V4L2_PIX_FMT_JPEG,
+		  V4L2_PIX_FMT_RGB24, MAX_4K_WIDTH, MAX_4K_HEIGHT),
+	RTK_CODEC(RTK_COD_STD_ENCODE_JPEG, V4L2_PIX_FMT_YUV420,
+		  V4L2_PIX_FMT_JPEG, MAX_4K_WIDTH, MAX_4K_HEIGHT),
+	RTK_CODEC(RTK_COD_STD_ENCODE_JPEG, V4L2_PIX_FMT_NV12, V4L2_PIX_FMT_JPEG,
+		  MAX_4K_WIDTH, MAX_4K_HEIGHT),
+	RTK_CODEC(RTK_COD_STD_ENCODE_JPEG, V4L2_PIX_FMT_YUV422P,
+		  V4L2_PIX_FMT_JPEG, MAX_4K_WIDTH, MAX_4K_HEIGHT),
+	RTK_CODEC(RTK_COD_STD_ENCODE_JPEG, V4L2_PIX_FMT_NV16, V4L2_PIX_FMT_JPEG,
+		  MAX_4K_WIDTH, MAX_4K_HEIGHT),
+	RTK_CODEC(RTK_COD_STD_ENCODE_JPEG, V4L2_PIX_FMT_YUV444M,
+		  V4L2_PIX_FMT_JPEG, MAX_4K_WIDTH, MAX_4K_HEIGHT),
+	RTK_CODEC(RTK_COD_STD_ENCODE_JPEG, V4L2_PIX_FMT_NV24, V4L2_PIX_FMT_JPEG,
+		  MAX_4K_WIDTH, MAX_4K_HEIGHT),
+	RTK_CODEC(RTK_COD_STD_ENCODE_JPEG, V4L2_PIX_FMT_RGB24,
+		  V4L2_PIX_FMT_JPEG, MAX_4K_WIDTH, MAX_4K_HEIGHT),
+	RTK_CODEC(RTK_COD_STD_ENCODE_JPEG, V4L2_PIX_FMT_GREY, V4L2_PIX_FMT_JPEG,
+		  MAX_4K_WIDTH, MAX_4K_HEIGHT),
+};
+
+struct rtk_video_device {
+	const char *name;
+	enum rtk_jcodec_ctx_type type;
+	const struct rtk_context_ops *ops;
+	bool direct;
+	u32 src_formats[RTK_JCODEC_MAX_FORMATS];
+	u32 dst_formats[RTK_JCODEC_MAX_FORMATS];
+};
+
+static const struct rtk_video_device rtk_jpeg_decoder = {
+	.name = "rtk-jpeg-decoder",
+	.type = RTK_JCODEC_CTX_DECODER,
+	.ops = &rtk_jpeg_decode_ops,
+	.direct = true,
+	.src_formats = {
+		V4L2_PIX_FMT_JPEG,
+	},
+	.dst_formats = {
+		V4L2_PIX_FMT_NV12,
+		V4L2_PIX_FMT_NV16,
+		V4L2_PIX_FMT_NV24,
+		V4L2_PIX_FMT_RGB24,
+	},
+};
+
+static const struct rtk_video_device rtk_jpeg_encoder = {
+	.name = "rtk-jpeg-encoder",
+	.type = RTK_JCODEC_CTX_ENCODER,
+	.ops = &rtk_jpeg_encode_ops,
+	.direct = true,
+	.src_formats = {
+		V4L2_PIX_FMT_YUV420,
+		//V4L2_PIX_FMT_YVU420,
+		V4L2_PIX_FMT_NV12,
+		V4L2_PIX_FMT_YUV422P,
+		V4L2_PIX_FMT_NV16,
+		V4L2_PIX_FMT_YUV444M,
+		V4L2_PIX_FMT_NV24,
+		V4L2_PIX_FMT_RGB24,
+		V4L2_PIX_FMT_GREY,
+	},
+	.dst_formats = {
+		V4L2_PIX_FMT_JPEG,
+	},
+};
+
+static const struct rtk_video_device *rtk_video_devices[] = {
+	&rtk_jpeg_decoder,
+	&rtk_jpeg_encoder,
+};
+
+enum rtk_platform {
+	RTK_STARK,
+};
+
+static const struct rtk_devinfo rtk_devdata[] = {
+	[RTK_STARK] = {
+		.product      = CODA_J10,
+		.codecs       = rtk_video_codecs,
+		.num_codecs   = ARRAY_SIZE(rtk_video_codecs),
+		.vdevs        = rtk_video_devices,
+		.num_vdevs    = ARRAY_SIZE(rtk_video_devices),
+	},
+};
+
+static ssize_t get_instance_info(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct rtk_jcodec_dev *rdev = dev_get_drvdata(dev);
+	struct rtk_jcodec_ctx *ctx = NULL;
+	int len = 0;
+	int dec_cnt = 0;
+	int enc_cnt = 0;
+
+	list_for_each_entry(ctx, &rdev->instances, list) {
+		if (ctx) {
+			struct rtk_q_data *q_data_src;
+
+			q_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+			if (ctx->inst_type == RTK_JCODEC_CTX_DECODER) {
+				dec_cnt++;
+				len += scnprintf(buf + len, PAGE_SIZE - len,
+					"Dec instance %d: Codec MJPEG, Resolution %dx%d\n", dec_cnt,
+					q_data_src->width, q_data_src->height);
+			} else {
+				enc_cnt++;
+			}
+		}
+	}
+
+	len += scnprintf(buf + len, PAGE_SIZE - len,
+		"Dec total instance(MJPEG) %d\n", dec_cnt);
+	len += scnprintf(buf + len, PAGE_SIZE - len,
+		"Enc total instance(MJPEG) %d\n", enc_cnt);
+
+	return len;
+}
+
+void rtk_jcodec_write(struct rtk_jcodec_dev *dev, u32 data, u32 reg)
+{
+	writel(data, dev->regs_base + reg);
+}
+
+unsigned int rtk_jcodec_read(struct rtk_jcodec_dev *dev, u32 reg)
+{
+	u32 data;
+
+	data = readl(dev->regs_base + reg);
+
+	return data;
+}
+
+int rtk_jcodec_check_firmware(struct rtk_jcodec_dev *dev)
+{
+	int ret;
+
+	ret = clk_prepare_enable(dev->clk);
+	if (ret)
+		goto err_clk_per;
+	clk_disable_unprepare(dev->clk);
+
+	return 0;
+err_clk_per:
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int rtk_jcodec_clk_enable(struct clk *clk)
+{
+	if (!(clk == NULL || IS_ERR(clk))) {
+		return clk_prepare_enable(clk);
+	}
+	return 0;
+}
+
+static void rtk_jcodec_clk_disable(struct clk *clk)
+{
+	if (!(clk == NULL || IS_ERR(clk))) {
+		clk_disable_unprepare(clk);
+	}
+}
+#endif
+
+/**
+ * RTK jcodec hw operations
+ */
+
+int rtk_jcodec_sw_reset(struct rtk_jcodec_dev *dev)
+{
+	u32 streamBufStartAddr;
+	u32 streamBufEndAddr;
+	u32 streamWrPtr;
+	u32 streamRdPtr;
+	u32 val;
+	int ret = 0;
+
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_BBC_BAS_ADDR);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_BBC_END_ADDR);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_BBC_RD_PTR);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_BBC_WR_PTR);
+
+	streamBufStartAddr = rtk_jcodec_read(dev, RTK_REG_JPEG_BBC_BAS_ADDR);
+	streamBufEndAddr = rtk_jcodec_read(dev, RTK_REG_JPEG_BBC_END_ADDR);
+	streamRdPtr = rtk_jcodec_read(dev, RTK_REG_JPEG_BBC_RD_PTR);
+	streamWrPtr = rtk_jcodec_read(dev, RTK_REG_JPEG_BBC_WR_PTR);
+
+	rtk_jcodec_write(dev, (1 << JPG_START_INIT), RTK_REG_JPEG_PIC_START);
+
+	do {
+		val = rtk_jcodec_read(dev, RTK_REG_JPEG_PIC_START);
+	} while ((val & (1 << JPG_START_INIT)) == (1 << JPG_START_INIT));
+
+	rtk_jcodec_write(dev, streamBufStartAddr, RTK_REG_JPEG_BBC_BAS_ADDR);
+	rtk_jcodec_write(dev, streamBufEndAddr, RTK_REG_JPEG_BBC_END_ADDR);
+	rtk_jcodec_write(dev, streamRdPtr, RTK_REG_JPEG_BBC_RD_PTR);
+	rtk_jcodec_write(dev, streamWrPtr, RTK_REG_JPEG_BBC_WR_PTR);
+
+	return ret;
+}
+
+int rtk_jcodec_hw_reset(struct rtk_jcodec_dev *dev)
+{
+	int ret = 0;
+	unsigned int val;
+
+	lockdep_assert_held(&dev->rtk_mutex);
+
+	if (!dev->rstc) {
+		return -ENOENT;
+	}
+
+	rtk_jcodec_clk_disable(dev->clk);
+
+	reset_control_reset(dev->rstc);
+
+	rtk_jcodec_clk_enable(dev->clk);
+
+	val = rtk_jcodec_read(dev, RTK_REG_JPEG_DBUS);
+	val |= (dbus_en << 0);
+	val &= ~(1 << 1); //Disable idle gating, fix it later.
+	rtk_jcodec_write(dev, val, RTK_REG_JPEG_DBUS);
+
+	return ret;
+}
+
+static int rtk_jcodec_hw_init(struct rtk_jcodec_dev *dev)
+{
+	unsigned int val;
+	int ret;
+
+	ret = clk_prepare_enable(dev->clk);
+	if (ret) {
+		goto err_clk_jpeg;
+	}
+
+	reset_control_reset(dev->rstc);
+
+	val = rtk_jcodec_read(dev, RTK_REG_JPEG_DBUS);
+	val |= (dbus_en << 0);
+	val &= ~(1 << 1); //Disable idle gating, fix it later.
+	rtk_jcodec_write(dev, val, RTK_REG_JPEG_DBUS);
+
+	rtk_jcodec_sw_reset(dev);
+
+	clk_disable_unprepare(dev->clk);
+
+	return 0;
+
+err_clk_jpeg:
+	return ret;
+}
+
+static void rtk_get_max_dimensions(struct rtk_jcodec_dev *dev,
+				   const struct rtk_codec *codec, int *max_w,
+				   int *max_h)
+{
+	const struct rtk_codec *codecs = dev->devinfo->codecs;
+	int num_codecs = dev->devinfo->num_codecs;
+	unsigned int w, h;
+	int k;
+
+	if (codec) {
+		w = codec->max_w;
+		h = codec->max_h;
+	} else {
+		for (k = 0, w = 0, h = 0; k < num_codecs; k++) {
+			w = max(w, codecs[k].max_w);
+			h = max(h, codecs[k].max_h);
+		}
+	}
+
+	if (max_w)
+		*max_w = w;
+	if (max_h)
+		*max_h = h;
+}
+
+static const struct rtk_video_device *
+to_rtk_video_device(struct video_device *vdev)
+{
+	struct rtk_jcodec_dev *dev = video_get_drvdata(vdev);
+	unsigned int i = vdev - dev->vfd;
+
+	if (i >= dev->devinfo->num_vdevs)
+		return NULL;
+
+	return dev->devinfo->vdevs[i];
+}
+
+/**
+ * RTK jcodec common operations
+ */
+
+const char *rtk_jcodec_product_name(int product)
+{
+	static char buf[9];
+
+	switch (product) {
+	case CODA_J10:
+		return "CODA_J10";
+	default:
+		snprintf(buf, sizeof(buf), "(0x%04x)", product);
+		return buf;
+	}
+}
+
+static const struct rtk_codec *rtk_jcodec_find_codec(struct rtk_jcodec_dev *dev,
+						     int src_fourcc,
+						     int dst_fourcc)
+{
+	const struct rtk_codec *codecs = dev->devinfo->codecs;
+	int num_codecs = dev->devinfo->num_codecs;
+	int k;
+
+	if (src_fourcc == dst_fourcc)
+		return NULL;
+
+	for (k = 0; k < num_codecs; k++) {
+		if (codecs[k].src_fourcc == src_fourcc &&
+		    codecs[k].dst_fourcc == dst_fourcc)
+			break;
+	}
+
+	if (k == num_codecs)
+		return NULL;
+
+	return &codecs[k];
+}
+
+static void rtk_jcodec_set_default_params(struct rtk_jcodec_ctx *ctx)
+{
+	unsigned int max_w, max_h;
+	int i;
+
+	ctx->codec = rtk_jcodec_find_codec(ctx->dev, ctx->cvd->src_formats[0],
+					   ctx->cvd->dst_formats[0]);
+
+	max_w = min(ctx->codec->max_w, (unsigned int)MAX_4K_WIDTH);
+	max_h = min(ctx->codec->max_h, (unsigned int)MAX_4K_HEIGHT);
+
+	ctx->params.codec_mode = ctx->codec->mode;
+	ctx->params.packedFormat = 0;
+	ctx->params.frameEndian = JPU_FRAME_ENDIAN;
+	ctx->params.streamEndian = JPU_STREAM_ENDIAN;
+	ctx->params.stuffByteEnable = 0;
+	ctx->params.is_firt_frame = 0;
+	ctx->params.rgb = 0;
+
+	if (ctx->cvd->src_formats[0] == V4L2_PIX_FMT_JPEG ||
+	    ctx->cvd->dst_formats[0] ==
+		    V4L2_PIX_FMT_JPEG) { //jpeg deocder or jpeg encoder
+		ctx->colorspace = V4L2_COLORSPACE_JPEG;
+		ctx->xfer_func = V4L2_XFER_FUNC_SRGB;
+		ctx->ycbcr_enc = V4L2_YCBCR_ENC_601;
+		ctx->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	} else {
+		ctx->colorspace = V4L2_COLORSPACE_REC709;
+		ctx->xfer_func = V4L2_XFER_FUNC_DEFAULT;
+		ctx->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+		ctx->quantization = V4L2_QUANTIZATION_DEFAULT;
+	}
+
+	ctx->params.framerate = 30;
+	/* Default formats for output and input queues */
+	ctx->q_data[V4L2_M2M_SRC_Q_DATA].fourcc = ctx->cvd->src_formats[0];
+	ctx->q_data[V4L2_M2M_SRC_Q_DATA].width = max_w;
+	ctx->q_data[V4L2_M2M_SRC_Q_DATA].height = max_h;
+	if (ctx->codec->src_fourcc != V4L2_PIX_FMT_JPEG) { // encoder
+		ctx->q_data[V4L2_M2M_SRC_Q_DATA].bytesperline = max_w * 3;
+		ctx->q_data[V4L2_M2M_SRC_Q_DATA].sizeimage =
+			ctx->q_data[V4L2_M2M_SRC_Q_DATA].bytesperline * max_h *
+			3;
+	} else { // decoder
+		ctx->q_data[V4L2_M2M_SRC_Q_DATA].bytesperline = 0;
+		ctx->q_data[V4L2_M2M_SRC_Q_DATA].sizeimage = 0x700000;
+		//ctx->q_data[V4L2_M2M_SRC_Q_DATA].sizeimage =coda_estimate_sizeimage(ctx, usize, max_w, max_h);
+	}
+	ctx->q_data[V4L2_M2M_SRC_Q_DATA].rect.width = max_w;
+	ctx->q_data[V4L2_M2M_SRC_Q_DATA].rect.height = max_h;
+
+	ctx->q_data[V4L2_M2M_DST_Q_DATA].fourcc = ctx->cvd->dst_formats[0];
+	ctx->q_data[V4L2_M2M_DST_Q_DATA].width = max_w;
+	ctx->q_data[V4L2_M2M_DST_Q_DATA].height = max_h;
+	if (ctx->codec->src_fourcc != V4L2_PIX_FMT_JPEG) { // encoder
+		ctx->q_data[V4L2_M2M_DST_Q_DATA].bytesperline = 0;
+		ctx->q_data[V4L2_M2M_DST_Q_DATA].sizeimage = 0x700000;
+		//ctx->q_data[V4L2_M2M_DST_Q_DATA].sizeimage =coda_estimate_sizeimage(ctx, usize, max_w, max_h);
+	} else { // decoder
+		ctx->q_data[V4L2_M2M_DST_Q_DATA].bytesperline = max_w * 3;
+		ctx->q_data[V4L2_M2M_DST_Q_DATA].sizeimage =
+			ctx->q_data[V4L2_M2M_DST_Q_DATA].bytesperline * max_h *
+			3;
+	}
+	ctx->q_data[V4L2_M2M_DST_Q_DATA].rect.width = max_w;
+	ctx->q_data[V4L2_M2M_DST_Q_DATA].rect.height = max_h;
+
+	/*
+	 * Since the RBC2AXI logic only supports a single chroma plane,
+	 * macroblock tiling only works for to NV12 pixel format.
+	 */
+	ctx->tiled_map_type = RTK_LINEAR_FRAME_MAP;
+
+	rtk_jcodec_dbg(2, ctx, "set default params :\n");
+	rtk_jcodec_dbg(2, ctx, "codec_mode : %d\n", ctx->params.codec_mode);
+	for (i = 0; i < 2; i++) {
+		rtk_jcodec_dbg(2, ctx, "q_data[%d].fourcc : 0x%x\n", i,
+			       ctx->q_data[i].fourcc);
+		rtk_jcodec_dbg(2, ctx,
+			       "q_data[%d].width : %d,"
+			       " q_data[%d].height : %d\n",
+			       i, ctx->q_data[i].width, i,
+			       ctx->q_data[i].height);
+		rtk_jcodec_dbg(2, ctx,
+			       "q_data[%d].bytesperline :"
+			       " %d, q_data[%d].sizeimage : %d\n",
+			       i, ctx->q_data[i].bytesperline, i,
+			       ctx->q_data[i].sizeimage);
+		rtk_jcodec_dbg(2, ctx,
+			       "q_data[%d].rect.width :"
+			       " %d, q_data[%d].rect.height : %d\n",
+			       i, ctx->q_data[i].rect.width, i,
+			       ctx->q_data[i].rect.height);
+	}
+}
+
+/*
+ * RTK jcodec v4l2 ioctl operations
+ */
+
+static int rtk_jcodec_querycap(struct file *file, void *priv,
+			       struct v4l2_capability *cap)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(priv);
+
+	strscpy(cap->driver, RTK_JCODEC_NAME, sizeof(cap->driver));
+	strscpy(cap->card, rtk_jcodec_product_name(ctx->dev->devinfo->product),
+		sizeof(cap->card));
+	strscpy(cap->bus_info, "platform:" RTK_JCODEC_NAME,
+		sizeof(cap->bus_info));
+
+	cap->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+
+	return 0;
+}
+
+static int rtk_jcodec_enum_fmt(struct file *file, void *priv,
+			       struct v4l2_fmtdesc *f)
+{
+	struct video_device *vdev = video_devdata(file);
+	const struct rtk_video_device *cvd = to_rtk_video_device(vdev);
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(priv);
+	const u32 *formats;
+
+	if (V4L2_TYPE_IS_OUTPUT(f->type)) {
+		formats = cvd->src_formats;
+	} else if (V4L2_TYPE_IS_CAPTURE(f->type)) {
+		formats = cvd->dst_formats;
+	} else {
+		return -EINVAL;
+	}
+
+	if (f->index >= RTK_JCODEC_MAX_FORMATS || formats[f->index] == 0) {
+		return -EINVAL;
+	}
+
+	f->pixelformat = formats[f->index];
+
+	rtk_jcodec_dbg(2, ctx, "%d.%s.(%s) enum format: \n", __LINE__, __func__,
+		       v4l2_type_names[f->type]);
+	rtk_jcodec_dbg(2, ctx, "%d.%s.     formats[%d] : 0x%x\n", __LINE__,
+		       __func__, f->index, formats[f->index]);
+
+	return 0;
+}
+
+static int rtk_jcodec_g_fmt(struct file *file, void *priv,
+			    struct v4l2_format *f)
+{
+	struct rtk_q_data *q_data;
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(priv);
+
+	q_data = rtk_get_q_data(ctx, f->type);
+	if (!q_data) {
+		return -EINVAL;
+	}
+
+	f->fmt.pix_mp.field = V4L2_FIELD_NONE;
+
+#ifdef RTK_INTERLACED
+	if (q_data->fourcc == V4L2_PIX_FMT_JPEG)
+		f->fmt.pix_mp.field = V4L2_FIELD_INTERLACED;
+#endif
+
+	f->fmt.pix_mp.pixelformat = q_data->fourcc;
+	f->fmt.pix_mp.width = q_data->width;
+	f->fmt.pix_mp.height = q_data->height;
+	f->fmt.pix_mp.plane_fmt[0].bytesperline = q_data->bytesperline;
+
+	f->fmt.pix_mp.plane_fmt[0].sizeimage = q_data->sizeimage;
+	f->fmt.pix_mp.colorspace = ctx->colorspace;
+	f->fmt.pix_mp.xfer_func = ctx->xfer_func;
+	f->fmt.pix_mp.ycbcr_enc = ctx->ycbcr_enc;
+	f->fmt.pix_mp.quantization = ctx->quantization;
+	f->fmt.pix_mp.num_planes = 1;
+
+	rtk_jcodec_dbg(2, ctx, "(%s) get format: \n", v4l2_type_names[f->type]);
+	rtk_jcodec_dbg(2, ctx, "     pixelformat  : %4.4s, field : %d\n",
+		       (char *)&f->fmt.pix_mp.pixelformat, f->fmt.pix_mp.field);
+	rtk_jcodec_dbg(2, ctx, "     widthxheight : (%dx%d)\n",
+		       f->fmt.pix_mp.width, f->fmt.pix_mp.height);
+	rtk_jcodec_dbg(2, ctx, "     bytesperline : %d\n",
+		       f->fmt.pix_mp.plane_fmt[0].bytesperline);
+	rtk_jcodec_dbg(2, ctx, "     sizeimage    : %d\n",
+		       f->fmt.pix_mp.plane_fmt[0].sizeimage);
+
+	return 0;
+}
+
+static int rtk_try_pixelformat(struct rtk_jcodec_ctx *ctx,
+			       struct v4l2_format *f)
+{
+	struct rtk_q_data *q_data;
+	const u32 *formats;
+	int i;
+
+	if (V4L2_TYPE_IS_OUTPUT(f->type))
+		formats = ctx->cvd->src_formats;
+	else if (V4L2_TYPE_IS_CAPTURE(f->type))
+		formats = ctx->cvd->dst_formats;
+	else
+		return -EINVAL;
+
+	for (i = 0; i < RTK_JCODEC_MAX_FORMATS; i++) {
+		if (formats[i] == f->fmt.pix_mp.pixelformat) {
+			f->fmt.pix_mp.pixelformat = formats[i];
+			return 0;
+		}
+	}
+
+	/* Fall back to currently set pixelformat */
+	q_data = rtk_get_q_data(ctx, f->type);
+	f->fmt.pix_mp.pixelformat = q_data->fourcc;
+
+	return 0;
+}
+#if 0
+static unsigned int rtk_estimate_sizeimage(struct rtk_jcodec_ctx *ctx,
+					   u32 sizeimage, u32 width, u32 height)
+{
+	/*
+	 * This is a rough estimate for sensible compressed buffer
+	 * sizes (between 1 and 16 bits per pixel). This could be
+	 * improved by better format specific worst case estimates.
+	 */
+	return round_up(clamp(sizeimage, width * height / 8,
+			      width * height * 2),
+			PAGE_SIZE);
+}
+#endif
+static int rtk_try_fmt(struct rtk_jcodec_ctx *ctx,
+		       const struct rtk_codec *codec, struct v4l2_format *f)
+{
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	unsigned int max_w, max_h;
+	enum v4l2_field field;
+
+	field = f->fmt.pix_mp.field;
+
+	if (field == V4L2_FIELD_ANY) { //V4L2_FIELD_ANY=0
+		field = V4L2_FIELD_NONE; //V4L2_FIELD_NONE=1
+	} else if (V4L2_FIELD_NONE != field) {
+		return -EINVAL;
+	}
+
+#ifdef RTK_INTERLACED
+	if (f->fmt.pix_mp.pixelformat == V4L2_PIX_FMT_JPEG)
+		field = V4L2_FIELD_INTERLACED;
+#endif
+
+	/* V4L2 specification suggests the driver corrects the format struct
+	 * if any of the dimensions is unsupported */
+	f->fmt.pix_mp.field = field;
+
+	rtk_get_max_dimensions(dev, codec, &max_w, &max_h);
+	v4l_bound_align_image(&f->fmt.pix_mp.width, MIN_W, max_w, W_ALIGN,
+			      &f->fmt.pix_mp.height, MIN_H, max_h, H_ALIGN,
+			      S_ALIGN);
+
+	switch (f->fmt.pix_mp.pixelformat) {
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_YVU420:
+		/*
+		 * Frame stride must be at least multiple of 8,
+		 * but multiple of 16 for h.264 or JPEG 4:2:x
+		 */
+		f->fmt.pix_mp.plane_fmt[0].bytesperline =
+			round_up(f->fmt.pix_mp.width, 16);
+		f->fmt.pix_mp.plane_fmt[0].sizeimage =
+			f->fmt.pix_mp.plane_fmt[0].bytesperline *
+			f->fmt.pix_mp.height * 3 / 2;
+		break;
+	case V4L2_PIX_FMT_YUYV:
+		f->fmt.pix_mp.plane_fmt[0].bytesperline =
+			round_up(f->fmt.pix_mp.width, 16) * 2;
+		f->fmt.pix_mp.plane_fmt[0].sizeimage =
+			f->fmt.pix_mp.plane_fmt[0].bytesperline *
+			f->fmt.pix_mp.height;
+		break;
+	case V4L2_PIX_FMT_YUV422P:
+	case V4L2_PIX_FMT_NV16:
+		f->fmt.pix_mp.plane_fmt[0].bytesperline =
+			round_up(f->fmt.pix_mp.width, 16);
+		f->fmt.pix_mp.plane_fmt[0].sizeimage =
+			f->fmt.pix_mp.plane_fmt[0].bytesperline *
+			f->fmt.pix_mp.height * 2;
+		break;
+	case V4L2_PIX_FMT_YUV444M:
+	case V4L2_PIX_FMT_NV24:
+		f->fmt.pix_mp.plane_fmt[0].bytesperline =
+			round_up(f->fmt.pix_mp.width, 16);
+		f->fmt.pix_mp.plane_fmt[0].sizeimage =
+			f->fmt.pix_mp.plane_fmt[0].bytesperline *
+			f->fmt.pix_mp.height * 3;
+		break;
+	case V4L2_PIX_FMT_RGB24:
+		f->fmt.pix_mp.plane_fmt[0].bytesperline =
+			round_up(f->fmt.pix_mp.width, 16) * 3;
+		f->fmt.pix_mp.plane_fmt[0].sizeimage =
+			f->fmt.pix_mp.plane_fmt[0].bytesperline *
+			f->fmt.pix_mp.height * 3;
+		break;
+	case V4L2_PIX_FMT_GREY:
+		/* keep 16 pixel alignment of 8-bit pixel data */
+		f->fmt.pix_mp.plane_fmt[0].bytesperline =
+			round_up(f->fmt.pix_mp.width, 16);
+		f->fmt.pix_mp.plane_fmt[0].sizeimage =
+			f->fmt.pix_mp.plane_fmt[0].bytesperline *
+			f->fmt.pix_mp.height;
+		break;
+	case V4L2_PIX_FMT_JPEG:
+		f->fmt.pix_mp.plane_fmt[0].bytesperline = 0;
+		/*f->fmt.pix_mp.plane_fmt[0].sizeimage =
+			rtk_estimate_sizeimage(ctx, f->fmt.pix_mp.plane_fmt[0].sizeimage,
+					       f->fmt.pix_mp.width,
+					       f->fmt.pix_mp.height);*/
+		f->fmt.pix_mp.plane_fmt[0].sizeimage = 0x700000;
+		break;
+	default:
+		BUG();
+	}
+
+	rtk_jcodec_dbg(2, ctx, "(%s) try format: \n", v4l2_type_names[f->type]);
+	rtk_jcodec_dbg(2, ctx, "     pixelformat  : %4.4s, field : %d\n",
+		       (char *)&f->fmt.pix_mp.pixelformat, f->fmt.pix_mp.field);
+	rtk_jcodec_dbg(2, ctx, "     widthxheight : (%dx%d)\n",
+		       f->fmt.pix_mp.width, f->fmt.pix_mp.height);
+	rtk_jcodec_dbg(2, ctx, "     bytesperline : %d\n",
+		       f->fmt.pix_mp.plane_fmt[0].bytesperline);
+	rtk_jcodec_dbg(2, ctx, "     sizeimage    : %d\n",
+		       f->fmt.pix_mp.plane_fmt[0].sizeimage);
+
+	return 0;
+}
+
+static int rtk_jcodec_try_fmt_vid_cap(struct file *file, void *priv,
+				      struct v4l2_format *f)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(priv);
+	const struct rtk_q_data *q_data_src;
+	const struct rtk_codec *codec;
+	struct vb2_queue *src_vq;
+	int hscale = 0;
+	int vscale = 0;
+	int ret;
+
+	rtk_jcodec_dbg(2, ctx, "%s %d.%s.type:%s.4cc:%4.4s.w:%d.h:%d."
+		"bytesperline:%d.sizeimage:%d.colorspace:%d\n",
+		RTK_JCODEC_NAME, __LINE__, __func__, v4l2_type_names[f->type],
+		(char *)&f->fmt.pix_mp.pixelformat, f->fmt.pix_mp.width,
+		f->fmt.pix_mp.height, f->fmt.pix_mp.plane_fmt[0].bytesperline,
+		f->fmt.pix_mp.plane_fmt[0].sizeimage, f->fmt.pix_mp.colorspace);
+
+	ret = rtk_try_pixelformat(ctx, f);
+	if (ret < 0) {
+		v4l2_err(&ctx->dev->v4l2_dev,
+			 "failed to rtk_try_pixelformat\n");
+		return ret;
+	}
+
+	q_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+
+	/*
+	 * If the source format is already fixed, only allow the same output
+	 * resolution. When decoding JPEG images, we also have to make sure to
+	 * use the same chroma subsampling.
+	 */
+	src_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,
+				 V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+	if (vb2_is_streaming(src_vq)) {
+		f->fmt.pix_mp.width = q_data_src->width >> hscale;
+		f->fmt.pix_mp.height = q_data_src->height >> vscale;
+
+		if (q_data_src->fourcc == V4L2_PIX_FMT_JPEG) {
+			if (ctx->params.jpeg_chroma_subsampling ==
+				    V4L2_JPEG_CHROMA_SUBSAMPLING_420 &&
+			    f->fmt.pix_mp.pixelformat == V4L2_PIX_FMT_YUV422P) {
+				f->fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12;
+			} else if (ctx->params.jpeg_chroma_subsampling ==
+				   V4L2_JPEG_CHROMA_SUBSAMPLING_422) {
+				f->fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV16;
+			} else if (ctx->params.jpeg_chroma_subsampling ==
+				   V4L2_JPEG_CHROMA_SUBSAMPLING_444) {
+				f->fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV24;
+			}
+		}
+	}
+
+	f->fmt.pix_mp.colorspace = ctx->colorspace;
+	f->fmt.pix_mp.xfer_func = ctx->xfer_func;
+	f->fmt.pix_mp.ycbcr_enc = ctx->ycbcr_enc;
+	f->fmt.pix_mp.quantization = ctx->quantization;
+	f->fmt.pix_mp.num_planes = 1;
+
+	q_data_src = rtk_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+	codec = rtk_jcodec_find_codec(ctx->dev, q_data_src->fourcc,
+				      f->fmt.pix_mp.pixelformat);
+
+	if (!codec) {
+		rtk_jcodec_dbg(2, ctx, "failed to rtk_jcodec_find_codec\n");
+		return -EINVAL;
+	}
+
+	return rtk_try_fmt(ctx, codec, f);
+}
+
+static int rtk_s_fmt(struct rtk_jcodec_ctx *ctx, struct v4l2_format *f,
+		     struct v4l2_rect *r)
+{
+	struct rtk_q_data *q_data;
+	struct vb2_queue *vq;
+
+	vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);
+	if (!vq)
+		return -EINVAL;
+
+	q_data = rtk_get_q_data(ctx, f->type);
+	if (!q_data)
+		return -EINVAL;
+
+	if (vb2_is_busy(vq)) {
+		v4l2_err(&ctx->dev->v4l2_dev, "%s: %s queue busy: %d\n",
+			 __func__, v4l2_type_names[f->type], vq->num_buffers);
+		return -EBUSY;
+	}
+
+	q_data->fourcc = f->fmt.pix_mp.pixelformat;
+	q_data->ori_width = f->fmt.pix_mp.width;
+	q_data->ori_height = f->fmt.pix_mp.height;
+	q_data->width = f->fmt.pix_mp.width;
+	q_data->height = f->fmt.pix_mp.height;
+	q_data->bytesperline = f->fmt.pix_mp.plane_fmt[0].bytesperline;
+	q_data->sizeimage = f->fmt.pix_mp.plane_fmt[0].sizeimage;
+
+	if (r) {
+		q_data->rect = *r;
+	} else {
+		q_data->rect.left = 0;
+		q_data->rect.top = 0;
+		q_data->rect.width = f->fmt.pix_mp.width;
+		q_data->rect.height = f->fmt.pix_mp.height;
+	}
+
+	switch (f->fmt.pix_mp.pixelformat) {
+	case V4L2_PIX_FMT_YUYV:
+		ctx->tiled_map_type = RTK_TILED_FRAME_MB_RASTER_MAP;
+		break;
+	case V4L2_PIX_FMT_NV12:
+		// TODO: coda upstream
+		// TODO: ray modify
+		// if (!disable_tiling && ctx->use_bit &&
+		//     ctx->dev->devinfo->product == CODA_J10) {
+		// 	ctx->tiled_map_type = RTK_TILED_FRAME_MB_RASTER_MAP;
+		// 	break;
+		// }
+		fallthrough;
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_YVU420:
+	case V4L2_PIX_FMT_YUV422P:
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_YUV444M:
+	case V4L2_PIX_FMT_NV24:
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_GREY:
+		ctx->tiled_map_type = RTK_LINEAR_FRAME_MAP;
+		break;
+	default:
+		break;
+	}
+
+	ctx->use_vdoa = false;
+
+	rtk_jcodec_dbg(2, ctx, "(%s) set format: \n", v4l2_type_names[f->type]);
+	rtk_jcodec_dbg(2, ctx, "     pixelformat  : %4.4s, field : %d\n",
+		       (char *)&f->fmt.pix_mp.pixelformat, f->fmt.pix_mp.field);
+	rtk_jcodec_dbg(2, ctx, "     widthxheight : (%dx%d)\n",
+		       f->fmt.pix_mp.width, f->fmt.pix_mp.height);
+	rtk_jcodec_dbg(2, ctx, "     bytesperline : %d\n",
+		       f->fmt.pix_mp.plane_fmt[0].bytesperline);
+	rtk_jcodec_dbg(2, ctx, "     sizeimage    : %d\n",
+		       f->fmt.pix_mp.plane_fmt[0].sizeimage);
+
+	rtk_jcodec_dbg(2, ctx, "(%s) set qdata: \n", v4l2_type_names[f->type]);
+	rtk_jcodec_dbg(2, ctx, "     fourcc       : %4.4s\n",
+		       (char *)&q_data->fourcc);
+	rtk_jcodec_dbg(2, ctx, "     widthxheight : (%dx%d)\n", q_data->width,
+		       q_data->height);
+	rtk_jcodec_dbg(2, ctx, "     bytesperline : %d\n",
+		       q_data->bytesperline);
+	rtk_jcodec_dbg(2, ctx, "     sizeimage    : %d\n", q_data->sizeimage);
+	rtk_jcodec_dbg(2, ctx, "     rect leftxtop     : (%dx%d)\n",
+		       q_data->rect.left, q_data->rect.top);
+	rtk_jcodec_dbg(2, ctx, "     rect widthxheight : (%dx%d)\n",
+		       q_data->rect.width, q_data->rect.height);
+	rtk_jcodec_dbg(2, ctx, "     ori  widthxheight : (%dx%d)\n",
+		       q_data->ori_width, q_data->ori_height);
+
+	rtk_jcodec_dbg(1, ctx,
+		       "Setting %s format, wxh: %dx%d, fmt: %4.4s"
+		       " sizeimage : %d %c\n",
+		       v4l2_type_names[f->type], q_data->width, q_data->height,
+		       (char *)&q_data->fourcc, q_data->sizeimage,
+		       (ctx->tiled_map_type == RTK_LINEAR_FRAME_MAP) ? 'L' :
+								       'T');
+
+	return 0;
+}
+
+static int rtk_jcodec_s_fmt_vid_cap(struct file *file, void *priv,
+				    struct v4l2_format *f)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(priv);
+	struct rtk_q_data *q_data_src;
+	const struct rtk_codec *codec;
+	struct v4l2_rect r;
+	int ret;
+
+	pr_info("%s %d.%s.type:%s.4cc:%4.4s.w:%d.h:%d."
+		"bytesperline:%d.sizeimage:%d.colorspace:%d\n",
+		RTK_JCODEC_NAME, __LINE__, __func__, v4l2_type_names[f->type],
+		(char *)&f->fmt.pix_mp.pixelformat, f->fmt.pix_mp.width,
+		f->fmt.pix_mp.height, f->fmt.pix_mp.plane_fmt[0].bytesperline,
+		f->fmt.pix_mp.plane_fmt[0].sizeimage, f->fmt.pix_mp.colorspace);
+
+	ret = rtk_jcodec_try_fmt_vid_cap(file, priv, f);
+	if (ret) {
+		v4l2_err(&ctx->dev->v4l2_dev,
+			 "failed to rtk_jcodec_try_fmt_vid_cap\n");
+		return ret;
+	}
+
+	q_data_src = rtk_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+	r.left = 0;
+	r.top = 0;
+	r.width = q_data_src->width;
+	r.height = q_data_src->height;
+
+	ret = rtk_s_fmt(ctx, f, &r);
+	if (ret) {
+		v4l2_err(&ctx->dev->v4l2_dev, "failed to rtk_s_fmt\n");
+		return ret;
+	}
+
+	if (ctx->inst_type != RTK_JCODEC_CTX_ENCODER)
+		return 0;
+
+	/* Setting the coded format determines the selected codec */
+	codec = rtk_jcodec_find_codec(ctx->dev, q_data_src->fourcc,
+				      f->fmt.pix_mp.pixelformat);
+	if (!codec) {
+		rtk_jcodec_dbg(2, ctx, "%d.%s.failed to determine codec\n",
+			       __LINE__, __func__);
+		return -EINVAL;
+	}
+	ctx->codec = codec;
+
+	ctx->colorspace = f->fmt.pix_mp.colorspace;
+	ctx->xfer_func = f->fmt.pix_mp.xfer_func;
+	ctx->ycbcr_enc = f->fmt.pix_mp.ycbcr_enc;
+	ctx->quantization = f->fmt.pix_mp.quantization;
+
+	return 0;
+}
+
+static void rtk_set_default_colorspace(struct v4l2_pix_format *fmt)
+{
+	enum v4l2_colorspace colorspace;
+
+	if (fmt->pixelformat == V4L2_PIX_FMT_JPEG)
+		colorspace = V4L2_COLORSPACE_JPEG;
+	else if (fmt->width <= 720 && fmt->height <= 576)
+		colorspace = V4L2_COLORSPACE_SMPTE170M;
+	else
+		colorspace = V4L2_COLORSPACE_REC709;
+
+	fmt->colorspace = colorspace;
+	fmt->xfer_func = V4L2_XFER_FUNC_DEFAULT;
+	fmt->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	fmt->quantization = V4L2_QUANTIZATION_DEFAULT;
+}
+
+static int rtk_jcodec_try_fmt_vid_out(struct file *file, void *priv,
+				      struct v4l2_format *f)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(priv);
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	const struct rtk_q_data *q_data_dst;
+	const struct rtk_codec *codec;
+	int ret;
+
+	rtk_jcodec_dbg(2, ctx, "%s %d.%s.type:%s.4cc:%4.4s.w:%d.h:%d."
+		"bytesperline:%d.sizeimage:%d.colorspace:%d\n",
+		RTK_JCODEC_NAME, __LINE__, __func__, v4l2_type_names[f->type],
+		(char *)&f->fmt.pix_mp.pixelformat, f->fmt.pix_mp.width,
+		f->fmt.pix_mp.height, f->fmt.pix_mp.plane_fmt[0].bytesperline,
+		f->fmt.pix_mp.plane_fmt[0].sizeimage, f->fmt.pix_mp.colorspace);
+
+	ret = rtk_try_pixelformat(ctx, f);
+	if (ret < 0) {
+		v4l2_err(&ctx->dev->v4l2_dev,
+			 "failed to rtk_try_pixelformat\n");
+		return ret;
+	}
+
+	if (f->fmt.pix_mp.colorspace == V4L2_COLORSPACE_DEFAULT) {
+		rtk_set_default_colorspace(&f->fmt.pix);
+	}
+
+	q_data_dst = rtk_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	codec = rtk_jcodec_find_codec(dev, f->fmt.pix_mp.pixelformat,
+				      q_data_dst->fourcc);
+
+	return rtk_try_fmt(ctx, codec, f);
+}
+
+static int rtk_jcodec_s_fmt_vid_out(struct file *file, void *priv,
+				    struct v4l2_format *f)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(priv);
+	const struct rtk_codec *codec;
+	struct v4l2_format f_cap;
+	struct vb2_queue *dst_vq;
+	int ret;
+
+	rtk_jcodec_dbg(2, ctx, "%s %d.%s.type:%s.4cc:%4.4s.w:%d.h:%d."
+		"bytesperline:%d.sizeimage:%d.colorspace:%d\n",
+		RTK_JCODEC_NAME, __LINE__, __func__, v4l2_type_names[f->type],
+		(char *)&f->fmt.pix_mp.pixelformat, f->fmt.pix_mp.width,
+		f->fmt.pix_mp.height, f->fmt.pix_mp.plane_fmt[0].bytesperline,
+		f->fmt.pix_mp.plane_fmt[0].sizeimage, f->fmt.pix_mp.colorspace);
+
+	ret = rtk_jcodec_try_fmt_vid_out(file, priv, f);
+	if (ret) {
+		v4l2_err(&ctx->dev->v4l2_dev,
+			 "failed to rtk_jcodec_try_fmt_vid_out\n");
+		return ret;
+	}
+
+	ret = rtk_s_fmt(ctx, f, NULL);
+	if (ret) {
+		v4l2_err(&ctx->dev->v4l2_dev, "failed to rtk_s_fmt\n");
+		return ret;
+	}
+
+	ctx->colorspace = f->fmt.pix_mp.colorspace;
+	ctx->xfer_func = f->fmt.pix_mp.xfer_func;
+	ctx->ycbcr_enc = f->fmt.pix_mp.ycbcr_enc;
+	ctx->quantization = f->fmt.pix_mp.quantization;
+
+	// return 0;
+	// TODO: refine later
+	if (ctx->inst_type != RTK_JCODEC_CTX_DECODER)
+		return 0;
+
+	/* Setting the coded format determines the selected codec */
+	codec = rtk_jcodec_find_codec(ctx->dev, f->fmt.pix_mp.pixelformat,
+				      V4L2_PIX_FMT_NV12);
+	if (!codec) {
+		rtk_jcodec_dbg(2, ctx, "%d.%s.failed to determine codec\n",
+			       __LINE__, __func__);
+		return -EINVAL;
+	}
+	ctx->codec = codec;
+
+	dst_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,
+				 V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	if (!dst_vq)
+		return -EINVAL;
+
+	if (vb2_is_busy(dst_vq))
+		return 0;
+
+	memset(&f_cap, 0, sizeof(f_cap));
+	f_cap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	rtk_jcodec_g_fmt(file, priv, &f_cap);
+	f_cap.fmt.pix_mp.width = f->fmt.pix_mp.width;
+	f_cap.fmt.pix_mp.height = f->fmt.pix_mp.height;
+
+	return rtk_jcodec_s_fmt_vid_cap(file, priv, &f_cap);
+}
+
+static int rtk_jcodec_reqbufs(struct file *file, void *priv,
+			      struct v4l2_requestbuffers *rb)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(priv);
+	int ret;
+
+	ret = v4l2_m2m_reqbufs(file, ctx->fh.m2m_ctx, rb);
+	if (ret)
+		return ret;
+
+	rtk_jcodec_dbg(2, ctx, "%d.%s.(%s) req %d bufs\n", __LINE__, __func__,
+		       v4l2_type_names[rb->type], rb->count);
+
+	/*
+	 * Allow to allocate instance specific per-context buffers, such as
+	 * bitstream ringbuffer, slice buffer, work buffer, etc. if needed.
+	 */
+
+	if (ctx->ops->reqbufs) {
+		return ctx->ops->reqbufs(ctx, rb);
+	}
+
+	return 0;
+}
+
+static int rtk_jcodec_qbuf(struct file *file, void *priv,
+			   struct v4l2_buffer *buf)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(priv);
+	if (ctx->inst_type == RTK_JCODEC_CTX_DECODER &&
+	    V4L2_TYPE_IS_OUTPUT(buf->type)) {
+		buf->flags &= ~V4L2_BUF_FLAG_LAST;
+	}
+
+	rtk_jcodec_dbg(2, ctx, "%d.%s.(%s) queue buf %d\n", __LINE__, __func__,
+		       v4l2_type_names[buf->type], buf->index);
+
+	return v4l2_m2m_qbuf(file, ctx->fh.m2m_ctx, buf);
+}
+
+static int rtk_jcodec_dqbuf(struct file *file, void *priv,
+			    struct v4l2_buffer *buf)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(priv);
+	int ret;
+	// static int fake_buf_last = 0;
+
+	ret = v4l2_m2m_dqbuf(file, ctx->fh.m2m_ctx, buf);
+
+	if (ctx->inst_type == RTK_JCODEC_CTX_DECODER &&
+	    V4L2_TYPE_IS_OUTPUT(buf->type)) {
+		buf->flags &= ~V4L2_BUF_FLAG_LAST;
+	}
+
+	rtk_jcodec_dbg(2, ctx, "(%s) dequeue buf %d%s\n",
+		       v4l2_type_names[buf->type], buf->index,
+		       (buf->flags & V4L2_BUF_FLAG_LAST) ? " (last)" : "");
+
+	return ret;
+}
+
+static int rtk_jcodec_g_selection(struct file *file, void *fh,
+				  struct v4l2_selection *s)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(fh);
+	struct rtk_q_data *q_data;
+	struct v4l2_rect r, *rsel;
+
+	//rtk_jcodec_dbg(2, ctx, "(%s) get selection, target : 0x%x\n",
+	//		 s->type, s->target);
+
+	q_data = rtk_get_q_data(ctx, s->type);
+	if (!q_data) {
+		return -EINVAL;
+	}
+
+	r.left = 0;
+	r.top = 0;
+	r.width = q_data->width;
+	r.height = q_data->height;
+	rsel = &q_data->rect;
+
+	rtk_jcodec_dbg(2, ctx, "rect x-y(%dx%d), rect w-h(%dx%d)\n", r.left,
+		       r.top, r.width, r.height);
+
+	rtk_jcodec_dbg(2, ctx, "rsel x-y(%dx%d), rsel w-h(%dx%d)\n", rsel->left,
+		       rsel->top, rsel->width, rsel->height);
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		rsel = &r;
+		fallthrough;
+	case V4L2_SEL_TGT_CROP:
+		if (!V4L2_TYPE_IS_OUTPUT(s->type) ||
+		    ctx->inst_type == RTK_JCODEC_CTX_DECODER) {
+			return -EINVAL;
+		}
+		break;
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+	case V4L2_SEL_TGT_COMPOSE_PADDED:
+		rsel = &r;
+		fallthrough;
+	case V4L2_SEL_TGT_COMPOSE:
+	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
+		if (!V4L2_TYPE_IS_CAPTURE(s->type) ||
+		    ctx->inst_type == RTK_JCODEC_CTX_ENCODER) {
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	s->r = *rsel;
+
+	return 0;
+}
+
+static int rtk_jcodec_s_selection(struct file *file, void *fh,
+				  struct v4l2_selection *s)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(fh);
+	struct rtk_q_data *q_data;
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		if (ctx->inst_type == RTK_JCODEC_CTX_ENCODER &&
+		    V4L2_TYPE_IS_OUTPUT(s->type)) {
+			q_data = get_q_data(ctx, s->type);
+			if (!q_data)
+				return -EINVAL;
+
+			s->r.left = 0;
+			s->r.top = 0;
+			s->r.width = clamp(s->r.width, 2U, q_data->width);
+			s->r.height = clamp(s->r.height, 2U, q_data->height);
+
+			if (s->flags & V4L2_SEL_FLAG_LE) {
+				s->r.width = round_up(s->r.width, 2);
+				s->r.height = round_up(s->r.height, 2);
+			} else {
+				s->r.width = round_down(s->r.width, 2);
+				s->r.height = round_down(s->r.height, 2);
+			}
+
+			q_data->rect = s->r;
+
+			rtk_jcodec_dbg(1, ctx,
+				       "Setting crop rectangle: %dx%d\n",
+				       s->r.width, s->r.height);
+
+			return 0;
+		}
+		fallthrough;
+	case V4L2_SEL_TGT_NATIVE_SIZE:
+	case V4L2_SEL_TGT_COMPOSE:
+		return rtk_jcodec_g_selection(file, fh, s);
+	default:
+		/* v4l2-compliance expects this to fail for read-only targets */
+		return -EINVAL;
+	}
+}
+
+static void rtk_jcodec_wake_up_capture_queue(struct rtk_jcodec_ctx *ctx)
+{
+	struct vb2_queue *dst_vq;
+
+	rtk_jcodec_dbg(1, ctx, "waking up capture queue\n");
+
+	dst_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,
+				 V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	dst_vq->last_buffer_dequeued = true;
+	wake_up(&dst_vq->done_wq);
+}
+
+static int rtk_jcodec_try_encoder_cmd(struct file *file, void *fh,
+				      struct v4l2_encoder_cmd *dc)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(fh);
+
+	if (ctx->inst_type != RTK_JCODEC_CTX_ENCODER)
+		return -ENOTTY;
+
+	return v4l2_m2m_ioctl_try_encoder_cmd(file, fh, dc);
+}
+
+static int rtk_jcodec_try_decoder_cmd(struct file *file, void *fh,
+				      struct v4l2_decoder_cmd *dc)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(fh);
+
+	if (ctx->inst_type != RTK_JCODEC_CTX_DECODER)
+		return -ENOTTY;
+
+	return v4l2_m2m_ioctl_try_decoder_cmd(file, fh, dc);
+}
+
+static bool rtk_jcodec_mark_last_meta(struct rtk_jcodec_ctx *ctx)
+{
+	struct rtk_meta_buffer *meta;
+
+	spin_lock(&ctx->meta_buffer_lock);
+	if (list_empty(&ctx->meta_buffer_list)) {
+		spin_unlock(&ctx->meta_buffer_lock);
+		rtk_jcodec_dbg(1, ctx, "meta buffer list empty\n");
+		return false;
+	}
+
+	meta = list_last_entry(&ctx->meta_buffer_list, struct rtk_meta_buffer,
+			       list);
+	meta->last = true;
+
+	rtk_jcodec_dbg(1, ctx, "marking last meta %d\n", meta->sequence);
+
+	spin_unlock(&ctx->meta_buffer_lock);
+	return true;
+}
+
+static bool rtk_jcodec_mark_last_dst_buf(struct rtk_jcodec_ctx *ctx)
+{
+	struct vb2_v4l2_buffer *buf;
+	struct vb2_buffer *dst_vb;
+	struct vb2_queue *dst_vq;
+	unsigned long flags;
+
+	rtk_jcodec_dbg(1, ctx, "marking last capture buffer\n");
+
+	dst_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,
+				 V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	spin_lock_irqsave(&dst_vq->done_lock, flags);
+	if (list_empty(&dst_vq->done_list)) {
+		spin_unlock_irqrestore(&dst_vq->done_lock, flags);
+		rtk_jcodec_dbg(1, ctx, "capture buffer done list empty\n");
+		return false;
+	}
+
+	dst_vb = list_last_entry(&dst_vq->done_list, struct vb2_buffer,
+				 done_entry);
+	buf = to_vb2_v4l2_buffer(dst_vb);
+	buf->flags |= V4L2_BUF_FLAG_LAST;
+
+	spin_unlock_irqrestore(&dst_vq->done_lock, flags);
+	return true;
+}
+
+static void rtk_wake_up_capture_queue(struct rtk_jcodec_ctx *ctx)
+{
+	struct vb2_queue *dst_vq;
+
+	rtk_jcodec_dbg(1, ctx, "waking up capture queue\n");
+
+	dst_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,
+				 V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	dst_vq->last_buffer_dequeued = true;
+	wake_up(&dst_vq->done_wq);
+}
+
+static int rtk_jcodec_encoder_cmd(struct file *file, void *fh,
+				  struct v4l2_encoder_cmd *ec)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(fh);
+	struct vb2_v4l2_buffer *buf;
+	int ret;
+
+	ret = v4l2_m2m_ioctl_try_encoder_cmd(file, fh, ec);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&ctx->wakeup_mutex);
+	buf = v4l2_m2m_last_src_buf(ctx->fh.m2m_ctx);
+	if (buf) {
+		/*
+		 * If the last output buffer is still on the queue, make sure
+		 * that decoder finish_run will see the last flag and report it
+		 * to userspace.
+		 */
+		buf->flags |= V4L2_BUF_FLAG_LAST;
+	} else {
+		/* Set the stream-end flag on this context */
+		ctx->bit_stream_param |= RTK_BIT_STREAM_END_FLAG;
+
+		/*
+		 * If the last output buffer has already been taken from the
+		 * queue, wake up the capture queue and signal end of stream
+		 * via the -EPIPE mechanism.
+		 */
+		rtk_wake_up_capture_queue(ctx);
+	}
+	mutex_unlock(&ctx->wakeup_mutex);
+
+	return 0;
+}
+
+static int rtk_jcodec_decoder_cmd(struct file *file, void *fh,
+				  struct v4l2_decoder_cmd *dc)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(fh);
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	struct vb2_queue *dst_vq;
+	struct vb2_v4l2_buffer *buf;
+	//struct vb2_queue *dst_vq;
+	bool stream_end;
+	bool wakeup;
+	int ret;
+
+	rtk_jcodec_dbg(2, ctx, "decoder cmd 0x%x: \n", dc->cmd);
+
+	ret = rtk_jcodec_try_decoder_cmd(file, fh, dc);
+	if (ret < 0)
+		return ret;
+
+	switch (dc->cmd) {
+	case V4L2_DEC_CMD_START:
+		mutex_lock(&dev->rtk_mutex);
+		mutex_lock(&ctx->bitstream_mutex);
+		dst_vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx,
+					 V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+		vb2_clear_last_buffer_dequeued(dst_vq);
+		ctx->bit_stream_param &= ~RTK_BIT_STREAM_END_FLAG;
+		rtk_feed_bitstream(ctx, NULL);
+		mutex_unlock(&ctx->bitstream_mutex);
+		mutex_unlock(&dev->rtk_mutex);
+		break;
+	case V4L2_DEC_CMD_STOP:
+		stream_end = false;
+		wakeup = false;
+
+		mutex_lock(&ctx->wakeup_mutex);
+
+		buf = v4l2_m2m_last_src_buf(ctx->fh.m2m_ctx);
+		if (buf) {
+			rtk_jcodec_dbg(1, ctx,
+				       "marking last pending buffer"
+				       " %d\n",
+				       buf->vb2_buf.index);
+
+			/* Mark last buffer */
+			buf->flags |= V4L2_BUF_FLAG_LAST;
+
+			if (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) == 0) {
+				rtk_jcodec_dbg(1, ctx,
+					       "all remaining"
+					       " buffers queued\n");
+				stream_end = true;
+			}
+		} else {
+			if (ctx->use_bit) {
+				if (rtk_jcodec_mark_last_meta(ctx)) {
+					stream_end = true;
+				} else {
+					wakeup = true;
+				}
+			} else {
+				if (!rtk_jcodec_mark_last_dst_buf(ctx)) {
+					wakeup = true;
+				}
+			}
+		}
+
+		if (stream_end) {
+			rtk_jcodec_dbg(1, ctx,
+				       "all remaining buffers queued\n");
+			/* Set the stream-end flag on this context */
+			rtk_bitstream_end_flag(ctx);
+			ctx->hold = false;
+			v4l2_m2m_try_schedule(ctx->fh.m2m_ctx);
+		}
+
+		if (wakeup) {
+			/* If there is no buffer in flight, wake up */
+			rtk_jcodec_wake_up_capture_queue(ctx);
+		}
+
+		mutex_unlock(&ctx->wakeup_mutex);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rtk_jcodec_enum_framesizes(struct file *file, void *fh,
+				      struct v4l2_frmsizeenum *fsize)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(fh);
+	struct rtk_q_data *q_data_src;
+	struct rtk_q_data *q_data_dst;
+	const struct rtk_codec *codec = NULL;
+
+	if (fsize->index) {
+		return -EINVAL;
+	}
+
+	if (ctx->cvd->type == RTK_JCODEC_CTX_DECODER) {
+		pr_info("%d.%s.pixel_format:%p4cc\n", __LINE__, __func__,
+			&(fsize->pixel_format));
+
+		if (fsize->pixel_format != V4L2_PIX_FMT_JPEG) {
+			q_data_src = rtk_get_q_data(
+				ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+			codec = rtk_jcodec_find_codec(ctx->dev,
+						      q_data_src->fourcc,
+						      fsize->pixel_format);
+		} else {
+			codec = rtk_jcodec_find_codec(ctx->dev,
+						      fsize->pixel_format,
+						      V4L2_PIX_FMT_NV12);
+		}
+	} else if (ctx->cvd->type == RTK_JCODEC_CTX_ENCODER) {
+		pr_info("%d.%s.pixel_format:%p4cc\n", __LINE__, __func__,
+			&(fsize->pixel_format));
+
+		if (fsize->pixel_format != V4L2_PIX_FMT_JPEG) {
+			q_data_dst = get_q_data(
+				ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+			codec = rtk_jcodec_find_codec(ctx->dev,
+						      fsize->pixel_format,
+						      q_data_dst->fourcc);
+
+		} else {
+			codec = rtk_jcodec_find_codec(ctx->dev,
+						      V4L2_PIX_FMT_NV12,
+						      fsize->pixel_format);
+		}
+	}
+
+	if (!codec) {
+		rtk_jcodec_dbg(2, ctx, "%d.%s.failed to determine codec\n",
+			       __LINE__, __func__);
+		return -ENOTTY;
+	}
+
+	fsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;
+	fsize->stepwise.min_width = MIN_WIDTH;
+	fsize->stepwise.max_width = codec->max_w;
+	fsize->stepwise.step_width = 1;
+	fsize->stepwise.min_height = MIN_HEIGHT;
+	fsize->stepwise.max_height = codec->max_h;
+	fsize->stepwise.step_height = 1;
+
+	rtk_jcodec_dbg(2, ctx, "enum framesizes: \n");
+	rtk_jcodec_dbg(2, ctx, "min_width : %d, max_width : %d\n",
+		       fsize->stepwise.min_width, fsize->stepwise.max_width);
+	rtk_jcodec_dbg(2, ctx, "min_height : %d, max_height : %d\n",
+		       fsize->stepwise.min_height, fsize->stepwise.max_height);
+	rtk_jcodec_dbg(2, ctx, "step_width : %d, step_height : %d\n",
+		       fsize->stepwise.step_width, fsize->stepwise.step_height);
+
+	return 0;
+}
+
+static int rtk_jcodec_enum_frameintervals(struct file *file, void *fh,
+					  struct v4l2_frmivalenum *f)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(fh);
+	struct rtk_q_data *q_data_src;
+	struct rtk_q_data *q_data_dst;
+	const struct rtk_codec *codec = NULL;
+
+	if (f->index)
+		return -EINVAL;
+
+	/* Disallow YUYV if the vdoa is not available */
+	if (/*!ctx->vdoa && */ f->pixel_format == V4L2_PIX_FMT_YUYV)
+		return -EINVAL;
+
+	if (ctx->cvd->type == RTK_JCODEC_CTX_DECODER) {
+		pr_info("%d.%s.pixel_format:%p4cc\n", __LINE__, __func__,
+			&(f->pixel_format));
+
+		if (f->pixel_format != V4L2_PIX_FMT_JPEG) {
+			q_data_src = rtk_get_q_data(
+				ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+			codec = rtk_jcodec_find_codec(
+				ctx->dev, q_data_src->fourcc, f->pixel_format);
+
+		} else {
+			codec = rtk_jcodec_find_codec(ctx->dev, f->pixel_format,
+						      V4L2_PIX_FMT_NV12);
+		}
+
+	} else if (ctx->cvd->type == RTK_JCODEC_CTX_ENCODER) {
+		pr_info("%d.%s.pixel_format:%p4cc\n", __LINE__, __func__,
+			&(f->pixel_format));
+
+		if (f->pixel_format != V4L2_PIX_FMT_JPEG) {
+			q_data_dst = get_q_data(
+				ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+			codec = rtk_jcodec_find_codec(ctx->dev, f->pixel_format,
+						      q_data_dst->fourcc);
+
+		} else {
+			codec = rtk_jcodec_find_codec(
+				ctx->dev, V4L2_PIX_FMT_NV12, f->pixel_format);
+		}
+	}
+
+	if (!codec) {
+		rtk_jcodec_dbg(2, ctx, "%d.%s.failed to determine codec\n",
+			       __LINE__, __func__);
+		return -ENOTTY;
+	}
+
+	if (f->width < MIN_W || f->width > codec->max_w || f->height < MIN_H ||
+	    f->height > codec->max_h)
+		return -EINVAL;
+
+	f->type = V4L2_FRMIVAL_TYPE_CONTINUOUS;
+	f->stepwise.min.numerator = 1;
+	f->stepwise.min.denominator = 65535;
+	f->stepwise.max.numerator = 65536;
+	f->stepwise.max.denominator = 1;
+	f->stepwise.step.numerator = 1;
+	f->stepwise.step.denominator = 1;
+
+	return 0;
+}
+
+static int rtk_jcodec_subscribe_event(struct v4l2_fh *fh,
+				      const struct v4l2_event_subscription *sub)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(fh);
+
+	rtk_jcodec_dbg(2, ctx, "subscribe event (0x%x)\n", sub->type);
+
+	switch (sub->type) {
+	case V4L2_EVENT_EOS:
+		return v4l2_event_subscribe(fh, sub, 0, NULL);
+	case V4L2_EVENT_SOURCE_CHANGE:
+		if (ctx->inst_type == RTK_JCODEC_CTX_DECODER)
+			return v4l2_event_subscribe(fh, sub, 0, NULL);
+		else
+			return -EINVAL;
+	default:
+		return v4l2_ctrl_subscribe_event(fh, sub);
+	}
+}
+
+// TODO: for debug
+int rtk_jcodec_expbuf(struct file *file, void *priv,
+		      struct v4l2_exportbuffer *eb)
+{
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(priv);
+	int ret;
+
+	rtk_jcodec_dbg(2, ctx, "(%s) export buf %d\n",
+		       v4l2_type_names[eb->type], eb->index);
+
+	ret = v4l2_m2m_ioctl_expbuf(file, priv, eb);
+
+	return ret;
+}
+
+static const struct v4l2_ioctl_ops rtk_jcodec_ioctl_ops = {
+	.vidioc_querycap = rtk_jcodec_querycap,
+
+	.vidioc_enum_fmt_vid_cap = rtk_jcodec_enum_fmt,
+	.vidioc_g_fmt_vid_cap_mplane = rtk_jcodec_g_fmt,
+	.vidioc_try_fmt_vid_cap_mplane = rtk_jcodec_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap_mplane = rtk_jcodec_s_fmt_vid_cap,
+
+	.vidioc_enum_fmt_vid_out = rtk_jcodec_enum_fmt,
+	.vidioc_g_fmt_vid_out_mplane = rtk_jcodec_g_fmt,
+	.vidioc_try_fmt_vid_out_mplane = rtk_jcodec_try_fmt_vid_out,
+	.vidioc_s_fmt_vid_out_mplane = rtk_jcodec_s_fmt_vid_out,
+
+	.vidioc_reqbufs = rtk_jcodec_reqbufs,
+	.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,
+
+	.vidioc_qbuf = rtk_jcodec_qbuf,
+	.vidioc_expbuf = rtk_jcodec_expbuf,
+	.vidioc_dqbuf = rtk_jcodec_dqbuf,
+	.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,
+	.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,
+
+	.vidioc_streamon = v4l2_m2m_ioctl_streamon,
+	.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,
+
+	.vidioc_g_selection = rtk_jcodec_g_selection,
+	.vidioc_s_selection = rtk_jcodec_s_selection,
+
+	.vidioc_try_encoder_cmd = rtk_jcodec_try_encoder_cmd,
+	.vidioc_encoder_cmd = rtk_jcodec_encoder_cmd,
+	.vidioc_try_decoder_cmd = rtk_jcodec_try_decoder_cmd,
+	.vidioc_decoder_cmd = rtk_jcodec_decoder_cmd,
+
+	//.vidioc_g_parm		= rtk_jcodec_g_parm,
+	//.vidioc_s_parm		= rtk_jcodec_s_parm,
+
+	.vidioc_enum_framesizes = rtk_jcodec_enum_framesizes,
+	.vidioc_enum_frameintervals = rtk_jcodec_enum_frameintervals,
+
+	.vidioc_subscribe_event = rtk_jcodec_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+/*
+ * RTK jcodec mem-to-mem operations.
+ */
+
+void rtk_jcodec_m2m_buf_done(struct rtk_jcodec_ctx *ctx,
+			     struct vb2_v4l2_buffer *buf,
+			     enum vb2_buffer_state state)
+{
+	const struct v4l2_event eos_event = { .type = V4L2_EVENT_EOS };
+
+	if (buf->flags & V4L2_BUF_FLAG_LAST) {
+		v4l2_event_queue_fh(&ctx->fh, &eos_event);
+	}
+
+	v4l2_m2m_buf_done(buf, state);
+}
+
+static void rtk_jcodec_device_run(void *m2m_priv)
+{
+	struct rtk_jcodec_ctx *ctx = m2m_priv;
+	struct rtk_jcodec_dev *dev = ctx->dev;
+
+	queue_work(dev->workqueue, &ctx->pic_run_work);
+}
+
+static void rtk_jcodec_pic_run_work(struct work_struct *work)
+{
+	struct rtk_jcodec_ctx *ctx =
+		container_of(work, struct rtk_jcodec_ctx, pic_run_work);
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	int ret;
+
+	mutex_lock(&ctx->buffer_mutex);
+	mutex_lock(&dev->rtk_mutex);
+
+	ret = ctx->ops->prepare_run(ctx);
+	if (ret < 0 && ctx->inst_type == RTK_JCODEC_CTX_DECODER) {
+		printk(KERN_INFO
+		       "[fn_name]:[\x1b[31m%s\033[0m], [line]: \x1b[33m%d\033[0m\n",
+		       __func__, __LINE__);
+#if 0	   
+		mutex_unlock(&dev->rtk_mutex);
+		mutex_unlock(&ctx->buffer_mutex);
+		/* job_finish scheduled by prepare_decode */
+		return;
+#else
+		goto exit;
+#endif
+	}
+
+	if (!wait_for_completion_timeout(&ctx->completion,
+					 msecs_to_jiffies(1000))) {
+		if (ctx->use_bit) {
+			dev_err(dev->dev, "RTK PIC_RUN timeout\n");
+
+			ctx->hold = true;
+
+			rtk_jcodec_hw_reset(dev);
+		}
+
+		if (ctx->ops->run_timeout)
+			ctx->ops->run_timeout(ctx);
+	} else {
+		ctx->ops->finish_run(ctx);
+	}
+
+exit:
+	if (ctx->parsing_hdr_err) {
+		ctx->ops->finish_run(ctx);
+		ctx->parsing_hdr_err = false;
+	}
+
+	mutex_unlock(&dev->rtk_mutex);
+	mutex_unlock(&ctx->buffer_mutex);
+
+	v4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);
+}
+
+static int rtk_jcodec_job_ready(void *m2m_priv)
+{
+	struct rtk_jcodec_ctx *ctx = m2m_priv;
+	int src_bufs = v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx);
+
+	/*
+	 * For both 'P' and 'key' frame cases 1 picture
+	 * and 1 frame are needed. In the decoder case,
+	 * the compressed frame can be in the bitstream.
+	 */
+	if (!src_bufs && ctx->inst_type != RTK_JCODEC_CTX_DECODER) {
+		rtk_jcodec_dbg(1, ctx,
+			       "not ready: not enough vid-out buffers.\n");
+		return 0;
+	}
+
+	if (!v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx)) {
+		rtk_jcodec_dbg(1, ctx,
+			       "not ready: not enough vid-cap buffers.\n");
+		return 0;
+	}
+
+	if (ctx->inst_type == RTK_JCODEC_CTX_DECODER && ctx->use_bit) {
+		bool stream_end =
+			ctx->bit_stream_param & RTK_BIT_STREAM_END_FLAG;
+		int num_metas = ctx->num_metas;
+		struct rtk_meta_buffer *meta;
+		unsigned int count;
+
+		count = hweight32(ctx->frm_dis_flg);
+
+		rtk_jcodec_dbg(2, ctx,
+			       "stream_end : %d, ctx->hold : %d, count : %d\n",
+			       stream_end, ctx->hold, count);
+
+		// TODO: ray refine free fb timing
+		if (/*ctx->use_vdoa && */ count >=
+		    (ctx->num_frame_buffers /*- 1*/)) {
+			rtk_jcodec_dbg(
+				1, ctx,
+				"not ready: all frame buffers in use: %d/%d (0x%x)",
+				count, ctx->num_frame_buffers,
+				ctx->frm_dis_flg);
+			return 0;
+		}
+
+		if (ctx->hold && !src_bufs) {
+			rtk_jcodec_dbg(
+				1, ctx,
+				"not ready: on hold for more buffers.\n");
+			return 0;
+		}
+
+		if (!stream_end && (num_metas + src_bufs) < 2) {
+			rtk_jcodec_dbg(1, ctx,
+				       "not ready: need 2 buffers"
+				       " available (queue:%d + bitstream:%d)\n",
+				       num_metas, src_bufs);
+			return 0;
+		}
+
+		meta = list_first_entry(&ctx->meta_buffer_list,
+					struct rtk_meta_buffer, list);
+		if (!rtk_bitstream_can_fetch_past(ctx, meta->end) &&
+		    !stream_end) {
+			rtk_jcodec_dbg(1, ctx,
+				       "not ready: not enough bitstream data"
+				       " to read past %u (%u)\n",
+				       meta->end, ctx->bitstream_fifo.kfifo.in);
+			return 0;
+		}
+	}
+
+	if (ctx->aborting) {
+		rtk_jcodec_dbg(1, ctx, "not ready: aborting\n");
+		return 0;
+	}
+
+	rtk_jcodec_dbg(2, ctx, "job ready\n");
+
+	return 1;
+}
+
+static void rtk_jcodec_job_abort(void *priv)
+{
+	struct rtk_jcodec_ctx *ctx = priv;
+
+	ctx->aborting = 1;
+
+	rtk_jcodec_dbg(1, ctx, "job abort\n");
+}
+
+static const struct v4l2_m2m_ops rtk_jcodec_m2m_ops = {
+	.device_run = rtk_jcodec_device_run,
+	.job_ready = rtk_jcodec_job_ready,
+	.job_abort = rtk_jcodec_job_abort,
+};
+
+/**
+ * RTK jcodec ctrls operations
+ */
+
+static int rtk_jcodec_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	const char *const *val_names = v4l2_ctrl_get_menu(ctrl->id);
+	struct rtk_jcodec_ctx *ctx =
+		container_of(ctrl->handler, struct rtk_jcodec_ctx, ctrls);
+
+	pr_info("[fn_name]:[\x1b[33m%s\033[0m], [line]: \x1b[33m%d\033[0m\n",
+		__func__, __LINE__);
+	pr_info("[\x1b[33mctrl->id : 0x%x(%d)\033[0m]\n", ctrl->id,
+		(ctrl->id - V4L2_CID_CODEC_BASE));
+	if (val_names)
+		rtk_jcodec_dbg(2, ctx,
+			       "s_ctrl: id = 0x%x, name = \"%s\","
+			       " val = %d (\"%s\")\n",
+			       ctrl->id, ctrl->name, ctrl->val,
+			       val_names[ctrl->val]);
+	else
+		rtk_jcodec_dbg(2, ctx,
+			       "s_ctrl: id = 0x%x, name = \"%s\","
+			       " val = %d\n",
+			       ctrl->id, ctrl->name, ctrl->val);
+
+	switch (ctrl->id) {
+	case V4L2_CID_HFLIP:
+		if (ctrl->val)
+			ctx->params.rot_mode |= CODA_MIR_HOR;
+		else
+			ctx->params.rot_mode &= ~CODA_MIR_HOR;
+		break;
+	case V4L2_CID_VFLIP:
+		if (ctrl->val)
+			ctx->params.rot_mode |= CODA_MIR_VER;
+		else
+			ctx->params.rot_mode &= ~CODA_MIR_VER;
+		break;
+	case V4L2_CID_MPEG_VIDEO_BITRATE:
+		ctx->params.bitrate = ctrl->val / 1000;
+		ctx->params.bitrate_changed = true;
+		break;
+	case V4L2_CID_MPEG_VIDEO_GOP_SIZE:
+		ctx->params.gop_size = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA:
+		ctx->params.h264_slice_alpha_c0_offset_div2 = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA:
+		ctx->params.h264_slice_beta_offset_div2 = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE:
+		ctx->params.h264_disable_deblocking_filter_idc = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_CONSTRAINED_INTRA_PREDICTION:
+		ctx->params.h264_constrained_intra_pred_flag = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE:
+		ctx->params.frame_rc_enable = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE:
+		ctx->params.mb_rc_enable = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_CHROMA_QP_INDEX_OFFSET:
+		ctx->params.h264_chroma_qp_index_offset = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_PROFILE:
+		/* TODO: switch between baseline and constrained baseline */
+		if (ctx->inst_type == RTK_JCODEC_CTX_ENCODER)
+			ctx->params.h264_profile_idc = 66;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_LEVEL:
+		/* nothing to do, this is set by the encoder */
+		break;
+	case V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP:
+		ctx->params.mpeg4_intra_qp = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP:
+		ctx->params.mpeg4_inter_qp = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_MPEG2_PROFILE:
+	case V4L2_CID_MPEG_VIDEO_MPEG2_LEVEL:
+	case V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE:
+	case V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL:
+		/* nothing to do, these are fixed */
+		break;
+	case V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE:
+		ctx->params.slice_mode = ctrl->val;
+		ctx->params.slice_mode_changed = true;
+		break;
+	case V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB:
+		ctx->params.slice_max_mb = ctrl->val;
+		ctx->params.slice_mode_changed = true;
+		break;
+	case V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES:
+		ctx->params.slice_max_bits = ctrl->val * 8;
+		ctx->params.slice_mode_changed = true;
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEADER_MODE:
+		break;
+	case V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB:
+		ctx->params.intra_refresh = ctrl->val;
+		ctx->params.intra_refresh_changed = true;
+		break;
+	case V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME:
+		ctx->params.force_ipicture = true;
+		break;
+	case V4L2_CID_JPEG_COMPRESSION_QUALITY:
+		rtk_set_jpeg_compression_quality(ctx, ctrl->val, 0);
+		break;
+	case V4L2_CID_JPEG_RESTART_INTERVAL:
+		ctx->params.jpeg_restart_interval = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_VBV_DELAY:
+		ctx->params.vbv_delay = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_VBV_SIZE:
+		ctx->params.vbv_size = min(ctrl->val * 8192, 0x7fffffff);
+		break;
+	default:
+		rtk_jcodec_dbg(1, ctx, "Invalid control, id=%d, val=%d\n",
+			       ctrl->id, ctrl->val);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rtk_jcodec_g_v_ctrl(struct v4l2_ctrl *ctrl)
+{
+	const char *const *val_names = v4l2_ctrl_get_menu(ctrl->id);
+	struct rtk_jcodec_ctx *ctx =
+		container_of(ctrl->handler, struct rtk_jcodec_ctx, ctrls);
+	int ret = 0;
+
+	if (val_names)
+		rtk_jcodec_dbg(2, ctx,
+			       "%d.%s.s_ctrl: id = 0x%x, name = \"%s\","
+			       "val = %d (\"%s\")\n",
+			       __LINE__, __func__, ctrl->id, ctrl->name,
+			       ctrl->val, val_names[ctrl->val]);
+	else
+		rtk_jcodec_dbg(2, ctx,
+			       "%d.%s.s_ctrl: id = 0x%x, name = \"%s\","
+			       " val = %d\n",
+			       __LINE__, __func__, ctrl->id, ctrl->name,
+			       ctrl->val);
+
+	switch (ctrl->id) {
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		if (ctx->initialized) {
+			rtk_jcodec_dbg(2, ctx, "%d.%s.min_frame_buffers : %d\n",
+				       __LINE__, __func__,
+				       ctx->min_frame_buffers);
+			ctrl->val = ctx->min_frame_buffers;
+		} else {
+			rtk_jcodec_dbg(2, ctx,
+				       "%d.%s.Seq not initialized yet\n",
+				       __LINE__, __func__);
+			ctrl->val = 1;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops rtk_jcodec_ctrl_ops = {
+	.s_ctrl = rtk_jcodec_s_ctrl,
+	.g_volatile_ctrl = rtk_jcodec_g_v_ctrl,
+};
+
+static void rtk_jcodec_encode_ctrls(struct rtk_jcodec_ctx *ctx)
+{
+	/* TODO: ....? */
+
+	v4l2_ctrl_new_std(&ctx->ctrls, &rtk_jcodec_ctrl_ops,
+			  V4L2_CID_JPEG_COMPRESSION_QUALITY, 5, 100, 1, 50);
+	v4l2_ctrl_new_std(&ctx->ctrls, &rtk_jcodec_ctrl_ops,
+			  V4L2_CID_JPEG_RESTART_INTERVAL, 0, 100, 1, 0);
+	//return;
+}
+
+static int rtk_jcodec_ctrls_setup(struct rtk_jcodec_ctx *ctx)
+{
+	struct v4l2_ctrl *ctrl;
+
+	v4l2_ctrl_handler_init(&ctx->ctrls, 9);
+
+	v4l2_ctrl_new_std(&ctx->ctrls, &rtk_jcodec_ctrl_ops, V4L2_CID_HFLIP, 0,
+			  1, 1, 0);
+	v4l2_ctrl_new_std(&ctx->ctrls, &rtk_jcodec_ctrl_ops, V4L2_CID_VFLIP, 0,
+			  1, 1, 0);
+	if (ctx->inst_type == RTK_JCODEC_CTX_ENCODER) {
+		if (ctx->cvd->dst_formats[0] == V4L2_PIX_FMT_JPEG)
+			rtk_jcodec_encode_ctrls(ctx);
+		// else
+		// 	rtk_vcodec_encode_ctrls(ctx);
+	} else {
+		ctrl = v4l2_ctrl_new_std(&ctx->ctrls, &rtk_jcodec_ctrl_ops,
+					 V4L2_CID_MIN_BUFFERS_FOR_CAPTURE,
+					 RTK_MIN_FRAME_BUFFERS,
+					 RTK_MAX_FRAME_BUFFERS, 1, 1);
+		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;
+
+		// TODO: refine later
+		// ctx->mb_err_cnt_ctrl = v4l2_ctrl_new_custom(&ctx->ctrls,
+		// 				&coda_mb_err_cnt_ctrl_config,
+		// 				NULL);
+		// if (ctx->mb_err_cnt_ctrl)
+		// 	ctx->mb_err_cnt_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+	}
+
+	if (ctx->ctrls.error) {
+		v4l2_err(&ctx->dev->v4l2_dev,
+			 "control initialization error (%d)", ctx->ctrls.error);
+		return -EINVAL;
+	}
+
+	return v4l2_ctrl_handler_setup(&ctx->ctrls);
+}
+
+/*
+ * RTK jcodec file operations
+ */
+
+static int rtk_jcodec_open(struct file *file)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct rtk_jcodec_dev *dev = video_get_drvdata(vdev);
+	struct rtk_jcodec_ctx *ctx;
+	unsigned int max = ~0;
+	char *name;
+	int ret;
+	int idx;
+	unsigned int val;
+
+	pr_info("%s %d.%s.enter\n", RTK_JCODEC_NAME, __LINE__, __func__);
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		pr_err("%s %d.%s.return -ENOMEM\n", RTK_JCODEC_NAME, __LINE__,
+		       __func__);
+		return -ENOMEM;
+	}
+
+	idx = ida_alloc_max(&dev->ida, max, GFP_KERNEL);
+	if (idx < 0) {
+		ret = idx;
+		pr_err("%s %d.%s.idx:%d.goto err_rtk_max\n", RTK_JCODEC_NAME,
+		       __LINE__, __func__, idx);
+		goto err_rtk_max;
+	}
+	pr_info("%s %d.%s.idx:%d\n", RTK_JCODEC_NAME, __LINE__, __func__, idx);
+
+	name = kasprintf(GFP_KERNEL, "context%d", idx);
+	if (!name) {
+		ret = -ENOMEM;
+		pr_err("%s %d.%s.-ENOMEM.goto err_rtk_name_init\n",
+		       RTK_JCODEC_NAME, __LINE__, __func__);
+		goto err_rtk_name_init;
+	}
+	pr_info("%s %d.%s.name:%s\n", RTK_JCODEC_NAME, __LINE__, __func__,
+		name);
+
+	ctx->debugfs_entry = debugfs_create_dir(name, dev->debugfs_root);
+	kfree(name);
+
+	ctx->cvd = to_rtk_video_device(vdev);
+	ctx->inst_type = ctx->cvd->type;
+	ctx->ops = ctx->cvd->ops;
+	ctx->use_bit = !ctx->cvd->direct;
+	init_completion(&ctx->completion);
+	INIT_WORK(&ctx->pic_run_work, rtk_jcodec_pic_run_work);
+
+	v4l2_fh_init(&ctx->fh, video_devdata(file));
+	file->private_data = &ctx->fh;
+	v4l2_fh_add(&ctx->fh);
+	ctx->dev = dev;
+	ctx->idx = idx;
+
+	rtk_jcodec_dbg(1, ctx, "\x1b[33mopen instance (%p) (%s)\033[0m\n", ctx,
+		       ctx->cvd->name);
+
+	switch (dev->devinfo->product) {
+	case CODA_J10:
+		/*
+		 * Enabling the BWB when decoding can hang the firmware with
+		 * certain streams. The issue was tracked as ENGR00293425 by
+		 * Freescale. As a workaround, disable BWB for all decoders.
+		 * The enable_bwb module parameter allows to override this.
+		 */
+		// TODO: refine later
+		// if (enable_bwb || ctx->inst_type == RTK_VCODEC_CTX_ENCODER)
+		// 	ctx->frame_mem_ctrl = CODA9_FRAME_ENABLE_BWB;
+		// fallthrough;
+		// TODO: refine later
+		// case CODA_HX4:
+		// case CODA_7541:
+		ctx->reg_idx = 0;
+		break;
+	default:
+		ctx->reg_idx = idx;
+	}
+
+	ctx->use_vdoa = false;
+
+	// TODO rtk16xxb settings
+	ret = pm_runtime_get_sync(dev->dev);
+	// TODO: refine later
+	if (ret < 0) {
+		v4l2_err(&dev->v4l2_dev, "failed to power up: %d\n", ret);
+		goto err_pm_get;
+	}
+
+	pr_info("%s %d.%s.\n", RTK_JCODEC_NAME, __LINE__, __func__);
+
+	reset_control_deassert(dev->rstc);
+	ret = rtk_jcodec_clk_enable(dev->clk);
+	if (ret)
+		goto err_clk_enable;
+	val = rtk_jcodec_read(dev, RTK_REG_JPEG_DBUS);
+	val |= (dbus_en << 0);
+	val &= ~(1 << 1); //Disable idle gating, fix it later.
+	rtk_jcodec_write(dev, val, RTK_REG_JPEG_DBUS);
+
+	rtk_jcodec_set_default_params(ctx);
+
+	ctx->fh.m2m_ctx =
+		v4l2_m2m_ctx_init(dev->m2m_dev, ctx, ctx->ops->queue_init);
+	if (IS_ERR(ctx->fh.m2m_ctx)) {
+		ret = PTR_ERR(ctx->fh.m2m_ctx);
+
+		v4l2_err(&dev->v4l2_dev, "%s return error (%d)\n", __func__,
+			 ret);
+		goto err_ctx_init;
+	}
+	pr_info("%s %d.%s.v4l2_m2m_ctx_init ok\n", RTK_JCODEC_NAME, __LINE__,
+		__func__);
+
+	ret = rtk_jcodec_ctrls_setup(ctx);
+	if (ret) {
+		v4l2_err(&dev->v4l2_dev, "failed to setup coda controls\n");
+		goto err_ctrls_setup;
+	}
+	pr_info("%s %d.%s.rtk_jcodec_ctrls_setup ok\n", RTK_JCODEC_NAME,
+		__LINE__, __func__);
+
+	ctx->fh.ctrl_handler = &ctx->ctrls;
+
+	mutex_init(&ctx->bitstream_mutex);
+	mutex_init(&ctx->buffer_mutex);
+	mutex_init(&ctx->wakeup_mutex);
+	INIT_LIST_HEAD(&ctx->meta_buffer_list);
+
+	list_add_tail(&ctx->list, &dev->instances);
+
+	spin_lock_init(&ctx->meta_buffer_lock);
+
+	pr_info("%s %d.%s.leave\n", RTK_JCODEC_NAME, __LINE__, __func__);
+	return 0;
+
+err_ctrls_setup:
+	v4l2_m2m_ctx_release(ctx->fh.m2m_ctx);
+err_ctx_init:
+	clk_disable_unprepare(dev->clk);
+err_clk_enable:
+	pm_runtime_put_sync(dev->dev);
+err_pm_get:
+	v4l2_fh_del(&ctx->fh);
+	v4l2_fh_exit(&ctx->fh);
+err_rtk_name_init:
+	ida_free(&dev->ida, ctx->idx);
+err_rtk_max:
+	kfree(ctx);
+	return ret;
+}
+
+static int rtk_jcodec_release(struct file *file)
+{
+	struct rtk_jcodec_dev *dev = video_drvdata(file);
+	struct rtk_jcodec_ctx *ctx = fh_to_ctx(file->private_data);
+
+	rtk_jcodec_dbg(1, ctx, "\x1b[31mrelease instance (%p) (%s)\033[0m\n",
+		       ctx, ctx->cvd->name);
+
+	if (ctx->inst_type == RTK_JCODEC_CTX_DECODER && ctx->use_bit) {
+		printk(KERN_INFO "[fn_name]:[\x1b[32m%s\033[0m], [line]:"
+				 " \x1b[33m%d\033[0m\n",
+		       __func__, __LINE__);
+		// TODO: refine later
+		rtk_bitstream_end_flag(ctx);
+	}
+
+	/* If this instance is running, call .job_abort and wait for it to end */
+	v4l2_m2m_ctx_release(ctx->fh.m2m_ctx);
+	// if (ctx->vdoa)
+	// 	vdoa_context_destroy(ctx->vdoa);
+
+	v4l2_ctrl_handler_free(&ctx->ctrls);
+
+	clk_disable_unprepare(dev->clk);
+
+	// TODO rtk16xxb settings
+	pm_runtime_mark_last_busy(dev->dev);
+	pm_runtime_put_autosuspend(dev->dev);
+	// TODO: refine later
+	// pm_runtime_put_sync(dev->dev);
+	v4l2_fh_del(&ctx->fh);
+	v4l2_fh_exit(&ctx->fh);
+	ida_free(&dev->ida, ctx->idx);
+	if (ctx->ops->release) {
+		ctx->ops->release(ctx);
+	}
+	debugfs_remove_recursive(ctx->debugfs_entry);
+	list_del(&ctx->list);
+	kfree(ctx);
+
+	return 0;
+}
+
+static const struct v4l2_file_operations rtk_jcodec_fops = {
+	.owner = THIS_MODULE,
+	.open = rtk_jcodec_open,
+	.release = rtk_jcodec_release,
+	.poll = v4l2_m2m_fop_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap = v4l2_m2m_fop_mmap,
+};
+
+static int rtk_jcodec_register_device(struct rtk_jcodec_dev *dev, int i)
+{
+	struct video_device *vfd = &dev->vfd[i];
+	const char *name;
+	int ret;
+
+	if (i >= dev->devinfo->num_vdevs)
+		return -EINVAL;
+
+	name = dev->devinfo->vdevs[i]->name;
+	strscpy(vfd->name, dev->devinfo->vdevs[i]->name, sizeof(vfd->name));
+	vfd->fops = &rtk_jcodec_fops;
+	vfd->ioctl_ops = &rtk_jcodec_ioctl_ops;
+	vfd->release = video_device_release_empty;
+	vfd->lock = &dev->dev_mutex;
+	vfd->v4l2_dev = &dev->v4l2_dev;
+	vfd->vfl_dir = VFL_DIR_M2M;
+	vfd->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;
+	video_set_drvdata(vfd, dev);
+
+	/* Not applicable, use the selection API instead */
+	// TODO: refine later
+	v4l2_disable_ioctl(vfd, VIDIOC_CROPCAP);
+	v4l2_disable_ioctl(vfd, VIDIOC_G_CROP);
+	v4l2_disable_ioctl(vfd, VIDIOC_S_CROP);
+
+	if (dev->devinfo->vdevs[i]->type == RTK_JCODEC_CTX_ENCODER) {
+		v4l2_disable_ioctl(vfd, VIDIOC_DECODER_CMD);
+		v4l2_disable_ioctl(vfd, VIDIOC_TRY_DECODER_CMD);
+		if (dev->devinfo->vdevs[i]->dst_formats[0] ==
+		    V4L2_PIX_FMT_JPEG) {
+			v4l2_disable_ioctl(vfd, VIDIOC_ENUM_FRAMEINTERVALS);
+			v4l2_disable_ioctl(vfd, VIDIOC_G_PARM);
+			v4l2_disable_ioctl(vfd, VIDIOC_S_PARM);
+		}
+	} else {
+		v4l2_disable_ioctl(vfd, VIDIOC_ENCODER_CMD);
+		v4l2_disable_ioctl(vfd, VIDIOC_TRY_ENCODER_CMD);
+		v4l2_disable_ioctl(vfd, VIDIOC_ENUM_FRAMESIZES);
+		v4l2_disable_ioctl(vfd, VIDIOC_ENUM_FRAMEINTERVALS);
+		v4l2_disable_ioctl(vfd, VIDIOC_G_PARM);
+		v4l2_disable_ioctl(vfd, VIDIOC_S_PARM);
+	}
+
+	ret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);
+	if (!ret) {
+		v4l2_info(&dev->v4l2_dev, "%s registered as %s\n", name,
+			  video_device_node_name(vfd));
+	}
+	pr_info("%s %d.%s.video_register_device.name:%s\n", RTK_JCODEC_NAME,
+		__LINE__, __func__, name);
+	return ret;
+}
+
+//coda_fw_callback
+static void rtk_jcodec_set_dev(struct rtk_jcodec_dev *dev)
+{
+	int i, ret;
+
+	ret = rtk_jcodec_hw_init(dev);
+	if (ret < 0) {
+		v4l2_err(&dev->v4l2_dev, "HW initialization failed\n");
+		goto put_pm;
+	}
+
+	dev->m2m_dev = v4l2_m2m_init(&rtk_jcodec_m2m_ops);
+	if (IS_ERR(dev->m2m_dev)) {
+		v4l2_err(&dev->v4l2_dev, "Failed to init mem2mem device\n");
+		goto put_pm;
+	}
+
+	ret = rtk_jcodec_check_firmware(dev);
+	if (ret < 0) {
+		goto put_pm;
+	}
+	for (i = 0; i < dev->devinfo->num_vdevs; i++) {
+		ret = rtk_jcodec_register_device(dev, i);
+		if (ret) {
+			v4l2_err(&dev->v4l2_dev,
+				 "Failed to register %s video device: %d\n",
+				 dev->devinfo->vdevs[i]->name, ret);
+			goto rel_vfd;
+		}
+	}
+
+	pm_runtime_set_suspended(dev->dev);
+	pm_runtime_use_autosuspend(dev->dev);
+	pm_runtime_set_autosuspend_delay(dev->dev, 15000);
+	pm_runtime_enable(dev->dev);
+	pm_runtime_mark_last_busy(dev->dev);
+	pr_info("%s %d.%s.af pm_xxx\n", RTK_JCODEC_NAME, __LINE__, __func__);
+
+	return;
+
+rel_vfd:
+	while (--i >= 0)
+		video_unregister_device(&dev->vfd[i]);
+	v4l2_m2m_release(dev->m2m_dev);
+put_pm:
+	pm_runtime_put_sync(dev->dev);
+}
+
+static const struct of_device_id rtk_dt_ids[] = {
+	{ .compatible = "realtek,rtd16xxb-jpeg",
+	  .data = &rtk_devdata[RTK_STARK] },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, rtk_dt_ids);
+
+static int rtk_jcodec_probe(struct platform_device *pdev)
+{
+	struct rtk_jcodec_dev *dev;
+	int ret, irq;
+
+	dev_info(&pdev->dev, "%s %d.%s.enter\n", RTK_JCODEC_NAME, __LINE__,
+		 __func__);
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	set_dma_ops(&pdev->dev, &rheap_dma_ops);
+	rheap_setup_dma_pools(&pdev->dev, "rtk_media_heap",
+			      RTK_FLAG_NONCACHED | RTK_FLAG_SCPUACC |
+				      RTK_FLAG_VO_POOL,
+			      __func__);
+
+	dev->devinfo = of_device_get_match_data(&pdev->dev);
+
+	dev->dev = &pdev->dev;
+
+	dev->clk = devm_clk_get(&pdev->dev, "jpeg");
+	//	dev->clk = clk_get(&pdev->dev, "jpeg");
+	if (IS_ERR(dev->clk)) {
+		dev_err(&pdev->dev, "Could not get jpeg clock\n");
+		return PTR_ERR(dev->clk);
+	}
+
+	/* Get memory for physical registers */
+	dev->regs_base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(dev->regs_base))
+		return PTR_ERR(dev->regs_base);
+
+	/* IRQ */
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "Could not get irq\n");
+		return irq;
+	}
+
+	ret = devm_request_irq(&pdev->dev, irq, rtk_jcodec_irq_handler, 0,
+			       RTK_JCODEC_NAME "-jpeg", dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to request irq: %d\n", ret);
+		return ret;
+	}
+
+	//dev->rstc = devm_reset_control_get_exclusive(&pdev->dev, "reset");
+	dev->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(dev->rstc)) {
+		ret = PTR_ERR(dev->rstc);
+		dev_err(&pdev->dev, "failed get reset control: %d\n", ret);
+		return ret;
+	}
+
+	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
+	if (ret)
+		return ret;
+
+	// TODO: Not sure rtk need ratelimit or not
+	//ratelimit_default_init(&dev->mb_err_rs);
+
+	mutex_init(&dev->dev_mutex);
+	mutex_init(&dev->rtk_mutex);
+	ida_init(&dev->ida);
+
+	dev->debugfs_root = debugfs_create_dir("rtk-jcodec-dbg", NULL);
+
+	dev->workqueue = alloc_ordered_workqueue("rtk-jcodec", WQ_MEM_RECLAIM);
+	if (!dev->workqueue) {
+		dev_err(&pdev->dev, "unable to alloc workqueue\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, dev);
+
+	/*
+	 * Start activated so we can directly call rtk_jcodec_hw_init in
+	 * coda_fw_callback regardless of whether CONFIG_PM is
+	 * enabled or whether the device is associated with a PM domain.
+	 */
+
+	// TODO: refine later
+	// pm_runtime_get_noresume(&pdev->dev);
+	// pm_runtime_set_active(&pdev->dev);
+	// pm_runtime_enable(&pdev->dev);
+	ret = device_create_file(&pdev->dev, &dev_attr_instance_info);
+	if (ret < 0)
+		dev_err(&pdev->dev, "failed to create jpeg v4l2 instance_info attribute\n");
+
+	INIT_LIST_HEAD(&dev->instances);
+
+	rtk_jcodec_set_dev(dev);
+	dev_info(&pdev->dev, "%s %d.%s.leave\n", RTK_JCODEC_NAME, __LINE__,
+		 __func__);
+	return 0;
+}
+
+static int rtk_jcodec_remove(struct platform_device *pdev)
+{
+	struct rtk_jcodec_dev *dev = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dev->vfd); i++) {
+		if (video_get_drvdata(&dev->vfd[i]))
+			video_unregister_device(&dev->vfd[i]);
+	}
+
+	device_remove_file(&pdev->dev, &dev_attr_instance_info);
+
+	if (dev->m2m_dev)
+		v4l2_m2m_release(dev->m2m_dev);
+	pm_runtime_disable(&pdev->dev);
+	v4l2_device_unregister(&dev->v4l2_dev);
+	destroy_workqueue(dev->workqueue);
+
+	debugfs_remove_recursive(dev->debugfs_root);
+	ida_destroy(&dev->ida);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int rtk_jcodec_runtime_suspend(struct device *dev)
+{
+	struct rtk_jcodec_dev *rdev = dev_get_drvdata(dev);
+	int ret = 0;
+
+	reset_control_deassert(rdev->rstc);
+	rtk_jcodec_clk_enable(rdev->clk);
+	rtk_jcodec_clk_disable(rdev->clk);
+	reset_control_assert(rdev->rstc);
+
+	return ret;
+}
+
+static int rtk_jcodec_runtime_resume(struct device *dev)
+{
+	struct rtk_jcodec_dev *rdev = dev_get_drvdata(dev);
+	int ret = 0;
+
+#if 0 // mark by joshua, need to refine
+	if (dev->pm_domain && rdev->codebuf.vaddr) {
+		dev_info(dev, "[fn_name]:[\x1b[33m%s\033[0m], [line]:"
+				" \x1b[33m%d\033[0m\n", __func__, __LINE__);
+		ret = rtk_jcodec_hw_init(rdev);
+		if (ret)
+			v4l2_err(&rdev->v4l2_dev, "HW initialization failed\n");
+	}
+#else
+	reset_control_deassert(rdev->rstc);
+	rtk_jcodec_clk_enable(rdev->clk);
+	rtk_jcodec_clk_disable(rdev->clk);
+	reset_control_assert(rdev->rstc);
+#endif
+	return ret;
+}
+#endif
+
+static const struct dev_pm_ops rtk_jcodec_pm_ops = { SET_RUNTIME_PM_OPS(
+	rtk_jcodec_runtime_suspend, rtk_jcodec_runtime_resume, NULL) };
+
+static struct platform_driver rtk_jcodec_driver = {
+	.probe	= rtk_jcodec_probe,
+	.remove	= rtk_jcodec_remove,
+	.driver	= {
+		.name	= RTK_JCODEC_NAME,
+		.of_match_table = rtk_dt_ids,
+		.pm	= &rtk_jcodec_pm_ops,
+	},
+};
+
+module_platform_driver(rtk_jcodec_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("HK Chiu <hkchiu@realtek.com>");
+MODULE_DESCRIPTION("Realtek jpeg codec V4L2 driver");
--- /dev/null
+++ b/drivers/media/platform/realtek/coda/rtk_jcodec/rtk_jcodec_drv.h
@@ -0,0 +1,486 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp.
+ *
+ */
+
+#ifndef _RTK_JCODEC_DRV_H_
+#define _RTK_JCODEC_DRV_H_
+
+#include <linux/debugfs.h>
+#include <linux/idr.h>
+#include <linux/irqreturn.h>
+#include <linux/mutex.h>
+#include <linux/kfifo.h>
+#include <linux/videodev2.h>
+#include <linux/ratelimit.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fh.h>
+#include <media/videobuf2-v4l2.h>
+
+//#define RTK_INTERLACED //SW-8965
+
+#define RTK_MIN_FRAME_BUFFERS 1
+#define RTK_MAX_FRAME_BUFFERS 32
+#define RTK_LINEAR_FRAME_MAP 0
+#define RTK_TILED_FRAME_MB_RASTER_MAP 1
+
+#define RTK_BIT_STREAM_END_FLAG (1 << 2)
+#define RTK_BIT_STREAM_PICEND_MODE (1 << 4)
+
+enum { V4L2_M2M_SRC_Q_DATA = 0,
+       V4L2_M2M_DST_Q_DATA = 1,
+};
+
+enum rtk_jcodec_ctx_type {
+	RTK_JCODEC_CTX_ENCODER,
+	RTK_JCODEC_CTX_DECODER,
+};
+
+enum { V4L2_M2M_SRC = 0,
+       V4L2_M2M_DST = 1,
+};
+
+enum rtk_jcodec_product {
+	CODA_960 = 0xf020,
+	//CODA_980 = 0xf021,
+	CODA_J10 = 0xf021, //not sure
+};
+
+/**
+* @brief enumeration type for interrupt bit for CODA series.
+*/
+enum int_bit {
+	INT_BIT_INIT = 0,
+	INT_BIT_SEQ_INIT = 1,
+	INT_BIT_SEQ_END = 2,
+	INT_BIT_PIC_RUN = 3,
+	INT_BIT_FRAMEBUF_SET = 4,
+	INT_BIT_ENC_HEADER = 5,
+	INT_BIT_DEC_PARA_SET = 7,
+	INT_BIT_DEC_BUF_FLUSH = 8,
+	INT_BIT_USERDATA = 9,
+	INT_BIT_DEC_FIELD = 10,
+	INT_BIT_DEC_MB_ROWS = 13,
+	INT_BIT_BIT_BUF_EMPTY = 14,
+	INT_BIT_BIT_BUF_FULL = 15
+};
+
+/**
+* @brief enumeration type for interrupt bit reasons for CODA series.
+*/
+enum int_bit_reason {
+	INT_BIT_REASON_INIT = 0,
+	INT_BIT_REASON_SEQ_INIT = 1,
+	INT_BIT_REASON_SEQ_END = 2,
+	INT_BIT_REASON_PIC_RUN = 3,
+	INT_BIT_REASON_FRAMEBUF_SET = 4,
+	INT_BIT_REASON_ENC_HEADER = 5,
+	INT_BIT_REASON_DEC_PARA_SET = 7,
+	INT_BIT_REASON_DEC_BUF_FLUSH = 8,
+	INT_BIT_REASON_USERDATA = 9,
+	INT_BIT_REASON_DEC_FIELD = 10,
+	INT_BIT_REASON_DEC_MB_ROWS = 13,
+	INT_BIT_REASON_BIT_BUF_EMPTY = 14,
+	INT_BIT_REASON_BIT_BUF_FULL = 15
+};
+
+struct rtk_video_device;
+
+struct rtk_devinfo {
+	char *firmware[3];
+	enum rtk_jcodec_product product;
+	const struct rtk_codec *codecs;
+	unsigned int num_codecs;
+	const struct rtk_video_device **vdevs;
+	unsigned int num_vdevs;
+	size_t workbuf_size;
+	size_t tempbuf_size;
+	size_t sram_size;
+};
+
+struct rtk_extra_buf {
+	void *vaddr;
+	dma_addr_t paddr;
+	u32 size;
+	struct debugfs_blob_wrapper blob;
+	struct dentry *dentry;
+};
+
+struct rtk_devtype {
+	char *firmware[3];
+	const struct rtk_codec *codecs;
+	unsigned int num_codecs;
+	const struct rtk_video_device **vdevs;
+	unsigned int num_vdevs;
+};
+
+struct rtk_jcodec_dev {
+	struct v4l2_device v4l2_dev;
+	struct video_device vfd[2];
+	struct device *dev;
+	const struct rtk_devinfo *devinfo;
+	int firmware;
+	// TODO: rtk support vdoa or not ?
+	// struct vdoa_data	*vdoa;
+
+	void __iomem *regs_base;
+	struct reset_control *rstc;
+
+	struct rtk_extra_buf codebuf;
+	struct rtk_extra_buf tempbuf;
+	struct rtk_extra_buf workbuf;
+	struct rtk_extra_buf sram;
+
+	struct mutex dev_mutex;
+	struct mutex rtk_mutex;
+	struct workqueue_struct *workqueue;
+	struct v4l2_m2m_dev *m2m_dev;
+	struct ida ida;
+	struct dentry *debugfs_root;
+	struct ratelimit_state mb_err_rs;
+	struct clk *clk;
+	struct list_head instances;
+};
+
+struct rtk_codec {
+	u32 mode;
+	u32 src_fourcc;
+	u32 dst_fourcc;
+	u32 max_w;
+	u32 max_h;
+};
+
+struct rtk_huff_tab;
+
+struct rtk_params {
+	u8 rot_mode;
+	u8 h264_intra_qp;
+	u8 h264_inter_qp;
+	u8 h264_min_qp;
+	u8 h264_max_qp;
+	u8 h264_disable_deblocking_filter_idc;
+	s8 h264_slice_alpha_c0_offset_div2;
+	s8 h264_slice_beta_offset_div2;
+	bool h264_constrained_intra_pred_flag;
+	s8 h264_chroma_qp_index_offset;
+	u8 h264_profile_idc;
+	u8 h264_level_idc;
+	u8 mpeg2_profile_idc;
+	u8 mpeg2_level_idc;
+	u8 mpeg4_intra_qp;
+	u8 mpeg4_inter_qp;
+	u8 gop_size;
+	int intra_refresh;
+	// TODO: rtk support jpeg or not ?
+	enum v4l2_jpeg_chroma_subsampling jpeg_chroma_subsampling;
+	u8 jpeg_quality;
+	int jpeg_restart_interval;
+	u8 *jpeg_qmat_tab[4];
+	int jpeg_qmat_index[4];
+	int jpeg_huff_dc_index[3];
+	int jpeg_huff_ac_index[3];
+	u32 *jpeg_huff_data;
+	struct rtk_huff_tab *jpeg_huff_tab;
+	int codec_mode;
+	int codec_mode_aux;
+	enum v4l2_mpeg_video_multi_slice_mode slice_mode;
+	u32 framerate;
+	u16 bitrate;
+	u16 vbv_delay;
+	u32 vbv_size;
+	u32 slice_max_bits;
+	u32 slice_max_mb;
+	bool force_ipicture;
+	bool gop_size_changed;
+	bool bitrate_changed;
+	bool framerate_changed;
+	bool h264_intra_qp_changed;
+	bool intra_refresh_changed;
+	bool slice_mode_changed;
+	bool frame_rc_enable;
+	bool mb_rc_enable;
+	bool is_firt_frame;
+	int packedFormat;
+	int streamEndian;
+	int frameEndian;
+	int format;
+	int rgb;
+	int stuffByteEnable;
+};
+
+struct rtk_meta_buffer {
+	struct list_head list;
+	u32 sequence;
+	struct v4l2_timecode timecode;
+	u64 timestamp;
+	unsigned int start;
+	unsigned int end;
+	bool last;
+};
+
+struct rtk_q_data {
+	unsigned int width;
+	unsigned int height;
+	unsigned int bytesperline;
+	unsigned int sizeimage;
+	unsigned int fourcc;
+	struct v4l2_rect rect;
+	unsigned int ori_width;
+	unsigned int ori_height;
+};
+
+struct rtk_axi_sram_info {
+	u32 axi_sram_use;
+	phys_addr_t buf_bit_use;
+	phys_addr_t buf_ip_ac_dc_use;
+	phys_addr_t buf_dbk_y_use;
+	phys_addr_t buf_dbk_c_use;
+	phys_addr_t buf_ovl_use;
+	phys_addr_t buf_btp_use;
+	int remaining;
+	phys_addr_t next_paddr;
+};
+
+enum rtk_ve1_enc_state {
+	RTK_VE1_STATE_ENC_IDLE = 0,
+	RTK_VE1_STATE_ENC_SEQ_INIT,
+	RTK_VE1_STATE_ENC_REG_FBS,
+	RTK_VE1_STATE_ENC_HEADER,
+	RTK_VE1_STATE_ENC_PIC,
+	RTK_VE1_STATE_ENC_PIC_DONE,
+	RTK_VE1_STATE_ENC_TIMEOUT
+};
+
+typedef enum {
+	PACKED_FORMAT_NONE,
+	PACKED_FORMAT_422_YUYV,
+	PACKED_FORMAT_422_UYVY,
+	PACKED_FORMAT_422_YVYU,
+	PACKED_FORMAT_422_VYUY,
+	PACKED_FORMAT_444
+} PackedOutputFormat;
+
+enum { SAMPLE_420 = 0xA,
+       SAMPLE_H422 = 0x9,
+       SAMPLE_V422 = 0x6,
+       SAMPLE_444 = 0x5,
+       SAMPLE_400 = 0x1 };
+
+enum { RTK_JPEG_FORMAT_420 = 0,
+       RTK_JPEG_FORMAT_422 = 1,
+       RTK_JPEG_FORMAT_224 = 2,
+       RTK_JPEG_FORMAT_444 = 3,
+       RTK_JPEG_FORMAT_400 = 4 };
+
+typedef enum {
+	JDI_LITTLE_ENDIAN = 0,
+	JDI_BIG_ENDIAN,
+	JDI_32BIT_LITTLE_ENDIAN,
+	JDI_32BIT_BIG_ENDIAN,
+} EndianMode;
+
+#define JPU_FRAME_ENDIAN JDI_LITTLE_ENDIAN
+#define JPU_STREAM_ENDIAN JDI_LITTLE_ENDIAN
+
+struct rtk_jcodec_ctx;
+
+struct rtk_context_ops {
+	int (*queue_init)(void *priv, struct vb2_queue *src_vq,
+			  struct vb2_queue *dst_vq);
+	int (*reqbufs)(struct rtk_jcodec_ctx *ctx,
+		       struct v4l2_requestbuffers *rb);
+	int (*decide_state)(struct rtk_jcodec_ctx *ctx,
+			    enum rtk_ve1_enc_state *new_state);
+	int (*reg_fbs)(struct rtk_jcodec_ctx *ctx);
+	int (*enc_header)(struct rtk_jcodec_ctx *ctx);
+	int (*start_streaming)(struct rtk_jcodec_ctx *ctx);
+	int (*prepare_run)(struct rtk_jcodec_ctx *ctx);
+	void (*finish_run)(struct rtk_jcodec_ctx *ctx);
+	void (*run_timeout)(struct rtk_jcodec_ctx *ctx);
+	void (*seq_init_work)(struct rtk_jcodec_ctx *ctx);
+	//void (*seq_init_work)(struct work_struct *work);
+	// void (*seq_end_work)(struct work_struct *work);
+	void (*release)(struct rtk_jcodec_ctx *ctx);
+};
+
+struct rtk_frame_buffers {
+	struct rtk_extra_buf buf;
+	struct rtk_meta_buffer meta;
+	u32 type;
+	u32 error;
+};
+
+struct rtk_jcodec_ctx {
+	struct rtk_jcodec_dev *dev;
+	struct mutex buffer_mutex;
+	struct work_struct pic_run_work;
+	struct work_struct seq_init_work;
+	struct work_struct seq_end_work;
+	struct completion completion;
+	const struct rtk_video_device *cvd;
+	const struct rtk_context_ops *ops;
+	const struct rtk_context_common_ops *common_ops;
+	int aborting;
+	int initialized;
+	int streamon_out;
+	int streamon_cap;
+	u32 qsequence;
+	u32 osequence;
+	u32 sequence_offset;
+	struct rtk_q_data q_data[2];
+	enum rtk_jcodec_ctx_type inst_type;
+	const struct rtk_codec *codec;
+	enum v4l2_colorspace colorspace;
+	enum v4l2_xfer_func xfer_func;
+	enum v4l2_ycbcr_encoding ycbcr_enc;
+	enum v4l2_quantization quantization;
+	struct rtk_params params;
+	struct v4l2_ctrl_handler ctrls;
+	struct v4l2_ctrl *h264_profile_ctrl;
+	struct v4l2_ctrl *h264_level_ctrl;
+	struct v4l2_ctrl *mpeg2_profile_ctrl;
+	struct v4l2_ctrl *mpeg2_level_ctrl;
+	struct v4l2_ctrl *mpeg4_profile_ctrl;
+	struct v4l2_ctrl *mpeg4_level_ctrl;
+	struct v4l2_ctrl *mb_err_cnt_ctrl;
+	struct v4l2_fh fh;
+	int gopcounter;
+	int runcounter;
+	int jpeg_ecs_offset;
+	char vpu_header[3][64];
+	int vpu_header_size[3];
+	struct kfifo bitstream_fifo;
+	struct mutex bitstream_mutex;
+	struct rtk_extra_buf bitstream;
+	bool hold;
+	struct rtk_extra_buf parabuf;
+	struct rtk_extra_buf mvcolbuf[RTK_MAX_FRAME_BUFFERS];
+	struct rtk_extra_buf slicebuf;
+	struct rtk_frame_buffers rtk_fbs[RTK_MAX_FRAME_BUFFERS];
+	struct list_head meta_buffer_list;
+	spinlock_t meta_buffer_lock;
+	int num_metas;
+	unsigned int first_frame_sequence;
+	struct rtk_extra_buf workbuf;
+	int min_frame_buffers;
+	int num_frame_buffers;
+	int idx;
+	int reg_idx;
+	struct rtk_axi_sram_info sram_info;
+	int tiled_map_type;
+	u32 bit_stream_param;
+	u32 frm_dis_flg;
+	// TODO: ray refine free fb timing
+	u32 disp_use_flg;
+	u32 frame_mem_ctrl;
+	u32 para_change;
+	int display_idx;
+	struct dentry *debugfs_entry;
+	bool use_bit;
+	bool use_vdoa;
+	// TODO: rtk support vdoa or not ?
+	// struct vdoa_ctx			*vdoa;
+	/*
+	 * wakeup mutex used to serialize encoder stop command and finish_run,
+	 * ensures that finish_run always either flags the last returned buffer
+	 * or wakes up the capture queue to signal EOS afterwards.
+	 */
+	struct mutex wakeup_mutex;
+	enum rtk_ve1_enc_state enc_state;
+	int seq_init_done;
+	int reg_fbs_done;
+	int enc_header_done;
+	u32 rdPtr;
+	u32 wrPtr;
+	u32 enc_min_fb_num;
+	bool parsing_hdr_err;
+
+	struct list_head list;
+};
+
+extern int rtk_jcodec_debug;
+
+#define rtk_jcodec_dbg(level, ctx, fmt, arg...)                                \
+	do {                                                                   \
+		if (rtk_jcodec_debug >= (level))                               \
+			v4l2_dbg((level), rtk_jcodec_debug,                    \
+				 &(ctx)->dev->v4l2_dev, "%u: " fmt,            \
+				 (ctx)->idx, ##arg);                           \
+	} while (0)
+
+#define rtk_jcodec_err(ctx, fmt, arg...)                                       \
+	do {                                                                   \
+		v4l2_err(&(ctx)->dev->v4l2_dev, "%u: " fmt, (ctx)->idx,        \
+			 ##arg);                                               \
+	} while (0)
+
+static inline struct rtk_q_data *rtk_get_q_data(struct rtk_jcodec_ctx *ctx,
+						enum v4l2_buf_type type)
+{
+	if (V4L2_TYPE_IS_OUTPUT(type))
+		return &(ctx->q_data[V4L2_M2M_SRC]);
+	else if (V4L2_TYPE_IS_CAPTURE(type))
+		return &(ctx->q_data[V4L2_M2M_DST]);
+	else
+		return NULL;
+}
+
+static inline unsigned rtk_get_bitstream_payload(struct rtk_jcodec_ctx *ctx)
+{
+	return kfifo_len(&ctx->bitstream_fifo);
+}
+
+/*
+ * The bitstream prefetcher needs to read at least 2 256 byte periods past
+ * the desired bitstream position for all data to reach the decoder.
+ */
+static inline bool rtk_bitstream_can_fetch_past(struct rtk_jcodec_ctx *ctx,
+						unsigned int pos)
+{
+	return (int)(ctx->bitstream_fifo.kfifo.in - ALIGN(pos, 256)) > 512;
+}
+
+bool rtk_bitstream_can_fetch_past(struct rtk_jcodec_ctx *ctx, unsigned int pos);
+
+void rtk_jcodec_m2m_buf_done(struct rtk_jcodec_ctx *ctx,
+			     struct vb2_v4l2_buffer *buf,
+			     enum vb2_buffer_state state);
+
+extern const struct rtk_context_ops rtk_jpeg_decode_ops;
+extern const struct rtk_context_ops rtk_jpeg_encode_ops;
+
+static inline struct rtk_q_data *get_q_data(struct rtk_jcodec_ctx *ctx,
+					    enum v4l2_buf_type type)
+{
+	if (V4L2_TYPE_IS_OUTPUT(type))
+		return &(ctx->q_data[V4L2_M2M_SRC]);
+	else if (V4L2_TYPE_IS_CAPTURE(type))
+		return &(ctx->q_data[V4L2_M2M_DST]);
+	else
+		return NULL;
+}
+
+void rtk_jcodec_write(struct rtk_jcodec_dev *dev, u32 data, u32 reg);
+
+unsigned int rtk_jcodec_read(struct rtk_jcodec_dev *dev, u32 reg);
+
+int rtk_jcodec_hw_reset(struct rtk_jcodec_dev *dev);
+
+void rtk_feed_bitstream(struct rtk_jcodec_ctx *ctx,
+			struct list_head *buffer_list);
+
+void rtk_set_jpeg_compression_quality(struct rtk_jcodec_ctx *ctx, int quality,
+				      int is_rgb);
+
+static inline void rtk_bitstream_end_flag(struct rtk_jcodec_ctx *ctx)
+{
+	ctx->bit_stream_param |= RTK_BIT_STREAM_END_FLAG;
+}
+
+irqreturn_t rtk_jcodec_irq_handler(int irq, void *data);
+
+#endif /* _RTK_JCODEC_DRV_H_ */
--- /dev/null
+++ b/drivers/media/platform/realtek/coda/rtk_jcodec/rtk_jcodec_jpeg.c
@@ -0,0 +1,2778 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Coda multi-standard codec IP - JPEG support functions
+ *
+ * Copyright (C) 2014 Philipp Zabel, Pengutronix
+ */
+
+#include <asm/unaligned.h>
+#include <linux/irqreturn.h>
+#include <linux/kernel.h>
+#include <linux/ktime.h>
+#include <linux/slab.h>
+#include <linux/swab.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-fh.h>
+#include <media/v4l2-jpeg.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+//#include <media/videobuf2-vmalloc.h> //fix vb2_vmalloc_memops build err
+
+#include "rtk_jcodec_drv.h"
+#include "rtk_jcodec_regs.h"
+//#include "trace.h"
+
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+#include "ve_common.h"
+#define METADATA_OFFSET (2048)
+#endif
+
+#define SOI_MARKER 0xffd8
+#define APP9_MARKER 0xffe9
+#define APP14_MARKER 0xffee
+#define DRI_MARKER 0xffdd
+#define DQT_MARKER 0xffdb
+#define DHT_MARKER 0xffc4
+#define SOF_MARKER 0xffc0
+#define SOS_MARKER 0xffda
+#define EOI_MARKER 0xffd9
+
+#define RTK_REG_BIT_RD_PTR(x) (BIT_RD_PTR + 8 * (x))
+#define RTK_REG_BIT_WR_PTR(x) (BIT_WR_PTR + 8 * (x))
+
+struct rtk_huff_tab {
+	u8 luma_dc[16 + 12];
+	u8 chroma_dc[16 + 12];
+	u8 luma_ac[16 + 162];
+	u8 chroma_ac[16 + 162];
+
+	/* DC Luma, DC Chroma, AC Luma, AC Chroma */
+	s16 min[4 * 16];
+	s16 max[4 * 16];
+	s8 ptr[4 * 16];
+};
+
+#define RTK_JPEG_ENC_HUFF_DATA_SIZE (256 + 256 + 16 + 16)
+
+/*
+ * Typical Huffman tables for 8-bit precision luminance and
+ * chrominance from JPEG ITU-T.81 (ISO/IEC 10918-1) Annex K.3
+ */
+
+static const unsigned char luma_dc[16 + 12] = {
+	/* bits */
+	0x00,
+	0x01,
+	0x05,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	/* values */
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x04,
+	0x05,
+	0x06,
+	0x07,
+	0x08,
+	0x09,
+	0x0a,
+	0x0b,
+};
+
+static const unsigned char chroma_dc[16 + 12] = {
+	/* bits */
+	0x00,
+	0x03,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	/* values */
+	0x00,
+	0x01,
+	0x02,
+	0x03,
+	0x04,
+	0x05,
+	0x06,
+	0x07,
+	0x08,
+	0x09,
+	0x0a,
+	0x0b,
+};
+
+static const unsigned char luma_ac[16 + 162 + 2] = {
+	/* bits */
+	0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04,
+	0x00, 0x00, 0x01, 0x7d,
+	/* values */
+	0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06,
+	0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,
+	0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72,
+	0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,
+	0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45,
+	0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
+	0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75,
+	0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
+	0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3,
+	0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
+	0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9,
+	0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
+	0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4,
+	0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, /* padded to 32-bit */
+};
+
+static const unsigned char chroma_ac[16 + 162 + 2] = {
+	/* bits */
+	0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04,
+	0x00, 0x01, 0x02, 0x77,
+	/* values */
+	0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41,
+	0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
+	0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1,
+	0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,
+	0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44,
+	0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
+	0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74,
+	0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
+	0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a,
+	0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
+	0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
+	0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
+	0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4,
+	0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, /* padded to 32-bit */
+};
+
+/*
+ * Quantization tables for luminance and chrominance components in
+ * zig-zag scan order from the Freescale i.MX VPU libraries
+ */
+
+static unsigned char luma_q[64] = {
+	0x06, 0x04, 0x04, 0x04, 0x05, 0x04, 0x06, 0x05, 0x05, 0x06, 0x09,
+	0x06, 0x05, 0x06, 0x09, 0x0b, 0x08, 0x06, 0x06, 0x08, 0x0b, 0x0c,
+	0x0a, 0x0a, 0x0b, 0x0a, 0x0a, 0x0c, 0x10, 0x0c, 0x0c, 0x0c, 0x0c,
+	0x0c, 0x0c, 0x10, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+	0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+	0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+};
+
+static unsigned char chroma_q[64] = {
+	0x07, 0x07, 0x07, 0x0d, 0x0c, 0x0d, 0x18, 0x10, 0x10, 0x18, 0x14,
+	0x0e, 0x0e, 0x0e, 0x14, 0x14, 0x0e, 0x0e, 0x0e, 0x0e, 0x14, 0x11,
+	0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x11, 0x11, 0x0c, 0x0c, 0x0c, 0x0c,
+	0x0c, 0x0c, 0x11, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+	0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+	0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
+};
+
+static const unsigned char jpeg_app14[] = { 0xFF, 0xEE, 0x00, 0x0E, 0x41, 0x64,
+					    0x6F, 0x62, 0x65, 0x00, 0x64, 0x00,
+					    0x00, 0x00, 0x00, 0x00 };
+static const unsigned char width_align[] = {
+	[RTK_JPEG_FORMAT_420] = 16, [RTK_JPEG_FORMAT_422] = 16,
+	[RTK_JPEG_FORMAT_224] = 8,  [RTK_JPEG_FORMAT_444] = 8,
+	[RTK_JPEG_FORMAT_400] = 8,
+};
+
+static const unsigned char height_align[] = {
+	[RTK_JPEG_FORMAT_420] = 16, [RTK_JPEG_FORMAT_422] = 8,
+	[RTK_JPEG_FORMAT_224] = 16, [RTK_JPEG_FORMAT_444] = 8,
+	[RTK_JPEG_FORMAT_400] = 8,
+};
+
+static int rtk_jpeg_chroma_format(u32 pixfmt)
+{
+	switch (pixfmt) {
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_NV12:
+		return RTK_JPEG_FORMAT_420;
+	case V4L2_PIX_FMT_YUV422P:
+	case V4L2_PIX_FMT_NV16:
+		return RTK_JPEG_FORMAT_422;
+	case V4L2_PIX_FMT_YUV444M:
+	case V4L2_PIX_FMT_NV24:
+	case V4L2_PIX_FMT_RGB24:
+		return RTK_JPEG_FORMAT_444;
+	case V4L2_PIX_FMT_GREY:
+		return RTK_JPEG_FORMAT_400;
+	}
+	return -EINVAL;
+}
+
+bool rtk_jpeg_check_buffer(struct rtk_jcodec_ctx *ctx, struct vb2_buffer *vb)
+{
+	void *vaddr = vb2_plane_vaddr(vb, 0);
+	u16 soi, eoi;
+	int len, i;
+
+	soi = be16_to_cpup((__be16 *)vaddr);
+	if (soi != SOI_MARKER)
+		return false;
+
+	len = vb2_get_plane_payload(vb, 0);
+	vaddr += len - 2;
+	for (i = 0; i < 32; i++) {
+		eoi = be16_to_cpup((__be16 *)(vaddr - i));
+		if (eoi == EOI_MARKER) {
+			if (i > 0)
+				vb2_set_plane_payload(vb, 0, len - i);
+			return true;
+		}
+	}
+
+	return false;
+}
+
+static int rtk_jpeg_gen_dec_huff_tab(struct rtk_jcodec_ctx *ctx, int tab_num);
+
+int rtk_jpeg_decode_header(struct rtk_jcodec_ctx *ctx, struct vb2_buffer *vb)
+{
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	u8 *buf = vb2_plane_vaddr(vb, 0);
+	size_t len = vb2_get_plane_payload(vb, 0);
+	struct v4l2_jpeg_scan_header scan_header;
+	struct v4l2_jpeg_reference quantization_tables[4] = {};
+	struct v4l2_jpeg_reference huffman_tables[4] = {};
+	struct v4l2_jpeg_header header = {
+		.scan = &scan_header,
+		.quantization_tables = quantization_tables,
+		.huffman_tables = huffman_tables,
+	};
+	struct rtk_q_data *q_data_src;
+	struct rtk_huff_tab *huff_tab;
+	int i, j, ret;
+	int sampleFactor;
+
+	size_t print_len = len < 30 ? len : 30;
+	char hex_buf[90];
+	memset(hex_buf, 0, sizeof(hex_buf));
+	for (i = 0; i < print_len; i++) {
+		snprintf(hex_buf + i * 3, 4, "%02x ", buf[i]);
+	}
+	rtk_jcodec_dbg(2, ctx, "First %zu bytes: %s\n", print_len,
+		       hex_buf); //print bs buffer
+
+	ret = v4l2_jpeg_parse_header(buf, len, &header);
+	if (ret < 0) {
+		v4l2_err(&dev->v4l2_dev, "failed to parse header\n");
+		return ret;
+	}
+
+	ctx->params.jpeg_restart_interval = header.restart_interval;
+
+	/* check frame header */
+	if (header.frame.height > ctx->codec->max_h ||
+	    header.frame.width > ctx->codec->max_w) {
+		v4l2_err(&dev->v4l2_dev, "invalid dimensions: %dx%d\n",
+			 header.frame.width, header.frame.height);
+		return -EINVAL;
+	}
+
+	if (header.app14_tf == V4L2_JPEG_APP14_TF_CMYK_RGB) {
+		ctx->params.rgb = 1;
+	} else {
+		ctx->params.rgb = 0;
+	}
+
+	for (i = 0; i < scan_header.num_components; i++) {
+		ctx->params.jpeg_qmat_index[i] =
+			header.frame.component[i].quantization_table_selector;
+
+		rtk_jcodec_dbg(2, ctx, "  Component %d:\n", i);
+		rtk_jcodec_dbg(2, ctx, "  ID: %d\n",
+			       header.frame.component[i].component_identifier);
+		rtk_jcodec_dbg(
+			2, ctx, "  Sampling Factor: H=%d, V=%d\n",
+			header.frame.component[i].horizontal_sampling_factor,
+			header.frame.component[i].vertical_sampling_factor);
+	}
+
+	if (scan_header.num_components == 1)
+		sampleFactor = SAMPLE_400;
+	else
+		sampleFactor =
+			((header.frame.component[0].horizontal_sampling_factor &
+			  3)
+			 << 2) |
+			(header.frame.component[0].vertical_sampling_factor &
+			 3);
+
+	switch (sampleFactor) {
+	case SAMPLE_420:
+		ctx->params.format = RTK_JPEG_FORMAT_420;
+		break;
+	case SAMPLE_H422:
+		ctx->params.format = RTK_JPEG_FORMAT_422;
+		break;
+	case SAMPLE_V422:
+		ctx->params.format = RTK_JPEG_FORMAT_224;
+		break;
+	case SAMPLE_444:
+		ctx->params.format = RTK_JPEG_FORMAT_444;
+		break;
+	default: // 4:0:0
+		ctx->params.format = RTK_JPEG_FORMAT_400;
+	}
+
+	q_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+
+	if (header.frame.height != q_data_src->height ||
+	    header.frame.width != q_data_src->width) {
+		v4l2_err(
+			&dev->v4l2_dev,
+			" frame dimensions don't match format: %dx%d q_data_src %dx%d\n",
+			header.frame.width, header.frame.height,
+			q_data_src->width, q_data_src->height);
+
+		return -EINVAL;
+	}
+
+	if (header.frame.num_components != 3) {
+		v4l2_err(&dev->v4l2_dev,
+			 "unsupported number of components: %d\n",
+			 header.frame.num_components);
+		return -EINVAL;
+	}
+
+	/* install quantization tables */
+	if (quantization_tables[3].start) {
+		v4l2_err(&dev->v4l2_dev,
+			 "only 3 quantization tables supported\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < 4; i++) {
+		if (!quantization_tables[i].start)
+			continue;
+		if (quantization_tables[i].length != 64) {
+			v4l2_err(&dev->v4l2_dev,
+				 "only 8-bit quantization tables supported\n");
+			continue;
+		}
+		if (!ctx->params.jpeg_qmat_tab[i]) {
+			ctx->params.jpeg_qmat_tab[i] = kmalloc(64, GFP_KERNEL);
+			if (!ctx->params.jpeg_qmat_tab[i])
+				return -ENOMEM;
+		}
+		memcpy(ctx->params.jpeg_qmat_tab[i],
+		       quantization_tables[i].start, 64);
+	}
+
+	/* install Huffman tables */
+	for (i = 0; i < 4; i++) {
+		if (!huffman_tables[i].start) {
+			rtk_jcodec_dbg(2, ctx, "missing Huffman table %d \n",
+				       i);
+			//return -EINVAL;
+			continue;
+		}
+		/* AC tables should be between 17 -> 178, DC between 17 -> 28 */
+		if (huffman_tables[i].length < 17 ||
+		    huffman_tables[i].length > 178 ||
+		    ((i & 2) == 0 && huffman_tables[i].length > 28)) {
+			v4l2_err(&dev->v4l2_dev,
+				 "invalid Huffman table %d length: %zu\n", i,
+				 huffman_tables[i].length);
+			return -EINVAL;
+		}
+	}
+	huff_tab = ctx->params.jpeg_huff_tab;
+	if (!huff_tab) {
+		huff_tab = kzalloc(sizeof(struct rtk_huff_tab), GFP_KERNEL);
+		if (!huff_tab)
+			return -ENOMEM;
+		ctx->params.jpeg_huff_tab = huff_tab;
+	}
+
+	memset(huff_tab, 0, sizeof(*huff_tab));
+	if (huffman_tables[0].start) {
+		memcpy(huff_tab->luma_dc, huffman_tables[0].start,
+		       huffman_tables[0].length);
+	} else {
+		memcpy(huff_tab->luma_dc, luma_dc, sizeof(luma_dc));
+	}
+
+	if (huffman_tables[1].start) {
+		memcpy(huff_tab->chroma_dc, huffman_tables[1].start,
+		       huffman_tables[1].length);
+	} else {
+		memcpy(huff_tab->chroma_dc, chroma_dc, sizeof(chroma_dc) - 2);
+	}
+
+	if (huffman_tables[2].start) {
+		memcpy(huff_tab->luma_ac, huffman_tables[2].start,
+		       huffman_tables[2].length);
+	} else {
+		memcpy(huff_tab->luma_ac, luma_ac, sizeof(luma_ac));
+	}
+
+	if (huffman_tables[3].start) {
+		memcpy(huff_tab->chroma_ac, huffman_tables[3].start,
+		       huffman_tables[3].length);
+	} else {
+		memcpy(huff_tab->chroma_ac, chroma_ac, sizeof(chroma_ac) - 2);
+	}
+
+	/* check scan header */
+	for (i = 0; i < scan_header.num_components; i++) {
+		struct v4l2_jpeg_scan_component_spec *scan_component;
+
+		scan_component = &scan_header.component[i];
+		for (j = 0; j < header.frame.num_components; j++) {
+			if (header.frame.component[j].component_identifier ==
+			    scan_component->component_selector)
+				break;
+		}
+		if (j == header.frame.num_components)
+			continue;
+
+		ctx->params.jpeg_huff_dc_index[j] =
+			scan_component->dc_entropy_coding_table_selector;
+		ctx->params.jpeg_huff_ac_index[j] =
+			scan_component->ac_entropy_coding_table_selector;
+	}
+
+	/* Generate Huffman table information */
+	for (i = 0; i < 4; i++)
+		rtk_jpeg_gen_dec_huff_tab(ctx, i);
+
+	/* start of entropy coded segment */
+	ctx->jpeg_ecs_offset = header.ecs_offset;
+
+	switch (header.frame.subsampling) {
+	case V4L2_JPEG_CHROMA_SUBSAMPLING_420:
+	case V4L2_JPEG_CHROMA_SUBSAMPLING_422:
+	case V4L2_JPEG_CHROMA_SUBSAMPLING_444:
+		ctx->params.jpeg_chroma_subsampling = header.frame.subsampling;
+		break;
+	default:
+		v4l2_err(&dev->v4l2_dev, "chroma subsampling not supported: %d",
+			 header.frame.subsampling);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static inline void rtk_jpeg_write_huff_values(struct rtk_jcodec_dev *dev,
+					      u8 *bits, int num_values)
+{
+	s8 *values = (s8 *)(bits + 16);
+	int huff_length, i;
+
+	for (huff_length = 0, i = 0; i < 16; i++)
+		huff_length += bits[i];
+	for (i = huff_length; i < num_values; i++)
+		values[i] = -1;
+	for (i = 0; i < num_values; i++)
+		rtk_jcodec_write(dev, (s32)values[i], RTK_REG_JPEG_HUFF_DATA);
+}
+
+static int rtk_jpeg_dec_huff_setup(struct rtk_jcodec_ctx *ctx)
+{
+	struct rtk_huff_tab *huff_tab = ctx->params.jpeg_huff_tab;
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	s16 *huff_min = huff_tab->min;
+	s16 *huff_max = huff_tab->max;
+	s8 *huff_ptr = huff_tab->ptr;
+	int i;
+
+	/* MIN Tables */
+	rtk_jcodec_write(dev, 0x003, RTK_REG_JPEG_HUFF_CTRL);
+	rtk_jcodec_write(dev, 0x000, RTK_REG_JPEG_HUFF_ADDR);
+	for (i = 0; i < 4 * 16; i++)
+		rtk_jcodec_write(dev, (s32)huff_min[i], RTK_REG_JPEG_HUFF_DATA);
+
+	/* MAX Tables */
+	rtk_jcodec_write(dev, 0x403, RTK_REG_JPEG_HUFF_CTRL);
+	rtk_jcodec_write(dev, 0x440, RTK_REG_JPEG_HUFF_ADDR);
+	for (i = 0; i < 4 * 16; i++)
+		rtk_jcodec_write(dev, (s32)huff_max[i], RTK_REG_JPEG_HUFF_DATA);
+
+	/* PTR Tables */
+	rtk_jcodec_write(dev, 0x803, RTK_REG_JPEG_HUFF_CTRL);
+	rtk_jcodec_write(dev, 0x880, RTK_REG_JPEG_HUFF_ADDR);
+	for (i = 0; i < 4 * 16; i++)
+		rtk_jcodec_write(dev, (s32)huff_ptr[i], RTK_REG_JPEG_HUFF_DATA);
+
+	/* VAL Tables: DC Luma, DC Chroma, AC Luma, AC Chroma */
+	rtk_jcodec_write(dev, 0xc03, RTK_REG_JPEG_HUFF_CTRL);
+	rtk_jpeg_write_huff_values(dev, huff_tab->luma_dc, 12);
+	rtk_jpeg_write_huff_values(dev, huff_tab->chroma_dc, 12);
+	rtk_jpeg_write_huff_values(dev, huff_tab->luma_ac, 162);
+	rtk_jpeg_write_huff_values(dev, huff_tab->chroma_ac, 162);
+	rtk_jcodec_write(dev, 0x000, RTK_REG_JPEG_HUFF_CTRL);
+	return 0;
+}
+
+static inline void rtk_jpeg_write_qmat_tab(struct rtk_jcodec_dev *dev, u8 *qmat,
+					   int index)
+{
+	int i;
+
+	rtk_jcodec_write(dev, index | 0x3, RTK_REG_JPEG_QMAT_CTRL);
+	for (i = 0; i < 64; i++)
+		rtk_jcodec_write(dev, qmat[i], RTK_REG_JPEG_QMAT_DATA);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_QMAT_CTRL);
+}
+
+static void rtk_jpeg_qmat_setup(struct rtk_jcodec_ctx *ctx)
+{
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	int *qmat_index = ctx->params.jpeg_qmat_index;
+	u8 **qmat_tab = ctx->params.jpeg_qmat_tab;
+
+	rtk_jpeg_write_qmat_tab(dev, qmat_tab[qmat_index[0]], 0x00);
+	rtk_jpeg_write_qmat_tab(dev, qmat_tab[qmat_index[1]], 0x40);
+	rtk_jpeg_write_qmat_tab(dev, qmat_tab[qmat_index[2]], 0x80);
+}
+
+static void rtk_jpeg_dec_bbc_gbu_setup(struct rtk_jcodec_ctx *ctx,
+				       struct vb2_buffer *buf, u32 ecs_offset)
+{
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	int page_ptr, word_ptr, bit_ptr;
+	u32 bbc_base_addr, end_addr;
+	int bbc_cur_pos;
+	int ret, val;
+
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+	if (ctx->inst_type == RTK_JCODEC_CTX_DECODER &&
+	    V4L2_TYPE_IS_CAPTURE(buf->type))
+		bbc_base_addr =
+			vb2_dma_contig_plane_dma_addr(buf, 0) + METADATA_OFFSET;
+	else
+		bbc_base_addr = vb2_dma_contig_plane_dma_addr(buf, 0);
+#else
+	bbc_base_addr = vb2_dma_contig_plane_dma_addr(buf, 0);
+#endif
+
+	end_addr = bbc_base_addr + vb2_get_plane_payload(buf, 0);
+
+	page_ptr = ecs_offset / 256;
+	word_ptr = (ecs_offset % 256) / 4;
+
+	if (page_ptr & 1)
+		word_ptr += 64;
+	bit_ptr = (ecs_offset % 4) * 8;
+	if (word_ptr & 1)
+		bit_ptr += 32;
+	word_ptr &= ~0x1;
+
+	rtk_jcodec_write(dev, end_addr, RTK_REG_JPEG_BBC_WR_PTR);
+	rtk_jcodec_write(dev, bbc_base_addr, RTK_REG_JPEG_BBC_BAS_ADDR);
+
+	/* Leave 3 256-byte page margin to avoid a BBC interrupt */
+	rtk_jcodec_write(dev, end_addr + 256 * 3 + 256,
+			 RTK_REG_JPEG_BBC_END_ADDR);
+	val = DIV_ROUND_UP(vb2_plane_size(buf, 0), 256) + 3;
+	rtk_jcodec_write(dev, BIT(31) | val, RTK_REG_JPEG_BBC_STRM_CTRL);
+
+	bbc_cur_pos = page_ptr;
+	rtk_jcodec_write(dev, bbc_cur_pos, RTK_REG_JPEG_BBC_CUR_POS);
+	rtk_jcodec_write(dev, bbc_base_addr + (bbc_cur_pos << 8),
+			 RTK_REG_JPEG_BBC_EXT_ADDR);
+	rtk_jcodec_write(dev, (bbc_cur_pos & 1) << 6,
+			 RTK_REG_JPEG_BBC_INT_ADDR);
+	rtk_jcodec_write(
+		dev, 64,
+		RTK_REG_JPEG_BBC_DATA_CNT); // 64 * 4 byte == 32 * 8 byte
+	rtk_jcodec_write(dev, (ctx->params.streamEndian << 1) | 0,
+			 RTK_REG_JPEG_BBC_COMMAND);
+	do {
+		ret = rtk_jcodec_read(dev, RTK_REG_JPEG_BBC_BUSY);
+	} while (ret == 1);
+
+	bbc_cur_pos++;
+	rtk_jcodec_write(dev, bbc_cur_pos, RTK_REG_JPEG_BBC_CUR_POS);
+	rtk_jcodec_write(dev, bbc_base_addr + (bbc_cur_pos << 8),
+			 RTK_REG_JPEG_BBC_EXT_ADDR);
+	rtk_jcodec_write(dev, (bbc_cur_pos & 1) << 6,
+			 RTK_REG_JPEG_BBC_INT_ADDR);
+	rtk_jcodec_write(
+		dev, 64,
+		RTK_REG_JPEG_BBC_DATA_CNT); // 64 * 4 byte == 32 * 8 byte
+	rtk_jcodec_write(dev, (ctx->params.streamEndian << 1) | 0,
+			 RTK_REG_JPEG_BBC_COMMAND);
+	do {
+		ret = rtk_jcodec_read(dev, RTK_REG_JPEG_BBC_BUSY);
+	} while (ret == 1);
+
+	bbc_cur_pos++;
+	rtk_jcodec_write(dev, bbc_cur_pos, RTK_REG_JPEG_BBC_CUR_POS);
+	rtk_jcodec_write(dev, 1, RTK_REG_JPEG_BBC_CTRL);
+
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_GBU_TT_CNT);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_GBU_TT_CNT + 4);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_PIC_ERRMB);
+	rtk_jcodec_write(dev, word_ptr, RTK_REG_JPEG_GBU_WD_PTR);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_GBU_BBSR);
+	rtk_jcodec_write(dev, 127, RTK_REG_JPEG_GBU_BBER);
+	if (page_ptr & 1) {
+		rtk_jcodec_write(dev, 0, RTK_REG_JPEG_GBU_BBIR);
+		rtk_jcodec_write(dev, 0, RTK_REG_JPEG_GBU_BBHR);
+	} else {
+		rtk_jcodec_write(dev, 64, RTK_REG_JPEG_GBU_BBIR);
+		rtk_jcodec_write(dev, 64, RTK_REG_JPEG_GBU_BBHR);
+	}
+	rtk_jcodec_write(dev, 4, RTK_REG_JPEG_GBU_CTRL);
+	rtk_jcodec_write(dev, bit_ptr, RTK_REG_JPEG_GBU_FF_RPTR);
+	rtk_jcodec_write(dev, 3, RTK_REG_JPEG_GBU_CTRL);
+}
+
+static const int bus_req_num[] = {
+	[RTK_JPEG_FORMAT_420] = 2, [RTK_JPEG_FORMAT_422] = 3,
+	[RTK_JPEG_FORMAT_224] = 3, [RTK_JPEG_FORMAT_444] = 4,
+	[RTK_JPEG_FORMAT_400] = 4,
+};
+
+#define MCU_INFO(mcu_block_num, comp_num, comp0_info, comp1_info, comp2_info)  \
+	(((mcu_block_num) << RTK_JPEG_MCU_BLOCK_NUM_OFFSET) |                  \
+	 ((comp_num) << RTK_JPEG_COMP_NUM_OFFSET) |                            \
+	 ((comp0_info) << RTK_JPEG_COMP0_INFO_OFFSET) |                        \
+	 ((comp1_info) << RTK_JPEG_COMP1_INFO_OFFSET) |                        \
+	 ((comp2_info) << RTK_JPEG_COMP2_INFO_OFFSET))
+
+static const u32 mcu_info[] = {
+	[RTK_JPEG_FORMAT_420] = MCU_INFO(6, 3, 10, 5, 5),
+	[RTK_JPEG_FORMAT_422] = MCU_INFO(4, 3, 9, 5, 5),
+	[RTK_JPEG_FORMAT_224] = MCU_INFO(4, 3, 6, 5, 5),
+	[RTK_JPEG_FORMAT_444] = MCU_INFO(3, 3, 5, 5, 5),
+	[RTK_JPEG_FORMAT_400] = MCU_INFO(1, 1, 5, 0, 0),
+};
+/*
+ * Convert Huffman table specifcations to tables of codes and code lengths.
+ * For reference, see JPEG ITU-T.81 (ISO/IEC 10918-1) [1]
+ *
+ * [1] https://www.w3.org/Graphics/JPEG/itu-t81.pdf
+ */
+static int rtk_jpeg_gen_enc_huff_tab(struct rtk_jcodec_ctx *ctx, int tab_num,
+				     int *ehufsi, int *ehufco, int is_rgb)
+{
+	int i, j, k, lastk, si, code, maxsymbol;
+	const u8 *bits, *huffval;
+	struct {
+		int size[256];
+		int code[256];
+	} * huff;
+
+	static const unsigned char *huff_tabs[4];
+	if (!is_rgb) {
+		huff_tabs[0] = luma_dc;
+		huff_tabs[1] = luma_ac;
+		huff_tabs[2] = chroma_dc;
+		huff_tabs[3] = chroma_ac;
+
+	} else {
+		huff_tabs[0] = luma_dc;
+		huff_tabs[1] = luma_ac;
+		huff_tabs[2] = luma_dc;
+		huff_tabs[3] = luma_ac;
+	}
+
+	int ret = -EINVAL;
+
+	huff = kzalloc(sizeof(*huff), GFP_KERNEL);
+	if (!huff)
+		return -ENOMEM;
+
+	bits = huff_tabs[tab_num];
+	huffval = huff_tabs[tab_num] + 16;
+
+	maxsymbol = tab_num & 1 ? 256 : 16;
+
+	/* Figure C.1 - Generation of table of Huffman code sizes */
+	k = 0;
+	for (i = 1; i <= 16; i++) {
+		j = bits[i - 1];
+		if (k + j > maxsymbol)
+			goto out;
+		while (j--)
+			huff->size[k++] = i;
+	}
+	lastk = k;
+
+	/* Figure C.2 - Generation of table of Huffman codes */
+	k = 0;
+	code = 0;
+	si = huff->size[0];
+	while (k < lastk) {
+		while (huff->size[k] == si) {
+			huff->code[k++] = code;
+			code++;
+		}
+		if (code >= (1 << si))
+			goto out;
+		code <<= 1;
+		si++;
+	}
+
+	/* Figure C.3 - Ordering procedure for encoding procedure code tables */
+	for (k = 0; k < lastk; k++) {
+		i = huffval[k];
+		if (i >= maxsymbol || ehufsi[i])
+			goto out;
+		ehufco[i] = huff->code[k];
+		ehufsi[i] = huff->size[k];
+	}
+
+	ret = 0;
+out:
+	kfree(huff);
+	return ret;
+}
+
+#define DC_TABLE_INDEX0 0
+#define AC_TABLE_INDEX0 1
+#define DC_TABLE_INDEX1 2
+#define AC_TABLE_INDEX1 3
+
+static u8 *rtk_jpeg_get_huff_bits(struct rtk_jcodec_ctx *ctx, int tab_num)
+{
+	struct rtk_huff_tab *huff_tab = ctx->params.jpeg_huff_tab;
+
+	if (!huff_tab)
+		return NULL;
+
+	switch (tab_num) {
+	case DC_TABLE_INDEX0:
+		return huff_tab->luma_dc;
+	case AC_TABLE_INDEX0:
+		return huff_tab->luma_ac;
+	case DC_TABLE_INDEX1:
+		return huff_tab->chroma_dc;
+	case AC_TABLE_INDEX1:
+		return huff_tab->chroma_ac;
+	}
+
+	return NULL;
+}
+
+static int rtk_jpeg_gen_dec_huff_tab(struct rtk_jcodec_ctx *ctx, int tab_num)
+{
+	int ptr_cnt = 0, huff_code = 0, zero_flag = 0, data_flag = 0;
+	u8 *huff_bits;
+	s16 *huff_max;
+	s16 *huff_min;
+	s8 *huff_ptr;
+	int ofs;
+	int i;
+
+	huff_bits = rtk_jpeg_get_huff_bits(ctx, tab_num);
+	if (!huff_bits)
+		return -EINVAL;
+
+	/* DC/AC Luma, DC/AC Chroma -> DC Luma/Chroma, AC Luma/Chroma */
+	ofs = ((tab_num & 1) << 1) | ((tab_num >> 1) & 1);
+	ofs *= 16;
+
+	huff_ptr = ctx->params.jpeg_huff_tab->ptr + ofs;
+	huff_max = ctx->params.jpeg_huff_tab->max + ofs;
+	huff_min = ctx->params.jpeg_huff_tab->min + ofs;
+
+	for (i = 0; i < 16; i++) {
+		if (huff_bits[i]) {
+			huff_ptr[i] = ptr_cnt;
+			ptr_cnt += huff_bits[i];
+			huff_min[i] = huff_code;
+			huff_max[i] = huff_code + (huff_bits[i] - 1);
+			data_flag = 1;
+			zero_flag = 0;
+		} else {
+			huff_ptr[i] = -1;
+			huff_min[i] = -1;
+			huff_max[i] = -1;
+			zero_flag = 1;
+		}
+
+		if (data_flag == 1) {
+			if (zero_flag == 1)
+				huff_code <<= 1;
+			else
+				huff_code = (huff_max[i] + 1) << 1;
+		}
+	}
+
+	return 0;
+}
+
+static int rtk_jpeg_load_huff_tab(struct rtk_jcodec_ctx *ctx, int is_rgb)
+{
+	struct {
+		int size[4][256];
+		int code[4][256];
+	} * huff;
+	u32 *huff_data;
+	int i, j;
+	int ret;
+
+	huff = kzalloc(sizeof(*huff), GFP_KERNEL);
+	if (!huff)
+		return -ENOMEM;
+
+	/* Generate all four (luma/chroma DC/AC) code/size lookup tables */
+	for (i = 0; i < 4; i++) {
+		ret = rtk_jpeg_gen_enc_huff_tab(ctx, i, huff->size[i],
+						huff->code[i], is_rgb);
+		if (ret)
+			goto out;
+	}
+
+	if (!ctx->params.jpeg_huff_data) {
+		ctx->params.jpeg_huff_data = kzalloc(
+			sizeof(u32) * RTK_JPEG_ENC_HUFF_DATA_SIZE, GFP_KERNEL);
+		if (!ctx->params.jpeg_huff_data) {
+			ret = -ENOMEM;
+			goto out;
+		}
+	}
+	huff_data = ctx->params.jpeg_huff_data;
+
+	for (j = 0; j < 4; j++) {
+		/* Store Huffman lookup tables in AC0, AC1, DC0, DC1 order */
+		int t = (j == 0) ? AC_TABLE_INDEX0 :
+				   (j == 1) ?
+				   AC_TABLE_INDEX1 :
+				   (j == 2) ? DC_TABLE_INDEX0 : DC_TABLE_INDEX1;
+		/* DC tables only have 16 entries */
+		int len = (j < 2) ? 256 : 16;
+
+		for (i = 0; i < len; i++) {
+			if (huff->size[t][i] == 0 && huff->code[t][i] == 0)
+				*(huff_data++) = 0;
+			else
+				*(huff_data++) =
+					((huff->size[t][i] - 1) << 16) |
+					huff->code[t][i];
+		}
+	}
+
+	ret = 0;
+out:
+	kfree(huff);
+	return ret;
+}
+
+static void rtk_jpeg_write_huff_tab(struct rtk_jcodec_ctx *ctx)
+{
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	u32 *huff_data = ctx->params.jpeg_huff_data;
+	int i;
+
+	/* Write Huffman size/code lookup tables in AC0, AC1, DC0, DC1 order */
+	rtk_jcodec_write(dev, 0x3, RTK_REG_JPEG_HUFF_CTRL);
+	for (i = 0; i < RTK_JPEG_ENC_HUFF_DATA_SIZE; i++)
+		rtk_jcodec_write(dev, *(huff_data++), RTK_REG_JPEG_HUFF_DATA);
+	rtk_jcodec_write(dev, 0x0, RTK_REG_JPEG_HUFF_CTRL);
+}
+
+static inline void rtk_jpeg_write_qmat_quotients(struct rtk_jcodec_dev *dev,
+						 u8 *qmat, int index)
+{
+	int i;
+
+	rtk_jcodec_write(dev, index | 0x3, RTK_REG_JPEG_QMAT_CTRL);
+	for (i = 0; i < 64; i++)
+		rtk_jcodec_write(dev, 0x80000 / qmat[i],
+				 RTK_REG_JPEG_QMAT_DATA);
+	rtk_jcodec_write(dev, index, RTK_REG_JPEG_QMAT_CTRL);
+}
+
+static void rtk_jpeg_load_qmat_tab(struct rtk_jcodec_ctx *ctx)
+{
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	u8 *luma_tab;
+	u8 *chroma_tab;
+
+	struct rtk_q_data *q_data_src;
+	int chroma_format;
+	q_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+	chroma_format = rtk_jpeg_chroma_format(q_data_src->fourcc);
+
+	luma_tab = ctx->params.jpeg_qmat_tab[0];
+	if (!luma_tab)
+		luma_tab = luma_q;
+
+	chroma_tab = ctx->params.jpeg_qmat_tab[1];
+
+	if (!chroma_tab) {
+		if (chroma_format == RTK_JPEG_FORMAT_444 &&
+		    q_data_src->fourcc == V4L2_PIX_FMT_RGB24) {
+			chroma_tab = luma_q;
+		} else {
+			chroma_tab = chroma_q;
+		}
+	}
+
+	rtk_jpeg_write_qmat_quotients(dev, luma_tab, 0x00);
+	rtk_jpeg_write_qmat_quotients(dev, chroma_tab, 0x40);
+	rtk_jpeg_write_qmat_quotients(dev, chroma_tab, 0x80);
+}
+
+struct rtk_jpeg_stream {
+	u8 *curr;
+	u8 *end;
+};
+
+static inline int rtk_jpeg_put_byte(u8 byte, struct rtk_jpeg_stream *stream)
+{
+	if (stream->curr >= stream->end)
+		return -EINVAL;
+
+	*stream->curr++ = byte;
+
+	return 0;
+}
+
+static inline int rtk_jpeg_put_word(u16 word, struct rtk_jpeg_stream *stream)
+{
+	if (stream->curr + sizeof(__be16) > stream->end)
+		return -EINVAL;
+
+	put_unaligned_be16(word, stream->curr);
+	stream->curr += sizeof(__be16);
+
+	return 0;
+}
+
+static int rtk_jpeg_put_table(u16 marker, u8 index, const u8 *table, size_t len,
+			      struct rtk_jpeg_stream *stream)
+{
+	int i, ret;
+
+	ret = rtk_jpeg_put_word(marker, stream);
+	if (ret < 0)
+		return ret;
+	ret = rtk_jpeg_put_word(3 + len, stream);
+	if (ret < 0)
+		return ret;
+	ret = rtk_jpeg_put_byte(index, stream);
+	for (i = 0; i < len && ret == 0; i++)
+		ret = rtk_jpeg_put_byte(table[i], stream);
+
+	return ret;
+}
+
+static int rtk_jpeg_define_quantization_table(struct rtk_jcodec_ctx *ctx,
+					      u8 index,
+					      struct rtk_jpeg_stream *stream)
+{
+	return rtk_jpeg_put_table(DQT_MARKER, index,
+				  ctx->params.jpeg_qmat_tab[index], 64, stream);
+}
+
+static int rtk_jpeg_define_huffman_table(u8 index, const u8 *table, size_t len,
+					 struct rtk_jpeg_stream *stream)
+{
+	return rtk_jpeg_put_table(DHT_MARKER, index, table, len, stream);
+}
+
+static int rtk_jpeg_encode_header(struct rtk_jcodec_ctx *ctx, int len, u8 *buf)
+{
+	struct rtk_jpeg_stream stream = { buf, buf + len };
+	struct rtk_q_data *q_data_src;
+	int chroma_format, comp_num;
+	int i, ret, pad;
+	struct rtk_jcodec_dev *dev = ctx->dev;
+
+	q_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+	chroma_format = rtk_jpeg_chroma_format(q_data_src->fourcc);
+	if (chroma_format < 0)
+		return 0;
+
+	/* Start Of Image */
+	ret = rtk_jpeg_put_word(SOI_MARKER, &stream);
+	if (ret < 0)
+		return ret;
+
+	if (chroma_format == RTK_JPEG_FORMAT_444 &&
+	    q_data_src->fourcc == V4L2_PIX_FMT_RGB24) {
+		for (i = 0; i < sizeof(jpeg_app14) && ret == 0; i++) {
+			ret = rtk_jpeg_put_byte(jpeg_app14[i], &stream);
+		}
+		if (ret < 0)
+			return ret;
+	}
+
+	/* Define Restart Interval */
+	if (ctx->params.jpeg_restart_interval) {
+		ret = rtk_jpeg_put_word(DRI_MARKER, &stream);
+		if (ret < 0)
+			return ret;
+		ret = rtk_jpeg_put_word(4, &stream);
+		if (ret < 0)
+			return ret;
+		ret = rtk_jpeg_put_word(ctx->params.jpeg_restart_interval,
+					&stream);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* Define Quantization Tables */
+	ret = rtk_jpeg_define_quantization_table(ctx, 0x00, &stream);
+	if (ret < 0)
+		return ret;
+
+	if (chroma_format == RTK_JPEG_FORMAT_444 &&
+	    q_data_src->fourcc == V4L2_PIX_FMT_RGB24) {
+		rtk_set_jpeg_compression_quality(ctx, ctx->params.jpeg_quality,
+						 1);
+	}
+
+	if (chroma_format != RTK_JPEG_FORMAT_400) {
+		//if(chroma_components){
+		ret = rtk_jpeg_define_quantization_table(ctx, 0x01, &stream);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* Define Huffman Tables */
+	ret = rtk_jpeg_define_huffman_table(0x00, luma_dc, 16 + 12, &stream);
+	if (ret < 0)
+		return ret;
+	ret = rtk_jpeg_define_huffman_table(0x10, luma_ac, 16 + 162, &stream);
+	if (ret < 0)
+		return ret;
+	if (chroma_format != RTK_JPEG_FORMAT_400) {
+		if (chroma_format == RTK_JPEG_FORMAT_444 &&
+		    q_data_src->fourcc == V4L2_PIX_FMT_RGB24) {
+			ret = rtk_jpeg_load_huff_tab(ctx, 1);
+			if (ret < 0) {
+				v4l2_err(&dev->v4l2_dev,
+					 "error loading Huffman tables\n");
+				return ret;
+			}
+
+			ret = rtk_jpeg_define_huffman_table(0x01, luma_dc,
+							    16 + 12, &stream);
+			if (ret < 0)
+				return ret;
+			ret = rtk_jpeg_define_huffman_table(0x11, luma_ac,
+							    16 + 162, &stream);
+			if (ret < 0)
+				return ret;
+
+		} else { //yuv
+			ret = rtk_jpeg_define_huffman_table(0x01, chroma_dc,
+							    16 + 12, &stream);
+			if (ret < 0)
+				return ret;
+			ret = rtk_jpeg_define_huffman_table(0x11, chroma_ac,
+							    16 + 162, &stream);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	/* Start Of Frame */
+	ret = rtk_jpeg_put_word(SOF_MARKER, &stream);
+	if (ret < 0)
+		return ret;
+	comp_num = (chroma_format == RTK_JPEG_FORMAT_400) ? 1 : 3;
+	ret = rtk_jpeg_put_word(8 + comp_num * 3, &stream);
+	if (ret < 0)
+		return ret;
+	ret = rtk_jpeg_put_byte(0x08, &stream);
+	if (ret < 0)
+		return ret;
+	ret = rtk_jpeg_put_word(q_data_src->height, &stream);
+	if (ret < 0)
+		return ret;
+	ret = rtk_jpeg_put_word(q_data_src->width, &stream);
+	if (ret < 0)
+		return ret;
+	ret = rtk_jpeg_put_byte(comp_num, &stream);
+	if (ret < 0)
+		return ret;
+	for (i = 0; i < comp_num; i++) {
+		static unsigned char subsampling[5][3] = {
+			[RTK_JPEG_FORMAT_420] = { 0x22, 0x11, 0x11 },
+			[RTK_JPEG_FORMAT_422] = { 0x21, 0x11, 0x11 },
+			[RTK_JPEG_FORMAT_224] = { 0x12, 0x11, 0x11 },
+			[RTK_JPEG_FORMAT_444] = { 0x11, 0x11, 0x11 },
+			[RTK_JPEG_FORMAT_400] = { 0x11 },
+		};
+
+		/* Component identifier, matches SOS */
+		ret = rtk_jpeg_put_byte(i + 1, &stream);
+		if (ret < 0)
+			return ret;
+		ret = rtk_jpeg_put_byte(subsampling[chroma_format][i], &stream);
+		if (ret < 0)
+			return ret;
+		/* Chroma table index */
+		ret = rtk_jpeg_put_byte((i == 0) ? 0 : 1, &stream);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* Pad to multiple of 8 bytes */
+	pad = (stream.curr - buf) % 8;
+	if (pad) {
+		pad = 8 - pad;
+		while (pad--) {
+			ret = rtk_jpeg_put_byte(0x00, &stream);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return stream.curr - buf;
+}
+
+/*
+ * Scale quantization table using nonlinear scaling factor
+ * u8 qtab[64], scale [50,190]
+ */
+static void rtk_scale_quant_table(u8 *q_tab, int scale)
+{
+	unsigned int temp;
+	int i;
+
+	for (i = 0; i < 64; i++) {
+		temp = DIV_ROUND_CLOSEST((unsigned int)q_tab[i] * scale, 100);
+		if (temp <= 0)
+			temp = 1;
+		if (temp > 255)
+			temp = 255;
+		q_tab[i] = (unsigned char)temp;
+	}
+}
+
+void rtk_set_jpeg_compression_quality(struct rtk_jcodec_ctx *ctx, int quality,
+				      int is_rgb)
+{
+	unsigned int scale;
+
+	ctx->params.jpeg_quality = quality;
+
+	/* Clip quality setting to [5,100] interval */
+	if (quality > 100)
+		quality = 100;
+	if (quality < 5)
+		quality = 5;
+
+	/*
+	 * Non-linear scaling factor:
+	 * [5,50] -> [1000..100], [51,100] -> [98..0]
+	 */
+	if (quality < 50)
+		scale = 5000 / quality;
+	else
+		scale = 200 - 2 * quality;
+
+	if (ctx->params.jpeg_qmat_tab[0]) {
+		memcpy(ctx->params.jpeg_qmat_tab[0], luma_q, 64);
+		rtk_scale_quant_table(ctx->params.jpeg_qmat_tab[0], scale);
+	}
+	if (ctx->params.jpeg_qmat_tab[1]) {
+		if (!is_rgb) {
+			memcpy(ctx->params.jpeg_qmat_tab[1], chroma_q, 64);
+		} else {
+			memcpy(ctx->params.jpeg_qmat_tab[1], luma_q, 64);
+		}
+
+		rtk_scale_quant_table(ctx->params.jpeg_qmat_tab[1], scale);
+	}
+}
+
+/*
+ * Encoder context operations
+ */
+
+static int rtk_jpeg_start_encoding(struct rtk_jcodec_ctx *ctx)
+{
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	int ret;
+
+	ret = rtk_jpeg_load_huff_tab(ctx, 0);
+	if (ret < 0) {
+		v4l2_err(&dev->v4l2_dev, "error loading Huffman tables\n");
+		return ret;
+	}
+	if (!ctx->params.jpeg_qmat_tab[0]) {
+		ctx->params.jpeg_qmat_tab[0] = kmalloc(64, GFP_KERNEL);
+		if (!ctx->params.jpeg_qmat_tab[0])
+			return -ENOMEM;
+	}
+	if (!ctx->params.jpeg_qmat_tab[1]) {
+		ctx->params.jpeg_qmat_tab[1] = kmalloc(64, GFP_KERNEL);
+		if (!ctx->params.jpeg_qmat_tab[1])
+			return -ENOMEM;
+	}
+	rtk_set_jpeg_compression_quality(ctx, ctx->params.jpeg_quality, 0);
+
+	return 0;
+}
+
+void rtk_set_packedFormat(struct rtk_jcodec_ctx *ctx, struct rtk_q_data *q_data,
+			  u32 fourcc, int aligned_width)
+{
+	struct rtk_jcodec_dev *dev = ctx->dev;
+
+	if (fourcc == V4L2_PIX_FMT_RGB24) {
+		ctx->params.packedFormat = PACKED_FORMAT_444;
+
+		if (aligned_width * 3 != q_data->bytesperline) {
+			v4l2_err(&dev->v4l2_dev, "stride mismatch: %d != %d\n",
+				 aligned_width, q_data->bytesperline);
+		}
+	} else {
+		ctx->params.packedFormat = PACKED_FORMAT_NONE;
+
+		if (aligned_width != q_data->bytesperline) {
+			v4l2_err(&dev->v4l2_dev, "stride mismatch: %d != %d\n",
+				 aligned_width, q_data->bytesperline);
+		}
+	}
+}
+
+void rtk_jcodec_write_base(struct rtk_jcodec_ctx *ctx,
+			   struct rtk_q_data *q_data,
+			   struct vb2_v4l2_buffer *buf, int chroma_interleave,
+			   unsigned int reg_y)
+{
+	u32 base_y = 0, base_cb = 0, base_cr = 0;
+	u32 allocHeight = q_data->height;
+	u32 lumaSize, chrSize;
+	int divX, divY;
+	int chroma_format = rtk_jpeg_chroma_format(q_data->fourcc);
+	u32 val;
+
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+	if (ctx->inst_type == RTK_JCODEC_CTX_DECODER &&
+	    V4L2_TYPE_IS_CAPTURE(buf->vb2_buf.type))
+		base_y = vb2_dma_contig_plane_dma_addr(&buf->vb2_buf, 0) +
+			 METADATA_OFFSET;
+	else
+		base_y = vb2_dma_contig_plane_dma_addr(&buf->vb2_buf, 0);
+#else
+	base_y = vb2_dma_contig_plane_dma_addr(&buf->vb2_buf, 0);
+#endif
+
+	divX = chroma_format == RTK_JPEG_FORMAT_420 ||
+			       chroma_format == RTK_JPEG_FORMAT_422 ?
+		       2 :
+		       1;
+	divY = chroma_format == RTK_JPEG_FORMAT_420 ||
+			       chroma_format == RTK_JPEG_FORMAT_224 ?
+		       2 :
+		       1;
+
+	lumaSize = ((q_data->bytesperline + 1) / 2 * 2) *
+		   ((allocHeight + 1) / 2 * 2);
+	chrSize = lumaSize / divX / divY;
+
+	switch (q_data->fourcc) {
+	case V4L2_PIX_FMT_YUYV:
+		/* Fallthrough: IN -H264-> CODA -NV12 MB-> VDOA -YUYV-> OUT */
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_YUV422P:
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_YUV444M:
+	case V4L2_PIX_FMT_NV24:
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_GREY:
+		base_cb = base_y + lumaSize;
+		base_cr = (chroma_interleave == 0) ? (base_cb + chrSize) : 0;
+		break;
+	case V4L2_PIX_FMT_YVU420:
+		/* Switch Cb and Cr for YVU420 format */
+		base_cr = base_y + lumaSize;
+		base_cb = (chroma_interleave == 0) ? (base_cr + chrSize) : 0;
+		break;
+	default:
+		base_cb = base_y + lumaSize;
+		base_cr = (chroma_interleave == 0) ? (base_cb + chrSize) : 0;
+		break;
+	}
+
+	rtk_jcodec_write(ctx->dev, base_y, reg_y);
+	rtk_jcodec_write(ctx->dev, base_cb, reg_y + 4);
+	rtk_jcodec_write(ctx->dev, base_cr, reg_y + 8);
+
+	rtk_jcodec_write(ctx->dev, q_data->bytesperline,
+			 RTK_REG_JPEG_DPB_YSTRIDE);
+
+	val = (chroma_format == RTK_JPEG_FORMAT_420 ||
+	       chroma_format == RTK_JPEG_FORMAT_422 ||
+	       chroma_format == RTK_JPEG_FORMAT_400) ?
+		      2 :
+		      1;
+	if (chroma_interleave > 0)
+		rtk_jcodec_write(ctx->dev,
+				 (q_data->bytesperline / (int)val) * 2,
+				 RTK_REG_JPEG_DPB_CSTRIDE);
+	else
+		rtk_jcodec_write(ctx->dev, q_data->bytesperline / (int)val,
+				 RTK_REG_JPEG_DPB_CSTRIDE);
+}
+
+static int rtk_jpeg_prepare_encode(struct rtk_jcodec_ctx *ctx)
+{
+	struct rtk_q_data *q_data_src;
+	struct vb2_v4l2_buffer *src_buf, *dst_buf;
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	u32 start_addr, end_addr;
+	u16 aligned_width, aligned_height;
+	bool chroma_interleave;
+	int chroma_format;
+	int header_len;
+
+	src_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);
+	dst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);
+	q_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+
+	if (vb2_get_plane_payload(&src_buf->vb2_buf, 0) == 0)
+		vb2_set_plane_payload(&src_buf->vb2_buf, 0,
+				      vb2_plane_size(&src_buf->vb2_buf, 0));
+
+	src_buf->sequence = ctx->osequence;
+	dst_buf->sequence = ctx->osequence;
+	ctx->osequence++;
+
+	src_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;
+	src_buf->flags &= ~V4L2_BUF_FLAG_PFRAME;
+
+	//coda_set_gdi_regs(ctx);
+
+	start_addr = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);
+	end_addr = start_addr + vb2_plane_size(&dst_buf->vb2_buf, 0);
+
+	if (ctx->params.is_firt_frame == 0) {
+		rtk_jcodec_write(dev, start_addr, RTK_REG_JPEG_BBC_WR_PTR);
+
+		ctx->params.is_firt_frame = 1;
+	}
+
+	chroma_format = rtk_jpeg_chroma_format(q_data_src->fourcc);
+	if (chroma_format < 0)
+		return chroma_format;
+
+	/* Round image dimensions to multiple of MCU size */
+	aligned_width = round_up(q_data_src->width, width_align[chroma_format]);
+	aligned_height =
+		round_up(q_data_src->height, height_align[chroma_format]);
+	if (q_data_src->fourcc == V4L2_PIX_FMT_RGB24) {
+		if (aligned_width * 3 != q_data_src->bytesperline) {
+			v4l2_err(&dev->v4l2_dev,
+				 "wrong rgb stride: %d instead of %d\n",
+				 aligned_width * 3, q_data_src->bytesperline);
+		}
+	} else {
+		if (aligned_width != q_data_src->bytesperline) {
+			v4l2_err(&dev->v4l2_dev,
+				 "wrong stride: %d instead of %d\n",
+				 aligned_width, q_data_src->bytesperline);
+		}
+	}
+	header_len =
+		rtk_jpeg_encode_header(ctx,
+				       vb2_plane_size(&dst_buf->vb2_buf, 0),
+				       vb2_plane_vaddr(&dst_buf->vb2_buf, 0));
+	if (header_len < 0)
+		return header_len;
+
+	rtk_jcodec_write(
+		dev, 0,
+		RTK_REG_JPEG_CLP_INFO_REG); //off ROI enable due to not supported feature for encoder.
+
+	rtk_jcodec_write(dev, start_addr + header_len,
+			 RTK_REG_JPEG_BBC_BAS_ADDR);
+	rtk_jcodec_write(dev, end_addr, RTK_REG_JPEG_BBC_END_ADDR);
+	rtk_jcodec_write(dev, start_addr + header_len, RTK_REG_JPEG_BBC_WR_PTR);
+	rtk_jcodec_write(dev, start_addr + header_len, RTK_REG_JPEG_BBC_RD_PTR);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_BBC_CUR_POS);
+	/* 64 words per 256-byte page */
+	rtk_jcodec_write(dev, 64, RTK_REG_JPEG_BBC_DATA_CNT);
+	rtk_jcodec_write(dev, start_addr, RTK_REG_JPEG_BBC_EXT_ADDR);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_BBC_INT_ADDR);
+
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_GBU_BT_PTR);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_GBU_WD_PTR);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_GBU_BBSR);
+	rtk_jcodec_write(dev,
+			 BIT(31) | ((end_addr - start_addr - header_len) / 256),
+			 RTK_REG_JPEG_BBC_STRM_CTRL);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_GBU_CTRL);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_GBU_FF_RPTR);
+	rtk_jcodec_write(dev, 127, RTK_REG_JPEG_GBU_BBER); //((256 / 4) * 2) - 1
+	rtk_jcodec_write(dev, 64,
+			 RTK_REG_JPEG_GBU_BBIR); // 64 * 4 byte == 32 * 8 byte
+	rtk_jcodec_write(dev, 64,
+			 RTK_REG_JPEG_GBU_BBHR); // 64 * 4 byte == 32 * 8 byte
+
+	rtk_set_packedFormat(ctx, q_data_src, q_data_src->fourcc,
+			     aligned_width);
+
+	if (q_data_src->fourcc == V4L2_PIX_FMT_NV12 ||
+	    q_data_src->fourcc == V4L2_PIX_FMT_NV16 ||
+	    q_data_src->fourcc == V4L2_PIX_FMT_NV24)
+		chroma_interleave = 1;
+	else if (q_data_src->fourcc == V4L2_PIX_FMT_NV21)
+		chroma_interleave = 2;
+	else {
+		chroma_interleave = 0;
+	}
+
+	rtk_jcodec_write(
+		dev,
+		RTK_JPEG_PIC_CTRL_TC_DIRECTION |
+			RTK_JPEG_PIC_CTRL_ENCODER_EN /*| pEncInfo->usePartial*/ |
+			(0 << 2),
+		RTK_REG_JPEG_PIC_CTRL); // 0x18 = RTK_JPEG_PIC_CTRL_TC_DIRECTION | RTK_JPEG_PIC_CTRL_ENCODER_EN
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_SCL_INFO);
+
+	//rtk_jcodec_write(dev, chroma_interleave, RTK_REG_JPEG_DPB_CONFIG);
+	if (ctx->params.packedFormat == PACKED_FORMAT_NONE) {
+		rtk_jcodec_write(dev,
+				 (ctx->params.frameEndian << 6) | (0 << 5) |
+					 (0 << 4) | (0 << 2) |
+					 ((chroma_interleave == 0) ?
+						  0 :
+						  (chroma_interleave == 1) ? 2 :
+									     3),
+				 RTK_REG_JPEG_DPB_CONFIG);
+	} else if (ctx->params.packedFormat == PACKED_FORMAT_444) {
+		rtk_jcodec_write(dev,
+				 (ctx->params.frameEndian << 6) | (1 << 5) |
+					 (0 << 4) | (0 << 2) |
+					 ((chroma_interleave == 0) ?
+						  0 :
+						  (chroma_interleave == 1) ? 2 :
+									     3),
+				 RTK_REG_JPEG_DPB_CONFIG);
+	} else {
+		rtk_jcodec_write(
+			dev,
+			(ctx->params.frameEndian << 6) | (0 << 5) | (1 << 4) |
+				((ctx->params.packedFormat - 1) << 2) |
+				((chroma_interleave == 0) ?
+					 0 :
+					 (chroma_interleave == 1) ? 2 : 3),
+			RTK_REG_JPEG_DPB_CONFIG);
+	}
+
+	rtk_jcodec_write(dev, ctx->params.jpeg_restart_interval,
+			 RTK_REG_JPEG_RST_INTVAL);
+	rtk_jcodec_write(dev, (ctx->params.streamEndian << 1) | 1,
+			 RTK_REG_JPEG_BBC_CTRL);
+
+	rtk_jcodec_write(
+		dev,
+		/*pEncInfo->partiallineNum << 16 | pEncInfo->partialBufNum << 3 | */
+		bus_req_num[chroma_format], RTK_REG_JPEG_OP_INFO);
+
+	rtk_jpeg_write_huff_tab(ctx);
+	rtk_jpeg_load_qmat_tab(ctx);
+
+	if (ctx->params.rot_mode & RTK_ROT_90) {
+		aligned_width = aligned_height;
+		aligned_height = q_data_src->bytesperline;
+		if (chroma_format == RTK_JPEG_FORMAT_422) {
+			chroma_format = RTK_JPEG_FORMAT_224;
+		} else if (chroma_format == RTK_JPEG_FORMAT_224) {
+			chroma_format = RTK_JPEG_FORMAT_422;
+		}
+	}
+	/* These need to be multiples of MCU size */
+	rtk_jcodec_write(dev, aligned_width << 16 | aligned_height,
+			 RTK_REG_JPEG_PIC_SIZE);
+	rtk_jcodec_write(dev,
+			 ctx->params.rot_mode ?
+				 (RTK_ROT_MIR_ENABLE | ctx->params.rot_mode) :
+				 0,
+			 RTK_REG_JPEG_ROT_INFO);
+
+	rtk_jcodec_write(dev, mcu_info[chroma_format], RTK_REG_JPEG_MCU_INFO);
+
+	rtk_jcodec_write(
+		dev, ctx->params.stuffByteEnable << 3,
+		RTK_REG_JPEG_GBU_CTRL); // stuffing "FF" data where frame end
+
+	rtk_jcodec_write_base(ctx, q_data_src, src_buf, chroma_interleave,
+			      RTK_REG_JPEG_DPB_BASE00);
+
+	//coda_write(dev, 0, CODA9_REG_JPEG_DPB_BASE00);
+	//coda_write(dev, 0, CODA9_GDI_CONTROL);
+	//coda_write(dev, 1, CODA9_GDI_PIC_INIT_HOST);
+
+	//coda_write(dev, 1, CODA9_GDI_WPROT_ERR_CLR);
+	//coda_write(dev, 0, CODA9_GDI_WPROT_RGN_EN);
+
+	//trace_coda_jpeg_run(ctx, src_buf);
+
+	//JpuWriteReg(MJPEG_PIC_STATUS_REG, JpuReadReg(MJPEG_PIC_STATUS_REG));
+	//if (pEncInfo->usePartial)
+	//	JpuWriteReg(MJPEG_PIC_START_REG, (1<<JPG_START_PIC)|(1<<JPG_START_PARTIAL));
+	//else
+	rtk_jcodec_write(dev, 1, RTK_REG_JPEG_PIC_START);
+
+	return 0;
+}
+
+void rtk_m2m_buf_done(struct rtk_jcodec_ctx *ctx, struct vb2_v4l2_buffer *buf,
+		      enum vb2_buffer_state state)
+{
+	const struct v4l2_event eos_event = { .type = V4L2_EVENT_EOS };
+
+	if (buf->flags & V4L2_BUF_FLAG_LAST)
+		v4l2_event_queue_fh(&ctx->fh, &eos_event);
+
+	v4l2_m2m_buf_done(buf, state);
+}
+
+static void rtk_jpeg_finish_encode(struct rtk_jcodec_ctx *ctx)
+{
+	struct vb2_v4l2_buffer *src_buf, *dst_buf;
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	u32 wr_ptr, start_ptr;
+	u32 err_mb;
+
+	if (ctx->aborting) {
+		rtk_jcodec_write(ctx->dev, 0, RTK_REG_JPEG_BBC_FLUSH_CMD);
+		return;
+	}
+
+	/*
+	 * Lock to make sure that an encoder stop command running in parallel
+	 * will either already have marked src_buf as last, or it will wake up
+	 * the capture queue after the buffers are returned.
+	 */
+	mutex_lock(&ctx->wakeup_mutex);
+	src_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);
+	dst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
+
+	//trace_coda_jpeg_done(ctx, dst_buf);
+
+	/*
+	 * Set plane payload to the number of bytes written out
+	 * by the JPEG processing unit
+	 */
+	start_ptr = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);
+	wr_ptr = rtk_jcodec_read(dev, RTK_REG_JPEG_BBC_WR_PTR);
+	vb2_set_plane_payload(&dst_buf->vb2_buf, 0, wr_ptr - start_ptr);
+
+	err_mb = rtk_jcodec_read(dev, RTK_REG_JPEG_PIC_ERRMB);
+	if (err_mb) {
+		rtk_jcodec_dbg(2, ctx, "ERRMB: 0x%x\n", err_mb);
+	}
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_BBC_FLUSH_CMD);
+
+	dst_buf->flags &= ~(V4L2_BUF_FLAG_PFRAME | V4L2_BUF_FLAG_LAST);
+	dst_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;
+	dst_buf->flags |= src_buf->flags & V4L2_BUF_FLAG_LAST;
+
+	v4l2_m2m_buf_copy_metadata(src_buf, dst_buf, false);
+
+	v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);
+	rtk_m2m_buf_done(ctx, dst_buf,
+			 /*err_mb ? VB2_BUF_STATE_ERROR :*/ VB2_BUF_STATE_DONE);
+	mutex_unlock(&ctx->wakeup_mutex);
+
+	rtk_jcodec_dbg(1, ctx, "job finished: encoded frame (%u)%s\n",
+		       dst_buf->sequence,
+		       (dst_buf->flags & V4L2_BUF_FLAG_LAST) ? " (last)" : "");
+
+	/*
+	 * Reset JPEG processing unit after each encode run to work
+	 * around hangups when switching context between encoder and
+	 * decoder.
+	 */
+	rtk_jcodec_hw_reset(dev);
+}
+
+static void rtk_jpeg_encode_timeout(struct rtk_jcodec_ctx *ctx)
+{
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	u32 end_addr, wr_ptr;
+
+	/* Handle missing BBC overflow interrupt via timeout */
+	end_addr = rtk_jcodec_read(dev, RTK_REG_JPEG_BBC_END_ADDR);
+	wr_ptr = rtk_jcodec_read(dev, RTK_REG_JPEG_BBC_WR_PTR);
+	if (wr_ptr >= end_addr - 256) {
+		v4l2_err(&dev->v4l2_dev, "JPEG too large for capture buffer\n");
+		rtk_jpeg_finish_encode(ctx);
+		return;
+	}
+
+	rtk_jcodec_hw_reset(dev);
+}
+static void rtk_jpeg_release(struct rtk_jcodec_ctx *ctx)
+{
+	int i;
+
+	if (ctx->params.jpeg_qmat_tab[0] == luma_q)
+		ctx->params.jpeg_qmat_tab[0] = NULL;
+	if (ctx->params.jpeg_qmat_tab[1] == chroma_q)
+		ctx->params.jpeg_qmat_tab[1] = NULL;
+	for (i = 0; i < 4; i++)
+		kfree(ctx->params.jpeg_qmat_tab[i]);
+	kfree(ctx->params.jpeg_huff_data);
+	kfree(ctx->params.jpeg_huff_tab);
+}
+
+/*
+ * Decoder context operations
+ */
+
+static int rtk_jpeg_start_decoding(struct rtk_jcodec_ctx *ctx)
+{
+	ctx->params.jpeg_qmat_index[0] = 0;
+	ctx->params.jpeg_qmat_index[1] = 1;
+	ctx->params.jpeg_qmat_index[2] = 1;
+	ctx->params.jpeg_qmat_tab[0] = luma_q;
+	ctx->params.jpeg_qmat_tab[1] = chroma_q;
+	/* nothing more to do here */
+
+	/* TODO: we could already scan the first header to get the chroma
+	 * format.
+	 */
+
+	return 0;
+}
+static inline int rtk_jpeg_scale(int src, int dst)
+{
+	return (dst <= src / 8) ?
+		       3 :
+		       (dst <= src / 4) ? 2 : (dst <= src / 2) ? 1 : 0;
+}
+
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+static void rtk_jpeg_fill_frame_info(struct rtk_jcodec_ctx *ctx,
+				     struct rtk_q_data *q_data,
+				     struct vb2_v4l2_buffer *buf)
+{
+	struct ve_frame_info *info =
+		(struct ve_frame_info *)vb2_plane_vaddr(&buf->vb2_buf, 0);
+	u32 base_addr = vb2_dma_contig_plane_dma_addr(&buf->vb2_buf, 0) +
+			METADATA_OFFSET;
+	memset(info, 0, sizeof(struct ve_frame_info));
+
+	info->yuvs.lumaOffTblAddr = 0xffffffff;
+	info->yuvs.chromaOffTblAddr = 0xffffffff;
+	info->yuvs.lumaOffTblAddrR = 0xffffffff;
+	info->yuvs.chromaOffTblAddrR = 0xffffffff;
+	info->yuvs.bufBitDepth = 8;
+	info->yuvs.matrix_coefficients = 1;
+	info->yuvs.tch_hdr_metadata[0] = -1;
+
+	info->yuvs.Y_addr_Right = 0xffffffff;
+	info->yuvs.U_addr_Right = 0xffffffff;
+	info->yuvs.pLock_Right = 0xffffffff;
+	info->rtk_meta_buf_id = 0x52544B6D; //RTKm
+
+	info->yuvs.width = q_data->ori_width;
+	info->yuvs.height = q_data->ori_height;
+	info->yuvs.Y_addr = base_addr;
+	info->yuvs.U_addr = base_addr + q_data->bytesperline * q_data->height;
+	info->yuvs.Y_pitch = q_data->bytesperline;
+	info->yuvs.C_pitch = q_data->bytesperline;
+	info->yuvs.mode = CONSECUTIVE_FRAME;
+}
+#endif
+
+static int rtk_jpeg_prepare_decode(struct rtk_jcodec_ctx *ctx)
+{
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	int aligned_width, aligned_height;
+	int chroma_format;
+	int ret;
+	u32 val, dst_fourcc;
+	struct rtk_q_data *q_data_src, *q_data_dst;
+	struct vb2_v4l2_buffer *src_buf, *dst_buf;
+	int chroma_interleave;
+	int scl_hor_mode, scl_ver_mode;
+	src_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);
+	if (!src_buf) {
+		v4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);
+		rtk_jcodec_dbg(
+			1, ctx,
+			"rtk_jpeg_prepare_decode error: no available source buffer");
+		return -EINVAL;
+	}
+	dst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);
+	q_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+	q_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	dst_fourcc = q_data_dst->fourcc;
+
+	scl_hor_mode = rtk_jpeg_scale(q_data_src->width, q_data_dst->width);
+	scl_ver_mode = rtk_jpeg_scale(q_data_src->height, q_data_dst->height);
+
+	if (vb2_get_plane_payload(&src_buf->vb2_buf, 0) == 0)
+		vb2_set_plane_payload(&src_buf->vb2_buf, 0,
+				      vb2_plane_size(&src_buf->vb2_buf, 0));
+
+	chroma_format = rtk_jpeg_chroma_format(q_data_dst->fourcc);
+	if (chroma_format < 0) {
+		v4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);
+		return chroma_format;
+	}
+
+	if (q_data_src->sizeimage <
+	    vb2_get_plane_payload(&src_buf->vb2_buf, 0)) {
+		v4l2_err(&dev->v4l2_dev, "bs buffer too small: %d < %d \n",
+			 q_data_src->sizeimage,
+			 (int)vb2_get_plane_payload(&src_buf->vb2_buf, 0));
+	}
+
+	if (ctx->params.is_firt_frame == 0) {
+		u32 bbc_base_addr =
+			vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);
+		u32 end_addr = bbc_base_addr + q_data_src->sizeimage;
+
+		rtk_jcodec_write(dev, bbc_base_addr, RTK_REG_JPEG_BBC_BAS_ADDR);
+		rtk_jcodec_write(dev, end_addr, RTK_REG_JPEG_BBC_END_ADDR);
+		rtk_jcodec_write(dev, bbc_base_addr, RTK_REG_JPEG_BBC_RD_PTR);
+		rtk_jcodec_write(dev, bbc_base_addr, RTK_REG_JPEG_BBC_WR_PTR);
+		rtk_jcodec_write(dev, 0, RTK_REG_JPEG_BBC_STRM_CTRL);
+		ctx->params.is_firt_frame = 1;
+	}
+
+	ret = rtk_jpeg_decode_header(ctx, &src_buf->vb2_buf);
+	if (ret < 0) {
+		v4l2_err(&dev->v4l2_dev, "failed to decode JPEG header: %d\n",
+			 ret);
+#if 0
+		src_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);
+		dst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
+		v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);
+
+#if 0
+		v4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);
+		v4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);
+#else
+		v4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);
+#endif
+#else
+		ctx->parsing_hdr_err = true;
+
+#endif
+		return ret;
+	}
+
+	if (chroma_format != ctx->params.format) {
+		v4l2_err(&dev->v4l2_dev,
+			 "error chroma_format mismatch: %d != %d\n",
+			 chroma_format, ctx->params.format);
+		//chroma_format = ctx->params.format;
+		return -EINVAL;
+	}
+
+	/* Round image dimensions to multiple of MCU size */
+	aligned_width = round_up(q_data_src->width, width_align[chroma_format]);
+	aligned_height =
+		round_up(q_data_src->height, height_align[chroma_format]);
+
+	rtk_set_packedFormat(ctx, q_data_dst, dst_fourcc, aligned_width);
+
+	val = ctx->params.jpeg_huff_ac_index[0] << 12 |
+	      ctx->params.jpeg_huff_ac_index[1] << 11 |
+	      ctx->params.jpeg_huff_ac_index[2] << 10 |
+	      ctx->params.jpeg_huff_dc_index[0] << 9 |
+	      ctx->params.jpeg_huff_dc_index[1] << 8 |
+	      ctx->params.jpeg_huff_dc_index[2] << 7;
+
+	//always true
+	if (ctx->params.jpeg_huff_tab)
+		val |= RTK_JPEG_PIC_CTRL_USER_HUFFMAN_EN;
+
+	//align jpu
+	val |= (JPU_DEC_CHECK_WRITE_RESPONSE_BVALID_SIGNAL << 2);
+	val |= 0;
+
+	rtk_jcodec_write(dev, val, RTK_REG_JPEG_PIC_CTRL);
+
+	rtk_jcodec_write(dev, aligned_width << 16 | aligned_height,
+			 RTK_REG_JPEG_PIC_SIZE);
+
+	//chroma_interleave = (dst_fourcc == V4L2_PIX_FMT_NV12 );
+	if (dst_fourcc == V4L2_PIX_FMT_NV12 ||
+	    dst_fourcc == V4L2_PIX_FMT_NV16 || dst_fourcc == V4L2_PIX_FMT_NV24)
+		chroma_interleave = 1;
+	else if (dst_fourcc == V4L2_PIX_FMT_NV21)
+		chroma_interleave = 2;
+	else {
+		chroma_interleave = 0;
+	}
+
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_ROT_INFO);
+	rtk_jcodec_write(dev, bus_req_num[chroma_format], RTK_REG_JPEG_OP_INFO);
+	rtk_jcodec_write(dev, mcu_info[chroma_format], RTK_REG_JPEG_MCU_INFO);
+
+	if (scl_hor_mode || scl_ver_mode)
+		val = RTK_JPEG_SCL_ENABLE | (scl_hor_mode << 2) | scl_ver_mode;
+	else
+		val = 0;
+	rtk_jcodec_write(dev, val, RTK_REG_JPEG_SCL_INFO);
+
+	//rtk_jcodec_write(dev, chroma_interleave, RTK_REG_JPEG_DPB_CONFIG);
+	if (ctx->params.packedFormat == PACKED_FORMAT_NONE)
+		rtk_jcodec_write(
+			dev,
+			(ctx->params.frameEndian << 6) | (0 << 5) | (0 << 4) |
+				((chroma_interleave == 0) ?
+					 0 :
+					 (chroma_interleave == 1) ? 2 : 3),
+			RTK_REG_JPEG_DPB_CONFIG);
+	else if (ctx->params.packedFormat == PACKED_FORMAT_444)
+		rtk_jcodec_write(dev,
+				 (ctx->params.frameEndian << 6) | (1 << 5) |
+					 (0 << 4) | (0 << 2) |
+					 ((chroma_interleave == 0) ?
+						  0 :
+						  (chroma_interleave == 1) ? 2 :
+									     3),
+				 RTK_REG_JPEG_DPB_CONFIG);
+	else
+		rtk_jcodec_write(
+			dev,
+			(ctx->params.frameEndian << 6) | (0 << 5) | (1 << 4) |
+				((ctx->params.packedFormat - 1) << 2) |
+				((chroma_interleave == 0) ?
+					 0 :
+					 (chroma_interleave == 1) ? 2 : 3),
+			RTK_REG_JPEG_DPB_CONFIG);
+
+	rtk_jcodec_write(dev, ctx->params.jpeg_restart_interval,
+			 RTK_REG_JPEG_RST_INTVAL);
+
+	if (ctx->params.jpeg_huff_tab) {
+		ret = rtk_jpeg_dec_huff_setup(ctx);
+		if (ret < 0) {
+			v4l2_err(&dev->v4l2_dev,
+				 "failed to set up Huffman tables: %d\n", ret);
+			v4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);
+			return ret;
+		}
+	}
+
+	rtk_jpeg_qmat_setup(ctx);
+
+	rtk_jpeg_dec_bbc_gbu_setup(ctx, &src_buf->vb2_buf,
+				   ctx->jpeg_ecs_offset);
+
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_RST_INDEX);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_RST_COUNT);
+
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_DPCM_DIFF_Y);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_DPCM_DIFF_CB);
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_DPCM_DIFF_CR);
+
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_ROT_INFO);
+
+	rtk_jcodec_write_base(ctx, q_data_dst, dst_buf, chroma_interleave,
+			      RTK_REG_JPEG_DPB_BASE00);
+
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_CLP_INFO_REG);
+
+	rtk_jcodec_write(dev, 1, RTK_REG_JPEG_PIC_START);
+
+	return 0;
+}
+
+static void rtk_jpeg_finish_decode(struct rtk_jcodec_ctx *ctx)
+{
+	struct rtk_jcodec_dev *dev = ctx->dev;
+	struct vb2_v4l2_buffer *dst_buf, *src_buf;
+	struct rtk_q_data *q_data_dst;
+	u32 err_mb;
+
+	err_mb = rtk_jcodec_read(dev, RTK_REG_JPEG_PIC_ERRMB);
+	if (err_mb) {
+		rtk_jcodec_dbg(2, ctx, "ERRMB: 0x%x\n", err_mb);
+	}
+	rtk_jcodec_write(dev, 0, RTK_REG_JPEG_BBC_FLUSH_CMD);
+
+	/*
+	 * Lock to make sure that a decoder stop command running in parallel
+	 * will either already have marked src_buf as last, or it will wake up
+	 * the capture queue after the buffers are returned.
+	 */
+	mutex_lock(&ctx->wakeup_mutex);
+	src_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);
+	dst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
+	dst_buf->sequence = ctx->osequence++;
+
+	//trace_coda_jpeg_done(ctx, dst_buf);
+
+	dst_buf->flags &= ~(V4L2_BUF_FLAG_PFRAME | V4L2_BUF_FLAG_LAST);
+	dst_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;
+	dst_buf->flags |= src_buf->flags & V4L2_BUF_FLAG_LAST;
+
+	v4l2_m2m_buf_copy_metadata(src_buf, dst_buf, false);
+
+	q_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+	rtk_jpeg_fill_frame_info(ctx, q_data_dst, dst_buf);
+#endif
+
+	v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);
+#if 0
+	rtk_m2m_buf_done(
+		ctx, dst_buf,
+		/* err_mb ? VB2_BUF_STATE_ERROR : */ VB2_BUF_STATE_DONE);
+#else
+	rtk_m2m_buf_done(ctx, dst_buf,
+			 ctx->parsing_hdr_err ? VB2_BUF_STATE_ERROR :
+						VB2_BUF_STATE_DONE);
+#endif
+
+	mutex_unlock(&ctx->wakeup_mutex);
+
+	rtk_jcodec_dbg(1, ctx, "job finished: decoded frame (%u)%s\n",
+		       dst_buf->sequence,
+		       (dst_buf->flags & V4L2_BUF_FLAG_LAST) ? " (last)" : "");
+
+	/*
+	 * Reset JPEG processing unit after each decode run to work
+	 * around hangups when switching context between encoder and
+	 * decoder.
+	 */
+	rtk_jcodec_hw_reset(dev);
+}
+
+static int rtk_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,
+			   unsigned int *nplanes, unsigned int sizes[],
+			   struct device *alloc_devs[])
+{
+	struct rtk_jcodec_ctx *ctx = vb2_get_drv_priv(vq);
+	struct rtk_q_data *q_data;
+	unsigned int size;
+
+	q_data = rtk_get_q_data(ctx, vq->type);
+
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+	if (ctx->inst_type == RTK_JCODEC_CTX_DECODER &&
+	    V4L2_TYPE_IS_CAPTURE(vq->type))
+		size = q_data->sizeimage + METADATA_OFFSET;
+	else
+		size = q_data->sizeimage;
+#else
+	size = q_data->sizeimage;
+#endif
+
+	if (*nplanes) {
+		return sizes[0] < size ? -EINVAL : 0;
+	}
+
+	*nplanes = 1;
+	sizes[0] = size;
+
+	rtk_jcodec_dbg(1, ctx, "%s get %d buffer(s) of size %d each.\n",
+		       v4l2_type_names[vq->type], *nbuffers, size);
+
+	return 0;
+}
+
+static int rtk_buf_prepare(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct rtk_jcodec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
+	struct rtk_q_data *q_data;
+	int sizeimages;
+
+	q_data = rtk_get_q_data(ctx, vb->vb2_queue->type);
+	if (V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {
+		if (vbuf->field == V4L2_FIELD_ANY)
+			vbuf->field = V4L2_FIELD_NONE;
+
+#ifndef RTK_INTERLACED
+		if (vbuf->field != V4L2_FIELD_NONE) {
+			v4l2_warn(&ctx->dev->v4l2_dev,
+				  "%s error! field isn't supported\n",
+				  __func__);
+			return -EINVAL;
+		}
+#endif
+	}
+
+	rtk_jcodec_dbg(2, ctx, "%s buf prepare:\n",
+		       v4l2_type_names[vb->vb2_queue->type]);
+	//rtk_jcodec_dbg(2, ctx, "   vb2_plane_size : %d, q_data->sizeimage : %d\n",
+	//		vb2_plane_size(vb, 0), q_data->sizeimage);
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+	if (ctx->inst_type == RTK_JCODEC_CTX_DECODER &&
+	    V4L2_TYPE_IS_CAPTURE(vb->type))
+		sizeimages = q_data->sizeimage + METADATA_OFFSET;
+	else
+		sizeimages = q_data->sizeimage;
+#else
+	sizeimages = q_data->sizeimage;
+#endif
+
+	if (vb2_plane_size(vb, 0) < sizeimages) {
+		v4l2_warn(&ctx->dev->v4l2_dev,
+			  "%s data will not fit into plane (%lu < %lu)\n",
+			  __func__, vb2_plane_size(vb, 0), (long)sizeimages);
+		return -EINVAL;
+	}
+
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+	if (ctx->inst_type == RTK_JCODEC_CTX_DECODER &&
+	    V4L2_TYPE_IS_CAPTURE(vb->type)) {
+		vb2_set_plane_payload(vb, 0, sizeimages);
+		vb->planes[0].data_offset = METADATA_OFFSET;
+	}
+#endif
+
+	return 0;
+}
+
+static void rtk_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct rtk_jcodec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_queue *vq = vb->vb2_queue;
+	struct rtk_q_data *q_data;
+
+	q_data = rtk_get_q_data(ctx, vb->vb2_queue->type);
+
+	/*
+>------- * In the decoder case, immediately try to copy the buffer into the
+>------- * bitstream ringbuffer and mark it as ready to be dequeued.
+>------- */
+	if (ctx->bitstream.size && V4L2_TYPE_IS_OUTPUT(vq->type)) {
+		/*
+>------->------- * For backwards compatibility, queuing an empty buffer marks
+>------->------- * the stream end
+>------->------- */
+
+		if (vb2_get_plane_payload(vb, 0) == 0) {
+			rtk_jcodec_dbg(1, ctx, "queuing an empty buffer\n");
+			rtk_bitstream_end_flag(ctx);
+		}
+
+		mutex_lock(&ctx->bitstream_mutex);
+		v4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);
+		if (vb2_is_streaming(vb->vb2_queue)) {
+			/* This set buf->sequence = ctx->qsequence++ */
+			rtk_feed_bitstream(ctx, NULL);
+		}
+		mutex_unlock(&ctx->bitstream_mutex);
+
+	} else {
+		if ((ctx->inst_type == RTK_JCODEC_CTX_ENCODER ||
+		     !ctx->use_bit) &&
+		    V4L2_TYPE_IS_OUTPUT(vq->type)) {
+			vbuf->sequence = ctx->qsequence++;
+			printk(KERN_INFO "[vbuf->sequence : %d]"
+					 "[\x1b[33m%s\033[0m]\n",
+			       vbuf->sequence, __func__);
+		}
+
+		v4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);
+	}
+}
+
+static int rtk_bitstream_queue(struct rtk_jcodec_ctx *ctx, const u8 *buf,
+			       u32 size)
+{
+	u32 n = kfifo_in(&ctx->bitstream_fifo, buf, size);
+
+	return (n < size) ? -ENOSPC : 0;
+}
+
+static u32 rtk_buffer_parse_headers(struct rtk_jcodec_ctx *ctx,
+				    struct vb2_v4l2_buffer *src_buf,
+				    u32 payload)
+{
+	//u8 *vaddr = vb2_plane_vaddr(&src_buf->vb2_buf, 0);
+	u32 size = 0;
+
+	printk(KERN_INFO
+	       "[fn_name]:[\x1b[33m%s\033[0m], [line]: \x1b[33m%d\033[0m\n",
+	       __func__, __LINE__);
+
+	switch (ctx->codec->src_fourcc) {
+	case V4L2_PIX_FMT_MPEG2:
+		printk(KERN_INFO "[MPEG2][\x1b[33m%s\033[0m]\n", __func__);
+		// size = coda_mpeg2_parse_headers(ctx, vaddr, payload);
+		break;
+	case V4L2_PIX_FMT_MPEG4:
+		printk(KERN_INFO "[MPEG4][\x1b[33m%s\033[0m]\n", __func__);
+		// size = coda_mpeg4_parse_headers(ctx, vaddr, payload);
+		break;
+	default:
+		printk(KERN_INFO "[OTHER][\x1b[33m%s\033[0m]\n", __func__);
+		break;
+	}
+
+	return size;
+}
+
+static void rtk_kfifo_sync_to_device_write(struct rtk_jcodec_ctx *ctx)
+{
+	struct __kfifo *kfifo = &ctx->bitstream_fifo.kfifo;
+	//	struct rtk_jcodec_dev *dev = ctx->dev;
+	u32 wr_ptr;
+
+	wr_ptr = ctx->bitstream.paddr + (kfifo->in & kfifo->mask);
+
+	//rtk_jcodec_write(dev, wr_ptr, RTK_REG_BIT_WR_PTR(ctx->reg_idx));
+}
+
+static bool rtk_bitstream_try_queue(struct rtk_jcodec_ctx *ctx,
+				    struct vb2_v4l2_buffer *src_buf)
+{
+	unsigned long payload = vb2_get_plane_payload(&src_buf->vb2_buf, 0);
+	u8 *vaddr = vb2_plane_vaddr(&src_buf->vb2_buf, 0);
+	int ret;
+	int i;
+
+	rtk_jcodec_dbg(4, ctx, "[rtk_bitstream_try_queue]\n");
+	//rtk_jcodec_dbg(4, ctx, "src_buf %d, payload %d, kfifo_len : %d\n",
+	//	src_buf->vb2_buf.index, payload, rtk_get_bitstream_payload(ctx));
+
+	if (rtk_get_bitstream_payload(ctx) + payload + 512 >=
+	    ctx->bitstream.size) {
+		v4l2_err(&ctx->dev->v4l2_dev, "over bitstream buffer size\n");
+		return false;
+	}
+
+	if (!vaddr) {
+		v4l2_err(&ctx->dev->v4l2_dev, "trying to queue empty buffer\n");
+		return true;
+	}
+
+	if (ctx->qsequence == 0 && payload < 512) {
+		/*
+		 * Add padding after the first buffer, if it is too small to be
+		 * fetched by the CODA, by repeating the headers. Without
+		 * repeated headers, or the first frame already queued, decoder
+		 * sequence initialization fails with error code 0x2000 on i.MX6
+		 * or error code 0x1 on i.MX51.
+		 */
+		u32 header_size =
+			rtk_buffer_parse_headers(ctx, src_buf, payload);
+
+		if (header_size) {
+			rtk_jcodec_dbg(1, ctx, "pad with %u-byte header\n",
+				       header_size);
+			for (i = payload; i < 512; i += header_size) {
+				ret = rtk_bitstream_queue(ctx, vaddr,
+							  header_size);
+				if (ret < 0) {
+					v4l2_err(&ctx->dev->v4l2_dev,
+						 "bitstream buffer overflow\n");
+					return false;
+				}
+				if (ctx->dev->devinfo->product == CODA_J10) {
+					printk(KERN_ALERT
+					       "[fn_name]:[\x1b[31m%s\033[0m], [line]: \x1b[33m%d\033[0m\n",
+					       __func__, __LINE__);
+					break;
+				}
+			}
+		} else {
+			rtk_jcodec_dbg(
+				1, ctx,
+				"could not parse header, sequence initialization might fail\n");
+		}
+
+		/* Add padding before the first buffer, if it is too small */
+		//if (ctx->codec->src_fourcc == V4L2_PIX_FMT_H264)
+		//	rtk_bitstream_h264_pad(ctx, 512 - payload);
+	}
+
+	//if (ctx->codec->src_fourcc == V4L2_PIX_FMT_VP8) {
+	//	rtk_bitstream_vp8_pad(ctx, src_buf, payload);
+	//}
+
+	ret = rtk_bitstream_queue(ctx, vaddr, payload);
+	if (ret < 0) {
+		v4l2_err(&ctx->dev->v4l2_dev, "bitstream buffer overflow\n");
+		return false;
+	}
+
+	src_buf->sequence = ctx->qsequence++;
+	printk(KERN_INFO "[\x1b[33msrc_buf->sequence : %d\033[0m]\n",
+	       src_buf->sequence);
+
+	/* Sync read pointer to device */
+	if (ctx == v4l2_m2m_get_curr_priv(ctx->dev->m2m_dev)) {
+		rtk_kfifo_sync_to_device_write(ctx);
+	}
+
+	/* Set the stream-end flag after the last buffer is queued */
+	if (src_buf->flags & V4L2_BUF_FLAG_LAST) {
+		rtk_bitstream_end_flag(ctx);
+	}
+
+	ctx->hold = false;
+
+	rtk_jcodec_dbg(1, ctx, "rtk_bitstream_try_queue success\n");
+
+	//rtk_jcodec_dbg(4, ctx, "queue src_buf sequence %d \n",
+	//	src_buf->sequence, (src_buf->flags & V4L2_BUF_FLAG_LAST) ?
+	//			 " (last)" : "");
+
+	return true;
+}
+
+static char rtk_frame_type(u32 flags)
+{
+	return (flags & V4L2_BUF_FLAG_KEYFRAME) ?
+		       'I' :
+		       (flags & V4L2_BUF_FLAG_PFRAME) ?
+		       'P' :
+		       (flags & V4L2_BUF_FLAG_BFRAME) ? 'B' : '?';
+}
+
+void rtk_feed_bitstream(struct rtk_jcodec_ctx *ctx,
+			struct list_head *buffer_list)
+{
+	struct vb2_v4l2_buffer *src_buf;
+	struct rtk_meta_buffer *meta;
+	u32 start;
+
+	if (ctx->bit_stream_param & RTK_BIT_STREAM_END_FLAG) {
+		printk(KERN_INFO
+		       "[fn_name]:[\x1b[31m%s\033[0m], [line]: \x1b[33m%d\033[0m\n",
+		       __func__, __LINE__);
+		rtk_jcodec_dbg(1, ctx, "bitstream end\n");
+		return;
+	}
+
+	while (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) > 0) {
+		/*
+		 * Only queue two JPEGs into the bitstream buffer to keep
+		 * latency low. We need at least one complete buffer and the
+		 * header of another buffer (for prescan) in the bitstream.
+		 */
+		if (ctx->codec->src_fourcc == V4L2_PIX_FMT_JPEG &&
+		    ctx->num_metas > 1)
+			break;
+
+		if (ctx->num_frame_buffers &&
+		    ctx->num_metas >= ctx->num_frame_buffers) {
+			meta = list_first_entry(&ctx->meta_buffer_list,
+						struct rtk_meta_buffer, list);
+			/*
+>------->------->------- * If we managed to fill in at least a full reorder
+>------->------->------- * window of buffers (num_frame_buffers is a
+>------->------->------- * conservative estimate for this) and the bitstream
+>------->------->------- * prefetcher has at least 2 256 bytes periods beyond
+>------->------->------- * the first buffer to fetch, we can safely stop queuing
+>------->------->------- * in order to limit the decoder drain latency.
+>------->------->------- */
+			if (rtk_bitstream_can_fetch_past(ctx, meta->end)) {
+				break;
+			}
+		}
+
+		src_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);
+		rtk_jcodec_dbg(4, ctx, "feed bitstream src buf %d\n",
+			       src_buf->vb2_buf.index);
+
+		/* Drop frames that do not start/end with a SOI/EOI markers */
+		// TODO: refine later
+		if (ctx->codec->src_fourcc == V4L2_PIX_FMT_JPEG &&
+		    !rtk_jpeg_check_buffer(ctx, &src_buf->vb2_buf)) {
+			v4l2_err(&ctx->dev->v4l2_dev,
+				 "dropping invalid JPEG frame %d\n",
+				 ctx->qsequence);
+			src_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);
+			if (buffer_list) {
+				struct v4l2_m2m_buffer *m2m_buf;
+				m2m_buf = container_of(
+					src_buf, struct v4l2_m2m_buffer, vb);
+				list_add_tail(&m2m_buf->list, buffer_list);
+			} else {
+				v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);
+			}
+			continue;
+		}
+
+		/* Dump empty buffers */
+		if (!vb2_get_plane_payload(&src_buf->vb2_buf, 0)) {
+			src_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);
+			v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);
+			rtk_jcodec_dbg(4, ctx, "no plane payload\n");
+			continue;
+		}
+
+		/* Buffer start position */
+		start = ctx->bitstream_fifo.kfifo.in;
+
+		if (rtk_bitstream_try_queue(ctx, src_buf)) {
+			/*
+>------->------->------- * Source buffer is queued in the bitstream ringbuffer;
+>------->------->------- * queue the timestamp and mark source buffer as done
+>------->------->------- */
+			src_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);
+			rtk_jcodec_dbg(4, ctx, "remove bitstream src buf %d\n",
+				       src_buf->vb2_buf.index);
+
+			meta = kmalloc(sizeof(*meta), GFP_KERNEL);
+			if (meta) {
+				meta->sequence = src_buf->sequence;
+				meta->timecode = src_buf->timecode;
+				meta->timestamp = src_buf->vb2_buf.timestamp;
+				meta->start = start;
+				meta->end = ctx->bitstream_fifo.kfifo.in;
+				meta->last =
+					src_buf->flags & V4L2_BUF_FLAG_LAST;
+				if (meta->last)
+					rtk_jcodec_dbg(1, ctx,
+						       "meta %d is last\n",
+						       meta->sequence);
+
+				spin_lock(&ctx->meta_buffer_lock);
+				list_add_tail(&meta->list,
+					      &ctx->meta_buffer_list);
+				ctx->num_metas++;
+				spin_unlock(&ctx->meta_buffer_lock);
+
+				rtk_jcodec_dbg(
+					4, ctx, "Add meta sequence  : %d%s\n",
+					src_buf->sequence,
+					(src_buf->flags & V4L2_BUF_FLAG_LAST) ?
+						" (last)" :
+						"");
+				rtk_jcodec_dbg(4, ctx,
+					       "meta timestamp : %lld\n",
+					       meta->timestamp);
+				rtk_jcodec_dbg(4, ctx,
+					       "meta start     :"
+					       " 0x%x, meta->end : 0x%x\n",
+					       meta->start, meta->end);
+				rtk_jcodec_dbg(4, ctx, "num_metas      : %d\n",
+					       ctx->num_metas);
+			}
+
+			if (buffer_list) {
+				struct v4l2_m2m_buffer *m2m_buf;
+
+				m2m_buf = container_of(
+					src_buf, struct v4l2_m2m_buffer, vb);
+				list_add_tail(&m2m_buf->list, buffer_list);
+
+				rtk_jcodec_dbg(
+					4, ctx,
+					"Add %c frame %d to m2m buf list\n",
+					rtk_frame_type(src_buf->flags),
+					src_buf->sequence);
+			} else {
+				v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);
+
+				rtk_jcodec_dbg(4, ctx, "%c frame %d done\n",
+					       rtk_frame_type(src_buf->flags),
+					       src_buf->sequence);
+			}
+		} else {
+			v4l2_err(&ctx->dev->v4l2_dev,
+				 "rtk_bitstream_try_queue fail\n");
+			break;
+		}
+	}
+}
+
+static int rtk_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct rtk_jcodec_ctx *ctx = vb2_get_drv_priv(q);
+	struct v4l2_device *v4l2_dev = &ctx->dev->v4l2_dev;
+	struct rtk_q_data *q_data_src, *q_data_dst;
+	struct v4l2_m2m_buffer *m2m_buf, *tmp;
+	struct vb2_v4l2_buffer *buf;
+	struct list_head list;
+	int ret = 0;
+
+	if (count < 1) {
+		v4l2_err(&ctx->dev->v4l2_dev, "no buffer in queue\n");
+		return -EINVAL;
+	}
+
+	rtk_jcodec_dbg(1, ctx, "start streaming %s\n",
+		       v4l2_type_names[q->type]);
+
+	INIT_LIST_HEAD(&list);
+
+	q_data_src = rtk_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		//use_bit = 0
+		if (ctx->inst_type == RTK_JCODEC_CTX_DECODER && ctx->use_bit) {
+			/* copy the buffers that were queued before streamon */
+			mutex_lock(&ctx->bitstream_mutex);
+			rtk_feed_bitstream(ctx, &list);
+			mutex_unlock(&ctx->bitstream_mutex);
+
+			// TODO: refine later
+			// if (ctx->dev->devinfo->product != CODA_960 &&
+			//     rtk_get_bitstream_payload(ctx) < 512) {
+			// 	v4l2_err(v4l2_dev, "start payload < 512\n");
+			// 	ret = -EINVAL;
+			// 	goto err;
+			// }
+
+			if (!ctx->initialized) {
+				/* Run sequence initialization */
+				printk(KERN_INFO
+				       "[fn_name]:[\x1b[33m%s\033[0m], [line]: \x1b[33m%d\033[0m\n",
+				       __func__, __LINE__);
+				rtk_jcodec_dbg(1, ctx,
+					       "Run sequence initialization\n");
+				if (ctx->ops->seq_init_work) {
+					queue_work(ctx->dev->workqueue,
+						   &ctx->seq_init_work);
+					flush_work(&ctx->seq_init_work);
+				}
+			}
+		}
+
+		/*
+		 * Check the first input JPEG buffer to determine chroma
+		 * subsampling.
+		 */
+		if (q_data_src->fourcc == V4L2_PIX_FMT_JPEG) {
+			buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);
+			ret = rtk_jpeg_decode_header(ctx, &buf->vb2_buf);
+
+			/*
+			 * We have to start streaming even if the first buffer
+			 * does not contain a valid JPEG image. The error will
+			 * be caught during device run and will be signalled
+			 * via the capture buffer error flag.
+			 */
+
+			q_data_dst = get_q_data(
+				ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+			q_data_dst->width = round_up(q_data_src->width, 16);
+			q_data_dst->height = round_up(q_data_src->height, 16);
+			q_data_dst->bytesperline = q_data_dst->width;
+			if (ctx->params.jpeg_chroma_subsampling ==
+			    V4L2_JPEG_CHROMA_SUBSAMPLING_420) {
+				q_data_dst->sizeimage =
+					q_data_dst->bytesperline *
+					q_data_dst->height * 3 / 2;
+				if (q_data_dst->fourcc != V4L2_PIX_FMT_YUV420) {
+					q_data_dst->fourcc = V4L2_PIX_FMT_NV12;
+				}
+			} else if (ctx->params.jpeg_chroma_subsampling ==
+				   V4L2_JPEG_CHROMA_SUBSAMPLING_422) {
+				q_data_dst->sizeimage =
+					q_data_dst->bytesperline *
+					q_data_dst->height * 2;
+				q_data_dst->fourcc = V4L2_PIX_FMT_NV16;
+			} else if (ctx->params.jpeg_chroma_subsampling ==
+				   V4L2_JPEG_CHROMA_SUBSAMPLING_444) {
+				if (ctx->params.rgb) {
+					q_data_dst->fourcc = V4L2_PIX_FMT_RGB24;
+
+					q_data_dst->bytesperline =
+						q_data_dst->width * 3;
+
+				} else {
+					q_data_dst->fourcc = V4L2_PIX_FMT_NV24;
+				}
+
+				q_data_dst->sizeimage =
+					q_data_dst->bytesperline *
+					q_data_dst->height * 3;
+			}
+
+			q_data_dst->rect.left = 0;
+			q_data_dst->rect.top = 0;
+			q_data_dst->rect.width = q_data_src->width;
+			q_data_dst->rect.height = q_data_src->height;
+		}
+
+		ctx->streamon_out = 1;
+	} else {
+		ctx->streamon_cap = 1;
+	}
+
+	rtk_jcodec_dbg(1, ctx, "start streaming out(%d), cap(%d)\n",
+		       ctx->streamon_out, ctx->streamon_cap);
+
+	if (!(ctx->streamon_out && ctx->streamon_cap))
+		goto out;
+
+	q_data_dst = rtk_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+
+	rtk_jcodec_dbg(1, ctx, "src rect : %dx%d, dst : %dx%d\n",
+		       q_data_src->rect.width, q_data_src->rect.height,
+		       q_data_dst->width, q_data_dst->height);
+
+	if ((q_data_src->rect.width != q_data_dst->width &&
+	     round_up(q_data_src->rect.width, 16) != q_data_dst->width) ||
+	    (q_data_src->rect.height != q_data_dst->height &&
+	     round_up(q_data_src->rect.height, 16) != q_data_dst->height)) {
+		v4l2_err(v4l2_dev, "can't convert %dx%d to %dx%d\n",
+			 q_data_src->rect.width, q_data_src->rect.height,
+			 q_data_dst->width, q_data_dst->height);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/* Allow BIT decoder device_run with no new buffers queued */
+	if (ctx->inst_type == RTK_JCODEC_CTX_DECODER && ctx->use_bit)
+		v4l2_m2m_set_src_buffered(ctx->fh.m2m_ctx, true);
+
+	ctx->gopcounter = ctx->params.gop_size - 1;
+
+	// TODO: refine later
+	if (q_data_dst->fourcc == V4L2_PIX_FMT_JPEG)
+		ctx->params.gop_size = 1;
+
+	ctx->gopcounter = ctx->params.gop_size - 1;
+	/* Only decoders have this control */
+	if (ctx->mb_err_cnt_ctrl)
+		v4l2_ctrl_s_ctrl(ctx->mb_err_cnt_ctrl, 0);
+
+	ret = ctx->ops->start_streaming(ctx);
+	if (ctx->inst_type == RTK_JCODEC_CTX_DECODER) {
+		if (ret == -EAGAIN)
+			goto out;
+	}
+	if (ret < 0)
+		goto err;
+
+out:
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		list_for_each_entry_safe (m2m_buf, tmp, &list, list) {
+			list_del(&m2m_buf->list);
+			v4l2_m2m_buf_done(&m2m_buf->vb, VB2_BUF_STATE_DONE);
+		}
+	}
+
+	return 0;
+
+err:
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		list_for_each_entry_safe (m2m_buf, tmp, &list, list) {
+			list_del(&m2m_buf->list);
+			v4l2_m2m_buf_done(&m2m_buf->vb, VB2_BUF_STATE_QUEUED);
+		}
+		while ((buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))
+			v4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);
+	} else {
+		while ((buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))
+			v4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);
+	}
+	return ret;
+}
+
+static void rtk_stop_streaming(struct vb2_queue *q)
+{
+	struct rtk_jcodec_ctx *ctx = vb2_get_drv_priv(q);
+	struct vb2_v4l2_buffer *buf;
+	bool stop;
+
+	stop = ctx->streamon_out && ctx->streamon_cap;
+
+	rtk_jcodec_dbg(1, ctx, "stop streaming %s\n", v4l2_type_names[q->type]);
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		ctx->streamon_out = 0;
+		rtk_bitstream_end_flag(ctx);
+
+		ctx->qsequence = 0;
+
+		while ((buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx))) {
+			rtk_jcodec_dbg(1, ctx, "remove %d and set error\n",
+				       buf->vb2_buf.index);
+			v4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);
+		}
+	} else {
+		ctx->streamon_cap = 0;
+
+		ctx->osequence = 0;
+		ctx->sequence_offset = 0;
+
+		while ((buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx))) {
+			rtk_jcodec_dbg(1, ctx, "remove %d and set error\n",
+				       buf->vb2_buf.index);
+			v4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);
+		}
+	}
+
+	if (stop) {
+		struct rtk_meta_buffer *meta;
+		spin_lock(&ctx->meta_buffer_lock);
+		while (!list_empty(&ctx->meta_buffer_list)) {
+			meta = list_first_entry(&ctx->meta_buffer_list,
+						struct rtk_meta_buffer, list);
+			list_del(&meta->list);
+			kfree(meta);
+		}
+		ctx->num_metas = 0;
+		spin_unlock(&ctx->meta_buffer_lock);
+		kfifo_init(&ctx->bitstream_fifo, ctx->bitstream.vaddr,
+			   ctx->bitstream.size);
+		ctx->runcounter = 0;
+		ctx->aborting = 0;
+		ctx->hold = false;
+	}
+	if (!ctx->streamon_out && !ctx->streamon_cap) {
+		ctx->bit_stream_param &= ~RTK_BIT_STREAM_END_FLAG;
+	}
+}
+
+static const struct vb2_ops rtk_qops = {
+	.queue_setup = rtk_queue_setup,
+	.buf_prepare = rtk_buf_prepare,
+	.buf_queue = rtk_buf_queue,
+	.start_streaming = rtk_start_streaming,
+	.stop_streaming = rtk_stop_streaming,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+};
+
+static int rtk_jpeg_queue_init(struct rtk_jcodec_ctx *ctx, struct vb2_queue *vq)
+{
+	vq->drv_priv = ctx;
+	vq->ops = &rtk_qops;
+	vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);
+	vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	vq->lock = &ctx->dev->dev_mutex;
+	/* One way to indicate end-of-stream for coda is to set the
+	 * bytesused == 0. However by default videobuf2 handles bytesused
+	 * equal to 0 as a special case and changes its value to the size
+	 * of the buffer. Set the allow_zero_bytesused flag, so
+	 * that videobuf2 will keep the value of bytesused intact.
+	 */
+	vq->allow_zero_bytesused = 1;
+	/*
+	 * We might be fine with no buffers on some of the queues, but that
+	 * would need to be reflected in job_ready(). Currently we expect all
+	 * queues to have at least one buffer queued.
+	 */
+	vq->min_buffers_needed = 1;
+	/* below kernel 6.6 */
+	//vq->min_queued_buffers = 1;
+
+	vq->dev = ctx->dev->dev;
+	return vb2_queue_init(vq);
+}
+
+int rtk_encoder_queue_init(void *priv, struct vb2_queue *src_vq,
+			   struct vb2_queue *dst_vq)
+{
+	int ret;
+
+	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	src_vq->io_modes = VB2_DMABUF | VB2_MMAP;
+	src_vq->mem_ops = &vb2_dma_contig_memops;
+
+	ret = rtk_jpeg_queue_init(priv, src_vq);
+	if (ret)
+		return ret;
+
+	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	dst_vq->io_modes = VB2_DMABUF | VB2_MMAP;
+	dst_vq->mem_ops = &vb2_dma_contig_memops;
+
+	return rtk_jpeg_queue_init(priv, dst_vq);
+}
+#if 0
+int rtk_decoder_queue_init(void *priv, struct vb2_queue *src_vq,
+			    struct vb2_queue *dst_vq)
+{
+	int ret;
+
+	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	src_vq->io_modes = VB2_DMABUF | VB2_MMAP | VB2_USERPTR;
+	src_vq->mem_ops = &vb2_vmalloc_memops;
+	
+	ret = rtk_jpeg_queue_init(priv, src_vq);
+	if (ret)
+		return ret;
+
+	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	dst_vq->io_modes = VB2_DMABUF | VB2_MMAP;
+	dst_vq->dma_attrs = DMA_ATTR_NO_KERNEL_MAPPING;
+	dst_vq->mem_ops = &vb2_dma_contig_memops;
+
+	return rtk_jpeg_queue_init(priv, dst_vq);
+}
+#endif
+const struct rtk_context_ops rtk_jpeg_decode_ops = {
+	.queue_init = rtk_encoder_queue_init, /* non-bitstream operation */
+	.start_streaming = rtk_jpeg_start_decoding,
+	.prepare_run = rtk_jpeg_prepare_decode,
+	.finish_run = rtk_jpeg_finish_decode,
+	.release = rtk_jpeg_release,
+};
+const struct rtk_context_ops rtk_jpeg_encode_ops = {
+	.queue_init = rtk_encoder_queue_init,
+	.start_streaming = rtk_jpeg_start_encoding,
+	.prepare_run = rtk_jpeg_prepare_encode,
+	.finish_run = rtk_jpeg_finish_encode,
+	.run_timeout = rtk_jpeg_encode_timeout,
+	.release = rtk_jpeg_release,
+};
+irqreturn_t rtk_jcodec_irq_handler(int irq, void *data)
+{
+	struct rtk_jcodec_dev *dev = data;
+	struct rtk_jcodec_ctx *ctx;
+	int status;
+	int err_mb;
+
+	status = rtk_jcodec_read(dev, RTK_REG_JPEG_PIC_STATUS);
+	if (status == 0)
+		return IRQ_HANDLED;
+	rtk_jcodec_write(dev, status,
+			 RTK_REG_JPEG_PIC_STATUS); //interrupt_reason
+
+	if (status & RTK_JPEG_STATUS_OVERFLOW)
+		v4l2_err(&dev->v4l2_dev, "JPEG overflow\n");
+
+	if (status & RTK_JPEG_STATUS_BBC_INT)
+		v4l2_err(&dev->v4l2_dev, "JPEG BBC interrupt\n");
+
+	if (status & RTK_JPEG_STATUS_ERROR) {
+		v4l2_err(&dev->v4l2_dev, "JPEG error\n");
+
+		err_mb = rtk_jcodec_read(dev, RTK_REG_JPEG_PIC_ERRMB);
+		if (err_mb) {
+			v4l2_err(&dev->v4l2_dev,
+				 "ERRMB: 0x%x: rst idx %d, mcu pos (%d,%d)\n",
+				 err_mb, err_mb >> 24, (err_mb >> 12) & 0xfff,
+				 err_mb & 0xfff);
+		}
+	}
+
+	ctx = v4l2_m2m_get_curr_priv(dev->m2m_dev);
+	if (!ctx) {
+		v4l2_err(&dev->v4l2_dev,
+			 "Instance released before the end of transaction\n");
+		mutex_unlock(&dev->rtk_mutex);
+		return IRQ_HANDLED;
+	}
+
+	complete(&ctx->completion);
+
+	return IRQ_HANDLED;
+}
--- /dev/null
+++ b/drivers/media/platform/realtek/coda/rtk_jcodec/rtk_jcodec_regs.h
@@ -0,0 +1,136 @@
+//--=========================================================================--
+//  This file is a part of JPU Reference API project
+//-----------------------------------------------------------------------------
+//
+//       This confidential and proprietary software may be used only
+//     as authorized by a licensing agreement from Chips&Media Inc.
+//     In the event of publication, the following notice is applicable:
+//
+//            (C) COPYRIGHT 2006 - 2011  CHIPS&MEDIA INC.
+//                      ALL RIGHTS RESERVED
+//
+//       The entire notice above must be reproduced on all authorized
+//       copies.
+//
+//--=========================================================================--
+#ifndef __RTK_JCODEC_REGS_H__
+#define __RTK_JCODEC_REGS_H__
+
+#define RTK_REG_JPEG_DBUS (0x0000 + 0xF00)
+
+#define RTK_ROT_MIR_ENABLE (1 << 4)
+#define RTK_ROT_0 (0x0 << 0)
+#define RTK_ROT_90 (0x1 << 0)
+#define RTK_ROT_180 (0x2 << 0)
+#define RTK_ROT_270 (0x3 << 0)
+//#define RTK_JPEG_BASE				0x3000
+#define RTK_JPEG_BASE 0
+
+typedef enum {
+	JPG_START_PIC = 0,
+	JPG_START_INIT,
+	JPG_START_STOP,
+	JPG_START_PARTIAL
+} JpgStartCmd;
+
+#define RTK_REG_JPEG_PIC_START (RTK_JPEG_BASE + 0x000)
+#define RTK_REG_JPEG_PIC_STATUS (RTK_JPEG_BASE + 0x004)
+#define RTK_JPEG_STATUS_OVERFLOW BIT(3)
+#define RTK_JPEG_STATUS_BBC_INT BIT(2)
+#define RTK_JPEG_STATUS_ERROR BIT(1)
+#define RTK_JPEG_STATUS_DONE BIT(0)
+#define RTK_REG_JPEG_PIC_ERRMB (RTK_JPEG_BASE + 0x008)
+#define RTK_JPEG_ERRMB_RESTART_IDX_MASK (0xf << 24)
+#define RTK_JPEG_ERRMB_MCU_POS_X_MASK (0xfff << 12)
+#define RTK_JPEG_ERRMB_MCU_POS_Y_MASK 0xfff
+#define RTK_REG_JPEG_PIC_CTRL (RTK_JPEG_BASE + 0x010)
+#define RTK_JPEG_PIC_CTRL_USER_HUFFMAN_EN BIT(6)
+#define RTK_JPEG_PIC_CTRL_TC_DIRECTION BIT(4)
+#define RTK_JPEG_PIC_CTRL_ENCODER_EN BIT(3)
+#define RTK_REG_JPEG_PIC_SIZE (RTK_JPEG_BASE + 0x014)
+#define RTK_REG_JPEG_MCU_INFO (RTK_JPEG_BASE + 0x018)
+#define RTK_JPEG_MCU_BLOCK_NUM_OFFSET 16
+#define RTK_JPEG_COMP_NUM_OFFSET 12
+#define RTK_JPEG_COMP0_INFO_OFFSET 8
+#define RTK_JPEG_COMP1_INFO_OFFSET 4
+#define RTK_JPEG_COMP2_INFO_OFFSET 0
+#define RTK_REG_JPEG_ROT_INFO (RTK_JPEG_BASE + 0x01c)
+#define RTK_JPEG_ROT_MIR_ENABLE BIT(4)
+#define RTK_JPEG_ROT_MIR_MODE_MASK 0xf
+#define RTK_REG_JPEG_SCL_INFO (RTK_JPEG_BASE + 0x020)
+#define RTK_JPEG_SCL_ENABLE BIT(4)
+#define RTK_JPEG_SCL_HOR_MODE_MASK (0x3 << 2)
+#define RTK_JPEG_SCL_VER_MODE_MASK (0x3 << 0)
+#define RTK_REG_JPEG_IF_INFO (RTK_JPEG_BASE + 0x024)
+#define RTK_JPEG_SENS_IF_CLR BIT(1)
+#define RTK_JPEG_DISP_IF_CLR BIT(0)
+
+#define RTK_REG_JPEG_CLP_INFO_REG (RTK_JPEG_BASE + 0x028)
+
+#define RTK_REG_JPEG_OP_INFO (RTK_JPEG_BASE + 0x02c)
+#define RTK_JPEG_BUS_REQ_NUM_OFFSET 0
+#define RTK_JPEG_BUS_REQ_NUM_MASK 0x7
+
+#define RTK_REG_JPEG_DPB_CONFIG (RTK_JPEG_BASE + 0x030)
+#define RTK_REG_JPEG_DPB_BASE00 (RTK_JPEG_BASE + 0x034)
+#define RTK_REG_JPEG_DPB_BASE01 (RTK_JPEG_BASE + 0x038)
+#define RTK_REG_JPEG_DPB_BASE02 (RTK_JPEG_BASE + 0x03C)
+
+#define RTK_REG_JPEG_DPB_BASE10 (RTK_JPEG_BASE + 0x040)
+#define RTK_REG_JPEG_DPB_BASE11 (RTK_JPEG_BASE + 0x044)
+#define RTK_REG_JPEG_DPB_BASE12 (RTK_JPEG_BASE + 0x048)
+#define RTK_REG_JPEG_DPB_BASE20 (RTK_JPEG_BASE + 0x04C)
+
+#define RTK_REG_JPEG_DPB_BASE21 (RTK_JPEG_BASE + 0x050)
+#define RTK_REG_JPEG_DPB_BASE22 (RTK_JPEG_BASE + 0x054)
+#define RTK_REG_JPEG_DPB_BASE30 (RTK_JPEG_BASE + 0x058)
+#define RTK_REG_JPEG_DPB_BASE31 (RTK_JPEG_BASE + 0x05C)
+
+#define RTK_REG_JPEG_DPB_BASE32 (RTK_JPEG_BASE + 0x060)
+#define RTK_REG_JPEG_DPB_YSTRIDE (RTK_JPEG_BASE + 0x064)
+#define RTK_REG_JPEG_DPB_CSTRIDE (RTK_JPEG_BASE + 0x068)
+#define RTK_REG_JPEG_WRESP_CHECK (RTK_JPEG_BASE + 0x06C)
+
+#define RTK_REG_JPEG_CLP_BASE (RTK_JPEG_BASE + 0x070)
+#define RTK_REG_JPEG_CLP_SIZE (RTK_JPEG_BASE + 0x074)
+
+#define RTK_REG_JPEG_HUFF_CTRL (RTK_JPEG_BASE + 0x080)
+#define RTK_REG_JPEG_HUFF_ADDR (RTK_JPEG_BASE + 0x084)
+#define RTK_REG_JPEG_HUFF_DATA (RTK_JPEG_BASE + 0x088)
+#define RTK_REG_JPEG_QMAT_CTRL (RTK_JPEG_BASE + 0x090)
+#define RTK_REG_JPEG_QMAT_ADDR (RTK_JPEG_BASE + 0x094)
+#define RTK_REG_JPEG_QMAT_DATA (RTK_JPEG_BASE + 0x098)
+#define RTK_REG_JPEG_RST_INTVAL (RTK_JPEG_BASE + 0x0b0)
+#define RTK_REG_JPEG_RST_INDEX (RTK_JPEG_BASE + 0x0b4)
+#define RTK_REG_JPEG_RST_COUNT (RTK_JPEG_BASE + 0x0b8)
+#define RTK_REG_JPEG_DPCM_DIFF_Y (RTK_JPEG_BASE + 0x0f0)
+#define RTK_REG_JPEG_DPCM_DIFF_CB (RTK_JPEG_BASE + 0x0f4)
+#define RTK_REG_JPEG_DPCM_DIFF_CR (RTK_JPEG_BASE + 0x0f8)
+#define RTK_REG_JPEG_GBU_CTRL (RTK_JPEG_BASE + 0x100)
+#define RTK_REG_JPEG_GBU_BT_PTR (RTK_JPEG_BASE + 0x110)
+#define RTK_REG_JPEG_GBU_WD_PTR (RTK_JPEG_BASE + 0x114)
+#define RTK_REG_JPEG_GBU_TT_CNT (RTK_JPEG_BASE + 0x118)
+#define RTK_REG_JPEG_GBU_BBSR (RTK_JPEG_BASE + 0x140)
+#define RTK_REG_JPEG_GBU_BBER (RTK_JPEG_BASE + 0x144)
+#define RTK_REG_JPEG_GBU_BBIR (RTK_JPEG_BASE + 0x148)
+#define RTK_REG_JPEG_GBU_BBHR (RTK_JPEG_BASE + 0x14c)
+#define RTK_REG_JPEG_GBU_BCNT (RTK_JPEG_BASE + 0x158)
+#define RTK_REG_JPEG_GBU_FF_RPTR (RTK_JPEG_BASE + 0x160)
+#define RTK_REG_JPEG_GBU_FF_WPTR (RTK_JPEG_BASE + 0x164)
+#define RTK_REG_JPEG_BBC_END_ADDR (RTK_JPEG_BASE + 0x208)
+#define RTK_REG_JPEG_BBC_WR_PTR (RTK_JPEG_BASE + 0x20c)
+#define RTK_REG_JPEG_BBC_RD_PTR (RTK_JPEG_BASE + 0x210)
+#define RTK_REG_JPEG_BBC_EXT_ADDR (RTK_JPEG_BASE + 0x214)
+#define RTK_REG_JPEG_BBC_INT_ADDR (RTK_JPEG_BASE + 0x218)
+#define RTK_REG_JPEG_BBC_DATA_CNT (RTK_JPEG_BASE + 0x21c)
+#define RTK_REG_JPEG_BBC_COMMAND (RTK_JPEG_BASE + 0x220)
+#define RTK_REG_JPEG_BBC_BUSY (RTK_JPEG_BASE + 0x224)
+#define RTK_REG_JPEG_BBC_CTRL (RTK_JPEG_BASE + 0x228)
+#define RTK_REG_JPEG_BBC_CUR_POS (RTK_JPEG_BASE + 0x22c)
+#define RTK_REG_JPEG_BBC_BAS_ADDR (RTK_JPEG_BASE + 0x230)
+#define RTK_REG_JPEG_BBC_STRM_CTRL (RTK_JPEG_BASE + 0x234)
+#define RTK_REG_JPEG_BBC_FLUSH_CMD (RTK_JPEG_BASE + 0x238)
+
+#define JPU_DEC_CHECK_WRITE_RESPONSE_BVALID_SIGNAL 1
+
+#endif /* __RTK_JCODEC_REGS_H__ */
--- /dev/null
+++ b/drivers/media/platform/realtek/coda/rtk_jcodec/ve_common.h
@@ -0,0 +1,189 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ */
+#ifndef __VE_COMMON_H__
+#define __VE_COMMON_H__
+
+enum PICTURE_MODE {
+	INTERLEAVED_TOP_FIELD =
+		0, /* top	field data stored in even lines of a frame buffer */
+	INTERLEAVED_BOT_FIELD, /* bottom field data stored in odd  lines of a frame buffer */
+	CONSECUTIVE_TOP_FIELD, /* top	field data stored consecutlively in all lines of a field buffer */
+	CONSECUTIVE_BOT_FIELD, /* bottom field data stored consecutlively in all lines of a field buffer */
+	CONSECUTIVE_FRAME, /* progressive frame data stored consecutlively in all lines of a frame buffer */
+	INTERLEAVED_TOP_FIELD_422, /* top	field data stored in even lines of a frame buffer */
+	INTERLEAVED_BOT_FIELD_422, /* bottom field data stored in odd  lines of a frame buffer */
+	CONSECUTIVE_TOP_FIELD_422, /* top	field data stored consecutlively in all lines of a field buffer */
+	CONSECUTIVE_BOT_FIELD_422, /* bottom field data stored consecutlively in all lines of a field buffer */
+	CONSECUTIVE_FRAME_422, /* progressive frame with 4:2:2 chroma */
+	TOP_BOTTOM_FRAME, /* top field in the 0~height/2-1, bottom field in the height/2~height-1 in the frame */
+	INTERLEAVED_TOP_BOT_FIELD, /* one frame buffer contains one top and one bot field, top field first */
+	INTERLEAVED_BOT_TOP_FIELD, /* one frame buffer contains one bot and one top field, bot field first */
+
+	MPEG2_PIC_MODE_NOT_PROG /*yllin: for MPEG2 check pic mode usage */
+};
+
+struct yuv_state {
+	unsigned int version;
+	unsigned int mode;
+	unsigned int Y_addr;
+	unsigned int U_addr;
+	unsigned int pLock;
+	unsigned int width;
+	unsigned int height;
+	unsigned int Y_pitch;
+	unsigned int C_pitch;
+	unsigned int RPTSH;
+	unsigned int RPTSL;
+	unsigned int PTSH;
+	unsigned int PTSL;
+
+	/* for send two interlaced fields in the same packet,
+    valid only when mode is INTERLEAVED_TOP_BOT_FIELD or INTERLEAVED_BOT_TOP_FIELD*/
+	unsigned int RPTSH2;
+	unsigned int RPTSL2;
+	unsigned int PTSH2;
+	unsigned int PTSL2;
+
+	unsigned int context;
+	unsigned int pRefClock; /* not used now */
+
+	unsigned int pixelAR_hor; /* pixel aspect ratio hor, not used now */
+	unsigned int pixelAR_ver; /* pixel aspect ratio ver, not used now */
+
+	unsigned int Y_addr_Right; /* for mvc */
+	unsigned int U_addr_Right; /* for mvc */
+	unsigned int pLock_Right; /* for mvc */
+	unsigned int mvc; /* 1: mvc */
+	unsigned int
+		subPicOffset; /* 3D Blu-ray dependent-view sub-picture plane offset metadata as defined in BD spec sec. 9.3.3.6.
+    				Valid only when Y_BufId_Right and C_BufId_Right are both valid */
+	unsigned int pReceived; // fix bug 44329 by version 0x72746B30 'rtk0'
+	unsigned int
+		pReceived_Right; // fix bug 44329 by version 0x72746B30 'rtk0'
+
+	unsigned int fps; // 'rtk1'
+
+	unsigned int
+		IsForceDIBobMode; // force vo use bob mode to do deinterlace, 'rtk2'.
+	unsigned int lumaOffTblAddr; // 'rtk3'
+	unsigned int chromaOffTblAddr; // 'rtk3'
+	unsigned int lumaOffTblAddrR; // for mvc, 'rtk3'
+	unsigned int chromaOffTblAddrR; // for mvc, 'rtk3'
+
+	unsigned int bufBitDepth; // 'rtk3'
+	unsigned int
+		bufFormat; // 'rtk3', according to VO spec: 10bits Pixel Packing mode selection,
+	// "0": use 2 bytes to store 1 components. MSB justified.
+	// "1": use 4 bytes to store 3 components. LSB justified.
+
+	// VUI (Video Usability Information)
+	unsigned int transferCharacteristics; // 0:SDR, 1:HDR, 2:ST2084, 'rtk3'
+	// Mastering display colour volume SEI, 'rtk3'
+	unsigned int display_primaries_x0;
+	unsigned int display_primaries_y0;
+	unsigned int display_primaries_x1;
+	unsigned int display_primaries_y1;
+	unsigned int display_primaries_x2;
+	unsigned int display_primaries_y2;
+	unsigned int white_point_x;
+	unsigned int white_point_y;
+	unsigned int max_display_mastering_luminance;
+	unsigned int min_display_mastering_luminance;
+
+	// for transcode interlaced feild use.	//'rtk4'
+	unsigned int Y_addr_prev; //'rtk4'
+	unsigned int U_addr_prev; //'rtk4'
+	unsigned int Y_addr_next; //'rtk4'
+	unsigned int U_addr_next; //'rtk4'
+	unsigned int video_full_range_flag; //'rtk4' default= 1
+	unsigned int matrix_coefficients; //'rtk4' default= 1
+
+	// for transcode interlaced feild use.	//'rtk5'
+	unsigned int pLock_prev;
+	unsigned int pReceived_prev;
+	unsigned int pLock_next;
+	unsigned int pReceived_next;
+
+	unsigned int is_tch_video; //'rtk6'
+	unsigned int tch_hdr_metadata[144]; //'rtk6'
+
+	unsigned int pFrameBufferDbg; //'rtk7'
+	unsigned int pFrameBufferDbg_Right;
+	unsigned int Y_addr_EL; //'rtk8' for dolby vision
+	unsigned int U_addr_EL;
+	unsigned int width_EL;
+	unsigned int height_EL;
+	unsigned int Y_pitch_EL;
+	unsigned int C_pitch_EL;
+	unsigned int lumaOffTblAddr_EL;
+	unsigned int chromaOffTblAddr_EL;
+
+	unsigned int dm_reg1_addr;
+	unsigned int dm_reg1_size;
+	unsigned int dm_reg2_addr;
+	unsigned int dm_reg2_size;
+	unsigned int dm_reg3_addr;
+	unsigned int dm_reg3_size;
+	unsigned int dv_lut1_addr;
+	unsigned int dv_lut1_size;
+	unsigned int dv_lut2_addr;
+	unsigned int dv_lut2_size;
+
+	unsigned int slice_height; //'rtk8'
+
+	unsigned int hdr_metadata_addr; //'rtk9'
+	unsigned int hdr_metadata_size; //'rtk9'
+	unsigned int tch_metadata_addr; //'rtk9'
+	unsigned int tch_metadata_size; //'rtk9'
+	unsigned int is_dolby_video; //'rtk10'
+
+	unsigned int lumaOffTblSize; //'rtk11'
+	unsigned int chromaOffTblSize; //'rtk11'
+	// 'rtk12'
+	unsigned int Combine_Y_Addr;
+	unsigned int Combine_U_Addr;
+	unsigned int Combine_Width;
+	unsigned int Combine_Height;
+	unsigned int Combine_Y_Pitch;
+	unsigned int secure_flag;
+
+	// 'rtk13'
+	unsigned int tvve_picture_width;
+	unsigned int tvve_lossy_en;
+	unsigned int tvve_bypass_en;
+	unsigned int tvve_qlevel_sel_y;
+	unsigned int tvve_qlevel_sel_c;
+	unsigned int is_ve_tile_mode;
+	unsigned int film_grain_metadat_addr;
+	unsigned int film_grain_metadat_size;
+
+	// 'rtk14'
+	unsigned int partialSrcWin_x; //rtk14 0x72746B3E
+	unsigned int partialSrcWin_y;
+	unsigned int partialSrcWin_w;
+	unsigned int partialSrcWin_h;
+
+	// 'rtk15'
+	unsigned int dolby_out_hdr_metadata_addr; //rtk 15 0x72746B3F
+	unsigned int dolby_out_hdr_metadata_size;
+};
+
+/* simplified structure for capture buffer */
+struct ve_frame_info {
+	unsigned int rtk_meta_buf_id;
+	unsigned int is_ve1_buf;
+
+	struct yuv_state yuvs;
+
+	// priviate data
+	unsigned int hdr_type;
+};
+
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/debug.h
@@ -0,0 +1,67 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ */
+
+#ifndef __DEBUG_H__
+#define __DEBUG_H__
+
+#include <linux/videodev2.h>
+#include <linux/printk.h>
+
+/*
+ * The following categories are defined:
+ *
+ * INPUT: Used for gerneral input debug (output type)
+ *
+ * OUTPUT: Used for gerneral output debug (capture type)
+ *
+ * Enabling verbose debug messages is done through the rtkvdec.debug parameter,
+ * each category being enabled by a bit.
+ *
+ * rtkvdec.debug=0x1 will enable INPUT messages
+ * rtkvdec.debug=0x2 will enable OUTPUT messages
+ * rtkvdec.debug=0x3 will enable INPUT and OUTPUT messages
+ * ...
+ *
+ * An interesting feature is that it's possible to enable verbose logging at
+ * run-time by echoing the debug value in its sysfs node:
+ *   # echo 0xf > /sys/module/rtkvdec/parameters/debug
+ */
+#define VPU_DBG_NONE 0x00
+#define VPU_DBG_INPUT (1 << 0) // enable INPUT messages
+#define VPU_DBG_OUTPUT (1 << 1) // enable OUTPUT messages
+// ve1 log will use bit 16 ~ bit 31 of rtkvdec.debug for different category
+#define VPU_DBG_VE1_ALL (1 << 16) // enable all ve1 log
+#define VPU_DBG_VE1_UP_BS (1 << 17) // enable ve1 update bitstream buffer log
+#define VPU_DBG_VE1_DEC (1 << 18) // enable ve1 decode log
+#define VPU_DBG_VE1_DIS (1 << 19) // enable ve1 display log
+
+extern __printf(3, 4) void vpu_printk(const char *level, unsigned int category,
+				      const char *format, ...);
+
+#define vpu_err(fmt, ...) vpu_printk(KERN_ERR, VPU_DBG_NONE, fmt, ##__VA_ARGS__)
+
+#define vpu_warn(fmt, ...)                                                     \
+	vpu_printk(KERN_WARNING, VPU_DBG_NONE, fmt, ##__VA_ARGS__)
+
+#define vpu_info(fmt, ...)                                                     \
+	vpu_printk(KERN_INFO, VPU_DBG_NONE, fmt, ##__VA_ARGS__)
+
+#define vpu_dbg(fmt, ...)                                                     \
+	vpu_printk(KERN_DEBUG, VPU_DBG_NONE, fmt, ##__VA_ARGS__)
+
+#define vpu_input_dbg(fmt, ...)                                                \
+	vpu_printk(KERN_DEBUG, VPU_DBG_INPUT, fmt, ##__VA_ARGS__)
+
+#define vpu_output_dbg(fmt, ...)                                               \
+	vpu_printk(KERN_DEBUG, VPU_DBG_OUTPUT, fmt, ##__VA_ARGS__)
+
+#define V4L2_TYPE_TO_STR(type) (V4L2_TYPE_IS_OUTPUT(type) ? "out" : "cap")
+
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/drv_if.c
@@ -0,0 +1,1752 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#ifdef VPU_GET_CC
+#include <linux/module.h>
+#include <linux/netlink.h>
+#include <net/netlink.h>
+#include <net/net_namespace.h>
+#endif
+#include <linux/platform_device.h>
+#include <linux/of_reserved_mem.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
+#include <media/videobuf2-vmalloc.h>
+#include <media/videobuf2-dma-contig.h>
+#include <linux/firmware.h>
+#include <linux/dma-map-ops.h>
+#include <soc/realtek/memory.h>
+#include <soc/realtek/rtk_media_heap.h>
+#include "drv_if.h"
+#include "vpu.h"
+#include "debug.h"
+#include "rtkve1enc_common.h"
+
+unsigned int vpu_debug = 0;
+EXPORT_SYMBOL(vpu_debug);
+MODULE_PARM_DESC(
+	debug,
+	"activates debug info, where each bit enables a debug category.\n"
+	"\t\tBit 0 (0x01) will enable input messages (output type)\n"
+	"\t\tBit 1 (0x02) will enable output messages (capture type)\n");
+module_param_named(debug, vpu_debug, int, 0600);
+
+#define VPU_NAME "realtek-vpu"
+#define ENABLE_ADAPTIVE_PLAYBACK (0)
+#define ENABLE_REORDER_PTS (0)
+#define INVERT_BITVAL_1 (~1)
+
+#define RTKDEV_FOURCC_ENC v4l2_fourcc('R', 'E', 'N', 'C')
+#define RTKDEV_FOURCC_DEC v4l2_fourcc('R', 'D', 'E', 'C')
+
+static ssize_t get_instance_info(struct device *dev, struct device_attribute *attr,
+			 char *buf);
+
+static DEVICE_ATTR(instance_info, S_IRUSR, get_instance_info, NULL);
+
+static ssize_t set_enhance_mode(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count);
+
+static DEVICE_ATTR(enhance, S_IWUSR, NULL, set_enhance_mode);
+
+enum { V4L2_M2M_SRC = 0,
+       V4L2_M2M_DST = 1,
+};
+
+#ifdef VPU_GET_CC
+static struct sock *cc_data_sk = NULL;
+__u32 ccReaderPid;
+bool bcc_data_channel_bind;
+#define NETLINK_CC_DATA 31
+#define CC_DATA_LINK 0x12
+#define CC_DATA_UNLINK 0x13
+#endif
+
+static const struct rtkve1_drv_ops kent_drv_ops = {
+	.get_instance_pool = kent_vdi_ioctl_get_instance_pool,
+	.get_register_info = kent_vdi_ioctl_get_register_info,
+	.set_rtk_clk_gating = kent_vdi_ioctl_set_rtk_clk_gating,
+	.get_common_memory = kent_vdi_ioctl_get_common_memory,
+	.write_bit_firmware = kent_vdi_write_bit_firmware,
+	.allocate_physical_memory = kent_vdi_ioctl_allocate_physical_memory,
+	.free_physical_memory = kent_vdi_ioctl_free_physical_memory,
+	.allocate_physical_memory_no_mmap = kent_vdi_ioctl_allocate_physical_memory_no_mmap,
+	.free_physical_memory_no_mmap = kent_vdi_ioctl_free_physical_memory_no_mmap,
+	.open_instance = kent_vdi_ioctl_open_instance,
+	.close_instance = kent_vdi_ioctl_close_instance,
+	.wait_interrupt = kent_vdi_ioctl_wait_interrupt,
+};
+
+static const struct rtkve1_drv_ops stark_drv_ops = {
+	.get_instance_pool = rtd16xxb_vdi_ioctl_get_instance_pool,
+	.get_register_info = rtd16xxb_vdi_ioctl_get_register_info,
+	.set_rtk_clk_gating = rtd16xxb_vdi_ioctl_set_rtk_clk_gating,
+	.get_common_memory = rtd16xxb_vdi_ioctl_get_common_memory,
+	.write_bit_firmware = rtd16xxb_vdi_write_bit_firmware,
+	.allocate_physical_memory = rtd16xxb_vdi_ioctl_allocate_physical_memory,
+	.free_physical_memory = rtd16xxb_vdi_ioctl_free_physical_memory,
+	.allocate_physical_memory_no_mmap = rtd16xxb_vdi_ioctl_allocate_physical_memory_no_mmap,
+	.free_physical_memory_no_mmap = rtd16xxb_vdi_ioctl_free_physical_memory_no_mmap,
+	.open_instance = rtd16xxb_vdi_ioctl_open_instance,
+	.close_instance = rtd16xxb_vdi_ioctl_close_instance,
+	.wait_interrupt = rtd16xxb_vdi_ioctl_wait_interrupt,
+};
+
+static const struct rtkve_match_data rtkve_data[] = {
+	[RTK_STARK] = {
+		.product = RTK_STARK,
+		.fw_name = "realtek/rtd1619b/coda988_fw.bin",
+		.drv_ops = stark_drv_ops,
+		.gpu_cache = 0,
+	},
+	[RTK_KENT] = {
+		.product = RTK_KENT,
+		.fw_name = "realtek/rtd1625/boda955_fw.bin",
+		.drv_ops = kent_drv_ops,
+		.gpu_cache = 1,
+	},
+};
+
+static inline struct videc_ctx *file2ctx(struct file *file)
+{
+	return container_of(file->private_data, struct videc_ctx, fh);
+}
+
+void vpu_printk(const char *level, unsigned int category, const char *format,
+		...)
+{
+	struct va_format vaf;
+	va_list args;
+
+	if (category != VPU_DBG_NONE && !(vpu_debug & category))
+		return;
+
+	va_start(args, format);
+	vaf.fmt = format;
+	vaf.va = &args;
+
+	printk("%s"
+	       "[VDEC] %s %pV",
+	       level, strcmp(level, KERN_ERR) == 0 ? " *ERROR*" : "", &vaf);
+
+	va_end(args);
+}
+EXPORT_SYMBOL(vpu_printk);
+
+/*
+ * mem2mem callbacks
+ */
+
+/**
+ * job_ready() - check whether an instance is ready to be scheduled to run
+ */
+static int job_ready(void *priv)
+{
+	(void)priv;
+	vpu_input_dbg("%s\n", __func__);
+	return 1;
+}
+
+static void job_abort(void *priv)
+{
+	u32 *rtk_fourcc = (u32 *)priv;
+	struct rtkve1enc_ctx *enc_ctx;
+	struct videc_ctx *ctx = NULL;
+	struct videc_dev *dev = NULL;
+	const struct vpu_fmt_ops *op = NULL;
+	vpu_input_dbg("%s\n", __func__);
+
+	if (*rtk_fourcc == RTKDEV_FOURCC_ENC) {
+		enc_ctx = (struct rtkve1enc_ctx *)priv;
+		dev_dbg(enc_ctx->dev->dev, "%d.%s\n",
+			__LINE__, __func__);
+	}
+	else {
+		ctx = priv;
+		dev = ctx->dev;
+		op = get_vpu_fmt_ops();
+
+		if (!op)
+			return;
+		/* Will cancel the transaction in the next interrupt handler */
+		op->vpu_abort(priv, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+		op->vpu_abort(priv, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+		v4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);
+	}
+
+	vpu_input_dbg("%s done\n", __func__);
+}
+
+/* device_run() - prepares and starts the device
+ *
+ * This simulates all the immediate preparations required before starting
+ * a device. This will be called by the framework when it decides to schedule
+ * a particular instance.
+ */
+static void device_run(void *priv)
+{
+	u32 *rtk_fourcc = (u32 *)priv;
+	struct rtkve1enc_ctx *enc_ctx;
+
+	if (*rtk_fourcc == RTKDEV_FOURCC_ENC) {
+		//pr_err("%d.%s.priv:0x%px.encode rtk_fourcc:0x%x\n",
+		//	__LINE__, __func__,
+		//	priv, *rtk_fourcc);
+		enc_ctx = (struct rtkve1enc_ctx *)priv;
+		queue_work(enc_ctx->dev->encode_workqueue, &enc_ctx->encode_work);
+	}
+	else if (*rtk_fourcc == RTKDEV_FOURCC_DEC) {
+		//pr_err("%d.%s.priv:0x%px.decode rtk_fourcc:0x%x\n",
+		//	__LINE__, __func__,
+		//	priv, *rtk_fourcc);
+	}
+	else {
+		pr_err("%d.%s.priv:0x%px.unkown rtk_fourcc:0x%x\n",
+			__LINE__, __func__,
+			priv, *rtk_fourcc);
+	}
+}
+
+/*
+ * video ioctls
+ */
+static int vidioc_querycap(struct file *file, void *priv,
+			   struct v4l2_capability *cap)
+{
+	strncpy(cap->driver, VPU_NAME, sizeof(cap->driver) - 1);
+	strncpy(cap->card, VPU_NAME, sizeof(cap->card) - 1);
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s", VPU_NAME);
+	cap->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+	return 0;
+}
+
+static int videc_enum_fmt_vid_cap(struct file *file, void *priv,
+				  struct v4l2_fmtdesc *f)
+{
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	if (!op) {
+		vpu_err("vpu ops is NULL\n");
+		return 0;
+	}
+
+	return op->vpu_enum_fmt_cap(f);
+}
+
+static int videc_enum_fmt_vid_out(struct file *file, void *priv,
+				  struct v4l2_fmtdesc *f)
+{
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	if (!op) {
+		vpu_err("vpu ops is NULL\n");
+		return 0;
+	}
+
+	return op->vpu_enum_fmt_out(f);
+}
+
+static int videc_g_fmt(struct file *file, void *priv, struct v4l2_format *f)
+{
+	struct v4l2_fh *fh = file->private_data;
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	struct vb2_queue *vq;
+
+	if (!op) {
+		vpu_err("vpu ops is NULL\n");
+		return -EINVAL;
+	}
+
+	vq = v4l2_m2m_get_vq(fh->m2m_ctx, f->type);
+	if (!vq) {
+		vpu_err("no vb2 queue for type=%d", f->type);
+		return -EINVAL;
+	}
+
+	return op->vpu_g_fmt(priv, f);
+}
+
+static int videc_try_fmt_vid_cap(struct file *file, void *priv,
+				 struct v4l2_format *f)
+{
+	struct v4l2_fh *fh = file->private_data;
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+
+	if (!op) {
+		vpu_err("vpu ops is NULL\n");
+		return 0;
+	}
+
+	return op->vpu_try_fmt_cap(fh, f);
+}
+
+static int videc_try_fmt_vid_out(struct file *file, void *priv,
+				 struct v4l2_format *f)
+{
+	struct v4l2_fh *fh = file->private_data;
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	if (!op) {
+		vpu_err("vpu ops is NULL\n");
+		return 0;
+	}
+
+	return op->vpu_try_fmt_out(fh, f);
+}
+
+static int videc_s_fmt_vid_cap(struct file *file, void *priv,
+			       struct v4l2_format *f)
+{
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	if (!op) {
+		vpu_err("vpu ops is NULL\n");
+		return 0;
+	}
+
+	return op->vpu_s_fmt_cap(priv, f);
+}
+
+static int videc_s_fmt_vid_out(struct file *file, void *priv,
+			       struct v4l2_format *f)
+{
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	if (!op) {
+		vpu_err("vpu ops is NULL\n");
+		return 0;
+	}
+
+	return op->vpu_s_fmt_out(priv, f);
+}
+
+static int vpu_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct videc_ctx *ctx =
+		container_of(ctrl->handler, struct videc_ctx, ctrl_hdl);
+
+	switch (ctrl->id) {
+	case RTK_V4L2_SET_SECURE: {
+		ctx->params.is_secure = ctrl->val;
+#ifndef ENABLE_TEE_DRM_FLOW
+		if (ctx->params.is_secure) {
+			ctx->params.is_secure = 0;
+			vpu_err("Driver doesn't support secure, force normal buffer\n");
+		}
+#endif
+		break;
+	}
+	case RTK_V4L2_DEC_PARMS_CONFIG: {
+		struct rtk_dec_params *param = ctrl->p_new.p;
+		memcpy(&ctx->params.dec_params, param,
+		       sizeof(struct rtk_dec_params));
+
+		ctx->params.dec_params.en_adaptive_playback = ENABLE_ADAPTIVE_PLAYBACK;
+#ifndef REORDER_PTS
+		if (ctx->params.dec_params.en_pts_reorder) {
+			ctx->params.dec_params.en_pts_reorder = 0;
+			vpu_err("Driver doesn't support enabling pts reorder\n");
+		}
+#endif
+		break;
+	}
+	case V4L2_CID_COLORIMETRY_HDR10_CLL_INFO: {
+		memcpy(&ctx->params.cll, ctrl->p_new.p_hdr10_cll,
+		       sizeof(struct v4l2_ctrl_hdr10_cll_info));
+		ctx->params_update = true;
+		break;
+	}
+	case V4L2_CID_COLORIMETRY_HDR10_MASTERING_DISPLAY: {
+		memcpy(&ctx->params.mastering, ctrl->p_new.p_hdr10_mastering,
+		       sizeof(struct v4l2_ctrl_hdr10_mastering_display));
+		ctx->params_update = true;
+		break;
+	}
+	default: {
+		vpu_err("Invalid control, id=%d, val=%d\n", ctrl->id,
+			ctrl->val);
+		return -EINVAL;
+	}
+	}
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,6,0)
+static bool vpu_ctrl_type_equal(const struct v4l2_ctrl *ctrl, u32 idx,
+				union v4l2_ctrl_ptr ptr1,
+				union v4l2_ctrl_ptr ptr2)
+{
+	idx *= ctrl->elem_size;
+	return !memcmp(ptr1.p_const + idx, ptr2.p_const + idx, ctrl->elem_size);
+}
+#else
+static bool vpu_ctrl_type_equal(const struct v4l2_ctrl *ctrl,
+				union v4l2_ctrl_ptr ptr1,
+				union v4l2_ctrl_ptr ptr2)
+{
+	return !memcmp(ptr1.p_const, ptr2.p_const, ctrl->elems * ctrl->elem_size);
+}
+#endif
+
+static void vpu_ctrl_type_init(const struct v4l2_ctrl *ctrl, u32 idx,
+			       union v4l2_ctrl_ptr ptr)
+{
+	void *p = ptr.p + idx * ctrl->elem_size;
+
+	if (ctrl->p_def.p_const)
+		memcpy(p, ctrl->p_def.p_const, ctrl->elem_size);
+	else
+		memset(p, 0, ctrl->elem_size);
+}
+
+static void vpu_ctrl_type_log(const struct v4l2_ctrl *ctrl)
+{
+	if (ctrl->is_array) {
+		unsigned i;
+
+		for (i = 0; i < ctrl->nr_of_dims; i++)
+			pr_cont("[%u]", ctrl->dims[i]);
+		pr_cont(" ");
+	}
+
+	pr_cont("RTK DEC PARAMS");
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,6,0)
+static int vpu_ctrl_type_validate(const struct v4l2_ctrl *ctrl, u32 idx,
+#else
+static int vpu_ctrl_type_validate(const struct v4l2_ctrl *ctrl,
+#endif
+				  union v4l2_ctrl_ptr ptr)
+{
+	return 0;
+}
+
+static int vpu_g_v_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct vpu_fmt vpu_fmt;
+	int ret = 0;
+	struct videc_ctx *vid_ctx =
+		container_of(ctrl->handler, struct videc_ctx, ctrl_hdl);
+	struct v4l2_fh *fh = &vid_ctx->fh;
+
+	switch (ctrl->id) {
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		vpu_get_cap_fmt(fh, (void *)&vpu_fmt);
+		ctrl->val = vpu_fmt.misc.bufcnt;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops vpu_ctrl_ops = {
+	.s_ctrl = vpu_s_ctrl,
+	.g_volatile_ctrl = vpu_g_v_ctrl,
+};
+
+static const struct v4l2_ctrl_type_ops vpu_type_ops = {
+	.equal = vpu_ctrl_type_equal,
+	.init = vpu_ctrl_type_init,
+	.log = vpu_ctrl_type_log,
+	.validate = vpu_ctrl_type_validate,
+};
+
+static const struct v4l2_ctrl_config rtk_ctrl_set_secure = {
+	.ops = &vpu_ctrl_ops,
+	.id = RTK_V4L2_SET_SECURE,
+	.name = "Enable Secure Buffer(SVP)",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.def = 0,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config rtk_ctrl_dec_params = {
+	.ops = &vpu_ctrl_ops,
+	.type_ops = &vpu_type_ops,
+	.id = RTK_V4L2_DEC_PARMS_CONFIG,
+	.name = "Decoder parameters",
+	.type = V4L2_CTRL_TYPE_RTK_DEC_PARAM,
+	.def = 0,
+	.min = 0,
+	.max = UINT_MAX,
+	.step = 1,
+	.elem_size = sizeof(struct rtk_dec_params),
+};
+
+int vpu_ctrls_setup(struct videc_ctx *ctx)
+{
+	struct v4l2_ctrl *ctrl;
+	struct v4l2_ctrl_hdr10_cll_info p_hdr10_cll = { 1000, 400 };
+	struct v4l2_ctrl_hdr10_mastering_display p_hdr10_mastering = {
+		{ 34000, 13250, 7500 },
+		{ 16000, 34500, 3000 },
+		15635,
+		16450,
+		10000000,
+		500,
+	};
+
+	v4l2_ctrl_handler_init(&ctx->ctrl_hdl, 5);
+
+	ctrl = v4l2_ctrl_new_std(&ctx->ctrl_hdl, &vpu_ctrl_ops,
+				 V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 1);
+	ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;
+
+	v4l2_ctrl_new_std_compound(&ctx->ctrl_hdl, &vpu_ctrl_ops,
+				   V4L2_CID_COLORIMETRY_HDR10_CLL_INFO,
+				   v4l2_ctrl_ptr_create(&p_hdr10_cll));
+
+	v4l2_ctrl_new_std_compound(&ctx->ctrl_hdl, &vpu_ctrl_ops,
+				   V4L2_CID_COLORIMETRY_HDR10_MASTERING_DISPLAY,
+				   v4l2_ctrl_ptr_create(&p_hdr10_mastering));
+
+	v4l2_ctrl_new_custom(&ctx->ctrl_hdl, &rtk_ctrl_set_secure, NULL);
+	v4l2_ctrl_new_custom(&ctx->ctrl_hdl, &rtk_ctrl_dec_params, NULL);
+
+	if (ctx->ctrl_hdl.error) {
+		vpu_err("control initialization error (%d)",
+			ctx->ctrl_hdl.error);
+		v4l2_ctrl_handler_free(&ctx->ctrl_hdl);
+		return -EINVAL;
+	}
+
+	return v4l2_ctrl_handler_setup(&ctx->ctrl_hdl);
+}
+
+static int videc_reqbufs(struct file *file, void *priv,
+				struct v4l2_requestbuffers *rb)
+{
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	struct v4l2_fh *fh = file->private_data;
+	struct videc_ctx *ctx = file2ctx(file);
+	struct device *dev = ctx->dev->dev;
+	int ret = 0;
+
+	mutex_lock(&dev->mutex);
+	rheap_setup_dma_pools(dev, "rtk_media_heap",
+	                      RTK_FLAG_NONCACHED | RTK_FLAG_SCPUACC |
+	                      RTK_FLAG_VO_POOL, __func__);
+	ret = v4l2_m2m_ioctl_reqbufs(file, priv, rb);
+	mutex_unlock(&dev->mutex);
+	if (ret)
+		return ret;
+
+	vpu_info("%s reqbuf %d", v4l2_type_names[rb->type], rb->count);
+
+	if (V4L2_TYPE_IS_OUTPUT(rb->type))
+		ctx->reqbuf_out = rb->count;
+	else
+		ctx->reqbuf_cap = rb->count;
+
+	if (ctx->has_stream_on &&
+		ctx->reqbuf_out == 0 && ctx->reqbuf_cap == 0) {
+		op->vpu_reset_resource(fh);
+		ctx->ve_ctx = NULL;
+		ctx->reqbuf_out = -1;
+		ctx->reqbuf_cap = -1;
+	} else if (ctx->reqbuf_cap == 0) {
+		if (op->vpu_free_capture)
+			op->vpu_free_capture(fh);
+	}
+
+	return ret;
+}
+
+static int videc_querybuf(struct file *file, void *priv,
+			  struct v4l2_buffer *buf)
+{
+	int ret;
+
+	ret = v4l2_m2m_ioctl_querybuf(file, priv, buf);
+	return ret;
+}
+
+static int videc_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)
+{
+	struct v4l2_fh *fh = file->private_data;
+	struct videc_ctx *ctx = file2ctx(file);
+
+	if (V4L2_TYPE_IS_OUTPUT(buf->type) &&
+	    buf->memory == V4L2_MEMORY_DMABUF &&
+	    ctx->params.is_secure == true) {
+		struct vb2_queue *vq;
+		struct v4l2_fh *fh = file->private_data;
+		struct vb2_buffer *vb;
+
+		vq = v4l2_m2m_get_vq(fh->m2m_ctx, buf->type);
+		vb = vq->bufs[buf->index];
+		vb->planes[0].length = PAGE_ALIGN(buf->length);
+		buf->length = 0;
+	}
+
+	return v4l2_m2m_qbuf(file, fh->m2m_ctx, buf);
+}
+
+static int videc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)
+{
+	struct v4l2_fh *fh = file->private_data;
+
+	struct videc_ctx *vid_ctx = file2ctx(file);
+	struct vpu_ctx *vpu_ctx = vid_ctx->vpu_ctx;
+	if(vpu_ctx->is_decoder_error){
+		vpu_err("Call on DQBUF after decoder error");
+		return -EIO;
+	}
+
+	return v4l2_m2m_dqbuf(file, fh->m2m_ctx, buf);
+}
+
+static int videc_create_bufs(struct file *file, void *priv,
+			     struct v4l2_create_buffers *create)
+{
+	int ret;
+
+	ret = v4l2_m2m_ioctl_create_bufs(file, priv, create);
+	return ret;
+}
+int videc_prepare_buf(struct file *file, void *priv, struct v4l2_buffer *buf)
+{
+	int ret;
+
+	ret = v4l2_m2m_ioctl_prepare_buf(file, priv, buf);
+	return ret;
+}
+
+int videc_expbuf(struct file *file, void *priv, struct v4l2_exportbuffer *eb)
+{
+	int ret;
+
+	ret = v4l2_m2m_ioctl_expbuf(file, priv, eb);
+
+	return ret;
+}
+
+static int videc_g_selection(struct file *file, void *fh,
+			     struct v4l2_selection *sel)
+{
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	struct v4l2_rect rsel;
+	int ret;
+	if (!op) {
+		vpu_err("vpu ops is NULL\n");
+		return 0;
+	}
+
+
+	ret = op->vpu_g_crop(fh, &rsel);
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+	case V4L2_SEL_TGT_COMPOSE_PADDED:
+		//todo
+		/* fallthrough */
+	case V4L2_SEL_TGT_COMPOSE:
+	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
+		if (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			return -EINVAL;
+		//todo
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	memcpy(&sel->r, &rsel, sizeof(struct v4l2_rect));
+
+	return ret;
+}
+
+static int videc_frmsizeenum(struct file *file, void *priv,
+			     struct v4l2_frmsizeenum *fsize)
+{
+	int ret = 0;
+	struct v4l2_frmsize_stepwise *frmsize = NULL;
+
+	if (fsize->index != 0)
+		return -EINVAL;
+
+	frmsize = (struct v4l2_frmsize_stepwise *)vpu_get_frmsize(
+		fsize->pixel_format);
+	if (frmsize) {
+		memcpy(&fsize->stepwise, frmsize,
+		       sizeof(struct v4l2_frmsize_stepwise));
+	} else {
+		ret = -ENOTTY;
+	}
+
+	fsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;
+
+	return ret;
+}
+
+int videc_subscribe_event(struct v4l2_fh *fh,
+			  const struct v4l2_event_subscription *sub)
+{
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+
+	switch (sub->type) {
+	case V4L2_EVENT_SOURCE_CHANGE:
+		vid_ctx->is_sub_res_chg = true;
+		return v4l2_src_change_event_subscribe(fh, sub);
+	case V4L2_EVENT_EOS:
+		return v4l2_event_subscribe(fh, sub, 0, NULL);
+	default:
+		return v4l2_ctrl_subscribe_event(fh, sub);
+	}
+}
+
+static int videc_try_decoder_cmd(struct file *file, void *fh,
+				 struct v4l2_decoder_cmd *dc)
+{
+	return v4l2_m2m_ioctl_try_decoder_cmd(file, fh, dc);
+}
+
+static int videc_decoder_cmd(struct file *file, void *fh,
+			     struct v4l2_decoder_cmd *dc)
+{
+	struct videc_ctx *vid_ctx = file2ctx(file);
+	struct vpu_ctx *vpu_ctx = vid_ctx->vpu_ctx;
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	int ret = 0;
+
+	ret = videc_try_decoder_cmd(file, fh, dc);
+	if (ret < 0)
+		return ret;
+
+	if (!op) {
+		vpu_err("vpu ops is NULL\n");
+		return 0;
+	}
+
+	vpu_info("decoder cmd=%u", dc->cmd);
+
+	if (vpu_ctx->stop_cmd) {
+		// the drain sequence is initiated
+		if (!vpu_ctx->last_buf_done) {
+			// the drain sequence is in progress and is not completed
+			if ((dc->cmd == V4L2_DEC_CMD_STOP) || (dc->cmd == V4L2_DEC_CMD_START)) {
+				vpu_err("return -EBUSY when received cmd:%d while the drain sequence is in progress\n",dc->cmd);
+				return -EBUSY;
+			}
+		}
+	}
+
+	switch (dc->cmd) {
+	case V4L2_DEC_CMD_STOP:
+		/* Defer vpu stop */
+		vpu_ctx->stop_cmd = true;
+		break;
+	case V4L2_DEC_CMD_START:
+		vpu_ctx->stop_cmd = false;
+		vpu_ctx->last_buf_done = false;
+		ret = op->vpu_start_cmd(fh);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ioctl_ops vpu_ioctl_ops = {
+	.vidioc_querycap = vidioc_querycap,
+
+	.vidioc_enum_fmt_vid_cap = videc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap_mplane = videc_g_fmt,
+	.vidioc_try_fmt_vid_cap_mplane	= videc_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap_mplane	= videc_s_fmt_vid_cap,
+
+	.vidioc_enum_fmt_vid_out = videc_enum_fmt_vid_out,
+	.vidioc_g_fmt_vid_out_mplane = videc_g_fmt,
+	.vidioc_try_fmt_vid_out_mplane	= videc_try_fmt_vid_out,
+	.vidioc_s_fmt_vid_out_mplane = videc_s_fmt_vid_out,
+
+	.vidioc_reqbufs = videc_reqbufs,
+	.vidioc_querybuf = videc_querybuf,
+	.vidioc_qbuf = videc_qbuf,
+	.vidioc_dqbuf = videc_dqbuf,
+	.vidioc_prepare_buf = videc_prepare_buf,
+	.vidioc_create_bufs = videc_create_bufs,
+	.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,
+	.vidioc_g_selection = videc_g_selection,
+	.vidioc_streamon = v4l2_m2m_ioctl_streamon,
+	.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,
+
+	.vidioc_enum_framesizes = videc_frmsizeenum,
+	.vidioc_subscribe_event = videc_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+
+	.vidioc_try_decoder_cmd = videc_try_decoder_cmd,
+	.vidioc_decoder_cmd = videc_decoder_cmd,
+};
+
+/*
+ * Queue operations
+ */
+
+static int videc_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,
+			     unsigned int *nplanes, unsigned int sizes[],
+			     struct device *alloc_devs[])
+{
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	struct videc_ctx *ctx = vb2_get_drv_priv(vq);
+	vpu_input_dbg("%s\n", __func__);
+	if (!op) {
+		vpu_err("vpu ops is NULL\n");
+		return 0;
+	}
+
+	alloc_devs[0] = ctx->dev->v4l2_dev.dev;
+	return op->vpu_queue_info(vq, nbuffers, nplanes, &sizes[0]);
+}
+
+static int videc_buf_prepare(struct vb2_buffer *vb)
+{
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	int sizeimages, ret;
+	unsigned int nplanes = 0;
+
+	if (!op) {
+		vpu_err("vpu ops is NULL\n");
+		return 0;
+	}
+
+	ret = op->vpu_queue_info(vb->vb2_queue, NULL, &nplanes, &sizeimages);
+	if (ret)
+		return ret;
+
+	if (V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {
+		if (vbuf->field == V4L2_FIELD_ANY)
+			vbuf->field = V4L2_FIELD_NONE;
+	}
+
+	if (vb2_plane_size(vb, 0) < sizeimages) {
+		vpu_err("%s data will not fit into plane (%lu < %lu)\n",
+			__func__, vb2_plane_size(vb, 0), (long)sizeimages);
+		return -EINVAL;
+	}
+
+	if (!V4L2_TYPE_IS_OUTPUT(vb->type)) {
+		vb2_set_plane_payload(vb, 0, sizeimages);
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+		vb->planes[0].data_offset = METADATA_OFFSET;
+#endif
+	}
+
+	return 0;
+}
+
+static void videc_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct videc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+
+	v4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);
+	if (!op) {
+		vpu_err("vpu ops is NULL\n");
+		return;
+	}
+	op->vpu_qbuf(&ctx->fh, vb);
+}
+
+static int videc_start_streaming(struct vb2_queue *q, unsigned count)
+{
+	struct videc_ctx *ctx = vb2_get_drv_priv(q);
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	int ret;
+	vpu_info("%s %s\n", __func__, V4L2_TYPE_TO_STR(q->type));
+
+	if (!op) {
+		vpu_err("vpu ops is NULL\n");
+		return 0;
+	}
+	ret = op->vpu_start_streaming(q, count);
+	if (ret) {
+		vpu_err("vpu_start_streaming fail ret %d\n", ret);
+		return ret;
+	}
+
+	ctx->has_stream_on = true;
+	return 0;
+}
+
+static void videc_stop_streaming(struct vb2_queue *q)
+{
+	struct videc_ctx *ctx = vb2_get_drv_priv(q);
+	struct vb2_v4l2_buffer *vbuf;
+	unsigned long flags;
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	int ret;
+	vpu_info("%s %s\n", __func__, V4L2_TYPE_TO_STR(q->type));
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		for (;;) {
+			vbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);
+			if (vbuf == NULL)
+				break;
+			spin_lock_irqsave(&ctx->dev->irqlock, flags);
+			v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);
+			spin_unlock_irqrestore(&ctx->dev->irqlock, flags);
+		}
+	}
+
+	if (!op) {
+		vpu_err("vpu ops is NULL\n");
+		return;
+	}
+
+	ret = op->vpu_stop_streaming(q);
+	if (ret) {
+		vpu_err("vpu_stop_streaming fail ret %d\n", ret);
+	}
+	return;
+}
+
+#ifdef VPU_GET_CC
+bool cc_isCCReaderReady(void)
+{
+	return bcc_data_channel_bind;
+}
+EXPORT_SYMBOL(cc_isCCReaderReady);
+
+__u32 cc_getCCReaderPid(void)
+{
+	return ccReaderPid;
+}
+EXPORT_SYMBOL(cc_getCCReaderPid);
+
+bool cc_isCCInit(void)
+{
+	return (cc_data_sk == NULL);
+}
+EXPORT_SYMBOL(cc_isCCInit);
+
+void cc_data_channel_send(char *message, int total_size, int pid)
+{
+	struct sk_buff *out_skb;
+	struct nlmsghdr *out_nlh;
+	int ret;
+	//vpu_err(" cc_data_channel_send start!\n");
+
+	if (pid == 0)
+		goto failure;
+
+	out_skb = nlmsg_new(total_size, GFP_KERNEL);
+	if (!out_skb)
+		goto failure;
+
+	out_nlh = nlmsg_put(out_skb, 0, 0, CC_DATA_LINK, total_size, 0);
+	if (!out_nlh) {
+		nlmsg_free(out_skb);
+		goto failure;
+	}
+
+	memcpy(nlmsg_data(out_nlh), message, total_size);
+
+	ret = nlmsg_unicast(cc_data_sk, out_skb, pid);
+
+	if (ret < 0) {
+		bcc_data_channel_bind = false;
+		return;
+	}
+
+	return;
+failure:
+	vpu_err(" failed in cc_data_channel_send!\n");
+}
+EXPORT_SYMBOL(cc_data_channel_send);
+
+static int cc_data_channel_bind(struct net *net, int group)
+{
+	bcc_data_channel_bind = true;
+
+	return 0;
+}
+
+static void cc_data_channel_unbind(struct net *net, int group)
+{
+	bcc_data_channel_bind = false;
+}
+
+static void cc_data_channel_receive(struct sk_buff *skb)
+{
+	struct nlmsghdr *nlh;
+	void *payload; //message from user space
+	int payload_len; // with padding, but ok for echo
+
+	nlh = nlmsg_hdr(skb);
+
+	switch (nlh->nlmsg_type) {
+	case CC_DATA_LINK:
+		payload = nlmsg_data(nlh);
+		payload_len = nlmsg_len(nlh);
+		ccReaderPid = nlh->nlmsg_pid;
+		bcc_data_channel_bind = true;
+		break;
+	case CC_DATA_UNLINK:
+		payload = nlmsg_data(nlh);
+		payload_len = nlmsg_len(nlh);
+		ccReaderPid = 0;
+		bcc_data_channel_bind = false;
+		cc_data_channel_send((char *)payload, payload_len,
+				     nlh->nlmsg_pid); // for unlock
+		break;
+	default:
+		vpu_err("Unknow msgtype recieved!\n");
+	}
+	return;
+}
+
+int cc_data_channel_init(void)
+{
+	struct netlink_kernel_cfg nlcfg = {
+		.groups = 1,
+		.input = cc_data_channel_receive,
+		.bind = cc_data_channel_bind,
+		.unbind = cc_data_channel_unbind,
+	};
+
+	bcc_data_channel_bind = false;
+	cc_data_sk = netlink_kernel_create(&init_net, NETLINK_CC_DATA, &nlcfg);
+
+	if (cc_data_sk == NULL) {
+		vpu_err("cc_data_channel_init netlink create error!\n");
+	} else {
+		vpu_info("cc_data_channel_init initialed ok!\n");
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(cc_data_channel_init);
+
+void cc_data_channel_exit(void)
+{
+	if (cc_data_sk == NULL)
+		return;
+
+	vpu_info("cc_data_channel_exit...\n");
+
+	netlink_kernel_release(cc_data_sk);
+
+	cc_data_sk = NULL;
+	bcc_data_channel_bind = false;
+}
+EXPORT_SYMBOL(cc_data_channel_exit);
+
+#endif
+
+static const struct vb2_ops vpu_qops = {
+	.queue_setup = videc_queue_setup,
+	.buf_prepare = videc_buf_prepare,
+	.buf_queue = videc_buf_queue,
+	.start_streaming = videc_start_streaming,
+	.stop_streaming = videc_stop_streaming,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+};
+
+static int queue_init(void *priv, struct vb2_queue *src_vq,
+		      struct vb2_queue *dst_vq)
+{
+	struct videc_ctx *ctx = priv;
+	int ret;
+
+	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	src_vq->io_modes = VB2_DMABUF | VB2_MMAP;
+	src_vq->drv_priv = ctx;
+	src_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);
+	src_vq->ops = &vpu_qops;
+	src_vq->mem_ops = &vb2_vmalloc_memops;
+	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	src_vq->lock = &ctx->dev->dev_mutex;
+	src_vq->dev = ctx->dev->dev;
+
+	ret = vb2_queue_init(src_vq);
+	if (ret)
+		return ret;
+
+	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	dst_vq->io_modes = VB2_DMABUF | VB2_MMAP;
+	dst_vq->drv_priv = ctx;
+	dst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);
+	dst_vq->ops = &vpu_qops;
+	dst_vq->mem_ops = &vb2_dma_contig_memops;
+	dst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	dst_vq->lock = &ctx->dev->dev_mutex;
+	dst_vq->dev = ctx->dev->dev;
+
+	return vb2_queue_init(dst_vq);
+}
+
+/*
+ * File operations
+ */
+static int vpu_open(struct file *file)
+{
+	struct videc_dev *dev = video_drvdata(file);
+	struct videc_ctx *ctx = NULL;
+	int rc = 0;
+
+	if (mutex_lock_interruptible(&dev->dev_mutex))
+		return -ERESTARTSYS;
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		rc = -ENOMEM;
+		goto open_unlock;
+	}
+
+	ctx->rtkdev_fourcc = RTKDEV_FOURCC_DEC;
+	ctx->vpu_ctx = vpu_alloc_context();
+	if (!ctx->vpu_ctx) {
+		rc = -ENOMEM;
+		kfree(ctx);
+		goto open_unlock;
+	}
+	ctx->reqbuf_out = -1;
+	ctx->reqbuf_cap = -1;
+
+	v4l2_fh_init(&ctx->fh, video_devdata(file));
+	file->private_data = &ctx->fh;
+	ctx->dev = dev;
+
+	ctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx, &queue_init);
+
+	if (IS_ERR(ctx->fh.m2m_ctx)) {
+		rc = PTR_ERR(ctx->fh.m2m_ctx);
+
+		vpu_free_context(ctx->vpu_ctx);
+		kfree(ctx);
+		goto open_unlock;
+	}
+
+	ctx->file = file;
+
+	if (vpu_ctrls_setup(ctx)) {
+		v4l2_err(&dev->v4l2_dev,
+			 "failed to setup realtek vpu controls\n");
+		goto open_unlock;
+	}
+
+	ctx->fh.ctrl_handler = &ctx->ctrl_hdl;
+
+	v4l2_fh_add(&ctx->fh);
+
+	memset(&ctx->params, 0, sizeof(struct videc_params));
+	ctx->params.dec_params.en_adaptive_playback = ENABLE_ADAPTIVE_PLAYBACK;
+	ctx->params.dec_params.en_pts_reorder = ENABLE_REORDER_PTS;
+	ctx->params.dec_params.en_enhance = dev->en_enhance;
+
+	list_add_tail(&ctx->list, &dev->instances);
+	ctx->support_gpu_cache = dev->ve_data->gpu_cache;
+	vpu_info("Created instance: %px, m2m_ctx: %px\n", ctx, ctx->fh.m2m_ctx);
+
+open_unlock:
+	mutex_unlock(&dev->dev_mutex);
+	return rc;
+}
+
+static int vpu_release(struct file *file)
+{
+	struct videc_dev *dev = video_drvdata(file);
+	struct videc_ctx *ctx = file2ctx(file);
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+
+	vpu_info("Releasing instance %px\n", ctx);
+
+	mutex_lock(&dev->dev_mutex);
+	v4l2_m2m_ctx_release(ctx->fh.m2m_ctx);
+	op->vpu_reset_resource(&ctx->fh);
+
+	v4l2_fh_del(&ctx->fh);
+	v4l2_fh_exit(&ctx->fh);
+
+	if (ctx->vpu_ctx)
+		vpu_free_context(ctx->vpu_ctx);
+
+	v4l2_ctrl_handler_free(&ctx->ctrl_hdl);
+
+	list_del(&ctx->list);
+	kfree(ctx);
+	mutex_unlock(&dev->dev_mutex);
+
+	vpu_info("Releasing done\n");
+	return 0;
+}
+
+static const struct v4l2_file_operations vpu_fops = {
+	.owner = THIS_MODULE,
+	.open = vpu_open,
+	.release = vpu_release,
+	.poll = v4l2_m2m_fop_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap = v4l2_m2m_fop_mmap,
+};
+
+static struct video_device vpu_videodev = {
+	.name = VPU_NAME,
+	.vfl_dir = VFL_DIR_M2M,
+	.fops = &vpu_fops,
+	.ioctl_ops = &vpu_ioctl_ops,
+	.minor = -1,
+	.release = video_device_release_empty,
+};
+
+static void rtkve1_encode_work(struct work_struct *work)
+{
+	struct rtkve1enc_ctx *ctx = container_of(work, struct rtkve1enc_ctx, encode_work);
+	int ret;
+	enum rtkve1_enc_state new_state = 0;
+
+	/* check and decide state */
+	ret = ctx->ops->decide_state(ctx, &new_state);
+	if (ret < 0) {
+		goto exit;
+	}
+
+	switch (new_state) {
+		case RTK_VE1_STATE_ENC_SEQ_INIT:
+			ctx->ops->seq_init(ctx);
+			break;
+		case RTK_VE1_STATE_ENC_REG_FBS:
+			ret = ctx->ops->reg_fbs(ctx);
+			break;
+		case RTK_VE1_STATE_ENC_HEADER:
+			ret = ctx->ops->enc_header(ctx);
+			break;
+		case RTK_VE1_STATE_ENC_PIC:
+			ret = ctx->ops->enc_pic(ctx);
+			break;
+		case RTK_VE1_STATE_ENC_RESET:
+			break;
+		case RTK_VE1_STATE_ENC_SEQ_END:
+			ctx->ops->seq_end(ctx);
+			break;
+		case RTK_VE1_STATE_ENC_TIMEOUT:
+			//ret = ctx->ops->run_timeout(ctx);
+			break;
+		default:
+			break;
+	}
+
+exit:
+	v4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->v4l2_fh.m2m_ctx);
+}
+
+static int rtkve1enc_open(struct file *file)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct videc_dev *dev = video_drvdata(file);
+	struct rtkve1enc_ctx *ctx = NULL;
+	int ret = 0;
+
+	dev_dbg(dev->dev, "%d.%s.[+] video_device:0x%px.videc_dev:0x%px\n", __LINE__, __func__,
+		vdev, dev);
+
+	if (mutex_lock_interruptible(&dev->dev_mutex)) {
+		dev_err(dev->dev, "%d.%s.mutex_lock_interruptible() fail\n", __LINE__, __func__);
+		return -ERESTARTSYS;
+	}
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		ret = -ENOMEM;
+		dev_err(dev->dev, "%d.%s.kzalloc ctx fail\n", __LINE__, __func__);
+		goto open_unlock;
+	}
+
+	ctx->rtkdev_fourcc = RTKDEV_FOURCC_ENC;
+	ctx->dev = dev;
+	dev_dbg(dev->dev, "%d.%s.ctx:0x%px\n",
+		__LINE__, __func__,
+		ctx);
+
+	v4l2_fh_init(&ctx->v4l2_fh, vdev);
+	file->private_data = &ctx->v4l2_fh;
+	v4l2_fh_add(&ctx->v4l2_fh);
+
+	ctx->ops = &rtkve1enc_ops;
+	/* queue_init */
+	ctx->v4l2_fh.m2m_ctx =
+		v4l2_m2m_ctx_init(dev->m2m_dev, ctx, ctx->ops->queue_init);
+	if (IS_ERR(ctx->v4l2_fh.m2m_ctx)) {
+		ret = PTR_ERR(ctx->v4l2_fh.m2m_ctx);
+		dev_err(dev->dev, "%d.%s.v4l2_m2m_ctx_init() fail\n", __LINE__, __func__);
+		goto free_ctx;
+	}
+	dev_dbg(dev->dev, "%d.%s.m2m_ctx:0x%px\n", __LINE__, __func__,
+		ctx->v4l2_fh.m2m_ctx);
+
+	/* ctrls_setup */
+	if (ctx->ops->ctrls_setup(ctx)) {
+		ret = -ENODEV;
+		dev_err(dev->dev, "%d.%s.ctrls_setup() fail\n", __LINE__, __func__);
+		goto err_m2m_release;
+	}
+
+	rtkve_set_default_format(ctx, &ctx->src_fmt, &ctx->dst_fmt);
+	ctx->colorspace = V4L2_COLORSPACE_DEFAULT;
+	ctx->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	ctx->quantization = V4L2_QUANTIZATION_DEFAULT;
+	ctx->xfer_func = V4L2_XFER_FUNC_DEFAULT;
+
+	INIT_WORK(&ctx->encode_work, rtkve1_encode_work);
+	ctx->debugfs_entry = debugfs_create_dir(RTKVE1_ENC_DEV_NAME, dev->debugfs_root);
+
+	//rtkve1_initialize(ctx);
+
+	list_add_tail(&ctx->list, &dev->enc_instances);
+
+	mutex_unlock(&dev->dev_mutex);
+	dev_dbg(dev->dev, "%d.%s.[-] ret:%d\n",
+		__LINE__, __func__, ret);
+	return ret;
+
+err_m2m_release:
+	v4l2_m2m_ctx_release(ctx->v4l2_fh.m2m_ctx);
+free_ctx:
+	v4l2_fh_del(&ctx->v4l2_fh);
+	v4l2_fh_exit(&ctx->v4l2_fh);
+	kfree(ctx);
+open_unlock:
+	mutex_unlock(&dev->dev_mutex);
+	return ret;
+}
+
+static int rtkve1enc_release(struct file *file)
+{
+	struct videc_dev *dev = video_drvdata(file);
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(file->private_data);
+
+	dev_dbg(dev->dev, "%d.%s.[+] ctx:0x%px.enc_initialized:%d.enc_state:%d\n",
+		__LINE__, __func__,
+		ctx, ctx->enc_initialized,
+		ctx->enc_state);
+	mutex_lock(&dev->dev_mutex);
+	if (ctx->enc_initialized > 0) {
+		if (ctx->enc_state >= RTK_VE1_STATE_ENC_SEQ_INIT) {
+			ctx->ops->seq_end(ctx);
+		}
+		rtkve1_finalize(ctx, dev);
+	}
+	v4l2_m2m_ctx_release(ctx->v4l2_fh.m2m_ctx);
+	// release/reset resource
+	v4l2_ctrl_handler_free(&ctx->v4l2_ctrl_hdl);
+	v4l2_fh_del(&ctx->v4l2_fh);
+	v4l2_fh_exit(&ctx->v4l2_fh);
+	debugfs_remove_recursive(ctx->debugfs_entry);
+	list_del(&ctx->list);
+	kfree(ctx);
+	ctx = NULL;
+	mutex_unlock(&dev->dev_mutex);
+	dev_dbg(dev->dev, "%d.%s.[-]\n", __LINE__, __func__);
+
+	return 0;
+}
+
+static const struct v4l2_file_operations rtkve1enc_fops = {
+	.owner = THIS_MODULE,
+	.open = rtkve1enc_open,
+	.release = rtkve1enc_release,
+	.poll = v4l2_m2m_fop_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap = v4l2_m2m_fop_mmap,
+};
+
+static struct video_device rtkve1enc_videodev = {
+	.name = RTKVE1_ENC_DEV_NAME,
+	.vfl_dir = VFL_DIR_M2M,
+	.fops = &rtkve1enc_fops,
+	.ioctl_ops = &rtkve1enc_ioctl_ops,
+	.minor = -1,
+	.release = video_device_release_empty,
+};
+
+static struct v4l2_m2m_ops m2m_ops = {
+	.device_run = device_run,
+	.job_ready = job_ready,
+	.job_abort = job_abort,
+};
+
+static ssize_t get_instance_info(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct videc_dev *vdev = dev_get_drvdata(dev);
+	struct videc_ctx *ctx = NULL;
+	struct rtkve1enc_ctx *enc_ctx = NULL;
+	int len = 0;
+	int dec_cnt = 0;
+	int enc_cnt = 0;
+
+	list_for_each_entry(ctx, &vdev->instances, list) {
+		if (ctx) {
+			dec_cnt++;
+			len += scnprintf(buf + len, PAGE_SIZE - len,
+				"Dec instance %d: ", dec_cnt);
+			len += scnprintf(buf + len, PAGE_SIZE - len,
+				vpu_ve_status(ctx->vpu_ctx, &ctx->fh));
+		}
+	}
+
+	list_for_each_entry(enc_ctx, &vdev->enc_instances, list) {
+		if (enc_ctx) {
+			enc_cnt++;
+		}
+	}
+
+	len += scnprintf(buf + len, PAGE_SIZE - len,
+		"Enc total instance(H264) %d\n", enc_cnt);
+
+	return len;
+}
+
+static ssize_t set_enhance_mode(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	struct videc_dev *v_dev = dev_get_drvdata(dev);
+	unsigned long mode;
+	int ret = 0;
+
+	ret = kstrtol(buf, 0, &mode);
+	if (ret != 0 || mode & INVERT_BITVAL_1) {
+		pr_err("Incorrect input value. Please input 1 or 0.");
+		return -EINVAL;
+	}
+
+	v_dev->en_enhance = mode;
+
+	return count;
+}
+
+static uint16_t hex_int(char *hex)
+{
+	uint16_t val = 0;
+	while (*hex) {
+		uint8_t byte = *hex++;
+		if (byte >= '0' && byte <= '9')
+			byte = byte - '0';
+		else if (byte >= 'a' && byte <= 'f')
+			byte = byte - 'a' + 10;
+		else if (byte >= 'A' && byte <= 'F')
+			byte = byte - 'A' + 10;
+		val = (val << 4) | (byte & 0xF);
+	}
+
+	return val;
+}
+
+static int ve1fw_convert_to_binary(uint16_t *bin, u8 *fw, uint32_t size)
+{
+	int i = 0;
+	int j = 0;
+	u8 hex[5];
+
+	for (i = 0; i < size;) {
+		memset(hex, 0x00, 5);
+		memcpy(hex, fw + i, 4);
+		bin[j++] = hex_int(hex);
+		i += 5;
+	}
+
+	return j;
+}
+
+static int rtkve1_load_firmware(struct device *dev, const char *fw_name)
+{
+	struct videc_dev *v_dev = dev_get_drvdata(dev);
+	const struct firmware *fw;
+	int ret;
+	u8 *fw_binary;
+	int fw_sz;
+
+	ret = request_firmware(&fw, fw_name, dev);
+	if (ret) {
+		vpu_err("%d.%s.request_firmware fail\n",
+			__LINE__, __func__);
+		return ret;
+	}
+
+	vpu_info("%d.%s.fw size:%ld\n",
+		__LINE__, __func__,
+		fw->size);
+	fw_binary = devm_kzalloc(dev, (512*1024), GFP_KERNEL);
+	fw_sz = ve1fw_convert_to_binary((uint16_t *)fw_binary, (u8 *)fw->data, fw->size);
+	v_dev->ve1fw_binary = fw_binary;
+	v_dev->ve1fw_size_in_word = fw_sz;
+
+	release_firmware(fw);
+	return 0;
+}
+
+static int vpu_probe(struct platform_device *pdev)
+{
+	struct videc_dev *dev;
+	struct video_device *dec_dev;
+	struct video_device *enc_dev = NULL;
+	int ret;
+
+	/* Allocate a new instance */
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	dev->ve1_devinfo = kzalloc(sizeof(struct rtkve1_dev_info), GFP_KERNEL);
+	if (!dev->ve1_devinfo) {
+		vpu_err("%d.%s.kzalloc struct rtkve1_dev_info fail\n",
+			__LINE__, __func__);
+		return -ENOMEM;
+	}
+
+	dev->ve_data = device_get_match_data(&pdev->dev);
+	if (!dev->ve_data) {
+		vpu_err("%d.%s.missing match_data\n",
+			__LINE__, __func__);
+		ret = -EINVAL;
+		goto err_free_info;
+	}
+	vpu_info("%d.%s.ve_data->product:%d.ve_data->drv_ops:0x%px.get_instance_pool:0x%px\n",
+		__LINE__, __func__,
+		dev->ve_data->product,
+		(void *)&(dev->ve_data->drv_ops),
+		(void *)(dev->ve_data->drv_ops.get_instance_pool));
+
+	set_dma_ops(&pdev->dev, &rheap_dma_ops);
+	rheap_setup_dma_pools(&pdev->dev, "rtk_media_heap",
+	                      RTK_FLAG_NONCACHED | RTK_FLAG_SCPUACC |
+	                      RTK_FLAG_VO_U_POOL, __func__);
+
+	spin_lock_init(&dev->irqlock);
+
+	/* Initialize the top-level structure */
+	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
+	if (ret) {
+		goto err_free_info;
+	}
+
+	dev->dev = &pdev->dev;
+	atomic_set(&dev->ve1_num_inst, 0);
+	atomic_set(&dev->ve2_num_inst, 0);
+	mutex_init(&dev->dev_mutex);
+	mutex_init(&dev->ve1_hw_mutex);
+
+	/* Initialize realtek-vpu video_device */
+	dev->video_dev[0] = vpu_videodev;
+	dec_dev = &dev->video_dev[0];
+	dec_dev->lock = &dev->dev_mutex;
+	dec_dev->v4l2_dev = &dev->v4l2_dev;
+	dec_dev->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;
+	video_set_drvdata(dec_dev, dev);
+
+	if (dev->ve_data->product == RTK_STARK) {
+		/* Initialize rtkve1-enc video_device */
+		dev->video_dev[1] = rtkve1enc_videodev;
+		enc_dev = &dev->video_dev[1];
+		enc_dev->lock = &dev->dev_mutex;
+		enc_dev->v4l2_dev = &dev->v4l2_dev;
+		enc_dev->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;
+		video_set_drvdata(enc_dev, dev);
+	}
+
+	platform_set_drvdata(pdev, dev);
+
+	/* Initialize per-driver m2m data */
+	dev->m2m_dev = v4l2_m2m_init(&m2m_ops);
+	if (IS_ERR(dev->m2m_dev)) {
+		vpu_err("Failed to init mem2mem device\n");
+		ret = PTR_ERR(dev->m2m_dev);
+		goto err_m2m;
+	}
+
+	dev->encode_workqueue = alloc_ordered_workqueue(
+		RTKVE1_ENC_DEV_NAME, WQ_MEM_RECLAIM | WQ_FREEZABLE);
+	if (!dev->encode_workqueue) {
+		vpu_err("Failed to create encode workqueue\n");
+		ret = -EINVAL;
+		goto err_workq;
+	}
+
+	INIT_LIST_HEAD(&dev->instances);
+	INIT_LIST_HEAD(&dev->enc_instances);
+
+	/* Register video4linux device after initialization is completed */
+	ret = video_register_device(dec_dev, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		vpu_err("Failed to register decode device\n");
+		goto err_dec;
+	}
+	vpu_info("%d.%s.decoder registered as /dev/video%d.name=%s\n",
+		__LINE__, __func__,
+		dec_dev->num, dec_dev->name);
+
+	if (dev->ve_data->product == RTK_STARK) {
+		ret = video_register_device(enc_dev, VFL_TYPE_VIDEO, -1);
+		if (ret) {
+			vpu_err("Failed to register encode device\n");
+			goto err_enc;
+		}
+		vpu_info("%d.%s.encoder registered as /dev/video%d.name=%s\n",
+			__LINE__, __func__,
+			enc_dev->num, enc_dev->name);
+	}
+
+	ret = device_create_file(&pdev->dev, &dev_attr_instance_info);
+	if (ret < 0)
+		vpu_err("failed to create v4l2 instance_info attribute\n");
+
+	ret = device_create_file(&pdev->dev, &dev_attr_enhance);
+	if (ret < 0)
+		vpu_err("failed to create v4l2 enhance attribute\n");
+
+	dev->debugfs_root = debugfs_create_dir("rtkvdec-dbg", NULL);
+
+	ret = rtkve1_load_firmware(&pdev->dev, dev->ve_data->fw_name);
+	if (ret) {
+		vpu_err("%d.%s.failed to rtkve1_load_firmware.ret:%d\n",
+			__LINE__, __func__, ret);
+		ret = -EINVAL;
+		goto err_enc;
+	}
+
+	vpu_info("%s is done", __func__);
+	return 0;
+
+err_enc:
+	video_unregister_device(&dev->video_dev[0]);
+err_dec:
+	destroy_workqueue(dev->encode_workqueue);
+err_workq:
+	v4l2_m2m_release(dev->m2m_dev);
+err_m2m:
+	v4l2_device_unregister(&dev->v4l2_dev);
+err_free_info:
+	kfree(dev->ve1_devinfo);
+	dev->ve1_devinfo = NULL;
+
+	return ret;
+}
+
+static int vpu_remove(struct platform_device *pdev)
+{
+	struct videc_dev *dev = platform_get_drvdata(pdev);
+
+	vpu_info("Removing %s\n", VPU_NAME);
+
+	if (dev->encode_workqueue)
+		destroy_workqueue(dev->encode_workqueue);
+#if 0
+	if (ve1_devinfo->codebuf.size != 0) {
+		dev_dbg(dev->dev, "%d.%s.free_dma.name:codebuf.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+			__LINE__, __func__,
+			ve1_devinfo->codebuf.size,
+			ve1_devinfo->codebuf.paddr,
+			ve1_devinfo->codebuf.vaddr);
+		rtkve1_free_dma_memory(dev, &ve1_devinfo->codebuf, "codebuf");
+	}
+	if (ve1_devinfo->parabuf.size != 0) {
+		dev_dbg(dev->dev, "%d.%s.free_dma.name:parabuf.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+			__LINE__, __func__,
+			ve1_devinfo->parabuf.size,
+			ve1_devinfo->parabuf.paddr,
+			ve1_devinfo->parabuf.vaddr);
+		rtkve1_free_dma_memory(dev, &ve1_devinfo->parabuf, "parabuf");
+	}
+	if (ve1_devinfo->tempbuf.size != 0) {
+		dev_dbg(dev->dev, "%d.%s.free_dma.name:tempbuf.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+			__LINE__, __func__,
+			ve1_devinfo->tempbuf.size,
+			ve1_devinfo->tempbuf.paddr,
+			ve1_devinfo->tempbuf.vaddr);
+		rtkve1_free_dma_memory(dev, &ve1_devinfo->tempbuf, "tempbuf");
+	}
+#endif
+	kfree(dev->ve1_devinfo);
+	dev->ve1_devinfo = NULL;
+
+	device_remove_file(&pdev->dev, &dev_attr_enhance);
+	device_remove_file(&pdev->dev, &dev_attr_instance_info);
+
+	v4l2_m2m_release(dev->m2m_dev);
+	video_unregister_device(&dev->video_dev[0]);
+	video_unregister_device(&dev->video_dev[1]);
+	v4l2_device_unregister(&dev->v4l2_dev);
+	debugfs_remove_recursive(dev->debugfs_root);
+
+	return 0;
+}
+
+static int vpu_suspend(struct device *dev)
+{
+	struct videc_dev *vdev = dev_get_drvdata(dev);
+	struct videc_ctx *ctx = NULL;
+	int ret = 0;
+
+	list_for_each_entry(ctx, &vdev->instances, list) {
+		if (ctx) {
+			vpu_ve_suspend(ctx->vpu_ctx, &ctx->fh);
+		}
+	}
+
+	return ret;
+}
+
+static int vpu_resume(struct device *dev)
+{
+	struct videc_dev *vdev = dev_get_drvdata(dev);
+	struct videc_ctx *ctx = NULL;
+	int ret = 0;
+
+
+	list_for_each_entry(ctx, &vdev->instances, list) {
+		if (ctx) {
+			vpu_ve_resume(ctx->vpu_ctx, &ctx->fh);
+		}
+	}
+	return ret;
+}
+
+static const struct dev_pm_ops vpu_pm_ops = {
+	.suspend = vpu_suspend,
+	.resume = vpu_resume,
+};
+
+static const struct of_device_id vpu_dt_ids[] = {
+	{ .compatible = "realtek,rtd16xxb-vpu-legacy", .data = &rtkve_data[RTK_STARK] },
+	{ .compatible = "realtek,kent-vpu-legacy", .data = &rtkve_data[RTK_KENT] },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, vpu_dt_ids);
+
+static struct platform_driver vpu_pdrv = {
+	.probe		= vpu_probe,
+	.remove		= vpu_remove,
+	.driver		= {
+		.name	= VPU_NAME,
+		.of_match_table = of_match_ptr(vpu_dt_ids),
+		.pm	= &vpu_pm_ops,
+	},
+};
+
+module_platform_driver(vpu_pdrv);
+
+MODULE_VERSION(CODEC_VERSION);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("William Lee <william.lee@realtek.com>");
+MODULE_DESCRIPTION("Realtek V4L2 VE2 Codec Driver");
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/drv_if.h
@@ -0,0 +1,133 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ */
+#ifndef __DRV_IF_H__
+#define __DRV_IF_H__
+
+#include <linux/debugfs.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+#include "ve1_v4l2_drv_ops.h"
+
+#define CODEC_VERSION "1.0.0"
+
+#define RTK_V4L2_SET_SECURE (V4L2_CID_USER_REALTEK_BASE + 0)
+#define RTK_V4L2_DEC_PARMS_CONFIG (V4L2_CID_USER_REALTEK_BASE + 1)
+
+//Attentation!This value should not be included in v4l2_ctrl_type
+#define V4L2_CTRL_TYPE_RTK_DEC_PARAM 0x9000
+
+struct videc_dev {
+	struct v4l2_device v4l2_dev;
+	struct video_device video_dev[2];
+
+	struct mutex dev_mutex;
+	struct mutex ve1_hw_mutex;
+	spinlock_t irqlock;
+
+	struct v4l2_m2m_dev *m2m_dev;
+	struct device *dev;
+	struct dentry *debugfs_root;
+
+	uint8_t en_enhance;
+
+	void *ve1_devinfo; /* struct rtkve1_dev_info */
+	void __iomem *ve1_register;
+	struct workqueue_struct *encode_workqueue;
+	u32 ve1_instance_nums; /* total instance number including ve1 decoder and encoder */
+	const struct rtkve_match_data *ve_data;
+	u8 *ve1fw_binary;
+	u32 ve1fw_size_in_word;
+
+	atomic_t ve1_num_inst;
+	atomic_t ve2_num_inst;
+
+	struct list_head instances;
+	struct list_head enc_instances;
+};
+
+struct rtk_dec_params {
+	//Colorimetry
+	uint32_t matrix_coefficients;
+	uint32_t range;
+	uint32_t transfer_characteristics;
+	uint32_t primaries;
+
+	uint8_t en_adaptive_playback;
+	uint8_t en_pts_reorder;
+	uint8_t en_enhance;
+};
+
+struct videc_params {
+	uint8_t is_secure;
+
+	struct v4l2_ctrl_hdr10_mastering_display mastering;
+	struct v4l2_ctrl_hdr10_cll_info cll;
+	struct rtk_dec_params dec_params;
+};
+
+struct videc_ctx {
+	/* RTKDEV_FOURCC_ENC or RTKDEV_FOURCC_DEC for distinguish priv in device_run() */
+	u32 rtkdev_fourcc;
+	struct v4l2_fh fh;
+	struct videc_dev *dev;
+
+	void *file; /* struct file */
+	void *vpu_ctx; /* context of vpu */
+	void *ve_ctx; /* context of video engine */
+
+	int reqbuf_out;
+	int reqbuf_cap;
+	bool is_sub_res_chg;
+	bool has_stream_on;
+	bool params_update;
+	bool support_gpu_cache;
+
+	struct v4l2_ctrl_handler ctrl_hdl;
+	struct videc_params params;
+
+	struct list_head list;
+};
+
+struct rtkve1_drv_ops {
+	int (*get_instance_pool)(vpudrv_buffer_t *vdb);
+	int (*get_register_info)(vpudrv_buffer_t *vdb);
+	int (*set_rtk_clk_gating)(vpu_clock_info_t* clockInfo);
+	int (*get_common_memory)(vpudrv_buffer_t *vdb);
+	ssize_t (*write_bit_firmware)(vpu_bit_firmware_info_t *buf, size_t len);
+	int (*allocate_physical_memory)(void *filp, vpudrv_buffer_t *vdb);
+	int (*free_physical_memory)(vpudrv_buffer_t *vdb);
+	int (*allocate_physical_memory_no_mmap)(void *filp, vpudrv_buffer_t *vdb);
+	int (*free_physical_memory_no_mmap)(vpudrv_buffer_t *vdb);
+	int (*open_instance)(void *filp, vpudrv_inst_info_t *inst_info);
+	int (*close_instance)(vpudrv_inst_info_t *inst_info);
+	int (*wait_interrupt)(vpudrv_intr_info_t *intr_info);
+};
+
+enum rtk_product {
+	RTK_STARK,
+	RTK_KENT
+};
+
+struct rtkve_match_data {
+	enum rtk_product product;
+	const char *fw_name;
+	struct rtkve1_drv_ops drv_ops;
+	bool gpu_cache;
+};
+
+#ifdef VPU_GET_CC
+int cc_data_channel_init(void);
+void cc_data_channel_exit(void);
+void cc_data_channel_send(char *message, int total_size, int pid);
+bool cc_isCCReaderReady(void);
+bool cc_isCCInit(void);
+__u32 cc_getCCReaderPid(void);
+#endif
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/rtkve1_common.c
@@ -0,0 +1,828 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video encoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#include <linux/dma-map-ops.h>
+#include <soc/realtek/memory.h>
+#include <soc/realtek/rtk_media_heap.h>
+#include <linux/iopoll.h>
+#include <crypto/hash.h>
+#include "rtkve1enc_common.h"
+#include "rtkve1_regdefine.h"
+#include "ve1_vdi.h"
+
+#define VDI_SYSTEM_ENDIAN VDI_LITTLE_ENDIAN
+#define VDI_128BIT_BUS_SYSTEM_ENDIAN VDI_128BIT_LITTLE_ENDIAN
+
+#define RTKVE1_BUSY_CHECK_TIMEOUT_US 10000000
+#define RTKVE1_WAIT_CMD_IDLE_TIMEOUT_US 10000000
+#define MBC_SET_SUBBLK_EN                                                      \
+	(MBC_BASE + 0xA0) // subblk_man_mode[20] cr_subblk_man_en[19:0]
+
+int rtkve1_md5_hash(unsigned char *result, int resultLen, char *data, int dataLen)
+{
+	int ret = 0;
+	struct crypto_shash *tfm = NULL;
+	struct shash_desc *desc = NULL;
+
+	if ((result == NULL) || (resultLen <= 0) || (data == NULL) ||
+	    (dataLen <= 0)) {
+		return -1;
+	}
+	pr_info("data:0x%px.dataLen:%d\n", data,
+		dataLen);
+	memset(result, 0, resultLen);
+
+	tfm = crypto_alloc_shash("md5", 0, 0);
+	if (IS_ERR(tfm)) {
+		tfm = NULL;
+		pr_err("IS_ERR(tfm)\n");
+		ret = -1;
+		goto out;
+	}
+
+	desc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
+	if (desc == NULL) {
+		pr_err("kmalloc desc fail\n");
+		ret = -1;
+		goto out;
+	}
+
+	desc->tfm = tfm;
+
+	if (crypto_shash_init(desc) < 0) {
+		pr_err("crypto_shash_init() fail\n");
+		ret = -1;
+		goto out;
+	}
+	//pr_info("crypto_shash_init() ok\n");
+
+	if (crypto_shash_update(desc, data, dataLen) < 0) {
+		pr_err("crypto_shash_update() fail\n");
+		ret = -1;
+		goto out;
+	}
+	//pr_info("crypto_shash_update() ok\n");
+
+	if (crypto_shash_final(desc, result) < 0) {
+		pr_err("crypto_shash_final() fail\n");
+		ret = -1;
+		goto out;
+	}
+	//pr_info("crypto_shash_final() ok\n");
+
+	//pr_info("%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
+	//	result[0], result[1], result[2], result[3], result[4],
+	//	result[5], result[6], result[7], result[8], result[9],
+	//	result[10], result[11], result[12], result[13], result[14],
+	//	result[15]);
+out:
+	if (desc) {
+		kfree(desc);
+	}
+	if (tfm) {
+		crypto_free_shash(tfm);
+	}
+
+	return ret;
+}
+
+int rtkve1_alloc_dma_memory(struct videc_dev *dev, struct rtkve1_buf *buf,
+        size_t size, const char *name, struct dentry *parent)
+{
+    mutex_lock(&dev->dev->mutex);
+    rheap_setup_dma_pools(dev->dev, "rtk_media_heap",
+                          RTK_FLAG_NONCACHED | RTK_FLAG_SCPUACC |
+                          RTK_FLAG_VO_U_POOL, __func__);
+    buf->vaddr = dma_alloc_coherent(dev->dev, size, &buf->paddr,
+                    GFP_KERNEL);
+    mutex_unlock(&dev->dev->mutex);
+    if (!buf->vaddr) {
+        dev_err(dev->dev, "%d.%s.dma_alloc_coherent() fail.name:%s.size:%zu\n",
+            __LINE__, __func__,
+            name, size);
+        return -ENOMEM;
+    }
+    buf->size = size;
+    dev_dbg(dev->dev, "%d.%s.alloc memory.name:%s.size:%zu.paddr:0x%llx.vaddr:0x%px\n",
+        __LINE__, __func__,
+        name, size,
+        buf->paddr, buf->vaddr);
+
+    if (name && parent) {
+        buf->blob.data = buf->vaddr;
+        buf->blob.size = size;
+        buf->dentry = debugfs_create_blob(name, 0444, parent,
+                        &buf->blob);
+	}
+
+	return 0;
+}
+
+void rtkve1_free_dma_memory(struct videc_dev *dev,
+        struct rtkve1_buf *buf, const char *name)
+{
+    if (buf->vaddr) {
+        dev_dbg(dev->dev, "%d.%s.free memory.name:%s.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+            __LINE__, __func__,
+            name, buf->size,
+            buf->paddr, buf->vaddr);
+
+        dma_free_coherent(dev->dev, buf->size, buf->vaddr, buf->paddr);
+        buf->vaddr = NULL;
+        buf->size = 0;
+        debugfs_remove(buf->dentry);
+        buf->dentry = NULL;
+	}
+}
+
+void rtkve1_parabuf_write(struct rtkve1enc_ctx *ctx, int index, u32 value)
+{
+    struct rtkve1_dev_info* ve1_devinfo = (struct rtkve1_dev_info*)ctx->dev->ve1_devinfo;
+	u32 *p = ve1_devinfo->parabuf.vaddr;
+
+	p[index ^ 1] = value;
+}
+
+static int convert_endian(unsigned int endian)
+{
+	return (endian & 0x0f);
+}
+
+static uint32_t convert_endian_coda9_to_wave4(uint32_t endian)
+{
+	uint32_t converted_endian = endian;
+	switch (endian) {
+	case VDI_LITTLE_ENDIAN:
+		converted_endian = 0;
+		break;
+	case VDI_BIG_ENDIAN:
+		converted_endian = 7;
+		break;
+	case VDI_32BIT_LITTLE_ENDIAN:
+		converted_endian = 4;
+		break;
+	case VDI_32BIT_BIG_ENDIAN:
+		converted_endian = 3;
+		break;
+	}
+	return converted_endian;
+}
+
+static void byte_swap(unsigned char *data, int len)
+{
+	u8 temp;
+	int i;
+
+	for (i = 0; i < len; i += 2) {
+		temp = data[i];
+		data[i] = data[i + 1];
+		data[i + 1] = temp;
+	}
+}
+
+static void word_swap(unsigned char *data, int len)
+{
+	u16 temp;
+	u16 *ptr = (u16 *)data;
+	int i;
+	s32 size = len / sizeof(uint16_t);
+
+	for (i = 0; i < size; i += 2) {
+		temp = ptr[i];
+		ptr[i] = ptr[i + 1];
+		ptr[i + 1] = temp;
+	}
+}
+
+static void dword_swap(unsigned char *data, int len)
+{
+	u32 temp;
+	u32 *ptr = (u32 *)data;
+	s32 size = len / sizeof(uint32_t);
+	int i;
+
+	for (i = 0; i < size; i += 2) {
+		temp = ptr[i];
+		ptr[i] = ptr[i + 1];
+		ptr[i + 1] = temp;
+	}
+}
+
+static void lword_swap(unsigned char *data, int len)
+{
+	u64 temp;
+	u64 *ptr = (u64 *)data;
+	s32 size = len / sizeof(uint64_t);
+	int i;
+
+	for (i = 0; i < size; i += 2) {
+		temp = ptr[i];
+		ptr[i] = ptr[i + 1];
+		ptr[i + 1] = temp;
+	}
+}
+
+static int swap_endian(unsigned char *data, int len, int endian)
+{
+	int changes;
+	int sys_endian;
+	bool byteChange, wordChange, dwordChange, lwordChange;
+
+	sys_endian = VDI_SYSTEM_ENDIAN;
+
+	endian = convert_endian(endian);
+	sys_endian = convert_endian(sys_endian);
+	if (endian == sys_endian)
+		return 0;
+
+	endian = convert_endian_coda9_to_wave4(endian);
+	sys_endian = convert_endian_coda9_to_wave4(sys_endian);
+
+	changes = endian ^ sys_endian;
+	byteChange = changes & 0x01;
+	wordChange = ((changes & 0x02) == 0x02);
+	dwordChange = ((changes & 0x04) == 0x04);
+	lwordChange = ((changes & 0x08) == 0x08);
+
+	if (byteChange)
+		byte_swap(data, len);
+	if (wordChange)
+		word_swap(data, len);
+	if (dwordChange)
+		dword_swap(data, len);
+	if (lwordChange)
+		lword_swap(data, len);
+
+	return 1;
+}
+
+int rtkve1_write_memory(struct videc_dev *dev,
+    void *vaddr, size_t bufsize,
+    size_t offset, u8 *data, int len, int endian)
+{
+    if (!vaddr || bufsize <= 0) {
+        dev_err(dev->dev, "%d.%s.vaddr is NULL or bufsize <= 0\n",
+            __LINE__, __func__);
+        return -EINVAL;
+    }
+
+    if (offset > bufsize || len > bufsize || offset + len > bufsize) {
+        dev_err(dev->dev, "%d.%s.invalid params.offset:%ld.len:%d.bufsize:%ld\n",
+            __LINE__, __func__,
+            offset, len, bufsize);
+        return -ENOSPC;
+    }
+
+    swap_endian(data, len, endian);
+    memcpy(vaddr + offset, data, len);
+    return len;
+}
+
+int rtkve1_read_memory(struct videc_dev *dev,
+    void *vaddr, size_t bufsize,
+    size_t offset, u8 *data, int len, int endian)
+{
+    if (!vaddr || bufsize <= 0) {
+        dev_err(dev->dev, "%d.%s.vaddr is NULL or bufsize <= 0\n",
+            __LINE__, __func__);
+        return -EINVAL;
+    }
+
+    if (offset > bufsize || len > bufsize || offset + len > bufsize) {
+        dev_err(dev->dev, "%d.%s.invalid params.offset:%ld.len:%d.bufsize:%ld\n",
+            __LINE__, __func__,
+            offset, len, bufsize);
+        return -ENOSPC;
+    }
+
+    memcpy(data, vaddr + offset, len);
+    swap_endian(data, len, endian);
+    return len;
+}
+
+void rtkve1_reg_writel(struct videc_dev *dev, unsigned int addr,
+        unsigned int data)
+{
+    //dev_dbg(dev->dev, "%d.%s.0x%X = 0x%x\n",
+    //    __LINE__, __func__,
+    //    addr, data);
+	writel(data, dev->ve1_register + addr);
+}
+
+unsigned int rtkve1_reg_readl(struct videc_dev *dev, u32 addr)
+{
+    u32 value = 0;
+    value = readl(dev->ve1_register + addr);
+    //dev_dbg(dev->dev, "%d.%s.0x%X = 0x%x\n",
+    //    __LINE__, __func__,
+    //    addr, value);
+	return value;
+}
+
+void rtkve1_issue_command(struct rtkve1enc_ctx *ctx, u32 cmd)
+{
+    struct videc_dev *dev = ctx->dev;
+
+	rtkve1_reg_writel(dev, BIT_WORK_BUF_ADDR, ctx->workbuf.paddr);
+
+	rtkve1_reg_writel(dev, BIT_BUSY_FLAG, 1);
+	rtkve1_reg_writel(dev, BIT_RUN_INDEX, ctx->inst_index);
+	rtkve1_reg_writel(dev, BIT_RUN_COD_STD, ctx->codec_mode);
+	rtkve1_reg_writel(dev, BIT_RUN_AUX_STD, 0);
+	rtkve1_reg_writel(dev, BIT_RUN_COMMAND, cmd);
+}
+
+int rtkve1_wait_interrupt(struct rtkve1enc_ctx *ctx, unsigned int timeout)
+{
+    int ret = 0;
+    int intr_reason = 0;
+    vpudrv_intr_info_t intr_info;
+
+    intr_info.core_idx = 0;
+    intr_info.timeout = timeout;
+    intr_info.intr_reason = 0;
+
+	ret = rtd16xxb_vdi_ioctl_wait_interrupt(&intr_info);
+	if (ret != 0) {
+		return -ETIMEDOUT;
+	}
+	intr_reason = intr_info.intr_reason;
+    return intr_reason;
+#if 0
+	int ret;
+
+	ret = wait_for_completion_timeout(&ctx->dev->irq_done,
+					  msecs_to_jiffies(timeout));
+	if (!ret)
+		return -ETIMEDOUT;
+
+	reinit_completion(&ctx->dev->irq_done);
+
+	return 0;
+#endif
+}
+
+void rtkve1_clear_interrupt(struct rtkve1enc_ctx *ctx)
+{
+    rtkve1_reg_writel(ctx->dev, BIT_INT_CLEAR, 1);
+    rtkve1_reg_writel(ctx->dev, BIT_INT_REASON, 0);
+}
+
+bool rtkve1_is_init(struct videc_dev *dev)
+{
+    u32 pc = rtkve1_reg_readl(dev, BIT_CUR_PC);
+    dev_dbg(dev->dev, "%d.%s.pc:0x%x\n",
+        __LINE__, __func__,
+        pc);
+	return rtkve1_reg_readl(dev, BIT_CUR_PC) != 0;
+}
+
+int rtkve1_wait_cmd_traffic_idle(struct videc_dev *dev)
+{
+	u32 data;
+
+	return read_poll_timeout(rtkve1_reg_readl, data, ((data & 0x70000) == 0x70000), 0,
+                RTKVE1_WAIT_CMD_IDLE_TIMEOUT_US, false, dev, RTKVE1_CMD_TRAFFIC);
+}
+
+int rtkve1_wait_busy(struct videc_dev *dev, unsigned int addr)
+{
+    int ret = 0;
+	u32 data;
+
+	ret = read_poll_timeout(rtkve1_reg_readl, data, data == 0, 0,
+            RTKVE1_BUSY_CHECK_TIMEOUT_US, false, dev, addr);
+    if (ret < 0) {
+        dev_dbg(dev->dev, "%d.%s.poll reg 0x%X timeout\n",
+            __LINE__, __func__,
+            data);
+        return ret;
+    }
+
+    ret = rtkve1_wait_cmd_traffic_idle(dev);
+    if (ret < 0) {
+        dev_dbg(dev->dev, "%d.%s.poll cmd traffic timeout\n",
+            __LINE__, __func__);
+    }
+
+    return ret;
+}
+
+int rtkve1_reset(struct videc_dev *dev, enum sw_reset_mode reset_mode)
+{
+    uint32_t cmd;
+    int ret;
+
+    if (reset_mode != SW_RESET_ON_BOOT) {
+        cmd = rtkve1_reg_readl(dev, BIT_RUN_COMMAND);
+        if (cmd == DEC_SEQ_INIT || cmd == PIC_RUN) {
+            if (rtkve1_reg_readl(dev, BIT_BUSY_FLAG) ||
+                rtkve1_reg_readl(dev, BIT_INT_REASON)) {
+                // stop all of pipeline
+                rtkve1_reg_writel(dev, MBC_SET_SUBBLK_EN,
+                    ((1 << 20) | 0));
+
+                // force to set the end of Bitstream to be decoded.
+                cmd = rtkve1_reg_readl(dev,
+                        BIT_BIT_STREAM_PARAM);
+                cmd |= 1 << 2;
+                rtkve1_reg_writel(dev, BIT_BIT_STREAM_PARAM,
+                    cmd);
+
+                cmd = rtkve1_reg_readl(dev, BIT_RD_PTR);
+                rtkve1_reg_writel(dev, BIT_WR_PTR, cmd);
+
+                ret = rtkve1_wait_busy(dev,
+                        BIT_INT_REASON);
+                if (ret) {
+                    dev_err(dev->dev, "%d.%s.wait_timeout.BIT_INT_REASON.ret:%d\n",
+                        __LINE__, __func__,
+                        ret);
+                    return -ETIMEDOUT;
+                }
+                // clear HW signal
+                rtkve1_reg_writel(dev, BIT_INT_REASON, 0);
+                rtkve1_reg_writel(dev, BIT_INT_CLEAR, 1);
+            }
+        }
+    }
+
+    // Waiting for completion of BWB transaction first
+    ret = rtkve1_wait_busy(dev, GDI_BWB_STATUS);
+    if (ret) {
+        dev_err(dev->dev, "%d.%s.wait_timeout.GDI_BWB_STATUS.ret:%d\n",
+            __LINE__, __func__,
+            ret);
+        return -ETIMEDOUT;
+    }
+
+    // Waiting for completion of bus transaction
+    // Step1 : No more request
+    rtkve1_reg_writel(
+        dev, GDI_BUS_CTRL,
+        0x11); // no more request {3'b0,no_more_req_sec,3'b0,no_more_req}
+
+    ret = rtkve1_wait_busy(dev, GDI_BWB_STATUS);
+    if (ret) {
+        dev_err(dev->dev, "%d.%s.wait_timeout.GDI_BWB_STATUS.ret:%d\n",
+            __LINE__, __func__,
+            ret);
+        rtkve1_reg_writel(dev, GDI_BUS_CTRL, 0x00);
+        return -ETIMEDOUT;
+    }
+
+    cmd = 0;
+    // Software Reset Trigger
+    if (reset_mode != SW_RESET_ON_BOOT)
+        cmd = VPU_SW_RESET_BPU_CORE | VPU_SW_RESET_BPU_BUS;
+
+    cmd |= VPU_SW_RESET_VCE_CORE | VPU_SW_RESET_VCE_BUS;
+    if (reset_mode == SW_RESET_ON_BOOT)
+        cmd |= VPU_SW_RESET_GDI_CORE |
+               VPU_SW_RESET_GDI_BUS; // If you reset GDI, tiled map should be reconfigured
+
+    rtkve1_reg_writel(dev, BIT_SW_RESET, cmd);
+
+    // wait until reset is done
+    if (rtkve1_wait_busy(dev, BIT_SW_RESET_STATUS) != 0) {
+        dev_err(dev->dev, "%d.%s.wait BIT_SW_RESET_STATUS timeout\n",
+            __LINE__, __func__);
+        rtkve1_reg_writel(dev, BIT_SW_RESET, 0x00);
+        rtkve1_reg_writel(dev, GDI_BUS_CTRL, 0x00);
+        return -ETIMEDOUT;
+    }
+
+    rtkve1_reg_writel(dev, BIT_SW_RESET, 0);
+
+    // Step3 : must clear GDI_BUS_CTRL after done SW_RESET
+    rtkve1_reg_writel(dev, GDI_BUS_CTRL, 0x00);
+
+	return 0;
+}
+
+static int write_fw(uint16_t *code_word, uint32_t size)
+{
+    int i;
+    vpu_bit_firmware_info_t bit_firmware_info;
+
+    bit_firmware_info.size = sizeof(vpu_bit_firmware_info_t);
+    bit_firmware_info.core_idx = 0;
+    bit_firmware_info.reg_base_offset = 0;
+
+    for (i = 0; i < 512; i++)
+        bit_firmware_info.bit_code[i] = code_word[i];
+
+    if (rtd16xxb_vdi_write_bit_firmware(&bit_firmware_info,
+        bit_firmware_info.size) < 0) {
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static int load_fw(struct videc_dev *dev,
+            uint16_t *code_word, uint32_t size)
+{
+    int ret = 0;
+    uint32_t data;
+    struct rtkve1_dev_info *dev_info = NULL;
+    u32 *src = (u32 *)code_word;
+    int i = 0;
+
+    dev_info = (struct rtkve1_dev_info *)dev->ve1_devinfo;
+
+    /* Check if the firmware has a 16-byte Freescale header, skip it */
+    if (code_word[0] == 'M' && code_word[1] == 'X')
+        src += 4;
+    /*
+     * Check whether the firmware is in native order or pre-reordered for
+     * memory access. The first instruction opcode always is 0xe40e.
+     */
+    if (__le16_to_cpup((__le16 *)src) == 0xe40e) {
+		u32 *dst = dev_info->codebuf.vaddr;
+        for (i = 0; i < (size - 16) / 4; i += 2) {
+            dst[i] = (src[i + 1] << 16) | (src[i + 1] >> 16);
+            dst[i + 1] = (src[i] << 16) | (src[i] >> 16);
+        }
+    } else {
+        /* Copy the already reordered firmware image */
+        memcpy(dev_info->codebuf.vaddr, src, size);
+	}
+
+    rtkve1_reg_writel(dev, BIT_INT_ENABLE, 0);
+    rtkve1_reg_writel(dev, BIT_CODE_RUN, 0);
+
+    for (i = 0; i < 2048; ++i) {
+        data = code_word[i];
+        rtkve1_reg_writel(dev, BIT_CODE_DOWN, (i << 16) | data);
+    }
+
+    dev_dbg(dev->dev, "%d.%s.ret:%d\n",
+        __LINE__, __func__, ret);
+    return ret;
+}
+
+int rtkve1_init(struct videc_dev *dev, u8 *firmware, uint32_t size)
+{
+    struct rtkve1_dev_info *dev_info = NULL;
+	int ret;
+	uint32_t data;
+
+	dev_info = (struct rtkve1_dev_info *)dev->ve1_devinfo;
+
+	ret = load_fw(dev, (uint16_t *)firmware, size);
+	if (ret < 0) {
+		dev_err(dev->dev, "%d.%s.failed to load a firmware.ret:%d\n",
+            __LINE__, __func__, ret);
+		return ret;
+	}
+    if (write_fw((uint16_t *)firmware, size) < 0) {
+		dev_err(dev->dev, "%d.%s.write_fw() fail.ret:%d\n",
+            __LINE__, __func__, ret);
+    }
+
+	rtkve1_reg_writel(dev, BIT_PARA_BUF_ADDR, dev_info->parabuf.paddr);
+	rtkve1_reg_writel(dev, BIT_CODE_BUF_ADDR, dev_info->codebuf.paddr);
+	rtkve1_reg_writel(dev, BIT_TEMP_BUF_ADDR, dev_info->tempbuf.paddr);
+
+	rtkve1_reg_writel(dev, BIT_BIT_STREAM_CTRL, VPU_STREAM_ENDIAN);
+	rtkve1_reg_writel(dev, BIT_FRAME_MEM_CTRL,
+        CBCR_INTERLEAVE << 2 | VPU_FRAME_ENDIAN);
+
+	rtkve1_reg_writel(dev, BIT_BIT_STREAM_PARAM, 0);
+
+	rtkve1_reg_writel(dev, BIT_AXI_SRAM_USE, 0);
+	rtkve1_reg_writel(dev, BIT_INT_ENABLE, 0);
+	rtkve1_reg_writel(dev, BIT_ROLLBACK_STATUS, 0);
+
+	data = (1 << INT_BIT_BIT_BUF_FULL);
+	data |= (1 << INT_BIT_BIT_BUF_EMPTY);
+	data |= (1 << INT_BIT_DEC_MB_ROWS);
+	data |= (1 << INT_BIT_SEQ_INIT);
+	data |= (1 << INT_BIT_DEC_FIELD);
+	data |= (1 << INT_BIT_PIC_RUN);
+
+	rtkve1_reg_writel(dev, BIT_INT_ENABLE, data);
+	rtkve1_reg_writel(dev, BIT_INT_CLEAR, 0x1);
+	rtkve1_reg_writel(dev, BIT_BUSY_FLAG, 0x1);
+	rtkve1_reg_writel(dev, BIT_CODE_RESET, 1);
+	rtkve1_reg_writel(dev, BIT_CODE_RUN, 1);
+
+	ret = rtkve1_wait_busy(dev, BIT_BUSY_FLAG);
+	if (ret) {
+		dev_err(dev->dev,
+			"%d.%s.timeout for checking BIT_BUSY_FLAG.ret:%d\n",
+            __LINE__, __func__, ret);
+		return -ETIMEDOUT;
+	}
+	dev_dbg(dev->dev, "%d.%s.BIT_CUR_PC:0x%x\n",
+        __LINE__, __func__,
+        rtkve1_reg_readl(dev, BIT_CUR_PC));
+	return 0;
+}
+
+int rtkve1_initialize(struct rtkve1enc_ctx *ctx, struct videc_dev *dev)
+{
+    int ret = 0;
+    struct vpudrv_buffer_t reg;
+    u32 product_code;
+    struct rtkve1_dev_info *dev_info = NULL;
+    vpu_clock_info_t clockInfo;
+    int i = 0;
+    vpudrv_buffer_t vdb;
+
+    if (dev->ve1_register == NULL) {
+        if (rtd16xxb_vdi_ioctl_get_register_info(&reg) < 0) {
+            return -EINVAL;
+        }
+        dev_info(dev->dev, "%d.%s.reg.size:%d.virt_addr:0x%lx\n",
+            __LINE__, __func__,
+            reg.size,
+            reg.virt_addr);
+        dev->ve1_register = (void __iomem *)reg.virt_addr;
+    }
+
+    mutex_lock(&dev->ve1_hw_mutex);
+
+    ctx->inst_index = dev->ve1_instance_nums;
+    ctx->enc_initialized = 1;
+    dev->ve1_instance_nums++;
+    dev_info(dev->dev, "%d.%s.inst_index:%d.enc_initialized:%d.ve1_instance_nums:%d.\n",
+        __LINE__, __func__,
+        ctx->inst_index,
+        ctx->enc_initialized,
+        dev->ve1_instance_nums);
+
+    if (dev->ve1_instance_nums == 1) {
+        clockInfo.core_idx = 0;
+        clockInfo.enable = 1;
+        rtd16xxb_vdi_ioctl_set_rtk_clk_gating(&clockInfo);
+        dev_dbg(dev->dev, "%d.%s.set rtk_clk_gating on\n",
+            __LINE__, __func__);
+    }
+
+    product_code = rtkve1_reg_readl(dev, VPU_PRODUCT_CODE_REGISTER);
+    dev_dbg(dev->dev, "%d.%s.product_code:0x%x\n",
+        __LINE__, __func__,
+        product_code);
+
+    if (!rtkve1_is_init(dev)) {
+        /* Clear registers */
+        dev_dbg(dev->dev, "%d.%s.w_register clear start\n", __LINE__, __func__);
+        for (i = 0; i < 64; i++)
+            rtkve1_reg_writel(dev, BIT_CODE_BUF_ADDR + i * 4, 0);
+        dev_dbg(dev->dev, "%d.%s.w_register clear end\n", __LINE__, __func__);
+    }
+
+    dev_info = (struct rtkve1_dev_info *)dev->ve1_devinfo;
+
+#if 1
+    vdb.size = SIZE_COMMON;
+    if (rtd16xxb_vdi_ioctl_get_common_memory(&vdb) < 0) {
+        dev_err(dev->dev, "%d.%s.rtd16xxb_vdi_ioctl_get_common_memory() fail\n",
+            __LINE__, __func__);
+        ret = -EINVAL;
+        goto mutex_unlock;
+    }
+    dev_info->codebuf.size = CODE_BUF_SIZE;
+    dev_info->codebuf.paddr = (dma_addr_t)(vdb.phys_addr);
+    dev_info->codebuf.vaddr = (void *)(vdb.virt_addr);
+    dev_dbg(dev->dev, "%d.%s.get_dma.name:codebuf.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+        __LINE__, __func__,
+        dev_info->codebuf.size,
+        dev_info->codebuf.paddr,
+        dev_info->codebuf.vaddr);
+
+    dev_info->tempbuf.size = TEMP_BUF_SIZE;
+    dev_info->tempbuf.paddr = (dma_addr_t)(dev_info->codebuf.paddr + CODE_BUF_SIZE);
+    dev_info->tempbuf.vaddr = (void *)(dev_info->codebuf.vaddr + CODE_BUF_SIZE);
+    dev_dbg(dev->dev, "%d.%s.get_dma.name:tempbuf.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+        __LINE__, __func__,
+        dev_info->tempbuf.size,
+        dev_info->tempbuf.paddr,
+        dev_info->tempbuf.vaddr);
+
+    dev_info->parabuf.size = PARA_BUF_SIZE;
+    dev_info->parabuf.paddr = (dma_addr_t)(dev_info->tempbuf.paddr + TEMP_BUF_SIZE);
+    dev_info->parabuf.vaddr = (void *)(dev_info->tempbuf.vaddr + TEMP_BUF_SIZE);
+    dev_dbg(dev->dev, "%d.%s.get_dma.name:parabuf.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+        __LINE__, __func__,
+        dev_info->parabuf.size,
+        dev_info->parabuf.paddr,
+        dev_info->parabuf.vaddr);
+#else
+	if (dev_info->codebuf.size == 0) {
+		ret = rtkve1_alloc_dma_memory(dev, &dev_info->codebuf, CODE_BUF_SIZE, "codebuf",
+				dev->debugfs_root);
+		if (ret < 0) {
+			return ret;
+		}
+		dev_dbg(dev->dev, "%d.%s.alloc_dma.name:codebuf.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+			__LINE__, __func__,
+			dev_info->codebuf.size,
+			dev_info->codebuf.paddr,
+			dev_info->codebuf.vaddr);
+	}
+	if (dev_info->parabuf.size == 0) {
+		ret = rtkve1_alloc_dma_memory(dev, &dev_info->parabuf, PARA_BUF_SIZE, "parabuf",
+				dev->debugfs_root);
+		if (ret < 0) {
+			return ret;
+		}
+		dev_dbg(dev->dev, "%d.%s.alloc_dma.name:parabuf.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+			__LINE__, __func__,
+			dev_info->parabuf.size,
+			dev_info->parabuf.paddr,
+			dev_info->parabuf.vaddr);
+	}
+	if (dev_info->tempbuf.size == 0) {
+		ret = rtkve1_alloc_dma_memory(dev, &dev_info->tempbuf, TEMP_BUF_SIZE, "tempbuf",
+				dev->debugfs_root);
+		if (ret < 0) {
+			return ret;
+		}
+		dev_dbg(dev->dev, "%d.%s.alloc_dma.name:tempbuf.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+			__LINE__, __func__,
+			dev_info->tempbuf.size,
+			dev_info->tempbuf.paddr,
+			dev_info->tempbuf.vaddr);
+	}
+#endif
+
+    if (rtkve1_is_init(dev))
+        goto mutex_unlock;
+
+    ret = rtkve1_reset(dev, SW_RESET_ON_BOOT);
+    if (ret) {
+        dev_err(dev->dev, "%d.%s.failed to reset rtkve1.ret:%d\n",
+            __LINE__, __func__,
+            ret);
+        goto mutex_unlock;
+    }
+
+    ret = rtkve1_init(dev, dev->ve1fw_binary, dev->ve1fw_size_in_word*2);
+    if (ret) {
+        dev_err(dev->dev,
+            "%d.%s.failed to initialize rtkve1.ret:%d\n",
+            __LINE__, __func__,
+            ret);
+    }
+
+mutex_unlock:
+    mutex_unlock(&dev->ve1_hw_mutex);
+
+    return ret;
+}
+
+int rtkve1_finalize(struct rtkve1enc_ctx *ctx, struct videc_dev *dev)
+{
+    int ret = 0;
+    vpu_clock_info_t clockInfo;
+
+    dev_dbg(dev->dev, "%d.%s.[+] enc_initialized:%d\n",
+        __LINE__, __func__,
+        ctx->enc_initialized);
+
+    if (ctx->enc_initialized == 0) {
+        dev_info(dev->dev, "%d.%s.[-] not initial yet\n",
+            __LINE__, __func__);
+        return -EINVAL;
+    }
+
+	mutex_lock(&dev->ve1_hw_mutex);
+    dev->ve1_instance_nums--;
+    dev_info(dev->dev, "%d.%s.ve1_instance_nums:%d\n",
+        __LINE__, __func__,
+        dev->ve1_instance_nums);
+
+    ret = rtkve1_wait_cmd_traffic_idle(dev);
+    if (ret) {
+        dev_err(dev->dev,
+            "%d.%s.timeout for checking RTKVE1_CMD_TRAFFIC.ret:%d\n",
+            __LINE__, __func__, ret);
+    }
+
+    if (dev->ve1_instance_nums == 0) {
+        clockInfo.core_idx = 0;
+        clockInfo.enable = 0;
+        rtd16xxb_vdi_ioctl_set_rtk_clk_gating(&clockInfo);
+        dev_dbg(dev->dev, "%d.%s.set rtk_clk_gating off\n",
+            __LINE__, __func__);
+    }
+
+    ctx->enc_initialized = 0;
+	mutex_unlock(&dev->ve1_hw_mutex);
+	dev_dbg(dev->dev, "%d.%s.[-]\n", __LINE__, __func__);
+
+    return ret;
+}
\ No newline at end of file
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/rtkve1_regdefine.h
@@ -0,0 +1,599 @@
+//--=========================================================================--
+//  This file is a part of VPU Reference API project
+//-----------------------------------------------------------------------------
+//
+//       This confidential and proprietary software may be used only
+//     as authorized by a licensing agreement from Chips&Media Inc.
+//     In the event of publication, the following notice is applicable:
+//
+//            (C) COPYRIGHT 2006 - 2011  CHIPS&MEDIA INC.
+//                      ALL RIGHTS RESERVED
+//
+//       The entire notice above must be reproduced on all authorized
+//       copies.
+//
+//--=========================================================================--
+#ifndef __RTKVE1_REG_DEFINE_H__
+#define __RTKVE1_REG_DEFINE_H__
+
+/************************************************************************/
+/* COMMON REGISTERS                                                     */
+/************************************************************************/
+#define VPU_PRODUCT_NAME_REGISTER 0x1040
+#define VPU_PRODUCT_CODE_REGISTER 0x1044
+
+//------------------------------------------------------------------------------
+// REGISTER BASE
+//------------------------------------------------------------------------------
+#define BIT_BASE 0x0000
+#define GDMA_BASE 0x1000
+#define MBC_BASE 0x0400
+#define ME_BASE 0x0600
+#define MC_BASE 0x0C00
+#define DMAC_BASE 0x2000
+
+#define BW_BASE 0x03000000
+//------------------------------------------------------------------------------
+// HARDWARE REGISTER
+//------------------------------------------------------------------------------
+// SW Reset command
+#define VPU_SW_RESET_BPU_CORE 0x008
+#define VPU_SW_RESET_BPU_BUS 0x010
+#define VPU_SW_RESET_VCE_CORE 0x020
+#define VPU_SW_RESET_VCE_BUS 0x040
+#define VPU_SW_RESET_GDI_CORE 0x080
+#define VPU_SW_RESET_GDI_BUS 0x100
+
+#define BIT_CODE_RUN (BIT_BASE + 0x000)
+#define BIT_CODE_DOWN (BIT_BASE + 0x004)
+#define BIT_INT_REQ (BIT_BASE + 0x008)
+#define BIT_INT_CLEAR (BIT_BASE + 0x00C)
+#define BIT_INT_STS (BIT_BASE + 0x010)
+#define BIT_CODE_RESET (BIT_BASE + 0x014)
+#define BIT_CUR_PC (BIT_BASE + 0x018)
+#define BIT_SW_RESET (BIT_BASE + 0x024)
+#define BIT_SW_RESET_STATUS (BIT_BASE + 0x034)
+
+//------------------------------------------------------------------------------
+// GLOBAL REGISTER
+//------------------------------------------------------------------------------
+#define BIT_CODE_BUF_ADDR (BIT_BASE + 0x100)
+#define BIT_WORK_BUF_ADDR (BIT_BASE + 0x104)
+#define BIT_PARA_BUF_ADDR (BIT_BASE + 0x108)
+#define BIT_BIT_STREAM_CTRL (BIT_BASE + 0x10C)
+#define BIT_FRAME_MEM_CTRL (BIT_BASE + 0x110)
+#define BIT_BIT_STREAM_PARAM (BIT_BASE + 0x114)
+#define BIT_TEMP_BUF_ADDR (BIT_BASE + 0x118)
+
+#define BIT_RD_PTR (BIT_BASE + 0x120)
+#define BIT_WR_PTR (BIT_BASE + 0x124)
+
+#define BIT_ROLLBACK_STATUS (BIT_BASE + 0x128) // internal used in f/w.
+
+#define BIT_AXI_SRAM_USE (BIT_BASE + 0x140)
+#define BIT_BYTE_POS_FRAME_START (BIT_BASE + 0x144)
+#define BIT_BYTE_POS_FRAME_END (BIT_BASE + 0x148)
+#define BIT_FRAME_CYCLE (BIT_BASE + 0x14C)
+
+#define BIT_FRM_DIS_FLG (BIT_BASE + 0x150)
+
+#define BIT_BUSY_FLAG (BIT_BASE + 0x160)
+#define BIT_RUN_COMMAND (BIT_BASE + 0x164)
+#define BIT_RUN_INDEX (BIT_BASE + 0x168)
+#define BIT_RUN_COD_STD (BIT_BASE + 0x16C)
+#define BIT_INT_ENABLE (BIT_BASE + 0x170)
+#define BIT_INT_REASON (BIT_BASE + 0x174)
+#define BIT_RUN_AUX_STD (BIT_BASE + 0x178)
+
+// MSG REGISTER ADDRESS changed
+#define BIT_MSG_0 (BIT_BASE + 0x130)
+#define BIT_MSG_1 (BIT_BASE + 0x134)
+#define BIT_MSG_2 (BIT_BASE + 0x138)
+#define BIT_MSG_3 (BIT_BASE + 0x13C)
+
+#define MBC_BUSY (MBC_BASE + 0x040)
+#define MC_BUSY (MC_BASE + 0x004)
+
+#define BIT_ME_LINEBUFFER_MODE (ME_BASE + 0x004) // CODA980
+#define BIT_ME_LINE_OVERFLOW (ME_BASE + 0x008) // CODA980
+#define BIT_ME_SEARCH_OVERFLOW (ME_BASE + 0x00C) // CODA980
+
+//------------------------------------------------------------------------------
+// [ENC SEQ INIT] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_ENC_SEQ_BB_START (BIT_BASE + 0x180)
+#define CMD_ENC_SEQ_BB_SIZE (BIT_BASE + 0x184)
+#define CMD_ENC_SEQ_OPTION                                                     \
+	(BIT_BASE +                                                            \
+	 0x188) // HecEnable,ConstIntraQp, FMO, QPREP, AUD, SLICE, MB BIT
+#define CMD_ENC_SEQ_COD_STD (BIT_BASE + 0x18C)
+#define CMD_ENC_SEQ_SRC_SIZE (BIT_BASE + 0x190)
+#define CMD_ENC_SEQ_SRC_F_RATE (BIT_BASE + 0x194)
+#define CMD_ENC_SEQ_MP4_PARA (BIT_BASE + 0x198)
+#define CMD_ENC_SEQ_263_PARA (BIT_BASE + 0x19C)
+#define CMD_ENC_SEQ_264_PARA (BIT_BASE + 0x1A0)
+#define CMD_ENC_SEQ_SLICE_MODE (BIT_BASE + 0x1A4)
+#define CMD_ENC_SEQ_GOP_NUM (BIT_BASE + 0x1A8)
+#define CMD_ENC_SEQ_RC_PARA (BIT_BASE + 0x1AC)
+#define CMD_ENC_SEQ_RC_BUF_SIZE (BIT_BASE + 0x1B0)
+#define CMD_ENC_SEQ_INTRA_REFRESH (BIT_BASE + 0x1B4)
+#define CMD_ENC_SEQ_VIDEO_SIGNAL_TYPE_PRESENT (BIT_BASE + 0x1BC)
+#define CMD_ENC_SEQ_INTRA_QP (BIT_BASE + 0x1C4)
+#define CMD_ENC_SEQ_RC_QP_MAX (BIT_BASE + 0x1C8)
+#define CMD_ENC_SEQ_RC_GAMMA (BIT_BASE + 0x1CC)
+#define CMD_ENC_SEQ_RC_INTERVAL_MODE                                           \
+	(BIT_BASE + 0x1D0) // mbInterval[32:2], rcIntervalMode[1:0]
+#define CMD_ENC_SEQ_INTRA_WEIGHT (BIT_BASE + 0x1D4)
+#define CMD_ENC_SEQ_ME_OPTION (BIT_BASE + 0x1D8)
+#define CMD_ENC_SEQ_RC_PARA2 (BIT_BASE + 0x1DC)
+#define CMD_ENC_SEQ_QP_RANGE_SET (BIT_BASE + 0x1E0)
+#define CMD_ENC_SEQ_RC_MAX_INTRA_SIZE (BIT_BASE + 0x1F0)
+
+#define CMD_ENC_SEQ_FIRST_MBA (BIT_BASE + 0x1E4)
+#define CMD_ENC_SEQ_HEIGHT_IN_MAP_UNITS (BIT_BASE + 0x1E8)
+#define CMD_ENC_SEQ_OVERLAP_CLIP_SIZE (BIT_BASE + 0x1EC)
+
+//------------------------------------------------------------------------------
+// [ENC SEQ END] COMMAND
+//------------------------------------------------------------------------------
+#define RET_ENC_SEQ_END_SUCCESS (BIT_BASE + 0x1C0)
+//------------------------------------------------------------------------------
+// [ENC PIC RUN] COMMAND
+//------------------------------------------------------------------------------
+
+#define CMD_ENC_PIC_SRC_INDEX (BIT_BASE + 0x180)
+#define CMD_ENC_PIC_SRC_STRIDE (BIT_BASE + 0x184)
+#define CMD_ENC_PIC_SRC_ADDR_Y (BIT_BASE + 0x1A8)
+#define CMD_ENC_PIC_SRC_ADDR_CB (BIT_BASE + 0x1AC)
+#define CMD_ENC_PIC_SRC_ADDR_CR (BIT_BASE + 0x1B0)
+#define CMD_ENC_PIC_SRC_BOTTOM_Y (BIT_BASE + 0x1E8) //coda980 only
+#define CMD_ENC_PIC_SRC_BOTTOM_CB (BIT_BASE + 0x1EC) //coda980 only
+#define CMD_ENC_PIC_SRC_BOTTOM_CR (BIT_BASE + 0x1F0) //coda980 only
+
+#define CMD_ENC_PIC_QS (BIT_BASE + 0x18C)
+#define CMD_ENC_PIC_ROT_MODE (BIT_BASE + 0x190)
+#define CMD_ENC_PIC_OPTION (BIT_BASE + 0x194)
+#define CMD_ENC_PIC_BB_START (BIT_BASE + 0x198)
+#define CMD_ENC_PIC_BB_SIZE (BIT_BASE + 0x19C)
+#define CMD_ENC_PIC_PARA_BASE_ADDR (BIT_BASE + 0x1A0)
+#define CMD_ENC_PIC_SUB_FRAME_SYNC (BIT_BASE + 0x1A4)
+
+#define RET_ENC_PIC_FRAME_NUM (BIT_BASE + 0x1C0)
+#define RET_ENC_PIC_TYPE (BIT_BASE + 0x1C4)
+#define RET_ENC_PIC_FRAME_IDX (BIT_BASE + 0x1C8)
+#define RET_ENC_PIC_SLICE_NUM (BIT_BASE + 0x1CC)
+#define RET_ENC_PIC_FLAG (BIT_BASE + 0x1D0)
+#define RET_ENC_PIC_SUCCESS (BIT_BASE + 0x1D8)
+
+//------------------------------------------------------------------------------
+// [ENC ROI INIT] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_ENC_ROI_MODE (BIT_BASE + 0x180) // [1]: RoiType, [0]: RoiEn
+#define CMD_ENC_ROI_NUM (BIT_BASE + 0x184) // [3:0] RoiNum
+
+#ifdef SUPPORT_ROI_50
+#define CMD_ENC_ROI_POS_0                                                      \
+	(BIT_BASE +                                                            \
+	 0x188) // [31:24]: MbyEnd, [23:16]: MbyStart, [15:8]: MbxEnd, [7:0]: MbxStart
+#define CMD_ENC_ROI_QP_0 (BIT_BASE + 0x18C)
+#define CMD_ENC_ROI_INDEX (BIT_BASE + 0x190)
+#else
+#define CMD_ENC_ROI_POS_0                                                      \
+	(BIT_BASE +                                                            \
+	 0x188) // [31:24]: MbyEnd, [23:16]: MbyStart, [15:8]: MbxEnd, [7:0]: MbxStart
+#define CMD_ENC_ROI_QP_0 (BIT_BASE + 0x18C) // [05:04]: RoiQp
+#define CMD_ENC_ROI_POS_1 (BIT_BASE + 0x190)
+#define CMD_ENC_ROI_QP_1 (BIT_BASE + 0x194)
+#define CMD_ENC_ROI_POS_2 (BIT_BASE + 0x198)
+#define CMD_ENC_ROI_QP_2 (BIT_BASE + 0x19C)
+#define CMD_ENC_ROI_POS_3 (BIT_BASE + 0x1A0)
+#define CMD_ENC_ROI_QP_3 (BIT_BASE + 0x1A4)
+#define CMD_ENC_ROI_POS_4 (BIT_BASE + 0x1A8)
+#define CMD_ENC_ROI_QP_4 (BIT_BASE + 0x1AC)
+#define CMD_ENC_ROI_POS_5 (BIT_BASE + 0x1B0)
+#define CMD_ENC_ROI_QP_5 (BIT_BASE + 0x1B4)
+#define CMD_ENC_ROI_POS_6 (BIT_BASE + 0x1B8)
+#define CMD_ENC_ROI_QP_6 (BIT_BASE + 0x1BC)
+#define CMD_ENC_ROI_POS_7 (BIT_BASE + 0x1C0)
+#define CMD_ENC_ROI_QP_7 (BIT_BASE + 0x1C4)
+#define CMD_ENC_ROI_POS_8 (BIT_BASE + 0x1C8)
+#define CMD_ENC_ROI_QP_8 (BIT_BASE + 0x1CC)
+#define CMD_ENC_ROI_POS_9 (BIT_BASE + 0x1D0)
+#define CMD_ENC_ROI_QP_9 (BIT_BASE + 0x1D4)
+#endif
+#define RET_ENC_ROI_SUCCESS (BIT_BASE + 0x1D8)
+
+//------------------------------------------------------------------------------
+// [ENC SET FRAME BUF] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_SET_FRAME_SUBSAMP_A (BIT_BASE + 0x188) //coda960 only
+#define CMD_SET_FRAME_SUBSAMP_B (BIT_BASE + 0x18C) //coda960 only
+#define CMD_SET_FRAME_SUBSAMP_A_MVC (BIT_BASE + 0x1B0) //coda960 only
+#define CMD_SET_FRAME_SUBSAMP_B_MVC (BIT_BASE + 0x1B4) //coda960 only
+
+#define CMD_SET_FRAME_DP_BUF_BASE (BIT_BASE + 0x1B0)
+#define CMD_SET_FRAME_DP_BUF_SIZE (BIT_BASE + 0x1B4)
+
+//------------------------------------------------------------------------------
+// [ENC HEADER] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_ENC_HEADER_CODE (BIT_BASE + 0x180)
+#define CMD_ENC_HEADER_BB_START (BIT_BASE + 0x184)
+#define CMD_ENC_HEADER_BB_SIZE (BIT_BASE + 0x188)
+#define CMD_ENC_HEADER_FRAME_CROP_H (BIT_BASE + 0x18C)
+#define CMD_ENC_HEADER_FRAME_CROP_V (BIT_BASE + 0x190)
+#define CMD_ENC_HEADER_CABAC_MODE (BIT_BASE + 0x194) // CODA980
+#define CMD_ENC_HEADER_CABAC_INIT_IDC (BIT_BASE + 0x198) // CODA980
+#define CMD_ENC_HEADER_TRANSFORM_8X8 (BIT_BASE + 0x19C) // CODA980
+#define CMD_ENC_HEADER_CHROMA_FORMAT (BIT_BASE + 0x1A0) // CODA980
+#define CMD_ENC_HEADER_FIELD_FLAG (BIT_BASE + 0x1A4)
+#define CMD_ENC_HEADER_PROFILE (BIT_BASE + 0x1A8) // CODA980
+
+#define RET_ENC_HEADER_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [ENC_PARA_SET] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_ENC_PARA_SET_TYPE (BIT_BASE + 0x180)
+#define RET_ENC_PARA_SET_SIZE (BIT_BASE + 0x1c0)
+#define RET_ENC_PARA_SET_SUCCESS (BIT_BASE + 0x1C4)
+
+//------------------------------------------------------------------------------
+// [ENC PARA CHANGE] COMMAND :
+//------------------------------------------------------------------------------
+#define CMD_ENC_PARAM_CHANGE_ENABLE                                            \
+	(BIT_BASE +                                                            \
+	 0x180) // FrameRateEn[3], BitRateEn[2], IntraQpEn[1], GopEn[0]
+#define CMD_ENC_PARAM_CHANGE_GOP_NUM (BIT_BASE + 0x184)
+#define CMD_ENC_PARAM_CHANGE_INTRA_QP (BIT_BASE + 0x188)
+#define CMD_ENC_PARAM_CHANGE_BITRATE (BIT_BASE + 0x18C)
+#define CMD_ENC_PARAM_CHANGE_F_RATE (BIT_BASE + 0x190)
+#define CMD_ENC_PARAM_CHANGE_INTRA_REFRESH (BIT_BASE + 0x194) // update param
+#define CMD_ENC_PARAM_CHANGE_SLICE_MODE (BIT_BASE + 0x198) // update param
+#define CMD_ENC_PARAM_CHANGE_HEC_MODE (BIT_BASE + 0x19C) // update param
+#define CMD_ENC_PARAM_CHANGE_CABAC_MODE                                        \
+	(BIT_BASE + 0x1A0) // entropyCodingMode==2
+#define CMD_ENC_PARAM_CHANGE_PPS_ID (BIT_BASE + 0x1B4) // entropyCodingMode==2
+
+#define RET_ENC_SEQ_PARA_CHANGE_SECCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [DEC SEQ INIT] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_DEC_SEQ_BB_START (BIT_BASE + 0x180)
+#define CMD_DEC_SEQ_BB_SIZE (BIT_BASE + 0x184)
+#define CMD_DEC_SEQ_OPTION (BIT_BASE + 0x188)
+
+#define CMD_DEC_SEQ_MP4_ASP_CLASS (BIT_BASE + 0x19C)
+#define CMD_DEC_SEQ_VC1_STREAM_FMT (BIT_BASE + 0x19C)
+#define CMD_DEC_SEQ_X264_MV_EN (BIT_BASE + 0x19C)
+#define CMD_DEC_SEQ_SPP_CHUNK_SIZE (BIT_BASE + 0x1A0)
+
+// For MPEG2 only
+#define CMD_DEC_SEQ_USER_DATA_OPTION (BIT_BASE + 0x194)
+#define CMD_DEC_SEQ_USER_DATA_BASE_ADDR (BIT_BASE + 0x1AC)
+#define CMD_DEC_SEQ_USER_DATA_BUF_SIZE (BIT_BASE + 0x1B0)
+
+#define CMD_DEC_SEQ_INIT_ESCAPE (BIT_BASE + 0x114)
+
+#define RET_DEC_SEQ_BIT_RATE (BIT_BASE + 0x1B4)
+#define RET_DEC_SEQ_EXT_INFO (BIT_BASE + 0x1B8)
+#define RET_DEC_SEQ_SUCCESS (BIT_BASE + 0x1C0)
+#define RET_DEC_SEQ_SRC_SIZE (BIT_BASE + 0x1C4)
+
+#define RET_DEC_SEQ_ASPECT (BIT_BASE + 0x1C8)
+#define RET_DEC_SEQ_FRAME_NEED (BIT_BASE + 0x1CC)
+#define RET_DEC_SEQ_FRAME_DELAY (BIT_BASE + 0x1D0)
+#define RET_DEC_SEQ_INFO (BIT_BASE + 0x1D4)
+#define RET_DEC_SEQ_VP8_SCALE_INFO (BIT_BASE + 0x1D4)
+
+#define RET_DEC_SEQ_CROP_LEFT_RIGHT (BIT_BASE + 0x1D8)
+#define RET_DEC_SEQ_CROP_TOP_BOTTOM (BIT_BASE + 0x1DC)
+#define RET_DEC_SEQ_SEQ_ERR_REASON (BIT_BASE + 0x1E0)
+
+#define RET_DEC_SEQ_FRATE_NR (BIT_BASE + 0x1E4)
+#define RET_DEC_SEQ_FRATE_DR (BIT_BASE + 0x1E8)
+#define RET_DEC_SEQ_HEADER_REPORT (BIT_BASE + 0x1EC)
+#define RET_DEC_SEQ_VUI_INFO (BIT_BASE + 0x18C)
+#define RET_DEC_SEQ_VUI_INFO_2 (BIT_BASE + 0x17C)
+#define RET_DEC_SEQ_VUI_PIC_STRUCT (BIT_BASE + 0x1A8)
+
+#define RET_DEC_SEQ_MP2_BAR_LEFT_RIGHT (BIT_BASE + 0x180)
+#define RET_DEC_SEQ_MP2_BAR_TOP_BOTTOM (BIT_BASE + 0x184)
+
+#define RET_DEC_PIC_MP2_OFFSET1 (BIT_BASE + 0x19C) // for MP2
+#define RET_DEC_PIC_MP2_OFFSET2 (BIT_BASE + 0x1A0) // for MP2
+#define RET_DEC_PIC_MP2_OFFSET3 (BIT_BASE + 0x1A4) // for MP2
+#define RET_DEC_PIC_MP2_OFFSET_NUM (BIT_BASE + 0x1A8) // for MP2
+
+//------------------------------------------------------------------------------
+// [DEC SEQ END] COMMAND
+//------------------------------------------------------------------------------
+#define RET_DEC_SEQ_END_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [DEC PIC RUN] COMMAND
+//----------------------------------------------------
+#define CMD_DEC_PIC_ROT_MODE (BIT_BASE + 0x180)
+#define CMD_DEC_PIC_ROT_INDEX (BIT_BASE + 0x184)
+#define CMD_DEC_PIC_ROT_ADDR_Y (BIT_BASE + 0x188)
+#define CMD_DEC_PIC_ROT_ADDR_CB (BIT_BASE + 0x18C)
+#define CMD_DEC_PIC_ROT_ADDR_CR (BIT_BASE + 0x190)
+#define CMD_DEC_PIC_ROT_STRIDE (BIT_BASE + 0x1B8)
+#define CMD_DEC_PIC_ROT_BOTTOM_Y (BIT_BASE + 0x1E8) // coda980 only
+#define CMD_DEC_PIC_ROT_BOTTOM_CB (BIT_BASE + 0x1EC) // coda980 only
+#define CMD_DEC_PIC_ROT_BOTTOM_CR (BIT_BASE + 0x1F0) // coda980 only
+
+#define CMD_DEC_PIC_OPTION (BIT_BASE + 0x194)
+
+#define CMD_DEC_PIC_USER_DATA_BASE_ADDR (BIT_BASE + 0x1AC)
+#define CMD_DEC_PIC_USER_DATA_BUF_SIZE (BIT_BASE + 0x1B0)
+
+#define CMD_DEC_PIC_NUM_ROWS (BIT_BASE + 0x1B4)
+#define CMD_DEC_PIC_THO_PIC_PARA (BIT_BASE + 0x198)
+#define CMD_DEC_PIC_THO_QMAT_ADDR (BIT_BASE + 0x1A0)
+#define CMD_DEC_PIC_THO_MB_PARA_ADDR (BIT_BASE + 0x1A4)
+#define RET_DEC_PIC_VUI_PIC_STRUCT (BIT_BASE + 0x1A8)
+#define RET_DEC_PIC_AVC_FPA_SEI0 (BIT_BASE + 0x19C)
+#define RET_DEC_PIC_AVC_FPA_SEI1 (BIT_BASE + 0x1A0)
+#define RET_DEC_PIC_AVC_FPA_SEI2 (BIT_BASE + 0x1A4)
+#define RET_DEC_NUM_MB_ROWS (BIT_BASE + 0x1B4) // it will be update
+#define RET_DEC_PIC_AVC_SEI_RP_INFO (BIT_BASE + 0x1B4)
+#define RET_DEC_PIC_HRD_INFO (BIT_BASE + 0x1B8)
+#define RET_DEC_PIC_SIZE (BIT_BASE + 0x1BC)
+#define RET_DEC_PIC_FRAME_NUM (BIT_BASE + 0x1C0)
+#define RET_DEC_PIC_FRAME_IDX (BIT_BASE + 0x1C4)
+#define RET_DEC_PIC_DISPLAY_IDX (BIT_BASE + 0x1C4)
+#define RET_DEC_PIC_ERR_MB (BIT_BASE + 0x1C8)
+#define RET_DEC_PIC_TYPE (BIT_BASE + 0x1CC)
+#define RET_DEC_PIC_POST (BIT_BASE + 0x1D0) // for VC1
+#define RET_DEC_PIC_MVC_REPORT (BIT_BASE + 0x1D0) // for MVC
+#define RET_DEC_PIC_OPTION (BIT_BASE + 0x1D4)
+#define RET_DEC_PIC_SUCCESS (BIT_BASE + 0x1D8)
+#define RET_DEC_PIC_CUR_IDX (BIT_BASE + 0x1DC)
+#define RET_DEC_PIC_DECODED_IDX (BIT_BASE + 0x1DC)
+#define RET_DEC_PIC_CROP_LEFT_RIGHT (BIT_BASE + 0x1E0) // for AVC, MPEG-2
+#define RET_DEC_PIC_CROP_TOP_BOTTOM (BIT_BASE + 0x1E4) // for AVC, MPEG-2
+#define RET_DEC_PIC_MODULO_TIME_BASE (BIT_BASE + 0x1E0) // for MP4
+#define RET_DEC_PIC_VOP_TIME_INCREMENT (BIT_BASE + 0x1E4) // for MP4
+#define RET_DEC_PIC_RV_TR (BIT_BASE + 0x1E8)
+#define RET_DEC_PIC_VP8_PIC_REPORT (BIT_BASE + 0x1E8)
+#define RET_DEC_PIC_ATSC_USER_DATA_INFO (BIT_BASE + 0x1E8) // H.264, MEPEG2
+#define RET_DEC_PIC_VUI_INFO_2 (BIT_BASE + 0x17C) // H.264, MPEG2
+#define RET_DEC_PIC_VUI_INFO (BIT_BASE + 0x1EC)
+#define RET_DEC_PIC_RV_TR_BFRAME (BIT_BASE + 0x1EC)
+#define RET_DEC_PIC_ASPECT (BIT_BASE + 0x1F0)
+#define RET_DEC_PIC_VP8_SCALE_INFO (BIT_BASE + 0x1F0)
+#define RET_DEC_PIC_FRATE_NR (BIT_BASE + 0x1F4)
+#define RET_DEC_PIC_FRATE_DR (BIT_BASE + 0x1F8)
+#define RET_DEC_PIC_POC_TOP (BIT_BASE + 0x1AC)
+#define RET_DEC_PIC_POC_BOT (BIT_BASE + 0x1B0)
+#define RET_DEC_PIC_POC (BIT_BASE + 0x1B0)
+
+//------------------------------------------------------------------------------
+// [DEC SET FRAME BUF] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_SET_FRAME_BUF_NUM (BIT_BASE + 0x180)
+#define CMD_SET_FRAME_BUF_STRIDE (BIT_BASE + 0x184)
+
+#define CMD_SET_FRAME_SLICE_BB_START (BIT_BASE + 0x188)
+#define CMD_SET_FRAME_SLICE_BB_SIZE (BIT_BASE + 0x18C)
+#define CMD_SET_FRAME_AXI_BIT_ADDR (BIT_BASE + 0x190)
+#define CMD_SET_FRAME_AXI_IPACDC_ADDR (BIT_BASE + 0x194)
+#define CMD_SET_FRAME_AXI_DBKY_ADDR (BIT_BASE + 0x198)
+#define CMD_SET_FRAME_AXI_DBKC_ADDR (BIT_BASE + 0x19C)
+#define CMD_SET_FRAME_AXI_OVL_ADDR (BIT_BASE + 0x1A0)
+#define CMD_SET_FRAME_AXI_BTP_ADDR (BIT_BASE + 0x1A4)
+
+#define CMD_SET_FRAME_CACHE_SIZE (BIT_BASE + 0x1A8)
+#define CMD_SET_FRAME_CACHE_CONFIG (BIT_BASE + 0x1AC)
+#define CMD_SET_FRAME_MB_BUF_BASE (BIT_BASE + 0x1B0)
+#define CMD_SET_FRAME_MAX_DEC_SIZE (BIT_BASE + 0x1B8)
+#define CMD_SET_FRAME_DELAY (BIT_BASE + 0x1BC)
+
+#define RET_SET_FRAME_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [DEC_PARA_SET] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_DEC_PARA_SET_TYPE (BIT_BASE + 0x180)
+#define CMD_DEC_PARA_SET_SIZE (BIT_BASE + 0x184)
+#define RET_DEC_PARA_SET_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [DEC_BUF_FLUSH] COMMAND
+//------------------------------------------------------------------------------
+#define RET_DEC_BUF_FLUSH_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [SLEEP/WAKE] COMMAND
+//------------------------------------------------------------------------------
+#define RET_SLEEP_WAKE_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [SET PIC INFO] COMMAND
+//------------------------------------------------------------------------------
+#define GDI_PRI_RD_PRIO_L (GDMA_BASE + 0x000)
+#define GDI_PRI_RD_PRIO_H (GDMA_BASE + 0x004)
+#define GDI_PRI_WR_PRIO_L (GDMA_BASE + 0x008)
+#define GDI_PRI_WR_PRIO_H (GDMA_BASE + 0x00c)
+#define GDI_PRI_RD_LOCK_CNT (GDMA_BASE + 0x010)
+#define GDI_PRI_WR_LOCK_CNT (GDMA_BASE + 0x014)
+#define GDI_SEC_RD_PRIO_L (GDMA_BASE + 0x018)
+#define GDI_SEC_RD_PRIO_H (GDMA_BASE + 0x01c)
+#define GDI_SEC_WR_PRIO_L (GDMA_BASE + 0x020)
+#define GDI_SEC_WR_PRIO_H (GDMA_BASE + 0x024)
+#define GDI_SEC_RD_LOCK_CNT (GDMA_BASE + 0x028)
+#define GDI_SEC_WR_LOCK_CNT (GDMA_BASE + 0x02c)
+#define GDI_SEC_CLIENT_EN (GDMA_BASE + 0x030)
+#define GDI_CONTROL (GDMA_BASE + 0x034)
+#define GDI_PIC_INIT_HOST (GDMA_BASE + 0x038)
+
+#define GDI_HW_VERINFO (GDMA_BASE + 0x050)
+#define GDI_PINFO_REQ (GDMA_BASE + 0x060)
+#define GDI_PINFO_ACK (GDMA_BASE + 0x064)
+#define GDI_PINFO_ADDR (GDMA_BASE + 0x068)
+#define GDI_PINFO_DATA (GDMA_BASE + 0x06c)
+#define GDI_BWB_ENABLE (GDMA_BASE + 0x070)
+#define GDI_BWB_SIZE (GDMA_BASE + 0x074)
+#define GDI_BWB_STD_STRUCT (GDMA_BASE + 0x078)
+#define GDI_BWB_STATUS (GDMA_BASE + 0x07c)
+
+#define GDI_STATUS (GDMA_BASE + 0x080)
+
+#define GDI_DEBUG_0 (GDMA_BASE + 0x084)
+#define GDI_DEBUG_1 (GDMA_BASE + 0x088)
+#define GDI_DEBUG_2 (GDMA_BASE + 0x08c)
+#define GDI_DEBUG_3 (GDMA_BASE + 0x090)
+#define GDI_DEBUG_PROBE_ADDR (GDMA_BASE + 0x094)
+#define GDI_DEBUG_PROBE_DATA (GDMA_BASE + 0x098)
+
+// write protect
+#define GDI_WPROT_ERR_CLR (GDMA_BASE + 0x0A0)
+#define GDI_WPROT_ERR_RSN (GDMA_BASE + 0x0A4)
+#define GDI_WPROT_ERR_ADR (GDMA_BASE + 0x0A8)
+#define GDI_WPROT_RGN_EN (GDMA_BASE + 0x0AC)
+#define GDI_WPROT_RGN0_STA (GDMA_BASE + 0x0B0)
+#define GDI_WPROT_RGN0_END (GDMA_BASE + 0x0B4)
+#define GDI_WPROT_RGN1_STA (GDMA_BASE + 0x0B8)
+#define GDI_WPROT_RGN1_END (GDMA_BASE + 0x0BC)
+#define GDI_WPROT_RGN2_STA (GDMA_BASE + 0x0C0)
+#define GDI_WPROT_RGN2_END (GDMA_BASE + 0x0C4)
+#define GDI_WPROT_RGN3_STA (GDMA_BASE + 0x0C8)
+#define GDI_WPROT_RGN3_END (GDMA_BASE + 0x0CC)
+#define GDI_WPROT_RGN4_STA (GDMA_BASE + 0x0D0)
+#define GDI_WPROT_RGN4_END (GDMA_BASE + 0x0D4)
+#define GDI_WPROT_RGN5_STA (GDMA_BASE + 0x0D8)
+#define GDI_WPROT_RGN5_END (GDMA_BASE + 0x0DC)
+#define GDI_WPROT_REGIONS 6
+
+#define GDI_BUS_CTRL (GDMA_BASE + 0x0F0)
+#define GDI_BUS_STATUS (GDMA_BASE + 0x0F4)
+
+#define GDI_SIZE_ERR_FLAG (GDMA_BASE + 0x0e0)
+#define GDI_ADR_RQ_SIZE_ERR_PRI0 (GDMA_BASE + 0x100)
+#define GDI_ADR_RQ_SIZE_ERR_PRI1 (GDMA_BASE + 0x104)
+#define GDI_ADR_RQ_SIZE_ERR_PRI1 (GDMA_BASE + 0x104)
+#define GDI_ADR_RQ_SIZE_ERR_PRI2 (GDMA_BASE + 0x108)
+#define GDI_ADR_WQ_SIZE_ERR_PRI0 (GDMA_BASE + 0x10c)
+#define GDI_ADR_WQ_SIZE_ERR_PRI1 (GDMA_BASE + 0x110)
+#define GDI_ADR_WQ_SIZE_ERR_PRI2 (GDMA_BASE + 0x114)
+
+#define GDI_ADR_RQ_SIZE_ERR_SEC0 (GDMA_BASE + 0x118)
+#define GDI_ADR_RQ_SIZE_ERR_SEC1 (GDMA_BASE + 0x11c)
+#define GDI_ADR_RQ_SIZE_ERR_SEC2 (GDMA_BASE + 0x120)
+
+#define GDI_ADR_WQ_SIZE_ERR_SEC0 (GDMA_BASE + 0x124)
+#define GDI_ADR_WQ_SIZE_ERR_SEC1 (GDMA_BASE + 0x128)
+#define GDI_ADR_WQ_SIZE_ERR_SEC2 (GDMA_BASE + 0x12c)
+
+#define GDI_INFO_CONTROL (GDMA_BASE + 0x400)
+#define GDI_INFO_PIC_SIZE (GDMA_BASE + 0x404)
+// GDI 2.0 register
+#define GDI_INFO_BASE_Y_TOP (GDMA_BASE + 0x408)
+#define GDI_INFO_BASE_CB_TOP (GDMA_BASE + 0x40C)
+#define GDI_INFO_BASE_CR_TOP (GDMA_BASE + 0x410)
+#define GDI_INFO_BASE_Y_BOT (GDMA_BASE + 0x414)
+#define GDI_INFO_BASE_CB_BOT (GDMA_BASE + 0x418)
+#define GDI_INFO_BASE_CR_BOT (GDMA_BASE + 0x41C)
+#define GDI_XY2AXI_LUM_BIT00 (GDMA_BASE + 0x800)
+#define GDI_XY2AXI_LUM_BIT1F (GDMA_BASE + 0x87C)
+#define GDI_XY2AXI_CHR_BIT00 (GDMA_BASE + 0x880)
+#define GDI_XY2AXI_CHR_BIT1F (GDMA_BASE + 0x8FC)
+#define GDI_XY2AXI_CONFIG (GDMA_BASE + 0x900)
+
+//GDI 1.0 register
+#define GDI_INFO_BASE_Y (GDMA_BASE + 0x408)
+#define GDI_INFO_BASE_CB (GDMA_BASE + 0x40C)
+#define GDI_INFO_BASE_CR (GDMA_BASE + 0x410)
+
+#define GDI_XY2_CAS_0 (GDMA_BASE + 0x800)
+#define GDI_XY2_CAS_F (GDMA_BASE + 0x83C)
+
+#define GDI_XY2_BA_0 (GDMA_BASE + 0x840)
+#define GDI_XY2_BA_1 (GDMA_BASE + 0x844)
+#define GDI_XY2_BA_2 (GDMA_BASE + 0x848)
+#define GDI_XY2_BA_3 (GDMA_BASE + 0x84C)
+
+#define GDI_XY2_RAS_0 (GDMA_BASE + 0x850)
+#define GDI_XY2_RAS_F (GDMA_BASE + 0x88C)
+
+#define GDI_XY2_RBC_CONFIG (GDMA_BASE + 0x890)
+#define GDI_RBC2_AXI_0 (GDMA_BASE + 0x8A0)
+#define GDI_RBC2_AXI_1F (GDMA_BASE + 0x91C)
+#define GDI_TILEDBUF_BASE (GDMA_BASE + 0x920)
+
+//------------------------------------------------------------------------------
+// Product, Reconfiguration Information
+//------------------------------------------------------------------------------
+#define DBG_CONFIG_REPORT_0 (GDMA_BASE + 0x040) //product name and version
+#define DBG_CONFIG_REPORT_1                                                    \
+	(GDMA_BASE + 0x044) //interface configuration, hardware definition
+#define DBG_CONFIG_REPORT_2 (GDMA_BASE + 0x048) //standard definition
+#define DBG_CONFIG_REPORT_3 (GDMA_BASE + 0x04C) //standard detail definition
+#define DBG_CONFIG_REPORT_4 (GDMA_BASE + 0x050) //definition in cnm_define
+#define DBG_CONFIG_REPORT_5 (GDMA_BASE + 0x054)
+#define DBG_CONFIG_REPORT_6 (GDMA_BASE + 0x058)
+#define DBG_CONFIG_REPORT_7 (GDMA_BASE + 0x05C)
+
+//------------------------------------------------------------------------------
+// MEMORY COPY MODULE REGISTER
+//------------------------------------------------------------------------------
+#define ADDR_DMAC_PIC_RUN (DMAC_BASE + 0x000)
+#define ADDR_DMAC_PIC_STATUS (DMAC_BASE + 0x004)
+#define ADDR_DMAC_PIC_OP_MODE (DMAC_BASE + 0x008)
+#define ADDR_DMAC_ID (DMAC_BASE + 0x00c) //the result muse be 0x4d435059
+
+#define ADDR_DMAC_SRC_BASE_Y (DMAC_BASE + 0x010)
+#define ADDR_DMAC_SRC_BASE_CB (DMAC_BASE + 0x014)
+#define ADDR_DMAC_SRC_BASE_CR (DMAC_BASE + 0x018)
+#define ADDR_DMAC_SRC_STRIDE (DMAC_BASE + 0x01c)
+
+#define ADDR_DMAC_DST_BASE_Y (DMAC_BASE + 0x020)
+#define ADDR_DMAC_DST_BASE_CB (DMAC_BASE + 0x024)
+#define ADDR_DMAC_DST_BASE_CR (DMAC_BASE + 0x028)
+#define ADDR_DMAC_DST_STRIDE (DMAC_BASE + 0x02c)
+
+#define ADDR_DMAC_SRC_MB_POS_X (DMAC_BASE + 0x030)
+#define ADDR_DMAC_SRC_MB_POS_Y (DMAC_BASE + 0x034)
+#define ADDR_DMAC_SRC_MB_BLK_X (DMAC_BASE + 0x038)
+#define ADDR_DMAC_SRC_MB_BLK_Y (DMAC_BASE + 0x03c)
+
+#define ADDR_DMAC_DST_MB_POS_X (DMAC_BASE + 0x040)
+#define ADDR_DMAC_DST_MB_POS_Y (DMAC_BASE + 0x044)
+#define ADDR_DMAC_DST_MB_BLK_X (DMAC_BASE + 0x048)
+#define ADDR_DMAC_DST_MB_BLK_Y (DMAC_BASE + 0x04c)
+
+#define ADDR_DMAC_SET_COLOR_Y (DMAC_BASE + 0x050)
+#define ADDR_DMAC_SET_COLOR_CB (DMAC_BASE + 0x054)
+#define ADDR_DMAC_SET_COLOR_CR (DMAC_BASE + 0x058)
+
+#define ADDR_DMAC_SUB_SAMPLE_X (DMAC_BASE + 0x060)
+#define ADDR_DMAC_SUB_SAMPLE_Y (DMAC_BASE + 0x064)
+
+//------------------------------------------------------------------------------
+// DMAC
+//------------------------------------------------------------------------------
+#define DMAC_DMAC_RUN (DMAC_BASE + 0x00)
+#define DMAC_SOFT_RESET (DMAC_BASE + 0x04)
+#define DMAC_DMAC_MODE (DMAC_BASE + 0x08)
+#define DMAC_DESC_ADDR (DMAC_BASE + 0x0c)
+#define DMAC_DESC0 (DMAC_BASE + 0x10)
+#define DMAC_DESC1 (DMAC_BASE + 0x14)
+#define DMAC_DESC2 (DMAC_BASE + 0x18)
+#define DMAC_DESC3 (DMAC_BASE + 0x1c)
+#define DMAC_DESC4 (DMAC_BASE + 0x20)
+#define DMAC_DESC5 (DMAC_BASE + 0x24)
+#define DMAC_DESC6 (DMAC_BASE + 0x28)
+#define DMAC_DESC7 (DMAC_BASE + 0x2c)
+
+//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
+// [FIRMWARE VERSION] COMMAND
+// [32:16] project number =>
+// [16:0]  version => xxxx.xxxx.xxxxxxxx
+//------------------------------------------------------------------------------
+#define RET_FW_VER_NUM (BIT_BASE + 0x1c0)
+#define RET_FW_CODE_REV (BIT_BASE + 0x1c4)
+
+#endif // #ifndef __RTKVE1_REG_DEFINE_H__
\ No newline at end of file
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/rtkve1enc_common.h
@@ -0,0 +1,288 @@
+#ifndef __RTKVE1_ENC_COMMON_H__
+#define __RTKVE1_ENC_COMMON_H__
+
+#include <linux/debugfs.h>
+#include <media/v4l2-device.h> // for struct v4l2_device, struct video_device
+#include <media/v4l2-ctrls.h> // for struct v4l2_ctrl_handler
+#include <media/v4l2-fh.h> // for struct v4l2_fh
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/v4l2-event.h>
+#include "drv_if.h"
+#include "ve1.h"
+
+#define RTKVE1_ENC_DEV_NAME "rtkve1-enc"
+
+#define RTKVE1_CMD_TRAFFIC 0x3020
+
+//#define VDI_LITTLE_ENDIAN 0
+
+#define VE1_BWB_ENABLE 1
+
+#define CODE_BUF_SIZE (248 * 1024)
+#define TEMP_BUF_SIZE (204 * 1024)
+#define WORK_BUF_SIZE (80 * 1024)
+#define PARA_BUF_SIZE (10 * 1024)
+#define BS_BUF_SIZE (4 * 1024)
+#define RTKVE1_ENC_HEADER_TEMP_BUF_SIZE 256
+
+#define RTKVE1_ENC_TIMEOUT 1000 /* ms */
+#define RTKVE1_MAX_FRAME_BUFFERS 32
+
+#define	HEADER_H264_SPS	0
+#define	HEADER_H264_PPS	1
+
+// COD_STD
+enum { HEVC_DEC = 0,
+       AVC_DEC = 0,
+       VC1_DEC = 1,
+       HEVC_ENC = 1,
+       MP2_DEC = 2,
+       MP4_DEC = 3,
+       DV3_DEC = 3,
+       RV_DEC = 4,
+       AVS_DEC = 5,
+       VPX_DEC = 7,
+       MAX_DEC = 7,
+       AVC_ENC = 8,
+       MP4_ENC = 11,
+       MAX_CODECS,
+};
+
+enum {
+	INT_BIT_INIT = 0,
+	INT_BIT_SEQ_INIT = 1,
+	INT_BIT_SEQ_END = 2,
+	INT_BIT_PIC_RUN = 3,
+	INT_BIT_FRAMEBUF_SET = 4,
+	INT_BIT_ENC_HEADER = 5,
+	INT_BIT_DEC_PARA_SET = 7,
+	INT_BIT_DEC_BUF_FLUSH = 8,
+	INT_BIT_USERDATA = 9,
+	INT_BIT_DEC_FIELD = 10,
+#ifdef SUPPORT_CDB
+	INT_BIT_DEBUFFER = 12,
+#endif
+	INT_BIT_DEC_MB_ROWS = 13,
+	INT_BIT_BIT_BUF_EMPTY = 14,
+	INT_BIT_BIT_BUF_FULL = 15
+};
+
+// BIT_RUN command
+enum { DEC_SEQ_INIT = 1,
+       ENC_SEQ_INIT = 1,
+       DEC_SEQ_END = 2,
+       ENC_SEQ_END = 2,
+       PIC_RUN = 3,
+       SET_FRAME_BUF = 4,
+       ENCODE_HEADER = 5,
+       ENC_PARA_SET = 6,
+       DEC_PARA_SET = 7,
+       DEC_BUF_FLUSH = 8,
+       RC_CHANGE_PARAMETER = 9,
+       VPU_SLEEP = 10,
+       VPU_WAKE = 11,
+       ENC_ROI_INIT = 12,
+       FIRMWARE_GET = 0xf };
+
+enum sw_reset_mode {
+	SW_RESET_SAFETY, /**< It resets VPU in safe way. It waits until pending bus transaction is completed and then perform reset. */
+	SW_RESET_FORCE, /**< It forces to reset VPU without waiting pending bus transaction to be completed. It is used for immediate termination such as system off. */
+	SW_RESET_ON_BOOT /**< This is the default reset mode that is executed since system booting.  This mode is actually executed in VPU_Init(), so does not have to be used independently. */
+};
+
+#define H264_MIN_ENC_PIC_WIDTH 96U
+#define H264_MIN_ENC_PIC_HEIGHT 16U
+#define H264_MAX_ENC_PIC_WIDTH 4096U
+#define H264_MAX_ENC_PIC_HEIGHT 2304U
+
+#define RAW_MIN_ENC_PIC_WIDTH 96U
+#define RAW_MIN_ENC_PIC_HEIGHT 16U
+#define RAW_MAX_ENC_PIC_WIDTH 4096U
+#define RAW_MAX_ENC_PIC_HEIGHT 2304U
+
+#define ENC_PIC_SIZE_STEP 1
+
+#define DEFAULT_FRAMERATE_NUM 30000
+#define DEFAULT_FRAMERATE_DENOM 1000
+#define DEFAULT_GOP 30
+#define DEFAULT_I_FRAME_QP -1
+
+#define MIN_BITRATE (64 * 1024)
+#define MAX_BITRATE (50000 * 1024)
+#define DEF_BITRATE (20000 * 1024)
+
+struct vpu_format {
+	unsigned int v4l2_pix_fmt;
+	unsigned int max_width;
+	unsigned int min_width;
+	unsigned int max_height;
+	unsigned int min_height;
+	unsigned int num_planes;
+};
+
+enum vpu_fmt_type { VPU_FMT_TYPE_CODEC = 0, VPU_FMT_TYPE_RAW = 1 };
+
+enum rtkve1_enc_state {
+	RTK_VE1_STATE_ENC_IDLE = 0,
+	RTK_VE1_STATE_ENC_SEQ_INIT,
+	RTK_VE1_STATE_ENC_REG_FBS,
+	RTK_VE1_STATE_ENC_HEADER,
+	RTK_VE1_STATE_ENC_PIC,
+	RTK_VE1_STATE_ENC_RESET,
+	RTK_VE1_STATE_ENC_SEQ_END,
+	RTK_VE1_STATE_ENC_TIMEOUT
+};
+
+struct rtkve1enc_params {
+	u32 framerate_num;
+	u32 framerate_denom;
+	u32 framerate;
+	u32 bitrate;
+	u32 bitrate_mode;
+	u32 gop_size;
+	u32 header_with_frm;
+	u32 force_key_frm;
+	u32 h264_profile_idc;
+	u32 h264_level_idc;
+	s32 intra_qp;
+	u32 transform_8x8_mode;
+	u32 field_flag;
+	u32 field_ref_mode;
+	u32 entropy_coding_mode;
+	u32 s_ctrl_level_value;
+};
+
+struct rtkve1_buf {
+	void *vaddr;
+	dma_addr_t paddr;
+	u32 size;
+	struct debugfs_blob_wrapper blob;
+	struct dentry *dentry;
+};
+
+struct rtkve1_dev_info {
+	struct rtkve1_buf codebuf;
+	struct rtkve1_buf parabuf;
+	struct rtkve1_buf tempbuf;
+};
+
+
+struct rtkve1enc_ctx {
+	/* RTKDEV_FOURCC_ENC or RTKDEV_FOURCC_DEC for distinguish priv in device_run() */
+	u32 rtkdev_fourcc;
+	u32 inst_index;
+    struct videc_dev *dev;
+	struct v4l2_fh v4l2_fh;
+	struct v4l2_ctrl_handler v4l2_ctrl_hdl;
+	struct v4l2_pix_format_mplane src_fmt;
+	struct v4l2_pix_format_mplane dst_fmt;
+	const struct rtkve1_context_ops *ops;
+	struct dentry *debugfs_entry;
+	struct work_struct encode_work;
+	struct vpudrv_buffer_t regs;
+
+	enum v4l2_colorspace colorspace;
+	enum v4l2_xfer_func xfer_func;
+	enum v4l2_ycbcr_encoding ycbcr_enc;
+	enum v4l2_quantization quantization;
+
+	u32 src_buf_size;
+	u32 src_buf_width;
+	u32 src_buf_height;
+
+	u32 codec_mode;
+	struct rtkve1enc_params enc_params;
+	struct rtkve1_buf bitstream;
+	struct rtkve1_buf workbuf;
+	struct rtkve1_buf framebuf[RTKVE1_MAX_FRAME_BUFFERS];
+	u8 frame_addr[RTKVE1_MAX_FRAME_BUFFERS][3][4];
+
+	int enc_initialized;
+	enum rtkve1_enc_state enc_state;
+	int seq_init_done;
+	int reg_fbs_done;
+	int enc_header_done;
+	int enc_pic_done;
+	int seq_end_done;
+	int stopping;
+	int out_streamon;
+	int cap_streamon;
+	bool eos;
+
+	u32 rdPtr;
+	u32 wrPtr;
+	u32 enc_min_fb_num;
+	u32 queued_src_buf_num;
+	u32 queued_dst_buf_num;
+	int reqbuf_out;
+	int reqbuf_cap;
+
+	void *enc_hdr_buf;
+	u32 enc_hdr_buf_size;
+	u32 enc_hdr_bytes;
+
+	int outbuf_new_file;
+	void *outbuf_fp;
+	unsigned char outbuf_file_name[256];
+	int enc_bs_new_file;
+	void *enc_bs_fp;
+	unsigned char enc_bs_file_name[256];
+
+	struct list_head list;
+	u32 srcbuf_sequence_of_key_frm;
+};
+
+struct rtkve1_context_ops {
+	const struct vpu_format *(*find_vpu_fmt)(unsigned int v4l2_pix_fmt,
+		enum vpu_fmt_type type);
+	const struct vpu_format *(*find_vpu_fmt_by_idx)(unsigned int idx,
+		enum vpu_fmt_type type);
+	int (*queue_init)(void *priv, struct vb2_queue *src_vq,
+		struct vb2_queue *dst_vq);
+	int (*ctrls_setup)(struct rtkve1enc_ctx *inst);
+	int (*reqbufs)(struct rtkve1enc_ctx *ctx, struct v4l2_requestbuffers *rb);
+	int (*decide_state)(struct rtkve1enc_ctx *ctx, enum rtkve1_enc_state *new_state);
+	int (*seq_init)(struct rtkve1enc_ctx *ctx);
+	int (*reg_fbs)(struct rtkve1enc_ctx *ctx);
+	int (*enc_header)(struct rtkve1enc_ctx *ctx);
+	int (*enc_pic)(struct rtkve1enc_ctx *ctx);
+	void (*seq_end)(struct rtkve1enc_ctx *ctx);
+	void (*run_timeout)(struct rtkve1enc_ctx *ctx);
+};
+
+void rtkve_set_default_format(struct rtkve1enc_ctx *inst,
+		struct v4l2_pix_format_mplane *src_fmt,
+		struct v4l2_pix_format_mplane *dst_fmt);
+
+extern struct v4l2_ioctl_ops rtkve1enc_ioctl_ops;
+extern const struct rtkve1_context_ops rtkve1enc_ops;
+
+static inline struct rtkve1enc_ctx *v4l2fh_to_ctx(struct v4l2_fh *vfh)
+{
+	return container_of(vfh, struct rtkve1enc_ctx, v4l2_fh);
+}
+
+int rtkve1_md5_hash(unsigned char *result, int resultLen, char *data, int dataLen);
+int rtkve1_alloc_dma_memory(struct videc_dev *dev, struct rtkve1_buf *buf,
+        size_t size, const char *name, struct dentry *parent);
+void rtkve1_free_dma_memory(struct videc_dev *dev,
+        struct rtkve1_buf *buf, const char *name);
+void rtkve1_parabuf_write(struct rtkve1enc_ctx *ctx, int index, u32 value);
+int rtkve1_write_memory(struct videc_dev *dev,
+    void *vaddr, size_t bufsize,
+    size_t offset, u8 *data, int len, int endian);
+int rtkve1_read_memory(struct videc_dev *dev,
+    void *vaddr, size_t bufsize,
+    size_t offset, u8 *data, int len, int endian);
+void rtkve1_reg_writel(struct videc_dev *dev, unsigned int addr,
+		     unsigned int data);
+unsigned int rtkve1_reg_readl(struct videc_dev *dev, u32 addr);
+void rtkve1_issue_command(struct rtkve1enc_ctx *ctx, u32 cmd);
+int rtkve1_wait_interrupt(struct rtkve1enc_ctx *ctx, unsigned int timeout);
+void rtkve1_clear_interrupt(struct rtkve1enc_ctx *ctx);
+int rtkve1_wait_busy(struct videc_dev *dev, unsigned int addr);
+int rtkve1_initialize(struct rtkve1enc_ctx *ctx, struct videc_dev *dev);
+int rtkve1_finalize(struct rtkve1enc_ctx *ctx, struct videc_dev *dev);
+
+#endif // #define __RTKVE1_ENC_COMMON_H__
\ No newline at end of file
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/rtkve1enc_enc.c
@@ -0,0 +1,2245 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video encoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/gcd.h>
+#include <linux/genalloc.h>
+#include <linux/idr.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/kfifo.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/videodev2.h>
+#include <linux/of.h>
+#include <linux/ratelimit.h>
+#include <linux/reset.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-v4l2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/videobuf2-vmalloc.h>
+
+#include "rtkve1enc_common.h"
+#include "rtkve1_regdefine.h"
+#include "ve1_vdi.h"
+
+//#define RTKVE1_DUMP_OUTBUF_EN
+#if defined(RTKVE1_DUMP_OUTBUF_EN)
+static int g_outbuf_dump_serial = 0;
+#endif
+
+//#define RTKVE1_DUMP_ENC_BS_EN
+#if defined(RTKVE1_DUMP_ENC_BS_EN)
+static int g_enc_bs_dump_serial = 0;
+#endif
+
+//#define VE1_MD5_SIZE 16
+//static unsigned char md5[VE1_MD5_SIZE];
+
+static const struct vpu_format rtkve1enc_fmt_list[2][3] = {
+	[VPU_FMT_TYPE_CODEC] = {
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_H264,
+			.max_width = H264_MAX_ENC_PIC_WIDTH,
+			.min_width = H264_MIN_ENC_PIC_WIDTH,
+			.max_height = H264_MAX_ENC_PIC_HEIGHT,
+			.min_height = H264_MIN_ENC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+	},
+	[VPU_FMT_TYPE_RAW] = {
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_YUV420,
+			.max_width = RAW_MAX_ENC_PIC_WIDTH,
+			.min_width = RAW_MIN_ENC_PIC_WIDTH,
+			.max_height = RAW_MAX_ENC_PIC_HEIGHT,
+			.min_height = RAW_MIN_ENC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_NV12,
+			.max_width = RAW_MAX_ENC_PIC_WIDTH,
+			.min_width = RAW_MIN_ENC_PIC_WIDTH,
+			.max_height = RAW_MAX_ENC_PIC_HEIGHT,
+			.min_height = RAW_MIN_ENC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_NV21,
+			.max_width = RAW_MAX_ENC_PIC_WIDTH,
+			.min_width = RAW_MIN_ENC_PIC_WIDTH,
+			.max_height = RAW_MAX_ENC_PIC_HEIGHT,
+			.min_height = RAW_MIN_ENC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+	}
+};
+
+const char *rtk_ve1_enc_state_str[] = {
+	[RTK_VE1_STATE_ENC_IDLE]		= "enc_idle",
+	[RTK_VE1_STATE_ENC_SEQ_INIT]	= "seq_init",
+	[RTK_VE1_STATE_ENC_REG_FBS]		= "reg_fbs",
+	[RTK_VE1_STATE_ENC_HEADER]		= "enc_header",
+	[RTK_VE1_STATE_ENC_PIC]			= "enc_pic",
+	[RTK_VE1_STATE_ENC_RESET]		= "enc_reset",
+	[RTK_VE1_STATE_ENC_SEQ_END]		= "seq_end",
+	[RTK_VE1_STATE_ENC_TIMEOUT]		= "enc_timeout",
+};
+
+/* vb2_ops */
+static int rtkve_enc_queue_setup(struct vb2_queue *q, unsigned int *num_buffers,
+				 unsigned int *num_planes, unsigned int sizes[],
+				 struct device *alloc_devs[])
+{
+	struct rtkve1enc_ctx *ctx = vb2_get_drv_priv(q);
+	struct v4l2_pix_format_mplane inst_format =
+		(V4L2_TYPE_IS_OUTPUT(q->type)) ? ctx->src_fmt : ctx->dst_fmt;
+	unsigned int i;
+	int ret = 0;
+
+	dev_dbg(ctx->dev->dev, "%s: num_buffers %d num_planes %d type %d\n",
+		__func__, *num_buffers, *num_planes, q->type);
+
+	if (*num_planes) {
+		if (inst_format.num_planes != *num_planes) {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		for (i = 0; i < *num_planes; i++) {
+			if (sizes[i] < inst_format.plane_fmt[i].sizeimage) {
+				ret = -EINVAL;
+				goto exit;
+			}
+		}
+	} else {
+		*num_planes = inst_format.num_planes;
+		for (i = 0; i < *num_planes; i++) {
+			sizes[i] = inst_format.plane_fmt[i].sizeimage;
+			dev_dbg(ctx->dev->dev, "size[%d] : %d\n", i, sizes[i]);
+		}
+	}
+exit:
+	return ret;
+}
+
+static int rtkve_enc_buf_out_validate(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+
+	vbuf->field = V4L2_FIELD_NONE;
+	return 0;
+}
+
+static int rtkve_enc_buf_prepare(struct vb2_buffer *vb)
+{
+	struct rtkve1enc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_queue *vq = vb->vb2_queue;
+	struct v4l2_pix_format_mplane *fmt;
+	int i;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.ctx:0x%px.type:%s\n",
+        __LINE__, __func__,
+		ctx, v4l2_type_names[vq->type]);
+	if (V4L2_TYPE_IS_OUTPUT(vb->type)) {
+		//dev_dbg(ctx->dev->dev, "%d.%s.ctx:0x%px.type:%s.dma_addr:0x%llx\n",
+		//	__LINE__, __func__,
+		//	ctx, v4l2_type_names[vq->type],
+		//	vb2_dma_contig_plane_dma_addr(vb, 0));
+		fmt = &ctx->src_fmt;
+	}
+	else
+		fmt = &ctx->dst_fmt;
+
+	for (i = 0; i < fmt->num_planes; i++) {
+		if (vb2_plane_size(vb, i) < fmt->plane_fmt[i].sizeimage) {
+			dev_err(ctx->dev->dev,
+				"data will not fit into plane %d (%lu < %d)", i,
+				vb2_plane_size(vb, i),
+				fmt->plane_fmt[i].sizeimage);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static void rtkve_enc_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct rtkve1enc_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_queue *vq = vb->vb2_queue;
+
+	if (V4L2_TYPE_IS_OUTPUT(vb->type)) {
+		vbuf->sequence = ctx->queued_src_buf_num++;
+		if (ctx->enc_params.force_key_frm) {
+			ctx->srcbuf_sequence_of_key_frm = vbuf->sequence;
+			dev_dbg(ctx->dev->dev, "%d.%s.ctx:0x%px.force key frame on sequence:%d\n",
+				__LINE__, __func__,
+				ctx, ctx->srcbuf_sequence_of_key_frm);
+			ctx->enc_params.force_key_frm = 0;
+		}
+	}
+	else {
+		vbuf->sequence = ctx->queued_dst_buf_num++;
+	}
+
+	dev_dbg(ctx->dev->dev, "%d.%s.ctx:0x%px.type:%s.sequence:%d\n",
+        __LINE__, __func__,
+		ctx, v4l2_type_names[vq->type],
+		vbuf->sequence);
+
+	v4l2_m2m_buf_queue(ctx->v4l2_fh.m2m_ctx, vbuf);
+}
+
+static int rtkve_enc_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct rtkve1enc_ctx *ctx = vb2_get_drv_priv(q);
+	int ret = 0;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.ctx:0x%px.type:%s\n",
+        __LINE__, __func__,
+		ctx, v4l2_type_names[q->type]);
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		ctx->out_streamon = 1;
+	}
+	else {
+		ctx->cap_streamon = 1;
+	}
+
+	return ret;
+}
+
+static void rtkve_enc_return_buffer(struct vb2_queue *vq, u32 state)
+{
+	struct rtkve1enc_ctx *ctx = vb2_get_drv_priv(vq);
+	struct vb2_v4l2_buffer *vbuf;
+
+	for (;;) {
+		if (V4L2_TYPE_IS_OUTPUT(vq->type))
+			vbuf = v4l2_m2m_src_buf_remove(ctx->v4l2_fh.m2m_ctx);
+		else
+			vbuf = v4l2_m2m_dst_buf_remove(ctx->v4l2_fh.m2m_ctx);
+
+		if (!vbuf)
+			break;
+
+		dev_dbg(ctx->dev->dev, "%d.%s.type:%s.v4l2_m2m_buf_done.vbuf:0x%px\n",
+			__LINE__, __func__,
+			v4l2_type_names[vq->type],
+			vbuf);
+		v4l2_m2m_buf_done(vbuf, state);
+	}
+}
+
+static void rtkve_enc_stop_streaming(struct vb2_queue *q)
+{
+	struct rtkve1enc_ctx *ctx = vb2_get_drv_priv(q);
+	struct v4l2_m2m_ctx *m2m_ctx = ctx->v4l2_fh.m2m_ctx;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.[+] ctx:0x%px.type:%s\n",
+        __LINE__, __func__,
+		ctx, v4l2_type_names[q->type]);
+
+	v4l2_m2m_suspend(ctx->dev->m2m_dev);
+
+	rtkve_enc_return_buffer(q, VB2_BUF_STATE_ERROR);
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		ctx->queued_src_buf_num = 0;
+		ctx->out_streamon = 0;
+	} else {
+		ctx->cap_streamon = 0;
+		ctx->stopping = 1;
+		queue_work(ctx->dev->encode_workqueue, &ctx->encode_work);
+		flush_work(&ctx->encode_work);
+
+		if (v4l2_m2m_has_stopped(m2m_ctx))
+			v4l2_m2m_clear_state(m2m_ctx);
+
+		ctx->queued_dst_buf_num = 0;
+	}
+
+	v4l2_m2m_resume(ctx->dev->m2m_dev);
+	dev_dbg(ctx->dev->dev, "%d.%s.[-] ctx:0x%px.type:%s\n",
+        __LINE__, __func__,
+		ctx, v4l2_type_names[q->type]);
+}
+
+static const struct vb2_ops rtkve1enc_vb2_ops = {
+	.queue_setup = rtkve_enc_queue_setup,
+	.buf_out_validate = rtkve_enc_buf_out_validate,
+	.buf_prepare = rtkve_enc_buf_prepare,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+	.buf_queue = rtkve_enc_buf_queue,
+	.start_streaming = rtkve_enc_start_streaming,
+	.stop_streaming = rtkve_enc_stop_streaming,
+};
+
+/* rtkve1_context_ops */
+static const struct vpu_format *rtkve_enc_find_fmt(unsigned int v4l2_pix_fmt,
+						enum vpu_fmt_type type)
+{
+	unsigned int index;
+	const struct vpu_format *fmt = NULL;
+
+	for (index = 0; index < ARRAY_SIZE(rtkve1enc_fmt_list[type]);
+	     index++) {
+		if (rtkve1enc_fmt_list[type][index].v4l2_pix_fmt ==
+		    v4l2_pix_fmt)
+			fmt = &rtkve1enc_fmt_list[type][index];
+	}
+
+	return fmt;
+}
+
+static const struct vpu_format *
+rtkve_enc_find_fmt_by_idx(unsigned int idx, enum vpu_fmt_type type)
+{
+	const struct vpu_format *fmt = NULL;
+
+	if (idx >= ARRAY_SIZE(rtkve1enc_fmt_list[type]))
+		goto exit;
+
+	if (!rtkve1enc_fmt_list[type][idx].v4l2_pix_fmt)
+		goto exit;
+
+	fmt = &rtkve1enc_fmt_list[type][idx];
+
+exit:
+	return fmt;
+}
+
+#define MAX_LEVEL_IDX 16
+static const int g_anLevel[MAX_LEVEL_IDX] =
+{
+    10, 11, 11, 12, 13,
+    //10, 16, 11, 12, 13,
+    20, 21, 22,
+    30, 31, 32,
+    40, 41, 42,
+    50, 51
+};
+
+static const int g_anLevelMaxMBPS[MAX_LEVEL_IDX] =
+{
+    1485,   1485,   3000,   6000, 11880,
+    11880,  19800,  20250,
+    40500,  108000, 216000,
+    245760, 245760, 522240,
+    589824, 983040
+};
+
+static const int g_anLevelMaxFS[MAX_LEVEL_IDX] =
+{
+    99,    99,   396, 396, 396,
+    396,   792,  1620,
+    1620,  3600, 5120,
+    8192,  8192, 8704,
+    22080, 36864
+};
+
+static const int g_anLevelMaxBR[MAX_LEVEL_IDX] =
+{
+    64,     64,   192,  384, 768,
+    2000,   4000,  4000,
+    10000,  14000, 20000,
+    20000,  50000, 50000,
+    135000, 240000
+};
+
+static const int g_anLevelMaxMbs[MAX_LEVEL_IDX] =
+{
+    28,   28,  56, 56, 56,
+    56,   79, 113,
+    113, 169, 202,
+    256, 256, 263,
+    420, 543
+};
+
+int rtkve1_h264_calc_level(int mb_num_x, int mb_num_y, int framerate, int bitrate)
+{
+    int mbps;
+    int framerate_div, framerate_res;
+    int mb_num_pic = (mb_num_x*mb_num_y);
+    int LevelIdc = 0;
+    int i, maxMbs;
+
+    pr_info("[%d]%s.mb_num_pic:%d.mb_num_x:%d.mb_num_y:%d.framerate:%d.bitrate:%d\n",
+        __LINE__, __func__,
+        mb_num_pic, mb_num_x, mb_num_y, framerate, bitrate);
+
+    framerate_div = (framerate >> 16) + 1;
+    framerate_res  = framerate & 0xFFFF;
+	framerate = framerate_res / framerate_div;
+    pr_info("[%d]%s.framerate_div:%d.framerate_res:%d.framerate:%d\n",
+        __LINE__, __func__,
+        framerate_div, framerate_res, framerate);
+    mbps = mb_num_pic*framerate;
+    pr_info("[%d]%s.mbps:%d\n",
+        __LINE__, __func__,
+        mbps);
+
+    for(i=0; i<MAX_LEVEL_IDX; i++)
+    {
+        maxMbs = g_anLevelMaxMbs[i];
+        //if ( mbps <= g_anLevelMaxMBPS[i]
+        //        && mb_num_pic <= g_anLevelMaxFS[i]
+        //        && mb_num_x   <= maxMbs
+        //        && mb_num_y   <= maxMbs
+        //        && bitrate  <= g_anLevelMaxBR[i] )
+        if ( mbps <= g_anLevelMaxMBPS[i]
+                && mb_num_pic <= g_anLevelMaxFS[i]
+                && mb_num_x   <= maxMbs
+                && mb_num_y   <= maxMbs)
+        {
+            LevelIdc = g_anLevel[i];
+            break;
+        }
+    }
+    pr_info("[%d]%s.i:%d.LevelIdc:%d\n",
+        __LINE__, __func__,
+        i, LevelIdc);
+
+    return LevelIdc;
+}
+
+static void dump_outbuf(struct rtkve1enc_ctx *ctx, uint8_t* buf,
+					uint32_t offset, uint32_t len)
+{
+#if defined(RTKVE1_DUMP_OUTBUF_EN)
+	int filp_open_flags;
+	ssize_t bytes = 0;
+	loff_t pos = 0;
+
+	if (ctx == NULL) {
+		return;
+	}
+
+	if ((buf != NULL) && (len != 0)) {
+		if (ctx->outbuf_new_file == 1) {
+			ctx->outbuf_new_file = 0;
+			filp_open_flags = O_CREAT | O_WRONLY;
+			memset(ctx->outbuf_file_name, 0, sizeof(unsigned char)*256);
+			snprintf(ctx->outbuf_file_name, 256,
+					"/mnt/outbuf_%d.yuv",
+					g_outbuf_dump_serial);
+			g_outbuf_dump_serial++;
+			dev_dbg(ctx->dev->dev, "%d.%s.create new outbuf dump:%s\n",__LINE__,__func__,
+					ctx->outbuf_file_name);
+		} else {
+			filp_open_flags = O_APPEND | O_WRONLY;
+		}
+		ctx->outbuf_fp =
+			(void *)filp_open(ctx->outbuf_file_name, filp_open_flags, 0);
+		if (IS_ERR((struct file *)ctx->outbuf_fp)) {
+			dev_err(ctx->dev->dev, "%d.%s.filp_open %s fail\n",__LINE__,__func__,
+					ctx->outbuf_file_name);
+		} else {
+			//dev_dbg(ctx->dev->dev, "%d.%s.filp_open %s ok\n",__LINE__,__func__,
+			//		ctx->outbuf_file_name);
+			bytes =
+				kernel_write((struct file *)(ctx->outbuf_fp),
+							(void *)(buf + offset), (size_t)len, &pos);
+			//dev_dbg(ctx->dev->dev, "%d.%s.kernel_write bytes:%ld.pos:%lld\n",__LINE__,__func__,
+			//		bytes, pos);
+			filp_close((struct file *)(ctx->outbuf_fp), NULL);
+			//dev_dbg(ctx->dev->dev, "%d.%s.filp_close %s\n",__LINE__,__func__,
+			//		ctx->outbuf_file_name);
+			ctx->outbuf_fp = NULL;
+		}
+	}
+#endif
+}
+
+static void enc_dump_bs(struct rtkve1enc_ctx *ctx, uint8_t* buf,
+				uint32_t len)
+{
+#if defined(RTKVE1_DUMP_ENC_BS_EN)
+	int filp_open_flags;
+	ssize_t bytes = 0;
+	loff_t pos = 0;
+
+	if (ctx == NULL) {
+		return;
+	}
+
+	if ((buf != NULL) && (len != 0)) {
+		if (ctx->enc_bs_new_file == 1) {
+			ctx->enc_bs_new_file = 0;
+			filp_open_flags = O_CREAT | O_WRONLY | O_TRUNC;
+			memset(ctx->enc_bs_file_name, 0, sizeof(unsigned char)*256);
+			snprintf(ctx->enc_bs_file_name, 256,
+					"/mnt/encbs_%d.es",
+					g_enc_bs_dump_serial);
+			g_enc_bs_dump_serial++;
+			dev_dbg(ctx->dev->dev, "%d.%s.create new outbuf dump:%s\n",__LINE__,__func__,
+					ctx->enc_bs_file_name);
+		} else {
+			filp_open_flags = O_APPEND | O_WRONLY;
+		}
+		ctx->enc_bs_fp =
+			(void *)filp_open(ctx->enc_bs_file_name, filp_open_flags, 0);
+		if (IS_ERR((struct file *)ctx->enc_bs_fp)) {
+			dev_err(ctx->dev->dev, "%d.%s.filp_open %s fail\n",__LINE__,__func__,
+					ctx->enc_bs_file_name);
+		} else {
+			//dev_dbg(ctx->dev->dev, "%d.%s.filp_open %s ok\n",__LINE__,__func__,
+			//		ctx->enc_bs_file_name);
+			bytes =
+				kernel_write((struct file *)(ctx->enc_bs_fp),
+							(void *)buf, (size_t)len, &pos);
+			//dev_dbg(ctx->dev->dev, "%d.%s.kernel_write bytes:%ld.pos:%lld\n",__LINE__,__func__,
+			//		bytes, pos);
+			filp_close((struct file *)(ctx->enc_bs_fp), NULL);
+			//dev_dbg(ctx->dev->dev, "%d.%s.filp_close %s\n",__LINE__,__func__,
+			//		ctx->enc_bs_file_name);
+			ctx->enc_bs_fp = NULL;
+		}
+	}
+#endif
+}
+
+static int enc_alloc_bsbuf_workbuf(struct rtkve1enc_ctx *ctx)
+{
+	struct videc_dev *dev = ctx->dev;
+	int ret = 0;
+
+	if (ctx->bitstream.size == 0) {
+		ret = rtkve1_alloc_dma_memory(dev, &ctx->bitstream, BS_BUF_SIZE, "bsbuf",
+				ctx->debugfs_entry);
+		if (ret < 0) {
+			return ret;
+		}
+		dev_dbg(dev->dev, "%d.%s.alloc_dma.name:bsbuf.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+			__LINE__, __func__,
+			ctx->bitstream.size,
+			ctx->bitstream.paddr,
+			ctx->bitstream.vaddr);
+	}
+	if (ctx->workbuf.size == 0) {
+		ret = rtkve1_alloc_dma_memory(dev, &ctx->workbuf, WORK_BUF_SIZE, "workbuf",
+				ctx->debugfs_entry);
+		if (ret < 0) {
+			return ret;
+		}
+		dev_dbg(dev->dev, "%d.%s.alloc_dma.name:workbuf.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+			__LINE__, __func__,
+			ctx->workbuf.size,
+			ctx->workbuf.paddr,
+			ctx->workbuf.vaddr);
+	}
+
+	return ret;
+}
+
+static int enc_alloc_frame_buffers(struct rtkve1enc_ctx *ctx)
+{
+	struct videc_dev *dev = ctx->dev;
+	int ret = 0;
+	int i = 0;
+	char dbg_name[16];
+
+	for (i=0; i < ctx->enc_min_fb_num; i++) {
+		memset(dbg_name, 0, sizeof(dbg_name));
+		snprintf(dbg_name, 16, "framebuf%d", i);
+		ret = rtkve1_alloc_dma_memory(dev, &ctx->framebuf[i], ctx->src_buf_size, dbg_name,
+				ctx->debugfs_entry);
+		if (ret < 0) {
+			return -ENOMEM;
+		}
+		dev_dbg(dev->dev, "%d.%s.alloc_dma.%d.name:%s.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+			__LINE__, __func__,
+			i, dbg_name, ctx->framebuf[i].size,
+			ctx->framebuf[i].paddr,
+			ctx->framebuf[i].vaddr);
+	}
+
+	return ret;
+}
+
+static void calc_src_buf_w_h(u32 src_buf_size,
+	u32 width, u32 hieght,
+	u32 *align_width, u32 *align_height)
+{
+	int align[4] = {16, 32, 64, 128};
+	int i = 0;
+
+	for (i = 0; i < 4; i++) {
+		*align_width = ALIGN(width, align[i]);
+		*align_height = ALIGN(hieght, align[i]);
+
+		if ((*align_width) * (*align_height) * 3 /2 == src_buf_size)
+			return;
+	}
+
+	*align_width = width;
+	*align_height = hieght;
+}
+
+static int enc_seq_init(struct rtkve1enc_ctx *ctx)
+{
+	u32 bitstream_buf, bitstream_size;
+	struct videc_dev *dev = ctx->dev;
+	//struct rtkve1_dev_info *ve1_devinfo = (struct rtkve1_dev_info *)dev->ve1_devinfo;
+	struct vb2_v4l2_buffer *src_buf = NULL;
+	u32 cbcrInterleave = 0;
+	u32 val;
+	int ret = 0;
+	int intr_reason = 0;
+	//u32 transform_8x8_mode = 1;
+	u32 chroma_format_400 = 0;
+	//u32 entropy_coding_mode = 1; /* 1 means CABAC */
+	//u32 field_flag = 0;
+	u32 streamEndflag = 0;
+	u32 rc_enable = 2;
+	u32 idr_interval = 1;
+	u32 slice_mode = 0;
+	u32 slice_size_mode = 0;
+	u32 slice_size = 0;
+	u32 rc_gop_I_qp_offset_en = 0;
+	u32 rc_gop_I_qp_offset = 0;
+	u32 frame_skip_disable = 1;
+	u32 initial_delay = 500;
+	u32 aud_enable = 0;
+	//u32 field_ref_mode = 0;
+	u32 user_qp_max = 0;
+	u32 user_gamma = 0;
+	u32 mb_interval = 0;
+	u32 rc_interval_mode = 0;
+	u32 intra_cost_weight = 0;
+
+	lockdep_assert_held(&dev->ve1_hw_mutex);
+
+	src_buf = v4l2_m2m_next_src_buf(ctx->v4l2_fh.m2m_ctx);
+	if (!src_buf) {
+		dev_err(dev->dev, "%d.%s.v4l2_m2m_next_src_buf() fail\n", __LINE__, __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	if (ctx->dst_fmt.pixelformat == V4L2_PIX_FMT_H264) {
+		ctx->codec_mode = AVC_ENC;
+	}
+
+	bitstream_buf = ctx->bitstream.paddr;
+	bitstream_size = ctx->bitstream.size;
+
+	dev_dbg(dev->dev, "%d.%s.s_ctrl_level_value:%d\n",
+		__LINE__, __func__,
+		ctx->enc_params.s_ctrl_level_value);
+	if (ctx->enc_params.s_ctrl_level_value == 0) {
+		ctx->enc_params.h264_level_idc = rtkve1_h264_calc_level(ctx->dst_fmt.width/16, ctx->dst_fmt.height/16, ctx->enc_params.framerate, ctx->enc_params.bitrate);
+		dev_dbg(ctx->dev->dev, "%d.%s.s_ctrl_level_value:%d.h264_level_idc:%d\n",
+			__LINE__, __func__,
+			ctx->enc_params.s_ctrl_level_value,
+			ctx->enc_params.h264_level_idc);
+	}
+	else {
+		ctx->enc_params.h264_level_idc = g_anLevel[ctx->enc_params.s_ctrl_level_value];
+		dev_dbg(ctx->dev->dev, "%d.%s.s_ctrl_level_value:%d.h264_level_idc:%d\n",
+			__LINE__, __func__,
+			ctx->enc_params.s_ctrl_level_value,
+			ctx->enc_params.h264_level_idc);
+	}
+
+	//rtkve1_reg_writel(dev, BIT_PARA_BUF_ADDR, (u32)ve1_devinfo->parabuf.paddr);
+
+	rtkve1_reg_writel(dev, CMD_ENC_SEQ_BB_START, bitstream_buf);
+	rtkve1_reg_writel(dev, CMD_ENC_SEQ_BB_SIZE, bitstream_size / 1024);
+
+	ctx->src_buf_size = vb2_get_plane_payload(&src_buf->vb2_buf, 0);
+	calc_src_buf_w_h(ctx->src_buf_size,
+		ctx->src_fmt.width, ctx->src_fmt.height,
+		&ctx->src_buf_width, &ctx->src_buf_height);
+	dev_dbg(dev->dev, "%d.%s.src_fmt(w:%d.h:%d).src_buf(w:%d.h:%d).src_buf_size:%d\n",
+		__LINE__, __func__,
+		ctx->src_fmt.width, ctx->src_fmt.height,
+		ctx->src_buf_width, ctx->src_buf_height,
+		ctx->src_buf_size);
+	val = (ctx->src_buf_width << 16) | ctx->src_buf_height;
+	rtkve1_reg_writel(dev, CMD_ENC_SEQ_SRC_SIZE, val);
+	// frame rate
+	rtkve1_reg_writel(dev, CMD_ENC_SEQ_SRC_F_RATE, ctx->enc_params.framerate);
+	/* profile, related to transform8x8Mode/chromaFormat400/entropyCodingMode/fieldFlag */
+	if ((ctx->enc_params.transform_8x8_mode == 1) || (chroma_format_400 == 1)) {
+		ctx->enc_params.h264_profile_idc = 2;
+	}
+	else if ((ctx->enc_params.entropy_coding_mode != 0) || (ctx->enc_params.field_flag == 1)) {
+		ctx->enc_params.h264_profile_idc = 1;
+	}
+	else {
+		ctx->enc_params.h264_profile_idc = 0;
+	}
+	val = ((ctx->enc_params.h264_profile_idc<<4) | 0x0);
+	dev_dbg(dev->dev, "%d.%s.h264_profile_idc:%d(transform_8x8_mode:%d.entropy_coding_mode:%d)\n",
+		__LINE__, __func__,
+		ctx->enc_params.h264_profile_idc,
+		ctx->enc_params.transform_8x8_mode,
+		ctx->enc_params.entropy_coding_mode);
+	rtkve1_reg_writel(dev, CMD_ENC_SEQ_COD_STD, val);
+	/* video Signal Type Present as 0 */
+	rtkve1_reg_writel(dev, CMD_ENC_SEQ_VIDEO_SIGNAL_TYPE_PRESENT, 0);
+	// H264 para, related to deblkFilterOffsetBeta/deblkFilterOffsetAlpha/disableDeblk/constrainedIntraPredFlag/chromaQpOffset
+	rtkve1_reg_writel(dev, CMD_ENC_SEQ_264_PARA, 0);
+	// ME, related to VPU_ME_LINEBUFFER_MODE/meBlkMode/MEUseZeroPmv/MESearchRangeY/MESearchRangeX
+	rtkve1_reg_writel(dev, CMD_ENC_SEQ_ME_OPTION, 0);
+	// slice mode, related to sliceMode/sliceSize/sliceSizeMode
+	val = 0;
+	if (slice_mode != 0) {
+		val = (slice_size << 2) | (slice_size_mode + 1);
+	}
+	rtkve1_reg_writel(dev, CMD_ENC_SEQ_SLICE_MODE, val);
+
+	if (rc_enable) {
+		val = (idr_interval << 21) | (rc_gop_I_qp_offset_en<<20) | ((rc_gop_I_qp_offset & 0xF)<<16) | ctx->enc_params.gop_size;
+		dev_dbg(dev->dev, "%d.%s.idr_interval:%d.gop_size:%d\n",
+			__LINE__, __func__,
+			idr_interval,
+			ctx->enc_params.gop_size);
+		rtkve1_reg_writel(dev, CMD_ENC_SEQ_GOP_NUM, val);
+
+		val = (frame_skip_disable << 31) | (initial_delay << 16) | 0;
+		dev_dbg(dev->dev, "%d.%s.frame_skip_disable:%d.initial_delay:%d\n",
+			__LINE__, __func__,
+			frame_skip_disable,
+			initial_delay);
+		rtkve1_reg_writel(dev, CMD_ENC_SEQ_RC_PARA, val);
+
+		if (rc_enable == 1) {
+			/* CBR */
+		}
+		else {
+			val = ((ctx->enc_params.bitrate/1024) << 4) | (rc_enable & 0xf);
+			dev_dbg(dev->dev, "%d.%s.bitrate:%d.rc_enable:%d\n",
+				__LINE__, __func__,
+				ctx->enc_params.bitrate,
+				rc_enable);
+			rtkve1_reg_writel(dev, CMD_ENC_SEQ_RC_PARA2, val);
+		}
+
+		rtkve1_reg_writel(dev, CMD_ENC_SEQ_RC_MAX_INTRA_SIZE, 0);
+		rtkve1_reg_writel(dev, CMD_ENC_SEQ_QP_RANGE_SET, 0);
+	}
+	else {
+		/* rate control - if rcEable == 0 begin */
+		val = (idr_interval << 21) | ctx->enc_params.gop_size;
+		dev_dbg(dev->dev, "%d.%s.idr_interval:%d.gop_size:%d\n",
+			__LINE__, __func__,
+			idr_interval,
+			ctx->enc_params.gop_size);
+		rtkve1_reg_writel(dev, CMD_ENC_SEQ_GOP_NUM, val);
+		rtkve1_reg_writel(dev, CMD_ENC_SEQ_RC_PARA, 0);
+		rtkve1_reg_writel(dev, CMD_ENC_SEQ_QP_RANGE_SET, 0);
+		rtkve1_reg_writel(dev, CMD_ENC_SEQ_RC_PARA2, 0);
+		/* rate control - if rcEable == 0 end */
+	}
+
+	// RC buffer size
+	rtkve1_reg_writel(dev, CMD_ENC_SEQ_RC_BUF_SIZE, 0);
+	// intra refresh, related to intraRefresh/ConscIntraRefreshEnable/CountIntraMbEnable/FieldSeqIntraRefreshEnable
+	rtkve1_reg_writel(dev, CMD_ENC_SEQ_INTRA_REFRESH, 0);
+
+	// intra QP, rcIntraQp
+	val = 0;
+	dev_dbg(dev->dev, "%d.%s.intra_qp:%d\n",
+		__LINE__, __func__,
+		ctx->enc_params.intra_qp);
+	if (ctx->enc_params.intra_qp >= 0) {
+		val = (1 << 5);
+		rtkve1_reg_writel(dev, CMD_ENC_SEQ_INTRA_QP, ctx->enc_params.intra_qp);
+	}
+	else {
+		rtkve1_reg_writel(dev, CMD_ENC_SEQ_INTRA_QP, 0xffffffff);
+	}
+	// QP max, related to rcIntraQp/audEnable/fieldFlag/fieldRefMode/userQpMax
+	val |= (aud_enable << 2);
+	val |= (ctx->enc_params.field_flag << 10);
+	val |= (ctx->enc_params.field_ref_mode << 11);
+	dev_dbg(dev->dev, "%d.%s.aud_enable:%d.field_flag:%d.field_ref_mode:%d\n",
+		__LINE__, __func__,
+		aud_enable,
+		ctx->enc_params.field_flag,
+		ctx->enc_params.field_ref_mode);
+	dev_dbg(dev->dev, "%d.%s.user_qp_max:%d.user_gamma:%d\n",
+		__LINE__, __func__,
+		user_qp_max,
+		user_gamma);
+	if (user_qp_max >= 0) {
+		val |= (1 << 6);
+		rtkve1_reg_writel(dev, CMD_ENC_SEQ_RC_QP_MAX, user_qp_max);
+	}
+	else {
+		rtkve1_reg_writel(dev, CMD_ENC_SEQ_RC_QP_MAX, 0);
+	}
+	// gamma, userGamma
+	if (user_gamma >= 0) {
+		val |= (1 << 7);
+		rtkve1_reg_writel(dev, CMD_ENC_SEQ_RC_GAMMA, user_gamma);
+	}
+	else {
+		rtkve1_reg_writel(dev, CMD_ENC_SEQ_RC_GAMMA, 0);
+	}
+	// option, related to rcIntraQp/audEnable/fieldFlag/fieldRefMode/userQpMax/userGamma
+	rtkve1_reg_writel(dev, CMD_ENC_SEQ_OPTION, val);
+	// interval mode, related to mbInterval/rcIntervalMode
+	val = (mb_interval << 2) | rc_interval_mode;
+	dev_dbg(dev->dev, "%d.%s.mb_interval:%d.rc_interval_mode:%d\n",
+		__LINE__, __func__,
+		mb_interval,
+		rc_interval_mode);
+	rtkve1_reg_writel(dev, CMD_ENC_SEQ_RC_INTERVAL_MODE, val);
+	// intra weight, intraCostWeight
+	dev_dbg(dev->dev, "%d.%s.intra_cost_weight:%d\n",
+		__LINE__, __func__,
+		intra_cost_weight);
+	rtkve1_reg_writel(dev, CMD_ENC_SEQ_INTRA_WEIGHT, intra_cost_weight);
+	
+	ctx->wrPtr = bitstream_buf;
+	ctx->rdPtr = bitstream_buf;
+	rtkve1_reg_writel(dev, BIT_WR_PTR, ctx->wrPtr);
+	rtkve1_reg_writel(dev, BIT_RD_PTR, ctx->rdPtr);
+
+	/* frame mem ctrl, related to bwbEnable/linear2TiledMode/mapType/chromaFormat400/cbcrInterleave/frameEndian */
+	switch (ctx->src_fmt.pixelformat) {
+		case V4L2_PIX_FMT_NV12:
+			cbcrInterleave = 1;
+			break;
+		case V4L2_PIX_FMT_NV21:
+			cbcrInterleave = 1;
+			break;
+		default:
+			break;
+	}
+	val = (VE1_BWB_ENABLE<<15) | (cbcrInterleave<<2) | VPU_FRAME_ENDIAN;
+	rtkve1_reg_writel(dev, BIT_FRAME_MEM_CTRL, val);
+	/* stream ctrl, related to lineBufIntEn/streamEndian */
+	rtkve1_reg_writel(dev, BIT_BIT_STREAM_CTRL, 0x30);
+
+	/* issue command */
+	rtkve1_issue_command(ctx, ENC_SEQ_INIT);
+
+	/* wait interrupt */
+	intr_reason = rtkve1_wait_interrupt(ctx, RTKVE1_ENC_TIMEOUT);
+	if (intr_reason < 0) {
+		dev_err(dev->dev, "%d.%s.rtkve1_wait_interrupt() fail\n",
+			__LINE__, __func__);
+		return intr_reason;
+	}
+	dev_dbg(dev->dev, "%d.%s.intr_reason:0x%x\n",
+		__LINE__, __func__, intr_reason);
+	rtkve1_clear_interrupt(ctx);
+
+	// get result
+	ret = rtkve1_reg_readl(dev, RET_ENC_SEQ_END_SUCCESS);
+	dev_dbg(dev->dev, "%d.%s.r_reg RET_ENC_SEQ_END_SUCCESS(0x%X):0x%x\n", __LINE__, __func__,
+		RET_ENC_SEQ_END_SUCCESS, ret);
+	if (!ret) {
+		dev_err(dev->dev, "%d.%s.RET_ENC_SEQ_END_SUCCESS fail \n",
+			__LINE__, __func__);
+		return ret;
+	}
+	if (ret & (1 << 31)) {
+		dev_err(dev->dev, "%d.%s.memory access violation\n",
+			__LINE__, __func__);
+		return ret;
+	}
+
+	ctx->wrPtr = rtkve1_reg_readl(dev, BIT_WR_PTR);
+	dev_dbg(dev->dev, "%d.%s.r_reg BIT_WR_PTR(0x%X):0x%x\n", __LINE__, __func__,
+		BIT_WR_PTR, ctx->wrPtr);
+
+	streamEndflag = rtkve1_reg_readl(dev, BIT_BIT_STREAM_PARAM);
+	dev_dbg(dev->dev, "%d.%s.r_reg BIT_BIT_STREAM_PARAM(0x%X):0x%x\n", __LINE__, __func__,
+		BIT_BIT_STREAM_PARAM, streamEndflag);
+
+	ctx->enc_min_fb_num = 2; // reconstructed frame + reference frame
+	dev_dbg(dev->dev, "%d.%s.enc_min_fb_num:%d\n", __LINE__, __func__, ctx->enc_min_fb_num);
+	ctx->seq_init_done = 1;
+
+	return ret;
+}
+
+static int enc_reg_fbs(struct rtkve1enc_ctx *ctx)
+{
+	int ret = 0;
+	struct videc_dev *dev = ctx->dev;
+	struct rtkve1_dev_info* ve1_devinfo = (struct rtkve1_dev_info*)ctx->dev->ve1_devinfo;
+	int i = 0;
+	u32 y=0, cb=0, cr=0;
+	u32 ysize = 0;
+	u32 cbcrInterleave = 0;
+	u32 val;
+	//unsigned char *p;
+
+	lockdep_assert_held(&dev->ve1_hw_mutex);
+
+	// frame mem ctrl, related to bwbEnable/linear2TiledMode/mapType/chromaFormat400/cbcrInterleave/frameEndian
+	switch (ctx->src_fmt.pixelformat) {
+		case V4L2_PIX_FMT_NV12:
+			cbcrInterleave = 1;
+			break;
+		case V4L2_PIX_FMT_NV21:
+			cbcrInterleave = 1;
+			break;
+		default:
+			break;
+	}
+	val = (VE1_BWB_ENABLE<<15) | (cbcrInterleave<<2) | VPU_FRAME_ENDIAN;
+	rtkve1_reg_writel(dev, BIT_FRAME_MEM_CTRL, val);
+
+#if 1
+	// write frame buffer address (bufY/bufCb/bufCr) to param buffer
+	ysize = ctx->src_buf_width * ctx->src_buf_height;
+	for (i = 0; i < ctx->enc_min_fb_num; i++) {
+		y = ctx->framebuf[i].paddr;
+		cb = y + ysize;
+		cr = y + ysize + ysize/4;
+		if (cbcrInterleave) {
+			cr = 0xffffffff;
+		}
+		dev_dbg(dev->dev, "%d.%s.%d.y:0x%x.cb:0x%x.cr:0x%x\n",
+			__LINE__, __func__,
+			i, y, cb, cr);
+		ctx->frame_addr[i][0][0] = (y >> 24) & 0xFF;
+		ctx->frame_addr[i][0][1] = (y >> 16) & 0xFF;
+		ctx->frame_addr[i][0][2] = (y >> 8) & 0xFF;
+		ctx->frame_addr[i][0][3] = (y >> 0) & 0xFF;
+
+		ctx->frame_addr[i][1][0] = (cb >> 24) & 0xFF;
+		ctx->frame_addr[i][1][1] = (cb >> 16) & 0xFF;
+		ctx->frame_addr[i][1][2] = (cb >> 8) & 0xFF;
+		ctx->frame_addr[i][1][3] = (cb >> 0) & 0xFF;
+
+		ctx->frame_addr[i][2][0] = (cr >> 24) & 0xFF;
+		ctx->frame_addr[i][2][1] = (cr >> 16) & 0xFF;
+		ctx->frame_addr[i][2][2] = (cr >> 8) & 0xFF;
+		ctx->frame_addr[i][2][3] = (cr >> 0) & 0xFF;
+	}
+	ret = rtkve1_write_memory(dev,
+			ve1_devinfo->parabuf.vaddr, ve1_devinfo->parabuf.size,
+			0,
+			(u8 *)ctx->frame_addr,
+			sizeof(ctx->frame_addr),
+			VDI_BIG_ENDIAN);
+	if (ret <= 0) {
+		dev_err(dev->dev, "%d.%s.rtkve1_write_memory buf_y fail\n",
+			__LINE__, __func__);
+		return ret;
+	}
+
+	for (i = 0; i < ctx->enc_min_fb_num; i++) {
+		ctx->frame_addr[i][0][0] = 0;
+		ctx->frame_addr[i][0][1] = 0;
+		ctx->frame_addr[i][0][2] = 0;
+		ctx->frame_addr[i][0][3] = 0;
+
+		ctx->frame_addr[i][1][0] = 0;
+		ctx->frame_addr[i][1][1] = 0;
+		ctx->frame_addr[i][1][2] = 0;
+		ctx->frame_addr[i][1][3] = 0;
+
+		ctx->frame_addr[i][2][0] = 0;
+		ctx->frame_addr[i][2][1] = 0;
+		ctx->frame_addr[i][2][2] = 0;
+		ctx->frame_addr[i][2][3] = 0;
+	}
+	ret = rtkve1_write_memory(dev,
+		ve1_devinfo->parabuf.vaddr, ve1_devinfo->parabuf.size,
+		384 + 128,
+		(u8 *)ctx->frame_addr,
+		sizeof(ctx->frame_addr),
+		VDI_BIG_ENDIAN);
+	if (ret <= 0) {
+		dev_err(dev->dev, "%d.%s.rtkve1_write_memory buf_y_bot fail\n",
+			__LINE__, __func__);
+		return ret;
+	}
+#else
+	// write frame buffer address (bufY/bufCb/bufCr) to param buffer
+	ysize = ctx->src_buf_width * ctx->src_buf_height;
+	for (i=0; i < ctx->enc_min_fb_num; i++) {
+		y = ctx->framebuf[i].paddr;
+		cb = y + ysize;
+		cr = y + ysize + ysize/4;
+		if (cbcrInterleave) {
+			cr = 0xffffffff;
+		}
+		dev_dbg(dev->dev, "%d.%s.%d.y:0x%x.cb:0x%x.cr:0x%x\n",
+			__LINE__, __func__,
+			i, y, cb, cr);
+		rtkve1_parabuf_write(ctx, i * 3 + 0, y);
+		rtkve1_parabuf_write(ctx, i * 3 + 1, cb);
+		rtkve1_parabuf_write(ctx, i * 3 + 2, cr);
+	}
+	//p = ve1_devinfo->parabuf.vaddr;
+	for (i=0; i < ctx->enc_min_fb_num; i++) {
+		p = (unsigned char *)ve1_devinfo->parabuf.vaddr + i*12;
+		dev_dbg(dev->dev, "%d.%s.%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+			__LINE__, __func__,
+			p[0], p[1], p[2], p[3], p[4], p[5],
+			p[6], p[7], p[8], p[9], p[10], p[11]);
+	}
+
+	// write frame buffer address (bufYBot/bufCbBot/bufCrBot)(hardcode 0) to (param buffer + 384 + 128)
+	for (i=0; i < ctx->enc_min_fb_num; i++) {
+		rtkve1_parabuf_write(ctx, 128 + i * 3 + 0, 0); // bufYBot
+		rtkve1_parabuf_write(ctx, 128 + i * 3 + 1, 0); // bufCbBot
+		rtkve1_parabuf_write(ctx, 128 + i * 3 + 2, 0); // bufCrBot
+	}
+	for (i=0; i < ctx->enc_min_fb_num; i++) {
+		p = (unsigned char *)ve1_devinfo->parabuf.vaddr + 384 + 128 + i*12;
+		dev_dbg(dev->dev, "%d.%s.%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+			__LINE__, __func__,
+			p[0], p[1], p[2], p[3], p[4], p[5],
+			p[6], p[7], p[8], p[9], p[10], p[11]);
+	}
+#endif
+
+	// frame buffer number
+	rtkve1_reg_writel(dev, CMD_SET_FRAME_BUF_NUM, ctx->enc_min_fb_num);
+	rtkve1_reg_writel(dev, CMD_SET_FRAME_BUF_STRIDE, ctx->src_buf_width);
+
+	/* AXI */
+	rtkve1_reg_writel(dev, CMD_SET_FRAME_AXI_BIT_ADDR, 0);
+	rtkve1_reg_writel(dev, CMD_SET_FRAME_AXI_IPACDC_ADDR, 0);
+	rtkve1_reg_writel(dev, CMD_SET_FRAME_AXI_DBKY_ADDR, 0);
+	rtkve1_reg_writel(dev, CMD_SET_FRAME_AXI_DBKC_ADDR, 0);
+	rtkve1_reg_writel(dev, CMD_SET_FRAME_AXI_OVL_ADDR, 0);
+
+	// frame cache config, related to CacheMode
+	rtkve1_reg_writel(dev, CMD_SET_FRAME_CACHE_CONFIG, 0x7e0);
+
+
+	/* issue command */
+	rtkve1_issue_command(ctx, SET_FRAME_BUF);
+
+	/* wait busy flag */
+	ret = rtkve1_wait_busy(dev, BIT_BUSY_FLAG);
+	if (ret) {
+		dev_err(dev->dev,
+			"%d.%s.wait_timeout.BIT_BUSY_FLAG.ret:%d\n",
+            __LINE__, __func__,
+			ret);
+		return -ETIMEDOUT;
+	}
+
+	// get result
+	ret = rtkve1_reg_readl(dev, RET_SET_FRAME_SUCCESS);
+	dev_dbg(dev->dev, "%d.%s.r_reg RET_SET_FRAME_SUCCESS(0x%X):0x%x\n",
+		__LINE__, __func__,
+		RET_SET_FRAME_SUCCESS, ret);
+	if (!ret) {
+		dev_err(dev->dev, "%d.%s.RET_SET_FRAME_SUCCESS fail \n",
+			__LINE__, __func__);
+		return -1;
+	}
+	if (ret & (1 << 31)) {
+		dev_err(dev->dev, "%d.%s.memory access violation\n",
+			__LINE__, __func__);
+		return -1;
+	}
+
+	ctx->reg_fbs_done = 1;
+
+	return ret;
+}
+
+static int enc_save_hdr(struct rtkve1enc_ctx *ctx, void *hdr_buf, int hdr_bytes, int append)
+{
+	struct videc_dev *dev = ctx->dev;
+	void *tmp_buf = NULL;
+	u32 hdr_buf_size = 0;
+
+	if ((append == 0) && (ctx->enc_hdr_buf != NULL)) {
+		vfree((void *)ctx->enc_hdr_buf);
+		ctx->enc_hdr_buf = NULL;
+		ctx->enc_hdr_buf_size = 0;
+		ctx->enc_hdr_bytes = 0;
+	}
+
+	if (append == 0) {
+		hdr_buf_size = (hdr_bytes<=RTKVE1_ENC_HEADER_TEMP_BUF_SIZE)?RTKVE1_ENC_HEADER_TEMP_BUF_SIZE:(hdr_bytes+RTKVE1_ENC_HEADER_TEMP_BUF_SIZE);
+		tmp_buf = (unsigned char *)vmalloc(hdr_buf_size);
+		if (!tmp_buf) {
+			dev_err(dev->dev, "%d.%s.vmalloc() fail\n",
+				__LINE__, __func__);
+			return -ENOMEM;
+		}
+		memcpy(tmp_buf, hdr_buf, hdr_bytes);
+		ctx->enc_hdr_buf = tmp_buf;
+		ctx->enc_hdr_buf_size = hdr_buf_size;
+		ctx->enc_hdr_bytes = hdr_bytes;
+	}
+	else if (append == 1)
+	{
+		if ((hdr_bytes + ctx->enc_hdr_bytes) > ctx->enc_hdr_buf_size) {
+			hdr_buf_size = hdr_bytes + ctx->enc_hdr_bytes;
+			tmp_buf = (unsigned char *)vmalloc(hdr_buf_size);
+			if (!tmp_buf) {
+				dev_err(dev->dev, "%d.%s.vmalloc() fail\n",
+					__LINE__, __func__);
+				return -ENOMEM;
+			}
+			memcpy(tmp_buf, ctx->enc_hdr_buf, ctx->enc_hdr_bytes);
+			memcpy(((unsigned char *)tmp_buf+ctx->enc_hdr_bytes), hdr_buf, hdr_bytes);
+
+			vfree((void *)ctx->enc_hdr_buf);
+			ctx->enc_hdr_buf = tmp_buf;
+			ctx->enc_hdr_buf_size = hdr_buf_size;
+			ctx->enc_hdr_bytes += hdr_bytes;
+		}
+		else {
+			memcpy(((unsigned char *)ctx->enc_hdr_buf+ctx->enc_hdr_bytes), hdr_buf, hdr_bytes);
+			ctx->enc_hdr_bytes += hdr_bytes;
+		}
+	}
+
+	return 0;
+}
+
+static int enc_header(struct rtkve1enc_ctx *ctx)
+{
+	int ret = 0;
+	struct videc_dev *dev = ctx->dev;
+	u32 header_code = 0;
+	u32 crop_flag = 0;
+	u32 sps_ID = 0;
+	u32 pps_ID = 0;
+	u32 zero_padding = 0;
+	u32 enc_sps_size = 0;
+	u32 enc_pps_size = 0;
+	unsigned char *p = NULL;
+	u32 crop_left=0, crop_right=0, crop_top=0, crop_bottom=0;
+	u32 crop_h=0, crop_v=0;
+
+	/* encode SPS begin */
+	/* stream ctrl, related to lineBufIntEn/streamEndian */
+	rtkve1_reg_writel(dev, BIT_BIT_STREAM_CTRL, 0x30);
+	/* if ringBufferEnable == 0 */
+	rtkve1_reg_writel(dev, CMD_ENC_HEADER_BB_START, (u32)(ctx->bitstream.paddr));
+	rtkve1_reg_writel(dev, CMD_ENC_HEADER_BB_SIZE, (u32)(ctx->bitstream.size) / 1024);
+	/* profile */
+	rtkve1_reg_writel(dev, CMD_ENC_HEADER_PROFILE, ctx->enc_params.h264_profile_idc);
+	/* chroma format, related to chromaFormat400 */
+	rtkve1_reg_writel(dev, CMD_ENC_HEADER_CHROMA_FORMAT, 0);
+	/* field flag, related to fieldRefMode/fieldFlag */
+	rtkve1_reg_writel(dev, CMD_ENC_HEADER_FIELD_FLAG, ((ctx->enc_params.field_ref_mode<<1)|ctx->enc_params.field_flag));
+
+	if ((ctx->dst_fmt.width != ctx->src_buf_width) || (ctx->dst_fmt.height != ctx->src_buf_height)) {
+		if ((ctx->src_buf_width >= ctx->dst_fmt.width) && (ctx->src_buf_height >= ctx->dst_fmt.height)) {
+			crop_left = 0;
+			crop_right = ctx->src_buf_width - ctx->dst_fmt.width;
+			crop_top = 0;
+			crop_bottom = ctx->src_buf_height - ctx->dst_fmt.height;
+			crop_h = crop_left << 16;
+			crop_h |= crop_right;
+			crop_v = crop_top << 16;
+			crop_v |= crop_bottom;
+			crop_flag = 1;
+			dev_dbg(dev->dev, "%d.%s.crop(%d,%d,%d,%d).crop_h:0x%x.crop_v:0x%x\n",
+				__LINE__, __func__,
+				crop_left, crop_right,
+				crop_top, crop_bottom,
+				crop_h, crop_v);
+			rtkve1_reg_writel(dev, CMD_ENC_HEADER_FRAME_CROP_H, crop_h);
+			rtkve1_reg_writel(dev, CMD_ENC_HEADER_FRAME_CROP_V, crop_v);
+		}
+	}
+
+	/* header code, related to headerType/crop_flag/level/spsID/zeroPaddingEnable */
+	dev_dbg(dev->dev, "%d.%s.headerType:%d.crop_flag:%d.h264_level_idc:%d.sps_ID:%d\n",
+		__LINE__, __func__,
+		HEADER_H264_SPS,
+		crop_flag,
+		ctx->enc_params.h264_level_idc,
+		sps_ID);
+	header_code = HEADER_H264_SPS | (crop_flag<<2);
+	header_code |= ctx->enc_params.h264_level_idc<<8;
+	header_code |= (sps_ID << 24);
+	header_code |= (zero_padding&1) << 31;
+	rtkve1_reg_writel(dev, CMD_ENC_HEADER_CODE, header_code);
+
+	/* rdPtr, wrPtr */
+	ctx->rdPtr = (u32)(ctx->bitstream.paddr);
+	ctx->wrPtr = (u32)(ctx->bitstream.paddr);
+	rtkve1_reg_writel(dev, BIT_RD_PTR, ctx->rdPtr);
+	rtkve1_reg_writel(dev, BIT_WR_PTR, ctx->wrPtr);
+
+	/* issue command */
+	rtkve1_issue_command(ctx, ENCODE_HEADER);
+
+	/* wait busy flag */
+	ret = rtkve1_wait_busy(dev, BIT_BUSY_FLAG);
+	if (ret) {
+		dev_err(dev->dev,
+			"%d.%s.wait_timeout.BIT_BUSY_FLAG.ret:%d\n",
+            __LINE__, __func__,
+			ret);
+		return -ETIMEDOUT;
+	}
+
+	/* get result */
+	ctx->wrPtr = rtkve1_reg_readl(dev, BIT_WR_PTR);
+	dev_dbg(dev->dev, "%d.%s.r_reg BIT_WR_PTR(0x%X):0x%x\n",
+		__LINE__, __func__,
+		BIT_WR_PTR, ctx->wrPtr);
+	enc_sps_size = ctx->wrPtr - (u32)(ctx->bitstream.paddr);
+	dev_dbg(dev->dev, "%d.%s.enc_sps_size:%d\n",
+		__LINE__, __func__,
+		enc_sps_size);
+	p = (unsigned char *)(ctx->bitstream.vaddr);
+	dev_dbg(dev->dev, "%d.%s.sps:%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+		__LINE__, __func__,
+		p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+		p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+	//ctx->enc_bs_new_file = 1;
+	//enc_dump_bs(ctx, p, enc_sps_size);
+	enc_save_hdr(ctx, ctx->bitstream.vaddr, enc_sps_size, 0);
+	/* encode SPS end */
+
+	/* encode PPS begin */
+	/* stream ctrl, related to lineBufIntEn/streamEndian */
+	rtkve1_reg_writel(dev, BIT_BIT_STREAM_CTRL, 0x30);
+	/* if ringBufferEnable == 0 */
+	rtkve1_reg_writel(dev, CMD_ENC_HEADER_BB_START, (u32)(ctx->bitstream.paddr));
+	rtkve1_reg_writel(dev, CMD_ENC_HEADER_BB_SIZE, (u32)(ctx->bitstream.size) / 1024);
+
+	if (ctx->enc_params.entropy_coding_mode != 2) {
+		/* if PPS, if entropyCodingMode != 2 (CAVLC/CABAC select according to PicType) */
+		rtkve1_reg_writel(dev, CMD_ENC_HEADER_CABAC_MODE, ctx->enc_params.entropy_coding_mode);
+		/* if PPS, if entropyCodingMode != 2 (CAVLC/CABAC select according to PicType), related to cabacInitIdc */
+		rtkve1_reg_writel(dev, CMD_ENC_HEADER_CABAC_INIT_IDC, 0);
+		/* if PPS, if entropyCodingMode != 2 (CAVLC/CABAC select according to PicType), related to transform8x8Mode */
+		rtkve1_reg_writel(dev, CMD_ENC_HEADER_TRANSFORM_8X8, ctx->enc_params.transform_8x8_mode);
+	}
+
+	/* header code, related to headerType/crop_flag/level/spsID/zeroPaddingEnable */
+	dev_dbg(dev->dev, "%d.%s.headerType:%d.crop_flag:%d.h264_level_idc:%d.sps_ID:%d.pps_ID:%d\n",
+		__LINE__, __func__,
+		HEADER_H264_PPS,
+		crop_flag,
+		ctx->enc_params.h264_level_idc,
+		sps_ID, pps_ID);
+	header_code = 0;
+	header_code = HEADER_H264_PPS | (crop_flag<<2);
+	header_code |= ctx->enc_params.h264_level_idc<<8;
+	header_code |= (sps_ID << 24);
+	header_code |= (pps_ID << 16);
+	header_code |= (zero_padding&1) << 31;
+	rtkve1_reg_writel(dev, CMD_ENC_HEADER_CODE, header_code);
+
+	ctx->rdPtr = (u32)(ctx->bitstream.paddr);
+	rtkve1_reg_writel(dev, BIT_RD_PTR, ctx->rdPtr);
+	rtkve1_reg_writel(dev, BIT_WR_PTR, ctx->wrPtr);
+
+	/* issue command */
+	rtkve1_issue_command(ctx, ENCODE_HEADER);
+
+	/* wait busy flag */
+	ret = rtkve1_wait_busy(dev, BIT_BUSY_FLAG);
+	if (ret) {
+		dev_err(dev->dev,
+			"%d.%s.wait_timeout.BIT_BUSY_FLAG.ret:%d\n",
+            __LINE__, __func__,
+			ret);
+		return -ETIMEDOUT;
+	}
+
+	/* get result */
+	ctx->wrPtr = rtkve1_reg_readl(dev, BIT_WR_PTR);
+	dev_dbg(dev->dev, "%d.%s.r_reg BIT_WR_PTR(0x%X):0x%x\n",
+		__LINE__, __func__,
+		BIT_WR_PTR, ctx->wrPtr);
+	enc_pps_size = ctx->wrPtr - (u32)(ctx->bitstream.paddr);
+	dev_dbg(dev->dev, "%d.%s.enc_pps_size:%d\n",
+		__LINE__, __func__,
+		enc_pps_size);
+	p = (unsigned char *)(ctx->bitstream.vaddr);
+	dev_dbg(dev->dev, "%d.%s.pps:%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+		__LINE__, __func__,
+		p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+		p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+	//enc_dump_bs(ctx, p, enc_pps_size);
+	enc_save_hdr(ctx, ctx->bitstream.vaddr, enc_pps_size, 1);
+	/* encode PPS end */
+
+	dev_dbg(dev->dev, "%d.%s.enc_hdr_bytes:%d\n",
+		__LINE__, __func__,
+		ctx->enc_hdr_bytes);
+	p = (unsigned char *)ctx->enc_hdr_buf;
+	while (p < ((unsigned char *)ctx->enc_hdr_buf + ctx->enc_hdr_bytes)) {
+		dev_dbg(dev->dev, "%d.%s.hdr_buf:%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+			__LINE__, __func__,
+			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
+			p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+		p += 16;
+	}
+
+	ctx->enc_header_done = 1;
+
+	return ret;
+}
+
+static int enc_copy_hdr(struct rtkve1enc_ctx *ctx, void *cap_buf, int cap_buf_size, int frm_bytes)
+{
+	int ret = 0;
+	struct videc_dev *dev = ctx->dev;
+	void *tmp_buf = NULL;
+
+	if ((frm_bytes + ctx->enc_hdr_bytes) > cap_buf_size) {
+		dev_err(dev->dev, "[%d]%s.no space for copy hdr to cap buf\n",
+			__LINE__, __func__);
+		return -EINVAL;
+	}
+	if ((ctx->enc_hdr_bytes == 0) || (ctx->enc_hdr_buf_size == 0)
+		|| (ctx->enc_hdr_buf == NULL)) {
+		dev_err(dev->dev, "[%d]%s.hdr buf is empty\n",
+			__LINE__, __func__);
+		return -EINVAL;
+	}
+
+	tmp_buf = (unsigned char *)vmalloc(frm_bytes);
+	if (!tmp_buf) {
+		dev_err(dev->dev, "[%d]%s.vmalloc() fail\n",
+			__LINE__, __func__);
+		return -ENOMEM;
+	}
+
+	memcpy(tmp_buf, cap_buf, frm_bytes);
+	memcpy(cap_buf, ctx->enc_hdr_buf, ctx->enc_hdr_bytes);
+	memcpy(((unsigned char *)cap_buf+ctx->enc_hdr_bytes), tmp_buf, frm_bytes);
+
+	vfree(tmp_buf);
+	tmp_buf = NULL;
+
+	return ret;
+}
+
+static int enc_pic(struct rtkve1enc_ctx *ctx)
+{
+	int ret = 0;
+	struct vb2_v4l2_buffer *src_buf = NULL;
+	struct vb2_v4l2_buffer *dst_buf = NULL;
+	unsigned char *p = NULL;
+	u32 offset = 0;
+	u32 len = 0;
+	u32 cbcrInterleave = 0;
+	u32 nv21 = 0;
+	u32 rot_mode = 0;
+	dma_addr_t src_buf_y=0, src_buf_cb=0, src_buf_cr=0;
+	dma_addr_t dst_buf_paddr = 0;
+	u32 dst_buf_size = 0;
+	u32 dst_buf_payload = 0;
+	void *dst_buf_vaddr = NULL;
+	struct videc_dev *dev = ctx->dev;
+	u32 src_buf_index = 0;
+	u32 is_idr = 0;
+	u32 value = 0;
+	u32 frm_idx, pic_type, enc_frm_bs_bytes, num_of_slices, pic_flag, src_idx;
+	//u32 i = 0;
+	int intr_reason = 0;
+	int intr_timeout_count = 0;
+
+	ctx->enc_pic_done = 0;
+
+	src_buf = v4l2_m2m_next_src_buf(ctx->v4l2_fh.m2m_ctx);
+	if (!src_buf) {
+		dev_err(dev->dev, "%d.%s.v4l2_m2m_next_src_buf() fail\n", __LINE__, __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	dst_buf = v4l2_m2m_next_dst_buf(ctx->v4l2_fh.m2m_ctx);
+	if (!dst_buf) {
+		dev_err(dev->dev, "%d.%s.v4l2_m2m_next_dst_buf() fail\n", __LINE__, __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	//dev_dbg(dev->dev, "%d.%s.msleep 100ms\n",
+	//	__LINE__, __func__);
+	//msleep(100);
+
+	dev_dbg(dev->dev, "%d.%s.src_buf:0x%px.index:%d.sequence:%d.key frame sequence:%d\n",
+		__LINE__, __func__,
+		src_buf, src_buf->vb2_buf.index,
+		src_buf->sequence, ctx->srcbuf_sequence_of_key_frm);
+	dev_dbg(dev->dev, "%d.%s.dst_buf:0x%px.index:%d.sequence:%d\n",
+		__LINE__, __func__,
+		dst_buf, dst_buf->vb2_buf.index,
+		dst_buf->sequence);
+
+	p = (unsigned char *)vb2_plane_vaddr(&src_buf->vb2_buf, 0);
+	len = src_buf->vb2_buf.planes[0].bytesused;
+	offset = src_buf->vb2_buf.planes[0].data_offset;
+	//dev_dbg(dev->dev, "%d.%s.src_buf.p:0x%px.len:%d.offset:%d\n",
+	//	__LINE__, __func__,
+	//	p, len, offset);
+
+	if (src_buf->sequence == 0) {
+		ctx->outbuf_new_file = 1;
+	}
+	if (src_buf->sequence == 0) {
+	dump_outbuf(ctx, p, offset, len);
+	}
+	//rtkve1_md5_hash(md5, VE1_MD5_SIZE,
+	//	(char *)p, len);
+	//dev_dbg(dev->dev, "yuv hash: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
+	//	md5[0], md5[1], md5[2], md5[3], md5[4],
+	//	md5[5], md5[6], md5[7], md5[8], md5[9],
+	//	md5[10], md5[11], md5[12], md5[13], md5[14],
+	//	md5[15]);
+
+	switch (ctx->src_fmt.pixelformat) {
+		case V4L2_PIX_FMT_NV12:
+			cbcrInterleave = 1;
+			nv21 = 0;
+			break;
+		case V4L2_PIX_FMT_NV21:
+			cbcrInterleave = 1;
+			nv21 = 1;
+			break;
+		default:
+			break;
+	}
+
+	src_buf_y = vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0) +
+		src_buf->vb2_buf.planes[0].data_offset;
+	src_buf_cb = src_buf_y + ctx->src_buf_width * ctx->src_buf_height;
+	src_buf_cr = src_buf_cb + (ctx->src_buf_width * ctx->src_buf_height / 4);
+	if (cbcrInterleave) {
+		src_buf_cr = 0xffffffff;
+	}
+	//dev_dbg(dev->dev, "%d.%s.src_buf_y:%pad.src_buf_cb:%pad.src_buf_cr:%pad\n",
+	//	__LINE__, __func__,
+	//	&src_buf_y, &src_buf_cb, &src_buf_cr);
+	dev_dbg(dev->dev, "%d.%s.src_buf_y:0x%llx.src_buf_cb:0x%llx.src_buf_cr:0x%llx\n",
+		__LINE__, __func__,
+		src_buf_y, src_buf_cb, src_buf_cr);
+
+	dst_buf_paddr = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0) +
+		dst_buf->vb2_buf.planes[0].data_offset;
+	dst_buf_size = vb2_plane_size(&dst_buf->vb2_buf, 0);
+	dst_buf_vaddr = vb2_plane_vaddr(&dst_buf->vb2_buf, 0);
+	//dev_dbg(dev->dev, "%d.%s.dst_buf_paddr:%pad.dst_buf_size:%d.dst_buf_vaddr:%px\n",
+	//	__LINE__, __func__,
+	//	&dst_buf_paddr, dst_buf_size, dst_buf_vaddr);
+	dev_dbg(dev->dev, "%d.%s.dst_buf_paddr:0x%llx.dst_buf_size:%d.dst_buf_vaddr:%px\n",
+		__LINE__, __func__,
+		dst_buf_paddr, dst_buf_size, dst_buf_vaddr);
+
+
+	/* endian/cbcrInterleave/sourceLBurstEn */
+	rot_mode = (cbcrInterleave&0x01) << 18;
+	rot_mode |= nv21 << 21;
+	rtkve1_reg_writel(dev, CMD_ENC_PIC_ROT_MODE, rot_mode);
+	/* quantParam */
+	rtkve1_reg_writel(dev, CMD_ENC_PIC_QS, 0xa);
+
+	/* The index number set to CMD_ENC_PIC_SRC_INDEX must be larger than
+	the number set to CMD_SET_FRAME_BUF_NUM to avoid reconstruction frame buffer area. */
+	src_buf_index = src_buf->vb2_buf.index + ctx->enc_min_fb_num;
+	dev_dbg(dev->dev, "%d.%s.src_buf_index:%d\n",
+		__LINE__, __func__,
+		src_buf_index);
+	rtkve1_reg_writel(dev, CMD_ENC_PIC_SRC_INDEX, src_buf_index);
+
+	rtkve1_reg_writel(dev, CMD_ENC_PIC_SRC_STRIDE, ctx->src_buf_width);
+
+	rtkve1_reg_writel(dev, CMD_ENC_PIC_SRC_ADDR_Y, (u32)src_buf_y);
+	rtkve1_reg_writel(dev, CMD_ENC_PIC_SRC_ADDR_CB, (u32)src_buf_cb);
+	rtkve1_reg_writel(dev, CMD_ENC_PIC_SRC_ADDR_CR, (u32)src_buf_cr);
+	rtkve1_reg_writel(dev, CMD_ENC_PIC_SRC_BOTTOM_Y, 0);
+	rtkve1_reg_writel(dev, CMD_ENC_PIC_SRC_BOTTOM_CB, 0);
+	rtkve1_reg_writel(dev, CMD_ENC_PIC_SRC_BOTTOM_CR, 0);
+
+	/* pic option, related to fieldRun/forceIPicture */
+	if (src_buf->sequence == 0) {
+		is_idr = 1;
+	}
+	if (src_buf->sequence == ctx->srcbuf_sequence_of_key_frm) {
+		dev_dbg(dev->dev, "%d.%s.set idr on key frame sequence:%d\n",
+			__LINE__, __func__, ctx->srcbuf_sequence_of_key_frm);
+		is_idr = 1;
+		ctx->srcbuf_sequence_of_key_frm = 0;
+	}
+	value = is_idr << 1 & 0x2;
+	rtkve1_reg_writel(dev, CMD_ENC_PIC_OPTION, value);
+
+	/* if ringBufferEnable == 0 */
+	rtkve1_reg_writel(dev, CMD_ENC_PIC_BB_START, (u32)dst_buf_paddr);
+	rtkve1_reg_writel(dev, CMD_ENC_PIC_BB_SIZE, dst_buf_size/1024);
+
+	/* rdPtr, if ringBufferEnable == 0  */
+	ctx->rdPtr = (u32)dst_buf_paddr;
+	rtkve1_reg_writel(dev, BIT_RD_PTR, ctx->rdPtr);
+
+	/* AXI use */
+	rtkve1_reg_writel(dev, BIT_AXI_SRAM_USE, 0);
+
+	/* rdPtr, wrPtr */
+	ctx->wrPtr = (u32)dst_buf_paddr;
+	ctx->rdPtr = (u32)dst_buf_paddr;
+	rtkve1_reg_writel(dev, BIT_WR_PTR, ctx->wrPtr);
+	rtkve1_reg_writel(dev, BIT_RD_PTR, ctx->rdPtr);
+
+	/* streamEndflag */
+	rtkve1_reg_writel(dev, BIT_BIT_STREAM_PARAM, 0);
+
+	/* frame mem ctrl, related to bwbEnable/linear2TiledMode/mapType/chromaFormat400/cbcrInterleave/frameEndian */
+	value = (VE1_BWB_ENABLE<<15) | (cbcrInterleave<<2) | VPU_FRAME_ENDIAN;
+	rtkve1_reg_writel(dev, BIT_FRAME_MEM_CTRL, value);
+	/* stream ctrl, related to lineBufIntEn/streamEndian */
+	rtkve1_reg_writel(dev, BIT_BIT_STREAM_CTRL, 0x30);
+
+	/* ME line buffer mode */
+	rtkve1_reg_writel(dev, BIT_ME_LINEBUFFER_MODE, 0);
+#if 0
+	if (src_buf->sequence < 3) {
+	//dev_dbg(dev->dev, "[%d]%s.r_register from 0x9804_0000~0x9804_2FFF start\n", __LINE__, __func__);
+	//for (i=0; i<3072; i++) {
+	dev_dbg(dev->dev, "[%d]%s.r_register from 0x9804_0000~0x9804_01FF start\n", __LINE__, __func__);
+	for (i=0; i<128; i++) {
+		value = rtkve1_reg_readl(dev, (i*4));
+		dev_dbg(dev->dev, "[%d]%s.r_reg 0x%04X:0x%x\n", __LINE__, __func__,
+			(i*4), value);
+	}
+	//dev_dbg(dev->dev, "[%d]%s.r_register from 0x9804_0000~0x9804_2FFF end\n", __LINE__, __func__);
+	dev_dbg(dev->dev, "[%d]%s.r_register from 0x9804_0000~0x9804_01FF end\n", __LINE__, __func__);
+	}
+#endif
+	/* issue command */
+	rtkve1_issue_command(ctx, PIC_RUN);
+
+	/* wait interrupt */
+	while (intr_timeout_count < RTKVE1_ENC_TIMEOUT) {
+		intr_reason = rtkve1_wait_interrupt(ctx, RTKVE1_ENC_TIMEOUT);
+		if (intr_reason < 0) {
+			intr_timeout_count++;
+		}
+		else {
+			break;
+		}
+	}
+	if (intr_reason < 0) {
+		dev_err(dev->dev, "%d.%s.rtkve1_wait_interrupt() fail\n",
+			__LINE__, __func__);
+		return intr_reason;
+	}
+	dev_dbg(dev->dev, "%d.%s.intr_reason:0x%x\n",
+		__LINE__, __func__, intr_reason);
+	rtkve1_clear_interrupt(ctx);
+
+	/* get result */
+	ret = rtkve1_reg_readl(dev, RET_ENC_PIC_SUCCESS);
+	dev_dbg(dev->dev, "%d.%s.r_reg RET_ENC_PIC_SUCCESS(0x%X):0x%x\n",
+		__LINE__, __func__,
+		RET_ENC_PIC_SUCCESS, ret);
+	if (ret & (1 << 31)) {
+		dev_err(dev->dev, "%d.%s.memory access violation\n",
+			__LINE__, __func__);
+		return ret;
+	}
+
+	frm_idx = rtkve1_reg_readl(dev, RET_ENC_PIC_FRAME_NUM);
+	pic_type = rtkve1_reg_readl(dev, RET_ENC_PIC_TYPE);
+	dev_dbg(dev->dev, "%d.%s.frm_idx:%d.pic_type:%d\n",
+		__LINE__, __func__,
+		frm_idx, pic_type);
+
+	ctx->rdPtr = rtkve1_reg_readl(dev, BIT_RD_PTR);
+	dev_dbg(dev->dev, "%d.%s.r_reg BIT_RD_PTR(0x%X):0x%x\n",
+		__LINE__, __func__,
+		BIT_RD_PTR, ctx->rdPtr);
+	ctx->wrPtr = rtkve1_reg_readl(dev, BIT_WR_PTR);
+	dev_dbg(dev->dev, "%d.%s.r_reg BIT_WR_PTR(0x%X):0x%x\n",
+		__LINE__, __func__,
+		BIT_WR_PTR, ctx->wrPtr);
+	enc_frm_bs_bytes = ctx->wrPtr - ctx->rdPtr;
+	dev_dbg(dev->dev, "%d.%s.encoded frame bytes:%d\n",
+		__LINE__, __func__,
+		enc_frm_bs_bytes);
+	//enc_dump_bs(ctx, (unsigned char *)dst_buf_vaddr, enc_frm_bs_bytes);
+	dst_buf_payload = enc_frm_bs_bytes;
+
+	if (src_buf->sequence == 0) {
+		enc_copy_hdr(ctx, dst_buf_vaddr, dst_buf_size, enc_frm_bs_bytes);
+		dst_buf_payload = enc_frm_bs_bytes + ctx->enc_hdr_bytes;
+		ctx->enc_bs_new_file = 1;
+		enc_dump_bs(ctx, (unsigned char *)dst_buf_vaddr, dst_buf_payload);
+		dev_dbg(dev->dev, "%d.%s.dst_buf_payload:%d\n",
+			__LINE__, __func__,
+			dst_buf_payload);
+	}
+	else {
+		enc_dump_bs(ctx, (unsigned char *)dst_buf_vaddr, enc_frm_bs_bytes);
+	}
+
+	num_of_slices = rtkve1_reg_readl(dev, RET_ENC_PIC_SLICE_NUM);
+	pic_flag = rtkve1_reg_readl(dev, RET_ENC_PIC_FLAG);
+	src_idx = rtkve1_reg_readl(dev, RET_ENC_PIC_FRAME_IDX);
+	dev_dbg(dev->dev, "%d.%s.num_of_slices:%d.pic_flag:0x%x.src_idx:%d\n",
+		__LINE__, __func__,
+		num_of_slices, pic_flag, src_idx);
+
+	v4l2_m2m_buf_copy_metadata(src_buf, dst_buf, false);
+	if (is_idr)
+		dst_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;
+	else
+		dst_buf->flags |= V4L2_BUF_FLAG_PFRAME;
+	dst_buf->flags |= src_buf->flags & V4L2_BUF_FLAG_LAST;
+	dev_dbg(dev->dev, "%d.%s.dst_buf->flags:0x%x.src_buf->flags:0x%x\n",
+		__LINE__, __func__,
+		dst_buf->flags,
+		src_buf->flags);
+
+	vb2_set_plane_payload(&dst_buf->vb2_buf, 0, dst_buf_payload);
+
+	dst_buf = v4l2_m2m_dst_buf_remove(ctx->v4l2_fh.m2m_ctx);
+	dev_dbg(dev->dev, "%d.%s.v4l2_m2m_buf_done.dst_buf:0x%px\n",
+		__LINE__, __func__,
+		dst_buf);
+	v4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);
+
+	src_buf = v4l2_m2m_src_buf_remove(ctx->v4l2_fh.m2m_ctx);
+	dev_dbg(dev->dev, "%d.%s.v4l2_m2m_buf_done.src_buf:0x%px.src_buf_y:0x%llx\n",
+		__LINE__, __func__,
+		src_buf,
+		src_buf_y);
+	v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);
+
+	ctx->enc_pic_done = 1;
+
+	return ret;
+}
+
+static int enc_seq_end(struct rtkve1enc_ctx *ctx)
+{
+	struct videc_dev *dev = ctx->dev;
+	int ret = 0;
+
+	lockdep_assert_held(&dev->ve1_hw_mutex);
+
+	/* if seq_init_done */
+	rtkve1_reg_writel(dev, BIT_WR_PTR, ctx->wrPtr);
+	rtkve1_reg_writel(dev, BIT_RD_PTR, ctx->rdPtr);
+
+	/* issue command */
+	rtkve1_issue_command(ctx, ENC_SEQ_END);
+
+	/* wait busy flag */
+	ret = rtkve1_wait_busy(dev, BIT_BUSY_FLAG);
+	if (ret) {
+		dev_err(dev->dev,
+			"%d.%s.wait_timeout.BIT_BUSY_FLAG.ret:%d\n",
+            __LINE__, __func__,
+			ret);
+		return -ETIMEDOUT;
+	}
+
+	ctx->wrPtr = rtkve1_reg_readl(dev, BIT_WR_PTR);
+	dev_dbg(dev->dev, "%d.%s.r_reg BIT_WR_PTR(0x%X):0x%x\n", __LINE__, __func__,
+		BIT_WR_PTR, ctx->rdPtr);
+
+	ctx->seq_end_done = 1;
+	ctx->stopping = 0;
+
+	return ret;
+}
+
+static void enc_clear_ctx(struct rtkve1enc_ctx *ctx)
+{
+	/* clear state variables */
+	ctx->enc_state = RTK_VE1_STATE_ENC_IDLE;
+	ctx->seq_init_done = 0;
+	ctx->reg_fbs_done = 0;
+	ctx->enc_header_done = 0;
+	ctx->enc_pic_done = 0;
+	ctx->seq_end_done = 0;
+
+	/* clear flags */
+	ctx->stopping = 0;
+	ctx->out_streamon = 0;
+	ctx->out_streamon = 0;
+	ctx->eos = 0;
+
+	ctx->rdPtr = 0;
+	ctx->wrPtr = 0;
+	ctx->enc_min_fb_num = 0;
+
+	if (ctx->enc_hdr_buf_size != 0) {
+		vfree((void *)ctx->enc_hdr_buf);
+		ctx->enc_hdr_buf = NULL;
+	}
+	ctx->enc_hdr_buf_size = 0;
+	ctx->enc_hdr_bytes = 0;
+
+	ctx->outbuf_new_file = 0;
+	ctx->enc_bs_new_file = 0;
+}
+
+static int rtkve1enc_queue_init(void *priv, struct vb2_queue *src_vq,
+                struct vb2_queue *dst_vq)
+{
+	struct rtkve1enc_ctx *ctx = priv;
+	int ret;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.[+] ctx:0x%px\n",
+		__LINE__, __func__, ctx);
+
+	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	src_vq->io_modes = VB2_MMAP | VB2_DMABUF;
+	src_vq->mem_ops = &vb2_dma_contig_memops;
+	src_vq->ops = &rtkve1enc_vb2_ops;
+	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	src_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);
+	src_vq->drv_priv = ctx;
+	src_vq->lock = &ctx->dev->dev_mutex;
+	src_vq->dev = ctx->dev->v4l2_dev.dev;
+	//src_vq->supports_requests = true;
+	ret = vb2_queue_init(src_vq);
+	if (ret)
+		goto exit;
+
+	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	dst_vq->io_modes = VB2_MMAP | VB2_DMABUF;
+	dst_vq->mem_ops = &vb2_dma_contig_memops;
+	dst_vq->ops = &rtkve1enc_vb2_ops;
+	dst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	dst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);
+	dst_vq->min_buffers_needed = 1;
+	dst_vq->drv_priv = ctx;
+	dst_vq->lock = &ctx->dev->dev_mutex;
+	dst_vq->dev = ctx->dev->v4l2_dev.dev;
+	ret = vb2_queue_init(dst_vq);
+	if (ret)
+		goto exit;
+
+exit:
+	dev_dbg(ctx->dev->dev, "%d.%s.[-] ret:%d\n",
+		__LINE__, __func__, ret);
+	return ret;
+}
+
+static int rtkve1enc_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct rtkve1enc_ctx *ctx =
+	container_of(ctrl->handler, struct rtkve1enc_ctx, v4l2_ctrl_hdl);
+
+	dev_dbg(ctx->dev->dev, "%d.%s.id:%d(0x%x)\n",
+		__LINE__, __func__,
+		(ctrl->id-V4L2_CID_CODEC_BASE),
+		ctrl->id);
+
+	switch (ctrl->id) {
+		case V4L2_CID_MPEG_VIDEO_H264_PROFILE:
+			dev_dbg(ctx->dev->dev, "%d.%s.H264_PROFILE.val:%d\n",
+				__LINE__, __func__,
+				ctrl->val);
+			if (ctrl->val == V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE ||
+				ctrl->val == V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE) {
+				/* Baseline profile */
+				ctx->enc_params.h264_profile_idc = 0;
+			}
+			else if (ctrl->val == V4L2_MPEG_VIDEO_H264_PROFILE_MAIN) {
+				/* Main profile */
+				ctx->enc_params.h264_profile_idc = 1;
+			}
+			else if (ctrl->val == V4L2_MPEG_VIDEO_H264_PROFILE_HIGH) {
+				/* High profile */
+				ctx->enc_params.h264_profile_idc = 2;
+			}
+			else {
+				ret = -EINVAL;
+			}
+			dev_dbg(ctx->dev->dev, "%d.%s.h264_profile_idc:%d\n",
+				__LINE__, __func__,
+				ctx->enc_params.h264_profile_idc);
+			break;
+		case V4L2_CID_MPEG_VIDEO_H264_LEVEL:
+			dev_dbg(ctx->dev->dev, "%d.%s.H264_LEVEL.val:%d\n",
+				__LINE__, __func__,
+				ctrl->val);
+			if ((ctrl->val >= 0) && (ctrl->val <= 15)) {
+				ctx->enc_params.s_ctrl_level_value = ctrl->val;
+			}
+			else {
+				ret = -EINVAL;
+			}
+			break;
+		case V4L2_CID_MPEG_VIDEO_GOP_SIZE:
+			dev_dbg(ctx->dev->dev, "%d.%s.GOP_SIZE.val:%d\n",
+				__LINE__, __func__,
+				ctrl->val);
+			if ((ctrl->val >= 0) && (ctrl->val <= 60)) {
+				ctx->enc_params.gop_size = ctrl->val;
+			}
+			else {
+				ret = -EINVAL;
+			}
+			break;
+		case V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP:
+			dev_dbg(ctx->dev->dev, "%d.%s.I_FRAME_QP.val:%d\n",
+				__LINE__, __func__,
+				ctrl->val);
+			if ((ctrl->val == -1) ||
+				((ctrl->val >= 0) && (ctrl->val <= 51))) {
+				ctx->enc_params.intra_qp = ctrl->val;
+			}
+			else {
+				ret = -EINVAL;
+			}
+			break;
+		case V4L2_CID_MPEG_VIDEO_BITRATE:
+			dev_dbg(ctx->dev->dev, "%d.%s.VIDEO_BITRATE.val:%d\n",
+				__LINE__, __func__,
+				ctrl->val);
+			if ((ctrl->val >= MIN_BITRATE) && (ctrl->val <= MAX_BITRATE)) {
+				ctx->enc_params.bitrate = ctrl->val/8; /* ctrl->val is average video bitrate in bits per second. */
+			}
+			else {
+				ret = -EINVAL;
+			}
+			break;
+		case V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME:
+			dev_dbg(ctx->dev->dev, "%d.%s.FORCE_KEY_FRAME.val:%d\n",
+				__LINE__, __func__,
+				ctrl->val);
+			ctx->enc_params.force_key_frm = 1;
+			break;
+		default:
+			break;
+	}
+
+    return ret;
+}
+
+static const struct v4l2_ctrl_ops rtkve1enc_ctrl_ops = {
+	.s_ctrl = rtkve1enc_s_ctrl,
+};
+
+static int rtkve1enc_ctrls_setup(struct rtkve1enc_ctx *ctx)
+{
+    struct v4l2_ctrl_handler *hdl = &ctx->v4l2_ctrl_hdl;
+    int ret = 0;
+    int max_gop_size = 60;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.[+] ctx:0x%px\n",
+		__LINE__, __func__, ctx);
+
+    v4l2_ctrl_handler_init(hdl, 9);
+
+    v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MIN_BUFFERS_FOR_OUTPUT, 1, 32, 1, 4);
+
+    v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 4);
+
+    v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_BITRATE,
+        MIN_BITRATE, MAX_BITRATE, 1, DEF_BITRATE);
+
+    v4l2_ctrl_new_std_menu(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_BITRATE_MODE,
+        V4L2_MPEG_VIDEO_BITRATE_MODE_VBR,
+        ~(1 << V4L2_MPEG_VIDEO_BITRATE_MODE_VBR),
+        V4L2_MPEG_VIDEO_BITRATE_MODE_VBR);
+
+    v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_GOP_SIZE, 0, max_gop_size, 1, DEFAULT_GOP);
+    v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP, -1, 51, 1, DEFAULT_I_FRAME_QP);
+/*
+    v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP, 0, 51, 1, 25);
+    v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_H264_MAX_QP, 0, 51, 1, 51);
+    v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_H264_CONSTRAINED_INTRA_PREDICTION, 0, 1, 1,
+        0);
+    v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE, 0, 1, 1, 1);
+    v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE, 0, 1, 1, 1);
+    v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_H264_CHROMA_QP_INDEX_OFFSET, -12, 12, 1, 0);
+*/
+
+    v4l2_ctrl_new_std_menu(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_H264_PROFILE,
+        V4L2_MPEG_VIDEO_H264_PROFILE_HIGH,
+        ~((1 << V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE) |
+          (1 << V4L2_MPEG_VIDEO_H264_PROFILE_MAIN) |
+          (1 << V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)),
+        V4L2_MPEG_VIDEO_H264_PROFILE_HIGH);
+    v4l2_ctrl_new_std_menu(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_H264_LEVEL,
+        V4L2_MPEG_VIDEO_H264_LEVEL_4_2, 0x0,
+        V4L2_MPEG_VIDEO_H264_LEVEL_4_2);
+    v4l2_ctrl_new_std_menu(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE,
+        V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES, 0x0,
+        V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE);
+    v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB, 1, 0x3fffffff, 1, 1);
+    v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES, 1, 0x3fffffff, 1,
+        500);
+    v4l2_ctrl_new_std_menu(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_HEADER_MODE,
+        V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME,
+        (1 << V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE),
+        V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME);
+    v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+        V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB, 0,
+        1920 * 1088 / 256, 1, 0);
+
+	v4l2_ctrl_new_std(hdl, &rtkve1enc_ctrl_ops,
+		V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME, 0, 1, 0, 0);
+
+    if (hdl->error) {
+        dev_err(ctx->dev->dev, "%d.%s.Failed to initialize control handler\n", __LINE__, __func__);
+        v4l2_ctrl_handler_free(hdl);
+        ret = hdl->error;
+        goto exit;
+    }
+
+	ctx->enc_params.transform_8x8_mode = 1;
+	dev_dbg(ctx->dev->dev, "%d.%s.set default.transform_8x8_mode:%d\n",
+		__LINE__, __func__,
+		ctx->enc_params.transform_8x8_mode);
+
+	ctx->enc_params.field_flag = 0;
+	ctx->enc_params.field_ref_mode = 1;
+	dev_dbg(ctx->dev->dev, "%d.%s.set default.field_flag:%d.field_ref_mode:%d\n",
+		__LINE__, __func__,
+		ctx->enc_params.field_flag,
+		ctx->enc_params.field_ref_mode);
+
+	ctx->enc_params.entropy_coding_mode = 1;
+	dev_dbg(ctx->dev->dev, "%d.%s.set default.entropy_coding_mode:%d\n",
+		__LINE__, __func__,
+		ctx->enc_params.entropy_coding_mode);
+
+	ctx->enc_params.gop_size = DEFAULT_GOP;
+	dev_dbg(ctx->dev->dev, "%d.%s.set default.gop_size:%d\n",
+		__LINE__, __func__,
+		ctx->enc_params.gop_size);
+
+	ctx->enc_params.bitrate = DEF_BITRATE;
+	dev_dbg(ctx->dev->dev, "%d.%s.set default.bitrate:%d\n",
+		__LINE__, __func__,
+		ctx->enc_params.bitrate);
+
+	ctx->enc_params.framerate_num = DEFAULT_FRAMERATE_NUM;
+	ctx->enc_params.framerate_denom = DEFAULT_FRAMERATE_DENOM;
+	dev_dbg(ctx->dev->dev, "%d.%s.set default.framerate_num:%d.framerate_denom:%d\n",
+		__LINE__, __func__,
+		ctx->enc_params.framerate_num,
+		ctx->enc_params.framerate_denom);
+
+	ctx->enc_params.intra_qp = -1;
+	dev_dbg(ctx->dev->dev, "%d.%s.set default.intra_qp:%d\n",
+		__LINE__, __func__,
+		ctx->enc_params.intra_qp);
+
+	ctx->enc_params.force_key_frm = 0;
+
+    ctx->v4l2_fh.ctrl_handler = hdl;
+    v4l2_ctrl_handler_setup(hdl);
+exit:
+	dev_dbg(ctx->dev->dev, "%d.%s.[-] ret:%d\n",
+		__LINE__, __func__, ret);
+    return ret;
+}
+
+static int rtkve1enc_reqbufs(struct rtkve1enc_ctx *ctx,
+            struct v4l2_requestbuffers *rb)
+{
+	struct videc_dev *dev = NULL;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.ctx:0x%px.type:%s.count:%d\n",
+        __LINE__, __func__,
+		ctx, v4l2_type_names[rb->type], rb->count);
+	dev = ctx->dev;
+
+	if (V4L2_TYPE_IS_OUTPUT(rb->type) && (rb->count != 0)) {
+		rtkve1_initialize(ctx, ctx->dev);
+	}
+
+	if ((ctx->reqbuf_out == 0) && (ctx->reqbuf_cap == 0)) {
+		dev_dbg(dev->dev, "%d.%s.ctx:0x%px.enc_initialized:%d.enc_state:%d\n",
+			__LINE__, __func__,
+			ctx, ctx->enc_initialized,
+			ctx->enc_state);
+		if (ctx->enc_initialized > 0) {
+			if (ctx->enc_state >= RTK_VE1_STATE_ENC_SEQ_INIT) {
+				ctx->ops->seq_end(ctx);
+			}
+			rtkve1_finalize(ctx, dev);
+		}
+	}
+
+	return 0;
+}
+
+static int rtkve1enc_decide_state(struct rtkve1enc_ctx *ctx, enum rtkve1_enc_state *new_state)
+{
+	int ret = 0;
+
+	if (new_state == NULL) {
+		return -EINVAL;
+	}
+
+	if (ctx->stopping && (ctx->enc_state == RTK_VE1_STATE_ENC_PIC)) {
+		*new_state = RTK_VE1_STATE_ENC_RESET;
+		dev_dbg(ctx->dev->dev, "%d.%s.org_state:%s.new_state:%s\n",
+			__LINE__, __func__,
+			rtk_ve1_enc_state_str[ctx->enc_state],
+			rtk_ve1_enc_state_str[*new_state]);
+		ctx->enc_state = *new_state;
+		return 0;
+	}
+	if (ctx->out_streamon && ctx->cap_streamon && (ctx->enc_state == RTK_VE1_STATE_ENC_RESET)) {
+		ctx->stopping = 0;
+		*new_state = RTK_VE1_STATE_ENC_PIC;
+		dev_dbg(ctx->dev->dev, "%d.%s.org_state:%s.new_state:%s\n",
+			__LINE__, __func__,
+			rtk_ve1_enc_state_str[ctx->enc_state],
+			rtk_ve1_enc_state_str[*new_state]);
+		return 0;
+	}
+
+	switch (ctx->enc_state) {
+		case RTK_VE1_STATE_ENC_IDLE:
+			*new_state = RTK_VE1_STATE_ENC_SEQ_INIT;
+			break;
+		case RTK_VE1_STATE_ENC_SEQ_INIT:
+			if (!ctx->seq_init_done) {
+				//dev_dbg(ctx->dev->dev, "%d.%s.!ctx->st_seq_init_done.state nochange\n", __LINE__, __func__);
+				ret = -EPERM;
+			}
+			else {
+				*new_state = RTK_VE1_STATE_ENC_REG_FBS;
+			}
+			break;
+		case RTK_VE1_STATE_ENC_REG_FBS:
+			if (!ctx->reg_fbs_done) {
+				dev_dbg(ctx->dev->dev, "%d.%s.!ctx->reg_fbs_done.state nochange\n", __LINE__, __func__);
+				ret = -EPERM;
+			}
+			else {
+				*new_state = RTK_VE1_STATE_ENC_HEADER;
+			}
+			break;
+		case RTK_VE1_STATE_ENC_HEADER:
+			if (!ctx->enc_header_done) {
+				pr_info("%d.%s.!ctx->enc_header_done.state nochange\n", __LINE__, __func__);
+				ret = -EPERM;
+			}
+			else {
+				*new_state = RTK_VE1_STATE_ENC_PIC;
+			}
+			break;
+		case RTK_VE1_STATE_ENC_PIC:
+			if (!ctx->enc_pic_done) {
+				pr_info("%d.%s.!ctx->enc_pic_done.state nochange\n", __LINE__, __func__);
+				ret = -EPERM;
+			}
+			else {
+				*new_state = RTK_VE1_STATE_ENC_PIC;
+			}
+			break;
+		default:
+			ret = -EPERM;
+			break;
+	}
+
+	if ((ret == 0) && (*new_state != ctx->enc_state)) {
+		dev_dbg(ctx->dev->dev, "%d.%s.org_state:%s.new_state:%s\n",
+			__LINE__, __func__,
+			rtk_ve1_enc_state_str[ctx->enc_state],
+			rtk_ve1_enc_state_str[*new_state]);
+	}
+
+	return ret;
+}
+
+static int rtkve1enc_seq_init(struct rtkve1enc_ctx *ctx)
+{
+	int ret = 0;
+	struct videc_dev *dev = ctx->dev;
+
+	dev_dbg(dev->dev, "%d.%s.[+]\n", __LINE__, __func__);
+	mutex_lock(&dev->ve1_hw_mutex);
+
+	ret = enc_alloc_bsbuf_workbuf(ctx);
+	if (ret < 0) {
+		goto exit;
+	}
+
+	ctx->enc_state = RTK_VE1_STATE_ENC_SEQ_INIT;
+	if (!ctx->seq_init_done) {
+		ret = enc_seq_init(ctx);
+	}
+
+exit:
+	mutex_unlock(&dev->ve1_hw_mutex);
+	dev_dbg(dev->dev, "%d.%s.[-]\n", __LINE__, __func__);
+
+	return ret;
+}
+
+static int rtkve1enc_reg_fbs(struct rtkve1enc_ctx *ctx)
+{
+	int ret = 0;
+	struct videc_dev *dev = ctx->dev;
+
+	dev_dbg(dev->dev, "%d.%s.[+]\n", __LINE__, __func__);
+	mutex_lock(&dev->ve1_hw_mutex);
+
+	ret = enc_alloc_frame_buffers(ctx);
+	if (ret < 0) {
+		goto exit;
+	}
+
+	ctx->enc_state = RTK_VE1_STATE_ENC_REG_FBS;
+	if (!ctx->reg_fbs_done) {
+		ret = enc_reg_fbs(ctx);
+	}
+
+exit:
+	mutex_unlock(&dev->ve1_hw_mutex);
+	dev_dbg(dev->dev, "%d.%s.[-]\n", __LINE__, __func__);
+
+	return ret;
+}
+
+static int rtkve1enc_header(struct rtkve1enc_ctx *ctx)
+{
+	int ret = 0;
+	struct videc_dev *dev = ctx->dev;
+
+	dev_dbg(dev->dev, "%d.%s.[+]\n", __LINE__, __func__);
+	mutex_lock(&dev->ve1_hw_mutex);
+	ctx->enc_state = RTK_VE1_STATE_ENC_HEADER;
+	if (!ctx->enc_header_done) {
+		ret = enc_header(ctx);
+	}
+	mutex_unlock(&dev->ve1_hw_mutex);
+	dev_dbg(dev->dev, "%d.%s.[-]\n", __LINE__, __func__);
+
+	return ret;
+}
+
+static int rtkve1enc_pic(struct rtkve1enc_ctx *ctx)
+{
+	int ret = 0;
+	struct videc_dev *dev = ctx->dev;
+
+	dev_dbg(dev->dev, "%d.%s.[+]\n", __LINE__, __func__);
+	mutex_lock(&dev->ve1_hw_mutex);
+	ctx->enc_state = RTK_VE1_STATE_ENC_PIC;
+	ret = enc_pic(ctx);
+	mutex_unlock(&dev->ve1_hw_mutex);
+	dev_dbg(dev->dev, "%d.%s.[-]\n", __LINE__, __func__);
+
+	return ret;
+}
+
+static void rtkve1enc_seq_end(struct rtkve1enc_ctx *ctx)
+{
+	int ret = 0;
+	struct videc_dev *dev = ctx->dev;
+	int i = 0;
+	char dbg_name[16];
+
+	dev_dbg(dev->dev, "%d.%s.[+]\n", __LINE__, __func__);
+	mutex_lock(&dev->ve1_hw_mutex);
+	ctx->enc_state = RTK_VE1_STATE_ENC_SEQ_END;
+	if (!ctx->seq_end_done) {
+		ret = enc_seq_end(ctx);
+		if (ret == -ETIMEDOUT) {
+		}
+	}
+
+	for (i=0; i < ctx->enc_min_fb_num; i++) {
+		if (ctx->framebuf[i].size != 0) {
+			memset(dbg_name, 0, sizeof(dbg_name));
+			snprintf(dbg_name, 16, "framebuf%d", i);
+			dev_dbg(dev->dev, "%d.%s.free_dma.%d.name:%s.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+				__LINE__, __func__,
+				i, dbg_name, ctx->framebuf[i].size,
+				ctx->framebuf[i].paddr,
+				ctx->framebuf[i].vaddr);
+			rtkve1_free_dma_memory(dev, &ctx->framebuf[i], dbg_name);
+		}
+	}
+
+	if (ctx->bitstream.size != 0) {
+		dev_dbg(dev->dev, "%d.%s.free_dma.name:bsbuf.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+			__LINE__, __func__,
+			ctx->bitstream.size,
+			ctx->bitstream.paddr,
+			ctx->bitstream.vaddr);
+		rtkve1_free_dma_memory(dev, &ctx->bitstream, "bsbuf");
+	}
+	if (ctx->workbuf.size != 0) {
+		dev_dbg(dev->dev, "%d.%s.free_dma.name:workbuf.size:%d.paddr:0x%llx.vaddr:0x%px\n",
+			__LINE__, __func__,
+			ctx->workbuf.size,
+			ctx->workbuf.paddr,
+			ctx->workbuf.vaddr);
+		rtkve1_free_dma_memory(dev, &ctx->workbuf, "workbuf");
+	}
+
+	enc_clear_ctx(ctx);
+
+	mutex_unlock(&dev->ve1_hw_mutex);
+	dev_dbg(dev->dev, "%d.%s.[-]\n", __LINE__, __func__);
+}
+
+static void rtkve1enc_timeout(struct rtkve1enc_ctx *ctx)
+{
+}
+
+const struct rtkve1_context_ops rtkve1enc_ops = {
+	.find_vpu_fmt = rtkve_enc_find_fmt,
+	.find_vpu_fmt_by_idx = rtkve_enc_find_fmt_by_idx,
+    .queue_init = rtkve1enc_queue_init,
+    .ctrls_setup = rtkve1enc_ctrls_setup,
+	.reqbufs = rtkve1enc_reqbufs,
+	.decide_state = rtkve1enc_decide_state,
+	.seq_init = rtkve1enc_seq_init,
+	.reg_fbs = rtkve1enc_reg_fbs,
+	.enc_header = rtkve1enc_header,
+	.enc_pic = rtkve1enc_pic,
+	.seq_end = rtkve1enc_seq_end,
+	.run_timeout = rtkve1enc_timeout,
+};
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/rtkve1enc_v4l2.c
@@ -0,0 +1,685 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video encoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#include "rtkve1enc_common.h"
+
+void rtkve_update_pix_fmt(struct rtkve1enc_ctx *ctx,
+			  struct v4l2_pix_format_mplane *pix_mp,
+			  unsigned int width, unsigned int height)
+{
+	pix_mp->flags = 0;
+	pix_mp->field = V4L2_FIELD_NONE;
+	memset(pix_mp->reserved, 0, sizeof(pix_mp->reserved));
+
+	switch (pix_mp->pixelformat) {
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+		pix_mp->width = width;
+		pix_mp->height = height;
+		dev_dbg(ctx->dev->dev, "%d.%s.%p4cc.width:%d.height:%d\n",
+			__LINE__, __func__,
+			&pix_mp->pixelformat,
+			pix_mp->width, pix_mp->height);
+
+		pix_mp->plane_fmt[0].bytesperline = pix_mp->width;
+		pix_mp->plane_fmt[0].sizeimage =
+			pix_mp->width * pix_mp->height * 3 / 2;
+		break;
+	default:
+		pix_mp->width = width;
+		pix_mp->height = height;
+		dev_dbg(ctx->dev->dev, "%d.%s.%p4cc.width:%d.height:%d\n",
+			__LINE__, __func__,
+			&pix_mp->pixelformat,
+			pix_mp->width, pix_mp->height);
+		pix_mp->plane_fmt[0].bytesperline = 0;
+		if (!pix_mp->plane_fmt[0].sizeimage)
+			pix_mp->plane_fmt[0].sizeimage = width * height;
+		break;
+	}
+}
+
+void rtkve_set_default_format(struct rtkve1enc_ctx *ctx,
+			      struct v4l2_pix_format_mplane *src_fmt,
+			      struct v4l2_pix_format_mplane *dst_fmt)
+{
+	const struct vpu_format *vpu_fmt;
+
+	vpu_fmt = ctx->ops->find_vpu_fmt_by_idx(0, VPU_FMT_TYPE_RAW);
+
+	src_fmt->pixelformat = vpu_fmt->v4l2_pix_fmt;
+	src_fmt->num_planes = vpu_fmt->num_planes;
+	rtkve_update_pix_fmt(ctx, src_fmt, vpu_fmt->max_width, vpu_fmt->max_height);
+
+	vpu_fmt = ctx->ops->find_vpu_fmt_by_idx(0, VPU_FMT_TYPE_CODEC);
+
+	dst_fmt->pixelformat = vpu_fmt->v4l2_pix_fmt;
+	dst_fmt->num_planes = vpu_fmt->num_planes;
+	rtkve_update_pix_fmt(ctx, dst_fmt, vpu_fmt->max_width, vpu_fmt->max_height);
+}
+
+static int rtkve_enc_querycap(struct file *file, void *fh,
+			      struct v4l2_capability *cap)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(fh);
+	dev_dbg(ctx->dev->dev, "%d.%s.[+] ctx:0x%px\n",
+		__LINE__, __func__, ctx);
+	strscpy(cap->driver, RTKVE1_ENC_DEV_NAME, sizeof(cap->driver));
+	strscpy(cap->card, RTKVE1_ENC_DEV_NAME, sizeof(cap->card));
+	strscpy(cap->bus_info, "platform:" RTKVE1_ENC_DEV_NAME,
+		sizeof(cap->bus_info));
+	dev_dbg(ctx->dev->dev, "%d.%s.[-]\n",
+		__LINE__, __func__);
+
+	return 0;
+}
+
+static int rtkve_enc_enum_framesizes(struct file *f, void *fh,
+				     struct v4l2_frmsizeenum *fsize)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(fh);
+	const struct vpu_format *vpu_fmt;
+	int ret = 0;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.[+] ctx:0x%px.index:%d\n",
+        __LINE__, __func__,
+		ctx, fsize->index);
+	if (fsize->index) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	vpu_fmt = ctx->ops->find_vpu_fmt(fsize->pixel_format,
+					  VPU_FMT_TYPE_CODEC);
+	if (!vpu_fmt) {
+		vpu_fmt = ctx->ops->find_vpu_fmt(fsize->pixel_format,
+						  VPU_FMT_TYPE_RAW);
+		if (!vpu_fmt) {
+			ret = -EINVAL;
+			dev_err(ctx->dev->dev, "%d.%s.can't find match VPU_FMT_TYPE_RAW.pixel_format:0x%x\n",
+				__LINE__, __func__, fsize->pixel_format);
+			goto exit;
+		}
+	}
+
+	fsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;
+	fsize->stepwise.min_width = vpu_fmt->min_width;
+	fsize->stepwise.max_width = vpu_fmt->max_width;
+	fsize->stepwise.step_width = ENC_PIC_SIZE_STEP;
+	fsize->stepwise.min_height = vpu_fmt->min_height;
+	fsize->stepwise.max_height = vpu_fmt->max_height;
+	fsize->stepwise.step_height = ENC_PIC_SIZE_STEP;
+
+exit:
+	dev_dbg(ctx->dev->dev, "%d.%s.[-] ret:%d\n",
+        __LINE__, __func__, ret);
+	return ret;
+}
+
+static int rtkve_enc_s_parm(struct file *file, void *fh,
+			    struct v4l2_streamparm *a)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(fh);
+	struct v4l2_fract *timeperframe = &a->parm.output.timeperframe;
+	int ret = 0;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.[+] ctx:0x%px.type:%d\n",
+        __LINE__, __func__, ctx, a->type);
+	if (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	dev_dbg(ctx->dev->dev, "%d.%s.numerator:%d.denominator:%d\n",
+		__LINE__, __func__,
+		timeperframe->numerator,
+		timeperframe->denominator);
+	if (timeperframe->numerator == 0 || timeperframe->denominator == 0) {
+		timeperframe->numerator = DEFAULT_FRAMERATE_DENOM;
+		timeperframe->denominator = DEFAULT_FRAMERATE_NUM;
+		ctx->enc_params.framerate_num = DEFAULT_FRAMERATE_NUM;
+		ctx->enc_params.framerate_denom = DEFAULT_FRAMERATE_DENOM;
+	}
+	// refer product.c
+	if ((timeperframe->denominator/timeperframe->numerator) < 15) {
+		dev_err(ctx->dev->dev, "%d.%s.invalid timeperframe %d/%d\n",
+			__LINE__, __func__,
+			timeperframe->numerator,
+			timeperframe->denominator);
+		ctx->enc_params.framerate_num = DEFAULT_FRAMERATE_NUM;
+		ctx->enc_params.framerate_denom = DEFAULT_FRAMERATE_DENOM;
+	}
+	//
+	else {
+		/* the meaning of numerator/denominator of timeperframe is different than framerate_num/framerate_denom */
+		/* ex: timeperframe is 1/30, then framerate is 30/1 */
+		ctx->enc_params.framerate_num = timeperframe->denominator;
+		ctx->enc_params.framerate_denom = timeperframe->numerator;
+	}
+
+	//ctx->enc_params.framerate = ctx->enc_params.framerate_num /
+	//			     ctx->enc_params.framerate_denom;
+	ctx->enc_params.framerate = (ctx->enc_params.framerate_denom - 1) << 16;
+	ctx->enc_params.framerate |= ctx->enc_params.framerate_num;
+	dev_dbg(ctx->dev->dev, "%d.%s.framerate:0x%x (%d/%d)\n",
+		__LINE__, __func__,
+		ctx->enc_params.framerate,
+		ctx->enc_params.framerate_num,
+		ctx->enc_params.framerate_denom);
+
+	a->parm.output.capability = V4L2_CAP_TIMEPERFRAME;
+
+exit:
+	dev_dbg(ctx->dev->dev, "%d.%s.[-] ret:%d\n",
+		__LINE__, __func__, ret);
+	return ret;
+}
+
+static int rtkve_enc_g_parm(struct file *file, void *fh,
+			    struct v4l2_streamparm *a)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(fh);
+	int ret = 0;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.[+] ctx:0x%px.type:%d\n",
+        __LINE__, __func__, ctx, a->type);
+	if (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	a->parm.output.capability = V4L2_CAP_TIMEPERFRAME;
+	a->parm.output.timeperframe.denominator =
+		ctx->enc_params.framerate_num;
+	a->parm.output.timeperframe.numerator =
+		ctx->enc_params.framerate_denom;
+
+exit:
+	dev_dbg(ctx->dev->dev, "%d.%s.[-] ret:%d\n",
+		__LINE__, __func__, ret);
+	return ret;
+}
+
+static int rtkve_enc_enum_fmt_cap(struct file *file, void *fh,
+				  struct v4l2_fmtdesc *f)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(fh);
+	const struct vpu_format *vpu_fmt;
+	int ret = 0;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.[+] ctx:0x%px.index:%d\n",
+        __LINE__, __func__, ctx, f->index);
+	vpu_fmt = ctx->ops->find_vpu_fmt_by_idx(f->index, VPU_FMT_TYPE_CODEC);
+	if (!vpu_fmt) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	f->pixelformat = vpu_fmt->v4l2_pix_fmt;
+	f->flags = 0;
+
+exit:
+	dev_dbg(ctx->dev->dev, "%d.%s.[-] ret:%d\n",
+        __LINE__, __func__, ret);
+	return ret;
+}
+
+static int rtkve_enc_try_fmt_cap(struct file *file, void *fh,
+				 struct v4l2_format *f)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	const struct vpu_format *vpu_fmt;
+	int width, height;
+	int ret = 0;
+
+	dev_dbg(ctx->dev->dev, "%s: 4cc %d w %d h %d plane %d colorspace %d\n",
+		__func__, pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	if (!V4L2_TYPE_IS_CAPTURE(f->type)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	vpu_fmt = ctx->ops->find_vpu_fmt(pix_mp->pixelformat,
+					  VPU_FMT_TYPE_CODEC);
+	if (!vpu_fmt) {
+		width = ctx->dst_fmt.width;
+		height = ctx->dst_fmt.height;
+		pix_mp->pixelformat = ctx->dst_fmt.pixelformat;
+		pix_mp->num_planes = ctx->dst_fmt.num_planes;
+	} else {
+		width = clamp(pix_mp->width, vpu_fmt->min_width,
+			      ctx->src_fmt.width);
+		dev_dbg(ctx->dev->dev, "%d.%s.width:%d.%d.%d.%d\n",
+			__LINE__, __func__,
+			width, pix_mp->width, vpu_fmt->min_width, ctx->src_fmt.width);
+		height = clamp(pix_mp->height, vpu_fmt->min_height,
+			       ctx->src_fmt.height);
+		dev_dbg(ctx->dev->dev, "%d.%s.height:%d.%d.%d.%d\n",
+			__LINE__, __func__,
+			height, pix_mp->height, vpu_fmt->min_height, ctx->src_fmt.height);
+		pix_mp->pixelformat = vpu_fmt->v4l2_pix_fmt;
+		pix_mp->num_planes = vpu_fmt->num_planes;
+	}
+
+	rtkve_update_pix_fmt(ctx, pix_mp, width, height);
+	pix_mp->colorspace = ctx->colorspace;
+	pix_mp->ycbcr_enc = ctx->ycbcr_enc;
+	pix_mp->quantization = ctx->quantization;
+	pix_mp->xfer_func = ctx->xfer_func;
+
+exit:
+	return ret;
+}
+
+static int rtkve_enc_s_fmt_cap(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i, ret = 0;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.%p4cc w %d h %d plane %d colorspace %d\n",
+		__LINE__, __func__,
+		&pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	ret = rtkve_enc_try_fmt_cap(file, fh, f);
+	if (ret) {
+		dev_err(ctx->dev->dev, "rtkve_enc_try_fmt_cap fail");
+		goto exit;
+	}
+
+	ctx->dst_fmt.width = pix_mp->width;
+	ctx->dst_fmt.height = pix_mp->height;
+	dev_dbg(ctx->dev->dev, "%d.%s.dst_fmt.width:%d.height:%d\n",
+		__LINE__, __func__,
+		ctx->dst_fmt.width, ctx->dst_fmt.height);
+	ctx->dst_fmt.pixelformat = pix_mp->pixelformat;
+	ctx->dst_fmt.field = pix_mp->field;
+	ctx->dst_fmt.flags = pix_mp->flags;
+	ctx->dst_fmt.num_planes = pix_mp->num_planes;
+	for (i = 0; i < ctx->dst_fmt.num_planes; i++) {
+		ctx->dst_fmt.plane_fmt[i].bytesperline =
+			pix_mp->plane_fmt[i].bytesperline;
+		ctx->dst_fmt.plane_fmt[i].sizeimage =
+			pix_mp->plane_fmt[i].sizeimage;
+	}
+
+	rtkve_update_pix_fmt(ctx, &ctx->src_fmt, pix_mp->width,
+			     pix_mp->height);
+
+exit:
+	dev_dbg(ctx->dev->dev, "%d.%s.[-] ret:%d\n",
+        __LINE__, __func__, ret);
+	return ret;
+}
+
+static int rtkve_enc_g_fmt_cap(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i;
+
+	pix_mp->width = ctx->dst_fmt.width;
+	pix_mp->height = ctx->dst_fmt.height;
+	pix_mp->pixelformat = ctx->dst_fmt.pixelformat;
+	pix_mp->field = ctx->dst_fmt.field;
+	pix_mp->flags = ctx->dst_fmt.flags;
+	pix_mp->num_planes = ctx->dst_fmt.num_planes;
+	for (i = 0; i < pix_mp->num_planes; i++) {
+		pix_mp->plane_fmt[i].bytesperline =
+			ctx->dst_fmt.plane_fmt[i].bytesperline;
+		pix_mp->plane_fmt[i].sizeimage =
+			ctx->dst_fmt.plane_fmt[i].sizeimage;
+	}
+
+	pix_mp->colorspace = ctx->colorspace;
+	pix_mp->ycbcr_enc = ctx->ycbcr_enc;
+	pix_mp->quantization = ctx->quantization;
+	pix_mp->xfer_func = ctx->xfer_func;
+
+	return 0;
+}
+
+static int rtkve_enc_enum_fmt_out(struct file *file, void *fh,
+				  struct v4l2_fmtdesc *f)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(fh);
+	const struct vpu_format *vpu_fmt;
+	int ret = 0;
+
+	dev_dbg(ctx->dev->dev, "%s: index %d\n", __func__, f->index);
+
+	vpu_fmt = ctx->ops->find_vpu_fmt_by_idx(f->index, VPU_FMT_TYPE_RAW);
+	if (!vpu_fmt) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	f->pixelformat = vpu_fmt->v4l2_pix_fmt;
+
+exit:
+	return ret;
+}
+
+static int rtkve_enc_try_fmt_out(struct file *file, void *fh,
+				 struct v4l2_format *f)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	const struct vpu_format *vpu_fmt;
+	int width, height;
+	int ret = 0;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.%p4cc w %d h %d plane %d colorspace %d\n",
+		__LINE__, __func__,
+		&pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	if (!V4L2_TYPE_IS_OUTPUT(f->type)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	vpu_fmt =
+		ctx->ops->find_vpu_fmt(pix_mp->pixelformat, VPU_FMT_TYPE_RAW);
+	if (!vpu_fmt) {
+		width = ctx->src_fmt.width;
+		height = ctx->src_fmt.height;
+		pix_mp->pixelformat = ctx->src_fmt.pixelformat;
+		pix_mp->num_planes = ctx->src_fmt.num_planes;
+	} else {
+		width  = round_up(pix_mp->width, 32);
+		height = round_up(pix_mp->height, 16);
+		dev_dbg(ctx->dev->dev, "%d.%s.width:%d.height:%d\n",
+			__LINE__, __func__,
+			width, height);
+		pix_mp->pixelformat = vpu_fmt->v4l2_pix_fmt;
+		pix_mp->num_planes = vpu_fmt->num_planes;
+	}
+
+	rtkve_update_pix_fmt(ctx, pix_mp, width, height);
+exit:
+	dev_dbg(ctx->dev->dev, "%d.%s.[-] ret:%d\n",
+        __LINE__, __func__, ret);
+	return ret;
+}
+
+static int rtkve_enc_s_fmt_out(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i, ret = 0;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.%p4cc w %d h %d plane %d colorspace %d\n",
+		__LINE__, __func__,
+		&pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	ret = rtkve_enc_try_fmt_out(file, fh, f);
+	if (ret) {
+		dev_err(ctx->dev->dev, "rtkve_dec_try_fmt_out fail");
+		goto exit;
+	}
+
+	ctx->src_fmt.width = pix_mp->width;
+	ctx->src_fmt.height = pix_mp->height;
+	ctx->src_fmt.pixelformat = pix_mp->pixelformat;
+	ctx->src_fmt.field = pix_mp->field;
+	ctx->src_fmt.flags = pix_mp->flags;
+	ctx->src_fmt.num_planes = pix_mp->num_planes;
+	for (i = 0; i < ctx->src_fmt.num_planes; i++) {
+		ctx->src_fmt.plane_fmt[i].bytesperline =
+			pix_mp->plane_fmt[i].bytesperline;
+		ctx->src_fmt.plane_fmt[i].sizeimage =
+			pix_mp->plane_fmt[i].sizeimage;
+	}
+
+	ctx->colorspace = pix_mp->colorspace;
+	ctx->ycbcr_enc = pix_mp->ycbcr_enc;
+	ctx->quantization = pix_mp->quantization;
+	ctx->xfer_func = pix_mp->xfer_func;
+
+	//rtkve_update_pix_fmt(ctx, &ctx->dst_fmt,
+	//	pix_mp->width, pix_mp->height);
+exit:
+	return ret;
+}
+
+static int rtkve_enc_g_fmt_out(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.[+] ctx:0x%px\n",
+        __LINE__, __func__, ctx);
+	pix_mp->width = ctx->src_fmt.width;
+	pix_mp->height = ctx->src_fmt.height;
+	pix_mp->pixelformat = ctx->src_fmt.pixelformat;
+	pix_mp->field = ctx->src_fmt.field;
+	pix_mp->flags = ctx->src_fmt.flags;
+	pix_mp->num_planes = ctx->src_fmt.num_planes;
+	for (i = 0; i < pix_mp->num_planes; i++) {
+		pix_mp->plane_fmt[i].bytesperline =
+			ctx->src_fmt.plane_fmt[i].bytesperline;
+		pix_mp->plane_fmt[i].sizeimage =
+			ctx->src_fmt.plane_fmt[i].sizeimage;
+	}
+
+	pix_mp->colorspace = ctx->colorspace;
+	pix_mp->ycbcr_enc = ctx->ycbcr_enc;
+	pix_mp->quantization = ctx->quantization;
+	pix_mp->xfer_func = ctx->xfer_func;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.[-]\n",
+        __LINE__, __func__);
+	return 0;
+}
+
+static int rtkve_enc_reqbufs(struct file *file, void *priv,
+			     struct v4l2_requestbuffers *rb)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(priv);
+	int ret = 0;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.[+] ctx:0x%px.type:%s.count:%d\n",
+        __LINE__, __func__,
+		ctx, v4l2_type_names[rb->type], rb->count);
+
+	ret = v4l2_m2m_ioctl_reqbufs(file, priv, rb);
+	if (ret) {
+		goto exit;
+	}
+
+	if (V4L2_TYPE_IS_OUTPUT(rb->type)) {
+		ctx->reqbuf_out = rb->count;
+	}
+	else {
+		ctx->reqbuf_cap = rb->count;
+	}
+
+	if (ctx->ops->reqbufs) {
+		ret = ctx->ops->reqbufs(ctx, rb);
+		if (ret) {
+			dev_err(ctx->dev->dev, "%d.%s.reqbufs() fail.ctx:0x%px\n",
+				__LINE__, __func__, ctx);
+		}
+	}
+
+exit:
+	dev_dbg(ctx->dev->dev, "%d.%s.[-] ret:%d\n",
+        __LINE__, __func__, ret);
+	return ret;
+}
+
+static int rtkve_enc_subscribe_event(struct v4l2_fh *fh,
+				     const struct v4l2_event_subscription *sub)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(fh);
+	dev_dbg(ctx->dev->dev, "%d.%s.ctx:0x%px.type:%d\n",
+        __LINE__, __func__,
+		ctx, sub->type);
+
+	switch (sub->type) {
+	case V4L2_EVENT_EOS:
+		return v4l2_event_subscribe(fh, sub, 0, NULL);
+	default:
+		return v4l2_ctrl_subscribe_event(fh, sub);
+	}
+
+	return 0;
+}
+
+static int rtkve_enc_cmd(struct file *file, void *priv,
+			 struct v4l2_encoder_cmd *cmd)
+{
+	struct rtkve1enc_ctx *ctx = v4l2fh_to_ctx(priv);
+	struct v4l2_m2m_ctx *m2m_ctx = ctx->v4l2_fh.m2m_ctx;
+	struct vb2_v4l2_buffer *buf;
+	int ret;
+
+	dev_dbg(ctx->dev->dev, "%d.%s.[+] ctx:0x%px.cmd:%d\n",
+        __LINE__, __func__,
+		ctx, cmd->cmd);
+
+	ret = v4l2_m2m_ioctl_try_encoder_cmd(file, priv, cmd);
+	if (ret)
+		return ret;
+
+	if (!vb2_is_streaming(v4l2_m2m_get_src_vq(m2m_ctx)) ||
+	    !vb2_is_streaming(v4l2_m2m_get_dst_vq(m2m_ctx)))
+		return 0;
+
+	switch (cmd->cmd) {
+	case V4L2_ENC_CMD_STOP:
+		buf = v4l2_m2m_last_src_buf(m2m_ctx);
+		if (buf) {
+			buf->flags |= V4L2_BUF_FLAG_LAST;
+			ctx->eos = true;
+		} else {
+			struct vb2_queue *dst_vq;
+
+			dst_vq = v4l2_m2m_get_vq(m2m_ctx,
+						 V4L2_BUF_TYPE_VIDEO_CAPTURE);
+			dst_vq->last_buffer_dequeued = true;
+			wake_up(&dst_vq->done_wq);
+		}
+		break;
+	case V4L2_ENC_CMD_START:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	dev_dbg(ctx->dev->dev, "%d.%s.[-] ctx:0x%px.cmd:%d\n",
+        __LINE__, __func__,
+		ctx, cmd->cmd);
+	return 0;
+}
+
+struct v4l2_ioctl_ops rtkve1enc_ioctl_ops = {
+	.vidioc_querycap = rtkve_enc_querycap,
+	.vidioc_enum_framesizes = rtkve_enc_enum_framesizes,
+
+	.vidioc_s_parm = rtkve_enc_s_parm,
+	.vidioc_g_parm = rtkve_enc_g_parm,
+
+	.vidioc_enum_fmt_vid_cap = rtkve_enc_enum_fmt_cap,
+	.vidioc_s_fmt_vid_cap_mplane = rtkve_enc_s_fmt_cap,
+	.vidioc_g_fmt_vid_cap_mplane = rtkve_enc_g_fmt_cap,
+	.vidioc_try_fmt_vid_cap_mplane = rtkve_enc_try_fmt_cap,
+
+	.vidioc_enum_fmt_vid_out = rtkve_enc_enum_fmt_out,
+	.vidioc_s_fmt_vid_out_mplane = rtkve_enc_s_fmt_out,
+	.vidioc_g_fmt_vid_out_mplane = rtkve_enc_g_fmt_out,
+	.vidioc_try_fmt_vid_out_mplane = rtkve_enc_try_fmt_out,
+
+	.vidioc_reqbufs = rtkve_enc_reqbufs,
+	.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,
+	.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,
+	.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,
+	.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,
+	.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,
+	.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,
+
+	.vidioc_streamon = v4l2_m2m_ioctl_streamon,
+	.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,
+
+	.vidioc_subscribe_event = rtkve_enc_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+
+	.vidioc_encoder_cmd = rtkve_enc_cmd,
+	.vidioc_try_encoder_cmd = v4l2_m2m_ioctl_try_encoder_cmd,
+};
+#if 0
+static void rtkve_enc_device_run(void *priv)
+{
+	struct vpu_instance *inst = priv;
+
+	queue_work(inst->dev->encode_workqueue, &inst->encode_work);
+}
+
+static int rtkve_enc_job_ready(void *priv)
+{
+	struct vpu_instance *inst = priv;
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "[%d]%s: state %d\n", inst->id, __func__,
+		inst->state);
+
+	if (inst->state == VPU_INST_STATE_STOP && inst->eos)
+		ret = 0;
+	else
+		ret = 1;
+
+	return ret;
+}
+
+static void rtkve_enc_job_abort(void *priv)
+{
+	struct vpu_instance *inst = priv;
+	struct vpu_device *dev = inst->dev;
+	const struct rtkve_match_data *dec_pdata = dev->rtkve_mdata;
+
+	dev_dbg(inst->dev->dev, "[%d]%s: state %d\n", inst->id, __func__,
+		inst->state);
+
+	dec_pdata->stop_decode(inst);
+}
+
+static const struct v4l2_m2m_ops rtkve_enc_m2m_ops = {
+	.device_run = rtkve_enc_device_run,
+	.job_ready = rtkve_enc_job_ready,
+	.job_abort = rtkve_enc_job_abort,
+};
+
+int rtkve_enc_init_m2m_dev(struct vpu_device *dev)
+{
+	dev->m2m_dev = v4l2_m2m_init(&rtkve_enc_m2m_ops);
+	if (IS_ERR(dev->m2m_dev)) {
+		dev_err(dev->dev, "v4l2_m2m_init fail: %ld\n",
+			PTR_ERR(dev->m2m_dev));
+		return PTR_ERR(dev->m2m_dev);
+	}
+
+	return 0;
+}
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_config.h
@@ -0,0 +1,61 @@
+//------------------------------------------------------------------------------
+// File: config.h
+//
+// Copyright (c) 2006, Chips & Media.  All rights reserved.
+// This file should be modified by some developers of C&M according to product version.
+//------------------------------------------------------------------------------
+#ifndef __CONFIG_H__
+#define __CONFIG_H__
+
+#define PLATFORM_LINUX
+#if defined(_MSC_VER)
+#include <windows.h>
+#define inline _inline
+#elif defined(__GNUC__)
+#elif defined(__ARMCC__)
+#else
+#error "Unknown compiler."
+#endif
+
+#define API_VERSION_MAJOR 5
+#define API_VERSION_MINOR 5
+#define API_VERSION_PATCH 38
+#define API_VERSION                                                            \
+	((API_VERSION_MAJOR << 16) | (API_VERSION_MINOR << 8) |                \
+	 API_VERSION_PATCH)
+
+//------------------------------------------------------------------------------
+// COMMON
+//------------------------------------------------------------------------------
+
+// do not define BIT_CODE_FILE_PATH in case of multiple product support. because wave410 and coda980 has different firmware binary format.
+#define CORE_0_BIT_CODE_FILE_PATH "coda960.out" // for coda960
+#define CORE_1_BIT_CODE_FILE_PATH "/vendor/lib/fw/ve1.bin" // for coda980
+
+//------------------------------------------------------------------------------
+// OMX
+//------------------------------------------------------------------------------
+
+//------------------------------------------------------------------------------
+// CODA960
+//------------------------------------------------------------------------------
+#define SUPPORT_ENC_NV21
+
+//------------------------------------------------------------------------------
+// WAVE512
+//------------------------------------------------------------------------------
+#define NO_COMMAND_QUEUE
+
+//------------------------------------------------------------------------------
+// CUSTOMER
+//------------------------------------------------------------------------------
+#define FIX_SET_GET_RD_PTR_BUG
+
+#define USE_OS_SCHEDULE_YIELD
+
+#define FIX_PEDING_INSTANCE_CHECK_BUG
+#define USE_TIMESTAMP_FOR_MULTI_INSTANCE
+
+#define SUPPORT_GET_NAL_START_POS
+
+#endif /* __CONFIG_H__ */
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_decode.c
@@ -0,0 +1,651 @@
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+
+#include "ve1_v4l2.h"
+#include "debug.h"
+#include "vpu.h"
+#include "ve1_wrapper.h"
+#include "ve1_vpuapi.h"
+
+#define VE1_BITSTREAM_BUFFER_SIZE (8 * 1024 * 1024)
+#ifdef VPU_GET_CC
+extern int ve1_get_userdata(struct ve1_ctx *ctx, unsigned char *pBuf,
+			    unsigned int nBufSize);
+extern void ProcessCC(struct ve1_ctx *ctx, unsigned char *cc_buf,
+		      unsigned int cc_size, long long PTS, int decode_index,
+		      int display_index, int codec_type);
+extern bool cc_isCCReaderReady(void);
+#endif
+static void ve1_set_stream_end(struct ve1_ctx *ctx)
+{
+	int ret;
+	if ((ctx != NULL) && (ctx->decHandle != NULL) &&
+	    (ctx->streamEnd == 0)) {
+		ctx->streamEnd = 1;
+		ret = VE1_SetStreamEnd(ctx);
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"EOS.af VE1_SetStreamEnd.ret:%d.size:0.accuBsFeedBytes:%d\n",
+			ret, ctx->accuBsFeedBytes);
+	}
+}
+
+int ve1_fill_bitstream(struct ve1_ctx *ctx, uint8_t *buf, uint32_t len,
+		       uint64_t timestamp, uint32_t sequence)
+{
+	struct ve1_meta *meta;
+	unsigned long flags;
+	unsigned long curBsWrPtr = 0;
+	int ret = 0;
+
+	// check if bitstream buffer has available space to put new data
+	if (ve1_get_bitstream_payload(ctx) + len >= ctx->bitstream.size) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "ENOSPC.payload:%d + len:%d >= bs_bufsize:%d\n",
+			ve1_get_bitstream_payload(ctx), len, ctx->bitstream.size);
+		return -ENOSPC;
+	}
+	if (ctx->decHandle != NULL) {
+		VE1_DecGetRdWrPtr(ctx);
+		if (ctx->vpuBsRingRoom <= len) {
+			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "ENOSPC.vpuBsRingRoom:%d <= len:%d\n",
+				ctx->vpuBsRingRoom, len);
+			return -ENOSPC;
+		}
+	}
+	if (ctx->bGotNextField) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"ENOSPC.bWaitNextField.only update next field before continue decoding\n");
+		return -ENOSPC;
+	}
+	if (ctx->bPostponeUpBs) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "ENOSPC.bPostponeUpBs.postpone fill bs\n");
+		return -ENOSPC;
+	}
+	if (ctx->dpbFull && (!ctx->bWaitNextField)) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "ENOSPC.dpb full.postpone fill bs\n");
+		return -ENOSPC;
+	}
+	if (ctx->seqInited && (ctx->ve1DecState == VE1_STATE_DEC_SEQ_INIT_DONE)) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "ENOSPC.no update bs until SET_FB\n");
+		return -ENOSPC;
+	}
+
+	curBsWrPtr = ctx->bsWrPtr;
+
+	ret = VE1_DecUpdateBS((void *)ctx, buf, len);
+	if (ret < 0) {
+		ve1_err(VE1_LOGTAG,
+			"VE1_DecUpdateBS() fail.ret:%d.ctx:0x%px.buf:0x%px.len:%d\n",
+			ret, ctx, buf, len);
+		return -EFAULT;
+	} else if (ret == 0) {
+		meta = kmalloc(sizeof(*meta), GFP_KERNEL);
+		if (meta) {
+			meta->sequence = sequence;
+			meta->timestamp = timestamp;
+			meta->start = curBsWrPtr;
+			meta->end = ctx->bsWrPtr;
+			spin_lock_irqsave(&ctx->buffer_meta_lock, flags);
+			list_add_tail(&meta->list, &ctx->buffer_meta_list);
+			ctx->num_metas++;
+			spin_unlock_irqrestore(&ctx->buffer_meta_lock, flags);
+			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+				"num_metas:%d.sequence:%d.len:%d.timestamp:%lld.start:0x%x.end:0x%x\n",
+				ctx->num_metas, sequence, len, timestamp, meta->start,
+				meta->end);
+		}
+	}
+
+	return 0;
+}
+
+static void ve1_seq_end_work(struct work_struct *work)
+{
+	struct ve1_ctx *ctx = container_of(work, struct ve1_ctx, seq_end_work);
+	int ret;
+
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[+]\n");
+
+	mutex_lock(&ctx->ve1_mutex);
+
+	if (ctx->ve1DecState < VE1_STATE_DEC_OPENED) {
+		goto out;
+	}
+
+	ret = VE1_DecClose(ctx);
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+		"af VE1_DecClose.ret:%d\n", ret);
+
+	ret = VE1_DecDeInit(ctx);
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+		"af VE1_DecDeInit.ret:%d\n", ret);
+
+	ctx->seqInited = 0;
+	ctx->handle_eos_by = VE1_HANDLE_EOS_BY_NONE;
+	ctx->last_frame = 0;
+
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-]\n");
+out:
+	mutex_unlock(&ctx->ve1_mutex);
+}
+
+static int ve1_alloc_bitstream_buffer(struct ve1_ctx *ctx)
+{
+	int ret = 0;
+	unsigned long virt_addr = 0;
+	if (ctx->bitstream.paddr) {
+		return 0;
+	}
+
+	ctx->bitstream.size = VE1_BITSTREAM_BUFFER_SIZE;
+	ret = VE1_AllocateBitstreamBuffer(ctx->pdev, &ctx->bitstream.paddr,
+					  &virt_addr, ctx->bitstream.size,
+					  ctx->is_svp);
+	if (ret < 0) {
+		ve1_err(VE1_LOGTAG,
+			"ctx:0x%px.VE1_AllocateBitstreamBuffer() fail.ret:%d\n",
+			ctx, ret);
+		return -ENOMEM;
+	}
+	ctx->totIonAllocatedBytes += ctx->bitstream.size;
+	ctx->bitstream.vaddr = (void *)virt_addr;
+	ve1_info(
+		VE1_LOGTAG,
+		"ctx:0x%px.VE1_AllocateBitstreamBuffer() ok.bitstream(0x%px,%lx,%lx,%d).tot:%d\n",
+		ctx, ctx->bitstream.vaddr, ctx->bitstream.paddr,
+		ctx->bitstream.dma_buf, ctx->bitstream.size,
+		ctx->totIonAllocatedBytes);
+
+	ctx->bsRdPtr = ctx->bsWrPtr = ctx->bitstream.paddr;
+
+	return 0;
+}
+
+static void ve1_free_bitstream_buffer(struct ve1_ctx *ctx)
+{
+	if (ctx->bitstream.paddr == 0) {
+		return;
+	}
+
+	VE1_FreeBitstreamBuffer(ctx->pdev, (unsigned long)ctx->bitstream.vaddr,
+				ctx->bitstream.paddr, ctx->bitstream.size);
+	ctx->totIonAllocatedBytes -= ctx->bitstream.size;
+	memset(&ctx->bitstream, 0, sizeof(struct ve1_buf));
+	ve1_info(VE1_LOGTAG, "ctx:0x%px.VE1_FreeBitstreamBuffer() ok.tot:%d\n",
+		 ctx, ctx->totIonAllocatedBytes);
+
+	ctx->bsRdPtr = ctx->bsWrPtr = 0;
+}
+
+static int rtkve1_get_meta(struct ve1_ctx *ctx, struct ve1_meta *result)
+{
+	int ret = 0;
+	struct ve1_meta *meta = NULL;
+	unsigned long flags;
+
+	if ((ctx == NULL) || (result == NULL)) {
+		ve1_err(VE1_LOGTAG, "ctx == NULL || result == NULL\n");
+		return -1;
+	}
+
+	spin_lock_irqsave(&ctx->buffer_meta_lock, flags);
+	if (!list_empty(&ctx->buffer_meta_list)) {
+		meta = list_first_entry(&ctx->buffer_meta_list,
+				struct ve1_meta, list);
+		*result = *meta;
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"timestamp:%lld.start:0x%x.end:0x%x.num_metas:%d.ve1DecState:%d.vpuRdPtr:0x%x\n",
+			meta->timestamp,
+			meta->start,
+			meta->end,
+			ctx->num_metas,
+			ctx->ve1DecState,
+			ctx->vpuRdPtr);
+		if ((ctx->ve1DecState <= VE1_STATE_DEC_SEQ_INIT_DONE) && (ctx->vpuRdPtr != meta->end)) {
+			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+				"processing seq init, vpuRdPtr:0x%x != fill_bs_end:0x%x, bs may contain frame, let decoding to consume meta\n",
+				ctx->vpuRdPtr,
+				meta->end);
+		}
+		else {
+			ctx->num_metas--;
+			list_del(&meta->list);
+			kfree(meta);
+			meta = NULL;
+		}
+	} else {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "buffer_meta_list is empty\n");
+		ret = -1;
+	}
+	spin_unlock_irqrestore(&ctx->buffer_meta_lock, flags);
+
+	return ret;
+}
+
+static int __ve1_decoder_seq_init(struct ve1_ctx *ctx)
+{
+	int ret;
+	struct ve1_meta meta;
+
+	lockdep_assert_held(&ctx->ve1_mutex);
+
+	if (ctx == NULL || ctx->decHandle == NULL) {
+		ve1_err(VE1_LOGTAG, "ctx == NULL || ctx->decHandle == NULL\n");
+		return -EINVAL;
+	}
+
+	ret = VE1_DecSeqInit(ctx);
+	if (ret < 0) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "VE1_DecSeqInit() fail\n");
+		ret = -EINVAL;
+	}
+	else {
+		ret = 0;
+	}
+
+	// consume ve1_meta of out_buf which used to parse headers
+	rtkve1_get_meta(ctx, &meta);
+
+	return ret;
+}
+
+static void ve1_dec_seq_init_work(struct work_struct *work)
+{
+	struct ve1_ctx *ctx = container_of(work, struct ve1_ctx, seq_init_work);
+	int ret;
+
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[+]\n");
+
+	mutex_lock(&ctx->ve1_mutex);
+
+	if (ctx->seqInited == 1) {
+		goto out;
+	}
+
+	ret = __ve1_decoder_seq_init(ctx);
+	if (ret < 0) {
+		//ve1_info(VE1_LOGTAG, "__ve1_decoder_seq_init() fail.ret:%d\n",
+		//	 ret);
+		goto out;
+	}
+	ctx->seqChangeDone = 0;
+
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-]\n");
+out:
+	mutex_unlock(&ctx->ve1_mutex);
+}
+
+static int ve1_start_decoding(struct ve1_ctx *ctx)
+{
+	int ret;
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[+]\n");
+
+	mutex_lock(&ctx->ve1_mutex);
+	if (ctx->bitstream.paddr == 0) {
+		ret = ve1_alloc_bitstream_buffer(ctx);
+		if (ret < 0) {
+			ve1_err(VE1_LOGTAG,
+				"[-] ve1_alloc_bitstream_buffer() fail.ret:%d\n",
+				ret);
+			goto out;
+		}
+	}
+	mutex_unlock(&ctx->ve1_mutex);
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-] ret:%d\n", ret);
+	return 0;
+out:
+	mutex_unlock(&ctx->ve1_mutex);
+	return ret;
+}
+
+static int ve1_prepare_decode(struct ve1_ctx *ctx)
+{
+	int ret = 0;
+
+	// handle EOS
+	if (ctx->handle_eos_by == VE1_HANDLE_EOS_BY_PREPARE_RUN) {
+		ctx->handle_eos_by = VE1_HANDLE_EOS_SET_END;
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"call ve1_set_stream_end()\n");
+		ve1_set_stream_end(ctx);
+	}
+
+	ret = VE1_DecStartDecode(ctx);
+	if (ret < 0) {
+		ve1_err(VE1_LOGTAG, "VE1_DecStartDecode() fail\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void rtkve1_add_displayble_frame_to_list(struct ve1_ctx *ctx)
+{
+	unsigned long flags;
+	struct ve1_displayable_frame *frame;
+	int frameIndex = 0;
+	PhysicalAddress framePhysAddr = 0;
+	unsigned long frameSize = 0;
+	void *tmp_dpb = NULL;
+	struct rtkve1_dpb_t *dpb = NULL;
+
+	if (ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "ctx == NULL\n");
+		return;
+	}
+
+	frameIndex = ctx->lastIndexFrameDisplay;
+
+	if (frameIndex >= 0) {
+		framePhysAddr = ctx->lastDisplayFrmBufY;
+		frameSize = (((FrameBuffer *)ctx->fbUser) + frameIndex)->size;
+		tmp_dpb = rtkve1_find_dpb((void *)ctx, framePhysAddr, ctx->currSequenceNo);
+		if (!tmp_dpb) {
+			ve1_err(VE1_LOGTAG,
+				"can't find framePhysAddr:0x%x in dpb[]\n",
+				framePhysAddr);
+			return;
+		}
+		dpb = (struct rtkve1_dpb_t *)tmp_dpb;
+
+		// save displayable frame info to displayable_frame_list
+		spin_lock_irqsave(&ctx->displayable_frame_lock, flags);
+		frame = kzalloc(sizeof(struct ve1_displayable_frame),
+				GFP_KERNEL);
+		if (frame) {
+			VE1_GetDisplayFrameInfo(ctx, frame);
+			frame->regIndex = frameIndex;
+			frame->dpb_paddr = framePhysAddr;
+			frame->vb2_v4l2_buf = dpb->vb2_v4l2_buf;
+			frame->size = frameSize;
+			frame->timestamp = ctx->frame_metas[frameIndex].timestamp;
+			frame->timecode = ctx->frame_metas[frameIndex].timecode;
+			memset(&frame->timecode, 0, sizeof(struct v4l2_timecode));
+			frame->sequenceNo = ctx->currSequenceNo;
+			ctx->cntAddToList++;
+			list_add_tail(&frame->list,
+				      &ctx->displayable_frame_list);
+			ve1_dbg(VPU_DBG_VE1_DIS, VE1_LOGTAG,
+				"add displayable_frame_list.regIndex:%d.dpb_paddr:0x%x.vb2_v4l2_buf:0x%px.size:%ld.timestamp:%lld.POC:%d.last_frame:%d.sequenceNo:%d.cnt:%u\n",
+				frameIndex, frame->dpb_paddr,
+				frame->vb2_v4l2_buf, frame->size,
+				frame->timestamp, frame->POC,
+				frame->last_frame, frame->sequenceNo,
+				ctx->cntAddToList);
+
+			// check if timestame back track
+			if ((frame->timestamp <= ctx->lastFrameTimestamp) &&
+			    (ctx->lastFrameTimestamp != 0)) {
+				ve1_dbg(VPU_DBG_VE1_DIS, VE1_LOGTAG,
+					"timestamp back track.curr:%lld(pts:%lld).last:%lld(pts:%lld)\n",
+					frame->timestamp,
+					div_u64((frame->timestamp * 9), 10000),
+					ctx->lastFrameTimestamp,
+					div_u64((ctx->lastFrameTimestamp * 9),
+						10000));
+			}
+			ctx->lastFrameTimestamp = frame->timestamp;
+		} else {
+			ve1_err(VE1_LOGTAG, "kzalloc frame fail\n");
+		}
+		spin_unlock_irqrestore(&ctx->displayable_frame_lock, flags);
+	} else if ((ctx->lastIndexFrameDisplay == -1) &&
+		   (!ctx->seqChangeDone)) {
+		struct ve1_displayable_frame *frame;
+		spin_lock_irqsave(&ctx->displayable_frame_lock, flags);
+		if (!list_empty(&ctx->displayable_frame_list)) {
+			frame = list_last_entry(&ctx->displayable_frame_list,
+						struct ve1_displayable_frame, list);
+			ve1_dbg(VPU_DBG_VE1_DIS, VE1_LOGTAG,
+				"last frame in displayable_frame_list.regIndex:%d.dpb_paddr:0x%x.vb2_v4l2_buf:0x%px.timestamp:%lld\n",
+				frame->regIndex, frame->dpb_paddr, frame->vb2_v4l2_buf,
+				frame->timestamp);
+			frame->last_frame = 1;
+			if (frame->isDequeued)
+			{
+				ctx->last_frame = 1;
+				ctx->lastFrmReportedAfFrmDqSeqNo = ctx->currSequenceNo;
+				ve1_info(VE1_LOGTAG, "set ctx->last_frame=%d, ctx->lastFrmReportedAfFrmDqSeqNo:%d\n",
+					ctx->last_frame, ctx->lastFrmReportedAfFrmDqSeqNo);
+			}
+		}
+		else {
+			ctx->last_frame = 1;
+			ctx->lastFrmReportedAfFrmDqSeqNo = ctx->currSequenceNo;
+			ve1_info(VE1_LOGTAG, "set ctx->last_frame=%d, ctx->lastFrmReportedAfFrmDqSeqNo:%d\n",
+				ctx->last_frame, ctx->lastFrmReportedAfFrmDqSeqNo);
+		}
+		spin_unlock_irqrestore(&ctx->displayable_frame_lock, flags);
+	}
+}
+EXPORT_SYMBOL(rtkve1_add_displayble_frame_to_list);
+
+void ve1_show_displayable_frame_list(struct ve1_ctx *ctx)
+{
+	unsigned long flags;
+	struct ve1_displayable_frame *frame;
+
+	if (ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "ctx == NULL\n");
+		return;
+	}
+
+	spin_lock_irqsave(&ctx->displayable_frame_lock, flags);
+	if (!list_empty(&ctx->displayable_frame_list)) {
+		list_for_each_entry (frame, &ctx->displayable_frame_list,
+				     list) {
+			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+				"iterate displayable_frame_list.regIndex:%d.dpb_paddr:0x%x.vb2_v4l2_buf:0x%px.isDequeued:%d.timestamp:0x%llx.sequenceNo:%d.last_frame:%d\n",
+				frame->regIndex, frame->dpb_paddr,
+				frame->vb2_v4l2_buf, frame->isDequeued,
+				frame->timestamp, frame->sequenceNo,
+				frame->last_frame);
+		}
+	}
+	spin_unlock_irqrestore(&ctx->displayable_frame_lock, flags);
+}
+EXPORT_SYMBOL(ve1_show_displayable_frame_list);
+
+static int ve1_finish_decode(struct ve1_ctx *ctx)
+{
+	int ret = 0;
+	struct ve1_meta meta;
+
+	ret = VE1_DecPicDone(ctx);
+	if (ret < 0) {
+		ve1_err(VE1_LOGTAG, "VE1_DecPicDone() fail\n");
+		return ret;
+	}
+
+	if (ctx->lastIndexFrameDecoded == -2) {
+		// when BS_MODE_PIC_END, indexFrameDecoded==-2 means ve1 can't decode a frame on current valid bitstream
+		// it should consume ve1_meta of out_buf
+		rtkve1_get_meta(ctx, &meta);
+	}
+
+	if ((ctx->lastIndexFrameDecoded >= 0) && (!ctx->noshowframe)) {
+		rtkve1_get_meta(ctx, &meta);
+		ctx->frame_metas[ctx->lastIndexFrameDecoded] = meta;
+#ifdef VPU_GET_CC
+		if ((ctx->userDataEnable) && (ctx->pUserDataSrcBuf != NULL) &&
+		    (ctx->lastIndexFrameDecoded >= 0)) {
+			unsigned int actualUserDataSize = 0;
+			DecOpenParam *pDecOp;
+
+			pDecOp = (DecOpenParam *)ctx->decOP;
+			//call ProcessCC() here
+			if (pDecOp->bitstreamFormat == STD_MPEG2) {
+				if (cc_isCCReaderReady()) {
+					if (ctx->is_svp) {
+						actualUserDataSize =
+							USER_DATA_SRC_BUF_SIZE;
+					} else {
+						memset(ctx->pUserDataSrcBuf, 0,
+						       USER_DATA_SRC_BUF_SIZE);
+						actualUserDataSize = ve1_get_userdata(
+							ctx,
+							ctx->pUserDataSrcBuf,
+							USER_DATA_SRC_BUF_SIZE);
+#if defined(VE1_CHECK_USERDATA_MD5_EN)
+						if (actualUserDataSize > 0) {
+							ve1_md5_hash(
+								ve1_md5_digest,
+								VE1_MD5_DIGEST_SIZE,
+								(char *)ctx
+									->pUserDataSrcBuf,
+								actualUserDataSize);
+							ve1_dbg(VPU_DBG_VE1_DEC,
+								VE1_WRAPPER_TAG,
+								"%d.userdata size:%d.MD5:0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
+								ctx->decodedFrmNum,
+								actualUserDataSize,
+								ve1_md5_digest[0],
+								ve1_md5_digest[1],
+								ve1_md5_digest[2],
+								ve1_md5_digest[3],
+								ve1_md5_digest[4],
+								ve1_md5_digest[5],
+								ve1_md5_digest[6],
+								ve1_md5_digest[7],
+								ve1_md5_digest[8],
+								ve1_md5_digest[9],
+								ve1_md5_digest
+									[10],
+								ve1_md5_digest
+									[11],
+								ve1_md5_digest
+									[12],
+								ve1_md5_digest
+									[13],
+								ve1_md5_digest
+									[14],
+								ve1_md5_digest
+									[15]);
+						}
+#endif
+					}
+
+					ProcessCC(
+						ctx,
+						(unsigned char *)
+							ctx->pUserDataSrcBuf,
+						actualUserDataSize,
+						ctx->frame_metas
+							[ctx->lastIndexFrameDecoded]
+								.timestamp,
+						ctx->lastIndexFrameDecoded,
+						ctx->lastIndexFrameDisplay,
+						ENUM_CC_MPGE2);
+				}
+			} else if ((pDecOp->bitstreamFormat == STD_AVC)) {
+				if (cc_isCCReaderReady()) {
+					if (ctx->is_svp) {
+						actualUserDataSize =
+							USER_DATA_SRC_BUF_SIZE;
+					} else {
+						memset(ctx->pUserDataSrcBuf, 0,
+						       USER_DATA_SRC_BUF_SIZE);
+						actualUserDataSize = ve1_get_userdata(
+							ctx,
+							ctx->pUserDataSrcBuf,
+							USER_DATA_SRC_BUF_SIZE);
+#if defined(VE1_CHECK_USERDATA_MD5_EN)
+						if (actualUserDataSize > 0) {
+							ve1_md5_hash(
+								ve1_md5_digest,
+								VE1_MD5_DIGEST_SIZE,
+								(char *)ctx
+									->pUserDataSrcBuf,
+								actualUserDataSize);
+							ve1_dbg(VPU_DBG_VE1_DEC,
+								VE1_WRAPPER_TAG,
+								"%d.userdata size:%d.MD5:0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
+								ctx->decodedFrmNum,
+								actualUserDataSize,
+								ve1_md5_digest[0],
+								ve1_md5_digest[1],
+								ve1_md5_digest[2],
+								ve1_md5_digest[3],
+								ve1_md5_digest[4],
+								ve1_md5_digest[5],
+								ve1_md5_digest[6],
+								ve1_md5_digest[7],
+								ve1_md5_digest[8],
+								ve1_md5_digest[9],
+								ve1_md5_digest
+									[10],
+								ve1_md5_digest
+									[11],
+								ve1_md5_digest
+									[12],
+								ve1_md5_digest
+									[13],
+								ve1_md5_digest
+									[14],
+								ve1_md5_digest
+									[15]);
+						}
+#endif
+					}
+
+					ProcessCC(
+						ctx,
+						(unsigned char *)
+							ctx->pUserDataSrcBuf,
+						actualUserDataSize,
+						ctx->frame_metas
+							[ctx->lastIndexFrameDecoded]
+								.timestamp,
+						ctx->lastIndexFrameDecoded,
+						ctx->lastIndexFrameDisplay,
+						ENUM_CC_H264);
+				}
+			}
+		}
+#endif
+	}
+
+	rtkve1_add_displayble_frame_to_list(ctx);
+
+	ret = 1; // defaultly, return 1 to let ve1_pic_run_work() queue_work pic_run_work
+
+	if ((ctx->lastIndexFrameDecoded == -1) &&
+	    (ctx->lastIndexFrameDisplay == -3 ||
+	     ctx->lastIndexFrameDisplay == -1)) {
+		ctx->dpbFull = 1;
+		// DBP full happened, return 0 to let ve1_pic_run_work() not queue_work pic_run_work
+		// instead, ve1_cap_qbuf() queue_work pic_run_work
+		ret = 0;
+	} else if (ctx->lastIndexFrameDecoded != -1) {
+		ctx->dpbFull = 0;
+	}
+
+	if (ctx->lastIndexFrameDisplay == -1) {
+		// decode finish, no more queue_work pic_run_work
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static void ve1_release(struct ve1_ctx *ctx)
+{
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[+]\n");
+	mutex_lock(&ctx->ve1_mutex);
+	ve1_free_bitstream_buffer(ctx);
+	mutex_unlock(&ctx->ve1_mutex);
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-]\n");
+}
+
+const struct ve1_ctx_ops ve1_decode_ops = {
+	.queue_init = NULL /*ve1_decoder_queue_init*/,
+	.reqbufs = NULL /*ve1_decoder_reqbufs*/,
+	.start_streaming = ve1_start_decoding,
+	.prepare_run = ve1_prepare_decode,
+	.finish_run = ve1_finish_decode,
+	.seq_init_work = ve1_dec_seq_init_work,
+	.seq_end_work = ve1_seq_end_work,
+	.release = ve1_release,
+};
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_mem.c
@@ -0,0 +1,324 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/ioctl.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/file.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/fdtable.h>
+#include <linux/syscalls.h>
+#include <linux/export.h>
+#include <linux/dma-map-ops.h>
+
+#include "ve1_mem.h"
+#include "ve1_mem_uapi.h"
+#include "ve1_mem_compat.h"
+
+#define VE1_MEM_TAG "[VE1_MEM]"
+
+#define ve1mem_printk(level, tag, fmt, arg...)                                 \
+	printk(level "%s [%d]%s." fmt, tag, __LINE__, __func__, ##arg)
+
+#define ve1mem_err(tag, fmt, arg...) ve1mem_printk(KERN_ERR, tag, fmt, ##arg)
+
+#define ve1mem_warn(tag, fmt, arg...)                                          \
+	ve1mem_printk(KERN_WARNING, tag, fmt, ##arg)
+
+#define ve1mem_info(tag, fmt, arg...) ve1mem_printk(KERN_INFO, tag, fmt, ##arg)
+
+#define ve1mem_dbg(tag, fmt, arg...)
+
+static DEFINE_MUTEX(ve1_mem_lock);
+static ve1_mem_reg_entry_t *ve1_mem_reg_head;
+static int ve1_mem_reg_count;
+
+void ve1_mem_list(void)
+{
+	ve1_mem_reg_entry_t *curr = NULL;
+	curr = ve1_mem_reg_head;
+	while (curr != NULL) {
+		ve1mem_dbg(
+			VE1_MEM_TAG,
+			"curr:0x%px.phys_addr:0x%lx.virt_addr:0x%px.size:%ld.dmabuf:0x%px.next:0x%px\n",
+			curr, curr->phys_addr, curr->addr, curr->size,
+			curr->dmabuf, curr->next);
+		curr = curr->next;
+	}
+}
+
+void ve1_mem_reg_add(ve1_mem_reg_entry_t *entry)
+{
+	mutex_lock(&ve1_mem_lock);
+	ve1_mem_list();
+	ve1mem_dbg(VE1_MEM_TAG,
+		   "entry:0x%px.phys_addr:0x%lx.virt_addr:0x%px.size:%ld\n",
+		   entry, entry->phys_addr, entry->addr, entry->size);
+	entry->next = ve1_mem_reg_head;
+	ve1_mem_reg_head = entry;
+	ve1_mem_reg_count++;
+	mutex_unlock(&ve1_mem_lock);
+}
+
+ve1_mem_reg_entry_t *ve1_mem_reg_remove(unsigned long phys_addr)
+{
+	ve1_mem_reg_entry_t *prev = NULL;
+	ve1_mem_reg_entry_t *curr = NULL;
+
+	mutex_lock(&ve1_mem_lock);
+	ve1_mem_list();
+	curr = ve1_mem_reg_head;
+	while (curr != NULL) {
+		if (curr->phys_addr != phys_addr) {
+			prev = curr;
+			curr = curr->next;
+			continue;
+		}
+
+		if (prev == NULL) {
+			ve1_mem_reg_head = curr->next;
+		} else {
+			prev->next = curr->next;
+		}
+		ve1_mem_reg_count--;
+		ve1mem_dbg(
+			VE1_MEM_TAG,
+			"found.curr:0x%px.phys_addr:0x%lx.virt_addr:0x%px.size:%ld.dmabuf:0x%px\n",
+			curr, curr->phys_addr, curr->addr, curr->size,
+			curr->dmabuf);
+		mutex_unlock(&ve1_mem_lock);
+
+		return curr;
+	}
+	ve1mem_dbg(
+		VE1_MEM_TAG,
+		"fail.curr:0x%px.phys_addr:0x%lx.virt_addr:0x%px.size:%ld.dmabuf:0x%px\n",
+		curr, curr->phys_addr, curr->addr, curr->size, curr->dmabuf);
+	mutex_unlock(&ve1_mem_lock);
+	return NULL;
+}
+
+static int ve1_mem_dma_buf_attach(struct dma_buf *dmabuf,
+				  struct dma_buf_attachment *attach)
+{
+	struct ve1_mem_dma_buf_attachment *a;
+	ve1_mem_reg_entry_t *curr = dmabuf->priv;
+	struct device *dev = curr->dev;
+
+	int ret;
+
+	a = kzalloc(sizeof(*a), GFP_KERNEL);
+	if (!a)
+		return -ENOMEM;
+
+	ret = dma_get_sgtable(dev, &a->sgt, curr->addr, curr->phys_addr,
+			      curr->size);
+	if (ret < 0) {
+		ve1mem_err(VE1_MEM_TAG,
+			   "failed to get scatterlist from DMA API\n");
+		kfree(a);
+		return -EINVAL;
+	}
+
+	attach->priv = a;
+
+	return 0;
+}
+
+static void ve1_mem_dma_buf_detatch(struct dma_buf *dmabuf,
+				    struct dma_buf_attachment *attach)
+{
+	struct ve1_mem_dma_buf_attachment *a = attach->priv;
+
+	sg_free_table(&a->sgt);
+	kfree(a);
+}
+
+static struct sg_table *ve1_mem_map_dma_buf(struct dma_buf_attachment *attach,
+					    enum dma_data_direction dir)
+{
+	struct ve1_mem_dma_buf_attachment *a = attach->priv;
+	struct sg_table *table;
+	int ret;
+
+	table = &a->sgt;
+
+	ret = dma_map_sgtable(attach->dev, table, dir, 0);
+	if (ret)
+		table = ERR_PTR(ret);
+	return table;
+}
+
+static void ve1_mem_unmap_dma_buf(struct dma_buf_attachment *attach,
+				  struct sg_table *table,
+				  enum dma_data_direction dir)
+{
+	dma_unmap_sgtable(attach->dev, table, dir, 0);
+}
+
+static int ve1_mem_mmap(struct dma_buf *dmabuf, struct vm_area_struct *vma)
+{
+	ve1_mem_reg_entry_t *curr = dmabuf->priv;
+	size_t size = vma->vm_end - vma->vm_start;
+	struct device *dev = curr->dev;
+	dma_addr_t daddr = curr->phys_addr;
+	void *vaddr = curr->addr;
+
+	ve1mem_dbg(VE1_MEM_TAG, "daddr:0x%lx.vaddr:0x%px.size:%ld\n", daddr,
+		   vaddr, size);
+	return dma_mmap_coherent(dev, vma, vaddr, daddr, size);
+}
+
+static void ve1_mem_release(struct dma_buf *dmabuf)
+{
+}
+
+static const struct dma_buf_ops ve1_dma_buf_ops = {
+	.attach = ve1_mem_dma_buf_attach,
+	.detach = ve1_mem_dma_buf_detatch,
+	.map_dma_buf = ve1_mem_map_dma_buf,
+	.unmap_dma_buf = ve1_mem_unmap_dma_buf,
+	.mmap = ve1_mem_mmap,
+	.release = ve1_mem_release,
+};
+
+int ve1_mem_reg_fd(unsigned long phys_addr, unsigned long *offset,
+		   unsigned long *size)
+{
+	int ret_fd = -1;
+	ve1_mem_reg_entry_t *curr = NULL;
+	DEFINE_DMA_BUF_EXPORT_INFO(exp_info);
+
+	if (mutex_lock_interruptible(&ve1_mem_lock)) {
+		return -ERESTARTSYS;
+	}
+	curr = ve1_mem_reg_head;
+
+	while (curr != NULL) {
+		if ((phys_addr >= curr->phys_addr) &&
+		    (phys_addr < (curr->phys_addr + curr->size))) {
+			exp_info.ops = &ve1_dma_buf_ops;
+			exp_info.size = curr->size;
+			exp_info.flags = O_RDWR;
+			exp_info.priv = curr;
+			curr->dmabuf = dma_buf_export(&exp_info);
+			if (IS_ERR(curr->dmabuf)) {
+				ret_fd = PTR_ERR(curr->dmabuf);
+				goto out;
+			}
+
+			ret_fd = dma_buf_fd(curr->dmabuf, O_CLOEXEC);
+
+			if (offset) {
+				*offset = phys_addr - curr->phys_addr;
+			}
+
+			if (size) {
+				*size = curr->size;
+			}
+			ve1mem_dbg(
+				VE1_MEM_TAG,
+				"get ret_fd(%d,0x%lx,%ld).curr:0x%px.phys_addr:0x%lx.size:%ld.dmabuf:0x%px\n",
+				ret_fd, *offset, *size, curr, curr->phys_addr,
+				curr->size, curr->dmabuf);
+			break;
+		} else {
+			curr = curr->next;
+		}
+	}
+out:
+	mutex_unlock(&ve1_mem_lock);
+	return ret_fd;
+}
+
+static long ve1_mem_ioctl(struct file *filp, unsigned int cmd,
+			  unsigned long arg)
+{
+	long ret = -ENOTTY;
+	struct ve1_mem_fd_data data;
+
+	ve1mem_dbg(VE1_MEM_TAG, "[+] filp:0x%px.cmd:0x%x.arg:0x%lx\n", filp,
+		   cmd, arg);
+
+	switch (cmd) {
+	case VE1_MEM_IOC_EXPORT:
+		if (copy_from_user(&data, (void __user *)arg, sizeof(data))) {
+			ve1mem_err(VE1_MEM_TAG, "copy_from_user ERROR!\n");
+			break;
+		}
+
+		data.ret_fd = ve1_mem_reg_fd(data.phyAddr, &data.ret_offset,
+					     &data.ret_size);
+		ve1mem_dbg(
+			VE1_MEM_TAG,
+			"ret_fd:%d.phyAddr:0x%lx.ret_offset:%ld.ret_size:%ld\n",
+			data.ret_fd, data.phyAddr, data.ret_offset,
+			data.ret_size);
+
+		if (data.ret_fd < 0) {
+			break;
+		}
+
+		if (copy_to_user((void __user *)arg, &data, sizeof(data))) {
+			/* copy from rpc_mem_ioctl() in rpc_mem.c
+>------->------- * The usercopy failed, but we can't do much about it, as
+>------->------- * dma_buf_fd() already called fd_install() and made the
+>------->------- * file descriptor accessible for the current process. It
+>------->------- * might already be closed and dmabuf no longer valid when
+>------->------- * we reach this point. Therefore "leak" the fd and rely on
+>------->------- * the process exit path to do any required cleanup.
+>------->------- */
+			ve1mem_err(VE1_MEM_TAG,
+				   "copy_to_user failed! (phyAddr=0x%lx)\n",
+				   data.phyAddr);
+			break;
+		}
+		ret = 0;
+		break;
+	default:
+		ve1mem_err(VE1_MEM_TAG, "Unknown ioctl (cmd=0x%x)\n", cmd);
+		ret = -ENOTTY;
+		break;
+	}
+
+	ve1mem_dbg(VE1_MEM_TAG, "[-]\n");
+	return ret;
+}
+
+static const struct file_operations ve1_mem_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = ve1_mem_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = compat_ve1_mem_ioctl,
+#endif
+};
+
+static struct miscdevice ve1_mem_miscdev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "ve1_mem",
+	.fops = &ve1_mem_fops,
+	.parent = NULL,
+};
+
+int ve1_mem_device_create(void)
+{
+	int ret;
+
+	ret = misc_register(&ve1_mem_miscdev);
+	if (ret) {
+		ve1mem_err(VE1_MEM_TAG, "failed to register misc device\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+void ve1_mem_device_destroy(void)
+{
+	misc_deregister(&ve1_mem_miscdev);
+}
+
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_mem.h
@@ -0,0 +1,26 @@
+#ifndef _RTK_VE1_MEM_H
+#define _RTK_VE1_MEM_H
+
+#include <linux/types.h>
+#include <linux/dma-buf.h>
+
+typedef struct ve1_mem_reg_entry {
+	struct device *dev;
+	unsigned long phys_addr;
+	void *addr;
+	unsigned long size;
+	struct dma_buf *dmabuf;
+	struct ve1_mem_reg_entry *next;
+} ve1_mem_reg_entry_t;
+
+struct ve1_mem_dma_buf_attachment {
+	struct sg_table sgt;
+};
+
+void ve1_mem_reg_add(ve1_mem_reg_entry_t *entry);
+ve1_mem_reg_entry_t *ve1_mem_reg_remove(unsigned long phys_addr);
+
+int ve1_mem_device_create(void);
+void ve1_mem_device_destroy(void);
+
+#endif /* _RTK_VE1_MEM_H */
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_mem_compat.c
@@ -0,0 +1,69 @@
+#include <linux/compat.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/module.h>
+
+#include "ve1_mem_uapi.h"
+#include "ve1_mem_compat.h"
+
+struct compat_ve1_mem_fd_data {
+	compat_ulong_t phyAddr;
+	compat_ulong_t ret_offset;
+	compat_ulong_t ret_size;
+	compat_int_t ret_fd;
+};
+
+#define COMPAT_VE1_MEM_IOC_EXPORT                                              \
+	_IOWR(VE1_MEM_IOC_MAGIC, 0, struct compat_ve1_mem_fd_data)
+
+extern int ve1_mem_reg_fd(unsigned long phys_addr, unsigned long *offset,
+			  unsigned long *size);
+
+long compat_ve1_mem_ioctl(struct file *filp, unsigned int cmd,
+			  unsigned long arg)
+{
+	if (!filp->f_op->unlocked_ioctl)
+		return -ENOTTY;
+
+	switch (cmd) {
+	case COMPAT_VE1_MEM_IOC_EXPORT: {
+		struct compat_ve1_mem_fd_data data32;
+		struct ve1_mem_fd_data data;
+
+		if (copy_from_user(&data32, compat_ptr(arg), sizeof(data32)))
+			return -EFAULT;
+
+		data = (struct ve1_mem_fd_data){
+			.phyAddr = data32.phyAddr,
+			.ret_offset = data32.ret_offset,
+			.ret_size = data32.ret_size,
+			.ret_fd = data32.ret_fd,
+		};
+
+		data.ret_fd = ve1_mem_reg_fd(data.phyAddr, &data.ret_offset,
+					     &data.ret_size);
+		pr_debug(
+			"ret_fd:%d.phyAddr:0x%lx.ret_offset:%ld.ret_size:%ld\n",
+			data.ret_fd, data.phyAddr, data.ret_offset,
+			data.ret_size);
+
+		data32.phyAddr = data.phyAddr;
+		data32.ret_offset = data.ret_offset;
+		data32.ret_size = data.ret_size;
+		data32.ret_fd = data.ret_fd;
+
+		if (copy_to_user(compat_ptr(arg), &data32, sizeof(data32)))
+			return -EFAULT;
+
+		return 0;
+	}
+
+	default: {
+		printk(KERN_ERR "[COMPAT_VE1_MEM] No such IOCTL, cmd is %d\n",
+		       cmd);
+		return -ENOIOCTLCMD;
+	}
+	}
+}
+
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_mem_compat.h
@@ -0,0 +1,14 @@
+#ifndef _LINUX_COMPAT_VE1_MEM_H
+#define _LINUX_COMPAT_VE1_MEM_H
+
+#if IS_ENABLED(CONFIG_COMPAT)
+
+long compat_ve1_mem_ioctl(struct file *filp, unsigned int cmd,
+			  unsigned long arg);
+
+#else
+
+#define compat_ve1_mem_ioctl NULL
+
+#endif /* CONFIG_COMPAT */
+#endif /* _LINUX_COMPAT_VE1_MEM_H */
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_mem_uapi.h
@@ -0,0 +1,17 @@
+#ifndef _RTK_VE1_MEM_UAPI_H
+#define _RTK_VE1_MEM_UAPI_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+struct ve1_mem_fd_data {
+	unsigned long phyAddr;
+	unsigned long ret_offset;
+	unsigned long ret_size;
+	int ret_fd;
+};
+
+#define VE1_MEM_IOC_MAGIC 'R'
+#define VE1_MEM_IOC_EXPORT _IOWR(VE1_MEM_IOC_MAGIC, 0, struct ve1_mem_fd_data)
+
+#endif /* _RTK_VE1_MEM_UAPI_H */
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_mm.c
@@ -0,0 +1,580 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include "ve1_mm.h"
+
+#ifdef MM_DEBUG
+#ifdef _MSC_VER
+#define DPRINT(_fmt, ...) printf(_fmt, __VA_ARGS__)
+#else
+#define DPRINT(_fmt, ...) printf(_fmt, args...)
+#endif
+#else
+#define DPRINT(_fmt, ...)
+#endif
+
+#define P_ALLOC(_x) vmalloc(_x)
+#define P_FREE(_x) vfree(_x)
+#define ASSERT(_exp)                                                           \
+	if (!(_exp)) {                                                         \
+		pr_err("ASSERT at %s:%d\n", __FILE__, __LINE__);               \
+		while (1)                                                      \
+			;                                                      \
+	}
+#define HEIGHT(_tree) (_tree == NULL ? -1 : _tree->height)
+#define MAX(_a, _b) (_a >= _b ? _a : _b)
+
+typedef enum { LEFT, RIGHT } rotation_dir_t;
+
+typedef struct avl_node_data_struct {
+	int key;
+	page_t *page;
+} avl_node_data_t;
+
+static avl_node_t *make_avl_node(vmem_key_t key, page_t *page)
+{
+	avl_node_t *node = (avl_node_t *)P_ALLOC(sizeof(avl_node_t));
+	node->key = key;
+	node->page = page;
+	node->height = 0;
+	node->left = NULL;
+	node->right = NULL;
+
+	return node;
+}
+
+static int get_balance_factor(avl_node_t *tree)
+{
+	int factor = 0;
+	if (tree) {
+		factor = HEIGHT(tree->right) - HEIGHT(tree->left);
+	}
+
+	return factor;
+}
+
+/*
+* Left Rotation
+*
+*      A                      B
+*       \                    / \
+*        B         =>       A   C
+*       /  \                 \
+*      D    C                 D
+*
+*/
+static avl_node_t *rotation_left(avl_node_t *tree)
+{
+	avl_node_t *rchild;
+	avl_node_t *lchild;
+
+	if (tree == NULL)
+		return NULL;
+
+	rchild = tree->right;
+	if (rchild == NULL) {
+		return tree;
+	}
+
+	lchild = rchild->left;
+	rchild->left = tree;
+	tree->right = lchild;
+
+	tree->height = MAX(HEIGHT(tree->left), HEIGHT(tree->right)) + 1;
+	rchild->height = MAX(HEIGHT(rchild->left), HEIGHT(rchild->right)) + 1;
+
+	return rchild;
+}
+
+/*
+* Reft Rotation
+*
+*         A                  B
+*       \                  /  \
+*      B         =>       D    A
+*    /  \                     /
+*   D    C                   C
+*
+*/
+static avl_node_t *rotation_right(avl_node_t *tree)
+{
+	avl_node_t *rchild;
+	avl_node_t *lchild;
+
+	if (tree == NULL)
+		return NULL;
+
+	lchild = tree->left;
+	if (lchild == NULL)
+		return NULL;
+
+	rchild = lchild->right;
+	lchild->right = tree;
+	tree->left = rchild;
+
+	tree->height = MAX(HEIGHT(tree->left), HEIGHT(tree->right)) + 1;
+	lchild->height = MAX(HEIGHT(lchild->left), HEIGHT(lchild->right)) + 1;
+
+	return lchild;
+}
+
+static avl_node_t *do_balance(avl_node_t *tree)
+{
+	int bfactor = 0, child_bfactor; /* balancing factor */
+
+	bfactor = get_balance_factor(tree);
+
+	if (bfactor >= 2) {
+		child_bfactor = get_balance_factor(tree->right);
+		if (child_bfactor == 1 || child_bfactor == 0) {
+			tree = rotation_left(tree);
+		} else if (child_bfactor == -1) {
+			tree->right = rotation_right(tree->right);
+			tree = rotation_left(tree);
+		} else {
+			pr_err("invalid balancing factor: %d\n", child_bfactor);
+			ASSERT(0);
+			return NULL;
+		}
+	} else if (bfactor <= -2) {
+		child_bfactor = get_balance_factor(tree->left);
+		if (child_bfactor == -1 || child_bfactor == 0) {
+			tree = rotation_right(tree);
+		} else if (child_bfactor == 1) {
+			tree->left = rotation_left(tree->left);
+			tree = rotation_right(tree);
+		} else {
+			pr_err("invalid balancing factor: %d\n", child_bfactor);
+			ASSERT(0);
+			return NULL;
+		}
+	}
+
+	return tree;
+}
+static avl_node_t *unlink_end_node(avl_node_t *tree, int dir,
+				   avl_node_t **found_node)
+{
+	*found_node = NULL;
+	if (tree == NULL)
+		return NULL;
+
+	if (dir == LEFT) {
+		if (tree->left == NULL) {
+			*found_node = tree;
+			return NULL;
+		}
+	} else {
+		if (tree->right == NULL) {
+			*found_node = tree;
+			return NULL;
+		}
+	}
+
+	if (dir == LEFT) {
+		tree->left = unlink_end_node(tree->left, LEFT, found_node);
+		if (tree->left == NULL) {
+			tree->left = (*found_node)->right;
+			(*found_node)->left = NULL;
+			(*found_node)->right = NULL;
+		}
+	} else {
+		tree->right = unlink_end_node(tree->right, RIGHT, found_node);
+		if (tree->right == NULL) {
+			tree->right = (*found_node)->left;
+			(*found_node)->left = NULL;
+			(*found_node)->right = NULL;
+		}
+	}
+
+	tree->height = MAX(HEIGHT(tree->left), HEIGHT(tree->right)) + 1;
+
+	return do_balance(tree);
+}
+
+static avl_node_t *avltree_insert(avl_node_t *tree, vmem_key_t key,
+				  page_t *page)
+{
+	if (tree == NULL) {
+		tree = make_avl_node(key, page);
+	} else {
+		if (key >= tree->key) {
+			tree->right = avltree_insert(tree->right, key, page);
+		} else {
+			tree->left = avltree_insert(tree->left, key, page);
+		}
+	}
+
+	tree = do_balance(tree);
+
+	tree->height = MAX(HEIGHT(tree->left), HEIGHT(tree->right)) + 1;
+
+	return tree;
+}
+
+static avl_node_t *do_unlink(avl_node_t *tree)
+{
+	avl_node_t *node;
+	avl_node_t *end_node;
+	node = unlink_end_node(tree->right, LEFT, &end_node);
+	if (node) {
+		tree->right = node;
+	} else {
+		node = unlink_end_node(tree->left, RIGHT, &end_node);
+		if (node)
+			tree->left = node;
+	}
+
+	if (node == NULL) {
+		node = tree->right ? tree->right : tree->left;
+		end_node = node;
+	}
+
+	if (end_node) {
+		end_node->left =
+			(tree->left != end_node) ? tree->left : end_node->left;
+		end_node->right = (tree->right != end_node) ? tree->right :
+							      end_node->right;
+		end_node->height =
+			MAX(HEIGHT(end_node->left), HEIGHT(end_node->right)) +
+			1;
+	}
+
+	tree = end_node;
+
+	return tree;
+}
+
+static avl_node_t *avltree_remove(avl_node_t *tree, avl_node_t **found_node,
+				  vmem_key_t key)
+{
+	*found_node = NULL;
+	if (tree == NULL) {
+		DPRINT("failed to find key %d\n", (int)key);
+		return NULL;
+	}
+
+	if (key == tree->key) {
+		*found_node = tree;
+		tree = do_unlink(tree);
+	} else if (key > tree->key) {
+		tree->right = avltree_remove(tree->right, found_node, key);
+	} else {
+		tree->left = avltree_remove(tree->left, found_node, key);
+	}
+
+	if (tree)
+		tree->height = MAX(HEIGHT(tree->left), HEIGHT(tree->right)) + 1;
+
+	tree = do_balance(tree);
+
+	return tree;
+}
+
+void avltree_free(avl_node_t *tree)
+{
+	if (tree == NULL)
+		return;
+	if (tree->left == NULL && tree->right == NULL) {
+		P_FREE(tree);
+		return;
+	}
+
+	avltree_free(tree->left);
+	tree->left = NULL;
+	avltree_free(tree->right);
+	tree->right = NULL;
+	P_FREE(tree);
+}
+
+static avl_node_t *remove_approx_value(avl_node_t *tree, avl_node_t **found,
+				       vmem_key_t key)
+{
+	*found = NULL;
+	if (tree == NULL) {
+		return NULL;
+	}
+
+	if (key == tree->key) {
+		*found = tree;
+		tree = do_unlink(tree);
+	} else if (key > tree->key) {
+		tree->right = remove_approx_value(tree->right, found, key);
+	} else {
+		tree->left = remove_approx_value(tree->left, found, key);
+		if (*found == NULL) {
+			*found = tree;
+			tree = do_unlink(tree);
+		}
+	}
+	if (tree)
+		tree->height = MAX(HEIGHT(tree->left), HEIGHT(tree->right)) + 1;
+	tree = do_balance(tree);
+
+	return tree;
+}
+
+static void set_blocks_free(video_mm_t *mm, int pageno, int npages)
+{
+	int last_pageno = pageno + npages - 1;
+	int i;
+	page_t *page;
+	page_t *last_page;
+
+	ASSERT(npages);
+
+	if (last_pageno >= mm->num_pages) {
+		DPRINT("set_blocks_free: invalid last page number: %d\n",
+		       last_pageno);
+		ASSERT(0);
+		return;
+	}
+
+	for (i = pageno; i <= last_pageno; i++) {
+		mm->page_list[i].used = 0;
+		mm->page_list[i].alloc_pages = 0;
+		mm->page_list[i].first_pageno = -1;
+	}
+
+	page = &mm->page_list[pageno];
+	page->alloc_pages = npages;
+	last_page = &mm->page_list[last_pageno];
+	last_page->first_pageno = pageno;
+
+	mm->free_tree = avltree_insert(mm->free_tree, MAKE_KEY(npages, pageno),
+				       page); /*lint !e571 Suspicious cast*/
+}
+
+static void set_blocks_alloc(video_mm_t *mm, int pageno, int npages)
+{
+	int last_pageno = pageno + npages - 1;
+	int i;
+	page_t *page;
+	page_t *last_page;
+
+	if (last_pageno >= mm->num_pages) {
+		DPRINT("set_blocks_free: invalid last page number: %d\n",
+		       last_pageno);
+		ASSERT(0);
+		return;
+	}
+
+	for (i = pageno; i <= last_pageno; i++) {
+		mm->page_list[i].used = 1;
+		mm->page_list[i].alloc_pages = 0;
+		mm->page_list[i].first_pageno = -1;
+	}
+
+	page = &mm->page_list[pageno];
+	page->alloc_pages = npages;
+
+	last_page = &mm->page_list[last_pageno];
+	last_page->first_pageno = pageno;
+
+	mm->alloc_tree =
+		avltree_insert(mm->alloc_tree, MAKE_KEY(page->addr, 0), page);
+}
+
+int vmem_init(video_mm_t *mm, unsigned long addr, unsigned long size)
+{
+	int i;
+
+	mm->base_addr = (addr + (VMEM_PAGE_SIZE - 1)) & ~(VMEM_PAGE_SIZE - 1);
+	mm->mem_size = size & ~VMEM_PAGE_SIZE;
+	mm->num_pages = mm->mem_size / VMEM_PAGE_SIZE;
+	mm->page_list = (page_t *)P_ALLOC(mm->num_pages * sizeof(page_t));
+	mm->free_tree = NULL;
+	mm->alloc_tree = NULL;
+	mm->free_page_count = mm->num_pages;
+	mm->alloc_page_count = 0;
+
+	for (i = 0; i < mm->num_pages; i++) {
+		mm->page_list[i].pageno = i;
+		mm->page_list[i].addr = mm->base_addr + i * VMEM_PAGE_SIZE;
+		mm->page_list[i].alloc_pages = 0;
+		mm->page_list[i].used = 0;
+		mm->page_list[i].first_pageno = -1;
+	}
+
+	set_blocks_free(mm, 0, mm->num_pages);
+
+	return 0;
+}
+
+int vmem_exit(video_mm_t *mm)
+{
+	if (mm == NULL) {
+		DPRINT("vmem_exit: invalid handle\n");
+		return -1;
+	}
+
+	if (mm->free_tree) {
+		avltree_free(mm->free_tree);
+		mm->free_tree = NULL;
+	}
+	if (mm->alloc_tree) {
+		avltree_free(mm->alloc_tree);
+		mm->alloc_tree = NULL;
+	}
+
+	if (mm->page_list) {
+		P_FREE(mm->page_list);
+		mm->page_list = NULL;
+	}
+
+	return 0;
+}
+
+unsigned long vmem_alloc(video_mm_t *mm, int size, unsigned long pid)
+{
+	avl_node_t *node;
+	page_t *free_page;
+	int npages, free_size;
+	int alloc_pageno;
+	unsigned long ptr;
+
+	if (mm == NULL) {
+		DPRINT("vmem_alloc: invalid handle\n");
+		return (unsigned long)-1;
+	}
+
+	if (size <= 0)
+		return (unsigned long)-1;
+
+	npages = (size + VMEM_PAGE_SIZE - 1) / VMEM_PAGE_SIZE;
+
+	mm->free_tree = remove_approx_value(
+		mm->free_tree, &node,
+		MAKE_KEY(npages, 0)); /*lint !e571 Suspicious cast*/
+	if (node == NULL) {
+		return (unsigned long)-1;
+	}
+	free_page = node->page;
+	free_size = KEY_TO_VALUE(node->key);
+
+	alloc_pageno = free_page->pageno;
+	set_blocks_alloc(mm, alloc_pageno, npages);
+	if (npages != free_size) {
+		int free_pageno = alloc_pageno + npages;
+		set_blocks_free(mm, free_pageno, (free_size - npages));
+	}
+
+	P_FREE(node);
+
+	ptr = mm->page_list[alloc_pageno].addr;
+	mm->alloc_page_count += npages;
+	mm->free_page_count -= npages;
+
+	return ptr;
+}
+
+int vmem_free(video_mm_t *mm, unsigned long ptr, unsigned long pid)
+{
+	unsigned long addr;
+	avl_node_t *found;
+	page_t *page;
+	int pageno, prev_free_pageno, next_free_pageno;
+	int prev_size, next_size;
+	int merge_page_no, merge_page_size, free_page_size;
+
+	if (mm == NULL) {
+		DPRINT("vmem_free: invalid handle\n");
+		return -1;
+	}
+
+	addr = ptr;
+
+	mm->alloc_tree =
+		avltree_remove(mm->alloc_tree, &found, MAKE_KEY(addr, 0));
+	if (found == NULL) {
+		DPRINT("vmem_free: 0x%08x not found\n", addr);
+		return -1;
+	}
+
+	/* find previous free block */
+	page = found->page;
+	pageno = page->pageno;
+	free_page_size = page->alloc_pages;
+	prev_free_pageno = pageno - 1;
+	prev_size = -1;
+	if (prev_free_pageno >= 0) {
+		if (mm->page_list[prev_free_pageno].used == 0) {
+			prev_free_pageno =
+				mm->page_list[prev_free_pageno].first_pageno;
+			prev_size = mm->page_list[prev_free_pageno].alloc_pages;
+		}
+	}
+
+	/* find next free block */
+	next_free_pageno = pageno + page->alloc_pages;
+	next_free_pageno =
+		(next_free_pageno == mm->num_pages) ? -1 : next_free_pageno;
+	next_size = -1;
+	if (next_free_pageno >= 0) {
+		if (mm->page_list[next_free_pageno].used == 0) {
+			next_size = mm->page_list[next_free_pageno].alloc_pages;
+		}
+	}
+	P_FREE(found);
+
+	/* merge */
+	merge_page_no = page->pageno;
+	merge_page_size = page->alloc_pages;
+	if (prev_size >= 0) {
+		mm->free_tree = avltree_remove(
+			mm->free_tree, &found,
+			MAKE_KEY(prev_size,
+				 prev_free_pageno)); /*lint !e571 Suspicious cast*/
+		if (found == NULL) {
+			ASSERT(0);
+			return -1;
+		}
+		merge_page_no = found->page->pageno;
+		merge_page_size += found->page->alloc_pages;
+		P_FREE(found);
+	}
+	if (next_size >= 0) {
+		mm->free_tree = avltree_remove(
+			mm->free_tree, &found,
+			MAKE_KEY(next_size,
+				 next_free_pageno)); /*lint !e571 Suspicious cast*/
+		if (found == NULL) {
+			ASSERT(0);
+			return -1;
+		}
+		merge_page_size += found->page->alloc_pages;
+		P_FREE(found);
+	}
+
+	page->alloc_pages = 0;
+	page->first_pageno = -1;
+
+	set_blocks_free(mm, merge_page_no, merge_page_size);
+
+	mm->alloc_page_count -= free_page_size;
+	mm->free_page_count += free_page_size;
+
+	DPRINT("FREE: total(%d) alloc(%d) free(%d)\n", mm->num_pages,
+	       mm->alloc_page_count, mm->free_page_count);
+
+	return 0;
+}
+
+int vmem_get_info(video_mm_t *mm, vmem_info_t *info)
+{
+	if (mm == NULL) {
+		return -1;
+	}
+
+	if (info == NULL) {
+		return -1;
+	}
+
+	info->total_pages = mm->num_pages;
+	info->alloc_pages = mm->alloc_page_count;
+	info->free_pages = mm->free_page_count;
+	info->page_size = VMEM_PAGE_SIZE;
+
+	return 0;
+}
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_mm.h
@@ -0,0 +1,70 @@
+#ifndef __CNM_VIDEO_MEMORY_ALLOCATOR_H_
+#define __CNM_VIDEO_MEMORY_ALLOCATOR_H_
+
+typedef struct _video_mm_info_struct {
+	unsigned long total_pages;
+	unsigned long alloc_pages;
+	unsigned long free_pages;
+	unsigned long page_size;
+} vmem_info_t;
+
+#if defined(WIN32) || defined(WIN64)
+#if (_MSC_VER == 1200)
+typedef _int64 vmem_key_t;
+#else
+typedef unsigned long long vmem_key_t;
+#endif
+#else
+typedef unsigned long long vmem_key_t;
+#endif
+
+#define VMEM_PAGE_SIZE (16 * 1024)
+
+#define MAKE_KEY(_a, _b) (((vmem_key_t)_a) << 32 | _b)
+#define KEY_TO_VALUE(_key) (_key >> 32)
+
+typedef struct page_struct {
+	int pageno;
+	unsigned long addr;
+	int used;
+	int alloc_pages;
+	int first_pageno;
+} page_t;
+
+typedef struct avl_node_struct {
+	vmem_key_t key;
+	int height;
+	page_t *page;
+	struct avl_node_struct *left;
+	struct avl_node_struct *right;
+} avl_node_t;
+
+typedef struct _video_mm_struct {
+	avl_node_t *free_tree;
+	avl_node_t *alloc_tree;
+	page_t *page_list;
+	int num_pages;
+	unsigned long base_addr;
+	unsigned long mem_size;
+	int free_page_count;
+	int alloc_page_count;
+} video_mm_t;
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+extern int vmem_init(video_mm_t *mm, unsigned long addr, unsigned long size);
+
+extern int vmem_exit(video_mm_t *mm);
+
+extern unsigned long vmem_alloc(video_mm_t *mm, int size, unsigned long pid);
+
+extern int vmem_free(video_mm_t *mm, unsigned long ptr, unsigned long pid);
+
+extern int vmem_get_info(video_mm_t *mm, vmem_info_t *info);
+
+#if defined(__cplusplus)
+}
+#endif
+#endif /* __CNM_VIDEO_MEMORY_ALLOCATOR_H__ */
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_product.c
@@ -0,0 +1,1139 @@
+//--=========================================================================--
+//  This file is a part of VPU Reference API project
+//-----------------------------------------------------------------------------
+//
+//  This confidential and proprietary software may be used only
+//  as authorized by a licensing agreement from Chips&Media Inc.
+//  In the event of publication, the following notice is applicable:
+//
+//            (C) COPYRIGHT 2006 - 2013  CHIPS&MEDIA INC.
+//                      ALL RIGHTS RESERVED
+//
+//   The entire notice above must be reproduced on all authorized copies.
+//
+//--=========================================================================--
+#include "ve1_product.h"
+#include "ve1_vpu.h"
+
+VpuAttr g_VpuCoreAttributes[MAX_NUM_VPU_CORE];
+
+static Int32 s_ProductIds[MAX_NUM_VPU_CORE] = {
+	PRODUCT_ID_NONE,
+};
+
+typedef struct FrameBufInfoStruct {
+	Uint32 unitSizeHorLuma;
+	Uint32 sizeLuma;
+	Uint32 sizeChroma;
+	BOOL fieldMap;
+} FrameBufInfo;
+
+#ifdef ENABLE_TEE_DRM_FLOW
+RetCode ProductVpuInitProtect(Uint32 coreIdx, void *firmware, Uint32 size,
+			      void *sess, void *rtk_sess, void *filp) //[r]
+{
+	RetCode ret = RETCODE_SUCCESS;
+	int productId;
+
+	productId = s_ProductIds[coreIdx];
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuInitProtect(coreIdx, firmware, size, sess,
+					  rtk_sess, filp);
+		break;
+	default:
+		ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+	}
+	return ret;
+}
+#endif
+
+Uint32 ProductVpuScan(Uint32 coreIdx)
+{
+	Uint32 foundProducts = 0;
+
+	/* Already scanned */
+	if (s_ProductIds[0] != PRODUCT_ID_NONE)
+		return 1;
+
+	s_ProductIds[0] = PRODUCT_ID_980;
+	foundProducts = MAX_NUM_VPU_CORE;
+
+	return (foundProducts == MAX_NUM_VPU_CORE);
+}
+
+Int32 ProductVpuGetId(Uint32 coreIdx)
+{
+	return s_ProductIds[coreIdx];
+}
+
+RetCode ProductVpuGetVersion(Uint32 coreIdx, Uint32 *versionInfo,
+			     Uint32 *revision)
+{
+	Int32 productId = s_ProductIds[coreIdx];
+	RetCode ret = RETCODE_SUCCESS;
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuGetVersion(coreIdx, versionInfo, revision);
+		break;
+	default:
+		ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuInit(Uint32 coreIdx, void *firmware, Uint32 size)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	int productId;
+
+	productId = s_ProductIds[coreIdx];
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuInit(coreIdx, firmware, size);
+		break;
+	default:
+		ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuReInit(Uint32 coreIdx, void *firmware, Uint32 size)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	int productId;
+
+	productId = s_ProductIds[coreIdx];
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuReInit(coreIdx, firmware, size);
+		break;
+	default:
+		ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+	}
+
+	return ret;
+}
+
+Uint32 ProductVpuIsInit(Uint32 coreIdx)
+{
+	Uint32 pc = 0;
+	int productId;
+
+	productId = s_ProductIds[coreIdx];
+
+	if (productId == PRODUCT_ID_NONE) {
+		ProductVpuScan(coreIdx);
+		productId = s_ProductIds[coreIdx];
+	}
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		pc = Coda9VpuIsInit(coreIdx);
+		break;
+	}
+
+	return pc;
+}
+
+Int32 ProductVpuIsBusy(Uint32 coreIdx)
+{
+	Int32 busy;
+	int productId;
+
+	productId = s_ProductIds[coreIdx];
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		busy = Coda9VpuIsBusy(coreIdx);
+		break;
+	default:
+		busy = 0;
+		break;
+	}
+
+	return busy;
+}
+
+Int32 ProductVpuWaitInterrupt(CodecInst *instance, Int32 timeout)
+{
+	int productId;
+	int flag = -1;
+
+	productId = s_ProductIds[instance->coreIdx];
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		flag = Coda9VpuWaitInterrupt(instance, timeout);
+		break;
+	default:
+		flag = -1;
+		break;
+	}
+
+	return flag;
+}
+
+RetCode ProductVpuReset(Uint32 coreIdx, SWResetMode resetMode)
+{
+	int productId;
+	RetCode ret = RETCODE_SUCCESS;
+
+	productId = s_ProductIds[coreIdx];
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuReset(coreIdx, resetMode);
+		break;
+	default:
+		ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+		break;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuSleepWake(Uint32 coreIdx, int iSleepWake, const Uint16 *code,
+			    Uint32 size)
+{
+	int productId;
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+
+	productId = s_ProductIds[coreIdx];
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuSleepWake(coreIdx, iSleepWake, (void *)code,
+					size);
+		break;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuClearInterrupt(Uint32 coreIdx, Uint32 flags)
+{
+	int productId;
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+
+	productId = s_ProductIds[coreIdx];
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuClearInterrupt(coreIdx);
+		break;
+	}
+
+	return ret;
+}
+
+Uint32 ProductVpuGetProductId(Uint32 coreIdx) // [r]
+{
+	Uint32 pc = 0;
+	int productId;
+
+	productId = s_ProductIds[coreIdx];
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		pc = Coda9VpuGetProductId(coreIdx);
+		break;
+	}
+
+	return pc;
+}
+
+RetCode ProductVpuDecBuildUpOpenParam(CodecInst *pCodec, DecOpenParam *param)
+{
+	Int32 productId;
+	Uint32 coreIdx;
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+
+	coreIdx = pCodec->coreIdx;
+	productId = s_ProductIds[coreIdx];
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuBuildUpDecParam(pCodec, param);
+		break;
+	}
+
+	return ret;
+}
+
+PhysicalAddress ProductVpuDecGetRdPtr(CodecInst *instance) //[r]
+{
+	Int32 productId;
+	Uint32 coreIdx;
+	PhysicalAddress retRdPtr;
+	DecInfo *pDecInfo;
+
+	pDecInfo = VPU_HANDLE_TO_DECINFO(instance);
+
+	coreIdx = instance->coreIdx;
+	productId = s_ProductIds[coreIdx];
+
+	switch (productId) {
+	default:
+		retRdPtr = VpuReadReg(coreIdx, pDecInfo->streamRdPtrRegAddr);
+		break;
+	}
+
+	return retRdPtr;
+}
+
+RetCode ProductVpuEncBuildUpOpenParam(CodecInst *pCodec, EncOpenParam *param)
+{
+	Int32 productId;
+	Uint32 coreIdx;
+	RetCode ret = RETCODE_NOT_SUPPORTED_FEATURE;
+
+	coreIdx = pCodec->coreIdx;
+	productId = s_ProductIds[coreIdx];
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuBuildUpEncParam(pCodec, param);
+		break;
+	default:
+		ret = RETCODE_NOT_SUPPORTED_FEATURE;
+	}
+
+	return ret;
+}
+
+RetCode ProductCheckDecOpenParam(DecOpenParam *param)
+{
+	Int32 productId;
+	Uint32 coreIdx;
+	VpuAttr *pAttr;
+
+	if (param == 0)
+		return RETCODE_INVALID_PARAM;
+
+	if (param->coreIdx >= MAX_NUM_VPU_CORE)
+		return RETCODE_INVALID_PARAM;
+
+	coreIdx = param->coreIdx;
+	productId = s_ProductIds[coreIdx];
+	VLOG(TRACE, "[%d]%s.productId:0x%x.\n", __LINE__, __func__, productId);
+	pAttr = &g_VpuCoreAttributes[coreIdx];
+
+	if (param->bitstreamBuffer % 8) {
+		VLOG(TRACE, "[%d]%s\n", __LINE__, __func__);
+		return RETCODE_INVALID_PARAM;
+	}
+
+	if (param->bitstreamMode == BS_MODE_INTERRUPT) {
+		if (param->bitstreamBufferSize % 1024 ||
+		    param->bitstreamBufferSize < 1024) {
+			VLOG(TRACE, "[%d]%s\n", __LINE__, __func__);
+			return RETCODE_INVALID_PARAM;
+		}
+	}
+
+	if (PRODUCT_ID_W_SERIES(productId)) {
+		if (param->virtAxiID > 16) {
+			// Maximum number of AXI channels is 15
+			return RETCODE_INVALID_PARAM;
+		}
+	}
+
+	// Check bitstream mode
+	if ((pAttr->supportBitstreamMode & (1 << param->bitstreamMode)) == 0) {
+		VLOG(TRACE, "[%d]%s\n", __LINE__, __func__);
+		return RETCODE_INVALID_PARAM;
+	}
+
+	if ((pAttr->supportDecoders & (1 << param->bitstreamFormat)) == 0) {
+		VLOG(TRACE, "[%d]%s\n", __LINE__, __func__);
+		return RETCODE_INVALID_PARAM;
+	}
+
+	/* check framebuffer endian */
+	if ((pAttr->supportEndianMask & (1 << param->frameEndian)) == 0) {
+		APIDPRINT("%s:%d Invalid frame endian(%d)\n",
+			  (Int32)param->frameEndian);
+		VLOG(TRACE, "[%d]%s\n", __LINE__, __func__);
+		return RETCODE_INVALID_PARAM;
+	}
+
+	/* check streambuffer endian */
+	if ((pAttr->supportEndianMask & (1 << param->streamEndian)) == 0) {
+		APIDPRINT("%s:%d Invalid stream endian(%d)\n",
+			  (Int32)param->streamEndian);
+		VLOG(TRACE, "[%d]%s\n", __LINE__, __func__);
+		return RETCODE_INVALID_PARAM;
+	}
+
+	/* check WTL */
+	if (param->wtlEnable) {
+		if (pAttr->supportWTL == 0)
+			return RETCODE_NOT_SUPPORTED_FEATURE;
+		switch (productId) {
+		case PRODUCT_ID_960:
+		case PRODUCT_ID_980:
+			if (param->wtlMode != FF_FRAME &&
+			    param->wtlMode != FF_FIELD)
+				return RETCODE_INVALID_PARAM;
+			break;
+		default:
+			break;
+		}
+	}
+
+	/* Tiled2Linear */
+	if (param->tiled2LinearEnable) {
+		if (pAttr->supportTiled2Linear == 0)
+			return RETCODE_NOT_SUPPORTED_FEATURE;
+
+		if (productId == PRODUCT_ID_960 ||
+		    productId == PRODUCT_ID_980) {
+			if (param->tiled2LinearMode != FF_FRAME &&
+			    param->tiled2LinearMode != FF_FIELD) {
+				APIDPRINT(
+					"%s:%d Invalid Tiled2LinearMode(%d)\n",
+					(Int32)param->tiled2LinearMode);
+				return RETCODE_INVALID_PARAM;
+			}
+		}
+	}
+	if (productId == PRODUCT_ID_960 || productId == PRODUCT_ID_980) {
+		if (param->mp4DeblkEnable == 1 &&
+		    !(param->bitstreamFormat == STD_MPEG4 ||
+		      param->bitstreamFormat == STD_H263 ||
+		      param->bitstreamFormat == STD_MPEG2 ||
+		      param->bitstreamFormat == STD_UNKNOWN3)) {
+			VLOG(TRACE, "[%d]%s\n", __LINE__, __func__);
+			return RETCODE_INVALID_PARAM;
+		}
+		if (param->wtlEnable && param->tiled2LinearEnable) {
+			VLOG(TRACE, "[%d]%s\n", __LINE__, __func__);
+			return RETCODE_INVALID_PARAM;
+		}
+	} else {
+		if (param->mp4DeblkEnable || param->mp4Class)
+			return RETCODE_INVALID_PARAM;
+		if (param->avcExtension)
+			return RETCODE_INVALID_PARAM;
+		if (param->tiled2LinearMode != FF_NONE)
+			return RETCODE_INVALID_PARAM;
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode ProductVpuDecInitSeq(CodecInst *instance)
+{
+	int productId;
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+
+	productId = instance->productId;
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuDecInitSeq(instance);
+		break;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuDecFiniSeq(CodecInst *instance)
+{
+	int productId;
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+
+	productId = instance->productId;
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuFiniSeq(instance);
+		break;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuDecGetSeqInfo(CodecInst *instance, DecInitialInfo *info)
+{
+	int productId;
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+
+	productId = instance->productId;
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuDecGetSeqInfo(instance, info);
+		break;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuDecCheckCapability(CodecInst *instance)
+{
+	DecInfo *pDecInfo;
+	VpuAttr *pAttr = &g_VpuCoreAttributes[instance->coreIdx];
+
+	pDecInfo = &instance->CodecInfo->decInfo;
+
+	if ((pAttr->supportDecoders &
+	     (1 << pDecInfo->openParam.bitstreamFormat)) == 0)
+		return RETCODE_NOT_SUPPORTED_FEATURE;
+
+	switch (instance->productId) {
+	case PRODUCT_ID_960:
+		if (pDecInfo->mapType >= TILED_FRAME_NO_BANK_MAP)
+			return RETCODE_NOT_SUPPORTED_FEATURE;
+		if (pDecInfo->tiled2LinearMode == FF_FIELD)
+			return RETCODE_NOT_SUPPORTED_FEATURE;
+		break;
+	case PRODUCT_ID_980:
+		if (pDecInfo->mapType >= COMPRESSED_FRAME_MAP)
+			return RETCODE_NOT_SUPPORTED_FEATURE;
+		break;
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode ProductVpuDecode(CodecInst *instance, DecParam *option)
+{
+	int productId;
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+
+	productId = instance->productId;
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuDecode(instance, option);
+		break;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuDecGetResult(CodecInst *instance, DecOutputInfo *result)
+{
+	int productId;
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+
+	productId = instance->productId;
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuDecGetResult(instance, result);
+		break;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuDecFlush(CodecInst *instance, FramebufferIndex *retIndexes,
+			   Uint32 size)
+{
+	RetCode ret = RETCODE_SUCCESS;
+
+	switch (instance->productId) {
+	default:
+		ret = Coda9VpuDecFlush(instance, retIndexes, size);
+		break;
+	}
+
+	return ret;
+}
+
+/************************************************************************/
+/* Decoder & Encoder                                                    */
+/************************************************************************/
+
+RetCode ProductVpuDecSetBitstreamFlag(CodecInst *instance, BOOL running,
+				      Int32 size)
+{
+	int productId;
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+	BOOL eos;
+	BOOL checkEos;
+	BOOL explicitEnd;
+	DecInfo *pDecInfo = &instance->CodecInfo->decInfo;
+
+	productId = instance->productId;
+
+	eos = (BOOL)(size == 0);
+	checkEos = (BOOL)(size > 0);
+	explicitEnd = (BOOL)(size == -2);
+
+	switch (productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		if (checkEos ||
+		    explicitEnd /* explicitEnd alst need to check the old value of streamEndflag*/) // gregory, for RTPIC-109(CHTMOD-196)
+			eos = (BOOL)((pDecInfo->streamEndflag & 0x04) == 0x04);
+		ret = Coda9VpuDecSetBitstreamFlag(instance, running, eos);
+		break;
+	}
+
+	return ret;
+}
+
+RetCode ProductCpbFlush(CodecInst *instance)
+{
+	RetCode ret;
+
+	switch (instance->productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuDecCpbFlush(instance);
+		break;
+	default:
+		ret = RETCODE_NOT_SUPPORTED_FEATURE;
+		break;
+	}
+
+	return ret;
+}
+
+/**
+ * \param   stride          stride of framebuffer in pixel.
+ */
+RetCode ProductVpuAllocateFramebuffer(
+	CodecInst *inst, FrameBuffer *fbArr, TiledMapType mapType, Int32 num,
+	Int32 stride, Int32 height, FrameBufferFormat format,
+	BOOL cbcrInterleave, BOOL nv21, Int32 endian, vpu_buffer_t *vb,
+	Int32 gdiIndex, FramebufferAllocType fbType)
+{
+	Int32 i;
+	Uint32 coreIdx;
+	vpu_buffer_t vbFrame;
+	FrameBufInfo fbInfo;
+	DecInfo *pDecInfo = &inst->CodecInfo->decInfo;
+	EncInfo *pEncInfo = &inst->CodecInfo->encInfo;
+	// Variables for TILED_FRAME/FILED_MB_RASTER
+	Uint32 sizeLuma;
+	Uint32 sizeChroma;
+	ProductId productId = (ProductId)inst->productId;
+	RetCode ret = RETCODE_SUCCESS;
+
+	osal_memset((void *)&vbFrame, 0x00, sizeof(vpu_buffer_t));
+	osal_memset((void *)&fbInfo, 0x00, sizeof(FrameBufInfo));
+
+	coreIdx = inst->coreIdx;
+
+	if (inst->codecMode == AVC_ENC)
+		format = pEncInfo->openParam.EncStdParam.avcParam
+					 .chromaFormat400 ?
+				 FORMAT_400 :
+				 FORMAT_420;
+	if (inst->codecMode == W_VP9_DEC) {
+		Uint32 framebufHeight = VPU_ALIGN64(height);
+		sizeLuma = CalcLumaSize(inst->productId, stride, framebufHeight,
+					format, cbcrInterleave, mapType, NULL);
+		sizeChroma =
+			CalcChromaSize(inst->productId, stride, framebufHeight,
+				       format, cbcrInterleave, mapType, NULL);
+	} else {
+		DRAMConfig *dramConfig = NULL;
+		if (productId == PRODUCT_ID_960) {
+			dramConfig = &pDecInfo->dramCfg;
+			dramConfig = (inst->isDecoder == TRUE) ?
+					     &pDecInfo->dramCfg :
+					     &pEncInfo->dramCfg;
+		}
+		sizeLuma = CalcLumaSize(inst->productId, stride, height, format,
+					cbcrInterleave, mapType, dramConfig);
+		sizeChroma =
+			CalcChromaSize(inst->productId, stride, height, format,
+				       cbcrInterleave, mapType, dramConfig);
+	}
+
+	// Framebuffer common informations
+	for (i = 0; i < num; i++) {
+		if (fbArr[i].updateFbInfo == TRUE) {
+			fbArr[i].updateFbInfo = FALSE;
+			fbArr[i].myIndex = i + gdiIndex;
+			fbArr[i].stride = stride;
+			fbArr[i].height = height;
+			fbArr[i].mapType = mapType;
+			fbArr[i].format = format;
+			fbArr[i].cbcrInterleave =
+				(mapType == COMPRESSED_FRAME_MAP ?
+					 TRUE :
+					 cbcrInterleave);
+			fbArr[i].nv21 = nv21;
+			fbArr[i].endian = endian;
+			fbArr[i].lumaBitDepth =
+				pDecInfo->initialInfo.lumaBitdepth;
+			fbArr[i].chromaBitDepth =
+				pDecInfo->initialInfo.chromaBitdepth;
+			fbArr[i].sourceLBurstEn = FALSE;
+		}
+	}
+
+	switch (mapType) {
+	case LINEAR_FRAME_MAP:
+	case LINEAR_FIELD_MAP:
+	case COMPRESSED_FRAME_MAP:
+	case ARM_COMPRESSED_FRAME_MAP:
+		ret = AllocateLinearFrameBuffer(mapType, fbArr, num, sizeLuma,
+						sizeChroma);
+		break;
+
+	default:
+		/* Tiled map */
+		if (productId == PRODUCT_ID_960) {
+			DRAMConfig *pDramCfg;
+			PhysicalAddress tiledBaseAddr = 0;
+			TiledMapConfig *pMapCfg;
+
+			pDramCfg = (inst->isDecoder == TRUE) ?
+					   &pDecInfo->dramCfg :
+					   &pEncInfo->dramCfg;
+			pMapCfg = (inst->isDecoder == TRUE) ?
+					  &pDecInfo->mapCfg :
+					  &pEncInfo->mapCfg;
+			vbFrame.phys_addr =
+				GetTiledFrameBase(coreIdx, fbArr, num);
+			if (fbType == FB_TYPE_PPU) {
+				tiledBaseAddr = pMapCfg->tiledBaseAddr;
+			} else {
+				pMapCfg->tiledBaseAddr = vbFrame.phys_addr;
+				tiledBaseAddr = vbFrame.phys_addr;
+			}
+			*vb = vbFrame;
+			ret = AllocateTiledFrameBufferGdiV1(
+				mapType, tiledBaseAddr, fbArr, num, sizeLuma,
+				sizeChroma, pDramCfg);
+		} else {
+			// PRODUCT_ID_980
+			ret = AllocateTiledFrameBufferGdiV2(
+				mapType, fbArr, num, sizeLuma, sizeChroma);
+		}
+		break;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuRegisterFramebuffer(CodecInst *instance)
+{
+	RetCode ret = RETCODE_FAILURE;
+
+	switch (instance->productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		if (IS_DECODER_HANDLE(instance))
+			ret = Coda9VpuDecRegisterFramebuffer(instance);
+		else
+			ret = Coda9VpuEncRegisterFramebuffer(instance);
+		break;
+	}
+	return ret;
+}
+
+RetCode ProductVpuDecUpdateFrameBuffer(CodecInst *instance, FrameBuffer *fbcFb,
+				       FrameBuffer *linearFb, Uint32 mvColIndex,
+				       Uint32 picWidth, Uint32 picHeight)
+{
+	RetCode ret = RETCODE_NOT_SUPPORTED_FEATURE;
+
+	return ret;
+}
+
+Int32 ProductCalculateFrameBufSize(Int32 productId, Int32 stride, Int32 height,
+				   TiledMapType mapType,
+				   FrameBufferFormat format, BOOL interleave,
+				   DRAMConfig *pDramCfg)
+{
+	Int32 size_dpb_lum, size_dpb_chr, size_dpb_all;
+
+	size_dpb_lum = CalcLumaSize(productId, stride, height, format,
+				    interleave, mapType, pDramCfg);
+	size_dpb_chr = CalcChromaSize(productId, stride, height, format,
+				      interleave, mapType, pDramCfg);
+	size_dpb_all = size_dpb_lum + size_dpb_chr * 2;
+
+	return size_dpb_all;
+}
+
+Int32 ProductCalculateAuxBufferSize(AUX_BUF_TYPE type, CodStd codStd,
+				    Int32 width, Int32 height)
+{
+	Int32 size = 0;
+
+	switch (type) {
+	case AUX_BUF_TYPE_MVCOL:
+		if (codStd == STD_AVC || codStd == STD_VC1 ||
+		    codStd == STD_MPEG4 || codStd == STD_H263 ||
+		    codStd == STD_RV || codStd == STD_AVS) {
+			size = VPU_ALIGN32(width) * VPU_ALIGN32(height);
+			size = (size * 3) / 2;
+			size = (size + 4) / 5;
+			size = ((size + 7) / 8) * 8;
+		} else {
+			size = 0;
+		}
+		break;
+	case AUX_BUF_TYPE_FBC_Y_OFFSET:
+	case AUX_BUF_TYPE_FBC_C_OFFSET:
+	default:
+		break;
+	}
+
+	return size;
+}
+
+/************************************************************************/
+/* ENCODER                                                              */
+/************************************************************************/
+RetCode ProductCheckEncOpenParam(EncOpenParam *pop)
+{
+	Int32 coreIdx;
+	Int32 picWidth;
+	Int32 picHeight;
+	Int32 productId;
+	VpuAttr *pAttr;
+
+	if (pop == 0)
+		return RETCODE_INVALID_PARAM;
+
+	if (pop->coreIdx >= MAX_NUM_VPU_CORE)
+		return RETCODE_INVALID_PARAM;
+
+	coreIdx = pop->coreIdx;
+	picWidth = pop->picWidth;
+	picHeight = pop->picHeight;
+	productId = s_ProductIds[coreIdx];
+	pAttr = &g_VpuCoreAttributes[coreIdx];
+
+	if ((pAttr->supportEncoders & (1 << pop->bitstreamFormat)) == 0)
+		return RETCODE_NOT_SUPPORTED_FEATURE;
+
+	if (pop->ringBufferEnable == TRUE) {
+		if (pop->bitstreamBuffer % 8) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		if (pop->bitstreamBufferSize % 1024 ||
+		    pop->bitstreamBufferSize < 1024)
+			return RETCODE_INVALID_PARAM;
+	}
+
+	if (pop->frameRateInfo == 0)
+		return RETCODE_INVALID_PARAM;
+
+	if (pop->bitstreamFormat == STD_AVC) {
+		if (productId == PRODUCT_ID_980) {
+			if (pop->bitRate > 524288 || pop->bitRate < 0)
+				return RETCODE_INVALID_PARAM;
+		}
+	} else {
+		if (pop->bitRate > 32767 || pop->bitRate < 0)
+			return RETCODE_INVALID_PARAM;
+	}
+
+	if (pop->bitRate != 0 && pop->initialDelay > 32767)
+		return RETCODE_INVALID_PARAM;
+
+	if (pop->bitRate != 0 && pop->initialDelay != 0 &&
+	    pop->vbvBufferSize < 0)
+		return RETCODE_INVALID_PARAM;
+
+	if (pop->frameSkipDisable != 0 && pop->frameSkipDisable != 1)
+		return RETCODE_INVALID_PARAM;
+
+	if (pop->sliceMode.sliceMode != 0 && pop->sliceMode.sliceMode != 1)
+		return RETCODE_INVALID_PARAM;
+
+	if (pop->sliceMode.sliceMode == 1) {
+		if (pop->sliceMode.sliceSizeMode != 0 &&
+		    pop->sliceMode.sliceSizeMode != 1) {
+			return RETCODE_INVALID_PARAM;
+		}
+		if (pop->sliceMode.sliceSizeMode == 1 &&
+		    pop->sliceMode.sliceSize == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+	}
+
+	if (pop->intraRefresh < 0)
+		return RETCODE_INVALID_PARAM;
+
+	if (pop->MEUseZeroPmv != 0 && pop->MEUseZeroPmv != 1)
+		return RETCODE_INVALID_PARAM;
+
+	if (pop->intraCostWeight < 0 || pop->intraCostWeight >= 65535)
+		return RETCODE_INVALID_PARAM;
+
+	if (productId == PRODUCT_ID_980) {
+		if (pop->MESearchRangeX < 0 || pop->MESearchRangeX > 4) {
+			return RETCODE_INVALID_PARAM;
+		}
+		if (pop->MESearchRangeY < 0 || pop->MESearchRangeY > 3) {
+			return RETCODE_INVALID_PARAM;
+		}
+	} else {
+		if (pop->MESearchRange < 0 || pop->MESearchRange >= 4)
+			return RETCODE_INVALID_PARAM;
+	}
+
+	if (pop->bitstreamFormat == STD_MPEG4) {
+		EncMp4Param *param = &pop->EncStdParam.mp4Param;
+		if (param->mp4DataPartitionEnable != 0 &&
+		    param->mp4DataPartitionEnable != 1) {
+			return RETCODE_INVALID_PARAM;
+		}
+		if (param->mp4DataPartitionEnable == 1) {
+			if (param->mp4ReversibleVlcEnable != 0 &&
+			    param->mp4ReversibleVlcEnable != 1) {
+				return RETCODE_INVALID_PARAM;
+			}
+		}
+		if (param->mp4IntraDcVlcThr < 0 ||
+		    7 < param->mp4IntraDcVlcThr) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		if (picWidth < MIN_ENC_PIC_WIDTH ||
+		    picWidth > MAX_ENC_PIC_WIDTH) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		if (picHeight < MIN_ENC_PIC_HEIGHT) {
+			return RETCODE_INVALID_PARAM;
+		}
+	} else if (pop->bitstreamFormat == STD_H263) {
+		EncH263Param *param = &pop->EncStdParam.h263Param;
+#ifdef H263_FRAME_RATE_LIMIT_CLEAR
+#else
+		Uint32 frameRateInc, frameRateRes;
+#endif
+
+		if (param->h263AnnexJEnable != 0 &&
+		    param->h263AnnexJEnable != 1) {
+			return RETCODE_INVALID_PARAM;
+		}
+		if (param->h263AnnexKEnable != 0 &&
+		    param->h263AnnexKEnable != 1) {
+			return RETCODE_INVALID_PARAM;
+		}
+		if (param->h263AnnexTEnable != 0 &&
+		    param->h263AnnexTEnable != 1) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		if (picWidth < MIN_ENC_PIC_WIDTH ||
+		    picWidth > MAX_ENC_PIC_WIDTH) {
+			return RETCODE_INVALID_PARAM;
+		}
+		if (picHeight < MIN_ENC_PIC_HEIGHT) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+#ifdef H263_FRAME_RATE_LIMIT_CLEAR
+#else
+		frameRateInc = ((pop->frameRateInfo >> 16) & 0xFFFF) + 1;
+		frameRateRes = pop->frameRateInfo & 0xFFFF;
+
+		if ((frameRateRes / frameRateInc) < 15) {
+			return RETCODE_INVALID_PARAM;
+		}
+#endif
+	} else if (pop->bitstreamFormat == STD_AVC) {
+		EncAvcParam *param = &pop->EncStdParam.avcParam;
+
+		AvcPpsParam *ActivePPS = NULL;
+
+		if (productId == PRODUCT_ID_980)
+			ActivePPS = &param->ppsParam[0];
+
+		if (param->constrainedIntraPredFlag != 0 &&
+		    param->constrainedIntraPredFlag != 1)
+			return RETCODE_INVALID_PARAM;
+		if (param->disableDeblk != 0 && param->disableDeblk != 1 &&
+		    param->disableDeblk != 2)
+			return RETCODE_INVALID_PARAM;
+		if (param->deblkFilterOffsetAlpha < -6 ||
+		    6 < param->deblkFilterOffsetAlpha)
+			return RETCODE_INVALID_PARAM;
+		if (param->deblkFilterOffsetBeta < -6 ||
+		    6 < param->deblkFilterOffsetBeta)
+			return RETCODE_INVALID_PARAM;
+		if (param->chromaQpOffset < -12 || 12 < param->chromaQpOffset)
+			return RETCODE_INVALID_PARAM;
+		if (param->audEnable != 0 && param->audEnable != 1)
+			return RETCODE_INVALID_PARAM;
+		if (param->frameCroppingFlag != 0 &&
+		    param->frameCroppingFlag != 1)
+			return RETCODE_INVALID_PARAM;
+		if (param->frameCropLeft & 0x01 ||
+		    param->frameCropRight & 0x01 ||
+		    param->frameCropTop & 0x01 ||
+		    param->frameCropBottom & 0x01) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		if (productId == PRODUCT_ID_980) {
+			if (picWidth < MIN_ENC_PIC_WIDTH ||
+			    picWidth > MAX_ENC_AVC_PIC_WIDTH)
+				return RETCODE_INVALID_PARAM;
+			if (picHeight < MIN_ENC_PIC_HEIGHT ||
+			    picHeight > MAX_ENC_AVC_PIC_HEIGHT)
+				return RETCODE_INVALID_PARAM;
+			if (ActivePPS->entropyCodingMode > 2 ||
+			    ActivePPS->entropyCodingMode < 0)
+				return RETCODE_INVALID_PARAM;
+			if (ActivePPS->cabacInitIdc < 0 ||
+			    ActivePPS->cabacInitIdc > 2)
+				return RETCODE_INVALID_PARAM;
+			if (ActivePPS->transform8x8Mode != 1 &&
+			    ActivePPS->transform8x8Mode != 0)
+				return RETCODE_INVALID_PARAM;
+			if (param->chromaFormat400 != 1 &&
+			    param->chromaFormat400 != 0)
+				return RETCODE_INVALID_PARAM;
+			if (param->fieldFlag != 1 && param->fieldFlag != 0)
+				return RETCODE_INVALID_PARAM;
+		} else {
+			if (picWidth < MIN_ENC_PIC_WIDTH ||
+			    picWidth > MAX_ENC_PIC_WIDTH)
+				return RETCODE_INVALID_PARAM;
+			if (picHeight < MIN_ENC_PIC_HEIGHT)
+				return RETCODE_INVALID_PARAM;
+		}
+	}
+
+	if (pop->linear2TiledEnable == TRUE) {
+		if (pop->linear2TiledMode != FF_FRAME &&
+		    pop->linear2TiledMode != FF_FIELD)
+			return RETCODE_INVALID_PARAM;
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode ProductVpuEncFiniSeq(CodecInst *instance)
+{
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+
+	switch (instance->productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuFiniSeq(instance);
+		break;
+	}
+	return ret;
+}
+
+RetCode ProductVpuEncSetup(CodecInst *instance)
+{
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+
+	switch (instance->productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuEncSetup(instance);
+		break;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuEncode(CodecInst *instance, EncParam *param)
+{
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+
+	switch (instance->productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuEncode(instance, param);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuEncGetResult(CodecInst *instance, EncOutputInfo *result)
+{
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+
+	switch (instance->productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuEncGetResult(instance, result);
+		break;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuEncGiveCommand(CodecInst *instance, CodecCommand cmd,
+				 void *param)
+{
+	RetCode ret = RETCODE_NOT_SUPPORTED_FEATURE;
+
+	switch (instance->productId) {
+	case PRODUCT_ID_960:
+	case PRODUCT_ID_980:
+		ret = Coda9VpuEncGiveCommand(instance, cmd, param);
+		break;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuEncInitSeq(CodecInst *instance) //[r]
+{
+	int productId;
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+
+	productId = instance->productId;
+
+	switch (productId) {
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+RetCode ProductVpuEncGetSeqInfo(CodecInst *instance, EncInitialInfo *info) //[r]
+{
+	int productId;
+	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
+
+	productId = instance->productId;
+
+	switch (productId) {
+	default:
+		break;
+	}
+
+	return ret;
+}
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_product.h
@@ -0,0 +1,220 @@
+//--=========================================================================--
+//  This file is a part of VPU Reference API project
+//-----------------------------------------------------------------------------
+//
+//       This confidential and proprietary software may be used only
+//     as authorized by a licensing agreement from Chips&Media Inc.
+//     In the event of publication, the following notice is applicable:
+//
+//            (C) COPYRIGHT 2006 - 2013  CHIPS&MEDIA INC.
+//                      ALL RIGHTS RESERVED
+//
+//       The entire notice above must be reproduced on all authorized
+//       copies.
+//
+//--=========================================================================--
+
+#ifndef __VPUAPI_PRODUCT_ABSTRACT_H__
+#define __VPUAPI_PRODUCT_ABSTRACT_H__
+
+#include "ve1_vpuapi.h"
+#include "ve1_vpuapifunc.h"
+
+#define IS_DECODER_HANDLE(_instance) (_instance->codecMode < AVC_ENC)
+#define IS_7Q_DECODER_HANDLE(_instance) (_instance->codecMode < W_AVC_ENC)
+
+enum { FramebufCacheNone,
+       FramebufCacheMaverickI,
+       FramebufCacheMaverickII,
+};
+
+typedef enum {
+	AUX_BUF_TYPE_MVCOL,
+	AUX_BUF_TYPE_FBC_Y_OFFSET,
+	AUX_BUF_TYPE_FBC_C_OFFSET
+} AUX_BUF_TYPE;
+
+typedef struct _tag_FramebufferIndex {
+	Int16 tiledIndex;
+	Int16 linearIndex;
+} FramebufferIndex;
+
+typedef struct _tag_VpuAttrStruct {
+	Uint32 productId;
+	Uint32 productNumber;
+	char productName[8];
+	Uint32 supportDecoders; /* bitmask: See CodStd in vpuapi.h */
+	Uint32 supportEncoders; /* bitmask: See CodStd in vpuapi.h */
+	Uint32 numberOfMemProtectRgns; /* always 10 */
+	Uint32 numberOfVCores;
+	BOOL supportWTL;
+	BOOL supportTiled2Linear;
+	BOOL supportTiledMap;
+	BOOL supportMapTypes; /* Framebuffer map type */
+	BOOL supportLinear2Tiled; /* Encoder */
+	BOOL support128bitBus;
+	BOOL supportThumbnailMode;
+	BOOL supportBitstreamMode;
+	BOOL supportFBCBWOptimization; /* WAVExxx decoder feature */
+	BOOL supportGDIHW;
+	BOOL supportCommandQueue;
+	Uint32 supportEndianMask;
+	Uint32 framebufferCacheType; /* 0: for None, 1 - Maverick-I, 2 - Maverick-II */
+	Uint32 bitstreamBufferMargin;
+	Uint32 interruptEnableFlag;
+	Uint32 hwConfigDef0;
+	Uint32 hwConfigDef1;
+	Uint32 hwConfigFeature; /**<< supported codec standards */
+	Uint32 hwConfigDate; /**<< Configuation Date Decimal, ex)20151130 */
+	Uint32 hwConfigRev; /**<< SVN revision, ex) 83521 */
+	Uint32 hwConfigType; /**<< Not defined yet */
+} VpuAttr;
+
+extern VpuAttr g_VpuCoreAttributes[MAX_NUM_VPU_CORE];
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/*
+ * Returns 0 - not found product id
+ *         1 - found product id
+ */
+extern Uint32 ProductVpuScan(Uint32 coreIdx);
+
+extern Int32 ProductVpuGetId(Uint32 coreIdx);
+
+extern RetCode ProductVpuGetVersion(Uint32 coreIdx, Uint32 *versionInfo,
+				    Uint32 *revision);
+
+extern RetCode ProductVpuInit(Uint32 coreIdx, void *firmware, Uint32 size);
+
+extern RetCode ProductVpuReInit(Uint32 coreIdx, void *firmware, Uint32 size);
+
+extern Uint32 ProductVpuIsInit(Uint32 coreIdx);
+
+extern Int32 ProductVpuIsBusy(Uint32 coreIdx);
+
+extern Int32 ProductVpuWaitInterrupt(CodecInst *instance, Int32 timeout);
+
+extern RetCode ProductVpuReset(Uint32 coreIdx, SWResetMode resetMode);
+
+extern RetCode ProductVpuSleepWake(Uint32 coreIdx, int iSleepWake,
+				   const Uint16 *code, Uint32 size);
+
+extern RetCode ProductVpuClearInterrupt(Uint32 coreIdx, Uint32 flags);
+
+extern Uint32 ProductVpuGetProductId(Uint32 coreIdx);
+
+extern RetCode ProductVpuDecBuildUpOpenParam(CodecInst *instance,
+					     DecOpenParam *param);
+
+extern RetCode ProductCheckDecOpenParam(DecOpenParam *param);
+
+extern RetCode ProductVpuDecInitSeq(CodecInst *instance);
+
+extern RetCode ProductVpuDecFiniSeq(CodecInst *instance);
+
+extern RetCode ProductVpuDecSetBitstreamFlag(CodecInst *instance, BOOL running,
+					     Int32 size);
+
+extern RetCode ProductCpbFlush(CodecInst *instance);
+/*
+ * FINI_SEQ
+ */
+extern RetCode ProductVpuDecEndSequence(CodecInst *instance);
+
+/**
+ *  @brief      Abstract function for SEQ_INIT.
+ */
+extern RetCode ProductVpuDecGetSeqInfo(CodecInst *instance,
+				       DecInitialInfo *info);
+
+/**
+ *  \brief      Check parameters for product specific decoder.
+ */
+extern RetCode ProductVpuDecCheckCapability(CodecInst *instance);
+
+/**
+ * \brief       Decode a coded picture.
+ */
+extern RetCode ProductVpuDecode(CodecInst *instance, DecParam *option);
+
+/**
+ *
+ */
+extern RetCode ProductVpuDecGetResult(CodecInst *instance,
+				      DecOutputInfo *result);
+
+/**
+ * \brief                   Flush framebuffers to prepare decoding new sequence
+ * \param   instance        decoder handle
+ * \param   retIndexes      Storing framebuffer indexes in display order.
+ *                          If retIndexes[i] is -1 then there is no display index from i-th.
+ */
+extern RetCode ProductVpuDecFlush(CodecInst *instance,
+				  FramebufferIndex *retIndexes, Uint32 size);
+
+/**
+ *  \brief      Allocate framebuffers with given parameters
+ */
+extern RetCode ProductVpuAllocateFramebuffer(
+	CodecInst *instance, FrameBuffer *fbArr, TiledMapType mapType,
+	Int32 num, Int32 stride, Int32 height, FrameBufferFormat format,
+	BOOL cbcrInterleave, BOOL nv21, Int32 endian, vpu_buffer_t *vb,
+	Int32 gdiIndex, FramebufferAllocType fbType);
+
+/**
+ *  \brief      Register framebuffers to VPU
+ */
+extern RetCode ProductVpuRegisterFramebuffer(CodecInst *instance);
+
+extern RetCode
+ProductVpuDecUpdateFrameBuffer(CodecInst *instance, FrameBuffer *fbcFb,
+			       FrameBuffer *linearFb, Uint32 mvColIndex,
+			       Uint32 picWidth, Uint32 picHeight);
+
+extern Int32 ProductCalculateFrameBufSize(Int32 productId, Int32 stride,
+					  Int32 height, TiledMapType mapType,
+					  FrameBufferFormat format,
+					  BOOL interleave,
+					  DRAMConfig *pDramCfg);
+extern Int32 ProductCalculateAuxBufferSize(AUX_BUF_TYPE type, CodStd codStd,
+					   Int32 width, Int32 height);
+
+extern PhysicalAddress ProductVpuDecGetRdPtr(CodecInst *instance);
+
+/************************************************************************/
+/* ENCODER                                                              */
+/************************************************************************/
+extern RetCode ProductVpuEncBuildUpOpenParam(CodecInst *pCodec,
+					     EncOpenParam *param);
+
+extern RetCode ProductVpuEncFiniSeq(CodecInst *instance);
+
+extern RetCode ProductCheckEncOpenParam(EncOpenParam *param);
+
+extern RetCode ProductVpuEncSetup(CodecInst *instance);
+
+extern RetCode ProductVpuEncode(CodecInst *instance, EncParam *param);
+
+extern RetCode ProductVpuEncGetResult(CodecInst *instance,
+				      EncOutputInfo *result);
+extern RetCode ProductVpuEncGiveCommand(CodecInst *instance, CodecCommand cmd,
+					void *param);
+
+extern RetCode ProductVpuEncInitSeq(CodecInst *instance);
+extern RetCode ProductVpuEncGetSeqInfo(CodecInst *instance,
+				       EncInitialInfo *info);
+
+#ifdef ENABLE_TEE_DRM_FLOW
+extern RetCode ProductVpuInitProtect(Uint32 coreIdx, void *firmware,
+				     Uint32 size, void *sess, void *rtk_sess,
+				     void *filp);
+#endif
+
+#ifdef __cplusplus
+};
+#endif /* __cplusplus */
+
+#endif /* __VPUAPI_PRODUCT_ABSTRACT_H__ */
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_regdefine.h
@@ -0,0 +1,595 @@
+//--=========================================================================--
+//  This file is a part of VPU Reference API project
+//-----------------------------------------------------------------------------
+//
+//       This confidential and proprietary software may be used only
+//     as authorized by a licensing agreement from Chips&Media Inc.
+//     In the event of publication, the following notice is applicable:
+//
+//            (C) COPYRIGHT 2006 - 2011  CHIPS&MEDIA INC.
+//                      ALL RIGHTS RESERVED
+//
+//       The entire notice above must be reproduced on all authorized
+//       copies.
+//
+//--=========================================================================--
+#include "ve1_config.h"
+
+#ifndef REGDEFINE_H_INCLUDED
+#define REGDEFINE_H_INCLUDED
+
+//------------------------------------------------------------------------------
+// REGISTER BASE
+//------------------------------------------------------------------------------
+#define BIT_BASE 0x0000
+#define GDMA_BASE 0x1000
+#define MBC_BASE 0x0400
+#define ME_BASE 0x0600
+#define MC_BASE 0x0C00
+#define DMAC_BASE 0x2000
+
+#define BW_BASE 0x03000000
+//------------------------------------------------------------------------------
+// HARDWARE REGISTER
+//------------------------------------------------------------------------------
+// SW Reset command
+#define VPU_SW_RESET_BPU_CORE 0x008
+#define VPU_SW_RESET_BPU_BUS 0x010
+#define VPU_SW_RESET_VCE_CORE 0x020
+#define VPU_SW_RESET_VCE_BUS 0x040
+#define VPU_SW_RESET_GDI_CORE 0x080
+#define VPU_SW_RESET_GDI_BUS 0x100
+
+#define BIT_CODE_RUN (BIT_BASE + 0x000)
+#define BIT_CODE_DOWN (BIT_BASE + 0x004)
+#define BIT_INT_REQ (BIT_BASE + 0x008)
+#define BIT_INT_CLEAR (BIT_BASE + 0x00C)
+#define BIT_INT_STS (BIT_BASE + 0x010)
+#define BIT_CODE_RESET (BIT_BASE + 0x014)
+#define BIT_CUR_PC (BIT_BASE + 0x018)
+#define BIT_SW_RESET (BIT_BASE + 0x024)
+#define BIT_SW_RESET_STATUS (BIT_BASE + 0x034)
+
+//------------------------------------------------------------------------------
+// GLOBAL REGISTER
+//------------------------------------------------------------------------------
+#define BIT_CODE_BUF_ADDR (BIT_BASE + 0x100)
+#define BIT_WORK_BUF_ADDR (BIT_BASE + 0x104)
+#define BIT_PARA_BUF_ADDR (BIT_BASE + 0x108)
+#define BIT_BIT_STREAM_CTRL (BIT_BASE + 0x10C)
+#define BIT_FRAME_MEM_CTRL (BIT_BASE + 0x110)
+#define BIT_BIT_STREAM_PARAM (BIT_BASE + 0x114)
+#define BIT_TEMP_BUF_ADDR (BIT_BASE + 0x118)
+
+#define BIT_RD_PTR (BIT_BASE + 0x120)
+#define BIT_WR_PTR (BIT_BASE + 0x124)
+
+#define BIT_ROLLBACK_STATUS (BIT_BASE + 0x128) // internal used in f/w.
+
+#define BIT_AXI_SRAM_USE (BIT_BASE + 0x140)
+#define BIT_BYTE_POS_FRAME_START (BIT_BASE + 0x144)
+#define BIT_BYTE_POS_FRAME_END (BIT_BASE + 0x148)
+#define BIT_FRAME_CYCLE (BIT_BASE + 0x14C)
+
+#define BIT_FRM_DIS_FLG (BIT_BASE + 0x150)
+
+#define BIT_BUSY_FLAG (BIT_BASE + 0x160)
+#define BIT_RUN_COMMAND (BIT_BASE + 0x164)
+#define BIT_RUN_INDEX (BIT_BASE + 0x168)
+#define BIT_RUN_COD_STD (BIT_BASE + 0x16C)
+#define BIT_INT_ENABLE (BIT_BASE + 0x170)
+#define BIT_INT_REASON (BIT_BASE + 0x174)
+#define BIT_RUN_AUX_STD (BIT_BASE + 0x178)
+
+// MSG REGISTER ADDRESS changed
+#define BIT_MSG_0 (BIT_BASE + 0x130)
+#define BIT_MSG_1 (BIT_BASE + 0x134)
+#define BIT_MSG_2 (BIT_BASE + 0x138)
+#define BIT_MSG_3 (BIT_BASE + 0x13C)
+
+#define MBC_BUSY (MBC_BASE + 0x040)
+#define MC_BUSY (MC_BASE + 0x004)
+
+#define BIT_ME_LINEBUFFER_MODE (ME_BASE + 0x004) // CODA980
+#define BIT_ME_LINE_OVERFLOW (ME_BASE + 0x008) // CODA980
+#define BIT_ME_SEARCH_OVERFLOW (ME_BASE + 0x00C) // CODA980
+
+//------------------------------------------------------------------------------
+// [ENC SEQ INIT] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_ENC_SEQ_BB_START (BIT_BASE + 0x180)
+#define CMD_ENC_SEQ_BB_SIZE (BIT_BASE + 0x184)
+#define CMD_ENC_SEQ_OPTION                                                     \
+	(BIT_BASE +                                                            \
+	 0x188) // HecEnable,ConstIntraQp, FMO, QPREP, AUD, SLICE, MB BIT
+#define CMD_ENC_SEQ_COD_STD (BIT_BASE + 0x18C)
+#define CMD_ENC_SEQ_SRC_SIZE (BIT_BASE + 0x190)
+#define CMD_ENC_SEQ_SRC_F_RATE (BIT_BASE + 0x194)
+#define CMD_ENC_SEQ_MP4_PARA (BIT_BASE + 0x198)
+#define CMD_ENC_SEQ_263_PARA (BIT_BASE + 0x19C)
+#define CMD_ENC_SEQ_264_PARA (BIT_BASE + 0x1A0)
+#define CMD_ENC_SEQ_SLICE_MODE (BIT_BASE + 0x1A4)
+#define CMD_ENC_SEQ_GOP_NUM (BIT_BASE + 0x1A8)
+#define CMD_ENC_SEQ_RC_PARA (BIT_BASE + 0x1AC)
+#define CMD_ENC_SEQ_RC_BUF_SIZE (BIT_BASE + 0x1B0)
+#define CMD_ENC_SEQ_INTRA_REFRESH (BIT_BASE + 0x1B4)
+#define CMD_ENC_SEQ_VIDEO_SIGNAL_TYPE_PRESENT (BIT_BASE + 0x1BC)
+#define CMD_ENC_SEQ_INTRA_QP (BIT_BASE + 0x1C4)
+#define CMD_ENC_SEQ_RC_QP_MAX (BIT_BASE + 0x1C8)
+#define CMD_ENC_SEQ_RC_GAMMA (BIT_BASE + 0x1CC)
+#define CMD_ENC_SEQ_RC_INTERVAL_MODE                                           \
+	(BIT_BASE + 0x1D0) // mbInterval[32:2], rcIntervalMode[1:0]
+#define CMD_ENC_SEQ_INTRA_WEIGHT (BIT_BASE + 0x1D4)
+#define CMD_ENC_SEQ_ME_OPTION (BIT_BASE + 0x1D8)
+#define CMD_ENC_SEQ_RC_PARA2 (BIT_BASE + 0x1DC)
+#define CMD_ENC_SEQ_QP_RANGE_SET (BIT_BASE + 0x1E0)
+#define CMD_ENC_SEQ_RC_MAX_INTRA_SIZE (BIT_BASE + 0x1F0)
+
+#define CMD_ENC_SEQ_FIRST_MBA (BIT_BASE + 0x1E4)
+#define CMD_ENC_SEQ_HEIGHT_IN_MAP_UNITS (BIT_BASE + 0x1E8)
+#define CMD_ENC_SEQ_OVERLAP_CLIP_SIZE (BIT_BASE + 0x1EC)
+
+//------------------------------------------------------------------------------
+// [ENC SEQ END] COMMAND
+//------------------------------------------------------------------------------
+#define RET_ENC_SEQ_END_SUCCESS (BIT_BASE + 0x1C0)
+//------------------------------------------------------------------------------
+// [ENC PIC RUN] COMMAND
+//------------------------------------------------------------------------------
+
+#define CMD_ENC_PIC_SRC_INDEX (BIT_BASE + 0x180)
+#define CMD_ENC_PIC_SRC_STRIDE (BIT_BASE + 0x184)
+#define CMD_ENC_PIC_SRC_ADDR_Y (BIT_BASE + 0x1A8)
+#define CMD_ENC_PIC_SRC_ADDR_CB (BIT_BASE + 0x1AC)
+#define CMD_ENC_PIC_SRC_ADDR_CR (BIT_BASE + 0x1B0)
+#define CMD_ENC_PIC_SRC_BOTTOM_Y (BIT_BASE + 0x1E8) //coda980 only
+#define CMD_ENC_PIC_SRC_BOTTOM_CB (BIT_BASE + 0x1EC) //coda980 only
+#define CMD_ENC_PIC_SRC_BOTTOM_CR (BIT_BASE + 0x1F0) //coda980 only
+
+#define CMD_ENC_PIC_QS (BIT_BASE + 0x18C)
+#define CMD_ENC_PIC_ROT_MODE (BIT_BASE + 0x190)
+#define CMD_ENC_PIC_OPTION (BIT_BASE + 0x194)
+#define CMD_ENC_PIC_BB_START (BIT_BASE + 0x198)
+#define CMD_ENC_PIC_BB_SIZE (BIT_BASE + 0x19C)
+#define CMD_ENC_PIC_PARA_BASE_ADDR (BIT_BASE + 0x1A0)
+#define CMD_ENC_PIC_SUB_FRAME_SYNC (BIT_BASE + 0x1A4)
+
+#define RET_ENC_PIC_FRAME_NUM (BIT_BASE + 0x1C0)
+#define RET_ENC_PIC_TYPE (BIT_BASE + 0x1C4)
+#define RET_ENC_PIC_FRAME_IDX (BIT_BASE + 0x1C8)
+#define RET_ENC_PIC_SLICE_NUM (BIT_BASE + 0x1CC)
+#define RET_ENC_PIC_FLAG (BIT_BASE + 0x1D0)
+#define RET_ENC_PIC_SUCCESS (BIT_BASE + 0x1D8)
+
+//------------------------------------------------------------------------------
+// [ENC ROI INIT] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_ENC_ROI_MODE (BIT_BASE + 0x180) // [1]: RoiType, [0]: RoiEn
+#define CMD_ENC_ROI_NUM (BIT_BASE + 0x184) // [3:0] RoiNum
+
+#ifdef SUPPORT_ROI_50
+#define CMD_ENC_ROI_POS_0                                                      \
+	(BIT_BASE +                                                            \
+	 0x188) // [31:24]: MbyEnd, [23:16]: MbyStart, [15:8]: MbxEnd, [7:0]: MbxStart
+#define CMD_ENC_ROI_QP_0 (BIT_BASE + 0x18C)
+#define CMD_ENC_ROI_INDEX (BIT_BASE + 0x190)
+#else
+#define CMD_ENC_ROI_POS_0                                                      \
+	(BIT_BASE +                                                            \
+	 0x188) // [31:24]: MbyEnd, [23:16]: MbyStart, [15:8]: MbxEnd, [7:0]: MbxStart
+#define CMD_ENC_ROI_QP_0 (BIT_BASE + 0x18C) // [05:04]: RoiQp
+#define CMD_ENC_ROI_POS_1 (BIT_BASE + 0x190)
+#define CMD_ENC_ROI_QP_1 (BIT_BASE + 0x194)
+#define CMD_ENC_ROI_POS_2 (BIT_BASE + 0x198)
+#define CMD_ENC_ROI_QP_2 (BIT_BASE + 0x19C)
+#define CMD_ENC_ROI_POS_3 (BIT_BASE + 0x1A0)
+#define CMD_ENC_ROI_QP_3 (BIT_BASE + 0x1A4)
+#define CMD_ENC_ROI_POS_4 (BIT_BASE + 0x1A8)
+#define CMD_ENC_ROI_QP_4 (BIT_BASE + 0x1AC)
+#define CMD_ENC_ROI_POS_5 (BIT_BASE + 0x1B0)
+#define CMD_ENC_ROI_QP_5 (BIT_BASE + 0x1B4)
+#define CMD_ENC_ROI_POS_6 (BIT_BASE + 0x1B8)
+#define CMD_ENC_ROI_QP_6 (BIT_BASE + 0x1BC)
+#define CMD_ENC_ROI_POS_7 (BIT_BASE + 0x1C0)
+#define CMD_ENC_ROI_QP_7 (BIT_BASE + 0x1C4)
+#define CMD_ENC_ROI_POS_8 (BIT_BASE + 0x1C8)
+#define CMD_ENC_ROI_QP_8 (BIT_BASE + 0x1CC)
+#define CMD_ENC_ROI_POS_9 (BIT_BASE + 0x1D0)
+#define CMD_ENC_ROI_QP_9 (BIT_BASE + 0x1D4)
+#endif
+#define RET_ENC_ROI_SUCCESS (BIT_BASE + 0x1D8)
+
+//------------------------------------------------------------------------------
+// [ENC SET FRAME BUF] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_SET_FRAME_SUBSAMP_A (BIT_BASE + 0x188) //coda960 only
+#define CMD_SET_FRAME_SUBSAMP_B (BIT_BASE + 0x18C) //coda960 only
+#define CMD_SET_FRAME_SUBSAMP_A_MVC (BIT_BASE + 0x1B0) //coda960 only
+#define CMD_SET_FRAME_SUBSAMP_B_MVC (BIT_BASE + 0x1B4) //coda960 only
+
+#define CMD_SET_FRAME_DP_BUF_BASE (BIT_BASE + 0x1B0)
+#define CMD_SET_FRAME_DP_BUF_SIZE (BIT_BASE + 0x1B4)
+
+//------------------------------------------------------------------------------
+// [ENC HEADER] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_ENC_HEADER_CODE (BIT_BASE + 0x180)
+#define CMD_ENC_HEADER_BB_START (BIT_BASE + 0x184)
+#define CMD_ENC_HEADER_BB_SIZE (BIT_BASE + 0x188)
+#define CMD_ENC_HEADER_FRAME_CROP_H (BIT_BASE + 0x18C)
+#define CMD_ENC_HEADER_FRAME_CROP_V (BIT_BASE + 0x190)
+#define CMD_ENC_HEADER_CABAC_MODE (BIT_BASE + 0x194) // CODA980
+#define CMD_ENC_HEADER_CABAC_INIT_IDC (BIT_BASE + 0x198) // CODA980
+#define CMD_ENC_HEADER_TRANSFORM_8X8 (BIT_BASE + 0x19C) // CODA980
+#define CMD_ENC_HEADER_CHROMA_FORMAT (BIT_BASE + 0x1A0) // CODA980
+#define CMD_ENC_HEADER_FIELD_FLAG (BIT_BASE + 0x1A4)
+#define CMD_ENC_HEADER_PROFILE (BIT_BASE + 0x1A8) // CODA980
+
+#define RET_ENC_HEADER_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [ENC_PARA_SET] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_ENC_PARA_SET_TYPE (BIT_BASE + 0x180)
+#define RET_ENC_PARA_SET_SIZE (BIT_BASE + 0x1c0)
+#define RET_ENC_PARA_SET_SUCCESS (BIT_BASE + 0x1C4)
+
+//------------------------------------------------------------------------------
+// [ENC PARA CHANGE] COMMAND :
+//------------------------------------------------------------------------------
+#define CMD_ENC_PARAM_CHANGE_ENABLE                                            \
+	(BIT_BASE +                                                            \
+	 0x180) // FrameRateEn[3], BitRateEn[2], IntraQpEn[1], GopEn[0]
+#define CMD_ENC_PARAM_CHANGE_GOP_NUM (BIT_BASE + 0x184)
+#define CMD_ENC_PARAM_CHANGE_INTRA_QP (BIT_BASE + 0x188)
+#define CMD_ENC_PARAM_CHANGE_BITRATE (BIT_BASE + 0x18C)
+#define CMD_ENC_PARAM_CHANGE_F_RATE (BIT_BASE + 0x190)
+#define CMD_ENC_PARAM_CHANGE_INTRA_REFRESH (BIT_BASE + 0x194) // update param
+#define CMD_ENC_PARAM_CHANGE_SLICE_MODE (BIT_BASE + 0x198) // update param
+#define CMD_ENC_PARAM_CHANGE_HEC_MODE (BIT_BASE + 0x19C) // update param
+#define CMD_ENC_PARAM_CHANGE_CABAC_MODE                                        \
+	(BIT_BASE + 0x1A0) // entropyCodingMode==2
+#define CMD_ENC_PARAM_CHANGE_PPS_ID (BIT_BASE + 0x1B4) // entropyCodingMode==2
+
+#define RET_ENC_SEQ_PARA_CHANGE_SECCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [DEC SEQ INIT] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_DEC_SEQ_BB_START (BIT_BASE + 0x180)
+#define CMD_DEC_SEQ_BB_SIZE (BIT_BASE + 0x184)
+#define CMD_DEC_SEQ_OPTION (BIT_BASE + 0x188)
+
+#define CMD_DEC_SEQ_MP4_ASP_CLASS (BIT_BASE + 0x19C)
+#define CMD_DEC_SEQ_VC1_STREAM_FMT (BIT_BASE + 0x19C)
+#define CMD_DEC_SEQ_X264_MV_EN (BIT_BASE + 0x19C)
+#define CMD_DEC_SEQ_SPP_CHUNK_SIZE (BIT_BASE + 0x1A0)
+
+// For MPEG2 only
+#define CMD_DEC_SEQ_USER_DATA_OPTION (BIT_BASE + 0x194)
+#define CMD_DEC_SEQ_USER_DATA_BASE_ADDR (BIT_BASE + 0x1AC)
+#define CMD_DEC_SEQ_USER_DATA_BUF_SIZE (BIT_BASE + 0x1B0)
+
+#define CMD_DEC_SEQ_INIT_ESCAPE (BIT_BASE + 0x114)
+
+#define RET_DEC_SEQ_BIT_RATE (BIT_BASE + 0x1B4)
+#define RET_DEC_SEQ_EXT_INFO (BIT_BASE + 0x1B8)
+#define RET_DEC_SEQ_SUCCESS (BIT_BASE + 0x1C0)
+#define RET_DEC_SEQ_SRC_SIZE (BIT_BASE + 0x1C4)
+
+#define RET_DEC_SEQ_ASPECT (BIT_BASE + 0x1C8)
+#define RET_DEC_SEQ_FRAME_NEED (BIT_BASE + 0x1CC)
+#define RET_DEC_SEQ_FRAME_DELAY (BIT_BASE + 0x1D0)
+#define RET_DEC_SEQ_INFO (BIT_BASE + 0x1D4)
+#define RET_DEC_SEQ_VP8_SCALE_INFO (BIT_BASE + 0x1D4)
+
+#define RET_DEC_SEQ_CROP_LEFT_RIGHT (BIT_BASE + 0x1D8)
+#define RET_DEC_SEQ_CROP_TOP_BOTTOM (BIT_BASE + 0x1DC)
+#define RET_DEC_SEQ_SEQ_ERR_REASON (BIT_BASE + 0x1E0)
+
+#define RET_DEC_SEQ_FRATE_NR (BIT_BASE + 0x1E4)
+#define RET_DEC_SEQ_FRATE_DR (BIT_BASE + 0x1E8)
+#define RET_DEC_SEQ_HEADER_REPORT (BIT_BASE + 0x1EC)
+#define RET_DEC_SEQ_VUI_INFO (BIT_BASE + 0x18C)
+#define RET_DEC_SEQ_VUI_INFO_2 (BIT_BASE + 0x17C)
+#define RET_DEC_SEQ_VUI_PIC_STRUCT (BIT_BASE + 0x1A8)
+
+#define RET_DEC_SEQ_MP2_BAR_LEFT_RIGHT (BIT_BASE + 0x180)
+#define RET_DEC_SEQ_MP2_BAR_TOP_BOTTOM (BIT_BASE + 0x184)
+
+#define RET_DEC_PIC_MP2_OFFSET1 (BIT_BASE + 0x19C) // for MP2
+#define RET_DEC_PIC_MP2_OFFSET2 (BIT_BASE + 0x1A0) // for MP2
+#define RET_DEC_PIC_MP2_OFFSET3 (BIT_BASE + 0x1A4) // for MP2
+#define RET_DEC_PIC_MP2_OFFSET_NUM (BIT_BASE + 0x1A8) // for MP2
+
+//------------------------------------------------------------------------------
+// [DEC SEQ END] COMMAND
+//------------------------------------------------------------------------------
+#define RET_DEC_SEQ_END_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [DEC PIC RUN] COMMAND
+//----------------------------------------------------
+#define CMD_DEC_PIC_ROT_MODE (BIT_BASE + 0x180)
+#define CMD_DEC_PIC_ROT_INDEX (BIT_BASE + 0x184)
+#define CMD_DEC_PIC_ROT_ADDR_Y (BIT_BASE + 0x188)
+#define CMD_DEC_PIC_ROT_ADDR_CB (BIT_BASE + 0x18C)
+#define CMD_DEC_PIC_ROT_ADDR_CR (BIT_BASE + 0x190)
+#define CMD_DEC_PIC_ROT_STRIDE (BIT_BASE + 0x1B8)
+#define CMD_DEC_PIC_ROT_BOTTOM_Y (BIT_BASE + 0x1E8) // coda980 only
+#define CMD_DEC_PIC_ROT_BOTTOM_CB (BIT_BASE + 0x1EC) // coda980 only
+#define CMD_DEC_PIC_ROT_BOTTOM_CR (BIT_BASE + 0x1F0) // coda980 only
+
+#define CMD_DEC_PIC_OPTION (BIT_BASE + 0x194)
+
+#define CMD_DEC_PIC_USER_DATA_BASE_ADDR (BIT_BASE + 0x1AC)
+#define CMD_DEC_PIC_USER_DATA_BUF_SIZE (BIT_BASE + 0x1B0)
+
+#define CMD_DEC_PIC_NUM_ROWS (BIT_BASE + 0x1B4)
+#define CMD_DEC_PIC_THO_PIC_PARA (BIT_BASE + 0x198)
+#define CMD_DEC_PIC_THO_QMAT_ADDR (BIT_BASE + 0x1A0)
+#define CMD_DEC_PIC_THO_MB_PARA_ADDR (BIT_BASE + 0x1A4)
+#define RET_DEC_PIC_VUI_PIC_STRUCT (BIT_BASE + 0x1A8)
+#define RET_DEC_PIC_AVC_FPA_SEI0 (BIT_BASE + 0x19C)
+#define RET_DEC_PIC_AVC_FPA_SEI1 (BIT_BASE + 0x1A0)
+#define RET_DEC_PIC_AVC_FPA_SEI2 (BIT_BASE + 0x1A4)
+#define RET_DEC_NUM_MB_ROWS (BIT_BASE + 0x1B4) // it will be update
+#define RET_DEC_PIC_AVC_SEI_RP_INFO (BIT_BASE + 0x1B4)
+#define RET_DEC_PIC_HRD_INFO (BIT_BASE + 0x1B8)
+#define RET_DEC_PIC_SIZE (BIT_BASE + 0x1BC)
+#define RET_DEC_PIC_FRAME_NUM (BIT_BASE + 0x1C0)
+#define RET_DEC_PIC_FRAME_IDX (BIT_BASE + 0x1C4)
+#define RET_DEC_PIC_DISPLAY_IDX (BIT_BASE + 0x1C4)
+#define RET_DEC_PIC_ERR_MB (BIT_BASE + 0x1C8)
+#define RET_DEC_PIC_TYPE (BIT_BASE + 0x1CC)
+#define RET_DEC_PIC_POST (BIT_BASE + 0x1D0) // for VC1
+#define RET_DEC_PIC_MVC_REPORT (BIT_BASE + 0x1D0) // for MVC
+#define RET_DEC_PIC_OPTION (BIT_BASE + 0x1D4)
+#define RET_DEC_PIC_SUCCESS (BIT_BASE + 0x1D8)
+#define RET_DEC_PIC_CUR_IDX (BIT_BASE + 0x1DC)
+#define RET_DEC_PIC_DECODED_IDX (BIT_BASE + 0x1DC)
+#define RET_DEC_PIC_CROP_LEFT_RIGHT (BIT_BASE + 0x1E0) // for AVC, MPEG-2
+#define RET_DEC_PIC_CROP_TOP_BOTTOM (BIT_BASE + 0x1E4) // for AVC, MPEG-2
+#define RET_DEC_PIC_MODULO_TIME_BASE (BIT_BASE + 0x1E0) // for MP4
+#define RET_DEC_PIC_VOP_TIME_INCREMENT (BIT_BASE + 0x1E4) // for MP4
+#define RET_DEC_PIC_RV_TR (BIT_BASE + 0x1E8)
+#define RET_DEC_PIC_VP8_PIC_REPORT (BIT_BASE + 0x1E8)
+#define RET_DEC_PIC_ATSC_USER_DATA_INFO (BIT_BASE + 0x1E8) // H.264, MEPEG2
+#define RET_DEC_PIC_VUI_INFO_2 (BIT_BASE + 0x17C) // H.264, MPEG2
+#define RET_DEC_PIC_VUI_INFO (BIT_BASE + 0x1EC)
+#define RET_DEC_PIC_RV_TR_BFRAME (BIT_BASE + 0x1EC)
+#define RET_DEC_PIC_ASPECT (BIT_BASE + 0x1F0)
+#define RET_DEC_PIC_VP8_SCALE_INFO (BIT_BASE + 0x1F0)
+#define RET_DEC_PIC_FRATE_NR (BIT_BASE + 0x1F4)
+#define RET_DEC_PIC_FRATE_DR (BIT_BASE + 0x1F8)
+#define RET_DEC_PIC_POC_TOP (BIT_BASE + 0x1AC)
+#define RET_DEC_PIC_POC_BOT (BIT_BASE + 0x1B0)
+#define RET_DEC_PIC_POC (BIT_BASE + 0x1B0)
+
+//------------------------------------------------------------------------------
+// [DEC SET FRAME BUF] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_SET_FRAME_BUF_NUM (BIT_BASE + 0x180)
+#define CMD_SET_FRAME_BUF_STRIDE (BIT_BASE + 0x184)
+
+#define CMD_SET_FRAME_SLICE_BB_START (BIT_BASE + 0x188)
+#define CMD_SET_FRAME_SLICE_BB_SIZE (BIT_BASE + 0x18C)
+#define CMD_SET_FRAME_AXI_BIT_ADDR (BIT_BASE + 0x190)
+#define CMD_SET_FRAME_AXI_IPACDC_ADDR (BIT_BASE + 0x194)
+#define CMD_SET_FRAME_AXI_DBKY_ADDR (BIT_BASE + 0x198)
+#define CMD_SET_FRAME_AXI_DBKC_ADDR (BIT_BASE + 0x19C)
+#define CMD_SET_FRAME_AXI_OVL_ADDR (BIT_BASE + 0x1A0)
+#define CMD_SET_FRAME_AXI_BTP_ADDR (BIT_BASE + 0x1A4)
+
+#define CMD_SET_FRAME_CACHE_SIZE (BIT_BASE + 0x1A8)
+#define CMD_SET_FRAME_CACHE_CONFIG (BIT_BASE + 0x1AC)
+#define CMD_SET_FRAME_MB_BUF_BASE (BIT_BASE + 0x1B0)
+#define CMD_SET_FRAME_MAX_DEC_SIZE (BIT_BASE + 0x1B8)
+#define CMD_SET_FRAME_DELAY (BIT_BASE + 0x1BC)
+
+#define RET_SET_FRAME_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [DEC_PARA_SET] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_DEC_PARA_SET_TYPE (BIT_BASE + 0x180)
+#define CMD_DEC_PARA_SET_SIZE (BIT_BASE + 0x184)
+#define RET_DEC_PARA_SET_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [DEC_BUF_FLUSH] COMMAND
+//------------------------------------------------------------------------------
+#define RET_DEC_BUF_FLUSH_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [SLEEP/WAKE] COMMAND
+//------------------------------------------------------------------------------
+#define RET_SLEEP_WAKE_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [SET PIC INFO] COMMAND
+//------------------------------------------------------------------------------
+#define GDI_PRI_RD_PRIO_L (GDMA_BASE + 0x000)
+#define GDI_PRI_RD_PRIO_H (GDMA_BASE + 0x004)
+#define GDI_PRI_WR_PRIO_L (GDMA_BASE + 0x008)
+#define GDI_PRI_WR_PRIO_H (GDMA_BASE + 0x00c)
+#define GDI_PRI_RD_LOCK_CNT (GDMA_BASE + 0x010)
+#define GDI_PRI_WR_LOCK_CNT (GDMA_BASE + 0x014)
+#define GDI_SEC_RD_PRIO_L (GDMA_BASE + 0x018)
+#define GDI_SEC_RD_PRIO_H (GDMA_BASE + 0x01c)
+#define GDI_SEC_WR_PRIO_L (GDMA_BASE + 0x020)
+#define GDI_SEC_WR_PRIO_H (GDMA_BASE + 0x024)
+#define GDI_SEC_RD_LOCK_CNT (GDMA_BASE + 0x028)
+#define GDI_SEC_WR_LOCK_CNT (GDMA_BASE + 0x02c)
+#define GDI_SEC_CLIENT_EN (GDMA_BASE + 0x030)
+#define GDI_CONTROL (GDMA_BASE + 0x034)
+#define GDI_PIC_INIT_HOST (GDMA_BASE + 0x038)
+
+#define GDI_HW_VERINFO (GDMA_BASE + 0x050)
+#define GDI_PINFO_REQ (GDMA_BASE + 0x060)
+#define GDI_PINFO_ACK (GDMA_BASE + 0x064)
+#define GDI_PINFO_ADDR (GDMA_BASE + 0x068)
+#define GDI_PINFO_DATA (GDMA_BASE + 0x06c)
+#define GDI_BWB_ENABLE (GDMA_BASE + 0x070)
+#define GDI_BWB_SIZE (GDMA_BASE + 0x074)
+#define GDI_BWB_STD_STRUCT (GDMA_BASE + 0x078)
+#define GDI_BWB_STATUS (GDMA_BASE + 0x07c)
+
+#define GDI_STATUS (GDMA_BASE + 0x080)
+
+#define GDI_DEBUG_0 (GDMA_BASE + 0x084)
+#define GDI_DEBUG_1 (GDMA_BASE + 0x088)
+#define GDI_DEBUG_2 (GDMA_BASE + 0x08c)
+#define GDI_DEBUG_3 (GDMA_BASE + 0x090)
+#define GDI_DEBUG_PROBE_ADDR (GDMA_BASE + 0x094)
+#define GDI_DEBUG_PROBE_DATA (GDMA_BASE + 0x098)
+
+// write protect
+#define GDI_WPROT_ERR_CLR (GDMA_BASE + 0x0A0)
+#define GDI_WPROT_ERR_RSN (GDMA_BASE + 0x0A4)
+#define GDI_WPROT_ERR_ADR (GDMA_BASE + 0x0A8)
+#define GDI_WPROT_RGN_EN (GDMA_BASE + 0x0AC)
+#define GDI_WPROT_RGN0_STA (GDMA_BASE + 0x0B0)
+#define GDI_WPROT_RGN0_END (GDMA_BASE + 0x0B4)
+#define GDI_WPROT_RGN1_STA (GDMA_BASE + 0x0B8)
+#define GDI_WPROT_RGN1_END (GDMA_BASE + 0x0BC)
+#define GDI_WPROT_RGN2_STA (GDMA_BASE + 0x0C0)
+#define GDI_WPROT_RGN2_END (GDMA_BASE + 0x0C4)
+#define GDI_WPROT_RGN3_STA (GDMA_BASE + 0x0C8)
+#define GDI_WPROT_RGN3_END (GDMA_BASE + 0x0CC)
+#define GDI_WPROT_RGN4_STA (GDMA_BASE + 0x0D0)
+#define GDI_WPROT_RGN4_END (GDMA_BASE + 0x0D4)
+#define GDI_WPROT_RGN5_STA (GDMA_BASE + 0x0D8)
+#define GDI_WPROT_RGN5_END (GDMA_BASE + 0x0DC)
+#define GDI_WPROT_REGIONS 6
+
+#define GDI_BUS_CTRL (GDMA_BASE + 0x0F0)
+#define GDI_BUS_STATUS (GDMA_BASE + 0x0F4)
+
+#define GDI_SIZE_ERR_FLAG (GDMA_BASE + 0x0e0)
+#define GDI_ADR_RQ_SIZE_ERR_PRI0 (GDMA_BASE + 0x100)
+#define GDI_ADR_RQ_SIZE_ERR_PRI1 (GDMA_BASE + 0x104)
+#define GDI_ADR_RQ_SIZE_ERR_PRI1 (GDMA_BASE + 0x104)
+#define GDI_ADR_RQ_SIZE_ERR_PRI2 (GDMA_BASE + 0x108)
+#define GDI_ADR_WQ_SIZE_ERR_PRI0 (GDMA_BASE + 0x10c)
+#define GDI_ADR_WQ_SIZE_ERR_PRI1 (GDMA_BASE + 0x110)
+#define GDI_ADR_WQ_SIZE_ERR_PRI2 (GDMA_BASE + 0x114)
+
+#define GDI_ADR_RQ_SIZE_ERR_SEC0 (GDMA_BASE + 0x118)
+#define GDI_ADR_RQ_SIZE_ERR_SEC1 (GDMA_BASE + 0x11c)
+#define GDI_ADR_RQ_SIZE_ERR_SEC2 (GDMA_BASE + 0x120)
+
+#define GDI_ADR_WQ_SIZE_ERR_SEC0 (GDMA_BASE + 0x124)
+#define GDI_ADR_WQ_SIZE_ERR_SEC1 (GDMA_BASE + 0x128)
+#define GDI_ADR_WQ_SIZE_ERR_SEC2 (GDMA_BASE + 0x12c)
+
+#define GDI_INFO_CONTROL (GDMA_BASE + 0x400)
+#define GDI_INFO_PIC_SIZE (GDMA_BASE + 0x404)
+// GDI 2.0 register
+#define GDI_INFO_BASE_Y_TOP (GDMA_BASE + 0x408)
+#define GDI_INFO_BASE_CB_TOP (GDMA_BASE + 0x40C)
+#define GDI_INFO_BASE_CR_TOP (GDMA_BASE + 0x410)
+#define GDI_INFO_BASE_Y_BOT (GDMA_BASE + 0x414)
+#define GDI_INFO_BASE_CB_BOT (GDMA_BASE + 0x418)
+#define GDI_INFO_BASE_CR_BOT (GDMA_BASE + 0x41C)
+#define GDI_XY2AXI_LUM_BIT00 (GDMA_BASE + 0x800)
+#define GDI_XY2AXI_LUM_BIT1F (GDMA_BASE + 0x87C)
+#define GDI_XY2AXI_CHR_BIT00 (GDMA_BASE + 0x880)
+#define GDI_XY2AXI_CHR_BIT1F (GDMA_BASE + 0x8FC)
+#define GDI_XY2AXI_CONFIG (GDMA_BASE + 0x900)
+
+//GDI 1.0 register
+#define GDI_INFO_BASE_Y (GDMA_BASE + 0x408)
+#define GDI_INFO_BASE_CB (GDMA_BASE + 0x40C)
+#define GDI_INFO_BASE_CR (GDMA_BASE + 0x410)
+
+#define GDI_XY2_CAS_0 (GDMA_BASE + 0x800)
+#define GDI_XY2_CAS_F (GDMA_BASE + 0x83C)
+
+#define GDI_XY2_BA_0 (GDMA_BASE + 0x840)
+#define GDI_XY2_BA_1 (GDMA_BASE + 0x844)
+#define GDI_XY2_BA_2 (GDMA_BASE + 0x848)
+#define GDI_XY2_BA_3 (GDMA_BASE + 0x84C)
+
+#define GDI_XY2_RAS_0 (GDMA_BASE + 0x850)
+#define GDI_XY2_RAS_F (GDMA_BASE + 0x88C)
+
+#define GDI_XY2_RBC_CONFIG (GDMA_BASE + 0x890)
+#define GDI_RBC2_AXI_0 (GDMA_BASE + 0x8A0)
+#define GDI_RBC2_AXI_1F (GDMA_BASE + 0x91C)
+#define GDI_TILEDBUF_BASE (GDMA_BASE + 0x920)
+
+//------------------------------------------------------------------------------
+// Product, Reconfiguration Information
+//------------------------------------------------------------------------------
+#define DBG_CONFIG_REPORT_0 (GDMA_BASE + 0x040) //product name and version
+#define DBG_CONFIG_REPORT_1                                                    \
+	(GDMA_BASE + 0x044) //interface configuration, hardware definition
+#define DBG_CONFIG_REPORT_2 (GDMA_BASE + 0x048) //standard definition
+#define DBG_CONFIG_REPORT_3 (GDMA_BASE + 0x04C) //standard detail definition
+#define DBG_CONFIG_REPORT_4 (GDMA_BASE + 0x050) //definition in cnm_define
+#define DBG_CONFIG_REPORT_5 (GDMA_BASE + 0x054)
+#define DBG_CONFIG_REPORT_6 (GDMA_BASE + 0x058)
+#define DBG_CONFIG_REPORT_7 (GDMA_BASE + 0x05C)
+
+//------------------------------------------------------------------------------
+// MEMORY COPY MODULE REGISTER
+//------------------------------------------------------------------------------
+#define ADDR_DMAC_PIC_RUN (DMAC_BASE + 0x000)
+#define ADDR_DMAC_PIC_STATUS (DMAC_BASE + 0x004)
+#define ADDR_DMAC_PIC_OP_MODE (DMAC_BASE + 0x008)
+#define ADDR_DMAC_ID (DMAC_BASE + 0x00c) //the result muse be 0x4d435059
+
+#define ADDR_DMAC_SRC_BASE_Y (DMAC_BASE + 0x010)
+#define ADDR_DMAC_SRC_BASE_CB (DMAC_BASE + 0x014)
+#define ADDR_DMAC_SRC_BASE_CR (DMAC_BASE + 0x018)
+#define ADDR_DMAC_SRC_STRIDE (DMAC_BASE + 0x01c)
+
+#define ADDR_DMAC_DST_BASE_Y (DMAC_BASE + 0x020)
+#define ADDR_DMAC_DST_BASE_CB (DMAC_BASE + 0x024)
+#define ADDR_DMAC_DST_BASE_CR (DMAC_BASE + 0x028)
+#define ADDR_DMAC_DST_STRIDE (DMAC_BASE + 0x02c)
+
+#define ADDR_DMAC_SRC_MB_POS_X (DMAC_BASE + 0x030)
+#define ADDR_DMAC_SRC_MB_POS_Y (DMAC_BASE + 0x034)
+#define ADDR_DMAC_SRC_MB_BLK_X (DMAC_BASE + 0x038)
+#define ADDR_DMAC_SRC_MB_BLK_Y (DMAC_BASE + 0x03c)
+
+#define ADDR_DMAC_DST_MB_POS_X (DMAC_BASE + 0x040)
+#define ADDR_DMAC_DST_MB_POS_Y (DMAC_BASE + 0x044)
+#define ADDR_DMAC_DST_MB_BLK_X (DMAC_BASE + 0x048)
+#define ADDR_DMAC_DST_MB_BLK_Y (DMAC_BASE + 0x04c)
+
+#define ADDR_DMAC_SET_COLOR_Y (DMAC_BASE + 0x050)
+#define ADDR_DMAC_SET_COLOR_CB (DMAC_BASE + 0x054)
+#define ADDR_DMAC_SET_COLOR_CR (DMAC_BASE + 0x058)
+
+#define ADDR_DMAC_SUB_SAMPLE_X (DMAC_BASE + 0x060)
+#define ADDR_DMAC_SUB_SAMPLE_Y (DMAC_BASE + 0x064)
+
+//------------------------------------------------------------------------------
+// DMAC
+//------------------------------------------------------------------------------
+#define DMAC_DMAC_RUN (DMAC_BASE + 0x00)
+#define DMAC_SOFT_RESET (DMAC_BASE + 0x04)
+#define DMAC_DMAC_MODE (DMAC_BASE + 0x08)
+#define DMAC_DESC_ADDR (DMAC_BASE + 0x0c)
+#define DMAC_DESC0 (DMAC_BASE + 0x10)
+#define DMAC_DESC1 (DMAC_BASE + 0x14)
+#define DMAC_DESC2 (DMAC_BASE + 0x18)
+#define DMAC_DESC3 (DMAC_BASE + 0x1c)
+#define DMAC_DESC4 (DMAC_BASE + 0x20)
+#define DMAC_DESC5 (DMAC_BASE + 0x24)
+#define DMAC_DESC6 (DMAC_BASE + 0x28)
+#define DMAC_DESC7 (DMAC_BASE + 0x2c)
+
+//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
+// [FIRMWARE VERSION] COMMAND
+// [32:16] project number =>
+// [16:0]  version => xxxx.xxxx.xxxxxxxx
+//------------------------------------------------------------------------------
+#define RET_FW_VER_NUM (BIT_BASE + 0x1c0)
+#define RET_FW_CODE_REV (BIT_BASE + 0x1c4)
+
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_v4l2.c
@@ -0,0 +1,1542 @@
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-event.h>
+
+#include "drv_if.h"
+#include "vpu.h"
+#include "ve1_v4l2.h"
+#include "ve1_mem.h"
+#include "debug.h"
+#include "ve1_wrapper.h"
+#include "ve1_vpuapi.h"
+
+extern const struct ve1_ctx_ops ve1_decode_ops;
+extern int ve1_fill_bitstream(struct ve1_ctx *ctx, uint8_t *buf, uint32_t len,
+			      uint64_t timestamp, uint32_t sequence);
+extern void ve1_show_displayable_frame_list(struct ve1_ctx *ctx);
+#ifdef VPU_GET_CC
+extern void ProcessCC_Display(void *ctx, long long PTS, int display_index);
+#endif
+#define VENG_ID 1
+
+#define HAS_REG_DPBS(ctx) \
+		((((struct ve1_ctx *)ctx)->fbAllocInfo) != NULL)
+
+/*
+ * Return vpu_ctx structure for a given struct v4l2_fh
+ */
+static struct vpu_ctx *fh_to_vpu(struct v4l2_fh *fh)
+{
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	return vid_ctx->vpu_ctx;
+}
+
+/*
+ * Return ve1_ctx structure for a given struct v4l2_fh
+ */
+static struct ve1_ctx *fh_to_ve(struct v4l2_fh *fh)
+{
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	return vid_ctx->ve_ctx;
+}
+
+/*
+ * Return ve1_ctx structure for a given struct vb2_queue
+ */
+static struct ve1_ctx *vq_to_ve(struct vb2_queue *q)
+{
+	struct videc_ctx *vid_ctx = vb2_get_drv_priv(q);
+	return vid_ctx->ve_ctx;
+}
+
+static void ve1_pic_run_work(struct work_struct *work)
+{
+	struct ve1_ctx *ctx = container_of(work, struct ve1_ctx, pic_run_work);
+	int ret;
+	bool queueRet = false;
+
+	if (ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "ctx is NULL\n");
+		return;
+	}
+
+	mutex_lock(&ctx->ve1_mutex);
+
+	ctx->cntExecPicRunWork++;
+
+	if (ctx->bFlush) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"do thing due to flushing\n");
+		goto out;
+	}
+
+	// RDK-1479, while entering ve1_pic_run_work(), maybe seq_end_work is already done and ve1DecState is VE1_STATE_DEC_UNINIT, it should not start to decode
+	if (ctx->ve1DecState < VE1_STATE_DEC_SEQ_INIT_DONE) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"exit ve1_pic_run_work due to ve1DecState:%d\n",
+			ctx->ve1DecState);
+		goto out;
+	}
+
+	if ((ctx->ve1DecState == VE1_STATE_DEC_SEQ_INIT_DONE) &&
+	    (ctx->streamon_cap == 0)) {
+		ve1_info(VE1_LOGTAG, "seq int done but not streamon_cap\n");
+	}
+
+	if (ctx->free_cap) {
+		ctx->free_cap = 0;
+		rtkve1_unreg_dpbs((void *)ctx);
+		//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+		//	"goto out\n");
+		//goto out;
+	}
+
+	if (!HAS_REG_DPBS(ctx) && (ctx->capReqBufsCnt != 0) && (ctx->regFbCount == 0)) {
+		ret = rtkve1_register_dpbs((void *)ctx);
+		if (ret < 0) {
+			ve1_err(VE1_LOGTAG,
+				"rtkve1_register_dpbs() fail.ret:%d.ctx:0x%px\n", ret, ctx);
+			ctx->fatal_err = 1;
+			goto err;
+		}
+		ctx->ve1DecState = VE1_STATE_DEC_SET_DPB;
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "set ve1DecState:%d\n",
+		ctx->ve1DecState);
+	}
+	else if (HAS_REG_DPBS(ctx)) {
+		ret = rtkve1_check_new_dpb((void *)ctx);
+		if (ret != 0) {
+			ve1_err(VE1_LOGTAG, "rtkve1_check_new_dpb() fail.ret:%d\n",ret);
+		}
+	}
+
+	if (ctx->ve1DecState < VE1_STATE_DEC_SET_DPB) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"exit ve1_pic_run_work due to ve1DecState:%d\n",
+			ctx->ve1DecState);
+		goto out;
+	}
+
+	if (ctx->bSuspend) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"postpone decoding due to suspend.ve1DecState:%d\n",
+			ctx->ve1DecState);
+		goto out;
+	}
+
+	ret = ctx->ops->prepare_run(ctx);
+	if (ret < 0) {
+		goto out;
+	}
+
+	// if bBufEmptyFlag and no more out_qbuf (streamEnd), "queue_work pic_run_work" won't triggered in VE1_DecUpdateBS(), do it here
+	if (ctx->bBufEmptyFlag && ctx->streamEnd) {
+		queueRet = queue_work(ctx->workqueue, &ctx->pic_run_work);
+		if (queueRet)
+			ctx->cntQueuePicRunWorkOk++;
+		else
+			ctx->cntQueuePicRunWorkFail++;
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"queue_work pic_run_work.cnt(%d,%d).ret:%d\n",
+			ctx->cntQueuePicRunWorkOk, ctx->cntQueuePicRunWorkFail,
+			queueRet);
+	}
+
+	if ((ctx->ve1DecState == VE1_STATE_DEC_START_DEC_ISSUED) &&
+	    (!ctx->bBufEmptyFlag) && (!ctx->bWaitNextField)) {
+		ret = VE1_DecWaitPicDone(ctx);
+		if (ret > 0) {
+			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "finish_run\n");
+			ret = ctx->ops->finish_run(ctx);
+			if (ret < 0) {
+				ve1_err(VE1_LOGTAG,
+					"af finish_run.fatal error.no more decode\n");
+			} else if (ret) {
+				queueRet = queue_work(ctx->workqueue,
+						      &ctx->pic_run_work);
+				if (queueRet)
+					ctx->cntQueuePicRunWorkOk++;
+				else
+					ctx->cntQueuePicRunWorkFail++;
+				ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+					"queue_work pic_run_work.cnt(%d,%d).ret:%d\n",
+					ctx->cntQueuePicRunWorkOk,
+					ctx->cntQueuePicRunWorkFail, queueRet);
+			}
+		}
+		if (ctx->bWaitNextField) {
+			queueRet =
+				queue_work(ctx->workqueue, &ctx->pic_run_work);
+			if (queueRet)
+				ctx->cntQueuePicRunWorkOk++;
+			else
+				ctx->cntQueuePicRunWorkFail++;
+			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+				"queue_work pic_run_work.cnt(%d,%d).ret:%d\n",
+				ctx->cntQueuePicRunWorkOk,
+				ctx->cntQueuePicRunWorkFail, queueRet);
+		}
+	}
+
+	if (ctx->aborting &&
+	    ctx->ops->seq_end_work) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "queue_work seq_end_work\n");
+		queue_work(ctx->workqueue, &ctx->seq_end_work);
+	}
+
+out:
+	mutex_unlock(&ctx->ve1_mutex);
+	return;
+
+err:
+	if (ctx->fatal_err) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"VE1_DecCheckComplete\n");
+		VE1_DecCheckComplete(ctx);
+		if (ctx->ops->seq_end_work) {
+			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "queue_work seq_end_work\n");
+			queue_work(ctx->workqueue, &ctx->seq_end_work);
+		}
+	}
+	mutex_unlock(&ctx->ve1_mutex);
+	return;
+}
+
+static int ve1_start_streaming(struct vb2_queue *q, uint32_t count,
+			       int pixelformat)
+{
+	int ret = 0;
+	struct ve1_ctx *ctx;
+	struct ve1_decopen_param open_param;
+	struct videc_ctx *vid_ctx = vb2_get_drv_priv(q);
+	struct vpu_ctx *vpu_ctx = vid_ctx->vpu_ctx;
+	bool queueRet = false;
+
+	if (q == NULL) {
+		ve1_err(VE1_LOGTAG, "q is NULL\n");
+		return -EINVAL;
+	}
+	ctx = vq_to_ve(q);
+	if (ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "ctx is NULL\n");
+		return -EINVAL;
+	}
+
+	if (vid_ctx == NULL) {
+		pr_err("%s [%d]%s.vid_ctx is NULL\n", VE1_LOGTAG, __LINE__,
+		       __func__);
+		return -EINVAL;
+	}
+	ctx->pdev = vid_ctx->dev->dev;
+
+	ve1_dbg(VPU_DBG_INPUT, VE1_LOGTAG,
+		"[+] ctx:0x%px.type:%s.count:%d.pixelformat:%4s.is_secure:%d.memory:%d.pdev:0x%px\n",
+		ctx, V4L2_TYPE_TO_STR(q->type), count, (char *)&pixelformat,
+		vid_ctx->params.is_secure, q->memory, ctx->pdev);
+
+	if (!ctx->ops) // ve1 hasn't been inited
+	{
+		// set struct ve1_ctx_ops
+		ctx->ops = &ve1_decode_ops;
+		// allocate workqueue
+		ctx->workqueue = alloc_workqueue(
+			"v4l2_ve1", WQ_UNBOUND | WQ_MEM_RECLAIM, 1);
+		if (!ctx->workqueue) {
+			ve1_err(VE1_LOGTAG, "[-] unable to alloc workqueue\n");
+			return -ENOMEM;
+		}
+
+		// init a struct work_struct for pic_run_work
+		INIT_WORK(&ctx->pic_run_work, ve1_pic_run_work);
+		if (ctx->ops->seq_init_work) {
+			// init a struct work_struct for seq_init_work
+			INIT_WORK(&ctx->seq_init_work, ctx->ops->seq_init_work);
+		}
+		if (ctx->ops->seq_end_work) {
+			// init a struct work_struct for seq_end_work
+			INIT_WORK(&ctx->seq_end_work, ctx->ops->seq_end_work);
+		}
+
+		// init struct mutex ve1_mutex
+		mutex_init(&ctx->ve1_mutex);
+
+		// init struct mutex ve1_dma_mutex
+		mutex_init(&ctx->ve1_dma_mutex);
+
+		// init struct list_head buffer_meta_list
+		INIT_LIST_HEAD(&ctx->buffer_meta_list);
+		// init spinlock_t buffer_meta_lock
+		spin_lock_init(&ctx->buffer_meta_lock);
+
+		// init struct list_head displayable_frame_list
+		INIT_LIST_HEAD(&ctx->displayable_frame_list);
+		// init spinlock_t displayable_frame_lock
+		spin_lock_init(&ctx->displayable_frame_lock);
+	}
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type) && (ctx->streamon_out == 1)) {
+		ve1_err(VE1_LOGTAG, "[-] OUTPUT is already stream on\n");
+		return -EPERM;
+	} else if (!V4L2_TYPE_IS_OUTPUT(q->type) && (ctx->streamon_cap == 1)) {
+		ve1_err(VE1_LOGTAG, "[-] CAPTURE is already stream on\n");
+		return -EPERM;
+	}
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		// ctx->ops->start_streaming(ctx) => ve1_start_decoding() => ve1_alloc_bitstream_buffer(), ve1_alloc_bitstream_buffer() needs ctx->is_svp
+		mutex_lock(&ctx->ve1_mutex);
+		ctx->is_svp = vid_ctx->params.is_secure;
+		ctx->out_vb2_q_memory = q->memory;
+		if (ctx->is_svp &&
+		    ctx->out_vb2_q_memory != V4L2_MEMORY_DMABUF) {
+			ret = -EPERM;
+			ve1_err(VE1_LOGTAG,
+				"[-] not support svp + OUTPUT memory is not V4L2_MEMORY_DMABUF\n");
+			goto out;
+		}
+		mutex_unlock(&ctx->ve1_mutex);
+	}
+
+	ret = ctx->ops->start_streaming(ctx);
+	if (ret < 0) {
+		ve1_err(VE1_LOGTAG, "[-] start_streaming() fail.ret:%d\n", ret);
+		return ret;
+	}
+
+	mutex_lock(&ctx->ve1_mutex);
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"ve1DecState:%d.is_svp:%d.out_vb2_q_memory:%d\n",
+			ctx->ve1DecState, ctx->is_svp, ctx->out_vb2_q_memory);
+
+		if (ctx->ve1DecState == VE1_STATE_DEC_UNINIT) {
+			ret = VE1_DecInit(ctx, vid_ctx->dev);
+			if (ret < 0) {
+				ve1_err(VE1_LOGTAG,
+					"[-] VE1_DecInit() fail.ret:%d\n", ret);
+				goto out;
+			}
+
+			memset(&open_param, 0,
+			       sizeof(struct ve1_decopen_param));
+			open_param.src_fmt_fourcc = pixelformat;
+			// FIXME, at this time, vpu_ctx->cap.fmt.pix.pixelformat hasn't been set (it will be set on vpu_g_fmt() or vpu_s_fmt_cap())
+			// and ve1 can't access the default value (cap_fmt[] in vpu.c), so set V4L2_PIX_FMT_NV12 directly
+			open_param.dst_fmt_fourcc = V4L2_PIX_FMT_NV12;
+			open_param.width = vpu_ctx->rect.width;
+			open_param.height = vpu_ctx->rect.height;
+			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+				"src_fmt_fourcc:%4s.dst_fmt_fourcc:%4s\n",
+				(char *)&open_param.src_fmt_fourcc,
+				(char *)&open_param.dst_fmt_fourcc);
+			ret = VE1_DecOpen(ctx, (void *)&open_param);
+			if (ret < 0) {
+				ve1_err(VE1_LOGTAG,
+					"[-] VE1_DecOpen() fail.ret:%d\n", ret);
+				goto out;
+			}
+		}
+
+		ctx->streamon_out = 1;
+		ctx->bNewBsDumpFile = 1; // #if defined(RTKVE1_DUMP_BS_EN) in ve1_wrapper.c
+	} else {
+		if (ctx->seqInited) {
+			ctx->capReqBufsCnt = vid_ctx->reqbuf_cap;
+			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+				"capReqBufsCnt:%d\n",
+				ctx->capReqBufsCnt);
+
+			queueRet =
+				queue_work(ctx->workqueue, &ctx->pic_run_work);
+			if (queueRet)
+				ctx->cntQueuePicRunWorkOk++;
+			else
+				ctx->cntQueuePicRunWorkFail++;
+			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+				"queue_work pic_run_work.cnt(%d,%d).ret:%d\n",
+				ctx->cntQueuePicRunWorkOk,
+				ctx->cntQueuePicRunWorkFail, queueRet);
+		} else if (ctx->ve1DecState < VE1_STATE_DEC_SEQ_INIT_DONE) {
+			ve1_info(VE1_LOGTAG,
+				 "streamon_cap but not seq init done\n");
+		}
+		ctx->streamon_cap = 1;
+		ctx->bNewYuvDumpFile = 1; // #if defined(RTKVE1_DUMP_YUV_EN) in ve1_wrapper.c
+		ctx->bNewChecksumFile = 1;
+		vpu_ctx->wait_disp_I = 1;
+	}
+	mutex_unlock(&ctx->ve1_mutex);
+	ve1_dbg(VPU_DBG_INPUT, VE1_LOGTAG, "[-] type:%s\n",
+		V4L2_TYPE_TO_STR(q->type));
+	return 0;
+out:
+	mutex_unlock(&ctx->ve1_mutex);
+	return ret;
+}
+
+static int ve1_stop_streaming(struct vb2_queue *q)
+{
+	struct ve1_ctx *ctx;
+	struct ve1_meta *meta;
+	struct ve1_displayable_frame *frame;
+	unsigned long flags;
+	//int i = 0;
+	//struct vb2_buffer *vb2 = NULL;
+	//dma_addr_t cap_buf_paddr;
+
+	if (q == NULL) {
+		ve1_err(VE1_LOGTAG, "q is NULL\n");
+		return -EINVAL;
+	}
+	ctx = vq_to_ve(q);
+	if (ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "ctx is NULL\n");
+		return -EINVAL;
+	}
+	ve1_dbg(VPU_DBG_INPUT, VE1_LOGTAG, "[+] ctx:0x%px.type:%s\n",
+		ctx, V4L2_TYPE_TO_STR(q->type));
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		rtkve1_flush_bitstream((void *)ctx);
+
+		mutex_lock(&ctx->ve1_mutex);
+		spin_lock_irqsave(&ctx->buffer_meta_lock, flags);
+		while (!list_empty(&ctx->buffer_meta_list)) {
+			meta = list_first_entry(&ctx->buffer_meta_list,
+						struct ve1_meta, list);
+			list_del(&meta->list);
+			kfree(meta);
+		}
+		ctx->num_metas = 0;
+		spin_unlock_irqrestore(&ctx->buffer_meta_lock, flags);
+
+		ctx->cntOutQbuf = 0;
+		ctx->streamon_out = 0;
+		ctx->outbuf_sequence = 0;
+		mutex_unlock(&ctx->ve1_mutex);
+	} else {
+		rtkve1_flush((void *)ctx);
+/*
+		for (i=0;i<q->num_buffers;i++) {
+			vb2 = q->bufs[i];
+			cap_buf_paddr = vb2_dma_contig_plane_dma_addr(vb2, 0);
+			ve1_dbg(VPU_DBG_OUTPUT, VE1_LOGTAG,
+				"cap_vb2[%d].index:%d.state:%d.paddr:0x%llx.vb2_v4l2_buf:0x%px\n",i,
+				vb2->index,
+				vb2->state,
+				cap_buf_paddr,
+				to_vb2_v4l2_buffer(vb2));
+		}
+*/
+		// remove all displayable frame info in ctx->displayable_frame_list
+		spin_lock_irqsave(&ctx->displayable_frame_lock, flags);
+		while (!list_empty(&ctx->displayable_frame_list)) {
+			frame = list_first_entry(&ctx->displayable_frame_list,
+						 struct ve1_displayable_frame,
+						 list);
+			list_del(&frame->list);
+			kfree(frame);
+		}
+		spin_unlock_irqrestore(&ctx->displayable_frame_lock, flags);
+		rtkve1_flush_dpbs((void *)ctx);
+
+		mutex_lock(&ctx->ve1_mutex);
+		ctx->cntAddToList = 0;
+		ctx->cntFrameDq = 0;
+		ctx->last_frame = 0;
+		ctx->streamon_cap = 0;
+		ctx->capbuf_sequence = 0;
+		ctx->lastFrmReportedAfFrmDqSeqNo = 0;
+		ctx->lastDqCapBuf = NULL;
+		mutex_unlock(&ctx->ve1_mutex);
+		mutex_lock(&ctx->ve1_dma_mutex);
+		ctx->lastDoneCapBuf = NULL;
+		mutex_unlock(&ctx->ve1_dma_mutex);
+	}
+
+	ve1_dbg(VPU_DBG_INPUT, VE1_LOGTAG,
+		"[-] type:%s.streamon_out(%d,%d).streamEnd:%d.seqInited:%d\n",
+		V4L2_TYPE_TO_STR(q->type), ctx->streamon_out, ctx->streamon_cap,
+		ctx->streamEnd,ctx->seqInited);
+	return 0;
+}
+
+// ve1_start_work() will be called only by ve1_out_qbuf() or ve1_cap_qbuf()
+static void ve1_start_work(void *fh, struct ve1_ctx *ctx)
+{
+	bool queueRet = false;
+	struct v4l2_rect rect;
+	struct vpu_ctx *vpu_ctx;
+
+	if (!ctx->seqInited && ctx->ops->seq_init_work) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "queue_work seq_init_work\n");
+		queue_work(ctx->workqueue, &ctx->seq_init_work);
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "flush_work seq_init_work\n");
+		flush_work(&ctx->seq_init_work);
+		if (ctx->seqInited) {
+			struct ve1_parsed_initial_info info;
+			struct vpu_fmt vpu_fmt;
+
+			mutex_lock(&ctx->ve1_mutex);
+			VE1_GetParsedInfo(ctx, &info);
+			mutex_unlock(&ctx->ve1_mutex);
+			ve1_info(VE1_LOGTAG,
+				"after seqInited.currSequenceNo:%d.get pic:%dx%d.display_rect(%d,%d,%d,%d).minDpbCount:%u.interlace:%u\n",
+				ctx->currSequenceNo, info.pic_width,
+				info.pic_height, info.visible_rect_left,
+				info.visible_rect_top, info.visible_rect_w,
+				info.visible_rect_h, info.minDpbCount,
+				info.interlace);
+			vpu_get_cap_fmt(fh, (void *)&vpu_fmt);
+			if ((vpu_fmt.spec.fmt.pix_mp.field == V4L2_FIELD_NONE) && info.interlace) {
+				vpu_fmt.spec.fmt.pix_mp.field = V4L2_FIELD_INTERLACED;
+			}
+			vpu_fmt.spec.fmt.pix_mp.width = info.pic_width;
+			vpu_fmt.spec.fmt.pix_mp.height = info.pic_height;
+			vpu_fmt.spec.fmt.pix_mp.plane_fmt[0].bytesperline = info.pic_width;
+			vpu_fmt.misc.bufcnt = info.minDpbCount;
+			vpu_update_cap_fmt(fh, (void *)&vpu_fmt);
+			vpu_ctx = fh_to_vpu(fh);
+			if (vpu_ctx->out_fmt.spec.fmt.pix_mp.pixelformat == V4L2_PIX_FMT_H264 &&
+				(info.visible_rect_w != 0) &&
+				(info.visible_rect_h != 0)) {
+				rect.top = info.visible_rect_top;
+				rect.left = info.visible_rect_left;
+				rect.width = info.visible_rect_w;
+				rect.height = info.visible_rect_h;
+				vpu_update_rect(fh, &rect);
+			}
+
+			if (vpu_check_sub_res_chg(fh)) {
+				ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+					"vpu_notify_event_resolution_change.currSequenceNo:%d\n",
+					ctx->currSequenceNo);
+				vpu_notify_event_resolution_change(fh);
+			}
+		}
+	}
+	// !ctx->seqChangeDone means seq_init_work() executed (ctx->seqChangeDone is set to 0 in ve1_dec_seq_init_work())
+	if (ctx->seqInited && !ctx->startDecode && !ctx->seqChangeDone) {
+		mutex_lock(&ctx->ve1_mutex);
+		ctx->startDecode = 1;
+		queueRet = queue_work(ctx->workqueue, &ctx->pic_run_work);
+		if (queueRet)
+			ctx->cntQueuePicRunWorkOk++;
+		else
+			ctx->cntQueuePicRunWorkFail++;
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"queue_work pic_run_work.cnt(%d,%d).ret:%d\n",
+			ctx->cntQueuePicRunWorkOk, ctx->cntQueuePicRunWorkFail,
+			queueRet);
+		mutex_unlock(&ctx->ve1_mutex);
+	}
+	else if (ctx->seqInited && ctx->startDecode && ctx->bPostponeUpBs && !ctx->bSuspend)
+	{
+		queueRet = queue_work(ctx->workqueue, &ctx->pic_run_work);
+		if (queueRet)
+			ctx->cntQueuePicRunWorkOk++;
+		else
+			ctx->cntQueuePicRunWorkFail++;
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"queue_work pic_run_work.cnt(%d,%d).ret:%d\n",
+			ctx->cntQueuePicRunWorkOk, ctx->cntQueuePicRunWorkFail,
+			queueRet);
+		flush_work(&ctx->pic_run_work);
+	}
+}
+
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+#define PLOCK_VERSION (0x72746B3D) //'rtk13'
+static void ve1_fill_display_frame_info(struct ve1_displayable_frame *frame,
+                                        void *captureBuf,
+                                        unsigned int secure_flag)
+{
+        struct ve_frame_info *info = (struct ve_frame_info *)captureBuf;
+        unsigned long long pts[2];
+
+        info->yuvs.lumaOffTblAddr = 0xffffffff;
+        info->yuvs.chromaOffTblAddr = 0xffffffff;
+        info->yuvs.lumaOffTblAddrR = 0xffffffff;
+        info->yuvs.chromaOffTblAddrR = 0xffffffff;
+        info->yuvs.bufBitDepth = 8;
+        info->yuvs.matrix_coefficients = 1;
+        info->yuvs.tch_hdr_metadata[0] = -1;
+
+        info->yuvs.Y_addr_Right = 0xffffffff;
+        info->yuvs.U_addr_Right = 0xffffffff;
+        info->yuvs.pLock_Right = 0xffffffff;
+
+        info->rtk_meta_buf_id = 0x52544B6D; //RTKm
+        info->is_ve1_buf = 1;
+
+        info->yuvs.Y_addr = frame->Y_addr;
+        info->yuvs.U_addr = frame->U_addr;
+        info->yuvs.Y_pitch = frame->bufStride;
+        info->yuvs.C_pitch = frame->bufStride;
+        info->yuvs.slice_height = frame->bufHeight;
+        info->yuvs.width = frame->rectRight - frame->rectLeft;
+        ;
+        info->yuvs.height = frame->rectBottom - frame->rectTop;
+        info->yuvs.mode = frame->mode;
+
+        if (frame->mode == INTERLEAVED_BOT_TOP_FIELD ||
+            frame->mode == INTERLEAVED_TOP_BOT_FIELD) {
+                // interlace
+                pts[1] = div_u64((frame->timestamp * 9), 100);
+                if (pts[1] > (frame->timeTick >> 1)) {
+                        pts[0] = pts[1] - (frame->timeTick >> 1);
+                } else {
+                        pts[0] = 0;
+                }
+        } else {
+                // progressive
+                pts[0] = div_u64((frame->timestamp * 9), 100);
+                pts[1] = 0;
+        }
+
+        info->yuvs.PTSH2 = (unsigned int)(pts[1] >> 32);
+        info->yuvs.RPTSH2 = (unsigned int)(pts[1] >> 32);
+        info->yuvs.PTSL2 = (unsigned int)(pts[1] & 0xffffffffLL);
+        info->yuvs.RPTSL2 = (unsigned int)(pts[1] & 0xffffffffLL);
+        info->yuvs.PTSH = (unsigned int)(pts[0] >> 32);
+        info->yuvs.PTSL = (unsigned int)(pts[0] & 0xffffffffLL);
+        info->yuvs.RPTSH = (unsigned int)(pts[0] >> 32);
+        info->yuvs.RPTSL = (unsigned int)(pts[0] & 0xffffffffLL);
+
+        info->yuvs.video_full_range_flag = frame->video_full_range_flag;
+        info->yuvs.matrix_coefficients =
+                ((frame->matrix_coefficients > 0) ? frame->matrix_coefficients :
+                                                    1);
+        if (frame->transfer_characteristics == 18) {
+                info->yuvs.transferCharacteristics = 6;
+        } else if (frame->transfer_characteristics == 14 ||
+                   frame->transfer_characteristics == 15) {
+                info->yuvs.transferCharacteristics = 1;
+        } else if (frame->transfer_characteristics == 16) {
+                info->yuvs.transferCharacteristics = 2;
+        } else {
+                info->yuvs.transferCharacteristics = 0;
+        }
+
+        if ((info->yuvs.transferCharacteristics == 1) ||
+            (info->yuvs.transferCharacteristics == 2)) {
+                /*HDR 10*/
+                info->hdr_type = 2;
+        } else if (info->yuvs.transferCharacteristics == 6) {
+                /*HLG*/
+                info->hdr_type = 3;
+        } else {
+                info->hdr_type = 0;
+        }
+
+        info->yuvs.secure_flag = secure_flag;
+
+        ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+                "tgid(%d,%d,%s).idx:%d.Y_addr:0x%x.U_addr:0x%x.bufW:%d.bufH:%d.w:%d.h:%d.pts(%lld,%lld).hdr(%d,%d,%d)\n",
+                current->tgid, current->pid, current->comm,
+                frame->frameBufIndex, info->yuvs.Y_addr, info->yuvs.U_addr,
+                info->yuvs.Y_pitch, info->yuvs.slice_height, info->yuvs.width,
+                info->yuvs.height, pts[0], pts[1],
+                info->yuvs.video_full_range_flag,
+                info->yuvs.transferCharacteristics,
+                info->yuvs.matrix_coefficients);
+}
+#endif
+
+static int ve1_out_qbuf(void *fh, uint8_t *buf, uint32_t len, uint64_t timestamp,
+			uint32_t sequence)
+{
+	int ret = 0;
+	struct ve1_ctx *ctx;
+	DecInitialInfo *initialInfo;
+
+	if ((fh == NULL) || (buf == NULL)) {
+		ve1_err(VE1_LOGTAG, "fh or buf == NULL\n");
+		return -EINVAL;
+	}
+	ctx = fh_to_ve(fh);
+	if (ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "ctx is NULL\n");
+		return -EINVAL;
+	}
+
+	if (ctx->error) {
+		ve1_err(VE1_LOGTAG,
+			"Something wrong, skip output qbuf\n");
+		return -EIO;
+	}
+	if (ctx->aborting || ctx->fatal_err) {
+		return -EINVAL;
+	}
+
+	ve1_dbg(VPU_DBG_INPUT, VE1_LOGTAG,
+		"[+] fh:0x%px.ctx:0x%px.buf:0x%px.len:%d.timestamp:%lld.seq:%d.cnt:%d\n",
+		fh, ctx, buf, len, timestamp, sequence, ctx->cntOutQbuf);
+
+	if (ctx->initialInfo != NULL) {
+		initialInfo = (DecInitialInfo *)ctx->initialInfo;
+		if (initialInfo->seqInitErrReason == 0x40000) {
+			ve1_err(VE1_LOGTAG, "Not support extended profile\n");
+			return -EINVAL;
+		}
+		if (initialInfo->seqInitErrReason == 0x20000) {
+			ve1_err(VE1_LOGTAG, "the image size exceeds the supported limits\n");
+			return -EINVAL;
+		}
+		if (((DecOpenParam *)ctx->decOP)->bitstreamFormat == STD_MPEG4) {
+			if ((initialInfo->mp4ShortVideoHeader == 0) &&
+				((initialInfo->seqInitErrReason >> 10) & 0x1)) {
+				// VE1 doesn't support MPEG4 GMC
+				ve1_err(VE1_LOGTAG, "Not support MPEG4 GMC\n");
+				return -EINVAL;
+			}
+		}
+	}
+
+	if (ctx->streamon_out == 1) {
+		mutex_lock(&ctx->ve1_mutex);
+		ret = ve1_fill_bitstream(ctx, buf, len, timestamp, sequence);
+		if (ret == -EFAULT) {
+			// real error
+			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+				"[-] ve1_fill_bitstream() fail.ret:%d\n", ret);
+			mutex_unlock(&ctx->ve1_mutex);
+			return ret;
+		}
+		else if (ret == 0) {
+			ctx->cntOutQbuf++;
+		}
+		mutex_unlock(&ctx->ve1_mutex);
+
+		ve1_start_work(fh, ctx);
+	}
+
+	// ret will be 0 or -ENOSPC, -ENOSPC means bitstream buffer doesn't have enough space to put new data
+	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-] ret:%d\n", ret);
+	return ret;
+}
+
+static int ve1_cap_qbuf(void *fh, struct vb2_buffer *vb)
+{
+	struct ve1_ctx *ctx;
+	struct vpu_ctx *vpu_ctx;
+	unsigned long flags;
+	struct ve1_displayable_frame *frame, *tmp;
+	bool bSetFbReuse = false;
+	PhysicalAddress dpb_paddr = 0;
+	unsigned int regIndex;
+	unsigned int sequenceNo;
+	bool queueRet = false;
+	unsigned long cap_buf_size = 0;
+	dma_addr_t cap_buf_paddr;
+	struct vb2_v4l2_buffer *vb2_v4l2_buf = NULL;
+	struct vb2_v4l2_buffer *rm_vb2_v4l2_buf = NULL;
+	int ret = 0;
+
+	if (vb == NULL) {
+		ve1_err(VE1_LOGTAG, "vb is NULL\n");
+		return -EINVAL;
+	}
+	ctx = vq_to_ve(vb->vb2_queue);
+	if (ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "ctx is NULL\n");
+		return -EINVAL;
+	}
+	vpu_ctx = fh_to_vpu(fh);
+	if (vpu_ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "vpu_ctx is NULL\n");
+		return -EINVAL;
+	}
+
+	vb2_v4l2_buf = to_vb2_v4l2_buffer(vb);
+	ve1_dbg(VPU_DBG_OUTPUT, VE1_LOGTAG,
+		"[+] ctx:0x%px.flag(%d,%d,%d,%d).vb2_v4l2_buf:0x%px\n", ctx,
+		ctx->dpbFull, ctx->streamEnd, ctx->seqInited, ctx->startDecode,
+		vb2_v4l2_buf);
+
+	if (ctx->streamon_cap == 1) {
+		// ctx->streamEnd means EOS already happened, ve1_out_qbuf() won't be called anymore, we need to queue_work(seq_init_work or pic_run_work) by ve1_cap_qbuf()
+		// CXI-3465, test_00.ts, from log, all video data have feed already before sequence change, after sequence changed, ve1_out_qbuf() won't be called anymore,
+		// we need to queue_work(seq_init_work or pic_run_work) by ve1_cap_qbuf()
+		if (ctx->streamEnd || !ctx->seqInited || !ctx->startDecode) {
+			ve1_start_work(fh, ctx);
+		}
+	}
+
+	if (HAS_REG_DPBS(ctx)) {
+		// print displayable_frame_list for debug
+		ve1_show_displayable_frame_list(ctx);
+
+		// check if there is a corresponding frame buffer need to be recycled
+		spin_lock_irqsave(&ctx->displayable_frame_lock, flags);
+		if (!list_empty(&ctx->displayable_frame_list)) {
+			list_for_each_entry_safe (frame, tmp,
+						  &ctx->displayable_frame_list,
+						  list) {
+				if (frame->vb2_v4l2_buf == vb2_v4l2_buf) {
+					if (frame->isDequeued == 0) {
+						ve1_err(VE1_LOGTAG,
+							"Unexpected fatal error.queue a never-dequeued cap_buf\n");
+					}
+					ve1_dbg(VPU_DBG_OUTPUT, VE1_LOGTAG,
+						"vb2_v4l2_buf:0x%px re-qbuf.VE1_UpdateDPBStatus(0x%x,%d,%d)\n",
+						frame->vb2_v4l2_buf,
+						frame->dpb_paddr,
+						frame->sequenceNo,
+						frame->regIndex);
+					dpb_paddr = frame->dpb_paddr;
+					regIndex = frame->regIndex;
+					sequenceNo = frame->sequenceNo;
+					bSetFbReuse = true;
+					list_del(&frame->list);
+					kfree(frame);
+					break;
+				}
+			}
+		}
+		spin_unlock_irqrestore(&ctx->displayable_frame_lock, flags);
+		if (bSetFbReuse) {
+			rm_vb2_v4l2_buf = v4l2_m2m_dst_buf_remove(
+				((struct v4l2_fh *)fh)->m2m_ctx);
+			if (rm_vb2_v4l2_buf != vb2_v4l2_buf) {
+				ve1_err(VE1_LOGTAG,
+					"the vb2_v4l2_buf:0x%px from v4l2_m2m_dst_buf_remove() not equals to cap_qbuf:0x%px\n",
+					rm_vb2_v4l2_buf, vb2_v4l2_buf);
+			}
+			VE1_UpdateDPBStatus((void *)ctx, dpb_paddr, sequenceNo,
+								RTKVE1_DPB_ST_VALID);
+		} else {
+			cap_buf_size = vb2_plane_size(vb, 0);
+			if (cap_buf_size == 0) {
+				ve1_err(VE1_LOGTAG, "cap_buf_size is 0\n");
+				rm_vb2_v4l2_buf = v4l2_m2m_dst_buf_remove(
+									((struct v4l2_fh *)fh)->m2m_ctx);
+				if (rm_vb2_v4l2_buf != vb2_v4l2_buf) {
+					ve1_err(VE1_LOGTAG,
+						"the vb2_v4l2_buf:0x%px from v4l2_m2m_dst_buf_remove() not equals to cap_qbuf:0x%px\n",
+						rm_vb2_v4l2_buf, vb2_v4l2_buf);
+				}
+				ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+					"v4l2_m2m_buf_done.vb2_v4l2_buf:0x%px\n",
+					vb2_v4l2_buf);
+				v4l2_m2m_buf_done(
+					vb2_v4l2_buf,
+					VB2_BUF_STATE_ERROR);
+				return -EINVAL;
+			}
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+			cap_buf_paddr = vb2_dma_contig_plane_dma_addr(vb, 0) + METADATA_OFFSET;
+#else
+			cap_buf_paddr = vb2_dma_contig_plane_dma_addr(vb, 0);
+#endif
+			//ve1_dbg(VPU_DBG_OUTPUT, VE1_LOGTAG,
+			//	"cap_buf_paddr:0x%lx.cap_buf_size:%ld.vb2_v4l2_buf:0x%px\n",
+			//	(unsigned long)cap_buf_paddr, cap_buf_size,
+			//	vb2_v4l2_buf);
+
+			ret = VE1_UpdateDPBStatus((void *)ctx, cap_buf_paddr, ctx->currSequenceNo,
+										RTKVE1_DPB_ST_VALID);
+			if (ret < 0) {
+				if ((ctx->capReqBufsCnt != 0) && (ctx->cntCap2Dpb == ctx->capReqBufsCnt)) {
+					ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "unexpected cap_qbuf which not in dpb[].cntCap2Dpb:%d\n",
+						ctx->cntCap2Dpb);
+					rm_vb2_v4l2_buf = v4l2_m2m_dst_buf_remove(
+										((struct v4l2_fh *)fh)->m2m_ctx);
+					if (rm_vb2_v4l2_buf != vb2_v4l2_buf) {
+						ve1_err(VE1_LOGTAG,
+							"the vb2_v4l2_buf:0x%px from v4l2_m2m_dst_buf_remove() not equals to cap_qbuf:0x%px\n",
+							rm_vb2_v4l2_buf, vb2_v4l2_buf);
+					}
+					ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+						"v4l2_m2m_buf_done.vb2_v4l2_buf:0x%px\n",
+						vb2_v4l2_buf);
+					v4l2_m2m_buf_done(
+						vb2_v4l2_buf,
+						VB2_BUF_STATE_ERROR);
+					return -EINVAL;
+				}
+				else {
+					rtkve1_add_capbuf_to_dpb((void *)ctx, cap_buf_size,
+											(unsigned long)cap_buf_paddr,
+											vb2_v4l2_buf);
+				}
+			}
+
+			rm_vb2_v4l2_buf = v4l2_m2m_dst_buf_remove(
+								((struct v4l2_fh *)fh)->m2m_ctx);
+			if (rm_vb2_v4l2_buf != vb2_v4l2_buf) {
+				ve1_err(VE1_LOGTAG,
+					"the vb2_v4l2_buf:0x%px from v4l2_m2m_dst_buf_remove() not equals to cap_qbuf:0x%px\n",
+					rm_vb2_v4l2_buf, vb2_v4l2_buf);
+			}
+		}
+
+		// CXI-3663, queue_work pic_run_work after frame buffer is recycled
+		if (ctx->dpbFull) {
+			queueRet =
+				queue_work(ctx->workqueue, &ctx->pic_run_work);
+			if (queueRet)
+				ctx->cntQueuePicRunWorkOk++;
+			else
+				ctx->cntQueuePicRunWorkFail++;
+			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+				"queue_work pic_run_work.cnt(%d,%d).ret:%d\n",
+				ctx->cntQueuePicRunWorkOk,
+				ctx->cntQueuePicRunWorkFail, queueRet);
+		}
+	} else {
+		cap_buf_size = vb2_plane_size(vb, 0);
+		if (cap_buf_size == 0) {
+			ve1_err(VE1_LOGTAG, "cap_buf_size is 0\n");
+			return -EINVAL;
+		}
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+		cap_buf_paddr = vb2_dma_contig_plane_dma_addr(vb, 0) + METADATA_OFFSET;
+#else
+		cap_buf_paddr = vb2_dma_contig_plane_dma_addr(vb, 0);
+#endif
+		//ve1_dbg(VPU_DBG_OUTPUT, VE1_LOGTAG,
+		//	"cap_buf_paddr:0x%lx.cap_buf_size:%ld.vb2_v4l2_buf:0x%px\n",
+		//	(unsigned long)cap_buf_paddr, cap_buf_size,
+		//	vb2_v4l2_buf);
+		rtkve1_add_capbuf_to_dpb((void *)ctx, cap_buf_size,
+								(unsigned long)cap_buf_paddr,
+								vb2_v4l2_buf);
+		rm_vb2_v4l2_buf = v4l2_m2m_dst_buf_remove(
+			((struct v4l2_fh *)fh)->m2m_ctx);
+		if (rm_vb2_v4l2_buf != vb2_v4l2_buf) {
+			ve1_err(VE1_LOGTAG,
+				"the vb2_v4l2_buf:0x%px from v4l2_m2m_dst_buf_remove() not equals to cap_qbuf:0x%px\n",
+				rm_vb2_v4l2_buf, vb2_v4l2_buf);
+		}
+	}
+
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-]\n");
+	return 0;
+}
+
+static int ve1_cap_dqbuf(void *fh, uint8_t *buf, uint64_t *timestamp,
+			 struct vb2_v4l2_buffer **disp_buf)
+{
+	struct ve1_ctx *ctx;
+	struct vpu_ctx *vpu_ctx;
+	unsigned long flags;
+	struct ve1_displayable_frame *frame;
+	bool bFillFrameInfo = false;
+	PhysicalAddress dpb_paddr = 0;
+	unsigned int regIndex;
+	unsigned int sequenceNo;
+	int ret = -EINVAL;
+	//unsigned int unDqFrmCount = 0;
+	//int lastFrmFlag = 0;
+	struct rtkve1_dpb_t *dpb_undq = NULL;
+
+	if ((fh == NULL) || (timestamp == NULL) || (disp_buf == NULL)) {
+		ve1_err(VE1_LOGTAG, "invalid parameters\n");
+		return ret;
+	}
+	ctx = fh_to_ve(fh);
+	if (ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "ctx is NULL\n");
+		return ret;
+	}
+	vpu_ctx = fh_to_vpu(fh);
+	if (vpu_ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "vpu_ctx is NULL\n");
+		return -EINVAL;
+	}
+
+	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[+]\n");
+
+	if (ctx->streamon_cap == 1) {
+		// print displayable_frame_list for debug
+		//ve1_show_displayable_frame_list(ctx);
+/*
+		if ((ctx->handle_eos_by >= VE1_HANDLE_EOS_SET_END) && (ctx->last_frame == 0)) {
+			spin_lock_irqsave(&ctx->displayable_frame_lock, flags);
+			if (!list_empty(&ctx->displayable_frame_list)) {
+				list_for_each_entry (
+					frame, &ctx->displayable_frame_list, list) {
+					if ((frame->vb2_v4l2_buf != NULL) &&
+						(frame->isDequeued == 0)) {
+						unDqFrmCount++;
+					}
+					if ((frame->vb2_v4l2_buf != NULL) &&
+						(frame->last_frame == 1)) {
+						lastFrmFlag = 1;
+					}
+				}
+			}
+			spin_unlock_irqrestore(&ctx->displayable_frame_lock, flags);
+			//ve1_dbg(VPU_DBG_OUTPUT, VE1_LOGTAG,
+			//		"unDqFrmCount:%d.lastFrmFlag:%d\n",unDqFrmCount,lastFrmFlag);
+			if ((unDqFrmCount == 1) && (lastFrmFlag == 0)) {
+				ve1_dbg(VPU_DBG_OUTPUT, VE1_LOGTAG,
+					"streamEnd + unDqFrmCount==1 + !lastFrmFlag, wait ve1 report last frame\n");
+				return -EINVAL;
+			}
+		}
+*/
+		spin_lock_irqsave(&ctx->displayable_frame_lock, flags);
+		if (!list_empty(&ctx->displayable_frame_list)) {
+			list_for_each_entry (
+				frame, &ctx->displayable_frame_list, list) {
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+				void *captureBuf = NULL;
+#endif
+				if ((frame->vb2_v4l2_buf != NULL) &&
+				    (frame->isDequeued == 0)) {
+					*timestamp = frame->timestamp;
+
+					if (frame->last_frame) {
+						ve1_info(
+							VE1_LOGTAG,
+							"ctx->last_frame = 1\n");
+						ctx->last_frame = 1;
+					}
+					ctx->cntFrameDq++;
+					ve1_dbg(VPU_DBG_OUTPUT, VE1_LOGTAG,
+						"dq vb2_v4l2_buf:0x%px.regIndex:%d.dpb_paddr:0x%x.isDequeued:%d.timestamp:%lld.POC:%d.type:%d.last_frame:%d.cnt:%d\n",
+						frame->vb2_v4l2_buf,
+						frame->regIndex,
+						frame->dpb_paddr,
+						frame->isDequeued,
+						frame->timestamp,
+						frame->POC,
+						frame->picType,
+						ctx->last_frame,
+						ctx->cntFrameDq);
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+					captureBuf = vb2_plane_vaddr(&frame->vb2_v4l2_buf->vb2_buf, 0);
+					if (captureBuf)
+						ve1_fill_display_frame_info(
+							frame, captureBuf, ctx->is_svp);
+					else
+						ve1_err(VE1_LOGTAG, "captureBuf is NULL\n");
+#endif
+					frame->isDequeued = 1;
+					*disp_buf = frame->vb2_v4l2_buf;
+					dpb_paddr = frame->dpb_paddr;
+					regIndex = frame->regIndex;
+					sequenceNo = frame->sequenceNo;
+					bFillFrameInfo = true;
+					if ((frame->POC != 0) && (frame->POC < ctx->lastDispPOC)) {
+						ve1_dbg(VPU_DBG_OUTPUT, VE1_LOGTAG,
+							"incorrect POC.curr:%d.last:%d\n",frame->POC,ctx->lastDispPOC);
+					}
+					ctx->lastDispPOC = frame->POC;
+					ctx->lastDqCapBuf = frame->vb2_v4l2_buf;
+					break;
+				}
+			}
+		}
+
+		spin_unlock_irqrestore(&ctx->displayable_frame_lock, flags);
+		if (bFillFrameInfo) {
+			if ((frame->picType == PIC_TYPE_IDR) || (frame->picType == PIC_TYPE_I)) {
+				vpu_ctx->wait_disp_I = 0;
+				ve1_dbg(VPU_DBG_OUTPUT, VE1_LOGTAG,
+					"dequeue I frame.set wait_disp_I:%d\n",
+					vpu_ctx->wait_disp_I);
+			}
+#ifdef VPU_GET_CC
+			// CXI-3837, VE1 send a displayable frame info to CAPTURE buffer, call ProcessCC_Display() here
+			ProcessCC_Display((void *)ctx, frame->timestamp,
+					  regIndex);
+#endif
+			VE1_UpdateDPBStatus((void *)ctx, dpb_paddr, sequenceNo,
+								RTKVE1_DPB_ST_DQ);
+			ret = 0;
+		}
+		else if (ctx->lastFrmReportedAfFrmDqSeqNo) {
+			mutex_lock(&ctx->ve1_dma_mutex);
+			if (!ctx->lastDoneCapBuf) {
+				dpb_undq = (struct rtkve1_dpb_t *)rtkve1_find_dpb_undequeue((void *)ctx, ctx->lastFrmReportedAfFrmDqSeqNo);
+				if (dpb_undq) {
+					*disp_buf = (struct vb2_v4l2_buffer *)(dpb_undq->vb2_v4l2_buf);
+					ctx->lastDoneCapBuf = *disp_buf;
+					ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+						"lastFrmReportedAfFrmDqSeqNo.let flow to vpu_buf_done() in threadcap().undq_v4l2_buf:0x%px.lastDqCapBuf:0x%px\n",
+						*disp_buf, ctx->lastDqCapBuf);
+					// return 0 to let flow to ve_get_info(get no_frame==1) => vpu_buf_done() in threadcap() (vpu.c)
+					ret = 0;
+				}
+			}
+			mutex_unlock(&ctx->ve1_dma_mutex);
+		}
+	}
+
+	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-] ret:%d\n", ret);
+	return ret;
+}
+
+static int ve1_abort(void *pCtx, int type)
+{
+	struct ve1_ctx *ctx;
+	if (!pCtx) {
+		ve1_err(VE1_LOGTAG, "pCtx is NULL\n");
+		return -EINVAL;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[+] ctx:0x%px.type:%s\n", ctx,
+		V4L2_TYPE_TO_STR(type));
+
+	mutex_lock(&ctx->ve1_mutex);
+	ctx->aborting = 1;
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+		"VE1_DecCheckComplete\n");
+	VE1_DecCheckComplete(ctx);
+	mutex_unlock(&ctx->ve1_mutex);
+
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-] ctx:0x%px.type:%s\n", ctx,
+		V4L2_TYPE_TO_STR(type));
+	return 0;
+}
+
+static void *ve1_alloc_context(void *fh)
+{
+	struct ve1_ctx *ctx = NULL;
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		ve1_err(VE1_LOGTAG, "Failed to allocate video engine\n");
+		return ctx;
+	}
+	ctx->filp = vid_ctx->file;
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "ctx:0x%px.filp:0x%px\n", ctx,
+		ctx->filp);
+
+	return ctx;
+}
+
+static void ve1_free_context(void *pCtx)
+{
+	struct ve1_ctx *ctx;
+	int i = 0;
+	struct vb2_v4l2_buffer *vb2_v4l2_buf = NULL;
+
+	if (!pCtx) {
+		ve1_err(VE1_LOGTAG, "pCtx is NULL\n");
+		return;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->ops && ctx->ops->seq_end_work) {
+		// queue seq_end_work on workqueue
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "queue_work seq_end_work.ctx:0x%px\n",
+			ctx);
+		queue_work(ctx->workqueue, &ctx->seq_end_work);
+		// Wait until seq_end_work has finished execution
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "flush_work seq_end_work\n");
+		flush_work(&ctx->seq_end_work);
+	}
+
+	mutex_lock(&ctx->ve1_dma_mutex);
+	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
+		if (IS_RTKVE1_DPB_VALID(ctx->dpb[i].status)) {
+			vb2_v4l2_buf = (struct vb2_v4l2_buffer *)(ctx->dpb[i].vb2_v4l2_buf);
+			if (vb2_v4l2_buf->vb2_buf.state == VB2_BUF_STATE_ACTIVE) {
+				ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+					"v4l2_m2m_buf_done.status:0x%x.regIndex:%d.vb2_v4l2_buf:0x%px.phys_addr:0x%lx.seqNo:%u\n",
+					ctx->dpb[i].status,
+					ctx->dpb[i].regIndex,
+					ctx->dpb[i].vb2_v4l2_buf,
+					ctx->dpb[i].phys_addr,
+					ctx->dpb[i].seqNo);
+				v4l2_m2m_buf_done(
+					(struct vb2_v4l2_buffer *)(ctx->dpb[i].vb2_v4l2_buf),
+					VB2_BUF_STATE_ERROR);
+			}
+		}
+	}
+	mutex_unlock(&ctx->ve1_dma_mutex);
+
+	if (ctx->workqueue) {
+		// destroy workqueue
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"destroy_workqueue workqueue:0x%px\n", ctx->workqueue);
+		destroy_workqueue(ctx->workqueue);
+		ctx->workqueue = NULL;
+	}
+
+	if (ctx->ops && ctx->ops->release) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "ops->release\n");
+		ctx->ops->release(ctx);
+	}
+
+	if (ctx->ops)
+		mutex_lock(&ctx->ve1_mutex);
+
+	if (ctx->decOP) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree decOP\n");
+		kfree(ctx->decOP);
+		ctx->decOP = NULL;
+	}
+	if (ctx->initialInfo) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree initialInfo\n");
+		kfree(ctx->initialInfo);
+		ctx->initialInfo = NULL;
+	}
+	if (ctx->fbAllocInfo) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree fbAllocInfo\n");
+		kfree(ctx->fbAllocInfo);
+		ctx->fbAllocInfo = NULL;
+	}
+	if (ctx->fbUser) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree fbUser\n");
+		kfree(ctx->fbUser);
+		ctx->fbUser = NULL;
+	}
+	if (ctx->decParam) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree decParam\n");
+		kfree(ctx->decParam);
+		ctx->decParam = NULL;
+	}
+	if (ctx->secAxiUse) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree secAxiUse\n");
+		kfree(ctx->secAxiUse);
+		ctx->secAxiUse = NULL;
+	}
+	if (ctx->decCacheConfig) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree decCacheConfig\n");
+		kfree(ctx->decCacheConfig);
+		ctx->decCacheConfig = NULL;
+	}
+	if (ctx->outputInfo) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree outputInfo\n");
+		kfree(ctx->outputInfo);
+		ctx->outputInfo = NULL;
+	}
+	if (ctx->seqHeader) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree seqHeader\n");
+		kfree(ctx->seqHeader);
+		ctx->seqHeader = NULL;
+	}
+	if (ctx->picHeader) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree picHeader\n");
+		kfree(ctx->picHeader);
+		ctx->picHeader = NULL;
+	}
+
+	if (ctx->ops)
+		mutex_unlock(&ctx->ve1_mutex);
+
+	kfree(ctx);
+}
+
+static void ve1_free_capture(void *pCtx)
+{
+	struct ve1_ctx *ctx;
+	if (!pCtx) {
+		ve1_err(VE1_LOGTAG, "pCtx is NULL\n");
+		return;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->streamon_cap) {
+		ve1_err(VE1_LOGTAG, "fatal.reqbufs 0 while cap streamon\n");
+		return;
+	}
+
+	ctx->cntCap2Dpb = 0;
+	//rtkve1_unreg_dpbs(pCtx);
+	ctx->free_cap = 1;
+}
+
+static int ve1_force_eos(void *fh, struct ve1_ctx *ctx)
+{
+	const struct v4l2_event eos_event = { .type = V4L2_EVENT_EOS };
+	struct v4l2_m2m_ctx *m2m_ctx = ((struct v4l2_fh *)fh)->m2m_ctx;
+	struct vb2_v4l2_buffer *buf = NULL;
+	int i = 0;
+
+
+	mutex_lock(&ctx->ve1_dma_mutex);
+	for (i = VE1_ION_STRUCT_NUM - 1; i >= 0; i--) {
+		struct vb2_v4l2_buffer *tmp = (struct vb2_v4l2_buffer *)ctx->dpb[i].vb2_v4l2_buf;
+		if (ctx->dpb[i].status == RTKVE1_DPB_ST_VALID &&
+				tmp->vb2_buf.state == VB2_BUF_STATE_ACTIVE) {
+			buf = ctx->dpb[i].vb2_v4l2_buf;
+			break;
+		}
+	}
+
+	if (i == -1) {
+		vpu_err("Can't find valid buffer for EOS\n");
+		mutex_unlock(&ctx->ve1_dma_mutex);
+		return -ENOBUFS;
+	}
+	mutex_unlock(&ctx->ve1_dma_mutex);
+
+	vb2_set_plane_payload(&buf->vb2_buf, 0, 0);
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+	buf->vb2_buf.planes[0].data_offset = 0;
+#endif
+	v4l2_m2m_last_buffer_done(m2m_ctx, buf);
+	v4l2_event_queue_fh(fh, &eos_event);
+
+	return 0;
+}
+
+static int ve1_stop_cmd(void *fh, int pixelformat)
+{
+	int ret = 0;
+	struct ve1_ctx *ctx = NULL;
+	struct vpu_ctx *vpu_ctx;
+	bool queueRet = false;
+
+	if (fh == NULL) {
+		ve1_err(VE1_LOGTAG, "invalid parameters\n");
+		return -1;
+	}
+	ctx = fh_to_ve(fh);
+	if (ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "ctx is NULL\n");
+		return -1;
+	}
+	vpu_ctx = fh_to_vpu(fh);
+	if (vpu_ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "vpu_ctx is NULL\n");
+		return -1;
+	}
+
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "ctx:0x%px\n",
+		ctx);
+
+	mutex_lock(&ctx->ve1_mutex);
+	if (ctx->int_reason & (1 << INT_BIT_DEC_FIELD)) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "eos with interrupt reason:0x%x\n",
+				ctx->int_reason);
+		ret = -1;
+		goto out;
+	}
+
+	if (!ctx->seqInited) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"eos but not seq init done\n");
+		ret = -1;
+		goto out;
+	}
+	if (ctx->streamon_out &&
+	    (ctx->handle_eos_by == VE1_HANDLE_EOS_BY_NONE)) {
+		ctx->handle_eos_by = VE1_HANDLE_EOS_BY_PREPARE_RUN;
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "set handle_eos_by:%d\n",
+			ctx->handle_eos_by);
+		if (ctx->bBufEmptyFlag) {
+			ctx->bBufEmptyFlag = false;
+			queueRet =
+				queue_work(ctx->workqueue, &ctx->pic_run_work);
+			if (queueRet)
+				ctx->cntQueuePicRunWorkOk++;
+			else
+				ctx->cntQueuePicRunWorkFail++;
+			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+				"queue_work pic_run_work.cnt(%d,%d).ret:%d\n",
+				ctx->cntQueuePicRunWorkOk,
+				ctx->cntQueuePicRunWorkFail, queueRet);
+		}
+
+		if (ctx->error)
+			ve1_force_eos(fh, ctx);
+	}
+
+out:
+	mutex_unlock(&ctx->ve1_mutex);
+	return ret;
+}
+
+static int ve1_start_cmd(void *fh)
+{
+	int ret = 0;
+	struct ve1_ctx *ctx = NULL;
+
+	if (fh == NULL) {
+		ve1_err(VE1_LOGTAG, "invalid parameters\n");
+		return -1;
+	}
+	ctx = fh_to_ve(fh);
+	if (ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "ctx is NULL\n");
+		return -1;
+	}
+
+	mutex_lock(&ctx->ve1_mutex);
+	ve1_info(VE1_LOGTAG, "%s.%d\n",
+				__func__, __LINE__);
+	ctx->handle_eos_by = VE1_HANDLE_EOS_BY_NONE;
+	ctx->last_frame = 0;
+
+	mutex_unlock(&ctx->ve1_mutex);
+	return ret;
+}
+
+static int ve1_suspend(void *fh)
+{
+	int ret = 0;
+	struct ve1_ctx *ctx = NULL;
+
+	ve1_info(VE1_LOGTAG, "%d.%s.enter\n",
+		__LINE__, __func__);
+	if (fh == NULL) {
+		ve1_err(VE1_LOGTAG, "invalid parameters\n");
+		return -1;
+	}
+	ctx = fh_to_ve(fh);
+	if (ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "ctx is NULL\n");
+		return -1;
+	}
+
+	mutex_lock(&ctx->ve1_mutex);
+	ctx->bSuspend = true;
+	mutex_unlock(&ctx->ve1_mutex);
+	ve1_info(VE1_LOGTAG, "%d.%s.leave\n",
+		__LINE__, __func__);
+	return ret;
+}
+
+static int ve1_resume(void *fh)
+{
+	int ret = 0;
+	struct ve1_ctx *ctx = NULL;
+
+	ve1_info(VE1_LOGTAG, "%d.%s.enter\n",
+		__LINE__, __func__);
+	if (fh == NULL) {
+		ve1_err(VE1_LOGTAG, "invalid parameters\n");
+		return -1;
+	}
+	ctx = fh_to_ve(fh);
+	if (ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "ctx is NULL\n");
+		return -1;
+	}
+
+	mutex_lock(&ctx->ve1_mutex);
+	ctx->bSuspend = false;
+	mutex_unlock(&ctx->ve1_mutex);
+	ve1_info(VE1_LOGTAG, "%d.%s.leave\n",
+		__LINE__, __func__);
+	return ret;
+}
+
+static int ve1_get_max_instance(void *fh)
+{
+	return MAX_NUM_INSTANCE;
+}
+
+static void ve1_get_info(void *fh, bool *eos, bool *no_frame)
+{
+	struct ve1_ctx *ctx;
+
+	if ((fh == NULL) || (eos == NULL)) {
+		ve1_err(VE1_LOGTAG, "invalid parameters\n");
+		return;
+	}
+	ctx = fh_to_ve(fh);
+	if (ctx == NULL) {
+		ve1_err(VE1_LOGTAG, "ctx is NULL\n");
+		return;
+	}
+
+	*eos = (bool)ctx->last_frame;
+	*no_frame = ctx->lastFrmReportedAfFrmDqSeqNo;
+}
+
+static int ve1_get_undq_dispFrm_cnt(void *fh)
+{
+	int cnt = 0;
+	struct ve1_ctx *ctx;
+	unsigned long flags;
+	struct ve1_displayable_frame *frame;
+
+	if (fh == NULL) {
+		ve1_err(VE1_LOGTAG, "invalid parameters\n");
+		goto out;
+	}
+	ctx = fh_to_ve(fh);
+	if (ctx == NULL) {
+		goto out;
+	}
+
+	spin_lock_irqsave(&ctx->displayable_frame_lock, flags);
+	if (!list_empty(&ctx->displayable_frame_list)) {
+		list_for_each_entry (frame, &ctx->displayable_frame_list,
+				     list) {
+			if (frame->isDequeued == 0) {
+				cnt++;
+			}
+		}
+	}
+	spin_unlock_irqrestore(&ctx->displayable_frame_lock, flags);
+
+out:
+	return cnt;
+}
+
+static struct veng_ops ve_ops = {
+	.ve_start_streaming = ve1_start_streaming,
+	.ve_stop_streaming = ve1_stop_streaming,
+	.ve_out_qbuf = ve1_out_qbuf,
+	.ve_cap_qbuf = ve1_cap_qbuf,
+	.ve_cap_dqbuf = ve1_cap_dqbuf,
+	.ve_abort = ve1_abort,
+	.ve_alloc_context = ve1_alloc_context,
+	.ve_free_context = ve1_free_context,
+	.ve_free_capture = ve1_free_capture,
+	.ve_stop_cmd = ve1_stop_cmd,
+	.ve_get_info = ve1_get_info,
+	.ve_get_undq_dispFrm_cnt = ve1_get_undq_dispFrm_cnt,
+	.ve_start_cmd = ve1_start_cmd,
+	.ve_suspend = ve1_suspend,
+	.ve_resume = ve1_resume,
+	.ve_get_max_instance = ve1_get_max_instance,
+};
+
+static int __init ve1_init(void)
+{
+	int ret;
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[+]\n");
+
+	ret = vpu_ve_register(VENG_ID, &ve_ops);
+	if (ret) {
+		ve1_err(VE1_LOGTAG, "[-] vpu_ve_register() fail\n");
+		return ret;
+	}
+
+	ret = ve1_mem_device_create();
+	if (ret) {
+		ve1_err(VE1_LOGTAG, "[-] ve1_mem_device_create() fail\n");
+		return ret;
+	}
+
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-]\n");
+	return 0;
+}
+
+static void __exit ve1_exit(void)
+{
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[+]\n");
+	ve1_mem_device_destroy();
+
+	vpu_ve_unregister(VENG_ID);
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-]\n");
+}
+
+module_init(ve1_init);
+module_exit(ve1_exit);
+
+MODULE_VERSION(CODEC_VERSION);
+MODULE_IMPORT_NS(DMA_BUF);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Scarly.Cheng <scarly.cheng@realtek.com>");
+MODULE_DESCRIPTION("V4L2 Realtek Video Engine 1 Codec Driver");
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_v4l2.h
@@ -0,0 +1,498 @@
+
+#ifndef __VE1_V4L2_H__
+#define __VE1_V4L2_H__
+
+#include <linux/debugfs.h> // for struct debugfs_blob_wrapper
+
+#include <media/v4l2-device.h> // for struct v4l2_device, struct video_device
+#include <media/v4l2-ctrls.h> // for struct v4l2_ctrl_handler
+#include <media/v4l2-fh.h> // for struct v4l2_fh
+#include "ve_common.h"
+#include "debug.h"
+
+#define VE1_LOGTAG "[V4L2_VE1]"
+
+#define MAX_VE1_FRAME_BUFFERS 32
+#define VE1_STREAM_END_FLAG (1 << 2)
+#define PTS_UNIT 90000L // 90000 pts/sec
+
+#define VE1_ION_STRUCT_NUM 256
+
+extern unsigned int vpu_debug;
+
+#define ve1_printk(level, category, tag, fmt, arg...)                          \
+	do {                                                                   \
+		int show_log = 0;                                              \
+		if (vpu_debug & VPU_DBG_VE1_ALL)                               \
+			show_log = 1;                                          \
+		else if (vpu_debug & category)                                 \
+			show_log = 1;                                          \
+		if (show_log)                                                  \
+			printk(level "%s [%d]%s." fmt, tag, __LINE__,          \
+			       __func__, ##arg);                               \
+	} while (0)
+
+#define ve1_err(tag, fmt, arg...)                                              \
+	printk(KERN_ERR "%s [%d]%s." fmt, tag, __LINE__, __func__, ##arg);
+
+#define ve1_warn(tag, fmt, arg...)                                             \
+	printk(KERN_WARNING "%s [%d]%s." fmt, tag, __LINE__, __func__, ##arg);
+
+#define ve1_info(tag, fmt, arg...)                                             \
+	printk(KERN_INFO "%s [%d]%s." fmt, tag, __LINE__, __func__, ##arg);
+
+#define ve1_dbg(category, tag, fmt, arg...)                                    \
+	ve1_printk(KERN_DEBUG, category, tag, fmt, ##arg)
+
+#define MPEG2_CC_REG_FRAME_MAX 32 // the maximum of VPU register frames
+#define MPEG2_CC_RINGBUF_SIZE 2048
+#define RTK_CC_SYNC 0x52744B63 // RtKc
+#define RTK_CC_HEADER_SIZE 16
+#define USER_DATA_NUM_MAX 8
+
+enum { ENUM_CC_MPGE2 = 1, ENUM_CC_H264, ENUM_CC_H265 };
+
+enum { ENUM_CC_A53_PART4 = 0, ENUM_CC_SCTE_20, ENUM_CC_DVD, ENUM_CC_TOTAL_NUM };
+
+typedef struct {
+	int nUserDataNum;
+	int nTotalUserDataSize;
+	int nUserDataType[USER_DATA_NUM_MAX];
+	int nUserDataOffset[USER_DATA_NUM_MAX];
+	int nUserDataSize[USER_DATA_NUM_MAX];
+} USER_DATA_INFO;
+
+/**
+* RTKVE1_DPB_ST_EMPTY:			this dpb info is empty
+* RTKVE1_DPB_ST_VALID:			this dpb is assigned by cap_qbuf
+* this status means cap_buf is owned by driver
+* set:		ve1_cap_qbuf() => VE1_UpdateDPBStatus() or rtkve1_add_capbuf_to_dpb()
+* clear:	ve1_stop_streaming(cap) => rtkve1_flush_dpbs(), all cap_bufs which owned by driver should be done
+*
+* RTKVE1_DPB_ST_REG: 			this dpb is registered to VE1
+* set:		rtkve1_register_dpbs(), rtkve1_register_new_dpb
+* clear:	ve1_free_capture() caused rtkve1_unreg_dpbs(), all dpb info are cleared
+*
+* RTKVE1_DPB_ST_DQ:				this dpb is dequeued by cap_dqbuf
+* set:		ve1_cap_dqbuf() => VE1_UpdateDPBStatus()
+* clear:	(1) ve1_cap_qbuf() => VE1_UpdateDPBStatus(RTKVE1_DPB_ST_VALID)
+*			(2) ve1_stop_streaming(cap) => rtkve1_flush_dpbs()
+*
+* RTKVE1_DPB_ST_WAIT_RECYCLE:	this dpb is waiting for recycle
+* set:		ve1_cap_qbuf() => VE1_UpdateDPBStatus()
+* clear:	(1) rtkve1_recycle_dpb()
+*			(2) ve1_stop_streaming(cap) => rtkve1_flush_dpbs()
+*/
+typedef enum {
+	RTKVE1_DPB_ST_EMPTY = 0x0000,
+	RTKVE1_DPB_ST_VALID =
+		0x0001,
+	RTKVE1_DPB_ST_REG = 0x0002,
+	RTKVE1_DPB_ST_DQ = 0x0004,
+	RTKVE1_DPB_ST_WAIT_RECYCLE =
+		0x0008
+} RTKVE1_DPB_STATUS;
+
+#define IS_RTKVE1_DPB_EMPTY(status) (((status) == RTKVE1_DPB_ST_EMPTY) ? 1 : 0)
+#define IS_RTKVE1_DPB_VALID(status) ((status)&RTKVE1_DPB_ST_VALID)
+#define IS_RTKVE1_DPB_REG(status) ((status)&RTKVE1_DPB_ST_REG)
+#define IS_RTKVE1_DPB_DQ(status) ((status)&RTKVE1_DPB_ST_DQ)
+#define IS_RTKVE1_DPB_WAIT_RECYCLE(status) ((status)&RTKVE1_DPB_ST_WAIT_RECYCLE)
+
+struct rtkve1_dpb_t {
+	unsigned int status; // RTKVE1_DPB_STATUS
+	unsigned int size;
+	unsigned long phys_addr;
+	unsigned long virt_addr;
+	void *vb2_v4l2_buf; // struct vb2_v4l2_buffer *
+	unsigned long dmabuf; // struct dma_buf *
+	unsigned long attach; // struct dma_buf_attachment *
+	unsigned long table; // struct sg_table *
+	void *reg_entry;
+	unsigned int regIndex; // the index when registering dpb to VE1
+	unsigned int seqNo; // sequence number
+};
+
+typedef uint32_t PhysicalAddress;
+
+struct tch_metadata_variables {
+	int tmInputSignalBlackLevelOffset;
+	int tmInputSignalWhiteLevelOffset;
+	int shadowGain;
+	int highlightGain;
+	int midToneWidthAdjFactor;
+	int tmOutputFineTuningNumVal;
+	int tmOutputFineTuningX[15];
+	int tmOutputFineTuningY[15];
+	int saturationGainNumVal;
+	int saturationGainX[15];
+	int saturationGainY[15];
+};
+
+struct tch_metadata_tables {
+	int luminanceMappingNumVal;
+	int luminanceMappingX[33];
+	int luminanceMappingY[33];
+	int colourCorrectionNumVal;
+	int colourCorrectionX[33];
+	int colourCorrectionY[33];
+	int chromaToLumaInjectionMuA;
+	int chromaToLumaInjectionMuB;
+};
+
+struct tch_metadata {
+	int specVersion;
+	int payloadMode;
+	int hdrPicColourSpace;
+	int hdrMasterDisplayColourSpace;
+	int hdrMasterDisplayMaxLuminance;
+	int hdrMasterDisplayMinLuminance;
+	int sdrPicColourSpace;
+	int sdrMasterDisplayColourSpace;
+	union {
+		struct tch_metadata_variables variables;
+		struct tch_metadata_tables tables;
+	} u;
+};
+
+typedef enum {
+	VE1_DEC_CODEC_AVC = 0,
+	VE1_DEC_CODEC_VC1,
+	VE1_DEC_CODEC_MPEG2,
+	VE1_DEC_CODEC_MPEG4,
+	VE1_DEC_CODEC_H263,
+	VE1_DEC_CODEC_RV = 6,
+	VE1_DEC_CODEC_AVS,
+	VE1_DEC_CODEC_THO = 9,
+	VE1_DEC_CODEC_VP3,
+	VE1_DEC_CODEC_VP8,
+	VE1_DEC_CODEC_MAX
+} ve1_decode_codec;
+
+enum { V4L2_M2M_SRC = 0,
+       V4L2_M2M_DST = 1,
+};
+
+enum { VE1_HANDLE_EOS_BY_NONE = 0,
+       VE1_HANDLE_EOS_BY_PREPARE_RUN = 1,
+       VE1_HANDLE_EOS_SET_END = 2,
+	   VE1_HANDLE_EOS_DEC_FINISH = 3,
+};
+
+struct ve1_device;
+
+struct ve1_devtype {
+	const struct ve1_codec *codecs;
+	unsigned int num_codecs;
+	const struct ve1_device *vdev;
+};
+
+struct ve1_buf {
+	void *vaddr;
+	unsigned long paddr;
+	unsigned long dma_buf;
+	u32 size;
+	struct debugfs_blob_wrapper blob;
+	struct dentry *dentry;
+};
+
+struct ve1_dev {
+	struct v4l2_device v4l2_dev;
+	struct video_device vfd;
+	struct platform_device *plat_dev;
+	const struct ve1_devtype *devtype;
+	spinlock_t irqlock;
+	struct mutex dev_mutex;
+	struct mutex ve1_mutex;
+	struct workqueue_struct *workqueue;
+	struct v4l2_m2m_dev *m2m_dev;
+};
+
+struct ve1_codec {
+	u32 type;
+	u32 src_fourcc;
+	u32 dst_fourcc;
+	u32 max_w;
+	u32 max_h;
+};
+
+struct ve1_meta {
+	struct list_head list;
+	u32 sequence;
+	struct v4l2_timecode timecode;
+	u64 timestamp;
+	u32 start;
+	u32 end;
+};
+
+struct ve1_q_data {
+	unsigned int width;
+	unsigned int height;
+	unsigned int bytesperline;
+	unsigned int sizeimage;
+	unsigned int fourcc;
+	struct v4l2_rect rect;
+};
+
+struct ve1_parsed_initial_info {
+	unsigned int pic_width; // picture width in sequence header
+	unsigned int pic_height; // picture height in sequence header
+	unsigned int visible_rect_left;
+	unsigned int visible_rect_top;
+	unsigned int visible_rect_w;
+	unsigned int visible_rect_h;
+	unsigned int minDpbCount;
+	unsigned int interlace;
+};
+
+struct ve1_displayable_frame {
+	struct list_head list;
+	unsigned int
+		regIndex; // outputinfo.indexFrameDisplay or outputinfo.indexFrameDecoded
+	PhysicalAddress
+		dpb_paddr; // physical address of decoded picture buffer (decoded frame buffer)
+	struct vb2_v4l2_buffer
+		*vb2_v4l2_buf; // the struct vb2_v4l2_buffer of dpb (cap_buf)
+	unsigned int
+		isDequeued; // 1 means this vb2_v4l2_buf is dequeued in ve1_cap_dqbuf
+	unsigned long size;
+	unsigned long long
+		timestamp; // timestamp get from src buffer (V4L2_BUF_TYPE_VIDEO_OUTPUT)
+	struct v4l2_timecode
+		timecode; // timecode get from src buffer (V4L2_BUF_TYPE_VIDEO_OUTPUT)
+	unsigned int last_frame;
+	unsigned int sequenceNo; // this frame belongs to which sequence
+
+	unsigned int frameBufIndex; // index of frame buffer
+	unsigned int
+		Y_addr; // physical address of luma of decoded/display frame buffer
+	unsigned int
+		U_addr; // physical address of chroma of decoded/display frame buffer
+	unsigned int bufStride; // allocated frame buffer width
+	unsigned int bufHeight; // allocatae frame buffer height
+	unsigned int picWidth; // picture width from Sequence Parameter Set
+	unsigned int picHeight; // picture height from Sequence Parameter Set
+	unsigned int rectLeft; // the left of display rectangle
+	unsigned int rectTop; // the top of display rectangle
+	unsigned int rectRight; // the right of display rectangle
+	unsigned int rectBottom; // the bottom of display rectangle
+	unsigned int bitDepth; // pixel bit-depth
+	unsigned int mode; // progressive or interlace (top first or bottom first)
+	unsigned long long timeTick; // 90K/fps
+	unsigned int video_full_range_flag; // H264 vui_parameters
+	unsigned int transfer_characteristics; // H264 vui_parameters
+	unsigned int matrix_coefficients; // H264 vui_parameters
+	int POC;
+	int picType;
+};
+
+struct ve1_decoded_frame {
+	int picType;
+	int errorBlock;
+	int POC;
+	signed char repeatFirstField; // for mpeg2 pts inc calculation
+	signed char mvcViewIdx;
+	signed char topFieldFirst;
+	char pairedFldFrm;
+	char stillVOBU;
+	char reSend;
+	signed short mvcPairIdx;
+	int qualityLevel;
+	int decodingSuccess;
+	int bytePosFrameStart;
+	int bytePosFrameEnd;
+	int ppuFbIndex;
+	int video_full_range_flag; // H264 vui_parameters
+	int colour_primaries; // H264 vui_parameters
+	int transfer_characteristics; // H264 vui_parameters
+	int matrix_coefficients; // H264 vui_parameters
+
+	enum PICTURE_MODE picMode;
+};
+
+struct ve1_ctx;
+
+struct ve1_ctx_ops {
+	int (*queue_init)(void *priv, struct vb2_queue *src_vq,
+			  struct vb2_queue *dst_vq);
+	int (*reqbufs)(struct ve1_ctx *ctx, struct v4l2_requestbuffers *rb);
+	int (*start_streaming)(struct ve1_ctx *ctx);
+	int (*prepare_run)(struct ve1_ctx *ctx);
+	int (*finish_run)(struct ve1_ctx *ctx);
+	void (*run_timeout)(struct ve1_ctx *ctx);
+	void (*seq_init_work)(struct work_struct *work);
+	void (*seq_end_work)(struct work_struct *work);
+	void (*release)(struct ve1_ctx *ctx);
+};
+
+struct ve1_ctx {
+	struct ve1_dev *dev;
+	struct mutex buffer_mutex;
+	struct work_struct pic_run_work;
+	struct work_struct seq_init_work;
+	struct work_struct seq_end_work;
+	const struct ve1_device *vd;
+	const struct ve1_ctx_ops *ops;
+	int aborting;
+	int seqInited;
+	int streamEnd;
+	int startDecode;
+	int dpbFull;
+	int streamon_out;
+	int streamon_cap;
+	unsigned int out_vb2_q_memory; // V4L2_MEMORY_MMAP or V4L2_MEMORY_DMABUF
+	u32 outbuf_sequence;
+	u32 capbuf_sequence;
+	struct ve1_q_data q_data[2];
+	const struct ve1_codec *codec;
+	enum v4l2_colorspace colorspace;
+	struct v4l2_ctrl_handler ctrls;
+	struct v4l2_fh fh;
+	struct mutex bitstream_mutex;
+	struct ve1_buf bitstream;
+	unsigned long
+		bsRdPtr; // whether svp or non-svp, it always store physical address
+	unsigned long
+		bsWrPtr; // whether svp or non-svp, it always store physical address
+	struct ve1_meta frame_metas[MAX_VE1_FRAME_BUFFERS];
+	struct list_head buffer_meta_list;
+	spinlock_t buffer_meta_lock;
+	struct list_head displayable_frame_list;
+	spinlock_t displayable_frame_lock;
+	int num_metas;
+	int idx;
+
+	void *filp; // struct file *file from ve1_open
+	int ve1DecState;
+	void *decOP;
+	void *decHandle;
+	void *initialInfo;
+	int regFbCount;
+	int framebufSize;
+	void *fbAllocInfo;
+	void *fbUser;
+	void *decParam;
+	void *secAxiUse;
+	void *decCacheConfig;
+	int int_reason;
+	PhysicalAddress vpuRdPtr;
+	PhysicalAddress vpuWrPtr;
+	PhysicalAddress bufEmptyVpuWrPtr;
+	void *outputInfo;
+	unsigned int outputinfoSN;
+	unsigned int decodedFrmNum;
+	unsigned int displayFrmNum;
+	unsigned int accuBsFeedBytes;
+	int lastIndexFrameDecoded;
+	int lastIndexFrameDisplay;
+	PhysicalAddress lastDisplayFrmBufY;
+	void *displayFrameInfo;
+	unsigned int vpuBsRingRoom;
+
+	// for merge rtk_ve1_v4l2 to rtk_vdec
+	struct mutex ve1_mutex;
+	struct workqueue_struct *workqueue;
+	int is_svp;
+	unsigned int
+		currSequenceNo; // current sequence No, it increased by 1 when seq init completed in VE1_DecSeqInit()
+	int seqChangeRequest;
+	int seqChangeDone;
+	int handle_eos_by;
+	int last_frame;
+	// cap_dqbuf on previous sequence maybe happened after new sequence inited,
+	// save currSequenceNo when last frame reported after frame dequeued, this seqNo will be used on rtkve1_find_dpb_undequeue()
+	unsigned int lastFrmReportedAfFrmDqSeqNo;
+	struct vb2_v4l2_buffer *lastDqCapBuf;
+	struct vb2_v4l2_buffer *lastDoneCapBuf;
+	unsigned long long lastFrameTimestamp;
+	struct ve1_decoded_frame frameQueue[MAX_VE1_FRAME_BUFFERS];
+	unsigned long long timeTick; // 90KHz
+	struct rtkve1_dpb_t dpb[VE1_ION_STRUCT_NUM];
+	int bNewYuvDumpFile;	// #if defined(RTKVE1_DUMP_YUV_EN) in ve1_wrapper.c
+	void *yuvDumpFile;		// #if defined(RTKVE1_DUMP_YUV_EN) in ve1_wrapper.c
+	unsigned char yuvDumpFileName[256]; // #if defined(RTKVE1_DUMP_YUV_EN) in ve1_wrapper.c
+	int bNewChecksumFile;
+	void *fpChecksum;
+
+	// info
+	int cntQueuePicRunWorkOk;
+	int cntQueuePicRunWorkFail;
+	int cntExecPicRunWork;
+	int cntOutQbuf;
+	int cntFrameDq;
+
+	struct device *pdev;
+	// debug
+	int totIonAllocatedBytes;
+
+#ifdef VPU_GET_CC
+	// user data info and buffer to config ve1
+	int userDataEnable;
+	int userDataReportMode;
+	int userDataBufSize;
+	PhysicalAddress
+		userDataBufPhysAddr; // it is an ion/dma buffer which set to ve1, ve1 will fill user data to this buffer if user data existed
+	void *pUserDataBufVirtAddr;
+	unsigned char *
+		pUserDataSrcBuf; // ve1_get_userdata() will parse header in pUserDataBufVirtAddr and copy actual user data bytes to this pUserDataSrcBuf
+	char *m_CCDecodeOrderWp
+		[MPEG2_CC_REG_FRAME_MAX]; //keeping write pointer by decoder's frame order, todo
+	int cc_error_count;
+#endif
+	int timeoutCount;
+	bool bBufEmptyFlag;
+	int cntCap2Dpb;
+	int32_t seqHeaderSize;
+	uint8_t *seqHeader;
+	uint8_t *picHeader;
+	bool bWaitNextField;
+	bool bGotNextField;
+	PhysicalAddress fldDoneVpuRp;
+	bool bPostponeUpBs; // postpone update bs. set to true after update bitstream, set to false after get int_reason
+	struct mutex ve1_dma_mutex;
+	PhysicalAddress lastInfoFrmStart;
+	PhysicalAddress lastInfoFrmEnd;
+	unsigned int cntAddToList;
+	unsigned int capReqBufsCnt;
+	bool bFlush;
+	unsigned int lastDispPOC;
+
+	int bNewBsDumpFile;		// #if defined(RTKVE1_DUMP_BS_EN) in ve1_wrapper.c
+	void *bsDumpFile;		// #if defined(RTKVE1_DUMP_BS_EN) in ve1_wrapper.c
+	unsigned char bsDumpFileName[256]; // #if defined(RTKVE1_DUMP_BS_EN) ve1_wrapper.c
+
+	int free_cap;
+	int error;
+	int noshowframe; // VP8
+	signed char prev_repeatFirstField;
+	bool bSuspend;
+	int fatal_err;
+};
+
+static inline unsigned long ve1_ring_valid_data(unsigned long ring_base,
+						unsigned long ring_limit,
+						unsigned long ring_rp,
+						unsigned long ring_wp)
+{
+	if (ring_wp >= ring_rp) {
+		return (ring_wp - ring_rp);
+	} else {
+		return ((ring_limit - ring_base) - (ring_rp - ring_wp));
+	}
+}
+
+static inline unsigned long ve1_ring_phys_to_virt(unsigned long phys_addr,
+						  unsigned long phys_base,
+						  unsigned long virt_base)
+{
+	return (virt_base + (phys_addr - phys_base));
+}
+
+static inline unsigned int ve1_get_bitstream_payload(struct ve1_ctx *ctx)
+{
+	return ve1_ring_valid_data(ctx->bitstream.paddr,
+				   ctx->bitstream.paddr + ctx->bitstream.size,
+				   ctx->bsRdPtr, ctx->bsWrPtr);
+}
+
+#endif /* __VE1_V4L2_H__ */
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_v4l2_drv_ops.h
@@ -0,0 +1,36 @@
+#ifndef __VE1_V4L2_DRV_OPS__
+#define __VE1_V4L2_DRV_OPS__
+
+#include <linux/fs.h>
+#include <linux/types.h>
+#include "ve1.h"
+
+
+extern int kent_vdi_ioctl_get_instance_pool(vpudrv_buffer_t *vdb);
+extern int kent_vdi_ioctl_get_register_info(vpudrv_buffer_t *vdb);
+extern int kent_vdi_ioctl_set_rtk_clk_gating(vpu_clock_info_t* clockInfo);
+extern int kent_vdi_ioctl_get_common_memory(vpudrv_buffer_t *vdb);
+extern ssize_t kent_vdi_write_bit_firmware(vpu_bit_firmware_info_t *buf, size_t len);
+extern int kent_vdi_ioctl_allocate_physical_memory(void *filp, vpudrv_buffer_t *vdb);
+extern int kent_vdi_ioctl_free_physical_memory(vpudrv_buffer_t *vdb);
+extern int kent_vdi_ioctl_allocate_physical_memory_no_mmap(void *filp, vpudrv_buffer_t *vdb);
+extern int kent_vdi_ioctl_free_physical_memory_no_mmap(vpudrv_buffer_t *vdb);
+extern int kent_vdi_ioctl_open_instance(void *filp, vpudrv_inst_info_t *inst_info);
+extern int kent_vdi_ioctl_close_instance(vpudrv_inst_info_t *inst_info);
+extern int kent_vdi_ioctl_wait_interrupt(vpudrv_intr_info_t *intr_info);
+
+
+extern int rtd16xxb_vdi_ioctl_get_instance_pool(vpudrv_buffer_t *vdb);
+extern int rtd16xxb_vdi_ioctl_get_register_info(vpudrv_buffer_t *vdb);
+extern int rtd16xxb_vdi_ioctl_set_rtk_clk_gating(vpu_clock_info_t* clockInfo);
+extern int rtd16xxb_vdi_ioctl_get_common_memory(vpudrv_buffer_t *vdb);
+extern ssize_t rtd16xxb_vdi_write_bit_firmware(vpu_bit_firmware_info_t *buf, size_t len);
+extern int rtd16xxb_vdi_ioctl_allocate_physical_memory(void *filp, vpudrv_buffer_t *vdb);
+extern int rtd16xxb_vdi_ioctl_free_physical_memory(vpudrv_buffer_t *vdb);
+extern int rtd16xxb_vdi_ioctl_allocate_physical_memory_no_mmap(void *filp, vpudrv_buffer_t *vdb);
+extern int rtd16xxb_vdi_ioctl_free_physical_memory_no_mmap(vpudrv_buffer_t *vdb);
+extern int rtd16xxb_vdi_ioctl_open_instance(void *filp, vpudrv_inst_info_t *inst_info);
+extern int rtd16xxb_vdi_ioctl_close_instance(vpudrv_inst_info_t *inst_info);
+extern int rtd16xxb_vdi_ioctl_wait_interrupt(vpudrv_intr_info_t *intr_info);
+
+#endif
\ No newline at end of file
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_vdi.c
@@ -0,0 +1,3241 @@
+//------------------------------------------------------------------------------
+// File: vdi.c
+//
+// Copyright (c) 2006, Chips & Media.  All rights reserved.
+//------------------------------------------------------------------------------
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/time.h>
+#include <linux/sched.h>
+
+#include "ve1.h"
+#include "ve1_vdi.h"
+#include "ve1_vdi_osal.h"
+#include "ve1_regdefine.h"
+#include "drv_if.h"
+
+#define VPU_DEVICE_NAME "/dev/vpu"
+#define RTK_VPU_DEVICE_NAME "/rtk/vpu"
+
+typedef struct mutex MUTEX_HANDLE;
+typedef struct new_pthread_mutex_t {
+	uint32_t val[10];
+} new_pthread_mutex_t;
+typedef new_pthread_mutex_t USERSPACE_MUTEX_HANDLE;
+#ifndef ANDROID
+// for gLinux, using mmap.
+#define mmap64 mmap
+#endif
+
+#define VE1_PROT_CTRL 0x3050
+#define VE1_CTRL 0x3000
+
+#define SUPPORT_INTERRUPT
+#define VPU_BIT_REG_SIZE 0xC000
+#define VDI_SRAM_BASE_ADDR                                                     \
+	0x00000000 // if we can know the sram address in SOC directly for vdi layer. it is possible to set in vdi layer without allocation from driver
+#define VDI_SRAM_SIZE 0x1D000 // RTK SRAM MAX size for stark(116kB)
+#define VDI_CODA9_SRAM_SIZE 0x1D000
+#define VDI_SYSTEM_ENDIAN VDI_LITTLE_ENDIAN
+#define VDI_128BIT_BUS_SYSTEM_ENDIAN VDI_128BIT_LITTLE_ENDIAN
+#define VDI_NUM_LOCK_HANDLES 5
+
+/* RTK, begin */
+typedef struct vpu_sram_info {
+	int inited;
+	int owner_core;
+	unsigned long generation;
+} vpu_sram_info;
+
+typedef struct vpu_sram_device {
+	vpu_sram_info *info;
+	struct mutex *lock;
+	unsigned long generation;
+	vpu_instance_pool_t *pvip[MAX_NUM_VPU_CORE];
+} vpu_sram_device;
+
+static DEFINE_MUTEX(vdi_info_mutex_init_lock);
+static struct mutex vdi_info_mutex[MAX_NUM_VPU_CORE];
+static struct mutex vdi_init_release_lock[MAX_NUM_VPU_CORE];
+
+static int vdi_info_mutex_init = 0;
+
+static struct mutex vpu_mutex;
+static struct mutex vpu_disp_mutex;
+static struct mutex vpu_sram_mutex;
+static struct mutex vpu_thumb_mutex;
+
+/* RTK, end */
+// kernel 5.15, redefinition in ve1.h, so rename vpudrv_buffer_pool_t to vdi_vpudrv_buffer_pool_t
+typedef struct vdi_vpudrv_buffer_pool_t {
+	vpudrv_buffer_t vdb;
+	int inuse;
+} vdi_vpudrv_buffer_pool_t;
+
+typedef struct {
+	unsigned long core_idx;
+	unsigned int product_code;
+	int vpu_fd;
+	vpu_instance_pool_t *pvip;
+	int task_num;
+	int clock_state;
+	vpudrv_buffer_t vdb_register;
+	vpu_buffer_t vpu_common_memory;
+	vpu_buffer_t vpu_common_memory_protect;
+	vdi_vpudrv_buffer_pool_t vpu_buffer_pool[MAX_VPU_BUFFER_POOL];
+	vpudrv_buffer_t
+		vdb_pvip; /* RTK, we didn't store pvip information into vpu_buffer_pool */
+	int vpu_buffer_pool_count;
+	unsigned int asic_id;
+	vpudrv_buffer_t dcsys_register;
+	vpudrv_buffer_t dmcsys_register;
+
+	struct mutex *vpu_mutex;
+	struct mutex *vpu_disp_mutex;
+	struct mutex *vpu_sram_mutex;
+	struct mutex *vpu_thumb_mutex;
+
+	vpu_sram_device *sram_dev;
+	int *thumb_used;
+	int *thumb_num;
+
+	struct mutex *ve1_hw_mutex;
+	u32 *ve1_instance_nums;
+	const struct rtkve1_drv_ops *drv_ops;
+} vdi_info_t;
+
+static vdi_info_t s_vdi_info[MAX_NUM_VPU_CORE];
+/* a mutex protecting the wrapper init */
+
+/* define internal function begin */
+static int Internal_swap_endian(unsigned long core_idx, unsigned char *data,
+				int len, int endian);
+static int Internal_allocate_common_memory(unsigned long core_idx);
+static int Internal_vdi_set_bit_firmware_to_pm(unsigned long core_idx,
+					       const unsigned short *code);
+static int Internal_vdi_release(unsigned long core_idx);
+static int Internal_vdi_lock(unsigned long core_idx);
+static void Internal_vdi_set_rtk_clk_gating(Uint32 coreIdx, BOOL clk_en);
+static unsigned int Internal_vdi_read_register(unsigned long core_idx,
+					       unsigned int addr);
+static void Internal_vdi_write_register(unsigned long core_idx,
+					unsigned int addr, unsigned int data);
+static int Internal_vdi_set_clock_gate(unsigned long core_idx, int enable);
+static void Internal_vdi_unlock(unsigned long core_idx);
+static void Internal_vdi_disp_unlock(unsigned long core_idx);
+static int Internal_vdi_allocate_dma_memory(unsigned long core_idx,
+					    vpu_buffer_t *vb, void *filp);
+static int Internal_vdi_allocate_dma_memory_no_mmap(unsigned long core_idx,
+						    vpu_buffer_t *vb,
+						    void *filp);
+static void Internal_vdi_free_dma_memory(unsigned long core_idx,
+					 vpu_buffer_t *vb);
+static void Internal_vdi_free_dma_memory_no_mmap(unsigned long core_idx,
+						 vpu_buffer_t *vb);
+static int Internal_vdi_convert_endian(unsigned long core_idx,
+				       unsigned int endian);
+static int Internal_vdi_write_memory(unsigned long core_idx, unsigned int addr,
+				     unsigned char *data, int len, int endian);
+static int Internal_vdi_get_total_instance_num(unsigned long core_idx);
+static void Internal_vdi_set_thumb_num(unsigned long core_idx,
+				       unsigned int enable);
+static unsigned int Internal_vdi_get_thumb_num(unsigned long core_idx);
+static unsigned int Internal_vdi_set_thumb_used(unsigned long core_idx,
+						unsigned int enable);
+static int Internal_vdi_get_common_memory(unsigned long core_idx,
+					  vpu_buffer_t *vb);
+static int Internal_vdi_get_common_memory_protect(unsigned long core_idx,
+						  vpu_buffer_t *vb, void *filp);
+static vpu_instance_pool_t *
+Internal_vdi_get_instance_pool(unsigned long core_idx);
+static int Internal_vdi_open_instance(unsigned long core_idx,
+				      unsigned long inst_idx, void *filp);
+static int Internal_vdi_close_instance(unsigned long core_idx,
+				       unsigned long inst_idx);
+static int Internal_vdi_get_instance_num(unsigned long core_idx);
+static int Internal_vdi_hw_reset(unsigned long core_idx);
+static void Internal_vdi_check_hwreset(unsigned long core_idx);
+static int restore_mutex_in_dead(MUTEX_HANDLE *mutex);
+static int Internal_vdi_init(unsigned long core_idx, void *videc_dev);
+
+//#define DEBUG_VDI_INFO_LOCK
+#ifdef DEBUG_VDI_INFO_LOCK
+#define lock_vdi_info(core_idx) lock_vdi_info_debug(core_idx, __FUNCTION__)
+#define unlock_vdi_info(vdi, core_idx)                                         \
+	unlock_vdi_info_debug(vdi, core_idx, __FUNCTION__)
+static vdi_info_t *lock_vdi_info_debug(unsigned long core_idx,
+				       const char *parent_name);
+static void unlock_vdi_info_debug(vdi_info_t *vdi, unsigned long core_idx,
+				  const char *parent_name);
+#else
+static vdi_info_t *lock_vdi_info(unsigned long core_idx);
+static void unlock_vdi_info(vdi_info_t *vdi, unsigned long core_idx);
+#endif
+/* define internal function end */
+
+static vpu_sram_device *sram_device_create(vpu_sram_info *info, void *pMutex,
+					   int *pMutexState, void *first_pvip,
+					   unsigned long pvip_size)
+{
+	int i;
+	int needToInited = 0;
+	vpu_sram_device *device =
+		(vpu_sram_device *)osal_malloc(sizeof(vpu_sram_device));
+
+	device->info = info;
+	device->lock = (struct mutex *)pMutex;
+	for (i = 0; i < MAX_NUM_VPU_CORE; i++)
+		device->pvip[i] =
+			(vpu_instance_pool_t *)((unsigned long)first_pvip +
+						(i * pvip_size));
+
+	if (*pMutexState == FALSE) {
+		mutex_init(device->lock);
+		*pMutexState = TRUE;
+		needToInited = 1;
+	}
+
+	mutex_lock(device->lock);
+
+	if (device->info->inited == FALSE)
+		needToInited = 1;
+
+	if (needToInited) {
+		device->info->owner_core = -1;
+		device->info->inited = TRUE;
+		device->info->generation++;
+	}
+	mutex_unlock(device->lock);
+
+	return device;
+}
+
+static void sram_device_remove(vpu_sram_device *device)
+{
+	restore_mutex_in_dead((MUTEX_HANDLE *)device->lock);
+	mutex_lock(device->lock);
+	mutex_unlock(device->lock);
+	osal_free(device);
+}
+
+static inline void vdi_info_mutex_init_check(void)
+{
+	mutex_lock(&vdi_info_mutex_init_lock);
+	if (vdi_info_mutex_init == 0) {
+		Int32 i;
+		for (i = 0; i < MAX_NUM_VPU_CORE; i++) {
+			mutex_init(&vdi_info_mutex[i]);
+			mutex_init(&vdi_init_release_lock[i]);
+			memset(&s_vdi_info[i], 0x00, sizeof(vdi_info_t));
+			s_vdi_info[i].vpu_fd = -1;
+		}
+		vdi_info_mutex_init = 1;
+	}
+	mutex_unlock(&vdi_info_mutex_init_lock);
+}
+
+#ifdef DEBUG_VDI_INFO_LOCK
+static vdi_info_t *lock_vdi_info_debug(unsigned long core_idx,
+				       const char *parent_name)
+{
+	vdi_info_mutex_init_check();
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		goto err;
+	mutex_lock(&vdi_info_mutex[core_idx]);
+	VLOG(ERR, "[%s:%s] core_idx = %ld", __FUNCTION__, parent_name,
+	     core_idx);
+	return &s_vdi_info[core_idx];
+err:
+	return NULL;
+}
+
+static void unlock_vdi_info_debug(vdi_info_t *vdi, unsigned long core_idx,
+				  const char *parent_name)
+{
+	if (vdi) {
+		mutex_unlock(&vdi_info_mutex[core_idx]);
+		VLOG(ERR, "[%s:%s] core_idx = %ld", __FUNCTION__, parent_name,
+		     core_idx);
+	}
+	return;
+}
+#else
+static vdi_info_t *lock_vdi_info(unsigned long core_idx)
+{
+	vdi_info_mutex_init_check();
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		goto err;
+	mutex_lock(&vdi_info_mutex[core_idx]);
+	return &s_vdi_info[core_idx];
+err:
+	return NULL;
+}
+
+static void unlock_vdi_info(vdi_info_t *vdi, unsigned long core_idx)
+{
+	if (vdi) {
+		mutex_unlock(&vdi_info_mutex[core_idx]);
+	}
+	return;
+}
+#endif
+
+static inline int vdi_pthread_mutex_trylock(unsigned long core_idx, int delayUs,
+					    MUTEX_HANDLE *mutex)
+{
+	int ret;
+	unlock_vdi_info(&s_vdi_info[core_idx], core_idx);
+	ret = mutex_trylock((struct mutex *)mutex);
+	ret = !ret; // mutex_trylock() return 1 means lock, pthread_mutex_trylock() return 0 means lock
+	if (ret != 0 && delayUs > 0) {
+		usleep_range(delayUs, delayUs);
+	}
+	lock_vdi_info(core_idx);
+	return ret;
+}
+
+static void vdi_init_thumb_info(vdi_info_t *vdi, int *pMutexState,
+				void *first_pvip, unsigned long pvip_size)
+{
+	int i, j;
+	int inUse = 0;
+	vpu_instance_pool_t *pvip;
+
+	if (*pMutexState == FALSE) {
+		mutex_init(vdi->vpu_thumb_mutex);
+		*pMutexState = TRUE;
+	}
+
+	mutex_lock(vdi->vpu_thumb_mutex);
+	for (i = 0; i < MAX_NUM_VPU_CORE; i++) {
+		pvip = (vpu_instance_pool_t *)((unsigned long)first_pvip +
+					       (i * pvip_size));
+		for (j = 0; j < MAX_NUM_INSTANCE; j++) {
+			int *pCodecInst = (int *)pvip->codecInstPool[j];
+			if (pCodecInst[0] != 0) { // indicate inUse of CodecInst
+				inUse = 1;
+				break;
+			}
+		}
+	}
+
+	if (inUse == 0) {
+		*vdi->thumb_used = 0;
+		*vdi->thumb_num = 0;
+	}
+	mutex_unlock(vdi->vpu_thumb_mutex);
+}
+
+int vdi_probe(unsigned long core_idx)
+{
+	int ret;
+	VLOG(TRACE, "[+] [%d]%s\n", __LINE__, __func__);
+
+	mutex_init(&vdi_info_mutex_init_lock);
+
+	ret = vdi_init(core_idx, NULL);
+	vdi_release(core_idx);
+	VLOG(TRACE, "[-] [%d]%s\n", __LINE__, __func__);
+	return ret;
+}
+
+int vdi_init(unsigned long core_idx, void *videc_dev)
+{
+	int ret = -1;
+	vdi_info_t *vdi = NULL;
+
+	VLOG(TRACE, "[+] [%d]%s.core_idx:%d.MAX_NUM_VPU_CORE:%d\n", __LINE__,
+	     __func__, core_idx, MAX_NUM_VPU_CORE);
+
+	vdi = lock_vdi_info(core_idx);
+	VLOG(TRACE, "[%d]%s.tgid(%d,%d,%s).vdi:0x%x\n", __LINE__, __func__,
+	     current->tgid, current->pid, current->comm, vdi);
+	if (vdi == NULL) {
+		VLOG(ERR, "[-] [%d]%s.vdi == NULL\n", __LINE__, __func__);
+		return ret;
+	}
+	mutex_lock(&vdi_init_release_lock[core_idx]);
+	ret = Internal_vdi_init(core_idx, videc_dev);
+	mutex_unlock(&vdi_init_release_lock[core_idx]);
+	unlock_vdi_info(vdi, core_idx);
+
+	VLOG(TRACE, "[-] [%d]%s.ret:%d\n", __LINE__, __func__, ret);
+	return ret;
+}
+
+static int Internal_vdi_init(unsigned long core_idx, void *videc_dev)
+{
+	vdi_info_t *vdi;
+	int i;
+	struct videc_dev *dev = NULL;
+
+	dev = (struct videc_dev *)videc_dev;
+	VLOG(INFO, "[+] [%d]%s.dev:0x%px\n",
+		__LINE__, __func__,
+		dev);
+
+	if (core_idx >= MAX_NUM_VPU_CORE) {
+		VLOG(ERR, "[-] [%d]%s.core_idx:%d > MAX_NUM_VPU_CORE:%d\n",
+		     __LINE__, __func__, core_idx, MAX_NUM_VPU_CORE);
+		return 0;
+	}
+
+	vdi = &s_vdi_info[core_idx];
+	if (vdi->vpu_fd != -1 && vdi->vpu_fd != 0x00) {
+		vdi->task_num++;
+		*vdi->ve1_instance_nums = *vdi->ve1_instance_nums + 1;
+		VLOG(INFO, "[%d]%s.task_num:%d.ve1_instance_nums:%d(0x%px)\n",
+			__LINE__, __func__,
+			vdi->task_num,
+			*vdi->ve1_instance_nums,
+			vdi->ve1_instance_nums);
+		return 0;
+	}
+
+	vdi->vpu_fd = 0xabcd;
+
+	memset(&vdi->vpu_buffer_pool, 0x00,
+	       sizeof(vdi_vpudrv_buffer_pool_t) * MAX_VPU_BUFFER_POOL);
+	memset(&vdi->vdb_pvip, 0x00, sizeof(vpudrv_buffer_t)); //RTK
+	memset(&vdi->dcsys_register, 0x00, sizeof(vpudrv_buffer_t)); //RTK
+	memset(&vdi->dmcsys_register, 0x00, sizeof(vpudrv_buffer_t)); //RTK
+
+	vdi->drv_ops = &(dev->ve_data->drv_ops);
+	VLOG(INFO, "[%d]%s.drv_ops:0x%px.get_instance_pool:0x%px\n",
+		__LINE__, __func__,
+		(void *)(vdi->drv_ops),
+		(void *)(vdi->drv_ops->get_instance_pool));
+
+	if (!Internal_vdi_get_instance_pool(core_idx)) {
+		VLOG(TRACE,
+		     "[%d][VDI] fail to create shared info for saving context \n",
+		     __LINE__);
+		goto ERR_VDI_INIT;
+	}
+
+	if (vdi->pvip->instance_pool_inited == FALSE) {
+		int *pCodecInst;
+		mutex_init(vdi->vpu_mutex);
+		mutex_init(vdi->vpu_disp_mutex);
+
+		for (i = 0; i < MAX_NUM_INSTANCE; i++) {
+			pCodecInst = (int *)vdi->pvip->codecInstPool[i];
+			pCodecInst[1] = i; // indicate instIndex of CodecInst
+			pCodecInst[0] = 0; // indicate inUse of CodecInst
+		}
+
+		vdi->pvip->instance_pool_inited = TRUE;
+	}
+
+	if (vdi->drv_ops->get_register_info(&vdi->vdb_register) < 0) {
+		VLOG(ERR, "[%d][VDI] fail to get host interface register\n",
+		     __LINE__);
+		goto ERR_VDI_INIT;
+	}
+
+	VLOG(TRACE,
+	     "[%d][VDI] map vdb_register core_idx=%d, virtaddr=0x%lx, size=%d\n",
+	     __LINE__, core_idx, vdi->vdb_register.virt_addr,
+	     vdi->vdb_register.size);
+
+	Internal_vdi_set_clock_gate(core_idx, 1);
+
+	vdi->ve1_hw_mutex = &dev->ve1_hw_mutex;
+	vdi->ve1_instance_nums = &dev->ve1_instance_nums;
+	VLOG(INFO, "[%d]%s.ve1_hw_mutex:0x%px.ve1_instance_nums:%d(0x%px)\n",
+		__LINE__, __func__,
+		vdi->ve1_hw_mutex,
+		*vdi->ve1_instance_nums,
+		vdi->ve1_instance_nums);
+
+	//VLOG(INFO, "[%d]%s.mutex_lock(vdi->ve1_hw_mutex)\n",
+	//	__LINE__, __func__);
+	mutex_lock(vdi->ve1_hw_mutex);
+
+	if (*vdi->ve1_instance_nums == 0) {
+		Internal_vdi_set_rtk_clk_gating(core_idx, TRUE);
+	}
+
+	vdi->product_code =
+		Internal_vdi_read_register(core_idx, VPU_PRODUCT_CODE_REGISTER);
+	VLOG(TRACE, "[%d]product_code:0x%x\n", __LINE__, vdi->product_code);
+
+	if (Internal_vdi_lock(core_idx) < 0) {
+		VLOG(ERR, "[%d][VDI] fail to handle lock function\n", __LINE__);
+		//VLOG(INFO, "%d.%s.mutex_unlock(vdi->ve1_hw_mutex)\n",
+		//	__LINE__, __func__);
+		mutex_unlock(vdi->ve1_hw_mutex);
+		goto ERR_VDI_INIT;
+	}
+
+	if (PRODUCT_CODE_NOT_W_SERIES(vdi->product_code)) // CODA9XX
+	{
+		if (Internal_vdi_read_register(core_idx, BIT_CUR_PC) ==
+		    0) // if BIT processor is not running.
+		{
+			VLOG(TRACE, "[%d]BIT processor is not running\n",
+			     __LINE__);
+			for (i = 0; i < 64; i++)
+				Internal_vdi_write_register(
+					core_idx, (i * 4) + 0x100, 0x0);
+		}
+	} else {
+		VLOG(ERR, "[%d]Unknown product id : %08x\n", __LINE__,
+		     vdi->product_code);
+		//VLOG(INFO, "%d.%s.mutex_unlock(vdi->ve1_hw_mutex)\n",
+		//	__LINE__, __func__);
+		mutex_unlock(vdi->ve1_hw_mutex);
+		goto ERR_VDI_INIT;
+	}
+
+	if (Internal_allocate_common_memory(core_idx) < 0) {
+		VLOG(ERR,
+		     "[%d][VDI] fail to get vpu common buffer from driver\n",
+		     __LINE__);
+		//VLOG(INFO, "%d.%s.mutex_unlock(vdi->ve1_hw_mutex)\n",
+		//	__LINE__, __func__);
+		mutex_unlock(vdi->ve1_hw_mutex);
+		goto ERR_VDI_INIT;
+	}
+
+	vdi->core_idx = core_idx;
+	vdi->task_num++;
+	Internal_vdi_unlock(core_idx);
+
+	*vdi->ve1_instance_nums = *vdi->ve1_instance_nums + 1;
+	VLOG(INFO, "[%d]%s.[VDI] success to init driver.task_num:%d.ve1_instance_nums:%d\n",
+		__LINE__, __func__,
+		vdi->task_num, *vdi->ve1_instance_nums);
+	//VLOG(INFO, "%d.%s.mutex_unlock(vdi->ve1_hw_mutex)\n",
+	//	__LINE__, __func__);
+	mutex_unlock(vdi->ve1_hw_mutex);
+
+	VLOG(INFO, "[-] [%d]%s\n", __LINE__, __func__);
+	return 0;
+
+ERR_VDI_INIT:
+	Internal_vdi_unlock(core_idx);
+	Internal_vdi_release(core_idx);
+	VLOG(ERR, "[-] [%d]%s\n", __LINE__, __func__);
+	return -1;
+}
+
+int vdi_set_bit_firmware_to_pm(unsigned long core_idx,
+			       const unsigned short *code)
+{
+	int ret = -1;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return ret;
+	ret = Internal_vdi_set_bit_firmware_to_pm(core_idx, code);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static int Internal_vdi_set_bit_firmware_to_pm(unsigned long core_idx,
+					       const unsigned short *code)
+{
+	int i;
+	vpu_bit_firmware_info_t bit_firmware_info;
+	vdi_info_t *vdi;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return 0;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return 0;
+
+	bit_firmware_info.size = sizeof(vpu_bit_firmware_info_t);
+	bit_firmware_info.core_idx = core_idx;
+	bit_firmware_info.reg_base_offset = 0;
+
+	for (i = 0; i < 512; i++)
+		bit_firmware_info.bit_code[i] = code[i];
+
+	if (vdi->drv_ops->write_bit_firmware(&bit_firmware_info,
+					    bit_firmware_info.size) < 0) {
+		VLOG(ERR,
+		     "[%d][VDI] fail to write_bit_firmware core=%d\n",
+		     __LINE__, bit_firmware_info.core_idx);
+		return -1;
+	}
+
+	return 0;
+}
+
+int vdi_release(unsigned long core_idx)
+{
+	int ret = -1;
+	vdi_info_t *vdi = NULL;
+
+	VLOG(TRACE, "[+] [%d]%s.core_idx:%d\n", __LINE__, __func__, core_idx);
+
+	mutex_lock(&vdi_init_release_lock[core_idx]);
+	vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL) {
+		mutex_unlock(&vdi_init_release_lock[core_idx]);
+		return ret;
+	}
+	ret = Internal_vdi_release(core_idx);
+	unlock_vdi_info(vdi, core_idx);
+	mutex_unlock(&vdi_init_release_lock[core_idx]);
+
+	VLOG(TRACE, "[-] [%d]%s.core_idx:%d.ret:%d\n", __LINE__, __func__,
+	     core_idx, ret);
+	return ret;
+}
+
+#define VE1_CMD_TRAFFIC 0x3020
+static int Internal_vdi_release(unsigned long core_idx)
+{
+	int i;
+	vpudrv_buffer_t vdb;
+	vdi_info_t *vdi;
+
+	VLOG(INFO, "[+] [%d]%s.core_idx:%d\n", __LINE__, __func__, core_idx);
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return 0;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return 0;
+
+	if (Internal_vdi_lock(core_idx) < 0) {
+		VLOG(ERR, "[VDI] fail to handle lock function\n");
+		return -1;
+	}
+
+	if (vdi->task_num > 1) // means that the opened instance remains
+	{
+		vdi->task_num--;
+		*vdi->ve1_instance_nums = *vdi->ve1_instance_nums - 1;
+		VLOG(INFO, "[%d]%s.task_num:%d.ve1_instance_nums:%d\n",
+			__LINE__, __func__,
+			vdi->task_num, *vdi->ve1_instance_nums);
+		Internal_vdi_unlock(core_idx);
+		return 0;
+	}
+
+	if (vdi->sram_dev) {
+		sram_device_remove(vdi->sram_dev);
+		vdi->sram_dev = NULL;
+	}
+
+    //check cmd traffic is empty
+    {
+        int nTimeoutCnt = 10;
+        unsigned int reg = 0;
+        unsigned int cmdReg = VE1_CMD_TRAFFIC;
+        do {
+            reg = Internal_vdi_read_register(core_idx, cmdReg);
+            if ((reg & 0x70000) == 0x70000)
+                break;
+            VLOG(INFO, "[VDI] reg 0x%x = 0x%x\n", cmdReg, reg);
+            usleep_range(1000, 1000);
+            nTimeoutCnt--;
+        } while(nTimeoutCnt > 0);
+    }
+
+	osal_memset(&vdi->vdb_register, 0x00, sizeof(vpudrv_buffer_t));
+
+	osal_memset(&vdi->dcsys_register, 0x00, sizeof(vpudrv_buffer_t));
+
+	osal_memset(&vdi->dmcsys_register, 0x00, sizeof(vpudrv_buffer_t));
+
+	vdb.size = 0;
+	// get common memory information to free virtual address
+	for (i = 0; i < MAX_VPU_BUFFER_POOL; i++) {
+		if (vdi->vpu_common_memory.phys_addr >=
+			    vdi->vpu_buffer_pool[i].vdb.phys_addr &&
+		    vdi->vpu_common_memory.phys_addr <
+			    (vdi->vpu_buffer_pool[i].vdb.phys_addr +
+			     vdi->vpu_buffer_pool[i].vdb.size)) {
+			vdi->vpu_buffer_pool[i].inuse = 0;
+			vdi->vpu_buffer_pool_count--;
+			vdb = vdi->vpu_buffer_pool[i].vdb;
+			break;
+		}
+	}
+
+	if (vdb.size > 0) {
+		memset(&vdi->vpu_common_memory, 0x00, sizeof(vpu_buffer_t));
+	}
+
+	if (vdi->vpu_common_memory_protect.size != 0) {
+		Internal_vdi_free_dma_memory(core_idx,
+					     &vdi->vpu_common_memory_protect);
+	}
+
+	vdi->task_num--;
+
+	//VLOG(INFO, "[%d]%s.mutex_lock(vdi->ve1_hw_mutex)\n",
+	//	__LINE__, __func__);
+	mutex_lock(vdi->ve1_hw_mutex);
+	*vdi->ve1_instance_nums = *vdi->ve1_instance_nums - 1;
+	if ((Internal_vdi_get_instance_num(core_idx) == 0) && (*vdi->ve1_instance_nums == 0))
+		Internal_vdi_set_rtk_clk_gating(core_idx, FALSE);
+	VLOG(INFO, "[%d]%s.task_num:%d.ve1_instance_nums:%d\n",
+		__LINE__, __func__,
+		vdi->task_num, *vdi->ve1_instance_nums);
+	//VLOG(INFO, "%d.%s.mutex_unlock(vdi->ve1_hw_mutex)\n",
+	//	__LINE__, __func__);
+	mutex_unlock(vdi->ve1_hw_mutex);
+
+	Internal_vdi_unlock(core_idx);
+
+	//RTK, free instance pool virtual address
+	if (vdi->vdb_pvip.size > 0) {
+		vdi->vdb_pvip.size = 0;
+	}
+
+	memset(vdi, 0x00, sizeof(vdi_info_t));
+	vdi->vpu_fd = -1;
+
+	VLOG(INFO, "[-] [%d]%s.core_idx:%d.ret:0\n", __LINE__, __func__,
+		core_idx);
+	return 0;
+}
+
+int vdi_get_common_memory(unsigned long core_idx, vpu_buffer_t *vb)
+{
+	int ret = -1;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return ret;
+	ret = Internal_vdi_get_common_memory(core_idx, vb);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static int Internal_vdi_get_common_memory(unsigned long core_idx,
+					  vpu_buffer_t *vb)
+{
+	vdi_info_t *vdi;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return -1;
+
+	osal_memcpy(vb, &vdi->vpu_common_memory, sizeof(vpu_buffer_t));
+
+	return 0;
+}
+
+static int Internal_allocate_common_memory(unsigned long core_idx)
+{
+	vdi_info_t *vdi = &s_vdi_info[core_idx];
+	vpudrv_buffer_t vdb;
+	int i;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return -1;
+
+	osal_memset(&vdb, 0x00, sizeof(vpudrv_buffer_t));
+
+	vdb.size = SIZE_COMMON * MAX_NUM_VPU_CORE;
+	if (vdi->drv_ops->get_common_memory(&vdb) < 0) {
+		VLOG(ERR,
+		     "[%d][VDI] fail to get_common_memory size=%d\n",
+		     __LINE__, vdb.size);
+		return -1;
+	}
+
+	// convert os driver buffer type to vpu buffer type
+	vdi->pvip->vpu_common_buffer.size = SIZE_COMMON;
+	vdi->pvip->vpu_common_buffer.phys_addr = (unsigned long)(vdb.phys_addr);
+	vdi->pvip->vpu_common_buffer.base = (unsigned long)(vdb.base);
+	vdi->pvip->vpu_common_buffer.virt_addr = (unsigned long)(vdb.virt_addr);
+
+	osal_memcpy(&vdi->vpu_common_memory, &vdi->pvip->vpu_common_buffer,
+		    sizeof(vpudrv_buffer_t));
+
+	for (i = 0; i < MAX_VPU_BUFFER_POOL; i++) {
+		if (vdi->vpu_buffer_pool[i].inuse == 0) {
+			vdi->vpu_buffer_pool[i].vdb = vdb;
+			vdi->vpu_buffer_pool_count++;
+			vdi->vpu_buffer_pool[i].inuse = 1;
+			break;
+		}
+	}
+
+	VLOG(TRACE,
+	     "[%d][VDI] vdi_get_common_memory physaddr=0x%lx, size=%d, virtaddr=0x%lx\n",
+	     __LINE__, (int)vdi->vpu_common_memory.phys_addr,
+	     (int)vdi->vpu_common_memory.size,
+	     (int)vdi->vpu_common_memory.virt_addr);
+
+	return 0;
+}
+
+static int allocate_common_memory_protect(unsigned long core_idx, void *filp)
+{
+	vdi_info_t *vdi = &s_vdi_info[core_idx];
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	if ((!vdi) || (vdi->vpu_fd == -1) || (vdi->vpu_fd == 0x00)) {
+		return -1;
+	}
+
+	vdi->vpu_common_memory_protect.size = SIZE_COMMON;
+	vdi->vpu_common_memory_protect.req_spec_region = VE_SECURE_PROTECTION;
+	if (Internal_vdi_allocate_dma_memory(
+		    core_idx, &vdi->vpu_common_memory_protect, filp) < 0) {
+		VLOG(ERR,
+		     "[VDI] fail to Internal_vdi_allocate_dma_memory size=%d\n",
+		     SIZE_COMMON);
+		return -1;
+	}
+
+	VLOG(TRACE,
+	     "[VDI] allocate_common_memory_protect physaddr=0x%lx, size=%d, virtaddr=0x%lx\n",
+	     (int)vdi->vpu_common_memory_protect.phys_addr,
+	     (int)vdi->vpu_common_memory_protect.size,
+	     (int)vdi->vpu_common_memory_protect.virt_addr);
+
+	return 0;
+}
+
+int vdi_get_common_memory_protect(unsigned long core_idx, vpu_buffer_t *vb,
+				  void *filp)
+{
+	int ret = -1;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return ret;
+	ret = Internal_vdi_get_common_memory_protect(core_idx, vb, filp);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static int Internal_vdi_get_common_memory_protect(unsigned long core_idx,
+						  vpu_buffer_t *vb, void *filp)
+{
+	vdi_info_t *vdi;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return -1;
+
+	if (vdi->vpu_common_memory_protect.size == 0)
+		allocate_common_memory_protect(core_idx, filp);
+
+	osal_memcpy(vb, &vdi->vpu_common_memory_protect, sizeof(vpu_buffer_t));
+
+	return 0;
+}
+
+vpu_instance_pool_t *vdi_get_instance_pool(unsigned long core_idx)
+{
+	vpu_instance_pool_t *ret = NULL;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return ret;
+	ret = Internal_vdi_get_instance_pool(core_idx);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static vpu_instance_pool_t *
+Internal_vdi_get_instance_pool(unsigned long core_idx)
+{
+	vdi_info_t *vdi;
+	vpudrv_buffer_t vdb;
+	int instance_pool_size_per_core;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return NULL;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return NULL;
+
+	osal_memset(&vdb, 0x00, sizeof(vpudrv_buffer_t));
+	if (!vdi->pvip) {
+		vdb.size =
+			sizeof(vpu_instance_pool_t) +
+			sizeof(USERSPACE_MUTEX_HANDLE) * VDI_NUM_LOCK_HANDLES;
+		vdb.size += sizeof(int) + sizeof(vpu_sram_info);
+		vdb.size += sizeof(int) * 3;
+		VLOG(TRACE, "[%d]size:%d(%d+%d*%d+%d*4+%d)\n", __LINE__,
+		     vdb.size, sizeof(vpu_instance_pool_t),
+		     sizeof(USERSPACE_MUTEX_HANDLE), VDI_NUM_LOCK_HANDLES,
+		     sizeof(int), sizeof(vpu_sram_info));
+		vdb.size = (vdb.size + 0xfff) & ~0xfff; /* align 4096 */
+		VLOG(TRACE, "[%d]size:%d\n", __LINE__, vdb.size);
+
+		if (vdi->drv_ops->get_instance_pool(&vdb) < 0) {
+			VLOG(ERR,
+			     "[%d][VDI] fail to allocate get instance pool physical space=%d\n",
+			     __LINE__, (int)vdb.size);
+			return NULL;
+		}
+		VLOG(TRACE, "[%d]vdb(0x%lx,0x%lx,%d)\n", __LINE__,
+		     vdb.virt_addr, vdb.phys_addr, vdb.size);
+
+		instance_pool_size_per_core = vdb.size / MAX_NUM_VPU_CORE;
+
+		vdi->pvip =
+			(vpu_instance_pool_t
+				 *)(vdb.virt_addr +
+				    (core_idx *
+				     (instance_pool_size_per_core /*sizeof(vpu_instance_pool_t) + sizeof(MUTEX_HANDLE)*VDI_NUM_LOCK_HANDLES*/)));
+		VLOG(TRACE, "[%d]%s.vdi->pvip:0x%px\n", __LINE__, __func__,
+		     vdi->pvip);
+
+		vdi->vpu_mutex = &vpu_mutex;
+		vdi->vpu_disp_mutex = &vpu_disp_mutex;
+		{
+			int *sram_mutex_init;
+			int *thumb_mutex_init;
+			void *sram_info;
+			vpu_instance_pool_t *first_pvip =
+				(vpu_instance_pool_t *)vdb.virt_addr;
+			vdi->vpu_sram_mutex = &vpu_sram_mutex;
+			sram_mutex_init =
+				(int *)((unsigned long)first_pvip +
+					(instance_pool_size_per_core -
+					 sizeof(USERSPACE_MUTEX_HANDLE) *
+						 VDI_NUM_LOCK_HANDLES -
+					 sizeof(int)));
+			sram_info = (void *)((unsigned long)sram_mutex_init -
+					     sizeof(vpu_sram_info));
+
+			if (vdi->sram_dev == NULL) {
+				vdi->sram_dev = sram_device_create(
+					sram_info, vdi->vpu_sram_mutex,
+					sram_mutex_init, first_pvip,
+					instance_pool_size_per_core);
+			}
+
+			vdi->vpu_thumb_mutex = &vpu_thumb_mutex;
+			vdi->thumb_used =
+				(int *)((unsigned long)sram_info - sizeof(int));
+			vdi->thumb_num =
+				(int *)((unsigned long)vdi->thumb_used -
+					sizeof(int));
+			thumb_mutex_init =
+				(int *)((unsigned long)vdi->thumb_num -
+					sizeof(int));
+			vdi_init_thumb_info(vdi, thumb_mutex_init, first_pvip,
+					    instance_pool_size_per_core);
+		}
+
+		VLOG(TRACE,
+		     "[%d][VDI] instance pool physaddr=0x%lx, virtaddr=0x%lx, base=0x%lx, size=%ld\n",
+		     __LINE__, (int)vdb.phys_addr, (int)vdb.virt_addr,
+		     (int)vdb.base, (int)vdb.size);
+
+		//RTK
+		vdi->vdb_pvip.size = vdb.size;
+		vdi->vdb_pvip.virt_addr = vdb.virt_addr;
+	}
+
+	return (vpu_instance_pool_t *)vdi->pvip;
+}
+
+int vdi_open_instance(unsigned long core_idx, unsigned long inst_idx,
+		      void *filp)
+{
+	int ret = -1;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return ret;
+	ret = Internal_vdi_open_instance(core_idx, inst_idx, filp);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static int Internal_vdi_open_instance(unsigned long core_idx,
+				      unsigned long inst_idx, void *filp)
+{
+	vdi_info_t *vdi;
+	vpudrv_inst_info_t inst_info;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return -1;
+
+	inst_info.core_idx = core_idx;
+	inst_info.inst_idx = inst_idx;
+
+	if (vdi->drv_ops->open_instance(filp, &inst_info) < 0) {
+		VLOG(ERR,
+		     "[%d][VDI] fail to deliver open instance num inst_idx=%d\n",
+		     __LINE__, (int)inst_idx);
+		return -1;
+	}
+
+	vdi->pvip->vpu_instance_num = inst_info.inst_open_count;
+
+	return 0;
+}
+
+int vdi_close_instance(unsigned long core_idx, unsigned long inst_idx)
+{
+	int ret = -1;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return ret;
+	ret = Internal_vdi_close_instance(core_idx, inst_idx);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static int Internal_vdi_close_instance(unsigned long core_idx,
+				       unsigned long inst_idx)
+{
+	vdi_info_t *vdi;
+	vpudrv_inst_info_t inst_info;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return -1;
+
+	inst_info.core_idx = core_idx;
+	inst_info.inst_idx = inst_idx;
+
+	if (vdi->drv_ops->close_instance(&inst_info) < 0) {
+		VLOG(ERR,
+		     "[%d][VDI] fail to deliver open instance num inst_idx=%d\n",
+		     __LINE__, (int)inst_idx);
+		return -1;
+	}
+
+	vdi->pvip->vpu_instance_num = inst_info.inst_open_count;
+
+	return 0;
+}
+
+int vdi_get_instance_num(unsigned long core_idx)
+{
+	int ret = -1;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return ret;
+	ret = Internal_vdi_get_instance_num(core_idx);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static int Internal_vdi_get_instance_num(unsigned long core_idx)
+{
+	vdi_info_t *vdi;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return -1;
+
+	return vdi->pvip->vpu_instance_num;
+}
+
+int vdi_hw_reset(unsigned long core_idx) // DEVICE_ADDR_SW_RESET
+{
+	int ret = -1;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return ret;
+	ret = Internal_vdi_hw_reset(core_idx);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static int Internal_vdi_hw_reset(unsigned long core_idx)
+{
+	vdi_info_t *vdi;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return -1;
+
+	return 0;
+}
+
+int vdi_check_protect(unsigned long core_idx)
+{
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	unsigned int value = 0x0;
+	if (vdi == NULL)
+		return 0;
+
+	if (core_idx == 1) {
+	} else if (core_idx == 0) // CODA9XX
+	{
+		if ((Internal_vdi_read_register(core_idx, VE1_CTRL) & 0x2) !=
+		    0) // if BIT processor is not running.
+		{
+			value = Internal_vdi_read_register(core_idx,
+							   VE1_PROT_CTRL);
+		} else {
+			VLOG(ERR, "VE1 CTI didn't enable\n");
+			goto ERR_VDI_GET_PROT;
+		}
+	} else {
+		VLOG(ERR, "Unknown core_idx : %08x\n", core_idx);
+		goto ERR_VDI_GET_PROT;
+	}
+
+	unlock_vdi_info(vdi, core_idx);
+	return (value == 0x5 ? 1 : 0);
+
+ERR_VDI_GET_PROT:
+	VLOG(ERR, "Got VE prot mode failed!!!");
+	unlock_vdi_info(vdi, core_idx);
+	return 0;
+}
+
+void vdi_check_hwreset(unsigned long core_idx)
+{
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return;
+	Internal_vdi_check_hwreset(core_idx);
+	unlock_vdi_info(vdi, core_idx);
+	return;
+}
+
+static void Internal_vdi_check_hwreset(unsigned long core_idx)
+{
+	vdi_info_t *vdi;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return;
+
+	Internal_vdi_lock(core_idx);
+
+	if (vdi->pvip->vpu_instance_num == 0) {
+		usleep_range(1000, 1000);
+	}
+
+	Internal_vdi_unlock(core_idx);
+}
+
+static int restore_mutex_in_dead(MUTEX_HANDLE *mutex)
+{
+	int mutex_value;
+	int *mutex_tmp = NULL;
+
+	if (!mutex)
+		return 0;
+	mutex_tmp = (int *)mutex;
+	mutex_value = (int)mutex_tmp[0];
+	if (mutex_value == (int)0xdead10cc) // destroy by device driver
+	{
+		mutex_init(mutex);
+		return 0;
+	}
+
+	return 1;
+}
+
+int vdi_lock(unsigned long core_idx)
+{
+	int ret = -1;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return ret;
+	ret = Internal_vdi_lock(core_idx);
+	if (ret == 0) {
+		//VLOG(INFO, "[%d]%s.mutex_lock(vdi->ve1_hw_mutex)\n",
+		//	__LINE__, __func__);
+		mutex_lock(vdi->ve1_hw_mutex);
+	}
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static int Internal_vdi_lock(unsigned long core_idx)
+{
+	vdi_info_t *vdi;
+	const int MUTEX_TIMEOUT = 0x7fffffff;
+#if defined(ANDROID) || !defined(PTHREAD_MUTEX_ROBUST_NP)
+	int _ret = 0, j;
+#endif
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return -1;
+#if defined(ANDROID) ||                                                        \
+	!defined(PTHREAD_MUTEX_ROBUST_NP) //[r] need to be modify
+	for (j = 0;
+	     (_ret = vdi_pthread_mutex_trylock(
+		      core_idx, 1000, (MUTEX_HANDLE *)vdi->vpu_mutex)) != 0 &&
+	     j < MUTEX_TIMEOUT;
+	     j++) {
+		if (restore_mutex_in_dead((MUTEX_HANDLE *)vdi->vpu_mutex) ==
+		    0) //Got 0xdead10cc
+		{
+			if (core_idx != 1) {
+				if (Internal_vdi_read_register(
+					    core_idx, BIT_BUSY_FLAG) == 1) {
+					Internal_vdi_write_register(
+						core_idx, BIT_BIT_STREAM_PARAM,
+						(1 << 2));
+					Internal_vdi_write_register(
+						core_idx, BIT_INT_REASON, 0);
+					Internal_vdi_write_register(
+						core_idx, BIT_INT_CLEAR, 1);
+				}
+			}
+		}
+	}
+
+	if (_ret == 0)
+		return 0;
+#else
+	while (1) {
+		int _ret, i;
+		for (i = 0; (_ret = vdi_pthread_mutex_trylock(
+				     core_idx, 1000,
+				     (MUTEX_HANDLE *)vdi->vpu_mutex)) != 0 &&
+			    i < MUTEX_TIMEOUT;
+		     i++) {
+			if (i == 0)
+				VLOG(ERR,
+				     "vdi_lock: mutex is already locked - try again\n");
+
+			if (i == 1000) // check whether vpu is really busy
+			{
+				if (Internal_vdi_read_register(
+					    core_idx, BIT_BUSY_FLAG) == 0)
+					break;
+			}
+
+			if (i > VPU_BUSY_CHECK_TIMEOUT) {
+				if (Internal_vdi_read_register(
+					    core_idx, BIT_BUSY_FLAG) == 1) {
+					Internal_vdi_write_register(
+						core_idx, BIT_BIT_STREAM_PARAM,
+						(1 << 2));
+					Internal_vdi_write_register(
+						core_idx, BIT_INT_REASON, 0);
+					Internal_vdi_write_register(
+						core_idx, BIT_INT_CLEAR, 1);
+				}
+				break;
+			}
+		}
+
+		if (_ret == 0)
+			break;
+
+		VLOG(ERR,
+		     "vdi_lock: can't get lock - force to unlock and clear pendingInst[%d:%s]\n",
+		     _ret, strerror(_ret));
+		if (_ret == EINVAL) {
+			Uint32 *pInt = (Uint32 *)vdi->vpu_mutex;
+			*pInt = 0xdead10cc;
+			restore_mutex_in_dead((MUTEX_HANDLE *)vdi->vpu_mutex);
+		}
+		Internal_vdi_unlock(core_idx);
+		vdi->pvip->pendingInst = NULL;
+		vdi->pvip->pendingInstIdxPlus1 = 0;
+	}
+#endif
+
+	return 0;
+}
+
+int vdi_lock_check(unsigned long core_idx)
+{
+	vdi_info_t *vdi;
+	int ret;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = lock_vdi_info(core_idx);
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00) {
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	ret = vdi_pthread_mutex_trylock(core_idx, 0,
+					(MUTEX_HANDLE *)vdi->vpu_mutex);
+	if (ret == 0) {
+		Internal_vdi_unlock(core_idx);
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	} else {
+		unlock_vdi_info(vdi, core_idx);
+		return 0;
+	}
+}
+
+void vdi_unlock(unsigned long core_idx)
+{
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return;
+	//VLOG(INFO, "%d.%s.mutex_unlock(vdi->ve1_hw_mutex)\n",
+	//	__LINE__, __func__);
+	mutex_unlock(vdi->ve1_hw_mutex);
+	Internal_vdi_unlock(core_idx);
+	unlock_vdi_info(vdi, core_idx);
+	return;
+}
+
+static void Internal_vdi_unlock(unsigned long core_idx)
+{
+	vdi_info_t *vdi;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return;
+
+	mutex_unlock(vdi->vpu_mutex);
+}
+
+int vdi_disp_lock(unsigned long core_idx)
+{
+	vdi_info_t *vdi;
+	const int MUTEX_TIMEOUT = 5000; // ms
+#if defined(ANDROID) || !defined(PTHREAD_MUTEX_ROBUST_NP)
+	int _ret = 0, j;
+#endif
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = lock_vdi_info(core_idx);
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00) {
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+#if defined(ANDROID) ||                                                        \
+	!defined(PTHREAD_MUTEX_ROBUST_NP) //[r] need to be modify
+	for (j = 0; (_ret = vdi_pthread_mutex_trylock(
+			     core_idx, 1000,
+			     (MUTEX_HANDLE *)vdi->vpu_disp_mutex)) != 0 &&
+		    j < MUTEX_TIMEOUT;
+	     j++) {
+		if (restore_mutex_in_dead(
+			    (MUTEX_HANDLE *)vdi->vpu_disp_mutex) ==
+		    0) //Got 0xdead10cc
+		{
+			if (core_idx != 1) {
+				if (Internal_vdi_read_register(
+					    core_idx, BIT_BUSY_FLAG) == 1) {
+					Internal_vdi_write_register(
+						core_idx, BIT_BIT_STREAM_PARAM,
+						(1 << 2));
+					Internal_vdi_write_register(
+						core_idx, BIT_INT_REASON, 0);
+					Internal_vdi_write_register(
+						core_idx, BIT_INT_CLEAR, 1);
+				}
+			}
+		}
+	}
+
+	if (_ret == 0) {
+		unlock_vdi_info(vdi, core_idx);
+		return 0;
+	}
+#else
+	while (1) {
+		int _ret, i;
+		for (i = 0;
+		     (_ret = vdi_pthread_mutex_trylock(
+			      core_idx, 1000,
+			      (MUTEX_HANDLE *)vdi->vpu_disp_mutex)) != 0 &&
+		     i < MUTEX_TIMEOUT;
+		     i++) {
+			if (i == 0)
+				VLOG(ERR,
+				     "vdi_disp_lock: mutex is already locked - try again\n");
+		}
+
+		if (_ret == 0)
+			break;
+
+		if (_ret == EINVAL) {
+			Uint32 *pInt = (Uint32 *)vdi->vpu_disp_mutex;
+			*pInt = 0xdead10cc;
+			restore_mutex_in_dead(
+				(MUTEX_HANDLE *)vdi->vpu_disp_mutex);
+		}
+
+		VLOG(ERR,
+		     "vdi_disp_lock: can't get lock - force to unlock. [%d:%s]\n",
+		     _ret, strerror(_ret));
+		Internal_vdi_disp_unlock(core_idx);
+	}
+#endif /* ANDROID */
+
+	unlock_vdi_info(vdi, core_idx);
+	return 0;
+}
+
+void vdi_disp_unlock(unsigned long core_idx)
+{
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return;
+	Internal_vdi_disp_unlock(core_idx);
+	unlock_vdi_info(vdi, core_idx);
+	return;
+}
+
+static void Internal_vdi_disp_unlock(unsigned long core_idx)
+{
+	vdi_info_t *vdi;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return;
+
+	mutex_unlock(vdi->vpu_disp_mutex);
+}
+
+void vdi_write_register(unsigned long core_idx, unsigned int addr,
+			unsigned int data)
+{
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return;
+	Internal_vdi_write_register(core_idx, addr, data);
+	unlock_vdi_info(vdi, core_idx);
+	return;
+}
+
+static void Internal_vdi_write_register(unsigned long core_idx,
+					unsigned int addr, unsigned int data)
+{
+	vdi_info_t *vdi;
+	unsigned long *reg_addr;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return;
+
+	reg_addr =
+		(unsigned long *)(addr +
+				  (unsigned long)vdi->vdb_register.virt_addr);
+
+	*(volatile unsigned int *)reg_addr = data;
+	//VLOG(INFO, "%d.%s.w_register.0x%X = 0x%x\n",
+	//	__LINE__, __func__,
+	//	addr, data);
+}
+
+unsigned int vdi_read_register(unsigned long core_idx, unsigned int addr)
+{
+	unsigned int ret = -1U;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return ret;
+	ret = Internal_vdi_read_register(core_idx, addr);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static unsigned int Internal_vdi_read_register(unsigned long core_idx,
+					       unsigned int addr)
+{
+	vdi_info_t *vdi;
+	unsigned long *reg_addr;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return (unsigned int)-1;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return (unsigned int)-1;
+
+	reg_addr =
+		(unsigned long *)(addr +
+				  (unsigned long)vdi->vdb_register.virt_addr);
+
+	//VLOG(INFO, "%d.%s.r_register.0x%X = 0x%x\n",
+	//	__LINE__, __func__,
+	//	addr, *(volatile unsigned int *)reg_addr);
+	return *(volatile unsigned int *)reg_addr;
+}
+
+#define FIO_TIMEOUT 100
+
+#define VCORE_DBG_ADDR(__vCoreIdx) 0x8000 + (0x1000 * __vCoreIdx) + 0x300
+#define VCORE_DBG_DATA(__vCoreIdx) 0x8000 + (0x1000 * __vCoreIdx) + 0x304
+#define VCORE_DBG_READY(__vCoreIdx) 0x8000 + (0x1000 * __vCoreIdx) + 0x308
+
+int vdi_clear_memory(unsigned long core_idx, unsigned int addr, int len,
+		     int endian)
+{
+	vdi_info_t *vdi;
+	vpudrv_buffer_t vdb;
+	unsigned long offset;
+
+	int i;
+	Uint8 *zero;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = lock_vdi_info(core_idx);
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00) {
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	osal_memset(&vdb, 0x00, sizeof(vpudrv_buffer_t));
+
+	for (i = 0; i < MAX_VPU_BUFFER_POOL; i++) {
+		if (vdi->vpu_buffer_pool[i].inuse == 1) {
+			vdb = vdi->vpu_buffer_pool[i].vdb;
+			if (addr >= vdb.phys_addr &&
+			    addr < (vdb.phys_addr + vdb.size))
+				break;
+		}
+	}
+
+	if (!vdb.size) {
+		VLOG(ERR, "address 0x%08x is not mapped address!!!\n",
+		     (int)addr);
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	zero = (Uint8 *)osal_malloc(len);
+	osal_memset((void *)zero, 0x00, len);
+
+	offset = addr - (unsigned long)vdb.phys_addr;
+	osal_memcpy((void *)((unsigned long)vdb.virt_addr + offset), zero, len);
+
+	osal_free(zero);
+
+	unlock_vdi_info(vdi, core_idx);
+	return len;
+}
+
+void vdi_set_sdram(unsigned long coreIdx, unsigned int addr, int len,
+		   unsigned char data, int endian)
+{
+	vdi_info_t *vdi = lock_vdi_info(coreIdx);
+	unsigned char *buf;
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00) {
+		unlock_vdi_info(vdi, coreIdx);
+		return;
+	}
+
+	buf = (unsigned char *)osal_malloc(len);
+	memset(buf, 0x00, len);
+	Internal_vdi_write_memory(coreIdx, addr, buf, len, endian);
+	osal_free(buf);
+	unlock_vdi_info(vdi, coreIdx);
+}
+
+void *vdi_get_virt_addr(unsigned long core_idx, unsigned int addr)
+{
+    vdi_info_t *vdi;
+    vpudrv_buffer_t vdb;
+    unsigned long offset;
+    int i;
+    void *result = NULL;
+
+    if (core_idx >= MAX_NUM_VPU_CORE)
+        return NULL;
+
+    vdi = lock_vdi_info(core_idx);
+
+    if(!vdi || vdi->vpu_fd==-1 || vdi->vpu_fd == 0x00)
+    {
+        unlock_vdi_info(vdi, core_idx);
+        return NULL;
+    }
+
+    osal_memset(&vdb, 0x00, sizeof(vpudrv_buffer_t));
+
+    for (i=0; i<MAX_VPU_BUFFER_POOL; i++)
+    {
+        if (vdi->vpu_buffer_pool[i].inuse == 1)
+        {
+            vdb = vdi->vpu_buffer_pool[i].vdb;
+            if (addr >= vdb.phys_addr && addr < (vdb.phys_addr + vdb.size)) {
+                break;
+            }
+        }
+    }
+
+    if (!vdb.size) {
+        VLOG(ERR, "address 0x%08x is not mapped address!!!\n", (int)addr);
+        unlock_vdi_info(vdi, core_idx);
+        return NULL;
+    }
+
+    offset = addr - (unsigned long)vdb.phys_addr;
+    result = (void *)(vdb.virt_addr + offset);
+
+    unlock_vdi_info(vdi, core_idx);
+    return result;
+}
+
+int vdi_write_memory(unsigned long core_idx, unsigned int addr,
+		     unsigned char *data, int len, int endian)
+{
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return -1;
+	len = Internal_vdi_write_memory(core_idx, addr, data, len, endian);
+	unlock_vdi_info(vdi, core_idx);
+	return len;
+}
+
+static int Internal_vdi_write_memory(unsigned long core_idx, unsigned int addr,
+				     unsigned char *data, int len, int endian)
+{
+	vdi_info_t *vdi;
+	vpudrv_buffer_t vdb;
+	unsigned long offset;
+	int i;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00) {
+		return -1;
+	}
+
+	osal_memset(&vdb, 0x00, sizeof(vpudrv_buffer_t));
+
+	for (i = 0; i < MAX_VPU_BUFFER_POOL; i++) {
+		if (vdi->vpu_buffer_pool[i].inuse == 1) {
+			vdb = vdi->vpu_buffer_pool[i].vdb;
+			if (addr >= vdb.phys_addr &&
+			    addr < (vdb.phys_addr + vdb.size)) {
+				break;
+			}
+		}
+	}
+
+	if (!vdb.size) {
+		VLOG(ERR, "address 0x%08x is not mapped address!!!\n",
+		     (int)addr);
+		return -1;
+	}
+
+	offset = addr - (unsigned long)vdb.phys_addr;
+	Internal_swap_endian(core_idx, data, len, endian);
+	osal_memcpy((void *)((unsigned long)vdb.virt_addr + offset), data, len);
+
+	return len;
+}
+
+int vdi_read_memory(unsigned long core_idx, unsigned int addr,
+		    unsigned char *data, int len, int endian)
+{
+	vdi_info_t *vdi;
+	vpudrv_buffer_t vdb;
+	unsigned long offset;
+	int i;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = lock_vdi_info(core_idx);
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00) {
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	osal_memset(&vdb, 0x00, sizeof(vpudrv_buffer_t));
+
+	for (i = 0; i < MAX_VPU_BUFFER_POOL; i++) {
+		if (vdi->vpu_buffer_pool[i].inuse == 1) {
+			vdb = vdi->vpu_buffer_pool[i].vdb;
+			if (addr >= vdb.phys_addr &&
+			    addr < (vdb.phys_addr + vdb.size)) {
+				break;
+			}
+		}
+	}
+
+	if (i >= MAX_VPU_BUFFER_POOL || !vdb.size) {
+		VLOG(ERR,
+		     "[VDI] vdi_read_memory fail!! reach the MAX_VPU_BUFFER_POOL or size is 0\n");
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	offset = addr - (unsigned long)vdb.phys_addr;
+	osal_memcpy(data, (const void *)((unsigned long)vdb.virt_addr + offset),
+		    len);
+	Internal_swap_endian(core_idx, data, len, endian);
+
+	unlock_vdi_info(vdi, core_idx);
+	return len;
+}
+
+int vdi_write_memory_va(unsigned long core_idx, unsigned char *addr,
+			unsigned char *data, int len, int endian)
+{
+	vdi_info_t *vdi = NULL;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = lock_vdi_info(core_idx);
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00) {
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	Internal_swap_endian(core_idx, data, len, endian);
+	osal_memcpy((void *)(addr), data, len);
+
+	unlock_vdi_info(vdi, core_idx);
+	return len;
+}
+
+int vdi_allocate_dma_memory(unsigned long core_idx, vpu_buffer_t *vb,
+			    void *filp)
+{
+	int ret = -1;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL || vb == NULL || filp == NULL) {
+		VLOG(ERR,
+		     "[%d]%s.parameters NULL.vdi:0x%px.vb:0x%px.filp:0x%px\n",
+		     __LINE__, __func__, vdi, vb, filp);
+		return ret;
+	}
+	ret = Internal_vdi_allocate_dma_memory(core_idx, vb, filp);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static int Internal_vdi_allocate_dma_memory(unsigned long core_idx,
+					    vpu_buffer_t *vb, void *filp)
+{
+	vdi_info_t *vdi;
+	int i;
+	vpudrv_buffer_t vdb;
+	int ret = -1;
+	int retry = 10;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00 || !filp) {
+		VLOG(ERR,
+		     "[%d]%s.parameters NULL.vdi:0x%px.vpu_fd:%d.filp:0x%px\n",
+		     __LINE__, __func__, vdi, vdi->vpu_fd, filp);
+		return -1;
+	}
+
+	osal_memset(&vdb, 0x00, sizeof(vpudrv_buffer_t));
+
+	vdb.size = vb->size;
+
+	if (vb->req_spec_region != 0) //ENABLE_TEE_DRM_FLOW
+	{
+		vdb.mem_type = vb->req_spec_region;
+	}
+
+	//RTK
+	while (1) {
+		ret = vdi->drv_ops->allocate_physical_memory(filp, &vdb);
+		if (ret >= 0)
+			break;
+		else {
+			if (retry > 0) {
+				retry--;
+				VLOG(WARN,
+				     "[%d][VDI] fail to allocate_physical_memory size=%d, wait 50ms and retry count=%d\n",
+				     __LINE__, vb->size, retry);
+				msleep(50);
+			} else {
+				VLOG(ERR,
+				     "[%d][VDI] fail to allocate_physical_memory size=%d\n",
+				     __LINE__, vb->size);
+				return -1;
+			}
+		}
+	}
+
+	vb->phys_addr = (unsigned long)vdb.phys_addr;
+	vb->base = (unsigned long)vdb.base;
+	vb->virt_addr = vdb.virt_addr;
+
+	for (i = 0; i < MAX_VPU_BUFFER_POOL; i++) {
+		if (vdi->vpu_buffer_pool[i].inuse == 0) {
+			vdi->vpu_buffer_pool[i].vdb = vdb;
+			vdi->vpu_buffer_pool_count++;
+			vdi->vpu_buffer_pool[i].inuse = 1;
+			break;
+		}
+	}
+
+	if (i >= MAX_VPU_BUFFER_POOL) {
+		VLOG(ERR,
+		     "[VDI] vdi_allocate_dma_memory fail!! reach the MAX_VPU_BUFFER_POOL, physaddr=%p, virtaddr=%p~%p, size=%d,, index=%d\n",
+		     vb->phys_addr, vb->virt_addr, vb->virt_addr + vb->size,
+		     vb->size, i);
+		return -1;
+	}
+
+	VLOG(TRACE,
+	     "[%d][VDI] Internal_vdi_allocate_dma_memory, physaddr=0x%lx, virtaddr=0x%lx~0x%lx, size=%d,, index=%d\n",
+	     __LINE__, vb->phys_addr, vb->virt_addr, vb->virt_addr + vb->size,
+	     vb->size, i);
+	return 0;
+}
+
+int vdi_allocate_dma_memory_no_mmap(unsigned long core_idx, vpu_buffer_t *vb,
+				    void *filp)
+{
+	int ret = -1;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL || vb == NULL || filp == NULL) {
+		VLOG(ERR,
+		     "[%d]%s.parameters NULL.vdi:0x%px.vb:0x%px.filp:0x%px\n",
+		     __LINE__, __func__, vdi, vb, filp);
+		return ret;
+	}
+	ret = Internal_vdi_allocate_dma_memory_no_mmap(core_idx, vb, filp);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static int Internal_vdi_allocate_dma_memory_no_mmap(unsigned long core_idx,
+						    vpu_buffer_t *vb,
+						    void *filp)
+{
+	vdi_info_t *vdi;
+	int i;
+	vpudrv_buffer_t vdb;
+	int ret = -1;
+	int retry = 10;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00 || !filp) {
+		VLOG(ERR,
+		     "[%d]%s.parameters NULL.vdi:0x%px.vpu_fd:%d.filp:0x%px\n",
+		     __LINE__, __func__, vdi, vdi->vpu_fd, filp);
+		return -1;
+	}
+
+	osal_memset(&vdb, 0x00, sizeof(vpudrv_buffer_t));
+
+	vdb.size = vb->size;
+
+	if (vb->req_spec_region != 0) //ENABLE_TEE_DRM_FLOW
+	{
+		vdb.mem_type = vb->req_spec_region;
+	}
+
+	//RTK
+	while (1) {
+		ret = vdi->drv_ops->allocate_physical_memory_no_mmap(filp,
+									  &vdb);
+		if (ret >= 0)
+			break;
+		else {
+			if (retry > 0) {
+				retry--;
+				VLOG(WARN,
+				     "[%d][VDI] fail to allocate_physical_memory_no_mmap size=%d, wait 50ms and retry count=%d\n",
+				     __LINE__, vb->size, retry);
+				msleep(50);
+			} else {
+				VLOG(ERR,
+				     "[%d][VDI] fail to allocate_physical_memory_no_mmap size=%d\n",
+				     __LINE__, vb->size);
+				return -1;
+			}
+		}
+	}
+
+	vb->phys_addr = vdb.phys_addr;
+	vb->base = vdb.base;
+
+	for (i = 0; i < MAX_VPU_BUFFER_POOL; i++) {
+		if (vdi->vpu_buffer_pool[i].inuse == 0) {
+			vdi->vpu_buffer_pool[i].vdb = vdb;
+			vdi->vpu_buffer_pool_count++;
+			vdi->vpu_buffer_pool[i].inuse = 1;
+			break;
+		}
+	}
+
+	if (i >= MAX_VPU_BUFFER_POOL) {
+		VLOG(ERR,
+		     "[VDI] vdi_allocate_dma_memory_no_mmap fail!! reach the MAX_VPU_BUFFER_POOL, physaddr=%p, virtaddr=%p~%p, size=%d,, index=%d\n",
+		     vb->phys_addr, vb->virt_addr, vb->virt_addr + vb->size,
+		     vb->size, i);
+		return -1;
+	}
+
+	VLOG(TRACE,
+	     "[%d][VDI] Internal_vdi_allocate_dma_memory_no_mmap, physaddr=0x%lx, size=%d, index=%d\n",
+	     __LINE__, vb->phys_addr, vb->size, i);
+	return 0;
+}
+
+int vdi_attach_dma_memory(unsigned long core_idx, vpu_buffer_t *vb)
+{
+	vdi_info_t *vdi;
+	int i;
+	vpudrv_buffer_t vdb;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = lock_vdi_info(core_idx);
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00) {
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	osal_memset(&vdb, 0x00, sizeof(vpudrv_buffer_t));
+
+	vdb.size = vb->size;
+	vdb.phys_addr = vb->phys_addr;
+	vdb.base = vb->base;
+
+	vdb.virt_addr = vb->virt_addr;
+
+	for (i = 0; i < MAX_VPU_BUFFER_POOL; i++) {
+		if (vdi->vpu_buffer_pool[i].vdb.phys_addr == vb->phys_addr) {
+			vdi->vpu_buffer_pool[i].vdb = vdb;
+			vdi->vpu_buffer_pool[i].inuse = 1;
+			break;
+		} else {
+			if (vdi->vpu_buffer_pool[i].inuse == 0) {
+				vdi->vpu_buffer_pool[i].vdb = vdb;
+				vdi->vpu_buffer_pool_count++;
+				vdi->vpu_buffer_pool[i].inuse = 1;
+				break;
+			}
+		}
+	}
+
+	if (i >= MAX_VPU_BUFFER_POOL) {
+		VLOG(ERR,
+		     "[VDI] vdi_attach_dma_memory fail!! reach the MAX_VPU_BUFFER_POOL, physaddr=0x%lx, virtaddr=0x%lx, size=%d, index=%d\n",
+		     vb->phys_addr, vb->virt_addr, vb->size, i);
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	VLOG(TRACE,
+	     "[VDI] vdi_attach_dma_memory, physaddr=0x%lx, virtaddr=0x%lx, size=%d, index=%d\n",
+	     vb->phys_addr, vb->virt_addr, vb->size, i);
+
+	unlock_vdi_info(vdi, core_idx);
+	return 0;
+}
+
+int vdi_dettach_dma_memory(unsigned long core_idx, vpu_buffer_t *vb)
+{
+	vdi_info_t *vdi;
+	int i;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = lock_vdi_info(core_idx);
+
+	if (!vb || !vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00) {
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	if (vb->size == 0) {
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	for (i = 0; i < MAX_VPU_BUFFER_POOL; i++) {
+		if (vdi->vpu_buffer_pool[i].vdb.phys_addr == vb->phys_addr) {
+			vdi->vpu_buffer_pool[i].inuse = 0;
+			vdi->vpu_buffer_pool_count--;
+			break;
+		}
+	}
+
+	if (i >= MAX_VPU_BUFFER_POOL) {
+		VLOG(ERR,
+		     "[VDI] vdi_dettach_dma_memory fail!! reach the MAX_VPU_BUFFER_POOL, physaddr=0x%lx, virtaddr=0x%lx, size=%d, index=%d\n",
+		     vb->phys_addr, vb->virt_addr, vb->size, i);
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	VLOG(TRACE,
+	     "[VDI] vdi_dettach_dma_memory, physaddr=0x%lx, virtaddr=0x%lx, size=%d, index=%d\n",
+	     vb->phys_addr, vb->virt_addr, vb->size, i);
+
+	unlock_vdi_info(vdi, core_idx);
+	return 0;
+}
+
+void vdi_free_dma_memory(unsigned long core_idx, vpu_buffer_t *vb)
+{
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return;
+	Internal_vdi_free_dma_memory(core_idx, vb);
+	unlock_vdi_info(vdi, core_idx);
+	return;
+}
+
+static void Internal_vdi_free_dma_memory(unsigned long core_idx,
+					 vpu_buffer_t *vb)
+{
+	vdi_info_t *vdi;
+	int i;
+	vpudrv_buffer_t vdb;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vb || !vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return;
+
+	if (vb->size == 0)
+		return;
+
+	osal_memset(&vdb, 0x00, sizeof(vpudrv_buffer_t));
+
+	for (i = 0; i < MAX_VPU_BUFFER_POOL; i++) {
+		if (vdi->vpu_buffer_pool[i].vdb.phys_addr == vb->phys_addr) {
+			vdi->vpu_buffer_pool[i].inuse = 0;
+			vdi->vpu_buffer_pool_count--;
+			vdb = vdi->vpu_buffer_pool[i].vdb;
+			VLOG(TRACE,
+			     "[%d]%s.found target vdb.base:0x%lx.phys_addr:0x%lx.virt_addr:0x%lx.size:%d\n",
+			     __LINE__, __func__, vdb.base, vdb.phys_addr,
+			     vdb.virt_addr, vdb.size);
+			break;
+		}
+	}
+
+	if (i >= MAX_VPU_BUFFER_POOL || !vdb.size) {
+		VLOG(ERR,
+		     "[VDI] reach the MAX_VPU_BUFFER_POOL or invalid buffer to free address = 0x%lx\n",
+		     (int)vdb.virt_addr);
+		return;
+	}
+
+	vdi->drv_ops->free_physical_memory(&vdb);
+
+	VLOG(TRACE,
+	     "[%d][VDI] Internal_vdi_free_dma_memory, physaddr=0x%lx, virtaddr=0x%lx, size=%d, index=%d\n",
+	     __LINE__, vb->phys_addr, vb->virt_addr, vb->size, i);
+	osal_memset(vb, 0, sizeof(vpu_buffer_t));
+}
+
+void vdi_free_dma_memory_no_mmap(unsigned long core_idx, vpu_buffer_t *vb)
+{
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return;
+	Internal_vdi_free_dma_memory_no_mmap(core_idx, vb);
+	unlock_vdi_info(vdi, core_idx);
+	return;
+}
+
+static void Internal_vdi_free_dma_memory_no_mmap(unsigned long core_idx,
+						 vpu_buffer_t *vb)
+{
+	vdi_info_t *vdi;
+	int i;
+	vpudrv_buffer_t vdb;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vb || !vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return;
+
+	if (vb->size == 0)
+		return;
+
+	osal_memset(&vdb, 0x00, sizeof(vpudrv_buffer_t));
+
+	for (i = 0; i < MAX_VPU_BUFFER_POOL; i++) {
+		if (vdi->vpu_buffer_pool[i].vdb.phys_addr == vb->phys_addr) {
+			vdi->vpu_buffer_pool[i].inuse = 0;
+			vdi->vpu_buffer_pool_count--;
+			vdb = vdi->vpu_buffer_pool[i].vdb;
+			break;
+		}
+	}
+
+	if (i >= MAX_VPU_BUFFER_POOL || !vdb.size) {
+		VLOG(ERR,
+		     "[VDI] reach the MAX_VPU_BUFFER_POOL or invalid buffer to free address = 0x%lx\n",
+		     (int)vdb.virt_addr);
+		return;
+	}
+
+	vdi->drv_ops->free_physical_memory_no_mmap(&vdb);
+
+	VLOG(TRACE,
+	     "[%d][VDI] Internal_vdi_free_dma_memory_no_mmap, physaddr=0x%lx, virtaddr=0x%lx, size=%d, index=%d\n",
+	     __LINE__, vb->phys_addr, vb->virt_addr, vb->size, i);
+	osal_memset(vb, 0, sizeof(vpu_buffer_t));
+}
+
+int vdi_get_sram_memory(unsigned long core_idx, vpu_buffer_t *vb)
+{
+	vdi_info_t *vdi = NULL;
+	vpudrv_buffer_t vdb;
+	unsigned int sram_size = 0;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = lock_vdi_info(core_idx);
+
+	if (!vb || !vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00) {
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	osal_memset(&vdb, 0x00, sizeof(vpudrv_buffer_t));
+
+	switch (vdi->product_code) {
+	case BODA950_CODE:
+	case CODA960_CODE:
+	case CODA980_CODE:
+		sram_size = VDI_CODA9_SRAM_SIZE;
+		vb->phys_addr = VDI_SRAM_BASE_ADDR;
+		break;
+	default:
+		VLOG(ERR, "Check SRAM_SIZE(%d)\n", vdi->product_code);
+		break;
+	}
+
+	if (sram_size >
+	    0) // if we can know the sram address directly in vdi layer, we use it first for sdram address
+	{
+		vb->size = sram_size;
+		VLOG(TRACE, "[%s:%d] core_idx:%d.phys_addr:0x%x.size:%d.\n",
+		     __FUNCTION__, __LINE__, core_idx, vb->phys_addr, vb->size);
+
+		unlock_vdi_info(vdi, core_idx);
+		return 0;
+	}
+
+	unlock_vdi_info(vdi, core_idx);
+	return 0;
+}
+
+int vdi_set_clock_gate(unsigned long core_idx, int enable)
+{
+	int ret = -1;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return ret;
+	ret = Internal_vdi_set_clock_gate(core_idx, enable);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static int Internal_vdi_set_clock_gate(unsigned long core_idx, int enable)
+{
+	vdi_info_t *vdi = NULL;
+	int ret = 0;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+	vdi = &s_vdi_info[core_idx];
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00) {
+		return -1;
+	}
+	vdi->clock_state = enable;
+
+	return ret;
+}
+
+int vdi_get_clock_gate(unsigned long core_idx)
+{
+	vdi_info_t *vdi;
+	int ret;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = lock_vdi_info(core_idx);
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00) {
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	ret = vdi->clock_state;
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+int vdi_wait_bus_busy(unsigned long core_idx, int timeout,
+		      unsigned int gdi_busy_flag)
+{
+	struct timespec64 ts_base;
+	struct timespec64 ts;
+	struct timespec64 ts_delta;
+	vdi_info_t *vdi;
+
+	vdi = lock_vdi_info(core_idx);
+
+	ktime_get_ts64(&ts_base);
+
+	while (1) {
+		if (PRODUCT_CODE_NOT_W_SERIES(vdi->product_code)) {
+			if (Internal_vdi_read_register(core_idx,
+						       gdi_busy_flag) == 0x77)
+				break;
+		} else {
+			VLOG(ERR, "Unknown product id : %08x\n",
+			     vdi->product_code);
+			unlock_vdi_info(vdi, core_idx);
+			return -1;
+		}
+
+		if (timeout > 0) {
+			ktime_get_ts64(&ts);
+			ts_delta = timespec64_sub(ts, ts_base);
+
+			if ((timespec64_to_ns(&ts_delta) / 1000000) > timeout)
+			{
+				VLOG(ERR,
+				     "[VDI] vdi_wait_bus_busy timeout, PC=0x%lx\n",
+				     Internal_vdi_read_register(core_idx,
+								0x018));
+				unlock_vdi_info(vdi, core_idx);
+				return -1;
+			}
+		}
+	}
+	unlock_vdi_info(vdi, core_idx);
+	return 0;
+}
+
+int vdi_wait_vpu_busy(unsigned long core_idx, int timeout,
+		      unsigned int addr_bit_busy_flag)
+{
+	struct timespec64 ts_base;
+	struct timespec64 ts;
+	struct timespec64 ts_delta;
+	Uint32 pc;
+	Uint32 code, normalReg = TRUE;
+
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return -1;
+
+	ktime_get_ts64(&ts_base);
+
+	code = Internal_vdi_read_register(
+		core_idx, VPU_PRODUCT_CODE_REGISTER); /* read product code */
+
+	if (PRODUCT_CODE_NOT_W_SERIES(code)) {
+		pc = BIT_CUR_PC;
+	} else {
+		VLOG(ERR, "Unknown product id : %08x\n", code);
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	while (1) {
+		if (normalReg == TRUE) {
+			if (Internal_vdi_read_register(core_idx,
+						       addr_bit_busy_flag) == 0)
+				break;
+		}
+
+		if (timeout > 0) {
+			ktime_get_ts64(&ts);
+			ts_delta = timespec64_sub(ts, ts_base);
+
+			if ((timespec64_to_ns(&ts_delta) / 1000000) > timeout)
+			{
+				Uint32 index;
+				for (index = 0; index < 50; index++) {
+					VLOG(ERR,
+					     "[%d]%s [VDI] vdi_wait_vpu_busy timeout, PC=0x%lx\n",
+					     __LINE__, __func__,
+					     Internal_vdi_read_register(
+						     core_idx, pc));
+				}
+				unlock_vdi_info(vdi, core_idx);
+				return -1;
+			}
+		}
+#ifdef SUPPORT_SW_UART
+		usleep(1000);
+#endif
+	}
+
+    //check cmd traffic is empty
+    {
+        int nTimeoutCnt = 10;
+        unsigned int reg = 0;
+        unsigned int cmdReg = VE1_CMD_TRAFFIC;
+        do {
+            reg = Internal_vdi_read_register(core_idx, cmdReg);
+            if ((reg & 0x70000) == 0x70000)
+                break;
+            VLOG(INFO, "[VDI] reg 0x%x = 0x%x\n", cmdReg, reg);
+            usleep_range(1000, 1000);
+            nTimeoutCnt--;
+        } while(nTimeoutCnt > 0);
+    }
+
+	unlock_vdi_info(vdi, core_idx);
+	return 0;
+}
+
+int vdi_wait_interrupt(unsigned long coreIdx, int timeout,
+		       unsigned int addr_bit_int_reason)
+{
+	int intr_reason = 0;
+	int ret;
+	vdi_info_t *vdi;
+	vpudrv_intr_info_t intr_info;
+
+	if (coreIdx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = lock_vdi_info(coreIdx);
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00) {
+		unlock_vdi_info(vdi, coreIdx);
+		return -1;
+	}
+#ifdef SUPPORT_INTERRUPT
+	intr_info.core_idx = coreIdx;
+	intr_info.timeout = timeout;
+	intr_info.intr_reason = 0;
+
+	ret = vdi->drv_ops->wait_interrupt(&intr_info);
+	if (ret != 0) {
+		unlock_vdi_info(vdi, coreIdx);
+		return -1;
+	}
+	intr_reason = intr_info.intr_reason;
+#else
+	struct timeval tv = { 0 };
+	Uint32 intrStatusReg;
+	Uint32 pc;
+	Int32 startTime, endTime, elaspedTime;
+
+	UNREFERENCED_PARAMETER(intr_info);
+
+	if (PRODUCT_CODE_NOT_W_SERIES(vdi->product_code)) {
+		pc = BIT_CUR_PC;
+		intrStatusReg = BIT_INT_STS;
+	} else {
+		VLOG(ERR, "Unknown product id : %08x\n", vdi->product_code);
+		unlock_vdi_info(vdi, coreIdx);
+		return -1;
+	}
+
+	gettimeofday(&tv, NULL);
+	startTime = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+	while (TRUE) {
+		if (Internal_vdi_read_register(coreIdx, intrStatusReg)) {
+			if ((intr_reason = Internal_vdi_read_register(
+				     coreIdx, addr_bit_int_reason)))
+				break;
+		}
+		gettimeofday(&tv, NULL);
+		endTime = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+		if (timeout > 0 && (endTime - startTime) >= timeout) {
+			unlock_vdi_info(vdi, coreIdx);
+			return -1;
+		}
+	}
+#endif
+
+	unlock_vdi_info(vdi, coreIdx);
+	return intr_reason;
+}
+
+static int read_pinfo_buffer(int core_idx, int addr)
+{
+	int ack;
+	int rdata;
+#define VDI_LOG_GDI_PINFO_ADDR (0x1068)
+#define VDI_LOG_GDI_PINFO_REQ (0x1060)
+#define VDI_LOG_GDI_PINFO_ACK (0x1064)
+#define VDI_LOG_GDI_PINFO_DATA (0x106c)
+	//------------------------------------------
+	// read pinfo - indirect read
+	// 1. set read addr     (GDI_PINFO_ADDR)
+	// 2. send req          (GDI_PINFO_REQ)
+	// 3. wait until ack==1 (GDI_PINFO_ACK)
+	// 4. read data         (GDI_PINFO_DATA)
+	//------------------------------------------
+	Internal_vdi_write_register(core_idx, VDI_LOG_GDI_PINFO_ADDR, addr);
+	Internal_vdi_write_register(core_idx, VDI_LOG_GDI_PINFO_REQ, 1);
+
+	ack = 0;
+	while (ack == 0) {
+		ack = Internal_vdi_read_register(core_idx,
+						 VDI_LOG_GDI_PINFO_ACK);
+	}
+
+	rdata = Internal_vdi_read_register(core_idx, VDI_LOG_GDI_PINFO_DATA);
+
+	return rdata;
+}
+
+enum { VDI_PRODUCT_ID_980, VDI_PRODUCT_ID_960 };
+
+static void printf_gdi_info(int core_idx, int num, int reset)
+{
+	int i;
+	int bus_info_addr;
+	int tmp;
+	int val;
+	int productId = 0;
+
+	val = Internal_vdi_read_register(core_idx, VPU_PRODUCT_CODE_REGISTER);
+	if ((val & 0xff00) == 0x3200)
+		val = 0x3200;
+
+	if (PRODUCT_CODE_NOT_W_SERIES(val)) {
+		if (val == CODA960_CODE || val == BODA950_CODE)
+			productId = VDI_PRODUCT_ID_960;
+		else if (val == CODA980_CODE)
+			productId = VDI_PRODUCT_ID_980;
+	} else {
+		VLOG(ERR, "Unknown product id : %08x\n", val);
+		return;
+	}
+
+	if (productId == VDI_PRODUCT_ID_980)
+		VLOG(TRACE, "\n**GDI information for GDI_20\n");
+	else
+		VLOG(TRACE, "\n**GDI information for GDI_10\n");
+
+	for (i = 0; i < num; i++) {
+#define VDI_LOG_GDI_INFO_CONTROL 0x1400
+		if (productId == VDI_PRODUCT_ID_980)
+			bus_info_addr = VDI_LOG_GDI_INFO_CONTROL + i * (0x20);
+		else
+			bus_info_addr = VDI_LOG_GDI_INFO_CONTROL + i * 0x14;
+		if (reset) {
+			Internal_vdi_write_register(core_idx, bus_info_addr,
+						    0x00);
+			bus_info_addr += 4;
+			Internal_vdi_write_register(core_idx, bus_info_addr,
+						    0x00);
+			bus_info_addr += 4;
+			Internal_vdi_write_register(core_idx, bus_info_addr,
+						    0x00);
+			bus_info_addr += 4;
+			Internal_vdi_write_register(core_idx, bus_info_addr,
+						    0x00);
+			bus_info_addr += 4;
+			Internal_vdi_write_register(core_idx, bus_info_addr,
+						    0x00);
+
+			if (productId == VDI_PRODUCT_ID_980) {
+				bus_info_addr += 4;
+				Internal_vdi_write_register(
+					core_idx, bus_info_addr, 0x00);
+
+				bus_info_addr += 4;
+				Internal_vdi_write_register(
+					core_idx, bus_info_addr, 0x00);
+
+				bus_info_addr += 4;
+				Internal_vdi_write_register(
+					core_idx, bus_info_addr, 0x00);
+			}
+
+		} else {
+			VLOG(TRACE, "index = %02d", i);
+
+			tmp = read_pinfo_buffer(
+				core_idx,
+				bus_info_addr); //TiledEn<<20 ,GdiFormat<<17,IntlvCbCr,<<16 GdiYuvBufStride
+			VLOG(TRACE, " control = 0x%08x", tmp);
+
+			bus_info_addr += 4;
+			tmp = read_pinfo_buffer(core_idx, bus_info_addr);
+			VLOG(TRACE, " pic_size = 0x%08x", tmp);
+
+			bus_info_addr += 4;
+			tmp = read_pinfo_buffer(core_idx, bus_info_addr);
+			VLOG(TRACE, " y-top = 0x%08x", tmp);
+
+			bus_info_addr += 4;
+			tmp = read_pinfo_buffer(core_idx, bus_info_addr);
+			VLOG(TRACE, " cb-top = 0x%08x", tmp);
+
+			bus_info_addr += 4;
+			tmp = read_pinfo_buffer(core_idx, bus_info_addr);
+			VLOG(TRACE, " cr-top = 0x%08x", tmp);
+			if (productId == VDI_PRODUCT_ID_980) {
+				bus_info_addr += 4;
+				tmp = read_pinfo_buffer(core_idx,
+							bus_info_addr);
+				VLOG(TRACE, " y-bot = 0x%08x", tmp);
+
+				bus_info_addr += 4;
+				tmp = read_pinfo_buffer(core_idx,
+							bus_info_addr);
+				VLOG(TRACE, " cb-bot = 0x%08x", tmp);
+
+				bus_info_addr += 4;
+				tmp = read_pinfo_buffer(core_idx,
+							bus_info_addr);
+				VLOG(TRACE, " cr-bot = 0x%08x", tmp);
+			}
+			VLOG(TRACE, "\n");
+		}
+	}
+}
+
+static void vdi_make_log(unsigned long core_idx, const char *str, int step)
+{
+	int val = 0x0;
+	(void)core_idx;
+
+	val &= 0xffff;
+	if (step == 1)
+		VLOG(TRACE, "\n**%s start(%d)\n", str, val);
+	else if (step == 2) //
+		VLOG(TRACE, "\n**%s timeout(%d)\n", str, val);
+	else
+		VLOG(TRACE, "\n**%s end(%d)\n", str, val);
+}
+
+void vdi_log(unsigned long core_idx, int cmd, int step)
+{
+	vdi_info_t *vdi;
+	int i;
+
+	// BIT_RUN command
+	enum { SEQ_INIT = 1,
+	       SEQ_END = 2,
+	       PIC_RUN = 3,
+	       SET_FRAME_BUF = 4,
+	       ENCODE_HEADER = 5,
+	       ENC_PARA_SET = 6,
+	       DEC_PARA_SET = 7,
+	       DEC_BUF_FLUSH = 8,
+	       RC_CHANGE_PARAMETER = 9,
+	       VPU_SLEEP = 10,
+	       VPU_WAKE = 11,
+	       ENC_ROI_INIT = 12,
+	       FIRMWARE_GET = 0xf,
+	       VPU_RESET = 0x10,
+	};
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return;
+
+	vdi = lock_vdi_info(core_idx);
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0) {
+		unlock_vdi_info(vdi, core_idx);
+		return;
+	}
+
+	if (PRODUCT_CODE_NOT_W_SERIES(vdi->product_code)) {
+		switch (cmd) {
+		case SEQ_INIT:
+			vdi_make_log(core_idx, "SEQ_INIT", step);
+			break;
+		case SEQ_END:
+			vdi_make_log(core_idx, "SEQ_END", step);
+			break;
+		case PIC_RUN:
+			vdi_make_log(core_idx, "PIC_RUN", step);
+			break;
+		case SET_FRAME_BUF:
+			vdi_make_log(core_idx, "SET_FRAME_BUF", step);
+			break;
+		case ENCODE_HEADER:
+			vdi_make_log(core_idx, "ENCODE_HEADER", step);
+			break;
+		case RC_CHANGE_PARAMETER:
+			vdi_make_log(core_idx, "RC_CHANGE_PARAMETER", step);
+			break;
+		case DEC_BUF_FLUSH:
+			vdi_make_log(core_idx, "DEC_BUF_FLUSH", step);
+			break;
+		case FIRMWARE_GET:
+			vdi_make_log(core_idx, "FIRMWARE_GET", step);
+			break;
+		case VPU_RESET:
+			vdi_make_log(core_idx, "VPU_RESET", step);
+			break;
+		case ENC_PARA_SET:
+			vdi_make_log(core_idx, "ENC_PARA_SET", step);
+			break;
+		case DEC_PARA_SET:
+			vdi_make_log(core_idx, "DEC_PARA_SET", step);
+			break;
+		default:
+			vdi_make_log(core_idx, "ANY_CMD", step);
+			break;
+		}
+	} else {
+		VLOG(ERR, "Unknown product id : %08x\n", vdi->product_code);
+		unlock_vdi_info(vdi, core_idx);
+		return;
+	}
+
+	for (i = 0; i < 0x200; i = i + 16) {
+		if (i == 0x20) {
+			VLOG(TRACE,
+			     "0x%04xh: 0x%08x 0x%08x 0xDEADDEAD 0xDEADDEAD\n",
+			     i, Internal_vdi_read_register(core_idx, i),
+			     Internal_vdi_read_register(core_idx, i + 4));
+		} else if (i == 0x80) {
+			VLOG(TRACE,
+			     "0x%04xh: 0x%08x 0xDEADDEAD 0xDEADDEAD 0xDEADDEAD\n",
+			     i, Internal_vdi_read_register(core_idx, i));
+		} else if (i >= 0xc0 && i < 0x100) {
+			VLOG(TRACE,
+			     "0x%04xh: 0xDEADDEAD 0xDEADDEAD 0xDEADDEAD 0xDEADDEAD\n",
+			     i);
+		} else {
+			VLOG(TRACE, "0x%04xh: 0x%08x 0x%08x 0x%08x 0x%08x\n", i,
+			     Internal_vdi_read_register(core_idx, i),
+			     Internal_vdi_read_register(core_idx, i + 4),
+			     Internal_vdi_read_register(core_idx, i + 8),
+			     Internal_vdi_read_register(core_idx, i + 0xc));
+		}
+	}
+
+	if (PRODUCT_CODE_NOT_W_SERIES(vdi->product_code)) {
+		if (cmd == VPU_RESET) {
+			printf_gdi_info(core_idx, 32, 0);
+
+#define VDI_LOG_MBC_BUSY 0x0440
+#define VDI_LOG_MC_BASE 0x0C00
+#define VDI_LOG_MC_BUSY 0x0C04
+#define VDI_LOG_GDI_BUS_STATUS (0x10F4)
+#define VDI_LOG_ROT_SRC_IDX (0x400 + 0x10C)
+#define VDI_LOG_ROT_DST_IDX (0x400 + 0x110)
+
+			VLOG(TRACE, "MBC_BUSY = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							VDI_LOG_MBC_BUSY));
+			VLOG(TRACE, "MC_BUSY = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							VDI_LOG_MC_BUSY));
+			VLOG(TRACE, "MC_MB_XY_DONE=(y:%d, x:%d)\n",
+			     (Internal_vdi_read_register(core_idx,
+							 VDI_LOG_MC_BASE) >>
+			      20) & 0x3F,
+			     (Internal_vdi_read_register(core_idx,
+							 VDI_LOG_MC_BASE) >>
+			      26) & 0x3F);
+			VLOG(TRACE, "GDI_BUS_STATUS = %x\n",
+			     Internal_vdi_read_register(
+				     core_idx, VDI_LOG_GDI_BUS_STATUS));
+
+			VLOG(TRACE, "ROT_SRC_IDX = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							VDI_LOG_ROT_SRC_IDX));
+			VLOG(TRACE, "ROT_DST_IDX = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							VDI_LOG_ROT_DST_IDX));
+
+			VLOG(TRACE, "P_MC_PIC_INDEX_0 = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x200));
+			VLOG(TRACE, "P_MC_PIC_INDEX_1 = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x20c));
+			VLOG(TRACE, "P_MC_PIC_INDEX_2 = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x218));
+			VLOG(TRACE, "P_MC_PIC_INDEX_3 = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x230));
+			VLOG(TRACE, "P_MC_PIC_INDEX_3 = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x23C));
+			VLOG(TRACE, "P_MC_PIC_INDEX_4 = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x248));
+			VLOG(TRACE, "P_MC_PIC_INDEX_5 = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x254));
+			VLOG(TRACE, "P_MC_PIC_INDEX_6 = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x260));
+			VLOG(TRACE, "P_MC_PIC_INDEX_7 = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x26C));
+			VLOG(TRACE, "P_MC_PIC_INDEX_8 = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x278));
+			VLOG(TRACE, "P_MC_PIC_INDEX_9 = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x284));
+			VLOG(TRACE, "P_MC_PIC_INDEX_a = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x290));
+			VLOG(TRACE, "P_MC_PIC_INDEX_b = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x29C));
+			VLOG(TRACE, "P_MC_PIC_INDEX_c = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x2A8));
+			VLOG(TRACE, "P_MC_PIC_INDEX_d = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x2B4));
+
+			VLOG(TRACE, "P_MC_PICIDX_0 = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x028));
+			VLOG(TRACE, "P_MC_PICIDX_1 = %x\n",
+			     Internal_vdi_read_register(core_idx,
+							MC_BASE + 0x02C));
+		}
+	} else {
+		VLOG(ERR, "Unknown product id : %08x\n", vdi->product_code);
+		unlock_vdi_info(vdi, core_idx);
+		return;
+	}
+	unlock_vdi_info(vdi, core_idx);
+}
+
+static void byte_swap(unsigned char *data, int len)
+{
+	Uint8 temp;
+	Int32 i;
+
+	for (i = 0; i < len - 1; i += 2) {
+		temp = data[i];
+		data[i] = data[i + 1];
+		data[i + 1] = temp;
+	}
+}
+
+static void word_swap(unsigned char *data, int len)
+{
+	Uint16 temp;
+	Uint16 *ptr = (Uint16 *)data;
+	Int32 i, size = len / sizeof(Uint16);
+
+	for (i = 0; i < size - 1; i += 2) {
+		temp = ptr[i];
+		ptr[i] = ptr[i + 1];
+		ptr[i + 1] = temp;
+	}
+}
+
+static void dword_swap(unsigned char *data, int len)
+{
+	Uint32 temp;
+	Uint32 *ptr = (Uint32 *)data;
+	Int32 i, size = len / sizeof(Uint32);
+
+	for (i = 0; i < size - 1; i += 2) {
+		temp = ptr[i];
+		ptr[i] = ptr[i + 1];
+		ptr[i + 1] = temp;
+	}
+}
+
+static void lword_swap(unsigned char *data, int len)
+{
+	Uint64 temp;
+	Uint64 *ptr = (Uint64 *)data;
+	Int32 i, size = len / sizeof(Uint64);
+
+	for (i = 0; i < size - 1; i += 2) {
+		temp = ptr[i];
+		ptr[i] = ptr[i + 1];
+		ptr[i + 1] = temp;
+	}
+}
+
+int vdi_get_system_endian(unsigned long core_idx)
+{
+	vdi_info_t *vdi;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = lock_vdi_info(core_idx);
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00) {
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+
+	if (PRODUCT_CODE_NOT_W_SERIES(vdi->product_code)) {
+		unlock_vdi_info(vdi, core_idx);
+		return VDI_SYSTEM_ENDIAN;
+	} else {
+		VLOG(ERR, "Unknown product id : %08x\n", vdi->product_code);
+		unlock_vdi_info(vdi, core_idx);
+		return -1;
+	}
+}
+
+int vdi_convert_endian(unsigned long core_idx, unsigned int endian)
+{
+	int ret = -1;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return ret;
+	ret = Internal_vdi_convert_endian(core_idx, endian);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static int Internal_vdi_convert_endian(unsigned long core_idx,
+				       unsigned int endian)
+{
+	vdi_info_t *vdi;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || !vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return -1;
+
+	if (PRODUCT_CODE_NOT_W_SERIES(vdi->product_code)) {
+	} else {
+		VLOG(ERR, "Unknown product id : %08x\n", vdi->product_code);
+		return -1;
+	}
+
+	return (endian & 0x0f);
+}
+
+static Uint32 convert_endian_coda9_to_wave4(Uint32 endian)
+{
+	Uint32 converted_endian = endian;
+	switch (endian) {
+	case VDI_LITTLE_ENDIAN:
+		converted_endian = 0;
+		break;
+	case VDI_BIG_ENDIAN:
+		converted_endian = 7;
+		break;
+	case VDI_32BIT_LITTLE_ENDIAN:
+		converted_endian = 4;
+		break;
+	case VDI_32BIT_BIG_ENDIAN:
+		converted_endian = 3;
+		break;
+	}
+	return converted_endian;
+}
+
+static int Internal_swap_endian(unsigned long core_idx, unsigned char *data,
+				int len, int endian)
+{
+	vdi_info_t *vdi;
+	int changes;
+	int sys_endian;
+	BOOL byteChange, wordChange, dwordChange, lwordChange;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return -1;
+
+	if (PRODUCT_CODE_NOT_W_SERIES(vdi->product_code)) {
+		sys_endian = VDI_SYSTEM_ENDIAN;
+	} else {
+		VLOG(ERR, "Unknown product id : %08x\n", vdi->product_code);
+		return -1;
+	}
+
+	endian = Internal_vdi_convert_endian(core_idx, endian);
+	sys_endian = Internal_vdi_convert_endian(core_idx, sys_endian);
+	if (endian == sys_endian)
+		return 0;
+
+	if (PRODUCT_CODE_NOT_W_SERIES(vdi->product_code)) {
+		endian = convert_endian_coda9_to_wave4(endian);
+		sys_endian = convert_endian_coda9_to_wave4(sys_endian);
+	} else {
+		VLOG(ERR, "Unknown product id : %08x\n", vdi->product_code);
+		return -1;
+	}
+
+	changes = endian ^ sys_endian;
+	byteChange = changes & 0x01;
+	wordChange = ((changes & 0x02) == 0x02);
+	dwordChange = ((changes & 0x04) == 0x04);
+	lwordChange = ((changes & 0x08) == 0x08);
+
+	if (byteChange)
+		byte_swap(data, len);
+	if (wordChange)
+		word_swap(data, len);
+	if (dwordChange)
+		dword_swap(data, len);
+	if (lwordChange)
+		lword_swap(data, len);
+
+	return 1;
+}
+
+void vdi_set_rtk_clk_gating(Uint32 coreIdx, BOOL clk_en)
+{
+	vdi_info_t *vdi = lock_vdi_info(coreIdx);
+	if (vdi == NULL)
+		return;
+	Internal_vdi_set_rtk_clk_gating(coreIdx, clk_en);
+	unlock_vdi_info(vdi, coreIdx);
+	return;
+}
+
+static void Internal_vdi_set_rtk_clk_gating(Uint32 coreIdx, BOOL clk_en)
+{
+	vdi_info_t *vdi;
+	vpu_clock_info_t clockInfo;
+
+	VLOG(TRACE, "[VDI]  %s, %d... coreIdx:%d, clk_en:%s\n", __FUNCTION__,
+	     __LINE__, coreIdx, (clk_en == TRUE ? "TRUE" : "FALSE"));
+	clockInfo.core_idx = coreIdx;
+	clockInfo.enable = clk_en;
+#ifdef SUPPORT_SW_UART
+	if (clk_en == FALSE)
+		return;
+#endif
+
+	vdi = &s_vdi_info[coreIdx];
+	vdi->drv_ops->set_rtk_clk_gating(&clockInfo);
+}
+
+unsigned int vdi_get_rtk_clk_rate(Uint32 coreIdx)
+{
+	vdi_info_t *vdi = lock_vdi_info(coreIdx);
+	vpu_clock_info_t clockInfo;
+
+	clockInfo.core_idx = coreIdx;
+	clockInfo.value = 0;
+
+	VLOG(TRACE, "[VDI]  %s, %d... coreIdx:%d, clk_rate:%d\n", __FUNCTION__,
+	     __LINE__, coreIdx, clockInfo.value);
+	unlock_vdi_info(vdi, coreIdx);
+	return clockInfo.value;
+}
+
+#define ENABLE_RM (1 << 3)
+#define ENABLE_DOLBY_VISION (1 << 1)
+typedef enum {
+	STD_AVC,
+	STD_VC1,
+	STD_MPEG2,
+	STD_MPEG4,
+	STD_H263,
+	STD_UNKNOWN3,
+	STD_RV,
+	STD_AVS,
+	STD_THO = 9,
+	STD_VP3,
+	STD_VP8,
+	STD_HEVC,
+	STD_VP9,
+	STD_AVS2,
+	STD_DOLBY_VISION,
+	STD_MAX
+} CodStd;
+
+unsigned int vdi_get_support_vtype(Uint32 coreIdx)
+{
+	unsigned int support_vtype =
+		(1 << STD_AVC) | (1 << STD_VC1) | (1 << STD_MPEG2) |
+		(1 << STD_MPEG4) | (1 << STD_H263) | (1 << STD_AVS) |
+		(1 << STD_THO) | (1 << STD_VP8) | (1 << STD_HEVC) |
+		(1 << STD_VP9) | (1 << STD_AVS2);
+
+	return support_vtype;
+}
+
+int vdi_set_ve_prot_mode(Uint32 core_idx, BOOL enable)
+{
+	vdi_info_t *vdi;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return 0;
+
+	vdi = lock_vdi_info(core_idx);
+
+	if (PRODUCT_CODE_NOT_W_SERIES(vdi->product_code)) // CODA9XX
+	{
+		if ((Internal_vdi_read_register(core_idx, VE1_CTRL) & 0x2) !=
+		    0) // if BIT processor is not running.
+		{
+			if (enable == TRUE) {
+				Internal_vdi_write_register(core_idx,
+							    VE1_PROT_CTRL, 0x5);
+			} else {
+				Internal_vdi_write_register(core_idx,
+							    VE1_PROT_CTRL, 0x2);
+			}
+		} else {
+			VLOG(ERR, "VE1 CTI didn't enable\n");
+			goto ERR_VDI_SET_PROT;
+		}
+	} else {
+		VLOG(ERR, "Unknown product id : %08x\n", vdi->product_code);
+		goto ERR_VDI_SET_PROT;
+	}
+
+	unlock_vdi_info(vdi, core_idx);
+	return 1;
+
+ERR_VDI_SET_PROT:
+	VLOG(ERR, "Set VE prot mode failed!!!");
+	unlock_vdi_info(vdi, core_idx);
+	return 0;
+}
+
+unsigned int vdi_set_dovi_flag(unsigned long core_idx, unsigned long inst_idx,
+			       unsigned int enable)
+{
+	vdi_info_t *vdi;
+	vpudrv_dovi_info_t dovi_flag;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return 0;
+
+	vdi = lock_vdi_info(core_idx);
+
+	dovi_flag.core_idx = core_idx;
+	dovi_flag.inst_idx = inst_idx;
+	dovi_flag.enable = enable;
+
+	unlock_vdi_info(vdi, core_idx);
+	return dovi_flag.enable;
+}
+
+int vdi_get_total_instance_num(unsigned long core_idx)
+{
+	int ret;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return -1;
+	ret = Internal_vdi_get_total_instance_num(core_idx);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static int Internal_vdi_get_total_instance_num(unsigned long core_idx)
+{
+	vdi_info_t *vdi;
+	vpudrv_inst_info_t inst_info;
+	inst_info.inst_open_count = 4;
+	//TODO: need to add rtd16xxb_vdi_ioctl_get_total_instance_num to get vpudrv_inst_info
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	vdi = &s_vdi_info[core_idx];
+
+	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
+		return -1;
+
+	return inst_info.inst_open_count;
+}
+
+void vdi_set_thumb_num(unsigned long core_idx, unsigned int enable)
+{
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return;
+	Internal_vdi_set_thumb_num(core_idx, enable);
+	unlock_vdi_info(vdi, core_idx);
+	return;
+}
+
+static void Internal_vdi_set_thumb_num(unsigned long core_idx,
+				       unsigned int enable)
+{
+	vdi_info_t *vdi;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return;
+
+	vdi = &s_vdi_info[core_idx];
+
+	mutex_lock(vdi->vpu_thumb_mutex);
+	if (enable) {
+		*vdi->thumb_num = *vdi->thumb_num + 1;
+		;
+	} else {
+		if (*vdi->thumb_num > 0)
+			*vdi->thumb_num = *vdi->thumb_num - 1;
+	}
+	mutex_unlock(vdi->vpu_thumb_mutex);
+}
+
+unsigned int vdi_get_thumb_num(unsigned long core_idx)
+{
+	unsigned int ret;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return -1U;
+	ret = Internal_vdi_get_thumb_num(core_idx);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static unsigned int Internal_vdi_get_thumb_num(unsigned long core_idx)
+{
+	vdi_info_t *vdi;
+	unsigned int ret = 0;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return 0;
+
+	vdi = &s_vdi_info[core_idx];
+
+	mutex_lock(vdi->vpu_thumb_mutex);
+	ret = *vdi->thumb_num;
+	mutex_unlock(vdi->vpu_thumb_mutex);
+
+	return ret;
+}
+
+unsigned int vdi_set_thumb_used(unsigned long core_idx, unsigned int enable)
+{
+	unsigned int ret;
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return -1U;
+	ret = Internal_vdi_set_thumb_used(core_idx, enable);
+	unlock_vdi_info(vdi, core_idx);
+	return ret;
+}
+
+static unsigned int Internal_vdi_set_thumb_used(unsigned long core_idx,
+						unsigned int enable)
+{
+	vdi_info_t *vdi;
+	unsigned int ret = 0;
+
+	if (core_idx >= MAX_NUM_VPU_CORE)
+		return 0;
+
+	vdi = &s_vdi_info[core_idx];
+
+	mutex_lock(vdi->vpu_thumb_mutex);
+	if (enable) {
+		if (*vdi->thumb_used == 0) {
+			*vdi->thumb_used = 1;
+			ret = 1;
+		}
+	} else {
+		*vdi->thumb_used = 0;
+	}
+	mutex_unlock(vdi->vpu_thumb_mutex);
+
+	return ret;
+}
+
+void ve1_hw_lock(unsigned long core_idx)
+{
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return;
+
+	//VLOG(INFO, "[%d]%s.mutex_lock(vdi->ve1_hw_mutex)\n",
+	//	__LINE__, __func__);
+	mutex_lock(vdi->ve1_hw_mutex);
+
+	unlock_vdi_info(vdi, core_idx);
+}
+
+void ve1_hw_unlock(unsigned long core_idx)
+{
+	vdi_info_t *vdi = lock_vdi_info(core_idx);
+	if (vdi == NULL)
+		return;
+
+	//VLOG(INFO, "%d.%s.mutex_unlock(vdi->ve1_hw_mutex)\n",
+	//	__LINE__, __func__);
+	mutex_unlock(vdi->ve1_hw_mutex);
+
+	unlock_vdi_info(vdi, core_idx);
+}
\ No newline at end of file
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_vdi.h
@@ -0,0 +1,213 @@
+//------------------------------------------------------------------------------
+// File: ve1_vdi.h
+//
+// Copyright (c) 2006, Chips & Media.  All rights reserved.
+//------------------------------------------------------------------------------
+
+#ifndef _VDI_H_
+#define _VDI_H_
+
+#include "ve1_mm.h"
+#include "ve1config.h"
+#include "ve1_vputypes.h"
+
+/************************************************************************/
+/* COMMON REGISTERS                                                     */
+/************************************************************************/
+#define VPU_PRODUCT_NAME_REGISTER 0x1040
+#define VPU_PRODUCT_CODE_REGISTER 0x1044
+
+#define MAX_VPU_CORE_NUM MAX_NUM_VPU_CORE
+#define SUPPORT_INTERRUPT
+
+#define MAX_VPU_BUFFER_POOL                                                    \
+	(64 * MAX_NUM_INSTANCE +                                               \
+	 12 * 3) //+12*3 => mvCol + YOfsTable + COfsTable
+
+#define VpuWriteReg(CORE, ADDR, DATA)                                          \
+	vdi_write_register(CORE, ADDR, DATA) // system register write
+#define VpuReadReg(CORE, ADDR)                                                 \
+	vdi_read_register(CORE, ADDR) // system register read
+#define VpuWriteMem(CORE, ADDR, DATA, LEN, ENDIAN)                             \
+	vdi_write_memory(CORE, ADDR, DATA, LEN, ENDIAN) // system memory write
+#define VpuReadMem(CORE, ADDR, DATA, LEN, ENDIAN)                              \
+	vdi_read_memory(CORE, ADDR, DATA, LEN, ENDIAN) // system memory read
+
+//ENABLE_TEE_DRM_FLOW
+#define VE_SECURE_NORMAL 1
+#define VE_SECURE_PROTECTION 2
+
+typedef struct vpu_buffer_t {
+	int size;
+	unsigned long phys_addr;
+	unsigned long base;
+	unsigned long virt_addr;
+	//ENABLE_TEE_DRM_FLOW
+	unsigned int
+		req_spec_region; /* RTK, for security video path, 0: normal, 1: ve special, 2: protection */
+} vpu_buffer_t;
+
+typedef enum {
+	VDI_LITTLE_ENDIAN = 0, /* 64bit LE */
+	VDI_BIG_ENDIAN, /* 64bit BE */
+	VDI_32BIT_LITTLE_ENDIAN,
+	VDI_32BIT_BIG_ENDIAN,
+	/* WAVE PRODUCTS */
+	VDI_128BIT_LITTLE_ENDIAN = 16,
+	VDI_128BIT_LE_BYTE_SWAP,
+	VDI_128BIT_LE_WORD_SWAP,
+	VDI_128BIT_LE_WORD_BYTE_SWAP,
+	VDI_128BIT_LE_DWORD_SWAP,
+	VDI_128BIT_LE_DWORD_BYTE_SWAP,
+	VDI_128BIT_LE_DWORD_WORD_SWAP,
+	VDI_128BIT_LE_DWORD_WORD_BYTE_SWAP,
+	VDI_128BIT_BE_DWORD_WORD_BYTE_SWAP,
+	VDI_128BIT_BE_DWORD_WORD_SWAP,
+	VDI_128BIT_BE_DWORD_BYTE_SWAP,
+	VDI_128BIT_BE_DWORD_SWAP,
+	VDI_128BIT_BE_WORD_BYTE_SWAP,
+	VDI_128BIT_BE_WORD_SWAP,
+	VDI_128BIT_BE_BYTE_SWAP,
+	VDI_128BIT_BIG_ENDIAN = 31,
+	VDI_ENDIAN_MAX
+} EndianMode;
+
+#define VDI_128BIT_ENDIAN_MASK 0xf
+
+typedef struct vpu_pending_intr_t {
+	int instance_id[COMMAND_QUEUE_DEPTH];
+	int int_reason[COMMAND_QUEUE_DEPTH];
+	int order_num[COMMAND_QUEUE_DEPTH];
+	int in_use[COMMAND_QUEUE_DEPTH];
+	int num_pending_intr;
+	int count;
+} vpu_pending_intr_t;
+
+typedef enum {
+	VDI_LINEAR_FRAME_MAP = 0,
+	VDI_TILED_FRAME_V_MAP = 1,
+	VDI_TILED_FRAME_H_MAP = 2,
+	VDI_TILED_FIELD_V_MAP = 3,
+	VDI_TILED_MIXED_V_MAP = 4,
+	VDI_TILED_FRAME_MB_RASTER_MAP = 5,
+	VDI_TILED_FIELD_MB_RASTER_MAP = 6,
+	VDI_TILED_FRAME_NO_BANK_MAP = 7,
+	VDI_TILED_FIELD_NO_BANK_MAP = 8,
+	VDI_LINEAR_FIELD_MAP = 9,
+	VDI_TILED_MAP_TYPE_MAX
+} vdi_gdi_tiled_map;
+
+typedef struct vpu_instance_pool_t {
+	unsigned char codecInstPool
+		[MAX_NUM_INSTANCE]
+		[MAX_INST_HANDLE_SIZE]; // Since VDI don't know the size of CodecInst structure, VDI should have the enough space not to overflow.
+	long long pendingInstIdxPlus1;
+	void *pendingInst;
+	vpu_buffer_t vpu_common_buffer;
+	int vpu_instance_num;
+	int instance_pool_inited;
+	video_mm_t vmem;
+	vpu_pending_intr_t pending_intr_list;
+} vpu_instance_pool_t;
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+int vdi_probe(unsigned long core_idx);
+int vdi_init(unsigned long core_idx, void *videc_dev);
+int vdi_release(
+	unsigned long core_idx); //this function may be called only at system off.
+
+vpu_instance_pool_t *vdi_get_instance_pool(unsigned long core_idx);
+int vdi_allocate_common_memory(unsigned long core_idx, Uint32 size);
+int vdi_get_common_memory(unsigned long core_idx, vpu_buffer_t *vb);
+int vdi_get_common_memory_protect(unsigned long core_idx, vpu_buffer_t *vb,
+				  void *filp);
+int vdi_allocate_dma_memory(unsigned long core_idx, vpu_buffer_t *vb,
+			    void *filp);
+int vdi_allocate_dma_memory_no_mmap(unsigned long core_idx, vpu_buffer_t *vb,
+				    void *filp);
+int vdi_attach_dma_memory(unsigned long core_idx, vpu_buffer_t *vb);
+void vdi_free_dma_memory(unsigned long core_idx, vpu_buffer_t *vb);
+void vdi_free_dma_memory_no_mmap(unsigned long core_idx, vpu_buffer_t *vb);
+int vdi_get_sram_memory(unsigned long core_idx, vpu_buffer_t *vb);
+int vdi_dettach_dma_memory(unsigned long core_idx, vpu_buffer_t *vb);
+
+int vdi_wait_interrupt(unsigned long core_idx, int timeout,
+		       unsigned int addr_bit_int_reason);
+int vdi_wait_vpu_busy(unsigned long core_idx, int timeout,
+		      unsigned int addr_bit_busy_flag);
+int vdi_wait_bus_busy(unsigned long core_idx, int timeout,
+		      unsigned int gdi_busy_flag);
+int vdi_hw_reset(unsigned long core_idx);
+void vdi_check_hwreset(unsigned long core_idx);
+int vdi_check_protect(unsigned long core_idx);
+
+int vdi_set_clock_gate(unsigned long core_idx, int enable);
+int vdi_get_clock_gate(unsigned long core_idx);
+/**
+ * @brief       make clock stable before changing clock frequency
+ * @detail      Before inoking vdi_set_clock_freg() caller MUST invoke vdi_ready_change_clock() function.
+ *              after changing clock frequency caller also invoke vdi_done_change_clock() function.
+ * @return  0   failure
+ *          1   success
+ */
+int vdi_ready_change_clock(unsigned long core_idx);
+int vdi_set_change_clock(unsigned long core_idx, unsigned long clock_mask);
+int vdi_done_change_clock(unsigned long core_idx);
+
+int vdi_get_instance_num(unsigned long core_idx);
+
+void vdi_write_register(unsigned long core_idx, unsigned int addr,
+			unsigned int data);
+unsigned int vdi_read_register(unsigned long core_idx, unsigned int addr);
+int vdi_clear_memory(unsigned long core_idx, unsigned int addr, int len,
+		     int endian);
+void *vdi_get_virt_addr(unsigned long core_idx, unsigned int addr);
+int vdi_write_memory(unsigned long core_idx, unsigned int addr,
+		     unsigned char *data, int len, int endian);
+int vdi_read_memory(unsigned long core_idx, unsigned int addr,
+		    unsigned char *data, int len, int endian);
+int vdi_write_memory_va(unsigned long core_idx, unsigned char *addr,
+			unsigned char *data, int len, int endian);
+
+int vdi_lock(unsigned long core_idx);
+int vdi_lock_check(unsigned long core_idx);
+void vdi_unlock(unsigned long core_idx);
+int vdi_disp_lock(unsigned long core_idx);
+void vdi_disp_unlock(unsigned long core_idx);
+void vdi_set_sdram(unsigned long core_idx, unsigned int addr, int len,
+		   unsigned char data, int endian);
+void vdi_log(unsigned long core_idx, int cmd, int step);
+int vdi_open_instance(unsigned long core_idx, unsigned long inst_idx,
+		      void *filp);
+int vdi_close_instance(unsigned long core_idx, unsigned long inst_idx);
+int vdi_set_bit_firmware_to_pm(unsigned long core_idx,
+			       const unsigned short *code);
+int vdi_get_system_endian(unsigned long core_idx);
+int vdi_convert_endian(unsigned long core_idx, unsigned int endian);
+void vdi_print_vpu_status(unsigned long coreIdx);
+
+void vdi_set_rtk_clk_gating(Uint32 coreIdx, BOOL clk_en);
+unsigned int vdi_get_rtk_clk_rate(Uint32 coreIdx);
+unsigned int vdi_get_support_vtype(Uint32 coreIdx);
+int vdi_set_ve_prot_mode(Uint32 core_idx, BOOL enable);
+unsigned int vdi_set_dovi_flag(unsigned long core_idx, unsigned long inst_idx,
+			       unsigned int enable);
+int vdi_get_total_instance_num(unsigned long core_idx);
+void vdi_set_thumb_num(unsigned long core_idx, unsigned int enable);
+unsigned int vdi_get_thumb_num(unsigned long core_idx);
+unsigned int vdi_set_thumb_used(unsigned long core_idx, unsigned int enable);
+void vdi_write_dcsys_register(unsigned long core_idx, unsigned int addr,
+			      unsigned int data, unsigned int type);
+int vdi_read_dcsys_register(unsigned long core_idx, unsigned int addr,
+			    unsigned int type);
+
+void ve1_hw_lock(unsigned long core_idx);
+void ve1_hw_unlock(unsigned long core_idx);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif //#ifndef _VDI_H_
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_vdi_osal.c
@@ -0,0 +1,310 @@
+//------------------------------------------------------------------------------
+// File: ve1_vdi_osal.c
+//
+// Copyright (c) 2006, Chips & Media.  All rights reserved.
+//------------------------------------------------------------------------------
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/string.h>
+
+#include "ve1config.h"
+#include "ve1_vdi_osal.h"
+static int log_colors[MAX_LOG_LEVEL] = {
+	0,
+	TERM_COLOR_R | TERM_COLOR_G | TERM_COLOR_B | TERM_COLOR_BRIGHT, //INFO
+	TERM_COLOR_R | TERM_COLOR_B | TERM_COLOR_BRIGHT, //WARN
+	TERM_COLOR_R | TERM_COLOR_BRIGHT, // ERR
+	TERM_COLOR_R | TERM_COLOR_G | TERM_COLOR_B //TRACE
+};
+
+static unsigned log_decor = LOG_HAS_TIME | LOG_HAS_FILE | LOG_HAS_MICRO_SEC |
+			    LOG_HAS_NEWLINE | LOG_HAS_SPACE | LOG_HAS_COLOR;
+static int max_log_level = MAX_LOG_LEVEL;
+
+static void term_restore_color(void);
+static void term_set_color(int color);
+#ifdef SUPPORT_SW_UART
+static pthread_mutex_t s_log_mutex;
+#endif
+int InitLog(void)
+{
+#ifdef SUPPORT_SW_UART
+	pthread_mutex_init(&s_log_mutex, NULL);
+#endif
+	return 1;
+}
+
+void DeInitLog(void)
+{
+#ifdef SUPPORT_SW_UART
+	pthread_mutex_destroy(&s_log_mutex);
+#endif
+}
+
+void SetLogColor(int level, int color)
+{
+	log_colors[level] = color;
+}
+
+int GetLogColor(int level)
+{
+	return log_colors[level];
+}
+
+void SetLogDecor(int decor)
+{
+	log_decor = decor;
+}
+
+int GetLogDecor(void)
+{
+	return log_decor;
+}
+
+void SetMaxLogLevel(int level)
+{
+	max_log_level = level;
+}
+int GetMaxLogLevel(void)
+{
+	return max_log_level;
+}
+
+void LogMsg(int level, const char *format, ...)
+{
+	va_list ptr;
+	char logBuf[MAX_PRINT_LENGTH] = { 0 };
+#if !defined(ANDROID)
+	char logBuf_tag[MAX_PRINT_LENGTH] = { 0 };
+#endif
+
+	if (level > max_log_level)
+		return;
+#ifdef SUPPORT_SW_UART
+	pthread_mutex_lock(&s_log_mutex);
+#endif
+
+	va_start(ptr, format);
+#if defined(WIN32) || defined(__MINGW32__)
+	_vsnprintf(logBuf, MAX_PRINT_LENGTH, format, ptr);
+#else
+	vsnprintf(logBuf, MAX_PRINT_LENGTH, format, ptr);
+#endif
+	va_end(ptr);
+
+	if (log_decor & LOG_HAS_COLOR)
+		term_set_color(log_colors[level]);
+
+#ifdef ANDROID
+	if (level == ERR) {
+		pr_err("%s %s", VLOG_TAG, logBuf);
+	} else if (level == INFO) {
+		pr_info("%s %s", VLOG_TAG, logBuf);
+	} else {
+		pr_debug("%s %s", VLOG_TAG, logBuf);
+	}
+#else
+	snprintf(logBuf_tag, MAX_PRINT_LENGTH, "%s %s", VLOG_TAG, logBuf);
+	fputs(logBuf_tag, stdout);
+#endif
+
+	if (log_decor & LOG_HAS_COLOR)
+		term_restore_color();
+#ifdef SUPPORT_SW_UART
+	pthread_mutex_unlock(&s_log_mutex);
+#endif
+}
+
+static void term_set_color(int color)
+{
+	/* put bright prefix to ansi_color */
+	char ansi_color[12] = "\033[01;3";
+
+	return;
+
+	if (color & TERM_COLOR_BRIGHT)
+		color ^= TERM_COLOR_BRIGHT;
+	else
+		strcpy(ansi_color, "\033[00;3");
+
+	switch (color) {
+	case 0:
+		/* black color */
+		strcat(ansi_color, "0m");
+		break;
+	case TERM_COLOR_R:
+		/* red color */
+		strcat(ansi_color, "1m");
+		break;
+	case TERM_COLOR_G:
+		/* green color */
+		strcat(ansi_color, "2m");
+		break;
+	case TERM_COLOR_B:
+		/* blue color */
+		strcat(ansi_color, "4m");
+		break;
+	case TERM_COLOR_R | TERM_COLOR_G:
+		/* yellow color */
+		strcat(ansi_color, "3m");
+		break;
+	case TERM_COLOR_R | TERM_COLOR_B:
+		/* magenta color */
+		strcat(ansi_color, "5m");
+		break;
+	case TERM_COLOR_G | TERM_COLOR_B:
+		/* cyan color */
+		strcat(ansi_color, "6m");
+		break;
+	case TERM_COLOR_R | TERM_COLOR_G | TERM_COLOR_B:
+		/* white color */
+		strcat(ansi_color, "7m");
+		break;
+	default:
+		/* default console color */
+		strcpy(ansi_color, "\033[00m");
+		break;
+	}
+
+}
+
+static void term_restore_color(void)
+{
+	term_set_color(log_colors[4]);
+}
+
+#define VE1_ALIGN(value, base) (((value) + ((base)-1)) & ~((base)-1))
+#define DEVICE_ALIGN (0x8) /* for non-cacheable memory */
+void *osal_memcpy(void *dst, const void *src, int count)
+{
+	if ((count % DEVICE_ALIGN) != 0 || ((long)dst % DEVICE_ALIGN) != 0) {
+		unsigned char *cDst = (unsigned char *)dst;
+		unsigned char *cSrc = (unsigned char *)src;
+		int copyCount = count;
+		if (((long)cDst % DEVICE_ALIGN) != 0) {
+			int i;
+			long copySize = VE1_ALIGN(((long)cDst), DEVICE_ALIGN) -
+					(long)cDst;
+			for (i = 0; i < (int)copySize; i++) {
+				cDst[0] = cSrc[0];
+				cDst += 1;
+				cSrc += 1;
+				copyCount -= 1;
+			}
+		}
+
+		if ((copyCount % DEVICE_ALIGN) != 0) {
+			int i;
+			long copySize = copyCount % DEVICE_ALIGN;
+			for (i = (copyCount - copySize); i < (int)copyCount;
+			     i++)
+				cDst[i] = cSrc[i];
+			copyCount -= copySize;
+		}
+
+		memcpy((void *)cDst, (void *)cSrc, copyCount);
+		return dst;
+	} else {
+		return memcpy(dst, src, count);
+	}
+}
+
+int osal_memcmp(const void *src, const void *dst, int size)
+{
+	return memcmp(src, dst, size);
+}
+
+void *osal_memset(void *dst, int val, int count)
+{
+	if (((long)dst % DEVICE_ALIGN) != 0) {
+		unsigned char *cDst = (unsigned char *)dst;
+		int copyCount = count;
+		if (((long)cDst % DEVICE_ALIGN) != 0) {
+			int i;
+			long copySize = VE1_ALIGN(((long)cDst), DEVICE_ALIGN) -
+					(long)cDst;
+			for (i = 0; i < (int)copySize; i++) {
+				cDst[0] = (unsigned char)(val & 0xff);
+				cDst += 1;
+				copyCount -= 1;
+			}
+		}
+
+		if ((copyCount % DEVICE_ALIGN) != 0) {
+			int i;
+			long copySize = copyCount % DEVICE_ALIGN;
+			for (i = (copyCount - copySize); i < (int)copyCount;
+			     i++)
+				cDst[i] = (unsigned char)(val & 0xff);
+			copyCount -= copySize;
+		}
+
+		memset((void *)cDst, val, copyCount);
+		return dst;
+	} else
+		return memset(dst, val, count);
+}
+
+void *osal_malloc(int size)
+{
+	return vmalloc(size);
+}
+
+void osal_free(void *p)
+{
+	vfree(p);
+}
+
+//------------------------------------------------------------------------------
+// math related api
+//------------------------------------------------------------------------------
+#ifndef I64
+typedef long long I64;
+#endif
+
+// 32 bit / 16 bit ==> 32-n bit remainder, n bit quotient
+static int fixDivRq(int a, int b, int n)
+{
+	I64 c;
+	I64 a_36bit;
+	I64 mask, signBit, signExt;
+	int i;
+
+	// DIVS emulation for BPU accumulator size
+	// For SunOS build
+	mask = 0x0F;
+	mask <<= 32;
+	mask |= 0x00FFFFFFFF; // mask = 0x0FFFFFFFFF;
+	signBit = 0x08;
+	signBit <<= 32; // signBit = 0x0800000000;
+	signExt = 0xFFFFFFF0;
+	signExt <<= 32; // signExt = 0xFFFFFFF000000000;
+
+	a_36bit = (I64)a;
+
+	for (i = 0; i < n; i++) {
+		c = a_36bit - (b << 15);
+		if (c >= 0)
+			a_36bit = (c << 1) + 1;
+		else
+			a_36bit = a_36bit << 1;
+
+		a_36bit = a_36bit & mask;
+		if (a_36bit & signBit)
+			a_36bit |= signExt;
+	}
+
+	a = (int)a_36bit;
+	return a; // R = [31:n], Q = [n-1:0]
+}
+
+int math_div(int number, int denom)
+{
+	int c;
+	c = fixDivRq(number, denom, 17); // R = [31:17], Q = [16:0]
+	c = c & 0xFFFF;
+	c = (c + 1) >> 1; // round
+	return (c & 0xFFFF);
+}
+
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_vdi_osal.h
@@ -0,0 +1,130 @@
+//------------------------------------------------------------------------------
+// File: log.h
+//
+// Copyright (c) 2006, Chips & Media.  All rights reserved.
+//------------------------------------------------------------------------------
+
+#ifndef _VDI_OSAL_H_
+#define _VDI_OSAL_H_
+
+enum { NONE = 0, ERR, WARN, INFO, TRACE, MAX_LOG_LEVEL };
+enum { LOG_HAS_DAY_NAME = 1, /**< Include day name [default: no] 	      */
+       LOG_HAS_YEAR = 2, /**< Include year digit [no]		      */
+       LOG_HAS_MONTH = 4, /**< Include month [no]		      */
+       LOG_HAS_DAY_OF_MON = 8, /**< Include day of month [no]	      */
+       LOG_HAS_TIME = 16, /**< Include time [yes]		      */
+       LOG_HAS_MICRO_SEC = 32, /**< Include microseconds [yes]             */
+       LOG_HAS_FILE = 64, /**< Include sender in the log [yes] 	      */
+       LOG_HAS_NEWLINE = 128, /**< Terminate each call with newline [yes] */
+       LOG_HAS_CR = 256, /**< Include carriage return [no] 	      */
+       LOG_HAS_SPACE = 512, /**< Include two spaces before log [yes]    */
+       LOG_HAS_COLOR = 1024, /**< Colorize logs [yes on win32]	      */
+       LOG_HAS_LEVEL_TEXT =
+	       2048 /**< Include level text string [no]	      */
+};
+enum { TERM_COLOR_R = 2, /**< Red            */
+       TERM_COLOR_G = 4, /**< Green          */
+       TERM_COLOR_B = 1, /**< Blue.          */
+       TERM_COLOR_BRIGHT = 8 /**< Bright mask.   */
+};
+
+#define MAX_PRINT_LENGTH 512
+
+#define VLOG_TAG "[RTK_VE1]"
+#define VLOG LogMsg
+
+#define LOG_ENABLE_FILE SetLogDecor(GetLogDecor() | LOG_HAS_FILE);
+
+typedef void *osal_file_t;
+#ifndef SEEK_SET
+#define SEEK_SET 0
+#endif
+
+#ifndef SEEK_CUR
+#define SEEK_CUR 1
+#endif
+
+#ifndef SEEK_END
+#define SEEK_END 2
+#endif
+
+#if defined(_WIN32) || defined(__WIN32__) || defined(_WIN64) ||                \
+	defined(WIN32) || defined(__MINGW32__)
+#elif defined(linux) || defined(__linux) || defined(ANDROID)
+#else
+
+#ifndef stdout
+#define stdout (void *)1
+#endif
+#ifndef stderr
+#define stderr (void *)1
+#endif
+
+#endif
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+int InitLog(void);
+void DeInitLog(void);
+
+void SetMaxLogLevel(int level);
+int GetMaxLogLevel(void);
+
+void SetLogColor(int level, int color);
+int GetLogColor(int level);
+
+void SetLogDecor(int decor);
+int GetLogDecor(void);
+
+//log print
+void LogMsg(int level, const char *format, ...);
+
+//timer
+void timer_start(void);
+void timer_stop(void);
+double timer_elapsed_us(void);
+double timer_elapsed_ms(void);
+int timer_is_valid(void);
+double timer_frequency(void);
+
+//math
+int math_div(int number, int denom);
+int math_modulo(int number, int denom);
+
+//terminal
+void osal_init_keyboard(void);
+void osal_close_keyboard(void);
+
+//memory
+void *osal_memcpy(void *dst, const void *src, int count);
+void *osal_memset(void *dst, int val, int count);
+int osal_memcmp(const void *src, const void *dst, int size);
+void *osal_malloc(int size);
+void *osal_realloc(void *ptr, int size);
+void osal_free(void *p);
+
+osal_file_t osal_fopen(const char *osal_file_tname, const char *mode);
+size_t osal_fwrite(const void *p, int size, int count, osal_file_t fp);
+size_t osal_fread(void *p, int size, int count, osal_file_t fp);
+long osal_ftell(osal_file_t fp);
+int osal_fseek(osal_file_t fp, long offset, int origin);
+int osal_fclose(osal_file_t fp);
+int osal_fflush(osal_file_t fp);
+int osal_fprintf(osal_file_t fp, const char *_Format, ...);
+int osal_fscanf(osal_file_t fp, const char *_Format, ...);
+int osal_kbhit(void);
+int osal_getch(void);
+int osal_flush_ch(void);
+int osal_feof(osal_file_t fp);
+void *osal_create_mutex(const char *name);
+void osal_close_mutex(void *handle);
+int osal_mutex_lock(void *handle);
+int osal_mutex_unlock(void *handle);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif //#ifndef _VDI_OSAL_H_
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_vpu.c
@@ -0,0 +1,4544 @@
+//--=========================================================================--
+//  This file is a part of VPU Reference API project
+//-----------------------------------------------------------------------------
+//
+//       This confidential and proprietary software may be used only
+//     as authorized by a licensing agreement from Chips&Media Inc.
+//     In the event of publication, the following notice is applicable:
+//
+//            (C) COPYRIGHT 2006 - 2013  CHIPS&MEDIA INC.
+//                      ALL RIGHTS RESERVED
+//
+//       The entire notice above must be reproduced on all authorized
+//       copies.
+//
+//--=========================================================================--
+#include "ve1_vpuconfig.h"
+#include "ve1_product.h"
+#include "ve1_regdefine.h"
+#include "ve1_vpu_md5.h"
+#include <linux/tee_drv.h>
+
+//#define GET_PERFORMANCE
+#ifdef GET_PERFORMANCE
+#include <string.h>
+#include <sys/time.h>
+struct timeval start_dec_tv;
+struct timeval start_enc_tv;
+struct timeval end_tv;
+#endif
+#ifndef __maybe_unused
+#define __maybe_unused __attribute__((unused))
+#endif
+
+//#define CODA9_CHECK_CODE_BUFFER_MD5SUM
+#if defined(CODA9_CHECK_CODE_BUFFER_MD5SUM)
+static Uint32 gCodaFwSize = 0;
+#endif
+
+extern int ta_TEEapi_memcpy_a7(struct tee_context *teeapi_ctx,
+			       unsigned int teeapi_tee_session,
+			       unsigned int dstPAddr, unsigned char *buf,
+			       int size);
+
+static RetCode Coda9VpuSetVeProtMode(Uint32 coreIdx, BOOL enable,
+				     void *sess __maybe_unused,
+				     void *rtk_sess __maybe_unused)
+{
+	if (1) {
+		if (vdi_set_ve_prot_mode(coreIdx, enable) == 0) {
+			VLOG(ERR, "coreIdx %d fail to enable prot mode",
+			     coreIdx);
+			return RETCODE_FAILURE;
+		}
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+static void Coda9VpuDecSetCommonAddress(CodecInst *instance)
+{
+	CodecInst *pCodecInst;
+	PhysicalAddress paraBuffer;
+	PhysicalAddress tempBuffer;
+	vpu_buffer_t vb;
+
+	osal_memset((void *)&vb, 0, sizeof(vpu_buffer_t));
+	pCodecInst = instance;
+
+	if (pCodecInst->isUseProtectBuffer) //RTK, need to review it
+	{
+		Coda9VpuSetVeProtMode(pCodecInst->coreIdx, TRUE,
+				      pCodecInst->sess, pCodecInst->rtk_sess);
+		vdi_get_common_memory_protect(pCodecInst->coreIdx, &vb,
+					      pCodecInst->filp);
+	} else {
+		Coda9VpuSetVeProtMode(pCodecInst->coreIdx, FALSE, NULL, NULL);
+		vdi_get_common_memory(pCodecInst->coreIdx, &vb);
+	}
+
+	tempBuffer = vb.phys_addr + CODE_BUF_SIZE;
+	paraBuffer = tempBuffer + TEMP_BUF_SIZE;
+	VpuWriteReg(pCodecInst->coreIdx, BIT_PARA_BUF_ADDR, paraBuffer);
+	VpuWriteReg(pCodecInst->coreIdx, BIT_TEMP_BUF_ADDR, tempBuffer);
+}
+
+#ifdef ENABLE_TEE_DRM_FLOW
+static void LoadBitCode(Uint32 coreIdx, PhysicalAddress codeBase,
+			const Uint16 *codeWord, int codeSize);
+static void Coda9VpuWriteMem(unsigned long core_idx, unsigned int addr,
+			     unsigned char *data, int len, int endian,
+			     void *teeapi_ctx, unsigned int teeapi_tee_session)
+{
+	int ret;
+	unsigned char *tmpData = NULL;
+
+	tmpData = (unsigned char *)osal_malloc(len);
+	if (tmpData == NULL) {
+		VLOG(ERR, "In[%s][%d] malloc failed\n", __func__, __LINE__);
+		return;
+	}
+	vdi_write_memory_va(core_idx, tmpData, data, len, endian);
+
+	ret = ta_TEEapi_memcpy_a7((struct tee_context *)teeapi_ctx,
+				  teeapi_tee_session, addr, tmpData, len);
+	if (ret < 0) {
+		VLOG(ERR, "[%d]%s.ta_TEEapi_memcpy_a7() fail.ret:%d\n",
+		     __LINE__, __func__, ret);
+	}
+
+	osal_free(tmpData);
+}
+
+RetCode Coda9VpuInitProtect(Uint32 coreIdx, void *firmware, Uint32 size,
+			    void *sess, void *rtk_sess, void *filp)
+{
+	Uint32 data;
+	vpu_buffer_t vb;
+	PhysicalAddress tempBuffer;
+	PhysicalAddress paraBuffer;
+	PhysicalAddress codeBuffer;
+	PhysicalAddress codeBufferProt;
+#if defined(CODA9_CHECK_CODE_BUFFER_MD5SUM)
+	unsigned char md5hash[16];
+#endif
+
+	VLOG(TRACE, "[+] [%d]%s.coreIdx:%d.firmware:%p.size:%d\n",__LINE__,__func__,coreIdx,firmware,size);
+
+	osal_memset((void *)&vb, 0, sizeof(vpu_buffer_t));
+	Coda9VpuSetVeProtMode((unsigned long)coreIdx, TRUE, sess, rtk_sess);
+	vdi_get_common_memory_protect((unsigned long)coreIdx, &vb, filp);
+
+	codeBufferProt = vb.phys_addr;
+	tempBuffer = codeBufferProt + CODE_BUF_SIZE;
+	paraBuffer = tempBuffer + TEMP_BUF_SIZE;
+
+	{
+		int i;
+		const Uint16 *codeWord = (const Uint16 *)firmware;
+		vdi_get_common_memory((unsigned long)coreIdx, &vb);
+		codeBuffer = vb.phys_addr;
+		LoadBitCode(coreIdx, codeBuffer, codeWord, size);
+#if defined(CODA9_CHECK_CODE_BUFFER_MD5SUM)
+		gCodaFwSize = size;
+		VLOG(TRACE,
+		     "[%d]%s.codeBuffer(phys:0x%08x,virt:0x%08x).size:%d\n",
+		     __LINE__, __func__, vb.phys_addr, vb.virt_addr, size);
+		MD5(((unsigned char *)(vb.virt_addr)), (size_t)size, md5hash);
+		VLOG(TRACE,
+		     "[%d]%s.codeBuffer Hash: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+		     __LINE__, __func__, md5hash[0], md5hash[1], md5hash[2],
+		     md5hash[3], md5hash[4], md5hash[5], md5hash[6], md5hash[7],
+		     md5hash[8], md5hash[9], md5hash[10], md5hash[11],
+		     md5hash[12], md5hash[13], md5hash[14], md5hash[15]);
+#endif
+
+		VpuWriteReg(coreIdx, BIT_INT_ENABLE, 0);
+		VpuWriteReg(coreIdx, BIT_CODE_RUN, 0);
+
+		for (i = 0; i < 2048; ++i) {
+			data = codeWord[i];
+			VpuWriteReg(coreIdx, BIT_CODE_DOWN, (i << 16) | data);
+		}
+	}
+
+	VpuWriteReg(coreIdx, BIT_PARA_BUF_ADDR, paraBuffer);
+	VpuWriteReg(coreIdx, BIT_CODE_BUF_ADDR, codeBuffer);
+	VpuWriteReg(coreIdx, BIT_TEMP_BUF_ADDR, tempBuffer);
+
+	VpuWriteReg(coreIdx, BIT_BIT_STREAM_CTRL, VPU_STREAM_ENDIAN);
+	VpuWriteReg(
+		coreIdx, BIT_FRAME_MEM_CTRL,
+		CBCR_INTERLEAVE << 2 |
+			VPU_FRAME_ENDIAN); // Interleave bit position is modified
+	VpuWriteReg(coreIdx, BIT_BIT_STREAM_PARAM, 0);
+
+	VpuWriteReg(coreIdx, BIT_AXI_SRAM_USE, 0);
+	VpuWriteReg(coreIdx, BIT_INT_ENABLE, 0);
+	VpuWriteReg(coreIdx, BIT_ROLLBACK_STATUS, 0);
+
+	data = (1 << INT_BIT_BIT_BUF_FULL);
+	data |= (1 << INT_BIT_BIT_BUF_EMPTY);
+	data |= (1 << INT_BIT_DEC_MB_ROWS);
+	data |= (1 << INT_BIT_SEQ_INIT);
+	data |= (1 << INT_BIT_DEC_FIELD);
+	data |= (1 << INT_BIT_PIC_RUN);
+
+	VpuWriteReg(coreIdx, BIT_INT_ENABLE, data);
+	VpuWriteReg(coreIdx, BIT_INT_CLEAR, 0x1);
+	VpuWriteReg(coreIdx, BIT_BUSY_FLAG, 0x1);
+	VpuWriteReg(coreIdx, BIT_CODE_RESET, 1);
+	VpuWriteReg(coreIdx, BIT_CODE_RUN, 1);
+
+	if (vdi_wait_vpu_busy(coreIdx, __VPU_BUSY_TIMEOUT, BIT_BUSY_FLAG) == -1)
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+
+	return RETCODE_SUCCESS;
+}
+
+#endif
+
+static void LoadBitCode(Uint32 coreIdx, PhysicalAddress codeBase,
+			const Uint16 *codeWord, int codeSize)
+{
+	int i;
+	BYTE code[8];
+
+	for (i = 0; i < codeSize; i += 4) {
+		// 2byte little endian variable to 1byte big endian buffer
+		code[0] = (BYTE)(codeWord[i + 0] >> 8);
+		code[1] = (BYTE)codeWord[i + 0];
+		code[2] = (BYTE)(codeWord[i + 1] >> 8);
+		code[3] = (BYTE)codeWord[i + 1];
+		code[4] = (BYTE)(codeWord[i + 2] >> 8);
+		code[5] = (BYTE)codeWord[i + 2];
+		code[6] = (BYTE)(codeWord[i + 3] >> 8);
+		code[7] = (BYTE)codeWord[i + 3];
+		VpuWriteMem(coreIdx, codeBase + i * 2, (BYTE *)code, 8,
+			    VDI_BIG_ENDIAN);
+	}
+
+	vdi_set_bit_firmware_to_pm(coreIdx, codeWord);
+}
+
+static RetCode BitLoadFirmware(Uint32 coreIdx, PhysicalAddress codeBase,
+			       const Uint16 *codeWord, int codeSize)
+{
+	int i;
+	Uint32 data;
+
+	LoadBitCode(coreIdx, codeBase, codeWord, codeSize);
+
+	VpuWriteReg(coreIdx, BIT_INT_ENABLE, 0);
+	VpuWriteReg(coreIdx, BIT_CODE_RUN, 0);
+
+	for (i = 0; i < 2048; ++i) {
+		data = codeWord[i];
+		VpuWriteReg(coreIdx, BIT_CODE_DOWN, (i << 16) | data);
+	}
+	return RETCODE_SUCCESS;
+}
+
+static void SetEncFrameMemInfo(CodecInst *pCodecInst)
+{
+	Uint32 val;
+	EncInfo *pEncInfo = &pCodecInst->CodecInfo->encInfo;
+
+	switch (pCodecInst->productId) {
+	case PRODUCT_ID_980:
+		val = (pEncInfo->openParam.bwbEnable << 15) |
+		      (pEncInfo->linear2TiledMode << 13) |
+		      (pEncInfo->mapType << 9);
+		if (pEncInfo->openParam.EncStdParam.avcParam.chromaFormat400)
+			val |= (FORMAT_400 << 6);
+		else
+			val |= (FORMAT_420 << 6);
+		val |= ((pEncInfo->openParam.cbcrInterleave)
+			<< 2); // Interleave bit position is modified
+		val |= pEncInfo->openParam.frameEndian;
+		VpuWriteReg(pCodecInst->coreIdx, BIT_FRAME_MEM_CTRL, val);
+		break;
+	case PRODUCT_ID_960:
+		val = 0;
+		if (pEncInfo->mapType) {
+			if (pEncInfo->mapType == TILED_FRAME_MB_RASTER_MAP ||
+			    pEncInfo->mapType == TILED_FIELD_MB_RASTER_MAP)
+				val |= (pEncInfo->linear2TiledEnable << 11) |
+				       (0x03 << 9) | (FORMAT_420 << 6);
+			else
+				val |= (pEncInfo->linear2TiledEnable << 11) |
+				       (0x02 << 9) | (FORMAT_420 << 6);
+		}
+		val |= ((pEncInfo->openParam.cbcrInterleave)
+			<< 2); // Interleave bit position is modified
+		val |= (pEncInfo->openParam.cbcrInterleave &
+			pEncInfo->openParam.nv21)
+		       << 3;
+		val |= (pEncInfo->openParam.bwbEnable << 12);
+		val |= pEncInfo->openParam.frameEndian;
+		VpuWriteReg(pCodecInst->coreIdx, BIT_FRAME_MEM_CTRL, val);
+		break;
+	}
+
+	return;
+}
+
+static char cmd2string[12][32] = {
+    "ENC_SEQ_INIT",
+    "ENC_SEQ_END",
+    "PIC_RUN",
+    "SET_FRAME_BUF",
+    "ENCODE_HEADER",
+    "ENC_PARA_SET",
+    "DEC_PARA_SET",
+    "DEC_BUF_FLUSH",
+    "RC_CHANGE_PARAMETER",
+    "VPU_SLEEP",
+    "VPU_WAKE",
+    "ENC_ROI_INIT",
+};
+
+void Coda9BitIssueCommand(Uint32 coreIdx, CodecInst *inst, int cmd)
+{
+	int instIdx = 0;
+	int cdcMode = 0;
+	int auxMode = 0;
+
+    VLOG(TRACE, "[+] [%d]%s.coreIdx:%d.cmd:%d(%s)\n",__LINE__,__func__,coreIdx,cmd,((cmd<=12)?cmd2string[cmd-1]:""));
+
+	if (inst != NULL) // command is specific to instance
+	{
+		instIdx = inst->instIndex;
+		cdcMode = inst->codecMode;
+		auxMode = inst->codecModeAux;
+	}
+
+	if (inst) {
+		if (inst->codecMode < AVC_ENC) {
+			VpuWriteReg(coreIdx, BIT_WORK_BUF_ADDR,
+				    inst->CodecInfo->decInfo.vbWork.phys_addr);
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+			SetDecWriteProtectRegions(inst);
+#endif
+		} else {
+			VpuWriteReg(coreIdx, BIT_WORK_BUF_ADDR,
+				    inst->CodecInfo->encInfo.vbWork.phys_addr);
+		}
+	}
+
+	VpuWriteReg(coreIdx, BIT_BUSY_FLAG, 1);
+	VpuWriteReg(coreIdx, BIT_RUN_INDEX, instIdx);
+	VpuWriteReg(coreIdx, BIT_RUN_COD_STD, cdcMode);
+	VpuWriteReg(coreIdx, BIT_RUN_AUX_STD, auxMode);
+	if (inst && inst->loggingEnable)
+		vdi_log(coreIdx, cmd, 1);
+	VpuWriteReg(coreIdx, BIT_RUN_COMMAND, cmd);
+    VLOG(TRACE, "[-] [%d]%s.coreIdx:%d\n",__LINE__,__func__,coreIdx);
+}
+
+static void SetupCoda9Properties(Uint32 coreIdx, Uint32 productId)
+{
+	VpuAttr *pAttr = &g_VpuCoreAttributes[coreIdx];
+	Int32 val;
+	char *pstr;
+	Uint32 support_vtype = 0;
+
+	/* Setup Attributes */
+	pAttr = &g_VpuCoreAttributes[coreIdx];
+
+	// Hardware version information
+	val = VpuReadReg(coreIdx, VPU_PRODUCT_CODE_REGISTER);
+	if ((val & 0xff00) == 0x3200)
+		val = 0x3200;
+	val = VpuReadReg(coreIdx, DBG_CONFIG_REPORT_0);
+	pstr = (char *)&val;
+	pAttr->productName[0] = pstr[3];
+	pAttr->productName[1] = pstr[2];
+	pAttr->productName[2] = pstr[1];
+	pAttr->productName[3] = pstr[0];
+	pAttr->productName[4] = 0;
+
+	pAttr->supportDecoders =
+		(1 << STD_AVC) | (1 << STD_VC1) | (1 << STD_MPEG2) |
+		(1 << STD_MPEG4) | (1 << STD_H263) | (1 << STD_AVS) |
+		(1 << STD_RV) | (1 << STD_THO) | (1 << STD_VP8);
+
+	support_vtype = vdi_get_support_vtype(coreIdx);
+	pAttr->supportDecoders = (pAttr->supportDecoders & support_vtype);
+	VLOG(TRACE,
+	     "\033[0;31mpAttr->supportDecoders : 0x%08x, support_vtype : 0x%08x\033[m\n",
+	     pAttr->supportDecoders, support_vtype);
+
+	/* Encoder */
+	pAttr->supportEncoders =
+		(1 << STD_AVC) | (1 << STD_MPEG4) | (1 << STD_H263);
+
+	/* WTL */
+	if (productId == PRODUCT_ID_960 || productId == PRODUCT_ID_980) {
+		pAttr->supportWTL = 1;
+	}
+	/* Tiled2Linear */
+	pAttr->supportTiled2Linear = 1;
+	/* Maptypes */
+	pAttr->supportMapTypes =
+		(1 << LINEAR_FRAME_MAP) | (1 << TILED_FRAME_V_MAP) |
+		(1 << TILED_FRAME_H_MAP) | (1 << TILED_FIELD_V_MAP) |
+		(1 << TILED_MIXED_V_MAP) | (1 << TILED_FRAME_MB_RASTER_MAP) |
+		(1 << TILED_FIELD_MB_RASTER_MAP);
+	if (productId == PRODUCT_ID_980) {
+		pAttr->supportMapTypes |= (1 << TILED_FRAME_NO_BANK_MAP) |
+					  (1 << TILED_FIELD_NO_BANK_MAP);
+	}
+	/* Linear2Tiled */
+	if (productId == PRODUCT_ID_960 || productId == PRODUCT_ID_980) {
+		pAttr->supportLinear2Tiled = 1;
+	}
+	/* Framebuffer Cache */
+	if (productId == PRODUCT_ID_960)
+		pAttr->framebufferCacheType = FramebufCacheMaverickI;
+	else if (productId == PRODUCT_ID_980)
+		pAttr->framebufferCacheType = FramebufCacheMaverickII;
+	else
+		pAttr->framebufferCacheType = FramebufCacheNone;
+	/* AXI 128bit Bus */
+	pAttr->support128bitBus = FALSE;
+	pAttr->supportEndianMask =
+		(1 << VDI_LITTLE_ENDIAN) | (1 << VDI_BIG_ENDIAN) |
+		(1 << VDI_32BIT_LITTLE_ENDIAN) | (1 << VDI_32BIT_BIG_ENDIAN);
+	pAttr->supportBitstreamMode = (1 << BS_MODE_INTERRUPT) |
+				      (1 << BS_MODE_PIC_END) |
+				      (1 << BS_MODE_ROLLBACK);
+	pAttr->bitstreamBufferMargin = VPU_GBU_SIZE;
+	pAttr->numberOfMemProtectRgns = 6;
+}
+
+Uint32 Coda9VpuGetProductId(Uint32 coreIdx)
+{
+	Uint32 productId;
+	Uint32 val;
+
+	val = VpuReadReg(coreIdx, VPU_PRODUCT_CODE_REGISTER);
+
+	if (val == BODA950_CODE)
+		productId = PRODUCT_ID_950;
+	else if (val == CODA960_CODE)
+		productId = PRODUCT_ID_960;
+	else if (val == CODA980_CODE)
+		productId = PRODUCT_ID_980;
+	else
+		productId = PRODUCT_ID_NONE;
+
+	if (productId != PRODUCT_ID_NONE)
+		SetupCoda9Properties(coreIdx, productId);
+
+	return productId;
+}
+
+RetCode Coda9VpuGetVersion(Uint32 coreIdx, Uint32 *versionInfo,
+			   Uint32 *revision)
+{
+	/* Get Firmware version */
+	VpuWriteReg(coreIdx, RET_FW_VER_NUM, 0);
+	Coda9BitIssueCommand(coreIdx, NULL, FIRMWARE_GET);
+	if (vdi_wait_vpu_busy(coreIdx, __VPU_BUSY_TIMEOUT, BIT_BUSY_FLAG) == -1)
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+
+	if (versionInfo != NULL) {
+		*versionInfo = VpuReadReg(coreIdx, RET_FW_VER_NUM);
+	}
+	if (revision != NULL) {
+		*revision = VpuReadReg(coreIdx, RET_FW_CODE_REV);
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuInit(Uint32 coreIdx, void *firmware, Uint32 size)
+{
+	Uint32 data;
+	vpu_buffer_t vb;
+	PhysicalAddress tempBuffer;
+	PhysicalAddress paraBuffer;
+	PhysicalAddress codeBuffer;
+
+    VLOG(TRACE, "[+] [%d]%s.coreIdx:%d.firmware:%p.size:%d\n",__LINE__,__func__,coreIdx,firmware,size);
+
+	osal_memset((void *)&vb, 0, sizeof(vpu_buffer_t));
+	Coda9VpuSetVeProtMode((unsigned long)coreIdx, FALSE, NULL, NULL);
+	vdi_get_common_memory((unsigned long)coreIdx, &vb);
+
+	codeBuffer = vb.phys_addr;
+	tempBuffer = codeBuffer + CODE_BUF_SIZE;
+	paraBuffer = tempBuffer + TEMP_BUF_SIZE;
+
+	BitLoadFirmware(coreIdx, codeBuffer, (const Uint16 *)firmware, size);
+
+	VpuWriteReg(coreIdx, BIT_PARA_BUF_ADDR, paraBuffer);
+	VpuWriteReg(coreIdx, BIT_CODE_BUF_ADDR, codeBuffer);
+	VpuWriteReg(coreIdx, BIT_TEMP_BUF_ADDR, tempBuffer);
+
+	VpuWriteReg(coreIdx, BIT_BIT_STREAM_CTRL, VPU_STREAM_ENDIAN);
+	VpuWriteReg(
+		coreIdx, BIT_FRAME_MEM_CTRL,
+		CBCR_INTERLEAVE << 2 |
+			VPU_FRAME_ENDIAN); // Interleave bit position is modified
+	VpuWriteReg(coreIdx, BIT_BIT_STREAM_PARAM, 0);
+
+	VpuWriteReg(coreIdx, BIT_AXI_SRAM_USE, 0);
+	VpuWriteReg(coreIdx, BIT_INT_ENABLE, 0);
+	VpuWriteReg(coreIdx, BIT_ROLLBACK_STATUS, 0);
+
+	data = (1 << INT_BIT_BIT_BUF_FULL);
+	data |= (1 << INT_BIT_BIT_BUF_EMPTY);
+	data |= (1 << INT_BIT_DEC_MB_ROWS);
+	data |= (1 << INT_BIT_SEQ_INIT);
+	data |= (1 << INT_BIT_DEC_FIELD);
+	data |= (1 << INT_BIT_PIC_RUN);
+
+	VpuWriteReg(coreIdx, BIT_INT_ENABLE, data);
+	VpuWriteReg(coreIdx, BIT_INT_CLEAR, 0x1);
+	VpuWriteReg(coreIdx, BIT_BUSY_FLAG, 0x1);
+	VpuWriteReg(coreIdx, BIT_CODE_RESET, 1);
+	VpuWriteReg(coreIdx, BIT_CODE_RUN, 1);
+
+	if (vdi_wait_vpu_busy(coreIdx, __VPU_BUSY_TIMEOUT, BIT_BUSY_FLAG) ==
+	    -1) {
+		VLOG(ERR, "[-] [%d]%s.RETCODE_VPU_RESPONSE_TIMEOUT\n", __LINE__,
+		     __func__);
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+
+    VLOG(TRACE, "[-] [%d]%s.coreIdx:%d.firmware:%p.size:%d\n",__LINE__,__func__,coreIdx,firmware,size);
+    return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuReInit(Uint32 coreIdx, void *firmware, Uint32 size)
+{
+	vpu_buffer_t vb;
+	PhysicalAddress tempBuffer;
+	PhysicalAddress paraBuffer;
+	PhysicalAddress codeBuffer;
+	PhysicalAddress oldCodeBuffer;
+
+	osal_memset((void *)&vb, 0, sizeof(vpu_buffer_t));
+	Coda9VpuSetVeProtMode((unsigned long)coreIdx, FALSE, NULL, NULL);
+	vdi_get_common_memory((unsigned long)coreIdx, &vb);
+
+	codeBuffer = vb.phys_addr;
+	tempBuffer = codeBuffer + CODE_BUF_SIZE;
+	paraBuffer = tempBuffer + TEMP_BUF_SIZE;
+
+	oldCodeBuffer = VpuReadReg(coreIdx, BIT_CODE_BUF_ADDR);
+
+	VpuWriteReg(coreIdx, BIT_PARA_BUF_ADDR, paraBuffer);
+	VpuWriteReg(coreIdx, BIT_CODE_BUF_ADDR, codeBuffer);
+	VpuWriteReg(coreIdx, BIT_TEMP_BUF_ADDR, tempBuffer);
+
+	if (oldCodeBuffer != codeBuffer) {
+		LoadBitCode(coreIdx, codeBuffer, (const Uint16 *)firmware,
+			    size);
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+Uint32 Coda9VpuIsInit(Uint32 coreIdx)
+{
+	Uint32 pc;
+
+	pc = VpuReadReg(coreIdx, BIT_CUR_PC);
+
+	return pc;
+}
+
+Int32 Coda9VpuIsBusy(Uint32 coreIdx)
+{
+	return VpuReadReg(coreIdx, BIT_BUSY_FLAG);
+}
+
+Int32 Coda9VpuWaitInterrupt(CodecInst *handle, int timeout)
+{
+	Int32 reason = 0;
+	unsigned int addr = 0;
+	unsigned int boundary = 0;
+	unsigned int value = 0;
+#if defined(CODA9_CHECK_CODE_BUFFER_MD5SUM)
+	vpu_buffer_t vb;
+	unsigned char md5hash[16];
+#endif
+
+	reason = vdi_wait_interrupt(handle->coreIdx, timeout, BIT_INT_REASON);
+	VLOG(TRACE, "[%d]%s.h:0x%x.reason:0x%x\n", __LINE__, __func__, handle,
+	     reason);
+
+	if (reason == -1) {
+		handle->noInterruptCnt++;
+		VLOG(TRACE, "[%d]%s.h:0x%x.interrupt -1.cnt:%d\n", __LINE__,
+		     __func__, handle, handle->noInterruptCnt);
+		if (handle->noInterruptCnt > 100) {
+			VLOG(TRACE,
+			     "[%d]%s.h:0x%x.BIT_BUSY_FLAG:0x%x.BIT_CUR_PC:0x%x\n",
+			     __LINE__, __func__, handle,
+			     VpuReadReg(handle->coreIdx, BIT_BUSY_FLAG),
+			     VpuReadReg(handle->coreIdx, BIT_CUR_PC));
+
+#if defined(CODA9_CHECK_CODE_BUFFER_MD5SUM)
+			vdi_get_common_memory((unsigned long)handle->coreIdx,
+					      &vb);
+			VLOG(TRACE,
+			     "[%d]%s.codeBuffer(phys:0x%08x,virt:0x%08x).size:%d.BIT_CODE_BUF_ADDR:0x%08x\n",
+			     __LINE__, __func__, vb.phys_addr, vb.virt_addr,
+			     gCodaFwSize,
+			     VpuReadReg(handle->coreIdx, BIT_CODE_BUF_ADDR));
+			MD5(((unsigned char *)(vb.virt_addr)),
+			    (size_t)gCodaFwSize, md5hash);
+			VLOG(TRACE,
+			     "[%d]%s.codeBuffer Hash: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+			     __LINE__, __func__, md5hash[0], md5hash[1],
+			     md5hash[2], md5hash[3], md5hash[4], md5hash[5],
+			     md5hash[6], md5hash[7], md5hash[8], md5hash[9],
+			     md5hash[10], md5hash[11], md5hash[12], md5hash[13],
+			     md5hash[14], md5hash[15]);
+#endif
+		}
+		if ((handle->noInterruptCnt > 100) &&
+		    (handle->noInterruptCnt % 100 == 1)) {
+			VLOG(TRACE, "read register 0x98040000 ~ 0x98040200\n");
+			addr = BIT_BASE;
+			boundary = addr + 0x200;
+			while (addr <= boundary) {
+				value = VpuReadReg(handle->coreIdx, addr);
+				VLOG(TRACE, "[0x%08x] = 0x%08x.\n", addr,
+				     value);
+				addr += 4;
+			}
+
+			VLOG(TRACE, "read register 0x98043000 ~ 0x98043100\n");
+			addr = 0x98043000 - 0x98040000;
+			boundary = addr + 0x100;
+			while (addr <= boundary) {
+				value = VpuReadReg(handle->coreIdx, addr);
+				VLOG(TRACE, "[0x%08x] = 0x%08x.\n", addr,
+				     value);
+				addr += 4;
+			}
+		}
+	} else {
+		handle->noInterruptCnt = 0;
+	}
+
+	return reason;
+}
+
+RetCode Coda9VpuClearInterrupt(Uint32 coreIdx)
+{
+#ifdef GET_PERFORMANCE
+	gettimeofday(&end_tv, NULL);
+	unsigned int duration = 0;
+	if (start_dec_tv.tv_sec != 0) {
+		duration = (end_tv.tv_sec - start_dec_tv.tv_sec) * 1000 +
+			   (end_tv.tv_usec - start_dec_tv.tv_usec) / 1000;
+		if (duration > 3)
+			VLOG(TRACE,
+			     "[VPUAPI]  DEC time per frame : %d ms (cycle: %d)\n",
+			     duration, VpuReadReg(coreIdx, BIT_FRAME_CYCLE));
+	}
+	if (start_enc_tv.tv_sec != 0) {
+		duration = (end_tv.tv_sec - start_enc_tv.tv_sec) * 1000 +
+			   (end_tv.tv_usec - start_enc_tv.tv_usec) / 1000;
+		if (duration > 3)
+			VLOG(TRACE,
+			     "[VPUAPI]  ENC time per frame : %d ms (cycle: %d)\n",
+			     duration, VpuReadReg(coreIdx, BIT_FRAME_CYCLE));
+	}
+	memset(&start_dec_tv, 0, sizeof(start_dec_tv));
+	memset(&start_enc_tv, 0, sizeof(start_enc_tv));
+#endif
+
+#if 1
+	VpuWriteReg(coreIdx, BIT_INT_REASON,
+		    0); // tell to F/W that HOST received an interrupt.
+#else
+	(void)coreIdx; //unused
+#endif
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuReset(Uint32 coreIdx, SWResetMode resetMode)
+{
+	Uint32 cmd;
+	Int32 productId = Coda9VpuGetProductId(coreIdx);
+
+    VLOG(TRACE, "[+] [%d]%s.coreIdx:%d.resetMode:%d\n",__LINE__,__func__,coreIdx,resetMode);
+	if (productId == PRODUCT_ID_960 || productId == PRODUCT_ID_980) {
+		if (resetMode != SW_RESET_ON_BOOT) {
+			cmd = VpuReadReg(coreIdx, BIT_RUN_COMMAND);
+			if (cmd == DEC_SEQ_INIT || cmd == PIC_RUN) {
+				if (VpuReadReg(coreIdx, BIT_BUSY_FLAG) ||
+				    VpuReadReg(coreIdx, BIT_INT_REASON)) {
+#define MBC_SET_SUBBLK_EN                                                      \
+	(MBC_BASE + 0xA0) // subblk_man_mode[20] cr_subblk_man_en[19:0]
+					// stop all of pipeline
+					VpuWriteReg(coreIdx, MBC_SET_SUBBLK_EN,
+						    ((1 << 20) | 0));
+
+					// force to set the end of Bitstream to be decoded.
+					cmd = VpuReadReg(coreIdx,
+							 BIT_BIT_STREAM_PARAM);
+					cmd |= 1 << 2;
+					VpuWriteReg(coreIdx,
+						    BIT_BIT_STREAM_PARAM, cmd);
+
+					cmd = VpuReadReg(coreIdx, BIT_RD_PTR);
+					VpuWriteReg(coreIdx, BIT_WR_PTR, cmd);
+
+					cmd = vdi_wait_interrupt(
+						coreIdx, __VPU_BUSY_TIMEOUT,
+						BIT_INT_REASON);
+
+					if (cmd != INTERRUPT_TIMEOUT_VALUE) {
+						VpuWriteReg(coreIdx,
+							    BIT_INT_REASON, 0);
+						VpuWriteReg(
+							coreIdx, BIT_INT_CLEAR,
+							1); // clear HW signal
+					}
+					// now all of hardwares would be stop.
+				}
+			}
+		}
+
+		// Waiting for completion of BWB transaction first
+		if (vdi_wait_vpu_busy(coreIdx, __VPU_BUSY_TIMEOUT,
+				      GDI_BWB_STATUS) == -1) {
+			vdi_log(coreIdx, 0x10, 2);
+			VLOG(ERR, "[-] [%d]%s.RETCODE_VPU_RESPONSE_TIMEOUT\n",
+			     __LINE__, __func__);
+			return RETCODE_VPU_RESPONSE_TIMEOUT;
+		}
+
+		// Waiting for completion of bus transaction
+		// Step1 : No more request
+		VpuWriteReg(
+			coreIdx, GDI_BUS_CTRL,
+			0x11); // no more request {3'b0,no_more_req_sec,3'b0,no_more_req}
+
+		// Step2 : Waiting for completion of bus transaction
+		if (vdi_wait_bus_busy(coreIdx, __VPU_BUSY_TIMEOUT,
+				      GDI_BUS_STATUS) == -1) {
+			VpuWriteReg(coreIdx, GDI_BUS_CTRL, 0x00);
+			vdi_log(coreIdx, 0x10, 2);
+			VLOG(ERR, "[-] [%d]%s.RETCODE_VPU_RESPONSE_TIMEOUT\n",
+			     __LINE__, __func__);
+			return RETCODE_VPU_RESPONSE_TIMEOUT;
+		}
+
+		cmd = 0;
+		// Software Reset Trigger
+		if (resetMode != SW_RESET_ON_BOOT)
+			cmd = VPU_SW_RESET_BPU_CORE | VPU_SW_RESET_BPU_BUS;
+		cmd |= VPU_SW_RESET_VCE_CORE | VPU_SW_RESET_VCE_BUS;
+		if (resetMode == SW_RESET_ON_BOOT)
+			cmd |= VPU_SW_RESET_GDI_CORE |
+			       VPU_SW_RESET_GDI_BUS; // If you reset GDI, tiled map should be reconfigured
+
+		VpuWriteReg(coreIdx, BIT_SW_RESET, cmd);
+
+		// wait until reset is done
+		if (vdi_wait_vpu_busy(coreIdx, __VPU_BUSY_TIMEOUT,
+				      BIT_SW_RESET_STATUS) == -1) {
+			VpuWriteReg(coreIdx, BIT_SW_RESET, 0x00);
+			VpuWriteReg(coreIdx, GDI_BUS_CTRL, 0x00);
+			vdi_log(coreIdx, 0x10, 2);
+			VLOG(ERR, "[-] [%d]%s.RETCODE_VPU_RESPONSE_TIMEOUT\n",
+			     __LINE__, __func__);
+			return RETCODE_VPU_RESPONSE_TIMEOUT;
+		}
+
+		VpuWriteReg(coreIdx, BIT_SW_RESET, 0);
+
+		// Step3 : must clear GDI_BUS_CTRL after done SW_RESET
+		VpuWriteReg(coreIdx, GDI_BUS_CTRL, 0x00);
+	} else {
+		vdi_log(coreIdx, 0x10, 0);
+		VLOG(ERR, "[-] [%d]%s.RETCODE_NOT_FOUND_VPU_DEVICE\n", __LINE__,
+		     __func__);
+		return RETCODE_NOT_FOUND_VPU_DEVICE;
+	}
+
+    VLOG(TRACE, "[-] [%d]%s.coreIdx:%d.ret:RETCODE_SUCCESS\n",__LINE__,__func__,coreIdx);
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuSleepWake(Uint32 coreIdx, int iSleepWake, const Uint16 *code,
+			  Uint32 size)
+{
+	static unsigned int regBk[64];
+	int i = 0;
+	const Uint16 *bit_code = NULL;
+	if (code && size > 0)
+		bit_code = code;
+
+	if (!bit_code)
+		return RETCODE_INVALID_PARAM;
+
+	if (vdi_wait_vpu_busy(coreIdx, __VPU_BUSY_TIMEOUT, BIT_BUSY_FLAG) ==
+	    -1) {
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+
+	if (iSleepWake == 1) {
+		for (i = 0; i < 64; i++)
+			regBk[i] =
+				VpuReadReg(coreIdx, BIT_BASE + 0x100 + (i * 4));
+	} else {
+		VpuWriteReg(coreIdx, BIT_CODE_RUN, 0);
+
+		for (i = 0; i < 64; i++)
+			VpuWriteReg(coreIdx, BIT_BASE + 0x100 + (i * 4),
+				    regBk[i]);
+
+		VpuWriteReg(coreIdx, BIT_BUSY_FLAG, 1);
+		VpuWriteReg(coreIdx, BIT_CODE_RESET, 1);
+		VpuWriteReg(coreIdx, BIT_CODE_RUN, 1);
+
+		if (vdi_wait_vpu_busy(coreIdx, __VPU_BUSY_TIMEOUT,
+				      BIT_BUSY_FLAG) == -1) {
+			return RETCODE_VPU_RESPONSE_TIMEOUT;
+		}
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+static RetCode SetupDecCodecInstance(Int32 productId, CodecInst *pCodec)
+{
+	DecInfo *pDecInfo = &pCodec->CodecInfo->decInfo;
+
+	pDecInfo->streamRdPtrRegAddr = BIT_RD_PTR;
+	pDecInfo->streamWrPtrRegAddr = BIT_WR_PTR;
+	pDecInfo->frameDisplayFlagRegAddr = BIT_FRM_DIS_FLG;
+	pDecInfo->currentPC = BIT_CUR_PC;
+	pDecInfo->busyFlagAddr = BIT_BUSY_FLAG;
+
+	if (productId == PRODUCT_ID_960) {
+		pDecInfo->dramCfg.rasBit = EM_RAS;
+		pDecInfo->dramCfg.casBit = EM_CAS;
+		pDecInfo->dramCfg.bankBit = EM_BANK;
+		pDecInfo->dramCfg.busBit = EM_WIDTH;
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+static RetCode SetupEncCodecInstance(Int32 productId, CodecInst *pCodec)
+{
+	EncInfo *pEncInfo = &pCodec->CodecInfo->encInfo;
+
+	pEncInfo->streamRdPtrRegAddr = BIT_RD_PTR;
+	pEncInfo->streamWrPtrRegAddr = BIT_WR_PTR;
+	pEncInfo->currentPC = BIT_CUR_PC;
+	pEncInfo->busyFlagAddr = BIT_BUSY_FLAG;
+
+	if (productId == PRODUCT_ID_960) {
+		pEncInfo->dramCfg.rasBit = EM_RAS;
+		pEncInfo->dramCfg.casBit = EM_CAS;
+		pEncInfo->dramCfg.bankBit = EM_BANK;
+		pEncInfo->dramCfg.busBit = EM_WIDTH;
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuBuildUpDecParam(CodecInst *pCodec, DecOpenParam *param)
+{
+	RetCode ret = RETCODE_SUCCESS;
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+	Uint32 i;
+	VpuAttr *pAttr;
+#endif
+	Uint32 coreIdx;
+	Uint32 productId;
+	DecInfo *pDecInfo = &pCodec->CodecInfo->decInfo;
+
+	coreIdx = pCodec->coreIdx;
+	productId = Coda9VpuGetProductId(coreIdx);
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+	pAttr = &g_VpuCoreAttributes[coreIdx];
+	pDecInfo->writeMemProtectCfg.numOfRegion =
+		pAttr->numberOfMemProtectRgns;
+	VLOG(INFO, "[%d]%s.numOfRegion:%d\n", __LINE__, __func__,
+	     pDecInfo->writeMemProtectCfg.numOfRegion);
+#endif
+
+	if ((ret = SetupDecCodecInstance(productId, pCodec)) != RETCODE_SUCCESS)
+		return ret;
+
+	if (param->vbWork.size) {
+		pDecInfo->vbWork = param->vbWork;
+		pDecInfo->workBufferAllocExt = 1;
+	} else {
+		pDecInfo->vbWork.size = WORK_BUF_SIZE;
+		if (pCodec->codecMode == AVC_DEC)
+			pDecInfo->vbWork.size += PS_SAVE_SIZE;
+
+		//ENABLE_TEE_DRM_FLOW
+		if (pCodec->isUseProtectBuffer)
+			pDecInfo->vbWork.req_spec_region = VE_SECURE_PROTECTION;
+		else
+			pDecInfo->vbWork.req_spec_region = 0;
+
+		if (vdi_allocate_dma_memory_no_mmap(pCodec->coreIdx,
+						    &pDecInfo->vbWork,
+						    pCodec->filp) < 0)
+			return RETCODE_INSUFFICIENT_RESOURCE;
+		VLOG(TRACE,
+		     "[%d]%s.vdi_allocate_dma_memory_no_mmap vbWork(0x%lx,0x%lx,0x%lx,%d,%d)\n",
+		     __LINE__, __func__, pDecInfo->vbWork.phys_addr,
+		     pDecInfo->vbWork.base, pDecInfo->vbWork.virt_addr,
+		     pDecInfo->vbWork.size, pDecInfo->vbWork.req_spec_region);
+
+		param->vbWork = pDecInfo->vbWork;
+		pDecInfo->workBufferAllocExt = 0;
+	}
+
+	if (productId == PRODUCT_ID_960) {
+		pDecInfo->dramCfg.bankBit = EM_BANK;
+		pDecInfo->dramCfg.casBit = EM_CAS;
+		pDecInfo->dramCfg.rasBit = EM_RAS;
+		pDecInfo->dramCfg.busBit = EM_WIDTH;
+	}
+
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+	for (i = 0; i < WPROT_DEC_MAX; i++)
+		pDecInfo->writeMemProtectCfg.decRegion[i].enable = 0;
+	ConfigDecWPROTRegion(
+		pCodec->coreIdx,
+		pDecInfo); // set common & PS or Work buffer memory protection
+#endif
+
+	return ret;
+}
+
+RetCode Coda9VpuDecInitSeq(DecHandle handle)
+{
+	CodecInst *pCodecInst = (CodecInst *)handle;
+	DecInfo *pDecInfo = &pCodecInst->CodecInfo->decInfo;
+	Uint32 val = 0;
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_SEQ_BB_START,
+		    pDecInfo->streamBufStartAddr);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_SEQ_BB_SIZE,
+		    pDecInfo->streamBufSize / 1024); // size in KBytes
+	Coda9VpuDecSetCommonAddress(pCodecInst);
+
+	if (pDecInfo->userDataEnable == TRUE) {
+		val = 0;
+		val |= (pDecInfo->userDataReportMode << 10);
+		val |= (pDecInfo->userDataEnable << 5);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_SEQ_USER_DATA_OPTION,
+			    val);
+		VpuWriteReg(pCodecInst->coreIdx,
+			    CMD_DEC_SEQ_USER_DATA_BASE_ADDR,
+			    pDecInfo->userDataBufAddr);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_SEQ_USER_DATA_BUF_SIZE,
+			    pDecInfo->userDataBufSize);
+	} else {
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_SEQ_USER_DATA_OPTION,
+			    0);
+		VpuWriteReg(pCodecInst->coreIdx,
+			    CMD_DEC_SEQ_USER_DATA_BASE_ADDR, 0);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_SEQ_USER_DATA_BUF_SIZE,
+			    0);
+	}
+	val = 0;
+
+	val |= (pDecInfo->reorderEnable << 1) & 0x2;
+
+	val |= (pDecInfo->openParam.mp4DeblkEnable & 0x1);
+	val |= (pDecInfo->avcErrorConcealMode << 2);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_SEQ_OPTION, val);
+
+	switch (pCodecInst->codecMode) {
+	case VC1_DEC:
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_SEQ_VC1_STREAM_FMT,
+			    (0 << 3) & 0x08);
+		break;
+	case MP4_DEC:
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_SEQ_MP4_ASP_CLASS,
+			    (VPU_GMC_PROCESS_METHOD << 3) |
+				    pDecInfo->openParam.mp4Class);
+		break;
+	case AVC_DEC:
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_SEQ_X264_MV_EN,
+			    VPU_AVC_X264_SUPPORT);
+		break;
+	}
+
+	if (pCodecInst->codecMode == AVC_DEC)
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_SEQ_SPP_CHUNK_SIZE,
+			    VPU_GBU_SIZE);
+
+	VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamWrPtrRegAddr,
+		    pDecInfo->streamWrPtr);
+	VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamRdPtrRegAddr,
+		    pDecInfo->streamRdPtr);
+
+	if (pCodecInst->productId == PRODUCT_ID_980 ||
+	    pCodecInst->productId == PRODUCT_ID_960) {
+		pDecInfo->streamEndflag &= ~(3 << 3);
+		if (pDecInfo->openParam.bitstreamMode ==
+		    BS_MODE_ROLLBACK) //rollback mode
+			pDecInfo->streamEndflag |= (1 << 3);
+		else if (pDecInfo->openParam.bitstreamMode == BS_MODE_PIC_END)
+			pDecInfo->streamEndflag |= (2 << 3);
+		else { // Interrupt Mode
+			if (pDecInfo->seqInitEscape) {
+				pDecInfo->streamEndflag |= (2 << 3);
+			}
+		}
+	}
+	VpuWriteReg(pCodecInst->coreIdx, BIT_BIT_STREAM_PARAM,
+		    pDecInfo->streamEndflag);
+
+	val = pDecInfo->openParam.streamEndian;
+	VpuWriteReg(pCodecInst->coreIdx, BIT_BIT_STREAM_CTRL, val);
+
+	if (pCodecInst->productId == PRODUCT_ID_980) {
+		val = 0;
+		val |= (pDecInfo->openParam.bwbEnable << 15);
+		val |= (pDecInfo->wtlMode << 17) |
+		       (pDecInfo->tiled2LinearMode << 13) | (FORMAT_420 << 6);
+		val |= ((pDecInfo->openParam.cbcrInterleave)
+			<< 2); // Interleave bit position is modified
+		val |= pDecInfo->openParam.frameEndian;
+		val |= pDecInfo->openParam.nv21 << 3;
+		VpuWriteReg(pCodecInst->coreIdx, BIT_FRAME_MEM_CTRL, val);
+	} else if (pCodecInst->productId == PRODUCT_ID_960) {
+		val = 0;
+		val |= (pDecInfo->wtlEnable << 17);
+		val |= (pDecInfo->openParam.bwbEnable << 12);
+		val |= ((pDecInfo->openParam.cbcrInterleave)
+			<< 2); // Interleave bit position is modified
+		val |= pDecInfo->openParam.frameEndian;
+		VpuWriteReg(pCodecInst->coreIdx, BIT_FRAME_MEM_CTRL, val);
+	} else {
+		return RETCODE_NOT_FOUND_VPU_DEVICE;
+	}
+
+	VpuWriteReg(pCodecInst->coreIdx, pDecInfo->frameDisplayFlagRegAddr, 0);
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst, DEC_SEQ_INIT);
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuFiniSeq(CodecInst *instance)
+{
+	Coda9BitIssueCommand(instance->coreIdx, instance, DEC_SEQ_END);
+	if (vdi_wait_vpu_busy(instance->coreIdx, __VPU_BUSY_TIMEOUT,
+			      BIT_BUSY_FLAG) == -1) {
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuDecode(CodecInst *instance, DecParam *param)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	Uint32 rotMir;
+	Int32 val;
+	vpu_instance_pool_t *vip;
+#if defined(CODA9_CHECK_CODE_BUFFER_MD5SUM)
+	vpu_buffer_t vb;
+	unsigned char md5hash[16];
+#endif
+
+	pCodecInst = instance;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(pCodecInst->coreIdx);
+	if (!vip) {
+		return RETCODE_INVALID_HANDLE;
+	}
+
+#if defined(CODA9_CHECK_CODE_BUFFER_MD5SUM)
+	vdi_get_common_memory((unsigned long)instance->coreIdx, &vb);
+	VLOG(TRACE,
+	     "[%d]%s.codeBuffer(phys:0x%08x,virt:0x%08x).size:%d.BIT_CODE_BUF_ADDR:0x%08x\n",
+	     __LINE__, __func__, vb.phys_addr, vb.virt_addr, gCodaFwSize,
+	     VpuReadReg(instance->coreIdx, BIT_CODE_BUF_ADDR));
+	MD5(((unsigned char *)(vb.virt_addr)), (size_t)gCodaFwSize, md5hash);
+	VLOG(TRACE,
+	     "[%d]%s.codeBuffer Hash: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+	     __LINE__, __func__, md5hash[0], md5hash[1], md5hash[2], md5hash[3],
+	     md5hash[4], md5hash[5], md5hash[6], md5hash[7], md5hash[8],
+	     md5hash[9], md5hash[10], md5hash[11], md5hash[12], md5hash[13],
+	     md5hash[14], md5hash[15]);
+#endif
+
+	Coda9VpuDecSetCommonAddress(instance);
+
+	rotMir = 0;
+	if (pDecInfo->rotationEnable) {
+		rotMir |= 0x10; // Enable rotator
+		switch (pDecInfo->rotationAngle) {
+		case 0:
+			rotMir |= 0x0;
+			break;
+
+		case 90:
+			rotMir |= 0x1;
+			break;
+
+		case 180:
+			rotMir |= 0x2;
+			break;
+
+		case 270:
+			rotMir |= 0x3;
+			break;
+		}
+	}
+
+	if (pDecInfo->mirrorEnable) {
+		rotMir |= 0x10; // Enable rotator
+		switch (pDecInfo->mirrorDirection) {
+		case MIRDIR_NONE:
+			rotMir |= 0x0;
+			break;
+
+		case MIRDIR_VER:
+			rotMir |= 0x4;
+			break;
+
+		case MIRDIR_HOR:
+			rotMir |= 0x8;
+			break;
+
+		case MIRDIR_HOR_VER:
+			rotMir |= 0xc;
+			break;
+		}
+	}
+
+	if (pDecInfo->tiled2LinearEnable) {
+		rotMir |= 0x10;
+	}
+
+	if (pDecInfo->deringEnable) {
+		rotMir |= 0x20; // Enable Dering Filter
+	}
+
+	if (rotMir && !pDecInfo->rotatorOutputValid) {
+		return RETCODE_ROTATOR_OUTPUT_NOT_SET;
+	}
+
+	VpuWriteReg(pCodecInst->coreIdx, RET_DEC_PIC_CROP_LEFT_RIGHT,
+		    0); // frame crop information(left, right)
+	VpuWriteReg(pCodecInst->coreIdx, RET_DEC_PIC_CROP_TOP_BOTTOM,
+		    0); // frame crop information(top, bottom)
+
+	if (pCodecInst->productId == PRODUCT_ID_960) {
+		if (pDecInfo->mapType > LINEAR_FRAME_MAP &&
+		    pDecInfo->mapType <= TILED_MIXED_V_MAP) {
+			SetTiledFrameBase(pCodecInst->coreIdx,
+					  pDecInfo->mapCfg.tiledBaseAddr);
+		} else {
+			SetTiledFrameBase(pCodecInst->coreIdx, 0);
+		}
+	}
+
+	if (pDecInfo->mapType != LINEAR_FRAME_MAP &&
+	    pDecInfo->mapType != LINEAR_FIELD_MAP) {
+		val = SetTiledMapType(
+			pCodecInst->coreIdx, &pDecInfo->mapCfg,
+			pDecInfo->mapType,
+			(pDecInfo->stride > pDecInfo->frameBufferHeight) ?
+				pDecInfo->stride :
+				pDecInfo->frameBufferHeight,
+			pDecInfo->openParam.cbcrInterleave, &pDecInfo->dramCfg);
+	} else {
+		val = SetTiledMapType(pCodecInst->coreIdx, &pDecInfo->mapCfg,
+				      pDecInfo->mapType, pDecInfo->stride,
+				      pDecInfo->openParam.cbcrInterleave,
+				      &pDecInfo->dramCfg);
+	}
+	if (val == 0) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	if (rotMir & 0x30) { // rotator or dering or tiled2linear enabled
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PIC_ROT_MODE, rotMir);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PIC_ROT_INDEX,
+			    pDecInfo->rotatorOutput.myIndex);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PIC_ROT_ADDR_Y,
+			    pDecInfo->rotatorOutput.bufY);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PIC_ROT_ADDR_CB,
+			    pDecInfo->rotatorOutput.bufCb);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PIC_ROT_ADDR_CR,
+			    pDecInfo->rotatorOutput.bufCr);
+		if (pCodecInst->productId == PRODUCT_ID_980) {
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_DEC_PIC_ROT_BOTTOM_Y,
+				    pDecInfo->rotatorOutput.bufYBot);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_DEC_PIC_ROT_BOTTOM_CB,
+				    pDecInfo->rotatorOutput.bufCbBot);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_DEC_PIC_ROT_BOTTOM_CR,
+				    pDecInfo->rotatorOutput.bufCrBot);
+		}
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PIC_ROT_STRIDE,
+			    pDecInfo->rotatorStride);
+	} else {
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PIC_ROT_MODE, rotMir);
+	}
+	if (pDecInfo->userDataEnable) {
+		VpuWriteReg(pCodecInst->coreIdx,
+			    CMD_DEC_PIC_USER_DATA_BASE_ADDR,
+			    pDecInfo->userDataBufAddr);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PIC_USER_DATA_BUF_SIZE,
+			    pDecInfo->userDataBufSize);
+	} else {
+		VpuWriteReg(pCodecInst->coreIdx,
+			    CMD_DEC_PIC_USER_DATA_BASE_ADDR, 0);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PIC_USER_DATA_BUF_SIZE,
+			    0);
+	}
+
+	val = 0;
+	if (param->iframeSearchEnable ==
+	    TRUE) { // if iframeSearch is Enable, other bit is ignore;
+		val |= (pDecInfo->userDataReportMode << 10);
+
+		if (pCodecInst->codecMode == AVC_DEC ||
+		    pCodecInst->codecMode == VC1_DEC) {
+			if (param->iframeSearchEnable == 1)
+				val |= (1 << 11) | (1 << 2);
+			else if (param->iframeSearchEnable == 2)
+				val |= (1 << 2);
+		} else {
+			val |= ((param->iframeSearchEnable & 0x1) << 2);
+		}
+	} else {
+		val |= (pDecInfo->userDataReportMode << 10);
+		val |= (pDecInfo->userDataEnable << 5);
+		val |= (param->skipframeMode << 3);
+	}
+
+	if (pCodecInst->productId == PRODUCT_ID_980) {
+		if (pCodecInst->codecMode == AVC_DEC &&
+		    pDecInfo->lowDelayInfo.lowDelayEn) {
+			val |= (pDecInfo->lowDelayInfo.lowDelayEn << 18);
+		}
+	}
+	if (pCodecInst->codecMode == MP2_DEC) {
+		val |= ((param->DecStdParam.mp2PicFlush & 1) << 15);
+	}
+	if (pCodecInst->codecMode == RV_DEC) {
+		val |= ((param->DecStdParam.rvDbkMode & 0x0f) << 16);
+	}
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PIC_OPTION, val);
+
+	if (pCodecInst->productId == PRODUCT_ID_980) {
+		if (pDecInfo->lowDelayInfo.lowDelayEn == TRUE) {
+			VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PIC_NUM_ROWS,
+				    pDecInfo->lowDelayInfo.numRows);
+		} else {
+			VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PIC_NUM_ROWS,
+				    0);
+		}
+	}
+
+	val = 0;
+
+	val = ((pDecInfo->secAxiInfo.u.coda9.useBitEnable & 0x01) << 0 |
+	       (pDecInfo->secAxiInfo.u.coda9.useIpEnable & 0x01) << 1 |
+	       (pDecInfo->secAxiInfo.u.coda9.useDbkYEnable & 0x01) << 2 |
+	       (pDecInfo->secAxiInfo.u.coda9.useDbkCEnable & 0x01) << 3 |
+	       (pDecInfo->secAxiInfo.u.coda9.useOvlEnable & 0x01) << 4 |
+	       (pDecInfo->secAxiInfo.u.coda9.useBtpEnable & 0x01) << 5 |
+	       (pDecInfo->secAxiInfo.u.coda9.useBitEnable & 0x01) << 8 |
+	       (pDecInfo->secAxiInfo.u.coda9.useIpEnable & 0x01) << 9 |
+	       (pDecInfo->secAxiInfo.u.coda9.useDbkYEnable & 0x01) << 10 |
+	       (pDecInfo->secAxiInfo.u.coda9.useDbkCEnable & 0x01) << 11 |
+	       (pDecInfo->secAxiInfo.u.coda9.useOvlEnable & 0x01) << 12 |
+	       (pDecInfo->secAxiInfo.u.coda9.useBtpEnable & 0x01) << 13);
+
+	VpuWriteReg(pCodecInst->coreIdx, BIT_AXI_SRAM_USE, val);
+
+	VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamWrPtrRegAddr,
+		    pDecInfo->streamWrPtr);
+	VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamRdPtrRegAddr,
+		    pDecInfo->streamRdPtr);
+
+	pDecInfo->streamEndflag &= ~(3 << 3);
+	if (pDecInfo->openParam.bitstreamMode ==
+	    BS_MODE_ROLLBACK) //rollback mode
+		pDecInfo->streamEndflag |= (1 << 3);
+	else if (pDecInfo->openParam.bitstreamMode == BS_MODE_PIC_END)
+		pDecInfo->streamEndflag |= (2 << 3);
+
+	VpuWriteReg(pCodecInst->coreIdx, BIT_BIT_STREAM_PARAM,
+		    pDecInfo->streamEndflag);
+
+	if (pCodecInst->productId == PRODUCT_ID_980) {
+		val = 0;
+		val |= (pDecInfo->openParam.bwbEnable << 15);
+		val |= (pDecInfo->wtlMode << 17) |
+		       (pDecInfo->tiled2LinearMode << 13) |
+		       (pDecInfo->mapType << 9) | (FORMAT_420 << 6);
+		if (pDecInfo->openParam.cbcrInterleave == 1)
+			val |= pDecInfo->openParam.nv21 << 3;
+	} else if (pCodecInst->productId == PRODUCT_ID_960) {
+		val = 0;
+		val |= (pDecInfo->wtlEnable << 17);
+		val |= (pDecInfo->openParam.bwbEnable << 12);
+		if (pDecInfo->mapType) {
+			if (pDecInfo->mapType == TILED_FRAME_MB_RASTER_MAP ||
+			    pDecInfo->mapType == TILED_FIELD_MB_RASTER_MAP)
+				val |= (pDecInfo->tiled2LinearEnable << 11) |
+				       (0x03 << 9) | (FORMAT_420 << 6);
+			else
+				val |= (pDecInfo->tiled2LinearEnable << 11) |
+				       (0x02 << 9) | (FORMAT_420 << 6);
+		}
+	} else {
+		return RETCODE_NOT_FOUND_VPU_DEVICE;
+	}
+
+	val |= ((pDecInfo->openParam.cbcrInterleave)
+		<< 2); // Interleave bit position is modified
+	val |= pDecInfo->openParam.frameEndian;
+	VpuWriteReg(pCodecInst->coreIdx, BIT_FRAME_MEM_CTRL, val);
+
+	val = pDecInfo->openParam.streamEndian;
+	VpuWriteReg(pCodecInst->coreIdx, BIT_BIT_STREAM_CTRL, val);
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_DELAY,
+		    pDecInfo->frameDelay); // SA5-1256
+
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst, PIC_RUN);
+
+#ifdef GET_PERFORMANCE
+	gettimeofday(&start_dec_tv, NULL);
+#endif
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuDecGetResult(CodecInst *instance, DecOutputInfo *result)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	Uint32 val = 0;
+
+	pCodecInst = instance;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, PIC_RUN, 0);
+
+	result->warnInfo = 0;
+	val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_SUCCESS);
+	result->decodingSuccess = val;
+	if (result->decodingSuccess & (1 << 31)) {
+		result->wprotErrReason =
+			VpuReadReg(pCodecInst->coreIdx, GDI_WPROT_ERR_RSN);
+		result->wprotErrAddress =
+			VpuReadReg(pCodecInst->coreIdx, GDI_WPROT_ERR_ADR);
+		return RETCODE_MEMORY_ACCESS_VIOLATION;
+	}
+
+	if (pCodecInst->codecMode == AVC_DEC) {
+		result->notSufficientPsBuffer = (val >> 3) & 0x1;
+		result->notSufficientSliceBuffer = (val >> 2) & 0x1;
+	}
+
+	result->chunkReuseRequired = 0;
+	if (pDecInfo->openParam.bitstreamMode == BS_MODE_PIC_END) {
+		switch (pCodecInst->codecMode) {
+		case AVC_DEC:
+			result->chunkReuseRequired =
+				((val >> 16) & 0x01); // in case of NPF frame
+			val = VpuReadReg(pCodecInst->coreIdx,
+					 RET_DEC_PIC_DECODED_IDX);
+			if (val == (Uint32)-1) {
+				result->chunkReuseRequired = TRUE;
+			}
+			break;
+		case MP2_DEC:
+		case MP4_DEC:
+			result->chunkReuseRequired = ((val >> 16) & 0x01);
+			break;
+		default:
+			break;
+		}
+	}
+
+	result->indexFrameDecoded =
+		VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_DECODED_IDX);
+	result->indexFrameDisplay =
+		VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_DISPLAY_IDX);
+	if (pDecInfo->mapType == LINEAR_FRAME_MAP) {
+		result->indexFrameDecodedForTiled = -1;
+		result->indexFrameDisplayForTiled = -1;
+	} else {
+		result->indexFrameDecodedForTiled = result->indexFrameDecoded;
+		result->indexFrameDisplayForTiled = result->indexFrameDisplay;
+	}
+
+	val = VpuReadReg(pCodecInst->coreIdx,
+			 RET_DEC_PIC_SIZE); // decoding picture size
+	result->decPicWidth = (val >> 16) & 0xFFFF;
+	result->decPicHeight = (val)&0xFFFF;
+
+	if (result->indexFrameDecoded >= 0 &&
+	    result->indexFrameDecoded < MAX_GDI_IDX) {
+		switch (pCodecInst->codecMode) {
+		case VPX_DEC:
+			if (pCodecInst->codecModeAux == VPX_AUX_VP8) {
+				// VP8 specific header information
+				// h_scale[31:30] v_scale[29:28] pic_width[27:14] pic_height[13:0]
+				val = VpuReadReg(pCodecInst->coreIdx,
+						 RET_DEC_PIC_VP8_SCALE_INFO);
+				result->vp8ScaleInfo.hScaleFactor =
+					(val >> 30) & 0x03;
+				result->vp8ScaleInfo.vScaleFactor =
+					(val >> 28) & 0x03;
+				result->vp8ScaleInfo.picWidth =
+					(val >> 14) & 0x3FFF;
+				result->vp8ScaleInfo.picHeight =
+					(val >> 0) & 0x3FFF;
+				// ref_idx_gold[31:24], ref_idx_altr[23:16], ref_idx_last[15: 8],
+				// version_number[3:1], show_frame[0]
+				val = VpuReadReg(pCodecInst->coreIdx,
+						 RET_DEC_PIC_VP8_PIC_REPORT);
+				result->vp8PicInfo.refIdxGold =
+					(val >> 24) & 0x0FF;
+				result->vp8PicInfo.refIdxAltr =
+					(val >> 16) & 0x0FF;
+				result->vp8PicInfo.refIdxLast =
+					(val >> 8) & 0x0FF;
+				result->vp8PicInfo.versionNumber =
+					(val >> 1) & 0x07;
+				result->vp8PicInfo.showFrame =
+					(val >> 0) & 0x01;
+			}
+			break;
+		case AVC_DEC:
+		case AVS_DEC: /* RTK need to check*/
+			val = VpuReadReg(
+				pCodecInst->coreIdx,
+				RET_DEC_PIC_CROP_LEFT_RIGHT); // frame crop information(left, right)
+			pDecInfo->initialInfo.picCropRect.left =
+				(val >> 16) & 0xffff;
+			pDecInfo->initialInfo.picCropRect.right =
+				pDecInfo->initialInfo.picWidth - (val & 0xffff);
+			val = VpuReadReg(
+				pCodecInst->coreIdx,
+				RET_DEC_PIC_CROP_TOP_BOTTOM); // frame crop information(top, bottom)
+			pDecInfo->initialInfo.picCropRect.top =
+				(val >> 16) & 0xffff;
+			pDecInfo->initialInfo.picCropRect.bottom =
+				pDecInfo->initialInfo.picHeight -
+				(val & 0xffff);
+			break;
+		case MP2_DEC:
+			val = VpuReadReg(pCodecInst->coreIdx,
+					 RET_DEC_SEQ_MP2_BAR_LEFT_RIGHT);
+			pDecInfo->initialInfo.mp2BardataInfo.barLeft =
+				((val >> 16) & 0xFFFF);
+			pDecInfo->initialInfo.mp2BardataInfo.barRight =
+				(val & 0xFFFF);
+			val = VpuReadReg(pCodecInst->coreIdx,
+					 RET_DEC_SEQ_MP2_BAR_TOP_BOTTOM);
+			pDecInfo->initialInfo.mp2BardataInfo.barTop =
+				((val >> 16) & 0xFFFF);
+			pDecInfo->initialInfo.mp2BardataInfo.barBottom =
+				(val & 0xFFFF);
+			result->mp2BardataInfo =
+				pDecInfo->initialInfo.mp2BardataInfo;
+
+			result->mp2PicDispExtInfo.offsetNum =
+				VpuReadReg(pCodecInst->coreIdx,
+					   RET_DEC_PIC_MP2_OFFSET_NUM);
+
+			val = VpuReadReg(pCodecInst->coreIdx,
+					 RET_DEC_PIC_MP2_OFFSET1);
+			result->mp2PicDispExtInfo.horizontalOffset1 =
+				(Int16)(val >> 16) & 0xFFFF;
+			result->mp2PicDispExtInfo.verticalOffset1 =
+				(Int16)(val & 0xFFFF);
+
+			val = VpuReadReg(pCodecInst->coreIdx,
+					 RET_DEC_PIC_MP2_OFFSET2);
+			result->mp2PicDispExtInfo.horizontalOffset2 =
+				(Int16)(val >> 16) & 0xFFFF;
+			result->mp2PicDispExtInfo.verticalOffset2 =
+				(Int16)(val & 0xFFFF);
+
+			val = VpuReadReg(pCodecInst->coreIdx,
+					 RET_DEC_PIC_MP2_OFFSET3);
+			result->mp2PicDispExtInfo.horizontalOffset3 =
+				(Int16)(val >> 16) & 0xFFFF;
+			result->mp2PicDispExtInfo.verticalOffset3 =
+				(Int16)(val & 0xFFFF);
+			break;
+		}
+	}
+
+	val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_TYPE);
+	result->interlacedFrame = (val >> 18) & 0x1;
+	result->topFieldFirst = (val >> 21) & 0x0001; // TopFieldFirst[21]
+	if (result->interlacedFrame) {
+		result->picTypeFirst =
+			(val & 0x38) >> 3; // pic_type of 1st field
+		result->picType = val & 7; // pic_type of 2nd field
+	} else {
+		result->picTypeFirst = PIC_TYPE_MAX; // no meaning
+		result->picType = val & 7;
+	}
+
+	result->pictureStructure =
+		(val >> 19) & 0x0003; // MbAffFlag[17], FieldPicFlag[16]
+	result->repeatFirstField = (val >> 22) & 0x0001;
+	result->progressiveFrame = (val >> 23) & 0x0003;
+
+	if (pCodecInst->codecMode == AVC_DEC) {
+		result->nalRefIdc =
+			(val >> 7) & 0x0003; // RTHA-152, gregory add
+		result->decFrameInfo = (val >> 15) & 0x0001;
+		result->picStrPresent = (val >> 27) & 0x0001;
+		result->picTimingStruct = (val >> 28) & 0x000f;
+		//update picture type when IDR frame
+		if (val & 0x40) { // 6th bit
+			if (result->interlacedFrame)
+				result->picTypeFirst = PIC_TYPE_IDR;
+			else
+				result->picType = PIC_TYPE_IDR;
+		}
+		result->decFrameInfo = (val >> 16) & 0x0003;
+		if (result->indexFrameDisplay >= 0) {
+			if (result->indexFrameDisplay ==
+			    result->indexFrameDecoded)
+				result->avcNpfFieldInfo = result->decFrameInfo;
+			else
+				result->avcNpfFieldInfo =
+					pDecInfo->decOutInfo
+						[result->indexFrameDisplay]
+							.decFrameInfo;
+		}
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_HRD_INFO);
+		result->avcHrdInfo.cpbMinus1 = val >> 2;
+		result->avcHrdInfo.vclHrdParamFlag = (val >> 1) & 1;
+		result->avcHrdInfo.nalHrdParamFlag = val & 1;
+
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_VUI_INFO);
+		result->avcVuiInfo.fixedFrameRateFlag = val & 1;
+		result->avcVuiInfo.timingInfoPresent = (val >> 1) & 0x01;
+		result->avcVuiInfo.chromaLocBotField = (val >> 2) & 0x07;
+		result->avcVuiInfo.chromaLocTopField = (val >> 5) & 0x07;
+		result->avcVuiInfo.chromaLocInfoPresent = (val >> 8) & 0x01;
+		result->avcVuiInfo.colorPrimaries = (val >> 16) & 0xff;
+		result->avcVuiInfo.colorDescPresent = (val >> 24) & 0x01;
+		result->avcVuiInfo.isExtSAR = (val >> 25) & 0x01;
+		result->avcVuiInfo.vidFullRange = (val >> 26) & 0x01;
+		result->avcVuiInfo.vidFormat = (val >> 27) & 0x07;
+		result->avcVuiInfo.vidSigTypePresent = (val >> 30) & 0x01;
+		result->avcVuiInfo.vuiParamPresent = (val >> 31) & 0x01;
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_VUI_INFO_2);
+		result->avcVuiInfo.vuiMatrixCoefficients = val & 0xff;
+		result->avcVuiInfo.vuiTransferCharacteristics =
+			(val >> 8) & 0xff;
+		val = VpuReadReg(pCodecInst->coreIdx,
+				 RET_DEC_PIC_VUI_PIC_STRUCT);
+		result->avcVuiInfo.vuiPicStructPresent = (val & 0x1);
+		result->avcVuiInfo.vuiPicStruct = (val >> 1);
+	}
+
+	if (pCodecInst->codecMode == MP2_DEC) {
+		result->fieldSequence = (val >> 25) & 0x0007;
+		result->frameDct = (val >> 28) & 0x0001;
+		result->progressiveSequence = (val >> 29) & 0x0001;
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_VUI_INFO_2);
+		result->mp2ColorPrimaries = (val >> 16) & 0xff;
+		result->mp2TransferChar = (val >> 8) & 0xff;
+		result->mp2MatrixCoeff = val & 0xff;
+	}
+
+	result->fRateNumerator = VpuReadReg(
+		pCodecInst->coreIdx,
+		RET_DEC_PIC_FRATE_NR); //Frame rate, Aspect ratio can be changed frame by frame.
+	result->fRateDenominator =
+		VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_FRATE_DR);
+	if (pCodecInst->codecMode == AVC_DEC && result->fRateDenominator > 0)
+		result->fRateDenominator *= 2;
+	if (pCodecInst->codecMode == MP4_DEC) {
+		result->mp4ModuloTimeBase = VpuReadReg(
+			pCodecInst->coreIdx, RET_DEC_PIC_MODULO_TIME_BASE);
+		result->mp4TimeIncrement = VpuReadReg(
+			pCodecInst->coreIdx, RET_DEC_PIC_VOP_TIME_INCREMENT);
+	}
+
+	if (pCodecInst->codecMode == RV_DEC) {
+		result->rvTr =
+			VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_RV_TR);
+		result->rvTrB = VpuReadReg(pCodecInst->coreIdx,
+					   RET_DEC_PIC_RV_TR_BFRAME);
+	}
+
+	if (pCodecInst->codecMode == VPX_DEC) {
+		result->aspectRateInfo = 0;
+	} else {
+		result->aspectRateInfo =
+			VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_ASPECT);
+	}
+
+	// User Data
+	if (pDecInfo->userDataEnable) {
+		int userDataNum;
+		int userDataSize;
+		BYTE tempBuf[8] = {
+			0,
+		};
+
+		if (!pCodecInst->isUseProtectBuffer)
+			VpuReadMem(pCodecInst->coreIdx,
+				   pDecInfo->userDataBufAddr + 0, tempBuf, 8,
+				   VPU_USER_DATA_ENDIAN);
+
+		val = ((tempBuf[0] << 24) & 0xFF000000) |
+		      ((tempBuf[1] << 16) & 0x00FF0000) |
+		      ((tempBuf[2] << 8) & 0x0000FF00) |
+		      ((tempBuf[3] << 0) & 0x000000FF);
+
+		userDataNum = (val >> 16) & 0xFFFF;
+		userDataSize = (val >> 0) & 0xFFFF;
+		if (userDataNum == 0)
+			userDataSize = 0;
+
+		result->decOutputExtData.userDataNum = userDataNum;
+		result->decOutputExtData.userDataSize = userDataSize;
+
+		val = ((tempBuf[4] << 24) & 0xFF000000) |
+		      ((tempBuf[5] << 16) & 0x00FF0000) |
+		      ((tempBuf[6] << 8) & 0x0000FF00) |
+		      ((tempBuf[7] << 0) & 0x000000FF);
+
+		if (userDataNum == 0)
+			result->decOutputExtData.userDataBufFull = 0;
+		else
+			result->decOutputExtData.userDataBufFull =
+				(val >> 16) & 0xFFFF;
+
+		result->decOutputExtData.activeFormat =
+			VpuReadReg(pCodecInst->coreIdx,
+				   RET_DEC_PIC_ATSC_USER_DATA_INFO) &
+			0xf;
+	}
+
+	result->numOfErrMBs =
+		VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_ERR_MB);
+	val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_SUCCESS);
+	result->sequenceChanged = ((val >> 20) & 0x1);
+	result->streamEndFlag = ((pDecInfo->streamEndflag >> 2) & 0x01);
+
+	if (pCodecInst->codecMode == AVS_DEC) {
+		Uint32 val = (Uint32)result->numOfErrMBs;
+		result->numOfErrMBs = (int)(val & 0x00ffffff);
+		result->errorReason = (val >> 24) & 0xff;
+	}
+	if (pCodecInst->codecMode == VC1_DEC &&
+	    result->indexFrameDisplay != -3) {
+		if (pDecInfo->vc1BframeDisplayValid == 0) {
+			if (result->picType == 2) {
+				result->indexFrameDisplay = -3;
+			} else {
+				pDecInfo->vc1BframeDisplayValid = 1;
+			}
+		}
+	}
+	if (pCodecInst->codecMode == AVC_DEC &&
+	    pCodecInst->codecModeAux == AVC_AUX_MVC) {
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_MVC_REPORT);
+		result->mvcPicInfo.viewIdxDisplay = (val >> 0) & 1;
+		result->mvcPicInfo.viewIdxDecoded = (val >> 1) & 1;
+	}
+
+	if (pCodecInst->codecMode == AVC_DEC) {
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_AVC_FPA_SEI0);
+
+		if ((int)val < 0) {
+			result->avcFpaSei.exist = 0;
+		} else {
+			result->avcFpaSei.exist = 1;
+			result->avcFpaSei.framePackingArrangementId = val;
+
+			val = VpuReadReg(pCodecInst->coreIdx,
+					 RET_DEC_PIC_AVC_FPA_SEI1);
+			result->avcFpaSei.contentInterpretationType =
+				val & 0x3F; // [5:0]
+			result->avcFpaSei.framePackingArrangementType =
+				(val >> 6) & 0x7F; // [12:6]
+			result->avcFpaSei.framePackingArrangementExtensionFlag =
+				(val >> 13) & 0x01; // [13]
+			result->avcFpaSei.frame1SelfContainedFlag =
+				(val >> 14) & 0x01; // [14]
+			result->avcFpaSei.frame0SelfContainedFlag =
+				(val >> 15) & 0x01; // [15]
+			result->avcFpaSei.currentFrameIsFrame0Flag =
+				(val >> 16) & 0x01; // [16]
+			result->avcFpaSei.fieldViewsFlag =
+				(val >> 17) & 0x01; // [17]
+			result->avcFpaSei.frame0FlippedFlag =
+				(val >> 18) & 0x01; // [18]
+			result->avcFpaSei.spatialFlippingFlag =
+				(val >> 19) & 0x01; // [19]
+			result->avcFpaSei.quincunxSamplingFlag =
+				(val >> 20) & 0x01; // [20]
+			result->avcFpaSei.framePackingArrangementCancelFlag =
+				(val >> 21) & 0x01; // [21]
+
+			val = VpuReadReg(pCodecInst->coreIdx,
+					 RET_DEC_PIC_AVC_FPA_SEI2);
+			result->avcFpaSei
+				.framePackingArrangementRepetitionPeriod =
+				val & 0x7FFF; // [14:0]
+			result->avcFpaSei.frame1GridPositionY =
+				(val >> 16) & 0x0F; // [19:16]
+			result->avcFpaSei.frame1GridPositionX =
+				(val >> 20) & 0x0F; // [23:20]
+			result->avcFpaSei.frame0GridPositionY =
+				(val >> 24) & 0x0F; // [27:24]
+			result->avcFpaSei.frame0GridPositionX =
+				(val >> 28) & 0x0F; // [31:28]
+		}
+
+		result->avcPocTop =
+			VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_POC_TOP);
+		result->avcPocBot =
+			VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_POC_BOT);
+
+		if (result->interlacedFrame) {
+			if (result->avcPocTop > result->avcPocBot) {
+				result->avcPocPic = result->avcPocBot;
+			} else {
+				result->avcPocPic = result->avcPocTop;
+			}
+		} else
+			result->avcPocPic = VpuReadReg(pCodecInst->coreIdx,
+						       RET_DEC_PIC_POC);
+	}
+
+	if (pCodecInst->codecMode == AVC_DEC) {
+		val = VpuReadReg(pCodecInst->coreIdx,
+				 RET_DEC_PIC_AVC_SEI_RP_INFO);
+
+		if ((int)val < 0) {
+			result->avcRpSei.exist = 0;
+		} else {
+			result->avcRpSei.exist = 1;
+			result->avcRpSei.changingSliceGroupIdc =
+				val & 0x3; // [1:0]
+			result->avcRpSei.brokenLinkFlag =
+				(val >> 2) & 0x01; // [2]
+			result->avcRpSei.exactMatchFlag =
+				(val >> 3) & 0x01; // [3]
+			result->avcRpSei.recoveryFrameCnt =
+				(val >> 4) & 0x3F; // [9:4]
+		}
+	}
+
+	result->bytePosFrameStart =
+		VpuReadReg(pCodecInst->coreIdx, BIT_BYTE_POS_FRAME_START);
+	result->bytePosFrameEnd =
+		VpuReadReg(pCodecInst->coreIdx, BIT_BYTE_POS_FRAME_END);
+
+	if (result->indexFrameDecoded >= 0 &&
+	    result->indexFrameDecoded < MAX_GDI_IDX)
+		pDecInfo->decOutInfo[result->indexFrameDecoded] = *result;
+
+	result->frameDisplayFlag = pDecInfo->frameDisplayFlag;
+	result->frameCycle = VpuReadReg(pCodecInst->coreIdx, BIT_FRAME_CYCLE);
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuDecSetBitstreamFlag(CodecInst *instance, BOOL running, BOOL eos)
+{
+	Uint32 val;
+	DecInfo *pDecInfo;
+
+	pDecInfo = &instance->CodecInfo->decInfo;
+
+	if (eos & 0x01) {
+		val = VpuReadReg(instance->coreIdx, BIT_BIT_STREAM_PARAM);
+		val |= 1 << 2;
+		pDecInfo->streamEndflag = val;
+		if (running == TRUE)
+			VpuWriteReg(instance->coreIdx, BIT_BIT_STREAM_PARAM,
+				    val);
+		return RETCODE_SUCCESS;
+	} else {
+		val = VpuReadReg(instance->coreIdx, BIT_BIT_STREAM_PARAM);
+		val &= ~(1 << 2);
+		pDecInfo->streamEndflag = val;
+		if (running == TRUE)
+			VpuWriteReg(instance->coreIdx, BIT_BIT_STREAM_PARAM,
+				    val);
+
+		return RETCODE_SUCCESS;
+	}
+}
+
+RetCode Coda9VpuDecCpbFlush(CodecInst *instance)
+{
+	Uint32 val;
+	DecInfo *pDecInfo;
+
+	pDecInfo = &instance->CodecInfo->decInfo;
+
+	if (pDecInfo->openParam.bitstreamMode != BS_MODE_INTERRUPT) {
+		return RETCODE_INVALID_COMMAND;
+	}
+
+	val = VpuReadReg(instance->coreIdx, BIT_BIT_STREAM_PARAM);
+	val &= ~(3 << 3);
+	val |= (2 << 3); // set to pic_end mode
+	VpuWriteReg(instance->coreIdx, BIT_BIT_STREAM_PARAM, val);
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuDecGetSeqInfo(CodecInst *instance, DecInitialInfo *info)
+{
+	CodecInst *pCodecInst = NULL;
+	DecInfo *pDecInfo = NULL;
+	Uint32 val, val2;
+
+	pCodecInst = instance;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	if (pCodecInst->loggingEnable) {
+		vdi_log(pCodecInst->coreIdx, DEC_SEQ_INIT, 0);
+	}
+
+	info->warnInfo = 0;
+	if (pDecInfo->openParam.bitstreamMode == BS_MODE_INTERRUPT &&
+	    pDecInfo->seqInitEscape) {
+		pDecInfo->streamEndflag &= ~(3 << 3);
+		VpuWriteReg(pCodecInst->coreIdx, BIT_BIT_STREAM_PARAM,
+			    pDecInfo->streamEndflag);
+		pDecInfo->seqInitEscape = 0;
+	}
+	pDecInfo->streamRdPtr =
+		VpuReadReg(instance->coreIdx, pDecInfo->streamRdPtrRegAddr);
+	pDecInfo->frameDisplayFlag = VpuReadReg(
+		pCodecInst->coreIdx, pDecInfo->frameDisplayFlagRegAddr);
+	pDecInfo->streamEndflag =
+		VpuReadReg(pCodecInst->coreIdx, BIT_BIT_STREAM_PARAM);
+
+	info->seqInitErrReason = 0;
+	val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_SEQ_SUCCESS);
+	if (val & (1 << 31)) {
+		return RETCODE_MEMORY_ACCESS_VIOLATION;
+	}
+
+	if (pDecInfo->openParam.bitstreamMode == BS_MODE_PIC_END ||
+	    pDecInfo->openParam.bitstreamMode == BS_MODE_ROLLBACK) {
+		if (val & (1 << 4)) {
+			info->seqInitErrReason =
+				(VpuReadReg(pCodecInst->coreIdx,
+					    RET_DEC_SEQ_SEQ_ERR_REASON));
+			return RETCODE_FAILURE;
+		}
+	}
+
+	if (val == 0) {
+		info->seqInitErrReason = VpuReadReg(pCodecInst->coreIdx,
+						    RET_DEC_SEQ_SEQ_ERR_REASON);
+		return RETCODE_FAILURE;
+	}
+
+	val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_SEQ_SRC_SIZE);
+	info->picWidth = ((val >> 16) & 0xffff);
+	info->picHeight = (val & 0xffff);
+	info->lumaBitdepth = 8;
+	info->chromaBitdepth = 8;
+	info->fRateNumerator =
+		VpuReadReg(pCodecInst->coreIdx, RET_DEC_SEQ_FRATE_NR);
+	info->fRateDenominator =
+		VpuReadReg(pCodecInst->coreIdx, RET_DEC_SEQ_FRATE_DR);
+	if (pCodecInst->codecMode == AVC_DEC && info->fRateDenominator > 0) {
+		info->fRateDenominator *= 2;
+	}
+
+	if (pCodecInst->codecMode == MP4_DEC) {
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_SEQ_INFO);
+		info->mp4ShortVideoHeader = (val >> 2) & 1;
+		info->mp4DataPartitionEnable = val & 1;
+		info->mp4ReversibleVlcEnable =
+			info->mp4DataPartitionEnable ? ((val >> 1) & 1) : 0;
+		info->h263AnnexJEnable = (val >> 3) & 1;
+	} else if (pCodecInst->codecMode == VPX_DEC &&
+		   pCodecInst->codecModeAux == VPX_AUX_VP8) {
+		// h_scale[31:30] v_scale[29:28] pic_width[27:14] pic_height[13:0]
+		val = VpuReadReg(pCodecInst->coreIdx,
+				 RET_DEC_SEQ_VP8_SCALE_INFO);
+		info->vp8ScaleInfo.hScaleFactor = (val >> 30) & 0x03;
+		info->vp8ScaleInfo.vScaleFactor = (val >> 28) & 0x03;
+		info->vp8ScaleInfo.picWidth = (val >> 14) & 0x3FFF;
+		info->vp8ScaleInfo.picHeight = (val >> 0) & 0x3FFF;
+	}
+
+	info->minFrameBufferCount =
+		VpuReadReg(pCodecInst->coreIdx, RET_DEC_SEQ_FRAME_NEED);
+
+	info->frameBufDelay =
+		VpuReadReg(pCodecInst->coreIdx, RET_DEC_SEQ_FRAME_DELAY);
+
+	/* RTK need to check */
+	if (pCodecInst->codecMode == AVC_DEC ||
+	    pCodecInst->codecMode == MP2_DEC ||
+	    pCodecInst->codecMode == AVS_DEC) {
+		val = VpuReadReg(pCodecInst->coreIdx,
+				 RET_DEC_SEQ_CROP_LEFT_RIGHT);
+		val2 = VpuReadReg(pCodecInst->coreIdx,
+				  RET_DEC_SEQ_CROP_TOP_BOTTOM);
+
+		info->picCropRect.left = ((val >> 16) & 0xFFFF);
+		info->picCropRect.right = info->picWidth - (val & 0xFFFF);
+		;
+		info->picCropRect.top = ((val2 >> 16) & 0xFFFF);
+		info->picCropRect.bottom = info->picHeight - (val2 & 0xFFFF);
+
+		val = (info->picWidth * info->picHeight * 3 / 2) / 1024;
+		info->normalSliceSize = val / 4;
+		info->worstSliceSize = val / 2;
+	} else {
+		info->picCropRect.left = 0;
+		info->picCropRect.right = info->picWidth;
+		info->picCropRect.top = 0;
+		info->picCropRect.bottom = info->picHeight;
+	}
+
+	if (pCodecInst->codecMode == MP2_DEC) {
+		val = VpuReadReg(pCodecInst->coreIdx,
+				 RET_DEC_SEQ_MP2_BAR_LEFT_RIGHT);
+		val2 = VpuReadReg(pCodecInst->coreIdx,
+				  RET_DEC_SEQ_MP2_BAR_TOP_BOTTOM);
+
+		info->mp2BardataInfo.barLeft = ((val >> 16) & 0xFFFF);
+		info->mp2BardataInfo.barRight = (val & 0xFFFF);
+		info->mp2BardataInfo.barTop = ((val2 >> 16) & 0xFFFF);
+		info->mp2BardataInfo.barBottom = (val2 & 0xFFFF);
+	}
+
+	val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_SEQ_HEADER_REPORT);
+	info->profile = (val >> 0) & 0xFF;
+	info->level = (val >> 8) & 0xFF;
+	info->interlace = (val >> 16) & 0x01;
+	info->direct8x8Flag = (val >> 17) & 0x01;
+	info->vc1Psf = (val >> 18) & 0x01;
+	info->constraint_set_flag[0] = (val >> 19) & 0x01;
+	info->constraint_set_flag[1] = (val >> 20) & 0x01;
+	info->constraint_set_flag[2] = (val >> 21) & 0x01;
+	info->constraint_set_flag[3] = (val >> 22) & 0x01;
+	info->chromaFormatIDC = (val >> 23) & 0x03;
+	info->isExtSAR = (val >> 25) & 0x01;
+	info->maxNumRefFrm = (val >> 27) & 0x0f;
+	info->maxNumRefFrmFlag = (val >> 31) & 0x01;
+	val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_SEQ_ASPECT);
+	info->aspectRateInfo = val;
+
+	val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_SEQ_BIT_RATE);
+	info->bitRate = val;
+
+	if (pCodecInst->codecMode == AVC_DEC) {
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_SEQ_VUI_INFO);
+		info->avcVuiInfo.fixedFrameRateFlag = val & 1;
+		info->avcVuiInfo.timingInfoPresent = (val >> 1) & 0x01;
+		info->avcVuiInfo.chromaLocBotField = (val >> 2) & 0x07;
+		info->avcVuiInfo.chromaLocTopField = (val >> 5) & 0x07;
+		info->avcVuiInfo.chromaLocInfoPresent = (val >> 8) & 0x01;
+		info->avcVuiInfo.colorPrimaries = (val >> 16) & 0xff;
+		info->avcVuiInfo.colorDescPresent = (val >> 24) & 0x01;
+		info->avcVuiInfo.isExtSAR = (val >> 25) & 0x01;
+		info->avcVuiInfo.vidFullRange = (val >> 26) & 0x01;
+		info->avcVuiInfo.vidFormat = (val >> 27) & 0x07;
+		info->avcVuiInfo.vidSigTypePresent = (val >> 30) & 0x01;
+		info->avcVuiInfo.vuiParamPresent = (val >> 31) & 0x01;
+
+		val = VpuReadReg(pCodecInst->coreIdx,
+				 RET_DEC_SEQ_VUI_PIC_STRUCT);
+		info->avcVuiInfo.vuiPicStructPresent = (val & 0x1);
+		info->avcVuiInfo.vuiPicStruct = (val >> 1);
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_SEQ_VUI_INFO_2);
+		info->avcVuiInfo.vuiMatrixCoefficients = val & 0xff;
+		info->avcVuiInfo.vuiTransferCharacteristics = (val >> 8) & 0xff;
+	}
+
+	if (pCodecInst->codecMode == MP2_DEC) {
+		// seq_ext info
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_SEQ_EXT_INFO);
+		info->mp2LowDelay = val & 1;
+		info->mp2DispVerSize = (val >> 1) & 0x3fff;
+		info->mp2DispHorSize = (val >> 15) & 0x3fff;
+
+		if (pDecInfo->userDataEnable) {
+			Uint32 userDataNum = 0;
+			Uint32 userDataSize = 0;
+			BYTE tempBuf[8] = {
+				0,
+			};
+
+			// user data
+			VpuReadMem(pCodecInst->coreIdx,
+				   pDecInfo->userDataBufAddr, tempBuf, 8,
+				   VPU_USER_DATA_ENDIAN);
+
+			val = ((tempBuf[0] << 24) & 0xFF000000) |
+			      ((tempBuf[1] << 16) & 0x00FF0000) |
+			      ((tempBuf[2] << 8) & 0x0000FF00) |
+			      ((tempBuf[3] << 0) & 0x000000FF);
+
+			userDataNum = (val >> 16) & 0xFFFF;
+			userDataSize = (val >> 0) & 0xFFFF;
+			if (userDataNum == 0) {
+				userDataSize = 0;
+			}
+
+			info->userDataNum = userDataNum;
+			info->userDataSize = userDataSize;
+
+			val = ((tempBuf[4] << 24) & 0xFF000000) |
+			      ((tempBuf[5] << 16) & 0x00FF0000) |
+			      ((tempBuf[6] << 8) & 0x0000FF00) |
+			      ((tempBuf[7] << 0) & 0x000000FF);
+
+			if (userDataNum == 0) {
+				info->userDataBufFull = 0;
+			} else {
+				info->userDataBufFull = (val >> 16) & 0xFFFF;
+			}
+		}
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_SEQ_VUI_INFO_2);
+		info->mp2ColorPrimaries = (val >> 16) & 0xff;
+		info->mp2TransferChar = (val >> 8) & 0xff;
+		info->mp2MatrixCoeff = val & 0xff;
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	PhysicalAddress paraBuffer;
+	PhysicalAddress tempBuffer;
+	vpu_buffer_t vb;
+	Uint32 val;
+	int i;
+	BYTE frameAddr[MAX_GDI_IDX][3][4];
+	BYTE colMvAddr[MAX_GDI_IDX][4];
+
+	osal_memset((void *)&vb, 0, sizeof(vpu_buffer_t));
+	osal_memset((void *)frameAddr, 0, sizeof(frameAddr));
+	osal_memset((void *)colMvAddr, 0, sizeof(colMvAddr));
+	pCodecInst = instance;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	if (pCodecInst->isUseProtectBuffer) //RTK, need to review it
+	{
+		Coda9VpuSetVeProtMode(pCodecInst->coreIdx, TRUE,
+				      pCodecInst->sess, pCodecInst->rtk_sess);
+		vdi_get_common_memory_protect(pCodecInst->coreIdx, &vb,
+					      pCodecInst->filp);
+	} else {
+		Coda9VpuSetVeProtMode(pCodecInst->coreIdx, FALSE, NULL, NULL);
+		vdi_get_common_memory(pCodecInst->coreIdx, &vb);
+	}
+	tempBuffer = vb.phys_addr + CODE_BUF_SIZE;
+	paraBuffer = tempBuffer + TEMP_BUF_SIZE;
+	VpuWriteReg(pCodecInst->coreIdx, BIT_PARA_BUF_ADDR, paraBuffer);
+	VpuWriteReg(pCodecInst->coreIdx, BIT_TEMP_BUF_ADDR, tempBuffer);
+
+	pDecInfo->mapCfg.productId = pCodecInst->productId;
+
+	if (pDecInfo->mapType != LINEAR_FRAME_MAP &&
+	    pDecInfo->mapType != LINEAR_FIELD_MAP) {
+		val = SetTiledMapType(
+			pCodecInst->coreIdx, &pDecInfo->mapCfg,
+			pDecInfo->mapType,
+			(pDecInfo->stride > pDecInfo->frameBufferHeight) ?
+				pDecInfo->stride :
+				pDecInfo->frameBufferHeight,
+			pDecInfo->openParam.cbcrInterleave, &pDecInfo->dramCfg);
+	} else {
+		val = SetTiledMapType(pCodecInst->coreIdx, &pDecInfo->mapCfg,
+				      pDecInfo->mapType, pDecInfo->stride,
+				      pDecInfo->openParam.cbcrInterleave,
+				      &pDecInfo->dramCfg);
+	}
+
+	if (val == 0) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	//Allocate frame buffer
+	for (i = 0; i < pDecInfo->numFbsForDecoding; i++) {
+		frameAddr[i][0][0] =
+			(pDecInfo->frameBufPool[i].bufY >> 24) & 0xFF;
+		frameAddr[i][0][1] =
+			(pDecInfo->frameBufPool[i].bufY >> 16) & 0xFF;
+		frameAddr[i][0][2] =
+			(pDecInfo->frameBufPool[i].bufY >> 8) & 0xFF;
+		frameAddr[i][0][3] =
+			(pDecInfo->frameBufPool[i].bufY >> 0) & 0xFF;
+		if (pDecInfo->openParam.cbcrOrder == CBCR_ORDER_NORMAL) {
+			frameAddr[i][1][0] =
+				(pDecInfo->frameBufPool[i].bufCb >> 24) & 0xFF;
+			frameAddr[i][1][1] =
+				(pDecInfo->frameBufPool[i].bufCb >> 16) & 0xFF;
+			frameAddr[i][1][2] =
+				(pDecInfo->frameBufPool[i].bufCb >> 8) & 0xFF;
+			frameAddr[i][1][3] =
+				(pDecInfo->frameBufPool[i].bufCb >> 0) & 0xFF;
+			frameAddr[i][2][0] =
+				(pDecInfo->frameBufPool[i].bufCr >> 24) & 0xFF;
+			frameAddr[i][2][1] =
+				(pDecInfo->frameBufPool[i].bufCr >> 16) & 0xFF;
+			frameAddr[i][2][2] =
+				(pDecInfo->frameBufPool[i].bufCr >> 8) & 0xFF;
+			frameAddr[i][2][3] =
+				(pDecInfo->frameBufPool[i].bufCr >> 0) & 0xFF;
+		} else {
+			frameAddr[i][2][0] =
+				(pDecInfo->frameBufPool[i].bufCb >> 24) & 0xFF;
+			frameAddr[i][2][1] =
+				(pDecInfo->frameBufPool[i].bufCb >> 16) & 0xFF;
+			frameAddr[i][2][2] =
+				(pDecInfo->frameBufPool[i].bufCb >> 8) & 0xFF;
+			frameAddr[i][2][3] =
+				(pDecInfo->frameBufPool[i].bufCb >> 0) & 0xFF;
+			frameAddr[i][1][0] =
+				(pDecInfo->frameBufPool[i].bufCr >> 24) & 0xFF;
+			frameAddr[i][1][1] =
+				(pDecInfo->frameBufPool[i].bufCr >> 16) & 0xFF;
+			frameAddr[i][1][2] =
+				(pDecInfo->frameBufPool[i].bufCr >> 8) & 0xFF;
+			frameAddr[i][1][3] =
+				(pDecInfo->frameBufPool[i].bufCr >> 0) & 0xFF;
+		}
+	}
+
+	if (pCodecInst->isUseProtectBuffer) //RTK, need to review it
+	{
+#ifdef ENABLE_TEE_DRM_FLOW
+		VLOG(TRACE,
+		     "[%d]%s.Coda9VpuWriteMem paraBuffer:0x%x with frameAddr.numFbsForDecoding:%d.sizeof(frameAddr):%d\n",
+		     __LINE__, __func__, paraBuffer,
+		     pDecInfo->numFbsForDecoding, sizeof(frameAddr));
+		Coda9VpuWriteMem(pCodecInst->coreIdx, paraBuffer,
+				 (BYTE *)frameAddr, sizeof(frameAddr),
+				 VDI_BIG_ENDIAN, pCodecInst->teeapi_ctx,
+				 pCodecInst->teeapi_tee_session);
+#else
+		VpuWriteMem(pCodecInst->coreIdx, paraBuffer, (BYTE *)frameAddr,
+			    sizeof(frameAddr), VDI_BIG_ENDIAN);
+#endif
+	} else {
+		VLOG(TRACE,
+		     "[%d]%s.VpuWriteMem paraBuffer:0x%x with frameAddr.numFbsForDecoding:%d.sizeof(frameAddr):%d\n",
+		     __LINE__, __func__, paraBuffer,
+		     pDecInfo->numFbsForDecoding, sizeof(frameAddr));
+		VpuWriteMem(pCodecInst->coreIdx, paraBuffer, (BYTE *)frameAddr,
+			    sizeof(frameAddr), VDI_BIG_ENDIAN);
+	}
+
+	// MV allocation and register
+	if (pCodecInst->codecMode == AVC_DEC ||
+	    pCodecInst->codecMode == VC1_DEC ||
+	    pCodecInst->codecMode == MP4_DEC ||
+	    pCodecInst->codecMode == RV_DEC ||
+	    pCodecInst->codecMode == AVS_DEC) {
+		int size_mvcolbuf;
+		vpu_buffer_t vbBuffer;
+		size_mvcolbuf = ((pDecInfo->initialInfo.picWidth + 31) & ~31) *
+				((pDecInfo->initialInfo.picHeight + 31) & ~31);
+		size_mvcolbuf = (size_mvcolbuf * 3) / 2;
+		size_mvcolbuf = (size_mvcolbuf + 4) / 5;
+		size_mvcolbuf = ((size_mvcolbuf + 7) / 8) * 8;
+		vbBuffer.size = size_mvcolbuf;
+		vbBuffer.phys_addr = 0;
+		for (i = 0; i < pDecInfo->numFbsForDecoding; i++) {
+			//ENABLE_TEE_DRM_FLOW
+			if (pCodecInst->isUseProtectBuffer)
+				vbBuffer.req_spec_region = VE_SECURE_PROTECTION;
+			else
+				vbBuffer.req_spec_region = 0;
+
+#ifdef DAH_222_PREALLOC_MV_SLICE_BUFFER
+			if (pDecInfo->vbMV[i].size == 0 ||
+			    pDecInfo->vbMV[i].size < vbBuffer.size)
+#else
+			if (pDecInfo->vbMV[i].size == 0)
+#endif
+			{
+#ifdef DAH_222_PREALLOC_MV_SLICE_BUFFER
+				if (pDecInfo->vbMV[i].size > 0 &&
+				    pDecInfo->vbMV[i].size < vbBuffer.size) {
+					VLOG(TRACE,
+					     "[%d]%s.vdi_free_dma_memory vbMV[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+					     __LINE__, __func__, i,
+					     pDecInfo->vbMV[i].phys_addr,
+					     pDecInfo->vbMV[i].base,
+					     pDecInfo->vbMV[i].virt_addr,
+					     pDecInfo->vbMV[i].size,
+					     pDecInfo->vbMV[i].req_spec_region);
+					vdi_free_dma_memory(pCodecInst->coreIdx,
+							    &pDecInfo->vbMV[i]);
+				}
+#endif
+				if (vdi_allocate_dma_memory_no_mmap(
+					    pCodecInst->coreIdx, &vbBuffer,
+					    pCodecInst->filp) < 0) {
+
+					return RETCODE_FAILURE;
+				}
+				pDecInfo->vbMV[i] = vbBuffer;
+				VLOG(TRACE,
+				     "[%d]%s.vdi_allocate_dma_memory_no_mmap vbMV[%d](0x%lx,0x%lx,0x%lx,%d,%d)\n",
+				     __LINE__, __func__, i,
+				     pDecInfo->vbMV[i].phys_addr,
+				     pDecInfo->vbMV[i].base,
+				     pDecInfo->vbMV[i].virt_addr,
+				     pDecInfo->vbMV[i].size,
+				     pDecInfo->vbMV[i].req_spec_region);
+			}
+		}
+		if (pCodecInst->codecMode == AVC_DEC) {
+			for (i = 0; i < pDecInfo->numFbsForDecoding; i++) {
+				colMvAddr[i][0] =
+					(pDecInfo->vbMV[i].phys_addr >> 24) &
+					0xFF;
+				colMvAddr[i][1] =
+					(pDecInfo->vbMV[i].phys_addr >> 16) &
+					0xFF;
+				colMvAddr[i][2] =
+					(pDecInfo->vbMV[i].phys_addr >> 8) &
+					0xFF;
+				colMvAddr[i][3] =
+					(pDecInfo->vbMV[i].phys_addr >> 0) &
+					0xFF;
+			}
+		} else {
+			colMvAddr[0][0] =
+				(pDecInfo->vbMV[0].phys_addr >> 24) & 0xFF;
+			colMvAddr[0][1] =
+				(pDecInfo->vbMV[0].phys_addr >> 16) & 0xFF;
+			colMvAddr[0][2] =
+				(pDecInfo->vbMV[0].phys_addr >> 8) & 0xFF;
+			colMvAddr[0][3] =
+				(pDecInfo->vbMV[0].phys_addr >> 0) & 0xFF;
+		}
+		if (pCodecInst->isUseProtectBuffer) //RTK, need to review it
+		{
+#ifdef ENABLE_TEE_DRM_FLOW
+			VLOG(TRACE,
+			     "[%d]%s.Coda9VpuWriteMem paraBuffer+384:0x%x with colMvAddr.numFbsForDecoding:%d.sizeof(colMvAddr):%d\n",
+			     __LINE__, __func__, (paraBuffer + 384),
+			     pDecInfo->numFbsForDecoding, sizeof(colMvAddr));
+			Coda9VpuWriteMem(pCodecInst->coreIdx, paraBuffer + 384,
+					 (BYTE *)colMvAddr, sizeof(colMvAddr),
+					 VDI_BIG_ENDIAN, pCodecInst->teeapi_ctx,
+					 pCodecInst->teeapi_tee_session);
+#else
+			VpuWriteMem(pCodecInst->coreIdx, paraBuffer + 384,
+				    (BYTE *)colMvAddr, sizeof(colMvAddr),
+				    VDI_BIG_ENDIAN);
+#endif
+		} else {
+			VLOG(TRACE,
+			     "[%d]%s.VpuWriteMem paraBuffer+384:0x%x with colMvAddr.numFbsForDecoding:%d.sizeof(colMvAddr):%d\n",
+			     __LINE__, __func__, (paraBuffer + 384),
+			     pDecInfo->numFbsForDecoding, sizeof(colMvAddr));
+			VpuWriteMem(pCodecInst->coreIdx, paraBuffer + 384,
+				    (BYTE *)colMvAddr, sizeof(colMvAddr),
+				    VDI_BIG_ENDIAN);
+		}
+	}
+
+	if (pCodecInst->productId == PRODUCT_ID_980) {
+		for (i = 0; i < pDecInfo->numFbsForDecoding; i++) {
+			frameAddr[i][0][0] =
+				(pDecInfo->frameBufPool[i].bufYBot >> 24) &
+				0xFF;
+			frameAddr[i][0][1] =
+				(pDecInfo->frameBufPool[i].bufYBot >> 16) &
+				0xFF;
+			frameAddr[i][0][2] =
+				(pDecInfo->frameBufPool[i].bufYBot >> 8) & 0xFF;
+			frameAddr[i][0][3] =
+				(pDecInfo->frameBufPool[i].bufYBot >> 0) & 0xFF;
+			if (pDecInfo->openParam.cbcrOrder ==
+			    CBCR_ORDER_NORMAL) {
+				frameAddr[i][1][0] =
+					(pDecInfo->frameBufPool[i].bufCbBot >>
+					 24) &
+					0xFF;
+				frameAddr[i][1][1] =
+					(pDecInfo->frameBufPool[i].bufCbBot >>
+					 16) &
+					0xFF;
+				frameAddr[i][1][2] =
+					(pDecInfo->frameBufPool[i].bufCbBot >>
+					 8) &
+					0xFF;
+				frameAddr[i][1][3] =
+					(pDecInfo->frameBufPool[i].bufCbBot >>
+					 0) &
+					0xFF;
+				frameAddr[i][2][0] =
+					(pDecInfo->frameBufPool[i].bufCrBot >>
+					 24) &
+					0xFF;
+				frameAddr[i][2][1] =
+					(pDecInfo->frameBufPool[i].bufCrBot >>
+					 16) &
+					0xFF;
+				frameAddr[i][2][2] =
+					(pDecInfo->frameBufPool[i].bufCrBot >>
+					 8) &
+					0xFF;
+				frameAddr[i][2][3] =
+					(pDecInfo->frameBufPool[i].bufCrBot >>
+					 0) &
+					0xFF;
+			} else {
+				frameAddr[i][2][0] =
+					(pDecInfo->frameBufPool[i].bufCbBot >>
+					 24) &
+					0xFF;
+				frameAddr[i][2][1] =
+					(pDecInfo->frameBufPool[i].bufCbBot >>
+					 16) &
+					0xFF;
+				frameAddr[i][2][2] =
+					(pDecInfo->frameBufPool[i].bufCbBot >>
+					 8) &
+					0xFF;
+				frameAddr[i][2][3] =
+					(pDecInfo->frameBufPool[i].bufCbBot >>
+					 0) &
+					0xFF;
+				frameAddr[i][1][0] =
+					(pDecInfo->frameBufPool[i].bufCrBot >>
+					 24) &
+					0xFF;
+				frameAddr[i][1][1] =
+					(pDecInfo->frameBufPool[i].bufCrBot >>
+					 16) &
+					0xFF;
+				frameAddr[i][1][2] =
+					(pDecInfo->frameBufPool[i].bufCrBot >>
+					 8) &
+					0xFF;
+				frameAddr[i][1][3] =
+					(pDecInfo->frameBufPool[i].bufCrBot >>
+					 0) &
+					0xFF;
+			}
+		}
+		if (pCodecInst->isUseProtectBuffer) //RTK, need to review it
+		{
+#ifdef ENABLE_TEE_DRM_FLOW
+			VLOG(TRACE,
+			     "[%d]%s.Coda9VpuWriteMem paraBuffer+384+128:0x%x with frameAddr.numFbsForDecoding:%d.sizeof(frameAddr):%d\n",
+			     __LINE__, __func__, (paraBuffer + 384 + 128),
+			     pDecInfo->numFbsForDecoding, sizeof(frameAddr));
+			Coda9VpuWriteMem(pCodecInst->coreIdx,
+					 paraBuffer + 384 + 128,
+					 (BYTE *)frameAddr, sizeof(frameAddr),
+					 VDI_BIG_ENDIAN, pCodecInst->teeapi_ctx,
+					 pCodecInst->teeapi_tee_session);
+#else
+			VpuWriteMem(pCodecInst->coreIdx, paraBuffer + 384 + 128,
+				    (BYTE *)frameAddr, sizeof(frameAddr),
+				    VDI_BIG_ENDIAN);
+#endif
+		} else {
+			VLOG(TRACE,
+			     "[%d]%s.VpuWriteMem paraBuffer+384+128:0x%x with frameAddr.numFbsForDecoding:%d.sizeof(frameAddr):%d\n",
+			     __LINE__, __func__, (paraBuffer + 384 + 128),
+			     pDecInfo->numFbsForDecoding, sizeof(frameAddr));
+			VpuWriteMem(pCodecInst->coreIdx, paraBuffer + 384 + 128,
+				    (BYTE *)frameAddr, sizeof(frameAddr),
+				    VDI_BIG_ENDIAN);
+		}
+
+		if (pDecInfo->wtlEnable) {
+			int num =
+				pDecInfo->numFbsForDecoding; /* start index of WTL fb array */
+			int end = pDecInfo->numFrameBuffers;
+			for (i = num; i < end; i++) {
+				frameAddr[i - num][0][0] =
+					(pDecInfo->frameBufPool[i].bufY >> 24) &
+					0xFF;
+				frameAddr[i - num][0][1] =
+					(pDecInfo->frameBufPool[i].bufY >> 16) &
+					0xFF;
+				frameAddr[i - num][0][2] =
+					(pDecInfo->frameBufPool[i].bufY >> 8) &
+					0xFF;
+				frameAddr[i - num][0][3] =
+					(pDecInfo->frameBufPool[i].bufY >> 0) &
+					0xFF;
+				if (pDecInfo->openParam.cbcrOrder ==
+				    CBCR_ORDER_NORMAL) {
+					frameAddr[i - num][1][0] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 24) &
+						0xFF;
+					frameAddr[i - num][1][1] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 16) &
+						0xFF;
+					frameAddr[i - num][1][2] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 8) &
+						0xFF;
+					frameAddr[i - num][1][3] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 0) &
+						0xFF;
+					frameAddr[i - num][2][0] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 24) &
+						0xFF;
+					frameAddr[i - num][2][1] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 16) &
+						0xFF;
+					frameAddr[i - num][2][2] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 8) &
+						0xFF;
+					frameAddr[i - num][2][3] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 0) &
+						0xFF;
+				} else {
+					frameAddr[i - num][2][0] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 24) &
+						0xFF;
+					frameAddr[i - num][2][1] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 16) &
+						0xFF;
+					frameAddr[i - num][2][2] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 8) &
+						0xFF;
+					frameAddr[i - num][2][3] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 0) &
+						0xFF;
+					frameAddr[i - num][1][0] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 24) &
+						0xFF;
+					frameAddr[i - num][1][1] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 16) &
+						0xFF;
+					frameAddr[i - num][1][2] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 8) &
+						0xFF;
+					frameAddr[i - num][1][3] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 0) &
+						0xFF;
+				}
+			}
+			if (pCodecInst->isUseProtectBuffer) //RTK, need to review it
+			{
+#ifdef ENABLE_TEE_DRM_FLOW
+				VLOG(TRACE,
+				     "[%d]%s.Coda9VpuWriteMem paraBuffer+384+128+384:0x%x with frameAddr.numFbsForDecoding:%d.sizeof(frameAddr):%d\n",
+				     __LINE__, __func__,
+				     (paraBuffer + 384 + 128 + 384),
+				     pDecInfo->numFbsForDecoding,
+				     sizeof(frameAddr));
+				Coda9VpuWriteMem(
+					pCodecInst->coreIdx,
+					paraBuffer + 384 + 128 + 384,
+					(BYTE *)frameAddr, sizeof(frameAddr),
+					VDI_BIG_ENDIAN, pCodecInst->teeapi_ctx,
+					pCodecInst->teeapi_tee_session);
+#else
+				VpuWriteMem(pCodecInst->coreIdx,
+					    paraBuffer + 384 + 128 + 384,
+					    (BYTE *)frameAddr,
+					    sizeof(frameAddr), VDI_BIG_ENDIAN);
+#endif
+			} else {
+				VLOG(TRACE,
+				     "[%d]%s.VpuWriteMem paraBuffer+384+128+384:0x%x with frameAddr.numFbsForDecoding:%d.sizeof(frameAddr):%d\n",
+				     __LINE__, __func__,
+				     (paraBuffer + 384 + 128 + 384),
+				     pDecInfo->numFbsForDecoding,
+				     sizeof(frameAddr));
+				VpuWriteMem(pCodecInst->coreIdx,
+					    paraBuffer + 384 + 128 + 384,
+					    (BYTE *)frameAddr,
+					    sizeof(frameAddr), VDI_BIG_ENDIAN);
+			}
+
+			if (pDecInfo->wtlMode == FF_FIELD) {
+				for (i = num; i < num * 2; i++) {
+					frameAddr[i - num][0][0] =
+						(pDecInfo->frameBufPool[i]
+							 .bufYBot >>
+						 24) &
+						0xFF;
+					frameAddr[i - num][0][1] =
+						(pDecInfo->frameBufPool[i]
+							 .bufYBot >>
+						 16) &
+						0xFF;
+					frameAddr[i - num][0][2] =
+						(pDecInfo->frameBufPool[i]
+							 .bufYBot >>
+						 8) &
+						0xFF;
+					frameAddr[i - num][0][3] =
+						(pDecInfo->frameBufPool[i]
+							 .bufYBot >>
+						 0) &
+						0xFF;
+					if (pDecInfo->openParam.cbcrOrder ==
+					    CBCR_ORDER_NORMAL) {
+						frameAddr[i - num][1][0] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCbBot >>
+							 24) &
+							0xFF;
+						frameAddr[i - num][1][1] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCbBot >>
+							 16) &
+							0xFF;
+						frameAddr[i - num][1][2] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCbBot >>
+							 8) &
+							0xFF;
+						frameAddr[i - num][1][3] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCbBot >>
+							 0) &
+							0xFF;
+						frameAddr[i - num][2][0] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCrBot >>
+							 24) &
+							0xFF;
+						frameAddr[i - num][2][1] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCrBot >>
+							 16) &
+							0xFF;
+						frameAddr[i - num][2][2] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCrBot >>
+							 8) &
+							0xFF;
+						frameAddr[i - num][2][3] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCrBot >>
+							 0) &
+							0xFF;
+					} else {
+						frameAddr[i - num][2][0] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCbBot >>
+							 24) &
+							0xFF;
+						frameAddr[i - num][2][1] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCbBot >>
+							 16) &
+							0xFF;
+						frameAddr[i - num][2][2] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCbBot >>
+							 8) &
+							0xFF;
+						frameAddr[i - num][2][3] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCbBot >>
+							 0) &
+							0xFF;
+						frameAddr[i - num][1][0] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCrBot >>
+							 24) &
+							0xFF;
+						frameAddr[i - num][1][1] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCrBot >>
+							 16) &
+							0xFF;
+						frameAddr[i - num][1][2] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCrBot >>
+							 8) &
+							0xFF;
+						frameAddr[i - num][1][3] =
+							(pDecInfo->frameBufPool[i]
+								 .bufCrBot >>
+							 0) &
+							0xFF;
+					}
+				}
+				if (pCodecInst->isUseProtectBuffer) //RTK, need to review it
+				{
+#ifdef ENABLE_TEE_DRM_FLOW
+					VLOG(TRACE,
+					     "[%d]%s.Coda9VpuWriteMem paraBuffer+384+128+384+384:0x%x with frameAddr.numFbsForDecoding:%d.sizeof(frameAddr):%d\n",
+					     __LINE__, __func__,
+					     (paraBuffer + 384 + 128 + 384 +
+					      384),
+					     pDecInfo->numFbsForDecoding,
+					     sizeof(frameAddr));
+					Coda9VpuWriteMem(
+						pCodecInst->coreIdx,
+						paraBuffer + 384 + 128 + 384 +
+							384,
+						(BYTE *)frameAddr,
+						sizeof(frameAddr),
+						VDI_BIG_ENDIAN,
+						pCodecInst->teeapi_ctx,
+						pCodecInst->teeapi_tee_session);
+#else
+					VpuWriteMem(pCodecInst->coreIdx,
+						    paraBuffer + 384 + 128 +
+							    384 + 384,
+						    (BYTE *)frameAddr,
+						    sizeof(frameAddr),
+						    VDI_BIG_ENDIAN);
+#endif
+				} else {
+					VLOG(TRACE,
+					     "[%d]%s.VpuWriteMem paraBuffer+384+128+384+384:0x%x with frameAddr.numFbsForDecoding:%d.sizeof(frameAddr):%d\n",
+					     __LINE__, __func__,
+					     (paraBuffer + 384 + 128 + 384 +
+					      384),
+					     pDecInfo->numFbsForDecoding,
+					     sizeof(frameAddr));
+					VpuWriteMem(pCodecInst->coreIdx,
+						    paraBuffer + 384 + 128 +
+							    384 + 384,
+						    (BYTE *)frameAddr,
+						    sizeof(frameAddr),
+						    VDI_BIG_ENDIAN);
+				}
+			}
+		}
+	} else {
+		if (pDecInfo->wtlEnable) {
+			int num =
+				pDecInfo->numFbsForDecoding; /* start index of WTL fb array */
+			int end = pDecInfo->numFrameBuffers;
+			for (i = num; i < end; i++) {
+				frameAddr[i - num][0][0] =
+					(pDecInfo->frameBufPool[i].bufY >> 24) &
+					0xFF;
+				frameAddr[i - num][0][1] =
+					(pDecInfo->frameBufPool[i].bufY >> 16) &
+					0xFF;
+				frameAddr[i - num][0][2] =
+					(pDecInfo->frameBufPool[i].bufY >> 8) &
+					0xFF;
+				frameAddr[i - num][0][3] =
+					(pDecInfo->frameBufPool[i].bufY >> 0) &
+					0xFF;
+				if (pDecInfo->openParam.cbcrOrder ==
+				    CBCR_ORDER_NORMAL) {
+					frameAddr[i - num][1][0] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 24) &
+						0xFF;
+					frameAddr[i - num][1][1] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 16) &
+						0xFF;
+					frameAddr[i - num][1][2] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 8) &
+						0xFF;
+					frameAddr[i - num][1][3] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 0) &
+						0xFF;
+					frameAddr[i - num][2][0] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 24) &
+						0xFF;
+					frameAddr[i - num][2][1] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 16) &
+						0xFF;
+					frameAddr[i - num][2][2] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 8) &
+						0xFF;
+					frameAddr[i - num][2][3] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 0) &
+						0xFF;
+				} else {
+					frameAddr[i - num][2][0] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 24) &
+						0xFF;
+					frameAddr[i - num][2][1] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 16) &
+						0xFF;
+					frameAddr[i - num][2][2] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 8) &
+						0xFF;
+					frameAddr[i - num][2][3] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCb >>
+						 0) &
+						0xFF;
+					frameAddr[i - num][1][0] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 24) &
+						0xFF;
+					frameAddr[i - num][1][1] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 16) &
+						0xFF;
+					frameAddr[i - num][1][2] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 8) &
+						0xFF;
+					frameAddr[i - num][1][3] =
+						(pDecInfo->frameBufPool[i]
+							 .bufCr >>
+						 0) &
+						0xFF;
+				}
+			}
+			if (pCodecInst->isUseProtectBuffer) //RTK, need to review it
+			{
+#ifdef ENABLE_TEE_DRM_FLOW
+				VLOG(TRACE,
+				     "[%d]%s.Coda9VpuWriteMem paraBuffer+384+128+384:0x%x with frameAddr.numFbsForDecoding:%d.sizeof(frameAddr):%d\n",
+				     __LINE__, __func__,
+				     (paraBuffer + 384 + 128 + 384),
+				     pDecInfo->numFbsForDecoding,
+				     sizeof(frameAddr));
+				Coda9VpuWriteMem(
+					pCodecInst->coreIdx,
+					paraBuffer + 384 + 128 + 384,
+					(BYTE *)frameAddr, sizeof(frameAddr),
+					VDI_BIG_ENDIAN, pCodecInst->teeapi_ctx,
+					pCodecInst->teeapi_tee_session);
+#else
+				VpuWriteMem(pCodecInst->coreIdx,
+					    paraBuffer + 384 + 128 + 384,
+					    (BYTE *)frameAddr,
+					    sizeof(frameAddr), VDI_BIG_ENDIAN);
+#endif
+			} else {
+				VLOG(TRACE,
+				     "[%d]%s.VpuWriteMem paraBuffer+384+128+384:0x%x with frameAddr.numFbsForDecoding:%d.sizeof(frameAddr):%d\n",
+				     __LINE__, __func__,
+				     (paraBuffer + 384 + 128 + 384),
+				     pDecInfo->numFbsForDecoding,
+				     sizeof(frameAddr));
+				VpuWriteMem(pCodecInst->coreIdx,
+					    paraBuffer + 384 + 128 + 384,
+					    (BYTE *)frameAddr,
+					    sizeof(frameAddr), VDI_BIG_ENDIAN);
+			}
+		}
+	}
+
+	if (!ConfigSecAXICoda9(pCodecInst->coreIdx, pCodecInst->codecMode,
+			       &pDecInfo->secAxiInfo, pDecInfo->stride,
+			       pDecInfo->frameBufferHeight,
+			       pDecInfo->initialInfo.profile & 0xff)) {
+		return RETCODE_INSUFFICIENT_RESOURCE;
+	}
+
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+	if (pDecInfo->secAxiInfo.bufSize) {
+		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_SEC_AXI]
+			.enable = 1;
+		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_SEC_AXI]
+			.isSecondary = 1;
+		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_SEC_AXI]
+			.startAddress = pDecInfo->secAxiInfo.bufBase;
+		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_SEC_AXI]
+			.endAddress = pDecInfo->secAxiInfo.bufBase +
+				      pDecInfo->secAxiInfo.bufSize;
+		VLOG(INFO,
+		     "[%d]%s.set decRegion[WPROT_DEC_SEC_AXI](%d,%d,0x%08x,0x%08x)\n",
+		     __LINE__, __func__,
+		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_SEC_AXI]
+			     .enable,
+		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_SEC_AXI]
+			     .isSecondary,
+		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_SEC_AXI]
+			     .startAddress,
+		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_SEC_AXI]
+			     .endAddress);
+	}
+#endif
+
+	for (i = 0; i < pDecInfo->numFrameBuffers; i++) {
+		pDecInfo->frameBufPool[i].nv21 =
+			pDecInfo->openParam.nv21 &
+			pDecInfo->openParam.cbcrInterleave;
+	}
+
+	// Tell the decoder how much frame buffers were allocated.
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_BUF_NUM,
+		    pDecInfo->numFrameBuffers);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_BUF_STRIDE,
+		    pDecInfo->stride);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_BIT_ADDR,
+		    pDecInfo->secAxiInfo.u.coda9.bufBitUse);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_IPACDC_ADDR,
+		    pDecInfo->secAxiInfo.u.coda9.bufIpAcDcUse);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_DBKY_ADDR,
+		    pDecInfo->secAxiInfo.u.coda9.bufDbkYUse);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_DBKC_ADDR,
+		    pDecInfo->secAxiInfo.u.coda9.bufDbkCUse);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_OVL_ADDR,
+		    pDecInfo->secAxiInfo.u.coda9.bufOvlUse);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_BTP_ADDR,
+		    pDecInfo->secAxiInfo.u.coda9.bufBtpUse);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_DELAY,
+		    pDecInfo->frameDelay);
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_CACHE_CONFIG,
+		    pDecInfo->cacheConfig.type2.CacheMode);
+
+	if (pCodecInst->codecMode == VPX_DEC) {
+		vpu_buffer_t *pvbSlice = &pDecInfo->vbSlice;
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+		WriteMemProtectCfg *pCgf = &pDecInfo->writeMemProtectCfg;
+#endif
+		if (pvbSlice->size == 0) {
+			pvbSlice->size = VP8_MB_SAVE_SIZE;
+			//ENABLE_TEE_DRM_FLOW
+			if (pCodecInst->isUseProtectBuffer)
+				pvbSlice->req_spec_region =
+					VE_SECURE_PROTECTION;
+			else
+				pvbSlice->req_spec_region = 0;
+
+			if (vdi_allocate_dma_memory_no_mmap(
+				    pCodecInst->coreIdx, pvbSlice,
+				    pCodecInst->filp) < 0) {
+				return RETCODE_INSUFFICIENT_RESOURCE;
+			}
+			VLOG(TRACE,
+			     "[%d]%s.vdi_allocate_dma_memory_no_mmap vbSlice(0x%lx,0x%lx,0x%lx,%d,%d)\n",
+			     __LINE__, __func__, pvbSlice->phys_addr,
+			     pvbSlice->base, pvbSlice->virt_addr,
+			     pvbSlice->size, pvbSlice->req_spec_region);
+		}
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+		pCgf->decRegion[WPROT_DEC_PIC_SAVE].enable = 1;
+		pCgf->decRegion[WPROT_DEC_PIC_SAVE].isSecondary = 0;
+		pCgf->decRegion[WPROT_DEC_PIC_SAVE].startAddress =
+			pvbSlice->phys_addr;
+		pCgf->decRegion[WPROT_DEC_PIC_SAVE].endAddress =
+			pvbSlice->phys_addr + pvbSlice->size;
+		VLOG(INFO,
+		     "[%d]%s.set decRegion[WPROT_DEC_PIC_SAVE](%d,%d,0x%08x,0x%08x)\n",
+		     __LINE__, __func__,
+		     pCgf->decRegion[WPROT_DEC_PIC_SAVE].enable,
+		     pCgf->decRegion[WPROT_DEC_PIC_SAVE].isSecondary,
+		     pCgf->decRegion[WPROT_DEC_PIC_SAVE].startAddress,
+		     pCgf->decRegion[WPROT_DEC_PIC_SAVE].endAddress);
+#endif
+		VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_MB_BUF_BASE,
+			    pvbSlice->phys_addr);
+	}
+
+	if (pCodecInst->codecMode == AVC_DEC) {
+		vpu_buffer_t *pvbSlice = &pDecInfo->vbSlice;
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+		WriteMemProtectCfg *pCgf = &pDecInfo->writeMemProtectCfg;
+#endif
+		if (pvbSlice->size == 0) {
+			pvbSlice->size = SLICE_SAVE_SIZE;
+			//ENABLE_TEE_DRM_FLOW
+			if (pCodecInst->isUseProtectBuffer)
+				pvbSlice->req_spec_region =
+					VE_SECURE_PROTECTION;
+			else
+				pvbSlice->req_spec_region = 0;
+
+			if (vdi_allocate_dma_memory_no_mmap(
+				    pCodecInst->coreIdx, pvbSlice,
+				    pCodecInst->filp) < 0) {
+				return RETCODE_INSUFFICIENT_RESOURCE;
+			}
+			VLOG(TRACE,
+			     "[%d]%s.vdi_allocate_dma_memory_no_mmap vbSlice(0x%lx,0x%lx,0x%lx,%d,%d)\n",
+			     __LINE__, __func__, pvbSlice->phys_addr,
+			     pvbSlice->base, pvbSlice->virt_addr,
+			     pvbSlice->size, pvbSlice->req_spec_region);
+		}
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+		pCgf->decRegion[WPROT_DEC_PIC_SAVE].enable = 1;
+		pCgf->decRegion[WPROT_DEC_PIC_SAVE].isSecondary = 0;
+		pCgf->decRegion[WPROT_DEC_PIC_SAVE].startAddress =
+			pvbSlice->phys_addr;
+		pCgf->decRegion[WPROT_DEC_PIC_SAVE].endAddress =
+			pvbSlice->phys_addr + pvbSlice->size;
+		VLOG(INFO,
+		     "[%d]%s.set decRegion[WPROT_DEC_PIC_SAVE](%d,%d,0x%08x,0x%08x)\n",
+		     __LINE__, __func__,
+		     pCgf->decRegion[WPROT_DEC_PIC_SAVE].enable,
+		     pCgf->decRegion[WPROT_DEC_PIC_SAVE].isSecondary,
+		     pCgf->decRegion[WPROT_DEC_PIC_SAVE].startAddress,
+		     pCgf->decRegion[WPROT_DEC_PIC_SAVE].endAddress);
+#endif
+		VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_SLICE_BB_START,
+			    pvbSlice->phys_addr);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_SLICE_BB_SIZE,
+			    (pvbSlice->size / 1024));
+	}
+
+	if (pCodecInst->productId == PRODUCT_ID_980) {
+		val = 0;
+		val |= (pDecInfo->openParam.bwbEnable << 15);
+		val |= (pDecInfo->wtlMode << 17) |
+		       (pDecInfo->tiled2LinearMode << 13) |
+		       (pDecInfo->mapType << 9) | (FORMAT_420 << 6);
+		val |= ((pDecInfo->openParam.cbcrInterleave)
+			<< 2); // Interleave bit position is modified
+		val |= pDecInfo->openParam.frameEndian;
+		VpuWriteReg(pCodecInst->coreIdx, BIT_FRAME_MEM_CTRL, val);
+	} else if (pCodecInst->productId == PRODUCT_ID_960) {
+		val = 0;
+		val |= (pDecInfo->wtlEnable << 17);
+		val |= (pDecInfo->openParam.bwbEnable << 12);
+		if (pDecInfo->mapType) {
+			if (pDecInfo->mapType == TILED_FRAME_MB_RASTER_MAP ||
+			    pDecInfo->mapType == TILED_FIELD_MB_RASTER_MAP)
+				val |= (pDecInfo->tiled2LinearEnable << 11) |
+				       (0x03 << 9) | (FORMAT_420 << 6);
+			else
+				val |= (pDecInfo->tiled2LinearEnable << 11) |
+				       (0x02 << 9) | (FORMAT_420 << 6);
+		}
+		val |= ((pDecInfo->openParam.cbcrInterleave)
+			<< 2); // Interleave bit position is modified
+		val |= pDecInfo->openParam.frameEndian;
+		VpuWriteReg(pCodecInst->coreIdx, BIT_FRAME_MEM_CTRL, val);
+	} else {
+		return RETCODE_NOT_FOUND_VPU_DEVICE;
+	}
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_MAX_DEC_SIZE, 0);
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst, SET_FRAME_BUF);
+	if (vdi_wait_vpu_busy(pCodecInst->coreIdx, __VPU_BUSY_TIMEOUT,
+			      BIT_BUSY_FLAG) == -1) {
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, SET_FRAME_BUF, 2);
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, SET_FRAME_BUF, 0);
+
+	if (VpuReadReg(pCodecInst->coreIdx, RET_SET_FRAME_SUCCESS) &
+	    (1 << 31)) {
+		return RETCODE_MEMORY_ACCESS_VIOLATION;
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuDecFlush(CodecInst *instance,
+			 FramebufferIndex *framebufferIndexes, Uint32 size)
+{
+	Uint32 i;
+	DecInfo *pDecInfo = &instance->CodecInfo->decInfo;
+#if defined(CODA9_CHECK_CODE_BUFFER_MD5SUM)
+	vpu_buffer_t vb;
+	unsigned char md5hash[16];
+
+	vdi_get_common_memory((unsigned long)instance->coreIdx, &vb);
+	VLOG(TRACE,
+	     "[%d]%s.codeBuffer(phys:0x%08x,virt:0x%08x).size:%d.BIT_CODE_BUF_ADDR:0x%08x\n",
+	     __LINE__, __func__, vb.phys_addr, vb.virt_addr, gCodaFwSize,
+	     VpuReadReg(instance->coreIdx, BIT_CODE_BUF_ADDR));
+	MD5(((unsigned char *)(vb.virt_addr)), (size_t)gCodaFwSize, md5hash);
+	VLOG(TRACE,
+	     "[%d]%s.codeBuffer Hash: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+	     __LINE__, __func__, md5hash[0], md5hash[1], md5hash[2], md5hash[3],
+	     md5hash[4], md5hash[5], md5hash[6], md5hash[7], md5hash[8],
+	     md5hash[9], md5hash[10], md5hash[11], md5hash[12], md5hash[13],
+	     md5hash[14], md5hash[15]);
+#endif
+
+	Coda9BitIssueCommand(instance->coreIdx, instance, DEC_BUF_FLUSH);
+	if (vdi_wait_vpu_busy(instance->coreIdx, __VPU_BUSY_TIMEOUT,
+			      BIT_BUSY_FLAG) == -1) {
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+
+	pDecInfo->frameDisplayFlag = VpuReadReg(
+		instance->coreIdx, pDecInfo->frameDisplayFlagRegAddr); //RTK
+
+	if (framebufferIndexes != NULL) {
+		for (i = 0; i < size; i++) {
+			framebufferIndexes[i].linearIndex = -2;
+			framebufferIndexes[i].tiledIndex = -2;
+		}
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+/************************************************************************/
+/* Encoder                                                              */
+/************************************************************************/
+
+RetCode Coda9VpuBuildUpEncParam(CodecInst *pCodec, EncOpenParam *param)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	Uint32 coreIdx;
+	Int32 productId;
+	EncInfo *pEncInfo = &pCodec->CodecInfo->encInfo;
+
+    VLOG(TRACE, "[+] [%d]%s.h:%p\n",__LINE__,__func__,(void *)pCodec);
+	coreIdx = pCodec->coreIdx;
+	productId = Coda9VpuGetProductId(coreIdx);
+
+	if ((ret = SetupEncCodecInstance(productId, pCodec)) != RETCODE_SUCCESS)
+		return ret;
+
+	if (param->bitstreamFormat == STD_MPEG4 ||
+	    param->bitstreamFormat == STD_H263)
+		pCodec->codecMode = MP4_ENC;
+	else if (param->bitstreamFormat == STD_AVC)
+		pCodec->codecMode = AVC_ENC;
+
+	if (param->bitstreamFormat == STD_AVC &&
+	    param->EncStdParam.avcParam.mvcExtension)
+		pCodec->codecModeAux = AVC_AUX_MVC;
+	else
+		pCodec->codecModeAux = 0;
+
+	if (productId == PRODUCT_ID_980) {
+		pEncInfo->ActivePPSIdx = 0;
+		pEncInfo->frameIdx = 0;
+		pEncInfo->fieldDone = 0;
+	}
+
+	pEncInfo->vbWork.size = WORK_BUF_SIZE;
+	pEncInfo->vbWork.req_spec_region = 0;
+	if (vdi_allocate_dma_memory(pCodec->coreIdx, &pEncInfo->vbWork,
+				    pCodec->filp) < 0)
+		return RETCODE_INSUFFICIENT_RESOURCE;
+	VLOG(TRACE,
+	     "[%d]%s.vdi_allocate_dma_memory vbWork(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+	     __LINE__, __func__, pEncInfo->vbWork.phys_addr,
+	     pEncInfo->vbWork.base, pEncInfo->vbWork.virt_addr,
+	     pEncInfo->vbWork.size, pEncInfo->vbWork.req_spec_region);
+
+	pEncInfo->streamRdPtr = param->bitstreamBuffer;
+	pEncInfo->streamWrPtr = param->bitstreamBuffer;
+	pEncInfo->lineBufIntEn = param->lineBufIntEn;
+	pEncInfo->streamBufStartAddr = param->bitstreamBuffer;
+	pEncInfo->streamBufSize = param->bitstreamBufferSize;
+	pEncInfo->streamBufEndAddr =
+		param->bitstreamBuffer + param->bitstreamBufferSize;
+	pEncInfo->stride = 0;
+	pEncInfo->vbFrame.size = 0;
+	pEncInfo->vbPPU.size = 0;
+	pEncInfo->frameAllocExt = 0;
+	pEncInfo->ppuAllocExt = 0;
+	pEncInfo->secAxiInfo.u.coda9.useBitEnable = 0;
+	pEncInfo->secAxiInfo.u.coda9.useIpEnable = 0;
+	pEncInfo->secAxiInfo.u.coda9.useDbkYEnable = 0;
+	pEncInfo->secAxiInfo.u.coda9.useDbkCEnable = 0;
+	pEncInfo->secAxiInfo.u.coda9.useOvlEnable = 0;
+	pEncInfo->rotationEnable = 0;
+	pEncInfo->mirrorEnable = 0;
+	pEncInfo->mirrorDirection = MIRDIR_NONE;
+	pEncInfo->rotationAngle = 0;
+	pEncInfo->initialInfoObtained = 0;
+	pEncInfo->ringBufferEnable = param->ringBufferEnable;
+	pEncInfo->linear2TiledEnable = param->linear2TiledEnable;
+	pEncInfo->linear2TiledMode = param->linear2TiledMode; // coda980 only
+	if (!pEncInfo->linear2TiledEnable)
+		pEncInfo->linear2TiledMode = 0;
+
+	/* Maverick Cache I */
+	osal_memset((void *)&pEncInfo->cacheConfig, 0x00,
+		    sizeof(MaverickCacheConfig));
+
+	if (productId == PRODUCT_ID_960) {
+		pEncInfo->dramCfg.bankBit = EM_BANK;
+		pEncInfo->dramCfg.casBit = EM_CAS;
+		pEncInfo->dramCfg.rasBit = EM_RAS;
+		pEncInfo->dramCfg.busBit = EM_WIDTH;
+	}
+
+    VLOG(TRACE, "[+] [%d]%s.h:%p.ret:%d\n",__LINE__,__func__,(void *)pCodec,ret);
+	return ret;
+}
+
+RetCode Coda9VpuEncSetup(CodecInst *pCodecInst)
+{
+	Int32 picWidth, picHeight;
+	Int32 data, val;
+	Int32 productId, rcEnable;
+	EncInfo *pEncInfo = &pCodecInst->CodecInfo->encInfo;
+
+    VLOG(TRACE, "[+] [%d]%s.h:%p\n",__LINE__,__func__,(void *)pCodecInst);
+
+	rcEnable = pEncInfo->openParam.rcEnable & 0xf;
+
+	productId = pCodecInst->productId;
+	picWidth = pEncInfo->openParam.picWidth;
+	picHeight = pEncInfo->openParam.picHeight;
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_BB_START,
+		    pEncInfo->streamBufStartAddr);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_BB_SIZE,
+		    pEncInfo->streamBufSize / 1024); // size in KB
+
+	// Rotation Left 90 or 270 case : Swap XY resolution for VPU internal usage
+	if (pEncInfo->rotationAngle == 90 || pEncInfo->rotationAngle == 270)
+		data = (picHeight << 16) | picWidth;
+	else
+		data = (picWidth << 16) | picHeight;
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_SRC_SIZE, data);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_SRC_F_RATE,
+		    pEncInfo->openParam.frameRateInfo);
+
+	if (pEncInfo->openParam.bitstreamFormat == STD_MPEG4) {
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_COD_STD, 3);
+		data = pEncInfo->openParam.EncStdParam.mp4Param.mp4IntraDcVlcThr
+			       << 2 |
+		       pEncInfo->openParam.EncStdParam.mp4Param
+				       .mp4ReversibleVlcEnable
+			       << 1 |
+		       pEncInfo->openParam.EncStdParam.mp4Param
+			       .mp4DataPartitionEnable;
+
+		data |= ((pEncInfo->openParam.EncStdParam.mp4Param.mp4HecEnable >
+			  0) ?
+				 1 :
+				 0)
+			<< 5;
+		data |= ((pEncInfo->openParam.EncStdParam.mp4Param.mp4Verid ==
+			  2) ?
+				 0 :
+				 1)
+			<< 6;
+
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_MP4_PARA, data);
+
+		if (productId == PRODUCT_ID_980)
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_ME_OPTION,
+				    (VPU_ME_LINEBUFFER_MODE << 9) |
+					    (pEncInfo->openParam.meBlkMode
+					     << 5) |
+					    (pEncInfo->openParam.MEUseZeroPmv
+					     << 4) |
+					    (pEncInfo->openParam.MESearchRangeY
+					     << 2) |
+					    pEncInfo->openParam.MESearchRangeX);
+		else
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_ME_OPTION,
+				    (pEncInfo->openParam.meBlkMode << 3) |
+					    (pEncInfo->openParam.MEUseZeroPmv
+					     << 2) |
+					    pEncInfo->openParam.MESearchRange);
+	} else if (pEncInfo->openParam.bitstreamFormat == STD_H263) {
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_COD_STD, 11);
+		data = pEncInfo->openParam.EncStdParam.h263Param.h263AnnexIEnable
+			       << 3 |
+		       pEncInfo->openParam.EncStdParam.h263Param.h263AnnexJEnable
+			       << 2 |
+		       pEncInfo->openParam.EncStdParam.h263Param.h263AnnexKEnable
+			       << 1 |
+		       pEncInfo->openParam.EncStdParam.h263Param
+			       .h263AnnexTEnable;
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_263_PARA, data);
+		if (productId == PRODUCT_ID_980)
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_ME_OPTION,
+				    (VPU_ME_LINEBUFFER_MODE << 9) |
+					    (pEncInfo->openParam.meBlkMode
+					     << 5) |
+					    (pEncInfo->openParam.MEUseZeroPmv
+					     << 4) |
+					    (pEncInfo->openParam.MESearchRangeY
+					     << 2) |
+					    pEncInfo->openParam.MESearchRangeX);
+		else
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_ME_OPTION,
+				    (pEncInfo->openParam.meBlkMode << 3) |
+					    (pEncInfo->openParam.MEUseZeroPmv
+					     << 2) |
+					    pEncInfo->openParam.MESearchRange);
+	} else if (pEncInfo->openParam.bitstreamFormat == STD_AVC) {
+		if (productId == PRODUCT_ID_980) {
+			int SliceNum = 0;
+			AvcPpsParam *ActivePPS =
+				&pEncInfo->openParam.EncStdParam.avcParam
+					 .ppsParam[pEncInfo->ActivePPSIdx];
+			if (ActivePPS->transform8x8Mode == 1 ||
+			    pEncInfo->openParam.EncStdParam.avcParam
+					    .chromaFormat400 == 1)
+				pEncInfo->openParam.EncStdParam.avcParam
+					.profile = 2;
+			else if (ActivePPS->entropyCodingMode != 0 ||
+				 pEncInfo->openParam.EncStdParam.avcParam
+						 .fieldFlag == 1)
+				pEncInfo->openParam.EncStdParam.avcParam
+					.profile = 1;
+			else
+				pEncInfo->openParam.EncStdParam.avcParam
+					.profile = 0;
+
+			if (pEncInfo->openParam.sliceMode.sliceMode == 1 &&
+			    pEncInfo->openParam.sliceMode.sliceSizeMode == 1)
+				SliceNum =
+					pEncInfo->openParam.sliceMode.sliceSize;
+
+			if (!pEncInfo->openParam.EncStdParam.avcParam.level) {
+				if (pEncInfo->openParam.EncStdParam.avcParam
+					    .fieldFlag)
+					pEncInfo->openParam.EncStdParam.avcParam
+						.level = LevelCalculation(
+						picWidth / 16,
+						(picHeight + 31) / 32,
+						pEncInfo->openParam
+							.frameRateInfo,
+						1, pEncInfo->openParam.bitRate,
+						SliceNum);
+				else
+					pEncInfo->openParam.EncStdParam.avcParam
+						.level = LevelCalculation(
+						picWidth / 16, picHeight / 16,
+						pEncInfo->openParam
+							.frameRateInfo,
+						0, pEncInfo->openParam.bitRate,
+						SliceNum);
+				if (pEncInfo->openParam.EncStdParam.avcParam
+					    .level < 0)
+					return RETCODE_INVALID_PARAM;
+			}
+
+			VpuWriteReg(
+				pCodecInst->coreIdx, CMD_ENC_SEQ_COD_STD,
+				(pEncInfo->openParam.EncStdParam.avcParam.profile
+				 << 4) | 0x0);
+			data = 0;
+			if (pEncInfo->openParam.EncStdParam.avcParam
+				    .videoSignalTypePresent) {
+				data = (pEncInfo->openParam.EncStdParam.avcParam
+						.videoSignalTypePresent
+					<< 29) |
+				       (pEncInfo->openParam.EncStdParam.avcParam
+						.videoFormat
+					<< 26) |
+				       (pEncInfo->openParam.EncStdParam.avcParam
+						.videoFullRangeFlag
+					<< 25) |
+				       (pEncInfo->openParam.EncStdParam.avcParam
+						.colourDescripPresFlag
+					<< 24) |
+				       (pEncInfo->openParam.EncStdParam.avcParam
+						.colourPrimaries
+					<< 16) |
+				       (pEncInfo->openParam.EncStdParam.avcParam
+						.transferCharacteristics
+					<< 8) |
+				       (pEncInfo->openParam.EncStdParam.avcParam
+						.matrixCoefficients
+					<< 0);
+			}
+
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_SEQ_VIDEO_SIGNAL_TYPE_PRESENT,
+				    data);
+		} else {
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_COD_STD,
+				    0x0);
+		}
+
+		data = (pEncInfo->openParam.EncStdParam.avcParam
+				.deblkFilterOffsetBeta &
+			15) << 12 |
+		       (pEncInfo->openParam.EncStdParam.avcParam
+				.deblkFilterOffsetAlpha &
+			15) << 8 |
+		       pEncInfo->openParam.EncStdParam.avcParam.disableDeblk
+			       << 6 |
+		       pEncInfo->openParam.EncStdParam.avcParam
+				       .constrainedIntraPredFlag
+			       << 5 |
+		       (pEncInfo->openParam.EncStdParam.avcParam.chromaQpOffset &
+			31);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_264_PARA, data);
+		if (productId == PRODUCT_ID_980) {
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_ME_OPTION,
+				    (VPU_ME_LINEBUFFER_MODE << 9) |
+					    (pEncInfo->openParam.meBlkMode
+					     << 5) |
+					    (pEncInfo->openParam.MEUseZeroPmv
+					     << 4) |
+					    (pEncInfo->openParam.MESearchRangeY
+					     << 2) |
+					    pEncInfo->openParam.MESearchRangeX);
+		} else {
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_ME_OPTION,
+				    (pEncInfo->openParam.meBlkMode << 3) |
+					    (pEncInfo->openParam.MEUseZeroPmv
+					     << 2) |
+					    pEncInfo->openParam.MESearchRange);
+		}
+	}
+
+	if (productId == PRODUCT_ID_980) {
+		data = 0;
+		if (pEncInfo->openParam.sliceMode.sliceMode != 0) {
+			data = pEncInfo->openParam.sliceMode.sliceSize << 2 |
+			       (pEncInfo->openParam.sliceMode.sliceSizeMode +
+				1); // encoding mode 0,1,2
+		}
+	} else {
+		data = pEncInfo->openParam.sliceMode.sliceSize << 2 |
+		       pEncInfo->openParam.sliceMode.sliceSizeMode << 1 |
+		       pEncInfo->openParam.sliceMode.sliceMode;
+	}
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_SLICE_MODE, data);
+
+	if (rcEnable) { // rate control enabled
+		if (productId == PRODUCT_ID_980) {
+			if (pEncInfo->openParam.bitstreamFormat == STD_AVC) {
+				int MinDeltaQp, MaxDeltaQp, QpMin, QpMax;
+
+				data = (pEncInfo->openParam.idrInterval << 21) |
+				       (pEncInfo->openParam.rcGopIQpOffsetEn
+					<< 20) |
+				       ((pEncInfo->openParam.rcGopIQpOffset &
+					 0xF)
+					<< 16) |
+				       pEncInfo->openParam.gopSize;
+				VpuWriteReg(pCodecInst->coreIdx,
+					    CMD_ENC_SEQ_GOP_NUM, data);
+
+				data = (pEncInfo->openParam.frameSkipDisable)
+					       << 31 |
+				       pEncInfo->openParam.initialDelay << 16 |
+				       0;
+				VpuWriteReg(pCodecInst->coreIdx,
+					    CMD_ENC_SEQ_RC_PARA, data);
+				if (pEncInfo->openParam.rcEnable ==
+				    1) //OMX_Video_ControlRateConstant
+					data = (pEncInfo->openParam.bitRate
+						<< 4) |
+					       (pEncInfo->openParam.rcEnable &
+						0xf) |
+					       (pEncInfo->openParam.strictCBR
+						<< 22);
+				else
+					data = (pEncInfo->openParam.bitRate
+						<< 4) |
+					       (pEncInfo->openParam.rcEnable &
+						0xf);
+
+				VpuWriteReg(pCodecInst->coreIdx,
+					    CMD_ENC_SEQ_RC_PARA2, data);
+
+				data = 0;
+				if (pEncInfo->openParam.maxIntraSize > 0)
+					data = (1 << 16) |
+					       (pEncInfo->openParam.maxIntraSize &
+						0xFFFF);
+				VpuWriteReg(pCodecInst->coreIdx,
+					    CMD_ENC_SEQ_RC_MAX_INTRA_SIZE,
+					    data);
+
+				if (pEncInfo->openParam.userMinDeltaQp < 0)
+					MinDeltaQp = 0;
+				else
+					MinDeltaQp = (1 << 6) |
+						     pEncInfo->openParam
+							     .userMinDeltaQp;
+
+				if (pEncInfo->openParam.userMaxDeltaQp < 0)
+					MaxDeltaQp = 0;
+				else
+					MaxDeltaQp = (1 << 6) |
+						     pEncInfo->openParam
+							     .userMaxDeltaQp;
+
+				if (pEncInfo->openParam.userQpMin < 0)
+					QpMin = 0;
+				else
+					QpMin = (1 << 6) |
+						pEncInfo->openParam.userQpMin;
+
+				if (pEncInfo->openParam.userQpMax < 0)
+					QpMax = 0;
+				else
+					QpMax = (1 << 6) |
+						pEncInfo->openParam.userQpMax;
+
+				data = MinDeltaQp << 24 | MaxDeltaQp << 16 |
+				       QpMin << 8 | QpMax;
+				VpuWriteReg(pCodecInst->coreIdx,
+					    CMD_ENC_SEQ_QP_RANGE_SET, data);
+			} else { // MP4
+				VpuWriteReg(pCodecInst->coreIdx,
+					    CMD_ENC_SEQ_GOP_NUM,
+					    pEncInfo->openParam.gopSize);
+
+				data = (pEncInfo->openParam.frameSkipDisable)
+					       << 31 |
+				       pEncInfo->openParam.initialDelay << 16 |
+				       pEncInfo->openParam.bitRate << 1 | 1;
+				VpuWriteReg(pCodecInst->coreIdx,
+					    CMD_ENC_SEQ_RC_PARA, data);
+				VpuWriteReg(pCodecInst->coreIdx,
+					    CMD_ENC_SEQ_QP_RANGE_SET, 0);
+				VpuWriteReg(pCodecInst->coreIdx,
+					    CMD_ENC_SEQ_RC_PARA2, 0);
+			}
+		} else {
+			/* coda960 ENCODER */
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_GOP_NUM,
+				    pEncInfo->openParam.gopSize);
+
+			data = (pEncInfo->openParam.frameSkipDisable) << 31 |
+			       pEncInfo->openParam.initialDelay << 16 |
+			       pEncInfo->openParam.bitRate << 1 | 1;
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_RC_PARA,
+				    data);
+		}
+	} else {
+		if (pEncInfo->openParam.bitstreamFormat == STD_AVC)
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_GOP_NUM,
+				    (pEncInfo->openParam.idrInterval << 21) |
+					    pEncInfo->openParam.gopSize);
+		else
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_GOP_NUM,
+				    pEncInfo->openParam.gopSize);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_RC_PARA, 0);
+		if (productId == PRODUCT_ID_980) {
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_SEQ_QP_RANGE_SET, 0);
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_RC_PARA2,
+				    0);
+		}
+	}
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_RC_BUF_SIZE,
+		    pEncInfo->openParam.vbvBufferSize);
+	data = pEncInfo->openParam.intraRefresh |
+	       pEncInfo->openParam.ConscIntraRefreshEnable << 16 |
+	       pEncInfo->openParam.CountIntraMbEnable << 17 |
+	       pEncInfo->openParam.FieldSeqIntraRefreshEnable << 18;
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_INTRA_REFRESH, data);
+
+	data = 0;
+	if (pEncInfo->openParam.rcIntraQp >= 0) {
+		data = (1 << 5);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_INTRA_QP,
+			    pEncInfo->openParam.rcIntraQp);
+	} else {
+		data = 0;
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_INTRA_QP,
+			    (Uint32)-1);
+	}
+
+	if (pCodecInst->codecMode == AVC_ENC) {
+		data |= (pEncInfo->openParam.EncStdParam.avcParam.audEnable
+			 << 2);
+		if (pCodecInst->codecModeAux == AVC_AUX_MVC) {
+			data |= (pEncInfo->openParam.EncStdParam.avcParam
+					 .interviewEn
+				 << 4);
+			data |= (pEncInfo->openParam.EncStdParam.avcParam
+					 .parasetRefreshEn
+				 << 8);
+			data |= (pEncInfo->openParam.EncStdParam.avcParam
+					 .prefixNalEn
+				 << 9);
+		}
+
+		if (productId == PRODUCT_ID_980) {
+			data |= pEncInfo->openParam.EncStdParam.avcParam
+					.fieldFlag
+				<< 10;
+			data |= pEncInfo->openParam.EncStdParam.avcParam
+					.fieldRefMode
+				<< 11;
+		}
+	}
+
+	if (pEncInfo->openParam.userQpMax >= 0) {
+		data |= (1 << 6);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_RC_QP_MAX,
+			    pEncInfo->openParam.userQpMax);
+	} else {
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_RC_QP_MAX, 0);
+	}
+
+	if (pEncInfo->openParam.userGamma >= 0) {
+		data |= (1 << 7);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_RC_GAMMA,
+			    pEncInfo->openParam.userGamma);
+	} else {
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_RC_GAMMA, 0);
+	}
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_OPTION, data);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_RC_INTERVAL_MODE,
+		    (pEncInfo->openParam.mbInterval << 2) |
+			    pEncInfo->openParam.rcIntervalMode);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_SEQ_INTRA_WEIGHT,
+		    pEncInfo->openParam.intraCostWeight);
+
+	VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamWrPtrRegAddr,
+		    pEncInfo->streamWrPtr);
+	VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamRdPtrRegAddr,
+		    pEncInfo->streamRdPtr);
+
+	SetEncFrameMemInfo(pCodecInst);
+
+	val = 0;
+	if (pEncInfo->ringBufferEnable == 0) {
+		if (pEncInfo->lineBufIntEn)
+			val |= (0x1 << 6);
+		val |= (0x1 << 5);
+		val |= (0x1 << 4);
+	} else {
+		val |= (0x1 << 3);
+	}
+	val |= pEncInfo->openParam.streamEndian;
+	VpuWriteReg(pCodecInst->coreIdx, BIT_BIT_STREAM_CTRL, val);
+
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst, ENC_SEQ_INIT);
+
+	if (vdi_wait_interrupt(pCodecInst->coreIdx, __VPU_BUSY_TIMEOUT,
+			       BIT_INT_REASON) == -1) {
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, ENC_SEQ_INIT, 2);
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+	VpuWriteReg(
+		pCodecInst->coreIdx, BIT_INT_CLEAR,
+		1); // that is OK. HW signal already is clear by device driver
+	VpuWriteReg(pCodecInst->coreIdx, BIT_INT_REASON, 0);
+
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, ENC_SEQ_INIT, 0);
+
+	if (VpuReadReg(pCodecInst->coreIdx, RET_ENC_SEQ_END_SUCCESS) &
+	    (1 << 31))
+		return RETCODE_MEMORY_ACCESS_VIOLATION;
+
+	if (VpuReadReg(pCodecInst->coreIdx, RET_ENC_SEQ_END_SUCCESS) == 0)
+		return RETCODE_FAILURE;
+
+	pEncInfo->streamWrPtr =
+		VpuReadReg(pCodecInst->coreIdx, pEncInfo->streamWrPtrRegAddr);
+	pEncInfo->streamEndflag =
+		VpuReadReg(pCodecInst->coreIdx, BIT_BIT_STREAM_PARAM);
+
+    VLOG(TRACE, "[-] [%d]%s.h:%p.ret:RETCODE_SUCCESS\n",__LINE__,__func__,(void *)pCodecInst);
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuEncRegisterFramebuffer(CodecInst *instance)
+{
+	CodecInst *pCodecInst = instance;
+	EncInfo *pEncInfo;
+	Int32 i, val;
+	RetCode ret;
+	PhysicalAddress paraBuffer;
+	BYTE frameAddr[MAX_FRAMEBUFFER_COUNT][3][4];
+	Int32 stride, height, mapType, num;
+	VpuAttr *pAttr = &g_VpuCoreAttributes[instance->coreIdx];
+    VLOG(TRACE, "[+] [%d]%s.h:%p\n",__LINE__,__func__,(void *)instance);
+
+	osal_memset((void *)frameAddr, 0, sizeof(frameAddr));
+
+	pEncInfo = &instance->CodecInfo->encInfo;
+	stride = pEncInfo->stride;
+	height = pEncInfo->frameBufferHeight;
+	mapType = pEncInfo->mapType;
+
+	if (pCodecInst->productId == PRODUCT_ID_960) {
+		pEncInfo->mapCfg.tiledBaseAddr = pEncInfo->vbFrame.phys_addr;
+	}
+
+	if (!ConfigSecAXICoda9(pCodecInst->coreIdx, instance->codecMode,
+			       &pEncInfo->secAxiInfo, stride, height, 0))
+		return RETCODE_INSUFFICIENT_RESOURCE;
+
+	if (pCodecInst->productId == PRODUCT_ID_960) {
+		val = SetTiledMapType(pCodecInst->coreIdx, &pEncInfo->mapCfg,
+				      mapType, stride,
+				      pEncInfo->openParam.cbcrInterleave,
+				      &pEncInfo->dramCfg);
+	} else {
+		if (mapType != LINEAR_FRAME_MAP && mapType != LINEAR_FIELD_MAP)
+			val = SetTiledMapType(
+				pCodecInst->coreIdx, &pEncInfo->mapCfg, mapType,
+				(stride > height) ? stride : height,
+				pEncInfo->openParam.cbcrInterleave,
+				&pEncInfo->dramCfg);
+		else
+			val = SetTiledMapType(
+				pCodecInst->coreIdx, &pEncInfo->mapCfg, mapType,
+				stride, pEncInfo->openParam.cbcrInterleave,
+				&pEncInfo->dramCfg);
+	}
+
+	if (val == 0)
+		return RETCODE_INVALID_PARAM;
+
+	SetEncFrameMemInfo(pCodecInst);
+
+	paraBuffer = VpuReadReg(pCodecInst->coreIdx, BIT_PARA_BUF_ADDR);
+
+	// Let the decoder know the addresses of the frame buffers.
+	for (i = 0; i < pEncInfo->numFrameBuffers; i++) {
+		frameAddr[i][0][0] =
+			(pEncInfo->frameBufPool[i].bufY >> 24) & 0xFF;
+		frameAddr[i][0][1] =
+			(pEncInfo->frameBufPool[i].bufY >> 16) & 0xFF;
+		frameAddr[i][0][2] =
+			(pEncInfo->frameBufPool[i].bufY >> 8) & 0xFF;
+		frameAddr[i][0][3] =
+			(pEncInfo->frameBufPool[i].bufY >> 0) & 0xFF;
+		frameAddr[i][1][0] =
+			(pEncInfo->frameBufPool[i].bufCb >> 24) & 0xFF;
+		frameAddr[i][1][1] =
+			(pEncInfo->frameBufPool[i].bufCb >> 16) & 0xFF;
+		frameAddr[i][1][2] =
+			(pEncInfo->frameBufPool[i].bufCb >> 8) & 0xFF;
+		frameAddr[i][1][3] =
+			(pEncInfo->frameBufPool[i].bufCb >> 0) & 0xFF;
+		frameAddr[i][2][0] =
+			(pEncInfo->frameBufPool[i].bufCr >> 24) & 0xFF;
+		frameAddr[i][2][1] =
+			(pEncInfo->frameBufPool[i].bufCr >> 16) & 0xFF;
+		frameAddr[i][2][2] =
+			(pEncInfo->frameBufPool[i].bufCr >> 8) & 0xFF;
+		frameAddr[i][2][3] =
+			(pEncInfo->frameBufPool[i].bufCr >> 0) & 0xFF;
+	}
+	VpuWriteMem(pCodecInst->coreIdx, paraBuffer, (BYTE *)frameAddr,
+		    sizeof(frameAddr), VDI_BIG_ENDIAN);
+
+	if (pCodecInst->productId == PRODUCT_ID_980) {
+		for (i = 0; i < pEncInfo->numFrameBuffers; i++) {
+			frameAddr[i][0][0] =
+				(pEncInfo->frameBufPool[i].bufYBot >> 24) &
+				0xFF;
+			frameAddr[i][0][1] =
+				(pEncInfo->frameBufPool[i].bufYBot >> 16) &
+				0xFF;
+			frameAddr[i][0][2] =
+				(pEncInfo->frameBufPool[i].bufYBot >> 8) & 0xFF;
+			frameAddr[i][0][3] =
+				(pEncInfo->frameBufPool[i].bufYBot >> 0) & 0xFF;
+			frameAddr[i][1][0] =
+				(pEncInfo->frameBufPool[i].bufCbBot >> 24) &
+				0xFF;
+			frameAddr[i][1][1] =
+				(pEncInfo->frameBufPool[i].bufCbBot >> 16) &
+				0xFF;
+			frameAddr[i][1][2] =
+				(pEncInfo->frameBufPool[i].bufCbBot >> 8) &
+				0xFF;
+			frameAddr[i][1][3] =
+				(pEncInfo->frameBufPool[i].bufCbBot >> 0) &
+				0xFF;
+			frameAddr[i][2][0] =
+				(pEncInfo->frameBufPool[i].bufCrBot >> 24) &
+				0xFF;
+			frameAddr[i][2][1] =
+				(pEncInfo->frameBufPool[i].bufCrBot >> 16) &
+				0xFF;
+			frameAddr[i][2][2] =
+				(pEncInfo->frameBufPool[i].bufCrBot >> 8) &
+				0xFF;
+			frameAddr[i][2][3] =
+				(pEncInfo->frameBufPool[i].bufCrBot >> 0) &
+				0xFF;
+		}
+		VpuWriteMem(pCodecInst->coreIdx, paraBuffer + 384 + 128,
+			    (BYTE *)frameAddr, sizeof(frameAddr),
+			    VDI_BIG_ENDIAN);
+	}
+
+	// Tell the codec how much frame buffers were allocated.
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_BUF_NUM,
+		    pEncInfo->numFrameBuffers);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_BUF_STRIDE, stride);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_BIT_ADDR,
+		    pEncInfo->secAxiInfo.u.coda9.bufBitUse);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_IPACDC_ADDR,
+		    pEncInfo->secAxiInfo.u.coda9.bufIpAcDcUse);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_DBKY_ADDR,
+		    pEncInfo->secAxiInfo.u.coda9.bufDbkYUse);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_DBKC_ADDR,
+		    pEncInfo->secAxiInfo.u.coda9.bufDbkCUse);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_OVL_ADDR,
+		    pEncInfo->secAxiInfo.u.coda9.bufOvlUse);
+
+	if (pAttr->framebufferCacheType == FramebufCacheMaverickII) {
+		VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_CACHE_CONFIG,
+			    pEncInfo->cacheConfig.type2.CacheMode);
+	} else if (pAttr->framebufferCacheType == FramebufCacheMaverickI) {
+		// Maverick Cache Configuration
+		val = (pEncInfo->cacheConfig.type1.luma.cfg.PageSizeX << 28) |
+		      (pEncInfo->cacheConfig.type1.luma.cfg.PageSizeY << 24) |
+		      (pEncInfo->cacheConfig.type1.luma.cfg.CacheSizeX << 20) |
+		      (pEncInfo->cacheConfig.type1.luma.cfg.CacheSizeY << 16) |
+		      (pEncInfo->cacheConfig.type1.chroma.cfg.PageSizeX << 12) |
+		      (pEncInfo->cacheConfig.type1.chroma.cfg.PageSizeY << 8) |
+		      (pEncInfo->cacheConfig.type1.chroma.cfg.CacheSizeX << 4) |
+		      (pEncInfo->cacheConfig.type1.chroma.cfg.CacheSizeY << 0);
+
+		VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_CACHE_SIZE, val);
+
+		val = (pEncInfo->cacheConfig.type1.Bypass << 4) |
+		      (pEncInfo->cacheConfig.type1.DualConf << 2) |
+		      (pEncInfo->cacheConfig.type1.PageMerge << 0);
+		val = val << 24;
+		val |= (pEncInfo->cacheConfig.type1.luma.cfg.BufferSize << 16) |
+		       (pEncInfo->cacheConfig.type1.chroma.cfg.BufferSize
+			<< 8) |
+		       (pEncInfo->cacheConfig.type1.chroma.cfg.BufferSize << 8);
+
+		VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_CACHE_CONFIG,
+			    val);
+	}
+
+	num = pEncInfo->numFrameBuffers;
+	if (pCodecInst->productId == PRODUCT_ID_960) {
+		Uint32 subsampleLumaSize = stride * height;
+		Uint32 subsampleChromaSize = stride * height / 4; // FORMAT_420
+		vpu_buffer_t vbBuf;
+		FrameBuffer *pFb;
+
+		osal_memset((void *)&vbBuf, 0, sizeof(vpu_buffer_t));
+		vbBuf.size = subsampleLumaSize + 2 * subsampleChromaSize;
+		vbBuf.phys_addr = (PhysicalAddress)0;
+		if (vdi_allocate_dma_memory(pCodecInst->coreIdx, &vbBuf,
+					    pCodecInst->filp) < 0) {
+			pEncInfo->vbSubSampFrame.size = 0;
+			pEncInfo->vbSubSampFrame.phys_addr = 0;
+			return RETCODE_INSUFFICIENT_RESOURCE;
+		}
+		VLOG(TRACE,
+		     "[%d]%s.vdi_allocate_dma_memory vbBuf(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+		     __LINE__, __func__, vbBuf.phys_addr, vbBuf.base,
+		     vbBuf.virt_addr, vbBuf.size, vbBuf.req_spec_region);
+		pFb = &pEncInfo->frameBufPool[num];
+		pFb->bufY = vbBuf.phys_addr;
+		pFb->bufCb = (PhysicalAddress)-1;
+		pFb->bufCr = (PhysicalAddress)-1;
+		pFb->updateFbInfo = TRUE;
+		ret = AllocateLinearFrameBuffer(LINEAR_FRAME_MAP, pFb, 1,
+						subsampleLumaSize,
+						subsampleChromaSize);
+		if (ret != RETCODE_SUCCESS) {
+			pEncInfo->vbSubSampFrame.size = 0;
+			pEncInfo->vbSubSampFrame.phys_addr = 0;
+			return RETCODE_INSUFFICIENT_RESOURCE;
+		}
+		pEncInfo->vbSubSampFrame = vbBuf;
+		num++;
+
+		// Set Sub-Sampling buffer for ME-Reference and DBK-Reconstruction
+		// BPU will swap below two buffer internally every pic by pic
+		val = GetXY2AXIAddr(&pEncInfo->mapCfg, 0, 0, 0, stride, pFb);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_SUBSAMP_A, val);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_SUBSAMP_B,
+			    val + (stride * height / 2));
+
+		if (pCodecInst->codecMode == AVC_ENC &&
+		    pCodecInst->codecModeAux == AVC_AUX_MVC) {
+			vbBuf.size =
+				subsampleLumaSize + 2 * subsampleChromaSize;
+			vbBuf.phys_addr = (PhysicalAddress)0;
+			if (vdi_allocate_dma_memory(pCodecInst->coreIdx, &vbBuf,
+						    pCodecInst->filp) < 0) {
+				pEncInfo->vbSubSampFrame.size = 0;
+				pEncInfo->vbSubSampFrame.phys_addr = 0;
+				return RETCODE_INSUFFICIENT_RESOURCE;
+			}
+			VLOG(TRACE,
+			     "[%d]%s.vdi_allocate_dma_memory vbBuf(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, vbBuf.phys_addr, vbBuf.base,
+			     vbBuf.virt_addr, vbBuf.size,
+			     vbBuf.req_spec_region);
+			pFb = &pEncInfo->frameBufPool[num];
+			pFb->bufY = vbBuf.phys_addr;
+			pFb->bufCb = (PhysicalAddress)-1;
+			pFb->bufCr = (PhysicalAddress)-1;
+			pFb->updateFbInfo = TRUE;
+			ret = AllocateLinearFrameBuffer(LINEAR_FRAME_MAP, pFb,
+							1, subsampleLumaSize,
+							subsampleChromaSize);
+			if (ret != RETCODE_SUCCESS) {
+				pEncInfo->vbMvcSubSampFrame.size = 0;
+				pEncInfo->vbMvcSubSampFrame.phys_addr = 0;
+				return RETCODE_INSUFFICIENT_RESOURCE;
+			}
+			pEncInfo->vbMvcSubSampFrame = vbBuf;
+			num++;
+
+			val = GetXY2AXIAddr(&pEncInfo->mapCfg, 0, 0, 0, stride,
+					    pFb);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_SET_FRAME_SUBSAMP_A_MVC, val);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_SET_FRAME_SUBSAMP_B_MVC,
+				    val + (stride * height / 2));
+		}
+	}
+
+	if (pCodecInst->codecMode == MP4_ENC) {
+		// MPEG4 Encoder Data-Partitioned bitstream temporal buffer
+		pEncInfo->vbScratch.size = SIZE_MP4ENC_DATA_PARTITION;
+		pEncInfo->vbScratch.req_spec_region = 0;
+		if (vdi_allocate_dma_memory(pCodecInst->coreIdx,
+					    &pEncInfo->vbScratch,
+					    pCodecInst->filp) < 0)
+			return RETCODE_INSUFFICIENT_RESOURCE;
+		VLOG(TRACE,
+		     "[%d]%s.vdi_allocate_dma_memory vbScratch(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+		     __LINE__, __func__, pEncInfo->vbScratch.phys_addr,
+		     pEncInfo->vbScratch.base, pEncInfo->vbScratch.virt_addr,
+		     pEncInfo->vbScratch.size,
+		     pEncInfo->vbScratch.req_spec_region);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_DP_BUF_BASE,
+			    pEncInfo->vbScratch.phys_addr);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_DP_BUF_SIZE,
+			    pEncInfo->vbScratch.size >> 10);
+	}
+
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst, SET_FRAME_BUF);
+	if (vdi_wait_vpu_busy(pCodecInst->coreIdx, __VPU_BUSY_TIMEOUT,
+			      BIT_BUSY_FLAG) == -1) {
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, SET_FRAME_BUF, 2);
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, SET_FRAME_BUF, 0);
+
+	if (VpuReadReg(pCodecInst->coreIdx, RET_SET_FRAME_SUCCESS) &
+	    (1 << 31)) {
+		return RETCODE_MEMORY_ACCESS_VIOLATION;
+	}
+
+    VLOG(TRACE, "[-] [%d]%s.h:%p.ret:RETCODE_SUCCESS\n",__LINE__,__func__,(void *)instance);
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuEncode(CodecInst *pCodecInst, EncParam *param)
+{
+	EncInfo *pEncInfo;
+	FrameBuffer *pSrcFrame;
+	Uint32 rotMirMode;
+	Uint32 val;
+	vpu_instance_pool_t *vip;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+    VLOG(TRACE, "[+] [%d]%s.h:%p\n",__LINE__,__func__,(void *)pCodecInst);
+
+	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(pCodecInst->coreIdx);
+	if (!vip) {
+		return RETCODE_INVALID_HANDLE;
+	}
+
+	pSrcFrame = param->sourceFrame;
+	rotMirMode = 0;
+	if (pEncInfo->rotationEnable == TRUE) {
+		switch (pEncInfo->rotationAngle) {
+		case 0:
+			rotMirMode |= 0x0;
+			break;
+		case 90:
+			rotMirMode |= 0x1;
+			break;
+		case 180:
+			rotMirMode |= 0x2;
+			break;
+		case 270:
+			rotMirMode |= 0x3;
+			break;
+		}
+	}
+
+	if (pEncInfo->mirrorEnable == TRUE) {
+		switch (pEncInfo->mirrorDirection) {
+		case MIRDIR_NONE:
+			rotMirMode |= 0x0;
+			break;
+		case MIRDIR_VER:
+			rotMirMode |= 0x4;
+			break;
+		case MIRDIR_HOR:
+			rotMirMode |= 0x8;
+			break;
+		case MIRDIR_HOR_VER:
+			rotMirMode |= 0xc;
+			break;
+		}
+	}
+
+	if (pCodecInst->productId == PRODUCT_ID_980) {
+		rotMirMode |= ((pSrcFrame->endian & 0x03) << 16);
+		rotMirMode |= ((pSrcFrame->cbcrInterleave & 0x01) << 18);
+		rotMirMode |= ((pSrcFrame->sourceLBurstEn & 0x01) << 4);
+	} else {
+		rotMirMode |= ((pSrcFrame->sourceLBurstEn & 0x01) << 4);
+		rotMirMode |= ((pSrcFrame->cbcrInterleave & 0x01) << 18);
+		rotMirMode |= pEncInfo->openParam.nv21 << 21;
+	}
+
+	if (pCodecInst->productId == PRODUCT_ID_980 &&
+	    pCodecInst->codecMode == AVC_ENC) {
+		//ROI command
+		if (param->setROI.mode) {
+			int roi_number = param->setROI.number;
+			int i;
+
+			VpuWriteReg(
+				pCodecInst->coreIdx, CMD_ENC_ROI_MODE,
+				1); // currently, only mode 0 can be supported
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_ROI_NUM,
+				    roi_number);
+
+			for (i = 0; i < roi_number; i++) {
+				VpuRect *rect = &param->setROI.region[i];
+				int data;
+				if (pEncInfo->openParam.EncStdParam.avcParam
+					    .fieldFlag)
+					data = ((((rect->bottom + 16) / 32) &
+						 0xff)
+						<< 24) |
+					       ((((rect->top + 16) / 32) & 0xff)
+						<< 16) |
+					       ((((rect->right + 8) / 16) &
+						 0xff)
+						<< 8) |
+					       (((rect->left + 8) / 16) & 0xff);
+				else
+					data = ((((rect->bottom + 8) / 16) &
+						 0xff)
+						<< 24) |
+					       ((((rect->top + 8) / 16) & 0xff)
+						<< 16) |
+					       ((((rect->right + 8) / 16) &
+						 0xff)
+						<< 8) |
+					       (((rect->left + 8) / 16) & 0xff);
+
+#ifdef SUPPORT_ROI_50
+				VpuWriteReg(pCodecInst->coreIdx,
+					    CMD_ENC_ROI_POS_0, data);
+				VpuWriteReg(pCodecInst->coreIdx,
+					    CMD_ENC_ROI_QP_0,
+					    param->setROI.qp[i]);
+				VpuWriteReg(pCodecInst->coreIdx,
+					    CMD_ENC_ROI_INDEX, i);
+				Coda9BitIssueCommand(pCodecInst->coreIdx,
+						     pCodecInst, ENC_ROI_INIT);
+				if (vdi_wait_vpu_busy(pCodecInst->coreIdx,
+						      __VPU_BUSY_TIMEOUT,
+						      BIT_BUSY_FLAG) == -1) {
+					if (pCodecInst->loggingEnable)
+						vdi_log(pCodecInst->coreIdx,
+							ENC_ROI_INIT, 2);
+					SetPendingInst(pCodecInst->coreIdx, 0);
+					LeaveLock(pCodecInst->coreIdx);
+					return RETCODE_VPU_RESPONSE_TIMEOUT;
+				}
+
+				if (pCodecInst->loggingEnable)
+					vdi_log(pCodecInst->coreIdx,
+						ENC_ROI_INIT, 0);
+				if (!VpuReadReg(pCodecInst->coreIdx,
+						RET_ENC_ROI_SUCCESS)) {
+					SetPendingInst(pCodecInst->coreIdx, 0);
+					LeaveLock(pCodecInst->coreIdx);
+					return RETCODE_FAILURE;
+				}
+#else
+				VpuWriteReg(pCodecInst->coreIdx,
+					    CMD_ENC_ROI_POS_0 + i * 8, data);
+				VpuWriteReg(pCodecInst->coreIdx,
+					    CMD_ENC_ROI_QP_0 + i * 8,
+					    param->setROI.qp[i]);
+#endif
+			}
+#ifdef SUPPORT_ROI_50
+#else
+			Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst,
+					     ENC_ROI_INIT);
+			if (vdi_wait_vpu_busy(pCodecInst->coreIdx,
+					      __VPU_BUSY_TIMEOUT,
+					      BIT_BUSY_FLAG) == -1) {
+				if (pCodecInst->loggingEnable)
+					vdi_log(pCodecInst->coreIdx,
+						ENC_ROI_INIT, 0);
+				LeaveLock(pCodecInst->coreIdx);
+				return RETCODE_VPU_RESPONSE_TIMEOUT;
+			}
+			if (pCodecInst->loggingEnable)
+				vdi_log(pCodecInst->coreIdx, ENC_ROI_INIT, 0);
+			if (!VpuReadReg(pCodecInst->coreIdx,
+					RET_ENC_ROI_SUCCESS)) {
+				LeaveLock(pCodecInst->coreIdx);
+				return RETCODE_FAILURE;
+			}
+#endif
+		} // if (param->setROI.mode)
+
+		{
+			int ActivePPSIdx = pEncInfo->ActivePPSIdx;
+			AvcPpsParam *ActvePPS =
+				&pEncInfo->openParam.EncStdParam.avcParam
+					 .ppsParam[ActivePPSIdx];
+			if (ActvePPS->entropyCodingMode == 2) {
+				int pic_idx;
+				int gop_num;
+				int slice_type = 0; // 0 = Intra, 1 =inter
+				int mvc_second_view;
+
+				pic_idx = pEncInfo->openParam.EncStdParam
+							  .avcParam.fieldFlag ?
+						  2 * pEncInfo->frameIdx +
+							  pEncInfo->fieldDone :
+						  pEncInfo->frameIdx;
+				gop_num =
+					pEncInfo->openParam.EncStdParam.avcParam
+							.fieldFlag ?
+						2 * pEncInfo->openParam.gopSize :
+						pEncInfo->openParam.gopSize;
+				mvc_second_view =
+					pEncInfo->openParam.EncStdParam.avcParam
+						.mvcExtension &&
+					(!pEncInfo->openParam.EncStdParam
+						  .avcParam.interviewEn);
+				if (pEncInfo->openParam.EncStdParam.avcParam
+					    .mvcExtension)
+					gop_num *= 2;
+				UNREFERENCED_PARAMETER(mvc_second_view);
+				UNREFERENCED_PARAMETER(slice_type);
+
+				if (gop_num == 0) // Only first I
+				{
+					if (pic_idx == 0 || pic_idx == 1)
+						slice_type = 0;
+					else
+						slice_type = 1;
+				} else if (gop_num == 1) // All I
+				{
+					slice_type = 0;
+				} else {
+					if ((pic_idx % gop_num) == 0 ||
+					    (pic_idx % gop_num) == 1) // I frame
+						slice_type = 0;
+					else // P frame
+						slice_type = 1;
+				}
+				if (pEncInfo->openParam.EncStdParam.avcParam
+					    .mvcExtension) {
+					if (pEncInfo->openParam.EncStdParam
+						    .avcParam.interviewEn) {
+						if (slice_type == 0 &&
+						    (pic_idx % 2) == 0) {
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_ENABLE,
+								(1 << 11) +
+									(1
+									 << 7)); // change_enable. pps_id, entropy_coding_mode
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_CABAC_MODE,
+								0); // pps-id
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_PPS_ID,
+								0); // cabac_mode
+						} else if (slice_type != 0 &&
+							   (pic_idx % 2) == 0) {
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_ENABLE,
+								(1 << 11) +
+									(1
+									 << 7)); // change_enable. pps_id, entropy_coding_mode
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_CABAC_MODE,
+								1); // pps-id
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_PPS_ID,
+								1); // cabac_mode
+						}
+
+						else //(slice_type==0 && pic_idx%2 !=0)
+						{
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_ENABLE,
+								(1 << 11) +
+									(1
+									 << 7)); // change_enable. pps_id, entropy_coding_mode
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_CABAC_MODE,
+								1); // pps-id
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_PPS_ID,
+								3); // cabac_mode
+						}
+					} else {
+						if (slice_type == 0 &&
+						    (pic_idx % 2) == 0) {
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_ENABLE,
+								0x880); // change_enable. pps_id, entropy_coding_mode
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_CABAC_MODE,
+								0); // pps-id
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_PPS_ID,
+								0); // cabac_mode
+						}
+
+						else if (slice_type != 0 &&
+							 (pic_idx % 2) == 0) {
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_ENABLE,
+								0x880); // change_enable. pps_id, entropy_coding_mode
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_CABAC_MODE,
+								1); // pps-id
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_PPS_ID,
+								1); // cabac_mode
+						}
+
+						else if (slice_type == 0 &&
+							 (pic_idx % 2) != 0) {
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_ENABLE,
+								0x880); // change_enable. pps_id, entropy_coding_mode
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_CABAC_MODE,
+								0); // pps-id
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_PPS_ID,
+								2); // cabac_mode
+						}
+
+						else //if(slice_type!=0 && pic_idx%2 !=0)
+						{
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_ENABLE,
+								0x880); // change_enable. pps_id, entropy_coding_mode
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_CABAC_MODE,
+								1); // pps-id
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_PPS_ID,
+								3); // cabac_mode
+						}
+					}
+				} else {
+					VpuWriteReg(
+						pCodecInst->coreIdx,
+						CMD_ENC_PARAM_CHANGE_ENABLE,
+						0x880); // change_enable. ppsId, entropyCodingMode
+					//default set by I (ID=0, mode=0)
+					VpuWriteReg(
+						pCodecInst->coreIdx,
+						CMD_ENC_PARAM_CHANGE_CABAC_MODE,
+						0);
+					VpuWriteReg(pCodecInst->coreIdx,
+						    CMD_ENC_PARAM_CHANGE_PPS_ID,
+						    0);
+					if (gop_num == 0) // only first I
+					{
+						if (pic_idx != 0) {
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_CABAC_MODE,
+								1);
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_PPS_ID,
+								1);
+						}
+					} else if (gop_num != 1) // not All I
+					{
+						if ((pic_idx % gop_num) !=
+						    0) // P frame
+						{
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_CABAC_MODE,
+								1);
+							VpuWriteReg(
+								pCodecInst
+									->coreIdx,
+								CMD_ENC_PARAM_CHANGE_PPS_ID,
+								1);
+						}
+					}
+				}
+				Coda9BitIssueCommand(pCodecInst->coreIdx,
+						     pCodecInst,
+						     RC_CHANGE_PARAMETER);
+				if (vdi_wait_vpu_busy(pCodecInst->coreIdx,
+						      __VPU_BUSY_TIMEOUT,
+						      BIT_BUSY_FLAG) == -1) {
+					if (pCodecInst->loggingEnable)
+						vdi_log(pCodecInst->coreIdx,
+							RC_CHANGE_PARAMETER, 0);
+					LeaveLock(pCodecInst->coreIdx);
+					return RETCODE_VPU_RESPONSE_TIMEOUT;
+				}
+				if (pCodecInst->loggingEnable)
+					vdi_log(pCodecInst->coreIdx,
+						RC_CHANGE_PARAMETER, 0);
+			}
+		}
+	}
+
+	if (pCodecInst->productId == PRODUCT_ID_960) {
+		if (pEncInfo->mapType > LINEAR_FRAME_MAP &&
+		    pEncInfo->mapType <= TILED_MIXED_V_MAP) {
+			SetTiledFrameBase(pCodecInst->coreIdx,
+					  pEncInfo->vbFrame.phys_addr);
+		} else {
+			SetTiledFrameBase(pCodecInst->coreIdx, 0);
+		}
+	}
+
+	if (pEncInfo->mapType != LINEAR_FRAME_MAP &&
+	    pEncInfo->mapType != LINEAR_FIELD_MAP) {
+		if (pEncInfo->stride > pEncInfo->frameBufferHeight)
+			val = SetTiledMapType(
+				pCodecInst->coreIdx, &pEncInfo->mapCfg,
+				pEncInfo->mapType, pEncInfo->stride,
+				pEncInfo->openParam.cbcrInterleave,
+				&pEncInfo->dramCfg);
+		else
+			val = SetTiledMapType(
+				pCodecInst->coreIdx, &pEncInfo->mapCfg,
+				pEncInfo->mapType, pEncInfo->frameBufferHeight,
+				pEncInfo->openParam.cbcrInterleave,
+				&pEncInfo->dramCfg);
+	} else {
+		val = SetTiledMapType(pCodecInst->coreIdx, &pEncInfo->mapCfg,
+				      pEncInfo->mapType, pEncInfo->stride,
+				      pEncInfo->openParam.cbcrInterleave,
+				      &pEncInfo->dramCfg);
+	}
+	if (val == 0) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	rotMirMode |= pEncInfo->openParam.nv21 << 21;
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PIC_ROT_MODE, rotMirMode);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PIC_QS, param->quantParam);
+
+	if (param->skipPicture) {
+		if (param->fieldRun) { // not support field + skipPicture
+			return RETCODE_INVALID_PARAM;
+		}
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PIC_OPTION,
+			    (param->fieldRun << 8) | 1);
+	} else {
+		// Registering Source Frame Buffer information
+		// Hide GDI IF under FW level
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PIC_SRC_INDEX,
+			    pSrcFrame->myIndex);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PIC_SRC_STRIDE,
+			    pSrcFrame->stride);
+		if (pEncInfo->openParam.cbcrOrder == CBCR_ORDER_NORMAL) {
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PIC_SRC_ADDR_Y,
+				    pSrcFrame->bufY);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_PIC_SRC_ADDR_CB, pSrcFrame->bufCb);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_PIC_SRC_ADDR_CR, pSrcFrame->bufCr);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_PIC_SRC_BOTTOM_Y,
+				    pSrcFrame->bufYBot);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_PIC_SRC_BOTTOM_CB,
+				    pSrcFrame->bufCbBot);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_PIC_SRC_BOTTOM_CR,
+				    pSrcFrame->bufCrBot);
+		} else { // CBCR_ORDER_REVERSED (YV12)
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PIC_SRC_ADDR_Y,
+				    pSrcFrame->bufY);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_PIC_SRC_ADDR_CB, pSrcFrame->bufCr);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_PIC_SRC_ADDR_CR, pSrcFrame->bufCb);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_PIC_SRC_BOTTOM_Y,
+				    pSrcFrame->bufYBot);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_PIC_SRC_BOTTOM_CB,
+				    pSrcFrame->bufCrBot);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_PIC_SRC_BOTTOM_CR,
+				    pSrcFrame->bufCbBot);
+		}
+
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PIC_OPTION,
+			    (param->fieldRun << 8) |
+				    (param->forceIPicture << 1 & 0x2));
+	}
+
+	if (pEncInfo->ringBufferEnable == 0) {
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PIC_BB_START,
+			    param->picStreamBufferAddr);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PIC_BB_SIZE,
+			    param->picStreamBufferSize / 1024); // size in KB
+		VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamRdPtrRegAddr,
+			    param->picStreamBufferAddr);
+		pEncInfo->streamRdPtr = param->picStreamBufferAddr;
+	}
+
+	val = 0;
+	val = ((pEncInfo->secAxiInfo.u.coda9.useBitEnable & 0x01) << 0 |
+	       (pEncInfo->secAxiInfo.u.coda9.useIpEnable & 0x01) << 1 |
+	       (pEncInfo->secAxiInfo.u.coda9.useDbkYEnable & 0x01) << 2 |
+	       (pEncInfo->secAxiInfo.u.coda9.useDbkCEnable & 0x01) << 3 |
+	       (pEncInfo->secAxiInfo.u.coda9.useOvlEnable & 0x01) << 4 |
+	       (pEncInfo->secAxiInfo.u.coda9.useBtpEnable & 0x01) << 5 |
+	       (pEncInfo->secAxiInfo.u.coda9.useBitEnable & 0x01) << 8 |
+	       (pEncInfo->secAxiInfo.u.coda9.useIpEnable & 0x01) << 9 |
+	       (pEncInfo->secAxiInfo.u.coda9.useDbkYEnable & 0x01) << 10 |
+	       (pEncInfo->secAxiInfo.u.coda9.useDbkCEnable & 0x01) << 11 |
+	       (pEncInfo->secAxiInfo.u.coda9.useOvlEnable & 0x01) << 12 |
+	       (pEncInfo->secAxiInfo.u.coda9.useBtpEnable & 0x01) << 13);
+
+	VpuWriteReg(pCodecInst->coreIdx, BIT_AXI_SRAM_USE, val);
+
+	VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamWrPtrRegAddr,
+		    pEncInfo->streamWrPtr);
+	VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamRdPtrRegAddr,
+		    pEncInfo->streamRdPtr);
+	VpuWriteReg(pCodecInst->coreIdx, BIT_BIT_STREAM_PARAM,
+		    pEncInfo->streamEndflag);
+
+	SetEncFrameMemInfo(pCodecInst);
+
+	val = 0;
+	if (pEncInfo->ringBufferEnable == 0) {
+		if (pEncInfo->lineBufIntEn)
+			val |= (0x1 << 6);
+		val |= (0x1 << 5);
+		val |= (0x1 << 4);
+	} else {
+		val |= (0x1 << 3);
+	}
+	val |= pEncInfo->openParam.streamEndian;
+	VpuWriteReg(pCodecInst->coreIdx, BIT_BIT_STREAM_CTRL, val);
+
+	if (pCodecInst->productId == PRODUCT_ID_980)
+		VpuWriteReg(pCodecInst->coreIdx, BIT_ME_LINEBUFFER_MODE,
+			    VPU_ME_LINEBUFFER_MODE); // default
+
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst, PIC_RUN);
+
+#ifdef GET_PERFORMANCE
+	gettimeofday(&start_enc_tv, NULL);
+#endif
+
+    VLOG(TRACE, "[-] [%d]%s.h:%p.ret:RETCODE_SUCCESS\n",__LINE__,__func__,(void *)pCodecInst);
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuEncGetResult(CodecInst *pCodecInst, EncOutputInfo *info)
+{
+	EncInfo *pEncInfo;
+	PhysicalAddress rdPtr;
+	PhysicalAddress wrPtr;
+	Uint32 pic_enc_result;
+
+    VLOG(TRACE, "[+] [%d]%s.h:%p\n",__LINE__,__func__,(void *)pCodecInst);
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, PIC_RUN, 0);
+
+	pic_enc_result = VpuReadReg(pCodecInst->coreIdx, RET_ENC_PIC_SUCCESS);
+	if (pic_enc_result & (1 << 31)) {
+		return RETCODE_MEMORY_ACCESS_VIOLATION;
+	}
+
+	if (pCodecInst->productId == PRODUCT_ID_980) {
+		if (pic_enc_result & 2) { //top field coding done
+			if (!pEncInfo->fieldDone)
+				pEncInfo->fieldDone = 1;
+		} else {
+			pEncInfo->frameIdx = VpuReadReg(pCodecInst->coreIdx,
+							RET_ENC_PIC_FRAME_NUM);
+			pEncInfo->fieldDone = 0;
+		}
+	}
+
+	info->picType = VpuReadReg(pCodecInst->coreIdx, RET_ENC_PIC_TYPE);
+
+	if (pEncInfo->ringBufferEnable == 0) {
+		rdPtr = VpuReadReg(pCodecInst->coreIdx,
+				   pEncInfo->streamRdPtrRegAddr);
+		wrPtr = VpuReadReg(pCodecInst->coreIdx,
+				   pEncInfo->streamWrPtrRegAddr);
+		info->bitstreamBuffer = rdPtr;
+		info->bitstreamSize = wrPtr - rdPtr;
+	}
+
+	info->numOfSlices =
+		VpuReadReg(pCodecInst->coreIdx, RET_ENC_PIC_SLICE_NUM);
+	info->bitstreamWrapAround =
+		VpuReadReg(pCodecInst->coreIdx, RET_ENC_PIC_FLAG);
+	info->reconFrameIndex =
+		VpuReadReg(pCodecInst->coreIdx, RET_ENC_PIC_FRAME_IDX);
+	info->reconFrame = pEncInfo->frameBufPool[info->reconFrameIndex];
+	info->encSrcIdx = info->reconFrameIndex;
+
+	pEncInfo->streamWrPtr =
+		VpuReadReg(pCodecInst->coreIdx, pEncInfo->streamWrPtrRegAddr);
+	pEncInfo->streamEndflag =
+		VpuReadReg(pCodecInst->coreIdx, BIT_BIT_STREAM_PARAM);
+
+	info->frameCycle = VpuReadReg(pCodecInst->coreIdx, BIT_FRAME_CYCLE);
+	info->rdPtr = pEncInfo->streamRdPtr;
+	info->wrPtr = pEncInfo->streamWrPtr;
+
+    VLOG(TRACE, "[-] [%d]%s.h:%p.ret:RETCODE_SUCCESS\n",__LINE__,__func__,(void *)pCodecInst);
+	return RETCODE_SUCCESS;
+}
+
+RetCode Coda9VpuEncGiveCommand(CodecInst *pCodecInst, CodecCommand cmd,
+			       void *param)
+{
+	RetCode ret = RETCODE_SUCCESS;
+
+	UNREFERENCED_PARAMETER(cmd);
+	UNREFERENCED_PARAMETER(param);
+
+	switch (cmd) {
+	default:
+		ret = RETCODE_NOT_SUPPORTED_FEATURE;
+	}
+
+	return ret;
+}
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_vpu.h
@@ -0,0 +1,97 @@
+//--=========================================================================--
+//  This file is a part of VPU Reference API project
+//-----------------------------------------------------------------------------
+//
+//       This confidential and proprietary software may be used only
+//     as authorized by a licensing agreement from Chips&Media Inc.
+//     In the event of publication, the following notice is applicable:
+//
+//            (C) COPYRIGHT 2006 - 2011  CHIPS&MEDIA INC.
+//                      ALL RIGHTS RESERVED
+//
+//       The entire notice above must be reproduced on all authorized
+//       copies.
+//
+//--=========================================================================--
+#ifndef __CODA9_FUNCTION_H__
+#define __CODA9_FUNCTION_H__
+
+#include "ve1_vpuapi.h"
+#include "ve1_product.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+extern void Coda9BitIssueCommand(Uint32 coreIdx, CodecInst *inst, int cmd);
+
+extern Uint32 Coda9VpuGetProductId(Uint32 coreIdx);
+
+extern RetCode Coda9VpuGetVersion(Uint32 coreIdx, Uint32 *versionInfo,
+				  Uint32 *revision);
+
+extern RetCode Coda9VpuInit(Uint32 coreIdx, void *firmware, Uint32 size);
+
+extern RetCode Coda9VpuReInit(Uint32 coreIdx, void *firmware, Uint32 size);
+
+extern Uint32 Coda9VpuIsInit(Uint32 coreIdx);
+
+extern Int32 Coda9VpuIsBusy(Uint32 coreIdx);
+
+extern Int32 Coda9VpuWaitInterrupt(CodecInst *handle, Int32 timeout);
+
+extern RetCode Coda9VpuReset(Uint32 coreIdx, SWResetMode resetMode);
+
+extern RetCode Coda9VpuSleepWake(Uint32 coreIdx, int iSleepWake,
+				 const Uint16 *code, Uint32 size);
+
+extern RetCode Coda9VpuClearInterrupt(Uint32 coreIdx);
+
+extern RetCode Coda9VpuFiniSeq(CodecInst *instance);
+
+extern RetCode Coda9VpuBuildUpDecParam(CodecInst *instance,
+				       DecOpenParam *param);
+
+extern RetCode Coda9VpuDecInitSeq(CodecInst *instance);
+
+extern RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance);
+
+extern RetCode Coda9VpuDecSetBitstreamFlag(CodecInst *instance, BOOL running,
+					   BOOL eos);
+
+extern RetCode Coda9VpuDecGetSeqInfo(CodecInst *instance, DecInitialInfo *info);
+
+extern RetCode Coda9VpuDecode(CodecInst *instance, DecParam *option);
+
+extern RetCode Coda9VpuDecGetResult(CodecInst *instance, DecOutputInfo *result);
+
+extern RetCode Coda9VpuDecFlush(CodecInst *instance,
+				FramebufferIndex *framebufferIndexes,
+				Uint32 size);
+
+extern RetCode Coda9VpuDecCpbFlush(CodecInst *instance);
+/************************************************************************/
+/* Encoder                                                              */
+/************************************************************************/
+extern RetCode Coda9VpuEncRegisterFramebuffer(CodecInst *instance);
+
+extern RetCode Coda9VpuBuildUpEncParam(CodecInst *pCodec, EncOpenParam *param);
+
+extern RetCode Coda9VpuEncSetup(CodecInst *instance);
+
+extern RetCode Coda9VpuEncode(CodecInst *pCodecInst, EncParam *param);
+
+extern RetCode Coda9VpuEncGetResult(CodecInst *pCodecInst, EncOutputInfo *info);
+
+extern RetCode Coda9VpuEncGiveCommand(CodecInst *pCodecInst, CodecCommand cmd,
+				      void *param);
+
+#ifdef ENABLE_TEE_DRM_FLOW
+extern RetCode Coda9VpuInitProtect(Uint32 coreIdx, void *firmware, Uint32 size,
+				   void *sess, void *rtk_sess, void *filp);
+#endif
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __CODA9_FUNCTION_H__ */
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_vpu_md5.h
@@ -0,0 +1,15 @@
+#ifndef _RVSD_DBG_MD5_H_
+//#include <stdio.h>
+//#include <stdlib.h>
+//#include <string.h>
+
+typedef struct MD5state_st {
+	unsigned int A, B, C, D;
+	unsigned int Nl, Nh;
+	unsigned int data[16];
+	unsigned int num;
+} MD5_CTX;
+
+unsigned char *MD5(const unsigned char *d, size_t n, unsigned char *md);
+
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_vpuapi.c
@@ -0,0 +1,5006 @@
+//--=========================================================================--
+//  This file is a part of VPU Reference API project
+//-----------------------------------------------------------------------------
+//
+//       This confidential and proprietary software may be used only
+//     as authorized by a licensing agreement from Chips&Media Inc.
+//     In the event of publication, the following notice is applicable:
+//
+//            (C) COPYRIGHT 2006 - 2013  CHIPS&MEDIA INC.
+//                      ALL RIGHTS RESERVED
+//
+//       The entire notice above must be reproduced on all authorized
+//       copies.
+//
+//--=========================================================================--
+
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/tee_drv.h>
+#include "ve1_vpuapifunc.h"
+#include "ve1_product.h"
+
+#ifdef DAH_222_PREALLOC_MV_SLICE_BUFFER
+/*
+ * Fixed DAH-222 , Stark NTS DRS AL1 video freeze
+ * Sometime during video resultion change, ion realloc need cost long time.
+ * In NonTunnel playback, we prealloc max buffer can reduce realloc time for these items.
+ */
+#include "ve1_vpuconfig.h"
+#endif
+
+#ifdef VE1_CHECKSUM
+#include <mcp_api.h>
+#define HASH_SIZE 32
+#endif
+
+#ifdef BIT_CODE_FILE_PATH
+#include BIT_CODE_FILE_PATH
+#endif
+
+#define INVALID_CORE_INDEX_RETURN_ERROR(_coreIdx)                              \
+	if (_coreIdx >= MAX_NUM_VPU_CORE)                                      \
+		return -1;
+
+Uint32 __VPU_BUSY_TIMEOUT = VPU_BUSY_CHECK_TIMEOUT;
+
+unsigned long vpu_ring_valid_data(unsigned long ring_base,
+				  unsigned long ring_limit,
+				  unsigned long ring_rp, unsigned long ring_wp)
+{
+	if (ring_wp >= ring_rp) {
+		return (ring_wp - ring_rp);
+	} else {
+		return (ring_limit - ring_base) - (ring_rp - ring_wp);
+	}
+}
+
+#ifdef ENABLE_TEE_DRM_FLOW
+extern int ta_TEEapi_init(struct tee_context **teeapi_ctx,
+			  unsigned int *teeapi_tee_session);
+extern int ta_TEEapi_deinit(struct tee_context *teeapi_ctx,
+			    unsigned int teeapi_tee_session);
+extern int ta_TEEapi_bitstreamprint(struct tee_context *teeapi_ctx,
+				    unsigned int teeapi_tee_session,
+				    unsigned int phy_addr, int size);
+extern int ta_TEEapi_bitstreamout(struct tee_context *teeapi_ctx,
+				  unsigned int teeapi_tee_session,
+				  unsigned int srcPAddr, unsigned char *buf,
+				  int size);
+extern int ta_TEEapi_memcpy(struct tee_context *teeapi_ctx,
+			    unsigned int teeapi_tee_session,
+			    unsigned int dstPhysAddr, unsigned int srtPhysAddr,
+			    int size);
+
+RetCode VPU_InitWithBitcodeProtect(Uint32 coreIdx, const Uint16 *code,
+				   Uint32 size, void *sess, void *rtk_sess,
+				   void *filp)
+{
+	RetCode ret;
+
+	if (coreIdx >= MAX_NUM_VPU_CORE)
+		return RETCODE_INVALID_PARAM;
+	if (code == NULL || size == 0)
+		return RETCODE_INVALID_PARAM;
+
+	if (vdi_init(coreIdx) < 0)
+		return RETCODE_FAILURE;
+
+	if (ProductVpuScan(coreIdx) == 0) {
+		return RETCODE_NOT_FOUND_VPU_DEVICE;
+	}
+
+	InitCodecInstancePool(coreIdx);
+
+	ret = ProductVpuReset(coreIdx, SW_RESET_ON_BOOT);
+	if (ret != RETCODE_SUCCESS) {
+		return ret;
+	}
+
+	ret = ProductVpuInitProtect(coreIdx, (void *)code, size, sess, rtk_sess,
+				    filp);
+	if (ret != RETCODE_SUCCESS) {
+		return ret;
+	}
+	return RETCODE_SUCCESS;
+}
+#endif
+
+static RetCode CheckInstanceValidity(CodecInst *pCodecInst)
+{
+	int i;
+	vpu_instance_pool_t *vip;
+
+	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(pCodecInst->coreIdx);
+	if (!vip)
+		return RETCODE_INSUFFICIENT_RESOURCE;
+
+	for (i = 0; i < MAX_NUM_INSTANCE; i++) {
+		if ((CodecInst *)vip->codecInstPool[i] == pCodecInst)
+			return RETCODE_SUCCESS;
+	}
+
+	return RETCODE_INVALID_HANDLE;
+}
+
+static RetCode CheckDecInstanceValidity(CodecInst *pCodecInst)
+{
+	RetCode ret;
+
+	if (pCodecInst == NULL)
+		return RETCODE_INVALID_HANDLE;
+
+	ret = CheckInstanceValidity(pCodecInst);
+	if (ret != RETCODE_SUCCESS) {
+		return RETCODE_INVALID_HANDLE;
+	}
+	if (!pCodecInst->inUse) {
+		return RETCODE_INVALID_HANDLE;
+	}
+
+	return ProductVpuDecCheckCapability(pCodecInst);
+}
+
+Int32 VPU_IsBusy(Uint32 coreIdx)
+{
+	Uint32 ret = 0;
+
+	INVALID_CORE_INDEX_RETURN_ERROR(coreIdx);
+
+	SetClockGate(coreIdx, 1);
+	ret = ProductVpuIsBusy(coreIdx);
+	SetClockGate(coreIdx, 0);
+
+	return ret != 0;
+}
+
+Int32 VPU_IsInit(Uint32 coreIdx)
+{
+	Int32 pc;
+	VLOG(TRACE, "[+] [%d]%s\n", __LINE__, __func__);
+
+	INVALID_CORE_INDEX_RETURN_ERROR(coreIdx);
+
+	SetClockGate(coreIdx, 1);
+	pc = ProductVpuIsInit(coreIdx);
+	SetClockGate(coreIdx, 0);
+
+	VLOG(TRACE, "[-] [%d]%s.pc:0x%x\n", __LINE__, __func__, pc);
+	return pc;
+}
+
+Int32 VPU_WaitInterrupt(Uint32 coreIdx, int timeout)
+{
+	Int32 ret;
+	CodecInst *instance;
+
+	INVALID_CORE_INDEX_RETURN_ERROR(coreIdx);
+
+	if ((instance = GetPendingInst(coreIdx)) != NULL) {
+		ret = ProductVpuWaitInterrupt(instance, timeout);
+		VLOG(TRACE, "[%d]%s.coreIdx:%d.timeout:%d.ret:%d\n", __LINE__,
+		     __func__, coreIdx, timeout, ret);
+	} else {
+		ret = -1;
+		VLOG(TRACE, "[%d]%s.coreIdx:%d.timeout:%d.ret:-1\n", __LINE__,
+		     __func__, coreIdx, timeout);
+	}
+
+	return ret;
+}
+
+Int32 VPU_WaitInterruptEx(VpuHandle handle, int timeout)
+{
+	Int32 ret;
+	CodecInst *pCodecInst;
+
+	pCodecInst = handle;
+
+	INVALID_CORE_INDEX_RETURN_ERROR(pCodecInst->coreIdx);
+
+	ret = ProductVpuWaitInterrupt(pCodecInst, timeout);
+
+	return ret;
+}
+
+void VPU_ClearInterrupt(Uint32 coreIdx)
+{
+	/* clear all interrupt flags */
+	ProductVpuClearInterrupt(coreIdx, 0xffff);
+	VLOG(TRACE, "[%d]%s.coreIdx:%d\n", __LINE__, __func__, coreIdx);
+}
+
+void VPU_ClearInterruptEx(VpuHandle handle, Int32 intrFlag)
+{
+	CodecInst *pCodecInst;
+
+	pCodecInst = handle;
+
+	ProductVpuClearInterrupt(pCodecInst->coreIdx, intrFlag);
+}
+
+int VPU_GetMvColBufSize(CodStd codStd, int width, int height, int num)
+{
+	int size_mvcolbuf = ProductCalculateAuxBufferSize(
+		AUX_BUF_TYPE_MVCOL, codStd, width, height);
+
+	if (codStd == STD_AVC || codStd == STD_HEVC || codStd == STD_VP9)
+		size_mvcolbuf *= num;
+
+	return size_mvcolbuf;
+}
+
+RetCode VPU_GetFBCOffsetTableSize(CodStd codStd, int width, int height,
+				  int *ysize, int *csize)
+{
+	if (ysize == NULL || csize == NULL)
+		return RETCODE_INVALID_PARAM;
+
+	*ysize = ProductCalculateAuxBufferSize(AUX_BUF_TYPE_FBC_Y_OFFSET,
+					       codStd, width, height);
+	*csize = ProductCalculateAuxBufferSize(AUX_BUF_TYPE_FBC_C_OFFSET,
+					       codStd, width, height);
+
+	return RETCODE_SUCCESS;
+}
+
+int VPU_GetFrameBufSize(int coreIdx, int stride, int height, int mapType,
+			int format, int interleave, DRAMConfig *pDramCfg)
+{
+	int productId;
+	UNREFERENCED_PARAMETER(interleave); /*!<< for backward compatiblity */
+
+	if (coreIdx < 0 || coreIdx >= MAX_NUM_VPU_CORE)
+		return -1;
+
+	productId = ProductVpuGetId(coreIdx);
+
+	return ProductCalculateFrameBufSize(productId, stride, height,
+					    (TiledMapType)mapType,
+					    (FrameBufferFormat)format,
+					    (BOOL)interleave, pDramCfg);
+}
+
+int VPU_GetProductId(int coreIdx)
+{
+	Int32 productId = -1;
+
+	VLOG(TRACE, "[+] [%d]%s\n", __LINE__, __func__);
+
+	INVALID_CORE_INDEX_RETURN_ERROR(coreIdx);
+
+	if (ProductVpuScan(coreIdx) == FALSE) {
+		VLOG(ERR, "[-] [%d]%s.ProductVpuScan() fail.coreIdx:%d\n",
+		     __LINE__, __func__, coreIdx);
+		return -1;
+	}
+	productId = ProductVpuGetId(coreIdx);
+	VLOG(TRACE, "[-] [%d]%s.productId:%d\n", __LINE__, __func__, productId);
+	return productId;
+}
+
+int VPU_GetOpenInstanceNum(Uint32 coreIdx)
+{
+	INVALID_CORE_INDEX_RETURN_ERROR(coreIdx);
+
+	return vdi_get_instance_num(coreIdx);
+}
+
+static RetCode InitializeVPU(Uint32 coreIdx, const Uint16 *code, Uint32 size, void *videc_dev)
+{
+	RetCode ret;
+	VLOG(TRACE, "[+] [%d]%s.code:0x%px.size:%d\n", __LINE__, __func__, code,
+	     size);
+
+	if (vdi_init(coreIdx, videc_dev) < 0) {
+		VLOG(ERR, "[%d]vdi_init() fail.coreIdx:%d", __LINE__, coreIdx);
+		return RETCODE_FAILURE;
+	}
+
+	EnterLock(coreIdx);
+
+	if (ProductVpuScan(coreIdx) == 0) {
+		LeaveLock(coreIdx);
+		VLOG(ERR, "[-] [%d]%s.RETCODE_NOT_FOUND_VPU_DEVICE\n", __LINE__,
+		     __func__);
+		return RETCODE_NOT_FOUND_VPU_DEVICE;
+	}
+
+	if (VPU_IsInit(coreIdx) != 0) {
+		SetClockGate(coreIdx, 1);
+		ProductVpuGetProductId(coreIdx);
+		LeaveLock(coreIdx);
+		VLOG(INFO, "[-] [%d]%s.RETCODE_CALLED_BEFORE\n", __LINE__,
+		     __func__);
+		return RETCODE_CALLED_BEFORE;
+	} else if (size == 0) //RTK
+	{
+		VLOG(WARN,
+		     "[%d]VPU didn't initial, we should re-load fw again\n",
+		     __LINE__);
+		LeaveLock(coreIdx);
+		vdi_release(coreIdx);
+		VLOG(TRACE, "[-] [%d]%s.RETCODE_NOT_FOUND_BITCODE_PATH\n",
+		     __LINE__, __func__);
+		return RETCODE_NOT_FOUND_BITCODE_PATH;
+	}
+
+	InitCodecInstancePool(coreIdx);
+
+	SetClockGate(coreIdx, 1);
+	ret = ProductVpuReset(coreIdx, SW_RESET_ON_BOOT);
+	if (ret != RETCODE_SUCCESS) {
+		LeaveLock(coreIdx);
+		VLOG(ERR, "[-] [%d]%s.ProductVpuReset() fail.ret:%d\n",
+		     __LINE__, __func__, ret);
+		return ret;
+	}
+
+	ret = ProductVpuInit(coreIdx, (void *)code, size);
+	if (ret != RETCODE_SUCCESS) {
+		LeaveLock(coreIdx);
+		VLOG(ERR, "[-] [%d]%s.ProductVpuInit() fail.ret:%d\n", __LINE__,
+		     __func__, ret);
+		return ret;
+	}
+	LeaveLock(coreIdx);
+	VLOG(TRACE, "[-] [%d]%s\n", __LINE__, __func__);
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_Init(Uint32 coreIdx, void *videc_dev)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	VLOG(INFO, "[+] [%d]%s.coreIdx:%d\n", __LINE__, __func__, coreIdx);
+	if (coreIdx >= MAX_NUM_VPU_CORE) {
+		VLOG(ERR, "[-] [%d]%s.coreIdx:%d.ret:RETCODE_INVALID_PARAM\n",
+		     __LINE__, __func__, coreIdx);
+		return RETCODE_INVALID_PARAM;
+	}
+
+	ret = InitializeVPU(coreIdx, NULL, 0, videc_dev);
+	VLOG(INFO, "[-] [%d]%s.coreIdx:%d.ret:%d\n", __LINE__, __func__,
+	     coreIdx, ret);
+	return ret;
+}
+
+RetCode VPU_InitWithBitcode(Uint32 coreIdx, const Uint16 *code, Uint32 size, void *videc_dev)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	VLOG(TRACE, "[+] [%d]%s.code:%px.size:%d\n", __LINE__, __func__, code,
+	     size);
+	if (coreIdx >= MAX_NUM_VPU_CORE) {
+		VLOG(ERR, "[-] [%d]%s.RETCODE_INVALID_PARAM\n", __LINE__,
+		     __func__);
+		return RETCODE_INVALID_PARAM;
+	}
+	if (code == NULL || size == 0) {
+		VLOG(ERR, "[-] [%d]%s.RETCODE_INVALID_PARAM\n", __LINE__,
+		     __func__);
+		return RETCODE_INVALID_PARAM;
+	}
+
+	ret = InitializeVPU(coreIdx, code, size, videc_dev);
+	VLOG(TRACE, "[-] [%d]%s.ret:%d\n", __LINE__, __func__, ret);
+	return ret;
+}
+
+RetCode VPU_DeInit(Uint32 coreIdx)
+{
+	int ret;
+
+	if (coreIdx >= MAX_NUM_VPU_CORE)
+		return RETCODE_INVALID_PARAM;
+
+	ret = vdi_release(coreIdx);
+	if (ret != 0) {
+		VLOG(ERR, "[%d]%s.coreIdx:%d.ret:0x%x\n", __LINE__, __func__,
+		     coreIdx, ret);
+		return RETCODE_FAILURE;
+	}
+
+	VLOG(INFO, "[%d]%s.coreIdx:%d.ret:RETCODE_SUCCESS\n", __LINE__,
+	     __func__, coreIdx);
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_GetVersionInfo(Uint32 coreIdx, Uint32 *versionInfo,
+			   Uint32 *revision, Uint32 *productId)
+{
+	RetCode ret;
+
+	if (coreIdx >= MAX_NUM_VPU_CORE)
+		return RETCODE_INVALID_PARAM;
+
+	EnterLock(coreIdx);
+
+	if (ProductVpuIsInit(coreIdx) == 0) {
+		LeaveLock(coreIdx);
+		return RETCODE_NOT_INITIALIZED;
+	}
+
+	if (GetPendingInst(coreIdx)) {
+		LeaveLock(coreIdx);
+		return RETCODE_FRAME_NOT_COMPLETE;
+	}
+
+	if (productId != NULL) {
+		*productId = ProductVpuGetId(coreIdx);
+	}
+	ret = ProductVpuGetVersion(coreIdx, versionInfo, revision);
+
+	LeaveLock(coreIdx);
+
+	return ret;
+}
+RetCode VPU_DecOpen(DecHandle *pHandle, DecOpenParam *pop)
+{
+	CodecInst *pCodecInst = 0;
+	DecInfo *pDecInfo;
+	RetCode ret;
+#if defined(ENABLE_TEE_DRM_FLOW)
+	int ret_teeapi;
+#endif
+
+	VLOG(TRACE, "[+] [%d]%s\n", __LINE__, __func__);
+	ret = ProductCheckDecOpenParam(pop);
+	if (ret != RETCODE_SUCCESS) {
+		VLOG(ERR, "[-] [%d]%s.ProductCheckDecOpenParam fail.ret:%d\n",
+		     __LINE__, __func__, ret);
+		return ret;
+	}
+
+	VLOG(TRACE, "[bitstreamFormat    ]: %d\n", pop->bitstreamFormat);
+	VLOG(TRACE, "[bitstreamBuffer    ]: 0x%08x\n", pop->bitstreamBuffer);
+	VLOG(TRACE, "[bitstreamBufferSize]: %d\n", pop->bitstreamBufferSize);
+	VLOG(TRACE, "[mp4DeblkEnable     ]: %d\n", pop->mp4DeblkEnable);
+	VLOG(TRACE, "[avcExtension       ]: %d\n", pop->avcExtension);
+	VLOG(TRACE, "[mp4Class           ]: %d\n", pop->mp4Class);
+	VLOG(TRACE, "[tiled2LinearEnable ]: %d\n", pop->tiled2LinearEnable);
+	VLOG(TRACE, "[tiled2LinearMode   ]: %d\n", pop->tiled2LinearMode);
+	VLOG(TRACE, "[wtlEnable          ]: %d\n", pop->wtlEnable);
+	VLOG(TRACE, "[wtlMode            ]: %d\n", pop->wtlMode);
+	VLOG(TRACE, "[cbcrInterleave     ]: %d\n", pop->cbcrInterleave);
+	VLOG(TRACE, "[nv21               ]: %d\n", pop->nv21);
+	VLOG(TRACE, "[cbcrOrder          ]: %d\n", pop->cbcrOrder);
+	VLOG(TRACE, "[BWB                ]: %d\n", pop->bwbEnable);
+	VLOG(TRACE, "[frameEndian        ]: %d\n", pop->frameEndian);
+	VLOG(TRACE, "[streamEndian       ]: %d\n", pop->streamEndian);
+	VLOG(TRACE, "[bitstreamMode      ]: %d\n", pop->bitstreamMode);
+	VLOG(TRACE, "[coreIdx            ]: %d\n", pop->coreIdx);
+	VLOG(TRACE, "[vbWork.size        ]: %d\n", pop->vbWork.size);
+	VLOG(TRACE, "[vbWork.phys_addr   ]: 0x%08lx\n", pop->vbWork.phys_addr);
+	VLOG(TRACE, "[vbWork.base        ]: 0x%08lx\n", pop->vbWork.base);
+	VLOG(TRACE, "[vbWork.virt_addr   ]: 0x%08lx\n", pop->vbWork.virt_addr);
+	VLOG(TRACE, "[vbWork.region      ]: %d\n", pop->vbWork.req_spec_region);
+	VLOG(TRACE, "[fbc_mode           ]: %d\n", pop->fbc_mode);
+	VLOG(TRACE, "[virtAxiID          ]: %d\n", pop->virtAxiID);
+	VLOG(TRACE, "[bwOptimization     ]: %d\n", pop->bwOptimization);
+	VLOG(TRACE, "[afbceEnable        ]: %d\n", pop->afbceEnable);
+	VLOG(TRACE, "[afbceFormat        ]: %d\n", pop->afbceFormat);
+	VLOG(TRACE, "[isUseProtectBuffer ]: %d\n", pop->isUseProtectBuffer);
+	VLOG(TRACE, "[sess               ]: %p\n", pop->sess);
+	VLOG(TRACE, "[rtk_sess           ]: %p\n", pop->rtk_sess);
+
+	EnterLock(pop->coreIdx);
+
+	if (VPU_IsInit(pop->coreIdx) == 0) {
+		LeaveLock(pop->coreIdx);
+		VLOG(ERR, "[-] [%d]%s.ret:RETCODE_NOT_INITIALIZED\n",
+		     __LINE__, __func__);
+		return RETCODE_NOT_INITIALIZED;
+	}
+
+	ret = GetCodecInstance(pop->coreIdx, &pCodecInst, pop->filp);
+	if (ret != RETCODE_SUCCESS) {
+		*pHandle = 0;
+		LeaveLock(pop->coreIdx);
+		VLOG(ERR, "[-] [%d]%s.GetCodecInstance fail.ret:%d\n", __LINE__,
+		     __func__, ret);
+		return ret;
+	}
+
+#if defined(ENABLE_TEE_DRM_FLOW)
+	ret_teeapi =
+		ta_TEEapi_init((struct tee_context **)&pCodecInst->teeapi_ctx,
+			       &pCodecInst->teeapi_tee_session);
+	if (ret_teeapi < 0) {
+		*pHandle = 0;
+		LeaveLock(pop->coreIdx);
+		VLOG(ERR, "[-] [%d]%s.ta_TEEapi_init() fail.ret:%d\n", __LINE__,
+		     __func__, ret_teeapi);
+		return RETCODE_FAILURE;
+	}
+#endif
+
+	pCodecInst->isDecoder = TRUE;
+	*pHandle = pCodecInst;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+	osal_memset(pDecInfo, 0x00, sizeof(DecInfo));
+	osal_memcpy((void *)&pDecInfo->openParam, pop, sizeof(DecOpenParam));
+
+	if (pop->bitstreamFormat == STD_MPEG4) {
+		pCodecInst->codecMode = MP4_DEC;
+		pCodecInst->codecModeAux = MP4_AUX_MPEG4;
+	} else if (pop->bitstreamFormat == STD_AVC) {
+		pCodecInst->codecMode = AVC_DEC;
+		pCodecInst->codecModeAux = pop->avcExtension;
+	} else if (pop->bitstreamFormat == STD_VC1) {
+		pCodecInst->codecMode = VC1_DEC;
+	} else if (pop->bitstreamFormat == STD_MPEG2) {
+		pCodecInst->codecMode = MP2_DEC;
+	} else if (pop->bitstreamFormat == STD_H263) {
+		pCodecInst->codecMode = MP4_DEC;
+		pCodecInst->codecModeAux = MP4_AUX_MPEG4;
+	} else if (pop->bitstreamFormat == STD_UNKNOWN3) {
+		pCodecInst->codecMode = DV3_DEC;
+		pCodecInst->codecModeAux = MP4_AUX_UNKNOWN3;
+	} else if (pop->bitstreamFormat == STD_RV) {
+		pCodecInst->codecMode = RV_DEC;
+	} else if (pop->bitstreamFormat == STD_AVS) {
+		pCodecInst->codecMode = AVS_DEC;
+	} else if (pop->bitstreamFormat == STD_THO) {
+		pCodecInst->codecMode = VPX_DEC;
+		pCodecInst->codecModeAux = VPX_AUX_THO;
+	} else if (pop->bitstreamFormat == STD_VP3) {
+		pCodecInst->codecMode = VPX_DEC;
+		pCodecInst->codecModeAux = VPX_AUX_THO;
+	} else if (pop->bitstreamFormat == STD_VP8) {
+		pCodecInst->codecMode = VPX_DEC;
+		pCodecInst->codecModeAux = VPX_AUX_VP8;
+	} else if (pop->bitstreamFormat == STD_HEVC) {
+		pCodecInst->codecMode = HEVC_DEC;
+	} else if (pop->bitstreamFormat == STD_VP9) {
+		pCodecInst->codecMode = W_VP9_DEC;
+	} else if (pop->bitstreamFormat == STD_AVS2) {
+		pCodecInst->codecMode = W_AVS2_DEC;
+	} else {
+		LeaveLock(pop->coreIdx);
+		VLOG(ERR,
+		     "[-] [%d]%s.ret:RETCODE_INVALID_PARAM.unknown bitstreamFormat:%d\n",
+		     __LINE__, __func__, pop->bitstreamFormat);
+		return RETCODE_INVALID_PARAM;
+	}
+
+	pDecInfo->enableAfbce = pop->afbceEnable;
+	pDecInfo->afbceFormat = pop->afbceFormat;
+	pDecInfo->wtlEnable = pop->wtlEnable;
+	pDecInfo->wtlMode = pop->wtlMode;
+	if (!pDecInfo->wtlEnable)
+		pDecInfo->wtlMode = 0;
+
+	pDecInfo->streamWrPtr = pop->bitstreamBuffer;
+	pDecInfo->streamRdPtr = pop->bitstreamBuffer;
+	pDecInfo->frameDelay = -1;
+	pDecInfo->streamBufStartAddr = pop->bitstreamBuffer;
+	pDecInfo->streamBufSize = pop->bitstreamBufferSize;
+	pDecInfo->streamBufEndAddr =
+		pop->bitstreamBuffer + pop->bitstreamBufferSize;
+	pDecInfo->reorderEnable = VPU_REORDER_ENABLE;
+	pDecInfo->mirrorDirection = MIRDIR_NONE;
+#ifdef FIX_SET_GET_RD_PTR_BUG
+#else
+	pDecInfo->prevFrameEndPos = pop->bitstreamBuffer;
+#endif
+
+	//ENABLE_TEE_DRM_FLOW //For RTK DRM flow
+	pCodecInst->isUseProtectBuffer = pop->isUseProtectBuffer;
+	pCodecInst->sess = pop->sess;
+	pCodecInst->rtk_sess = pop->rtk_sess;
+	pCodecInst->enableDcsysDebug = pop->enableDcsysDebug;
+
+	SetClockGate(pop->coreIdx, TRUE);
+	if ((ret = ProductVpuDecBuildUpOpenParam(pCodecInst, pop)) !=
+	    RETCODE_SUCCESS) {
+		SetClockGate(pop->coreIdx, FALSE);
+		*pHandle = 0;
+		LeaveLock(pCodecInst->coreIdx);
+		VLOG(ERR,
+		     "[-] [%d]%s.ProductVpuDecBuildUpOpenParam fail.ret:%d\n",
+		     __LINE__, __func__, ret);
+		return ret;
+	}
+	SetClockGate(pop->coreIdx, FALSE);
+
+	pDecInfo->tiled2LinearEnable = pop->tiled2LinearEnable;
+	pDecInfo->tiled2LinearMode = pop->tiled2LinearMode;
+	if (!pDecInfo->tiled2LinearEnable)
+		pDecInfo->tiled2LinearMode = 0; //coda980 only
+
+	if (!pDecInfo->wtlEnable) //coda980, wave320, wave410 only
+		pDecInfo->wtlMode = 0;
+
+	osal_memset((void *)&pDecInfo->cacheConfig, 0x00,
+		    sizeof(MaverickCacheConfig));
+#ifdef VE1_CHECKSUM
+	memset(&pDecInfo->hashTable, 0, sizeof(vpu_buffer_t));
+	pDecInfo->hashTable.size = HASH_SIZE;
+	if (vdi_allocate_dma_memory(pCodecInst->coreIdx, &pDecInfo->hashTable,
+				    pCodecInst->filp) < 0) {
+		pDecInfo->hashTable.size = 0;
+		VLOG(ERR, "fail to allocate checksum buffer");
+		return RETCODE_FAILURE;
+	}
+	VLOG(TRACE,
+	     "[%d]%s.vdi_allocate_dma_memory hashTable(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+	     __LINE__, __func__, pDecInfo->hashTable.phys_addr,
+	     pDecInfo->hashTable.base, pDecInfo->hashTable.virt_addr,
+	     pDecInfo->hashTable.size, pDecInfo->hashTable.req_spec_region);
+#endif
+
+#ifdef DAH_222_PREALLOC_MV_SLICE_BUFFER
+	int size_mvcolbuf = 0;
+	vpu_buffer_t vbBuffer;
+	size_mvcolbuf = ((PREALLOC_MV_WIDTH + 31) & ~31) *
+			((PREALLOC_MV_HEIGHT + 31) & ~31);
+	size_mvcolbuf = (size_mvcolbuf * 3) / 2;
+	size_mvcolbuf = (size_mvcolbuf + 4) / 5;
+	size_mvcolbuf = ((size_mvcolbuf + 7) / 8) * 8;
+	vbBuffer.size = size_mvcolbuf;
+	vbBuffer.phys_addr = 0;
+	for (int i = 0; i < PREALLOC_MV_BUFFER_COUNT; i++) {
+		//ENABLE_TEE_DRM_FLOW
+		if (pCodecInst->isUseProtectBuffer)
+			vbBuffer.req_spec_region = VE_SECURE_PROTECTION;
+		else
+			vbBuffer.req_spec_region = 0;
+
+		if (pDecInfo->vbMV[i].size == 0) {
+			if (vdi_allocate_dma_memory(pCodecInst->coreIdx,
+						    &vbBuffer) < 0) {
+				return RETCODE_FAILURE;
+			}
+			pDecInfo->vbMV[i] = vbBuffer;
+			VLOG(TRACE,
+			     "[%d]%s.vdi_allocate_dma_memory vbMV[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, i, pDecInfo->vbMV[i].phys_addr,
+			     pDecInfo->vbMV[i].base,
+			     pDecInfo->vbMV[i].virt_addr,
+			     pDecInfo->vbMV[i].size,
+			     pDecInfo->vbMV[i].req_spec_region);
+		}
+	}
+
+	if (pCodecInst->codecMode == VPX_DEC) {
+		vpu_buffer_t *pvbSlice = &pDecInfo->vbSlice;
+		if (pvbSlice->size == 0) {
+			pvbSlice->size = VP8_MB_SAVE_SIZE;
+			//ENABLE_TEE_DRM_FLOW
+			if (pCodecInst->isUseProtectBuffer)
+				pvbSlice->req_spec_region =
+					VE_SECURE_PROTECTION;
+			else
+				pvbSlice->req_spec_region = 0;
+
+			if (vdi_allocate_dma_memory(pCodecInst->coreIdx,
+						    pvbSlice) < 0) {
+				return RETCODE_INSUFFICIENT_RESOURCE;
+			}
+			VLOG(TRACE,
+			     "[%d]%s.vdi_allocate_dma_memory vbSlice(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, pvbSlice->phys_addr,
+			     pvbSlice->base, pvbSlice->virt_addr,
+			     pvbSlice->size, pvbSlice->req_spec_region);
+		}
+	}
+
+	if (pCodecInst->codecMode == AVC_DEC) {
+		vpu_buffer_t *pvbSlice = &pDecInfo->vbSlice;
+		if (pvbSlice->size == 0) {
+			pvbSlice->size = SLICE_SAVE_SIZE;
+			//ENABLE_TEE_DRM_FLOW
+			if (pCodecInst->isUseProtectBuffer)
+				pvbSlice->req_spec_region =
+					VE_SECURE_PROTECTION;
+			else
+				pvbSlice->req_spec_region = 0;
+
+			if (vdi_allocate_dma_memory(pCodecInst->coreIdx,
+						    pvbSlice) < 0) {
+				return RETCODE_INSUFFICIENT_RESOURCE;
+			}
+			VLOG(TRACE,
+			     "[%d]%s.vdi_allocate_dma_memory vbSlice(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, pvbSlice->phys_addr,
+			     pvbSlice->base, pvbSlice->virt_addr,
+			     pvbSlice->size, pvbSlice->req_spec_region);
+		}
+	}
+#endif // #ifdef DAH_222_PREALLOC_MV_SLICE_BUFFER
+
+	// for debug, enable logging by vpuapi self
+	//pCodecInst->loggingEnable = 1;
+
+	LeaveLock(pCodecInst->coreIdx);
+
+	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:RETCODE_SUCCESS\n", __LINE__,
+	     __func__, *pHandle);
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_DecClose(DecHandle handle)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	RetCode ret;
+	int i;
+#if defined(ENABLE_TEE_DRM_FLOW)
+	int ret_teeapi;
+#endif
+
+	VLOG(TRACE, "[+] [%d]%s.h:0x%x\n", __LINE__, __func__, handle);
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS) {
+		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
+		     handle, ret);
+		return ret;
+	}
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	if ((ret = ProductVpuDecFiniSeq(pCodecInst)) != RETCODE_SUCCESS) {
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, DEC_SEQ_END, 0);
+
+		if (ret == RETCODE_VPU_STILL_RUNNING) {
+			LeaveLock(pCodecInst->coreIdx);
+			VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__,
+			     __func__, handle, ret);
+			return ret;
+		}
+	}
+
+#if defined(ENABLE_TEE_DRM_FLOW)
+	ret_teeapi =
+		ta_TEEapi_deinit((struct tee_context *)pCodecInst->teeapi_ctx,
+				 pCodecInst->teeapi_tee_session);
+	if (ret_teeapi < 0) {
+		LeaveLock(pCodecInst->coreIdx);
+		VLOG(ERR, "[%d]%s.ta_TEEapi_deinit() fail.ret:%d\n", __LINE__,
+		     __func__, ret_teeapi);
+		return RETCODE_FAILURE;
+	}
+#endif
+
+	if (pDecInfo->vbSlice.size) {
+		VLOG(TRACE,
+		     "[%d]%s.vdi_free_dma_memory_no_mmap vbSlice(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+		     __LINE__, __func__, pDecInfo->vbSlice.phys_addr,
+		     pDecInfo->vbSlice.base, pDecInfo->vbSlice.virt_addr,
+		     pDecInfo->vbSlice.size, pDecInfo->vbSlice.req_spec_region);
+		vdi_free_dma_memory_no_mmap(pCodecInst->coreIdx,
+					    &pDecInfo->vbSlice);
+	}
+
+	if (pDecInfo->vbWork.size) {
+		if (pDecInfo->workBufferAllocExt == 0) {
+			VLOG(TRACE,
+			     "[%d]%s.vdi_free_dma_memory_no_mmap vbWork(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, pDecInfo->vbWork.phys_addr,
+			     pDecInfo->vbWork.base, pDecInfo->vbWork.virt_addr,
+			     pDecInfo->vbWork.size,
+			     pDecInfo->vbWork.req_spec_region);
+			vdi_free_dma_memory_no_mmap(pCodecInst->coreIdx,
+						    &pDecInfo->vbWork);
+		} else {
+			vdi_dettach_dma_memory(pCodecInst->coreIdx,
+					       &pDecInfo->vbWork);
+		}
+	}
+
+	if (pDecInfo->vbFrame.size) {
+		if (pDecInfo->frameAllocExt == 0) {
+			VLOG(TRACE,
+			     "[%d]%s.vdi_free_dma_memory vbFrame(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, pDecInfo->vbFrame.phys_addr,
+			     pDecInfo->vbFrame.base,
+			     pDecInfo->vbFrame.virt_addr,
+			     pDecInfo->vbFrame.size,
+			     pDecInfo->vbFrame.req_spec_region);
+			vdi_free_dma_memory(pCodecInst->coreIdx,
+					    &pDecInfo->vbFrame);
+		}
+	}
+	for (i = 0; i < MAX_REG_FRAME; i++) {
+		if (pDecInfo->vbMV[i].size) {
+			VLOG(TRACE,
+			     "[%d]%s.vdi_free_dma_memory_no_mmap vbMV[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, i, pDecInfo->vbMV[i].phys_addr,
+			     pDecInfo->vbMV[i].base,
+			     pDecInfo->vbMV[i].virt_addr,
+			     pDecInfo->vbMV[i].size,
+			     pDecInfo->vbMV[i].req_spec_region);
+			vdi_free_dma_memory_no_mmap(pCodecInst->coreIdx,
+						    &pDecInfo->vbMV[i]);
+		}
+		if (pDecInfo->vbFbcYTbl[i].size) {
+			if (pDecInfo->fbcTblAllocExt == 0) {
+				VLOG(TRACE,
+				     "[%d]%s.vdi_free_dma_memory vbFbcYTbl[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+				     __LINE__, __func__, i,
+				     pDecInfo->vbFbcYTbl[i].phys_addr,
+				     pDecInfo->vbFbcYTbl[i].base,
+				     pDecInfo->vbFbcYTbl[i].virt_addr,
+				     pDecInfo->vbFbcYTbl[i].size,
+				     pDecInfo->vbFbcYTbl[i].req_spec_region);
+				vdi_free_dma_memory(pCodecInst->coreIdx,
+						    &pDecInfo->vbFbcYTbl[i]);
+			}
+		}
+		if (pDecInfo->vbFbcCTbl[i].size) {
+			if (pDecInfo->fbcTblAllocExt == 0) {
+				VLOG(TRACE,
+				     "[%d]%s.vdi_free_dma_memory vbFbcCTbl[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+				     __LINE__, __func__, i,
+				     pDecInfo->vbFbcCTbl[i].phys_addr,
+				     pDecInfo->vbFbcCTbl[i].base,
+				     pDecInfo->vbFbcCTbl[i].virt_addr,
+				     pDecInfo->vbFbcCTbl[i].size,
+				     pDecInfo->vbFbcCTbl[i].req_spec_region);
+				vdi_free_dma_memory(pCodecInst->coreIdx,
+						    &pDecInfo->vbFbcCTbl[i]);
+			}
+		}
+	}
+
+	if (pDecInfo->vbTemp.size)
+		vdi_dettach_dma_memory(pCodecInst->coreIdx, &pDecInfo->vbTemp);
+
+	if (pDecInfo->vbPPU.size) {
+		if (pDecInfo->ppuAllocExt == 0) {
+			VLOG(TRACE,
+			     "[%d]%s.vdi_free_dma_memory vbPPU(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, pDecInfo->vbPPU.phys_addr,
+			     pDecInfo->vbPPU.base, pDecInfo->vbPPU.virt_addr,
+			     pDecInfo->vbPPU.size,
+			     pDecInfo->vbPPU.req_spec_region);
+			vdi_free_dma_memory(pCodecInst->coreIdx,
+					    &pDecInfo->vbPPU);
+		}
+	}
+
+	if (pDecInfo->vbWTL.size) {
+		VLOG(TRACE,
+		     "[%d]%s.vdi_free_dma_memory vbWTL(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+		     __LINE__, __func__, pDecInfo->vbWTL.phys_addr,
+		     pDecInfo->vbWTL.base, pDecInfo->vbWTL.virt_addr,
+		     pDecInfo->vbWTL.size, pDecInfo->vbWTL.req_spec_region);
+		vdi_free_dma_memory(pCodecInst->coreIdx, &pDecInfo->vbWTL);
+	}
+
+	if (pDecInfo->vbUserData.size)
+		vdi_dettach_dma_memory(pCodecInst->coreIdx,
+				       &pDecInfo->vbUserData);
+
+	if (pDecInfo->vbReport.size) {
+		VLOG(TRACE,
+		     "[%d]%s.vdi_free_dma_memory vbReport(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+		     __LINE__, __func__, pDecInfo->vbReport.phys_addr,
+		     pDecInfo->vbReport.base, pDecInfo->vbReport.virt_addr,
+		     pDecInfo->vbReport.size,
+		     pDecInfo->vbReport.req_spec_region);
+		vdi_free_dma_memory(pCodecInst->coreIdx, &pDecInfo->vbReport);
+	}
+
+	if (GetPendingInst(pCodecInst->coreIdx) == pCodecInst)
+		ClearPendingInst(pCodecInst->coreIdx);
+
+#ifdef VE1_CHECKSUM
+	if (pDecInfo->hashTable.size) {
+		Uint8 *result = (Uint8 *)pDecInfo->hashTable.virt_addr;
+		Uint32 sum = 0;
+		int i;
+		for (i = 0; i < HASH_SIZE; i++)
+			sum += result[i];
+		if (sum > 0)
+			VLOG(TRACE,
+			     "[RTKCKS]= Fianl Hash = %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x",
+			     result[0], result[1], result[2], result[3],
+			     result[4], result[5], result[6], result[7],
+			     result[8], result[9], result[10], result[11],
+			     result[12], result[13], result[14], result[15],
+			     result[16], result[17], result[18], result[19],
+			     result[20], result[21], result[22], result[23],
+			     result[24], result[25], result[26], result[27],
+			     result[28], result[29], result[30], result[31]);
+		VLOG(TRACE,
+		     "[%d]%s.vdi_free_dma_memory hashTable(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+		     __LINE__, __func__, pDecInfo->hashTable.phys_addr,
+		     pDecInfo->hashTable.base, pDecInfo->hashTable.virt_addr,
+		     pDecInfo->hashTable.size,
+		     pDecInfo->hashTable.req_spec_region);
+		vdi_free_dma_memory(pCodecInst->coreIdx, &pDecInfo->hashTable);
+	}
+#endif
+
+	LeaveLock(pCodecInst->coreIdx);
+
+	FreeCodecInstance(pCodecInst);
+
+	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__, handle,
+	     ret);
+	return ret;
+}
+
+RetCode VPU_DecSetEscSeqInit(DecHandle handle, int escape)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	RetCode ret;
+
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	if (pDecInfo->openParam.bitstreamMode != BS_MODE_INTERRUPT)
+		return RETCODE_INVALID_PARAM;
+
+	pDecInfo->seqInitEscape = escape;
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_DecGetInitialInfo(DecHandle handle, DecInitialInfo *info)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	RetCode ret;
+	Int32 flags;
+	Uint32 interruptBit;
+	VpuAttr *pAttr;
+
+	/* CODA9xx */
+	interruptBit = INT_BIT_SEQ_INIT;
+
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	if (info == NULL)
+		return RETCODE_INVALID_PARAM;
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+	ret = ProductVpuDecCheckCapability(pCodecInst);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
+
+	if (GetPendingInst(pCodecInst->coreIdx)) {
+		/* The other instance is running */
+		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
+		{
+			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
+			     __func__, __LINE__);
+			msleep(50);
+			if (GetPendingInst(pCodecInst->coreIdx)) {
+				LeaveLock(pCodecInst->coreIdx);
+				return RETCODE_FRAME_NOT_COMPLETE;
+			}
+		} else {
+			LeaveLock(pCodecInst->coreIdx);
+			return RETCODE_FRAME_NOT_COMPLETE;
+		}
+	}
+
+	if (DecBitstreamBufEmpty(pDecInfo)) {
+		LeaveLock(pCodecInst->coreIdx);
+		return RETCODE_WRONG_CALL_SEQUENCE;
+	}
+
+	ret = ProductVpuDecInitSeq(handle);
+	if (ret != RETCODE_SUCCESS) {
+		LeaveLock(pCodecInst->coreIdx);
+		return ret;
+	}
+
+	if (pAttr->supportCommandQueue == TRUE) {
+		LeaveLock(pCodecInst->coreIdx);
+	}
+
+	flags = ProductVpuWaitInterrupt(pCodecInst, __VPU_BUSY_TIMEOUT);
+
+	if (pAttr->supportCommandQueue == TRUE) {
+		EnterLock(pCodecInst->coreIdx);
+	}
+
+	if (flags == -1) {
+		info->rdPtr = VpuReadReg(pCodecInst->coreIdx,
+					 pDecInfo->streamRdPtrRegAddr);
+		info->wrPtr = VpuReadReg(pCodecInst->coreIdx,
+					 pDecInfo->streamWrPtrRegAddr);
+		ret = RETCODE_VPU_RESPONSE_TIMEOUT;
+	} else {
+		if (flags & (1 << interruptBit))
+			ProductVpuClearInterrupt(pCodecInst->coreIdx,
+						 (1 << interruptBit));
+
+		if (flags != (1 << interruptBit))
+			ret = RETCODE_FAILURE;
+		else
+			ret = ProductVpuDecGetSeqInfo(handle, info);
+	}
+
+	info->rdPtr =
+		VpuReadReg(pCodecInst->coreIdx, pDecInfo->streamRdPtrRegAddr);
+	info->wrPtr =
+		VpuReadReg(pCodecInst->coreIdx, pDecInfo->streamWrPtrRegAddr);
+
+	pDecInfo->initialInfo = *info;
+	if (ret == RETCODE_SUCCESS) {
+		pDecInfo->initialInfoObtained = 1;
+	}
+
+	SetPendingInst(pCodecInst->coreIdx, 0);
+
+	LeaveLock(pCodecInst->coreIdx);
+
+	return ret;
+}
+
+RetCode VPU_DecIssueSeqInit(DecHandle handle)
+{
+	CodecInst *pCodecInst;
+	RetCode ret;
+	VpuAttr *pAttr;
+
+	VLOG(TRACE, "[+] [%d]%s.h:0x%x\n", __LINE__, __func__, handle);
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS) {
+		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
+		     handle, ret);
+		return ret;
+	}
+
+	pCodecInst = handle;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
+
+	if (GetPendingInst(pCodecInst->coreIdx)) {
+		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
+		{
+			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
+			     __func__, __LINE__);
+			msleep(50);
+			if (GetPendingInst(pCodecInst->coreIdx)) {
+				LeaveLock(pCodecInst->coreIdx);
+				VLOG(ERR,
+				     "[-] [%d]%s.h:0x%x.ret:RETCODE_FRAME_NOT_COMPLETE\n",
+				     __LINE__, __func__, handle);
+				return RETCODE_FRAME_NOT_COMPLETE;
+			}
+		} else {
+			LeaveLock(pCodecInst->coreIdx);
+			VLOG(ERR,
+			     "[-] [%d]%s.h:0x%x.ret:RETCODE_FRAME_NOT_COMPLETE\n",
+			     __LINE__, __func__, handle);
+			return RETCODE_FRAME_NOT_COMPLETE;
+		}
+	}
+
+	ret = ProductVpuDecInitSeq(handle);
+	if (ret == RETCODE_SUCCESS) {
+		SetPendingInst(pCodecInst->coreIdx, pCodecInst);
+	}
+
+	if (pAttr->supportCommandQueue == TRUE) {
+		SetPendingInst(pCodecInst->coreIdx, NULL);
+		LeaveLock(pCodecInst->coreIdx);
+	}
+
+	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__, handle,
+	     ret);
+	return ret;
+}
+
+RetCode VPU_DecCompleteSeqInit(DecHandle handle, DecInitialInfo *info)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	RetCode ret;
+	VpuAttr *pAttr;
+
+	VLOG(TRACE, "[+] [%d]%s.h:0x%x\n", __LINE__, __func__, handle);
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS) {
+		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
+		     handle, ret);
+		return ret;
+	}
+
+	if (info == 0) {
+		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:RETCODE_INVALID_PARAM\n",
+		     __LINE__, __func__, handle);
+		return RETCODE_INVALID_PARAM;
+	}
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
+
+	if (pAttr->supportCommandQueue == TRUE) {
+		EnterLock(pCodecInst->coreIdx);
+	} else {
+		if (pCodecInst != GetPendingInst(pCodecInst->coreIdx)) {
+			SetPendingInst(pCodecInst->coreIdx, 0);
+			LeaveLock(pCodecInst->coreIdx);
+			VLOG(ERR,
+			     "[-] [%d]%s.h:0x%x.ret:RETCODE_WRONG_CALL_SEQUENCE\n",
+			     __LINE__, __func__, handle);
+			return RETCODE_WRONG_CALL_SEQUENCE;
+		}
+	}
+
+	ret = ProductVpuDecGetSeqInfo(handle, info);
+	if (ret == RETCODE_SUCCESS) {
+		pDecInfo->initialInfoObtained = 1;
+	}
+
+	info->rdPtr = ProductVpuDecGetRdPtr(pCodecInst);
+	info->wrPtr =
+		VpuReadReg(pCodecInst->coreIdx, pDecInfo->streamWrPtrRegAddr);
+#ifdef FIX_SET_GET_RD_PTR_BUG
+#else
+	pDecInfo->prevFrameEndPos = info->rdPtr;
+#endif
+	pDecInfo->initialInfo = *info;
+
+	VLOG(TRACE, "[picWidth                ]: %d\n", info->picWidth);
+	VLOG(TRACE, "[picHeight               ]: %d\n", info->picHeight);
+	VLOG(TRACE, "[fRateNumerator          ]: %d\n", info->fRateNumerator);
+	VLOG(TRACE, "[fRateDenominator        ]: %d\n", info->fRateDenominator);
+	VLOG(TRACE, "[picCropRect.left        ]: %d\n", info->picCropRect.left);
+	VLOG(TRACE, "[picCropRect.top         ]: %d\n", info->picCropRect.top);
+	VLOG(TRACE, "[picCropRect.right       ]: %d\n",
+	     info->picCropRect.right);
+	VLOG(TRACE, "[picCropRect.bottom      ]: %d\n",
+	     info->picCropRect.bottom);
+	VLOG(TRACE, "[mp4DataPartitionEnable  ]: %d\n",
+	     info->mp4DataPartitionEnable);
+	VLOG(TRACE, "[mp4ReversibleVlcEnable  ]: %d\n",
+	     info->mp4ReversibleVlcEnable);
+	VLOG(TRACE, "[mp4ShortVideoHeader     ]: %d\n",
+	     info->mp4ShortVideoHeader);
+	VLOG(TRACE, "[h263AnnexJEnable        ]: %d\n", info->h263AnnexJEnable);
+	VLOG(TRACE, "[minFrameBufferCount     ]: %d\n",
+	     info->minFrameBufferCount);
+	VLOG(TRACE, "[frameBufDelay           ]: %d\n", info->frameBufDelay);
+	VLOG(TRACE, "[normalSliceSize         ]: %d\n", info->normalSliceSize);
+	VLOG(TRACE, "[worstSliceSize          ]: %d\n", info->worstSliceSize);
+	VLOG(TRACE, "[maxSubLayers            ]: %d\n", info->maxSubLayers);
+	VLOG(TRACE, "[profile                 ]: %d\n", info->profile);
+	VLOG(TRACE, "[level                   ]: %d\n", info->level);
+	VLOG(TRACE, "[tier                    ]: %d\n", info->tier);
+	VLOG(TRACE, "[interlace               ]: %d\n", info->interlace);
+	VLOG(TRACE, "[constraint_set_flag     ]: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+	     info->constraint_set_flag[0], info->constraint_set_flag[1],
+	     info->constraint_set_flag[2], info->constraint_set_flag[3]);
+	VLOG(TRACE, "[direct8x8Flag           ]: %d\n", info->direct8x8Flag);
+	VLOG(TRACE, "[vc1Psf                  ]: %d\n", info->vc1Psf);
+	VLOG(TRACE, "[isExtSAR                ]: %d\n", info->isExtSAR);
+	VLOG(TRACE, "[maxNumRefFrmFlag        ]: %d\n", info->maxNumRefFrmFlag);
+	VLOG(TRACE, "[maxNumRefFrm            ]: %d\n", info->maxNumRefFrm);
+	VLOG(TRACE, "[aspectRateInfo          ]: %d\n", info->aspectRateInfo);
+	VLOG(TRACE, "[bitRate                 ]: %d\n", info->bitRate);
+	VLOG(TRACE, "[mp2LowDelay             ]: %d\n", info->mp2LowDelay);
+	VLOG(TRACE, "[mp2DispVerSize          ]: %d\n", info->mp2DispVerSize);
+	VLOG(TRACE, "[mp2DispHorSize          ]: %d\n", info->mp2DispHorSize);
+	VLOG(TRACE, "[userDataNum             ]: %d\n", info->userDataNum);
+	VLOG(TRACE, "[userDataSize            ]: %d\n", info->userDataSize);
+	VLOG(TRACE, "[chromaFormatIDC         ]: %d\n", info->chromaFormatIDC);
+	VLOG(TRACE, "[lumaBitdepth            ]: %d\n", info->lumaBitdepth);
+	VLOG(TRACE, "[chromaBitdepth          ]: %d\n", info->chromaBitdepth);
+	VLOG(TRACE, "[seqInitErrReason        ]: 0x%08x\n",
+	     info->seqInitErrReason);
+	VLOG(TRACE, "[warnInfo                ]: %d\n", info->warnInfo);
+	VLOG(TRACE, "[rdPtr                   ]: 0x%08x\n", info->rdPtr);
+	VLOG(TRACE, "[wrPtr                   ]: 0x%08x\n", info->wrPtr);
+	VLOG(TRACE, "[sequenceNo              ]: %d\n", info->sequenceNo);
+
+	SetPendingInst(pCodecInst->coreIdx, NULL);
+
+	LeaveLock(pCodecInst->coreIdx);
+
+	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__, handle,
+	     ret);
+	return ret;
+}
+
+static RetCode DecRegisterFrameBuffer(DecHandle handle, FrameBuffer *bufArray,
+				      int numFbsForDecoding, int numFbsForWTL,
+				      int stride, int height, int mapType)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	Int32 i;
+	Uint32 size, totalAllocSize;
+	RetCode ret;
+	FrameBuffer *fb, nullFb;
+	vpu_buffer_t *vb;
+	FrameBufferFormat format = FORMAT_420;
+	Int32 totalNumOfFbs;
+
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	if (numFbsForDecoding > MAX_FRAMEBUFFER_COUNT ||
+	    numFbsForWTL > MAX_FRAMEBUFFER_COUNT) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	osal_memset(&nullFb, 0x00, sizeof(FrameBuffer));
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+	pDecInfo->numFbsForDecoding = numFbsForDecoding;
+	pDecInfo->numFbsForWTL = numFbsForWTL;
+	pDecInfo->numFrameBuffers = numFbsForDecoding + numFbsForWTL;
+	pDecInfo->stride = stride;
+	if (pCodecInst->codecMode == VPX_DEC ||
+	    pCodecInst->codecMode == W_VP8_DEC)
+		pDecInfo->frameBufferHeight = VPU_ALIGN64(height);
+	else if (pCodecInst->codecMode == W_VP9_DEC)
+		pDecInfo->frameBufferHeight = VPU_ALIGN64(height);
+	else
+		pDecInfo->frameBufferHeight = height;
+	pDecInfo->mapType = mapType;
+	pDecInfo->mapCfg.productId = pCodecInst->productId;
+
+	ret = ProductVpuDecCheckCapability(pCodecInst);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	if (!pDecInfo->initialInfoObtained)
+		return RETCODE_WRONG_CALL_SEQUENCE;
+
+	if ((stride < pDecInfo->initialInfo.picWidth) || (stride % 8 != 0) ||
+	    (height < pDecInfo->initialInfo.picHeight)) {
+		return RETCODE_INVALID_STRIDE;
+	}
+
+	EnterLock(pCodecInst->coreIdx);
+	if (GetPendingInst(pCodecInst->coreIdx)) {
+		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
+		{
+			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
+			     __func__, __LINE__);
+			msleep(50);
+			if (GetPendingInst(pCodecInst->coreIdx)) {
+				LeaveLock(pCodecInst->coreIdx);
+				return RETCODE_FRAME_NOT_COMPLETE;
+			}
+		} else {
+			LeaveLock(pCodecInst->coreIdx);
+			return RETCODE_FRAME_NOT_COMPLETE;
+		}
+	}
+
+	/* clear frameBufPool */
+	for (i = 0;
+	     i < (int)(sizeof(pDecInfo->frameBufPool) / sizeof(FrameBuffer));
+	     i++) {
+		pDecInfo->frameBufPool[i] = nullFb;
+	}
+
+	/* LinearMap or TiledMap, compressed framebuffer inclusive. */
+	if (pDecInfo->initialInfo.lumaBitdepth > 8 ||
+	    pDecInfo->initialInfo.chromaBitdepth > 8)
+		format = FORMAT_420_P10_16BIT_LSB;
+
+	totalNumOfFbs = numFbsForDecoding + numFbsForWTL;
+	VLOG(TRACE,
+	     "[%d]%s.numFbsForDecoding:%d.numFbsForWTL:%d.totalNumOfFbs:%d(%d).\n",
+	     __LINE__, __func__, pDecInfo->numFbsForDecoding,
+	     pDecInfo->numFbsForWTL, totalNumOfFbs, pDecInfo->numFrameBuffers);
+	if (bufArray) {
+		for (i = 0; i < totalNumOfFbs; i++)
+			pDecInfo->frameBufPool[i] = bufArray[i];
+	} else {
+		vb = &pDecInfo->vbFrame;
+		fb = &pDecInfo->frameBufPool[0];
+		ret = ProductVpuAllocateFramebuffer(
+			(CodecInst *)handle, fb, (TiledMapType)mapType,
+			numFbsForDecoding, stride, height, format,
+			pDecInfo->openParam.cbcrInterleave,
+			pDecInfo->openParam.nv21,
+			pDecInfo->openParam.frameEndian, vb, 0, FB_TYPE_CODEC);
+		if (ret != RETCODE_SUCCESS) {
+			LeaveLock(pCodecInst->coreIdx);
+			return ret;
+		}
+	}
+	totalAllocSize = 0;
+	if (pCodecInst->productId != PRODUCT_ID_960) {
+		pDecInfo->mapCfg.tiledBaseAddr = pDecInfo->frameBufPool[0].bufY;
+	}
+
+	if (numFbsForDecoding == 1) {
+		size = ProductCalculateFrameBufSize(
+			handle->productId, stride, height,
+			(TiledMapType)mapType, format,
+			pDecInfo->openParam.cbcrInterleave, &pDecInfo->dramCfg);
+	} else {
+		size = pDecInfo->frameBufPool[1].bufY -
+		       pDecInfo->frameBufPool[0].bufY;
+	}
+	size *= numFbsForDecoding;
+	totalAllocSize += size;
+
+	/* LinearMap */
+	if (pDecInfo->wtlEnable == TRUE || pDecInfo->enableAfbce == TRUE ||
+	    numFbsForWTL != 0) {
+		pDecInfo->stride = stride;
+		if (bufArray) {
+			format = pDecInfo->frameBufPool[0].format;
+		} else {
+			TiledMapType map;
+			map = pDecInfo->enableAfbce == TRUE ?
+				      ARM_COMPRESSED_FRAME_MAP :
+				      ((pDecInfo->wtlMode == FF_FRAME ?
+						LINEAR_FRAME_MAP :
+						LINEAR_FIELD_MAP));
+			format = pDecInfo->wtlFormat;
+			vb = &pDecInfo->vbWTL;
+			fb = &pDecInfo->frameBufPool[numFbsForDecoding];
+
+			ret = ProductVpuAllocateFramebuffer(
+				(CodecInst *)handle, fb, map, numFbsForWTL,
+				stride, height, pDecInfo->wtlFormat,
+				pDecInfo->openParam.cbcrInterleave,
+				pDecInfo->openParam.nv21,
+				pDecInfo->openParam.frameEndian, vb, 0,
+				FB_TYPE_PPU);
+
+			if (ret != RETCODE_SUCCESS) {
+				LeaveLock(pCodecInst->coreIdx);
+				return ret;
+			}
+		}
+		if (numFbsForWTL == 1) {
+			size = ProductCalculateFrameBufSize(
+				handle->productId, stride, height,
+				(TiledMapType)mapType, format,
+				pDecInfo->openParam.cbcrInterleave,
+				&pDecInfo->dramCfg);
+		} else {
+			size = pDecInfo->frameBufPool[numFbsForDecoding + 1]
+				       .bufY -
+			       pDecInfo->frameBufPool[numFbsForDecoding].bufY;
+		}
+		size *= numFbsForWTL;
+		totalAllocSize += size;
+	}
+
+	ret = ProductVpuRegisterFramebuffer(pCodecInst);
+
+	LeaveLock(pCodecInst->coreIdx);
+
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+	{
+		PhysicalAddress startAddr = 0xffffffff;
+		PhysicalAddress endAddr = 0;
+		Int32 maxSize = 0;
+
+		startAddr = 0xffffffff;
+		endAddr = 0;
+		for (i = 0; i < totalNumOfFbs; i++) {
+			startAddr =
+				(startAddr > pDecInfo->frameBufPool[i].bufY) ?
+					pDecInfo->frameBufPool[i].bufY :
+					startAddr;
+			endAddr = (endAddr < pDecInfo->frameBufPool[i].bufY) ?
+					  pDecInfo->frameBufPool[i].bufY :
+					  endAddr;
+			maxSize = (maxSize < pDecInfo->frameBufPool[i].size) ?
+					  pDecInfo->frameBufPool[i].size :
+					  maxSize;
+		}
+		endAddr += maxSize;
+		VLOG(INFO,
+		     "[%d]%s.registered frameBuf startAddr:0x%08x.endAddr:0x%08x.size:%d\n",
+		     __LINE__, __func__, startAddr, endAddr, maxSize);
+
+		if (pDecInfo->vbMV[0].phys_addr > 0) {
+			for (i = 0; i < numFbsForDecoding; i++) {
+				PhysicalAddress mvColEndAddr =
+					pDecInfo->vbMV[i].phys_addr +
+					pDecInfo->vbMV[i].size;
+				VLOG(INFO,
+				     "[%d]%s.vbMV[%d](0x%08x,0x%08x).startAddr:0x%08x.endAddr:0x%08x\n",
+				     __LINE__, __func__, i,
+				     pDecInfo->vbMV[i].phys_addr, mvColEndAddr,
+				     startAddr, endAddr);
+				startAddr = (startAddr <
+					     pDecInfo->vbMV[i].phys_addr) ?
+						    startAddr :
+						    pDecInfo->vbMV[i].phys_addr;
+				endAddr = (endAddr < mvColEndAddr) ?
+						  mvColEndAddr :
+						  endAddr;
+				VLOG(INFO,
+				     "[%d]%s.new startAddr:0x%08x.endAddr:0x%08x\n",
+				     __LINE__, __func__, startAddr, endAddr);
+			}
+		}
+
+		if (pDecInfo->secAxiInfo.bufSize) {
+			pDecInfo->writeMemProtectCfg
+				.decRegion[WPROT_DEC_SEC_AXI]
+				.enable = TRUE;
+			pDecInfo->writeMemProtectCfg
+				.decRegion[WPROT_DEC_SEC_AXI]
+				.isSecondary = TRUE;
+			pDecInfo->writeMemProtectCfg
+				.decRegion[WPROT_DEC_SEC_AXI]
+				.startAddress = pDecInfo->secAxiInfo.bufBase;
+			pDecInfo->writeMemProtectCfg
+				.decRegion[WPROT_DEC_SEC_AXI]
+				.endAddress = pDecInfo->secAxiInfo.bufBase +
+					      pDecInfo->secAxiInfo.bufSize;
+			VLOG(INFO,
+			     "[%d]%s.set decRegion[WPROT_DEC_SEC_AXI](%d,%d,0x%08x,0x%08x)\n",
+			     __LINE__, __func__,
+			     pDecInfo->writeMemProtectCfg
+				     .decRegion[WPROT_DEC_SEC_AXI]
+				     .enable,
+			     pDecInfo->writeMemProtectCfg
+				     .decRegion[WPROT_DEC_SEC_AXI]
+				     .isSecondary,
+			     pDecInfo->writeMemProtectCfg
+				     .decRegion[WPROT_DEC_SEC_AXI]
+				     .startAddress,
+			     pDecInfo->writeMemProtectCfg
+				     .decRegion[WPROT_DEC_SEC_AXI]
+				     .endAddress);
+		}
+		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME].enable =
+			TRUE;
+		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+			.isSecondary = FALSE;
+		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+			.startAddress = startAddr;
+		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+			.endAddress = endAddr;
+		VLOG(INFO,
+		     "[%d]%s.set decRegion[WPROT_DEC_FRAME](%d,%d,0x%08x,0x%08x)\n",
+		     __LINE__, __func__,
+		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+			     .enable,
+		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+			     .isSecondary,
+		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+			     .startAddress,
+		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+			     .endAddress);
+	}
+#endif
+
+	return ret;
+}
+
+RetCode VPU_DecRegisterFrameBuffer(DecHandle handle, FrameBuffer *bufArray,
+				   int num, int stride, int height, int mapType)
+{
+	DecInfo *pDecInfo = &handle->CodecInfo->decInfo;
+	Uint32 numWTL = 0;
+	RetCode ret;
+	int i;
+
+	VLOG(TRACE, "[+] [%d]%s.h:0x%x.num:%d.stride:%d.height:%d.mapType:%d\n",
+	     __LINE__, __func__, handle, num, stride, height, mapType);
+	if (num) {
+		for (i = 0; i < num; i++) {
+			VLOG(TRACE,
+			     "[%d]%s.h:0x%x.size:%d.bufY:0x%x.0x%x.0x%x.updateFbInfo:%d\n",
+			     __LINE__, __func__, handle, bufArray[i].size,
+			     bufArray[i].bufY, bufArray[i].bufCb,
+			     bufArray[i].bufCr, bufArray[i].updateFbInfo);
+		}
+	}
+	if (pDecInfo->wtlEnable == TRUE)
+		numWTL = num;
+	ret = DecRegisterFrameBuffer(handle, bufArray, num, numWTL, stride,
+				     height, mapType);
+	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__, handle,
+	     ret);
+	return ret;
+}
+
+RetCode VPU_DecRegisterFrameBufferEx(DecHandle handle, FrameBuffer *bufArray,
+				     int numOfDecFbs, int numOfDisplayFbs,
+				     int stride, int height, int mapType)
+{
+	return DecRegisterFrameBuffer(handle, bufArray, numOfDecFbs,
+				      numOfDisplayFbs, stride, height, mapType);
+}
+
+RetCode VPU_DecGetFrameBuffer(DecHandle handle, int frameIdx,
+			      FrameBuffer *frameBuf)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	RetCode ret;
+
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	if (frameBuf == 0)
+		return RETCODE_INVALID_PARAM;
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	if (frameIdx < 0 || frameIdx >= pDecInfo->numFrameBuffers)
+		return RETCODE_INVALID_PARAM;
+
+	*frameBuf = pDecInfo->frameBufPool[frameIdx];
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_DecUpdateFrameBuffer(DecHandle handle, FrameBuffer *fbcFb,
+				 FrameBuffer *linearFb, Int32 mvColIndex,
+				 Int32 picWidth, Int32 picHeight)
+{
+	if (handle == NULL) {
+		return RETCODE_INVALID_HANDLE;
+	}
+
+	return ProductVpuDecUpdateFrameBuffer((CodecInst *)handle, fbcFb,
+					      linearFb, mvColIndex, picWidth,
+					      picHeight);
+}
+
+RetCode VPU_DecSetBitstreamBuffer(DecHandle handle, PhysicalAddress rdPtr,
+				  PhysicalAddress wrPtr)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	RetCode ret;
+
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	SetClockGate(pCodecInst->coreIdx, 1);
+
+	if (GetPendingInst(pCodecInst->coreIdx) == pCodecInst)
+		VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamRdPtrRegAddr,
+			    rdPtr);
+	else
+		pDecInfo->streamRdPtr = rdPtr;
+
+	SetClockGate(pCodecInst->coreIdx, 0);
+
+	pDecInfo->streamWrPtr = wrPtr;
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_DecSetDispFlag(DecHandle handle, int dispFlag) // [r] unused
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	RetCode ret;
+	VpuAttr *pAttr;
+
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
+	if (pAttr->supportCommandQueue == FALSE) {
+		EnterDispFlagLock(pCodecInst->coreIdx);
+		pDecInfo->frameDisplayFlag = dispFlag;
+		pDecInfo->clearDisplayIndexes = 0;
+		LeaveDispFlagLock(pCodecInst->coreIdx);
+	} else {
+		EnterLock(pCodecInst->coreIdx);
+		LeaveLock(pCodecInst->coreIdx);
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_DecGetBitstreamBuffer(DecHandle handle, PhysicalAddress *prdPtr,
+				  PhysicalAddress *pwrPtr, Uint32 *size)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	PhysicalAddress rdPtr;
+	PhysicalAddress wrPtr;
+	PhysicalAddress tempPtr;
+	int room;
+	Int32 coreIdx;
+	VpuAttr *pAttr;
+
+	coreIdx = handle->coreIdx;
+	pAttr = &g_VpuCoreAttributes[coreIdx];
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	SetClockGate(coreIdx, TRUE);
+
+	if (pAttr->supportCommandQueue == TRUE) {
+#ifdef FIX_SET_GET_RD_PTR_BUG
+		EnterLock(pCodecInst->coreIdx);
+		rdPtr = ProductVpuDecGetRdPtr(pCodecInst);
+		LeaveLock(pCodecInst->coreIdx);
+#else
+		if (pDecInfo->rdPtrValidFlag ==
+		    TRUE) { // when RdPtr has been updated by calling SetRdPtr.
+			rdPtr = pDecInfo->streamRdPtr;
+		} else {
+			EnterLock(pCodecInst->coreIdx);
+			rdPtr = ProductVpuDecGetRdPtr(pCodecInst);
+			LeaveLock(pCodecInst->coreIdx);
+		}
+#endif
+	} else {
+		if (GetPendingInst(coreIdx) == pCodecInst) {
+			if (pCodecInst->codecMode == AVC_DEC &&
+			    pCodecInst->codecModeAux == AVC_AUX_MVC) {
+				rdPtr = pDecInfo->streamRdPtr;
+			} else {
+				rdPtr = VpuReadReg(
+					coreIdx, pDecInfo->streamRdPtrRegAddr);
+			}
+		} else {
+			rdPtr = pDecInfo->streamRdPtr;
+		}
+	}
+
+	SetClockGate(coreIdx, FALSE);
+
+	wrPtr = pDecInfo->streamWrPtr;
+
+	pAttr = &g_VpuCoreAttributes[coreIdx];
+
+	tempPtr = rdPtr;
+
+	if (pDecInfo->openParam.bitstreamMode != BS_MODE_PIC_END) {
+		if (wrPtr < tempPtr) {
+			room = tempPtr - wrPtr -
+			       pAttr->bitstreamBufferMargin * 2;
+		} else {
+			room = (pDecInfo->streamBufEndAddr - wrPtr) +
+			       (tempPtr - pDecInfo->streamBufStartAddr) -
+			       pAttr->bitstreamBufferMargin * 2;
+		}
+		room--;
+	} else {
+		room = (pDecInfo->streamBufEndAddr - wrPtr);
+	}
+
+	if (prdPtr)
+		*prdPtr = tempPtr;
+	if (pwrPtr)
+		*pwrPtr = wrPtr;
+	if (size)
+		*size = room;
+
+	VLOG(TRACE, "[%d]%s.h:0x%x.rdPtr:0x%x.wrPtr:0x%x.room:%d\n", __LINE__,
+	     __func__, handle, tempPtr, wrPtr, room);
+	return RETCODE_SUCCESS;
+}
+
+// RTHA-133, for PIC_END + ring buffer
+RetCode VPU_DecGetBitstreamBufferEx(DecHandle handle, PhysicalAddress *prdPtr,
+				    PhysicalAddress *pwrPtr, Uint32 *size)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	PhysicalAddress rdPtr;
+	PhysicalAddress wrPtr;
+	PhysicalAddress tempPtr;
+	int room;
+	Int32 coreIdx;
+	VpuAttr *pAttr;
+
+	coreIdx = handle->coreIdx;
+	pAttr = &g_VpuCoreAttributes[coreIdx];
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	SetClockGate(coreIdx, TRUE);
+
+	if (pAttr->supportCommandQueue == TRUE) {
+#ifdef FIX_SET_GET_RD_PTR_BUG
+		EnterLock(pCodecInst->coreIdx);
+		rdPtr = ProductVpuDecGetRdPtr(pCodecInst);
+		LeaveLock(pCodecInst->coreIdx);
+#else
+		if (pDecInfo->rdPtrValidFlag ==
+		    TRUE) { // when RdPtr has been updated by calling SetRdPtr.
+			rdPtr = pDecInfo->streamRdPtr;
+		} else {
+			EnterLock(pCodecInst->coreIdx);
+			rdPtr = ProductVpuDecGetRdPtr(pCodecInst);
+			LeaveLock(pCodecInst->coreIdx);
+		}
+#endif
+	} else {
+		if (GetPendingInst(coreIdx) == pCodecInst) {
+			if (pCodecInst->codecMode == AVC_DEC &&
+			    pCodecInst->codecModeAux == AVC_AUX_MVC) {
+				rdPtr = pDecInfo->streamRdPtr;
+			} else {
+				rdPtr = VpuReadReg(
+					coreIdx, pDecInfo->streamRdPtrRegAddr);
+			}
+		} else {
+			rdPtr = pDecInfo->streamRdPtr;
+		}
+	}
+
+	SetClockGate(coreIdx, FALSE);
+
+	wrPtr = pDecInfo->streamWrPtr;
+
+	pAttr = &g_VpuCoreAttributes[coreIdx];
+
+	tempPtr = rdPtr;
+
+	if (wrPtr < tempPtr) {
+		room = tempPtr - wrPtr - pAttr->bitstreamBufferMargin * 2;
+	} else {
+		room = (pDecInfo->streamBufEndAddr - wrPtr) +
+		       (tempPtr - pDecInfo->streamBufStartAddr) -
+		       pAttr->bitstreamBufferMargin * 2;
+	}
+	room--;
+
+	if (prdPtr)
+		*prdPtr = tempPtr;
+	if (pwrPtr)
+		*pwrPtr = wrPtr;
+	if (size)
+		*size = room;
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_DecUpdateBitstreamBuffer(DecHandle handle, int size)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	PhysicalAddress wrPtr;
+	PhysicalAddress rdPtr;
+	RetCode ret;
+	BOOL running;
+	VpuAttr *pAttr;
+
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS) {
+		VLOG(ERR, "[-] [%d]%s.h:0x%x.size:%d.ret:%d\n", __LINE__,
+		     __func__, handle, size, ret);
+		return ret;
+	}
+
+	pCodecInst = handle;
+	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+	wrPtr = pDecInfo->streamWrPtr;
+
+	SetClockGate(pCodecInst->coreIdx, 1);
+
+	if (pAttr->supportCommandQueue == TRUE) {
+		running = FALSE;
+	} else {
+		running = (BOOL)(GetPendingInst(pCodecInst->coreIdx) ==
+				 pCodecInst);
+	}
+
+	if (size > 0) {
+		Uint32 room = 0;
+
+		if (running == TRUE)
+			rdPtr = VpuReadReg(pCodecInst->coreIdx,
+					   pDecInfo->streamRdPtrRegAddr);
+		else
+			rdPtr = pDecInfo->streamRdPtr;
+
+		if (wrPtr < rdPtr) {
+			if (rdPtr <= wrPtr + size) {
+				SetClockGate(pCodecInst->coreIdx, 0);
+				VLOG(ERR,
+				     "[-] [%d]%s.h:0x%x.size:%d.ret:RETCODE_INVALID_PARAM\n",
+				     __LINE__, __func__, handle, size);
+				return RETCODE_INVALID_PARAM;
+			}
+		}
+
+		wrPtr += size;
+
+		// Discuss with FuChun, vpuapi can't know BS buffer is ring buffer or line buffer.
+		// Gregory use "bitstreamMode != BS_MODE_PIC_END" to determine BS buffer is ring buffer is not correct due to we have PIC_END + ring buffer case.
+		// If line buffer, wrPts won't be bigger than pDecInfo->streamBufEndAddr, so mark this condition is also ok for line buffer.
+		if (wrPtr > pDecInfo->streamBufEndAddr) {
+			room = wrPtr - pDecInfo->streamBufEndAddr;
+			wrPtr = pDecInfo->streamBufStartAddr;
+			wrPtr += room;
+		} else if (wrPtr == pDecInfo->streamBufEndAddr) {
+			wrPtr = pDecInfo->streamBufStartAddr;
+		}
+
+		pDecInfo->streamWrPtr = wrPtr;
+		pDecInfo->streamRdPtr = rdPtr;
+
+		if (running == TRUE) {
+			VpuWriteReg(pCodecInst->coreIdx,
+				    pDecInfo->streamWrPtrRegAddr, wrPtr);
+		}
+	}
+
+	ret = ProductVpuDecSetBitstreamFlag(pCodecInst, running, size);
+
+	SetClockGate(pCodecInst->coreIdx, 0);
+	VLOG(TRACE, "[%d]%s.h:0x%x.size:%d.ret:%d\n", __LINE__, __func__,
+	     handle, size, ret);
+	return ret;
+}
+
+RetCode VPU_HWReset(Uint32 coreIdx)
+{
+	if (vdi_hw_reset(coreIdx) < 0)
+		return RETCODE_FAILURE;
+
+	if (GetPendingInst(coreIdx)) {
+		SetPendingInst(coreIdx, 0);
+		LeaveLock(
+			coreIdx); //if vpu is in a lock state. release the state;
+	}
+	return RETCODE_SUCCESS;
+}
+
+/**
+* VPU_SWReset
+* IN
+*    forcedReset : 1 if there is no need to waiting for BUS transaction,
+*                  0 for otherwise
+* OUT
+*    RetCode : RETCODE_FAILURE if failed to reset,
+*              RETCODE_SUCCESS for otherwise
+*/
+RetCode VPU_SWReset(Uint32 coreIdx, SWResetMode resetMode, void *pendingInst)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	CodecInst *pCodecInst = (CodecInst *)pendingInst;
+
+	VLOG(TRACE, "[+] [%d]%s.coreIdx:%d.resetMode:%d.pendingInst:%p\n",
+	     __LINE__, __func__, coreIdx, resetMode, pendingInst);
+	SetClockGate(coreIdx, 1);
+	ret = ProductVpuReset(coreIdx, resetMode);
+
+	if (ret != RETCODE_SUCCESS) //RTK
+	{
+		ret = VPU_HWReset(coreIdx);
+	} else {
+		if (pCodecInst) {
+			SetPendingInst(pCodecInst->coreIdx, 0);
+			LeaveLock(coreIdx);
+			SetClockGate(coreIdx, 1);
+			if (pCodecInst->loggingEnable) {
+				vdi_log(pCodecInst->coreIdx,
+					(pCodecInst->productId ==
+						 PRODUCT_ID_960 ||
+					 pCodecInst->productId ==
+						 PRODUCT_ID_980) ?
+						0x10 :
+						0x10000,
+					1);
+			}
+		}
+
+		if (pCodecInst) {
+			if (pCodecInst->loggingEnable) {
+				vdi_log(pCodecInst->coreIdx,
+					(pCodecInst->productId ==
+						 PRODUCT_ID_960 ||
+					 pCodecInst->productId ==
+						 PRODUCT_ID_980) ?
+						0x10 :
+						0x10000,
+					0);
+			}
+		}
+	}
+
+	SetClockGate(coreIdx, 0);
+
+	VLOG(TRACE, "[-] [%d]%s.coreIdx:%d.ret:%d\n", __LINE__, __func__,
+	     coreIdx, ret);
+	return ret;
+}
+
+//---- VPU_SLEEP/WAKE
+RetCode VPU_SleepWake(Uint32 coreIdx, int iSleepWake)
+{
+	SetClockGate(coreIdx, TRUE);
+	SetClockGate(coreIdx, FALSE);
+
+	return 0;
+}
+
+RetCode VPU_DecStartOneFrame(DecHandle handle, DecParam *param)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	Uint32 val = 0;
+	RetCode ret = RETCODE_SUCCESS;
+	VpuAttr *pAttr = NULL;
+
+	VLOG(TRACE, "[+] [%d]%s.h:0x%x.DecParam(%d,%d,%d)\n", __LINE__,
+	     __func__, handle, param->iframeSearchEnable, param->skipframeMode,
+	     param->craAsBlaFlag);
+
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS) {
+		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
+		     handle, ret);
+		return ret;
+	}
+
+	pCodecInst = (CodecInst *)handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	if (pDecInfo->stride ==
+	    0) { // This means frame buffers have not been registered.
+		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:RETCODE_WRONG_CALL_SEQUENCE\n",
+		     __LINE__, __func__, handle);
+		return RETCODE_WRONG_CALL_SEQUENCE;
+	}
+
+	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
+
+	EnterLock(pCodecInst->coreIdx);
+	if (GetPendingInst(pCodecInst->coreIdx)) {
+		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
+		{
+			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
+			     __func__, __LINE__);
+			msleep(50);
+			if (GetPendingInst(pCodecInst->coreIdx)) {
+				LeaveLock(pCodecInst->coreIdx);
+				VLOG(ERR,
+				     "[-] [%d]%s.h:0x%x.ret:RETCODE_FRAME_NOT_COMPLETE\n",
+				     __LINE__, __func__, handle);
+				return RETCODE_FRAME_NOT_COMPLETE;
+			}
+		} else {
+			LeaveLock(pCodecInst->coreIdx);
+			VLOG(ERR,
+			     "[-] [%d]%s.h:0x%x.ret:RETCODE_FRAME_NOT_COMPLETE\n",
+			     __LINE__, __func__, handle);
+			return RETCODE_FRAME_NOT_COMPLETE;
+		}
+	}
+
+	if (pAttr->supportCommandQueue == FALSE) {
+		EnterDispFlagLock(pCodecInst->coreIdx);
+		val = pDecInfo->frameDisplayFlag;
+		val |= pDecInfo->setDisplayIndexes;
+		val &= ~(Uint32)(pDecInfo->clearDisplayIndexes);
+		VpuWriteReg(pCodecInst->coreIdx,
+			    pDecInfo->frameDisplayFlagRegAddr, val);
+		pDecInfo->clearDisplayIndexes = 0;
+		pDecInfo->setDisplayIndexes = 0;
+		LeaveDispFlagLock(pCodecInst->coreIdx);
+	}
+
+	pDecInfo->frameStartPos = pDecInfo->streamRdPtr;
+
+	ret = ProductVpuDecode(pCodecInst, param);
+
+	if (pAttr->supportCommandQueue == TRUE) {
+		SetPendingInst(pCodecInst->coreIdx, NULL);
+		LeaveLock(pCodecInst->coreIdx);
+	} else {
+		SetPendingInst(pCodecInst->coreIdx, pCodecInst);
+	}
+
+	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__, handle,
+	     ret);
+	return ret;
+}
+
+RetCode VPU_DecGetOutputInfo(DecHandle handle, DecOutputInfo *info)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	RetCode ret;
+	VpuRect rectInfo;
+	Uint32 val;
+	Int32 decodedIndex;
+	Int32 displayIndex;
+	Uint32 maxDecIndex;
+	VpuAttr *pAttr;
+#ifdef VE1_CHECKSUM_LOG_TO_TMP
+	char hash[128];
+	FILE *hash_out_file;
+#endif
+
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS) {
+		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
+		     handle, ret);
+		return ret;
+	}
+
+	if (info == 0) {
+		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:RETCODE_INVALID_PARAM\n",
+		     __LINE__, __func__, handle);
+		return RETCODE_INVALID_PARAM;
+	}
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
+
+	if (pAttr->supportCommandQueue == TRUE) {
+		EnterLock(pCodecInst->coreIdx);
+	} else {
+		if (pCodecInst != GetPendingInst(pCodecInst->coreIdx)) {
+			SetPendingInst(pCodecInst->coreIdx, 0);
+			LeaveLock(pCodecInst->coreIdx);
+			VLOG(ERR,
+			     "[-] [%d]%s.h:0x%x.ret:RETCODE_WRONG_CALL_SEQUENCE\n",
+			     __LINE__, __func__, handle);
+			return RETCODE_WRONG_CALL_SEQUENCE;
+		}
+	}
+
+	osal_memset((void *)info, 0x00, sizeof(DecOutputInfo));
+
+	ret = ProductVpuDecGetResult(pCodecInst, info);
+	if (ret != RETCODE_SUCCESS) {
+		info->rdPtr = pDecInfo->streamRdPtr;
+		info->wrPtr = pDecInfo->streamWrPtr;
+		SetPendingInst(pCodecInst->coreIdx, 0);
+		LeaveLock(pCodecInst->coreIdx);
+		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
+		     handle, ret);
+		return ret;
+	}
+
+	decodedIndex = info->indexFrameDecoded;
+
+	if (pDecInfo->openParam.afbceEnable) {
+		maxDecIndex =
+			(pDecInfo->numFbsForDecoding > pDecInfo->numFbsForWTL) ?
+				pDecInfo->numFbsForDecoding :
+				pDecInfo->numFbsForWTL;
+		if (0 <= decodedIndex && decodedIndex < (int)maxDecIndex) {
+			val = pDecInfo->numFbsForDecoding; //fbOffset
+			pDecInfo->frameBufPool[val + decodedIndex].lfEnable =
+				info->lfEnable;
+		}
+	}
+
+	// Calculate display frame region
+	val = 0;
+	if (decodedIndex >= 0 && decodedIndex < MAX_GDI_IDX) {
+		//default value
+		rectInfo.left = 0;
+		rectInfo.right = info->decPicWidth;
+		rectInfo.top = 0;
+		rectInfo.bottom = info->decPicHeight;
+
+		if (pCodecInst->codecMode == HEVC_DEC ||
+		    pCodecInst->codecMode == AVC_DEC ||
+		    pCodecInst->codecMode == W_AVC_DEC ||
+		    pCodecInst->codecMode == AVS_DEC)
+			rectInfo = pDecInfo->initialInfo.picCropRect;
+
+		info->rcDecoded.left =
+			pDecInfo->decOutInfo[decodedIndex].rcDecoded.left =
+				rectInfo.left;
+		info->rcDecoded.right =
+			pDecInfo->decOutInfo[decodedIndex].rcDecoded.right =
+				rectInfo.right;
+		info->rcDecoded.top =
+			pDecInfo->decOutInfo[decodedIndex].rcDecoded.top =
+				rectInfo.top;
+		info->rcDecoded.bottom =
+			pDecInfo->decOutInfo[decodedIndex].rcDecoded.bottom =
+				rectInfo.bottom;
+	} else {
+		info->rcDecoded.left = 0;
+		info->rcDecoded.right = info->decPicWidth;
+		info->rcDecoded.top = 0;
+		info->rcDecoded.bottom = info->decPicHeight;
+	}
+
+	displayIndex = info->indexFrameDisplay;
+	if (info->indexFrameDisplay >= 0 &&
+	    info->indexFrameDisplay < MAX_GDI_IDX) {
+		if (pCodecInst->codecMode == VC1_DEC ||
+		    pCodecInst->codecMode ==
+			    W_VC1_DEC) // vc1 rotates decoded frame buffer region. the other std rotated whole frame buffer region.
+		{
+			if (pDecInfo->rotationEnable &&
+			    (pDecInfo->rotationAngle == 90 ||
+			     pDecInfo->rotationAngle == 270)) {
+				info->rcDisplay.left =
+					pDecInfo->decOutInfo[displayIndex]
+						.rcDecoded.top;
+				info->rcDisplay.right =
+					pDecInfo->decOutInfo[displayIndex]
+						.rcDecoded.bottom;
+				info->rcDisplay.top =
+					pDecInfo->decOutInfo[displayIndex]
+						.rcDecoded.left;
+				info->rcDisplay.bottom =
+					pDecInfo->decOutInfo[displayIndex]
+						.rcDecoded.right;
+			} else {
+				info->rcDisplay.left =
+					pDecInfo->decOutInfo[displayIndex]
+						.rcDecoded.left;
+				info->rcDisplay.right =
+					pDecInfo->decOutInfo[displayIndex]
+						.rcDecoded.right;
+				info->rcDisplay.top =
+					pDecInfo->decOutInfo[displayIndex]
+						.rcDecoded.top;
+				info->rcDisplay.bottom =
+					pDecInfo->decOutInfo[displayIndex]
+						.rcDecoded.bottom;
+			}
+		} else {
+			if (pDecInfo->rotationEnable) {
+				switch (pDecInfo->rotationAngle) {
+				case 90:
+					info->rcDisplay.left =
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.top;
+					info->rcDisplay.right =
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.bottom;
+					info->rcDisplay.top =
+						info->decPicWidth -
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.right;
+					info->rcDisplay.bottom =
+						info->decPicWidth -
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.left;
+					break;
+				case 270:
+					info->rcDisplay.left =
+						info->decPicHeight -
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.bottom;
+					info->rcDisplay.right =
+						info->decPicHeight -
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.top;
+					info->rcDisplay.top =
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.left;
+					info->rcDisplay.bottom =
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.right;
+					break;
+				case 180:
+					info->rcDisplay.left =
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.left;
+					info->rcDisplay.right =
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.right;
+					info->rcDisplay.top =
+						info->decPicHeight -
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.bottom;
+					info->rcDisplay.bottom =
+						info->decPicHeight -
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.top;
+					break;
+				default:
+					info->rcDisplay.left =
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.left;
+					info->rcDisplay.right =
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.right;
+					info->rcDisplay.top =
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.top;
+					info->rcDisplay.bottom =
+						pDecInfo->decOutInfo[displayIndex]
+							.rcDecoded.bottom;
+					break;
+				}
+
+			} else {
+				info->rcDisplay.left =
+					pDecInfo->decOutInfo[displayIndex]
+						.rcDecoded.left;
+				info->rcDisplay.right =
+					pDecInfo->decOutInfo[displayIndex]
+						.rcDecoded.right;
+				info->rcDisplay.top =
+					pDecInfo->decOutInfo[displayIndex]
+						.rcDecoded.top;
+				info->rcDisplay.bottom =
+					pDecInfo->decOutInfo[displayIndex]
+						.rcDecoded.bottom;
+			}
+
+			if (pDecInfo->mirrorEnable) {
+				Uint32 temp;
+				if (pDecInfo->mirrorDirection & MIRDIR_VER) {
+					temp = info->rcDisplay.top;
+					info->rcDisplay.top =
+						info->decPicHeight -
+						info->rcDisplay.bottom;
+					info->rcDisplay.bottom =
+						info->decPicHeight - temp;
+				}
+				if (pDecInfo->mirrorDirection & MIRDIR_HOR) {
+					temp = info->rcDisplay.left;
+					info->rcDisplay.left =
+						info->decPicWidth -
+						info->rcDisplay.right;
+					info->rcDisplay.right =
+						info->decPicWidth - temp;
+				}
+			}
+
+			switch (pCodecInst->codecMode) {
+			default:
+				break;
+			}
+		}
+
+		if (info->indexFrameDisplay == info->indexFrameDecoded) {
+			info->dispPicWidth = info->decPicWidth;
+			info->dispPicHeight = info->decPicHeight;
+		} else {
+			info->dispPicWidth =
+				pDecInfo->decOutInfo[displayIndex].decPicWidth;
+			info->dispPicHeight =
+				pDecInfo->decOutInfo[displayIndex].decPicHeight;
+		}
+
+		if (pDecInfo->scalerEnable == TRUE) {
+			if ((pDecInfo->scaleWidth != 0) &&
+			    (pDecInfo->scaleHeight != 0)) {
+				info->dispPicWidth = pDecInfo->scaleWidth;
+				info->dispPicHeight = pDecInfo->scaleHeight;
+				info->rcDisplay.right = pDecInfo->scaleWidth;
+				info->rcDisplay.bottom = pDecInfo->scaleHeight;
+			}
+		}
+	} else {
+		info->rcDisplay.left = 0;
+		info->rcDisplay.right = 0;
+		info->rcDisplay.top = 0;
+		info->rcDisplay.bottom = 0;
+
+		if (pDecInfo->rotationEnable || pDecInfo->mirrorEnable ||
+		    pDecInfo->tiled2LinearEnable || pDecInfo->deringEnable) {
+			info->dispPicWidth = info->decPicWidth;
+			info->dispPicHeight = info->decPicHeight;
+		} else {
+			info->dispPicWidth = 0;
+			info->dispPicHeight = 0;
+		}
+	}
+
+	if ((pCodecInst->codecMode == VC1_DEC ||
+	     pCodecInst->codecMode == W_VC1_DEC) &&
+	    info->indexFrameDisplay != -3) {
+		if (pDecInfo->vc1BframeDisplayValid == 0) {
+			if (info->picType == 2)
+				info->indexFrameDisplay = -3;
+			else
+				pDecInfo->vc1BframeDisplayValid = 1;
+		}
+	}
+
+	pDecInfo->streamRdPtr = ProductVpuDecGetRdPtr(pCodecInst);
+	pDecInfo->frameDisplayFlag = VpuReadReg(
+		pCodecInst->coreIdx, pDecInfo->frameDisplayFlagRegAddr);
+	if (pCodecInst->codecMode == W_VP9_DEC) {
+		pDecInfo->frameDisplayFlag &= 0xFFFF;
+	}
+	pDecInfo->frameEndPos = pDecInfo->streamRdPtr;
+
+	if (pDecInfo->frameEndPos < pDecInfo->frameStartPos)
+		info->consumedByte = pDecInfo->frameEndPos +
+				     pDecInfo->streamBufSize -
+				     pDecInfo->frameStartPos;
+	else
+		info->consumedByte =
+			pDecInfo->frameEndPos - pDecInfo->frameStartPos;
+
+	if (pDecInfo->deringEnable || pDecInfo->mirrorEnable ||
+	    pDecInfo->rotationEnable || pDecInfo->tiled2LinearEnable) {
+		info->dispFrame = pDecInfo->rotatorOutput;
+		info->dispFrame.stride = pDecInfo->rotatorStride;
+	} else {
+		val = ((pDecInfo->openParam.wtlEnable == TRUE ||
+			pDecInfo->openParam.afbceEnable) ?
+			       pDecInfo->numFbsForDecoding :
+			       0); //fbOffset
+		maxDecIndex =
+			(pDecInfo->numFbsForDecoding > pDecInfo->numFbsForWTL) ?
+				pDecInfo->numFbsForDecoding :
+				pDecInfo->numFbsForWTL;
+
+		if (0 <= info->indexFrameDisplay &&
+		    info->indexFrameDisplay < (int)maxDecIndex)
+			info->dispFrame =
+				pDecInfo->frameBufPool[val +
+						       info->indexFrameDisplay];
+	}
+
+	info->rdPtr = pDecInfo->streamRdPtr;
+	info->wrPtr = pDecInfo->streamWrPtr;
+	info->frameDisplayFlag = pDecInfo->frameDisplayFlag;
+
+	info->sequenceNo = pDecInfo->initialInfo.sequenceNo;
+	if (decodedIndex >= 0 && decodedIndex < MAX_GDI_IDX) {
+		pDecInfo->decOutInfo[decodedIndex] = *info;
+	}
+
+	if (displayIndex >= 0 && displayIndex < MAX_GDI_IDX) {
+		info->numOfTotMBs = info->numOfTotMBs;
+		info->numOfErrMBs = info->numOfErrMBs;
+		info->numOfTotMBsInDisplay =
+			pDecInfo->decOutInfo[displayIndex].numOfTotMBs;
+		info->numOfErrMBsInDisplay =
+			pDecInfo->decOutInfo[displayIndex].numOfErrMBs;
+		info->dispFrame.sequenceNo = info->sequenceNo;
+	} else {
+		info->numOfTotMBsInDisplay = 0;
+		info->numOfErrMBsInDisplay = 0;
+	}
+
+	if (info->sequenceChanged != 0) {
+		if (!(pCodecInst->productId == PRODUCT_ID_960 ||
+		      pCodecInst->productId == PRODUCT_ID_980)) {
+			/* Update new sequence information */
+			osal_memcpy((void *)&pDecInfo->initialInfo,
+				    (void *)&pDecInfo->newSeqInfo,
+				    sizeof(DecInitialInfo));
+		}
+		if ((info->sequenceChanged & SEQ_CHANGE_INTER_RES_CHANGE) !=
+		    SEQ_CHANGE_INTER_RES_CHANGE) {
+			pDecInfo->initialInfo.sequenceNo++;
+		}
+	}
+
+	SetPendingInst(pCodecInst->coreIdx, 0);
+#ifdef VE1_CHECKSUM
+	if (info->indexFrameDisplay >= 0) {
+		FrameBuffer fbTmp =
+			pDecInfo->frameBufPool[info->indexFrameDisplay];
+		int fbSize =
+			VPU_GetFrameBufSize(pCodecInst->coreIdx, fbTmp.stride,
+					    fbTmp.height, fbTmp.mapType,
+					    fbTmp.format, fbTmp.cbcrInterleave,
+					    &pDecInfo->dramCfg);
+		MCP_SHA256_Hash(info->dispFrame.bufY, fbSize,
+				pDecInfo->hashTable.phys_addr);
+		Uint8 *result = (Uint8 *)pDecInfo->hashTable.virt_addr;
+		VLOG(TRACE,
+		     "addr 0x%x size %zu Cur Hash= %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x",
+		     info->dispFrame.bufY, fbSize, result[0], result[1],
+		     result[2], result[3], result[4], result[5], result[6],
+		     result[7], result[8], result[9], result[10], result[11],
+		     result[12], result[13], result[14], result[15], result[16],
+		     result[17], result[18], result[19], result[20], result[21],
+		     result[22], result[23], result[24], result[25], result[26],
+		     result[27], result[28], result[29], result[30],
+		     result[31]);
+#ifdef VE1_CHECKSUM_LOG_TO_TMP
+		memset(hash, 0, sizeof(hash));
+		sprintf(hash,
+			"%.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x "
+			"%.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x "
+			"%.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x "
+			"%.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x\n",
+			result[0], result[1], result[2], result[3], result[4],
+			result[5], result[6], result[7], result[8], result[9],
+			result[10], result[11], result[12], result[13],
+			result[14], result[15], result[16], result[17],
+			result[18], result[19], result[20], result[21],
+			result[22], result[23], result[24], result[25],
+			result[26], result[27], result[28], result[29],
+			result[30], result[31]);
+		VLOG(TRACE, "%s", hash);
+		//open
+		hash_out_file = fopen("/tmp/hash.log", "a+");
+		if (hash_out_file) {
+			//write
+			fputs(hash, hash_out_file);
+			//close
+			fclose(hash_out_file);
+		} else {
+			VLOG(TRACE, "open /tmp/hash.log failed");
+		}
+#endif
+	}
+#endif
+
+	LeaveLock(pCodecInst->coreIdx);
+
+	if (pCodecInst->coreIdx == 0) {
+		pDecInfo->outputinfoSN++;
+		if ((pDecInfo->openParam.bitstreamMode == BS_MODE_ROLLBACK) &&
+		    !(info->decodingSuccess & 0x10) &&
+		    (info->indexFrameDecoded >= 0 ||
+		     info->indexFrameDecoded == -2)) {
+			pDecInfo->decodedFrmNum++;
+		} else if (info->indexFrameDecoded >= 0 ||
+			   info->indexFrameDecoded == -2) {
+			pDecInfo->decodedFrmNum++;
+		}
+	}
+	VLOG(TRACE,
+	     "[%d]%s.h:0x%x.%d.%d.dec:%d.dis:%d.POC:%d(%d,%d).type:%d(%d).pos(0x%x 0x%x 0x%x).size:%d.suc:0x%x.err:%d.frmDisFlg:0x%x.warn:%d.nalRefIdc:%d.decFrameInfo:%d.sc:0x%x.sef:%d\n",
+	     __LINE__, __func__, handle, pDecInfo->outputinfoSN,
+	     pDecInfo->decodedFrmNum, info->indexFrameDecoded,
+	     info->indexFrameDisplay, info->avcPocPic, info->avcPocTop,
+	     info->avcPocBot, info->picType, info->picTypeFirst,
+	     info->bytePosFrameStart, info->bytePosFrameEnd, info->rdPtr,
+	     vpu_ring_valid_data(
+		     pDecInfo->streamBufStartAddr,
+		     pDecInfo->streamBufStartAddr + pDecInfo->streamBufSize,
+		     info->bytePosFrameStart, info->bytePosFrameEnd),
+	     info->decodingSuccess, info->numOfErrMBs, info->frameDisplayFlag,
+	     info->warnInfo, info->nalRefIdc, info->decFrameInfo,
+	     info->sequenceChanged, info->streamEndFlag);
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_DecFrameBufferFlush(DecHandle handle, DecOutputInfo *pRemainings,
+				Uint32 *retNum)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	DecOutputInfo *pOut;
+	RetCode ret;
+	FramebufferIndex retIndex[MAX_GDI_IDX];
+	Uint32 retRemainings = 0;
+	Int32 i, index, val;
+	VpuAttr *pAttr = NULL;
+
+	VLOG(TRACE, "[+] [%d]%s.h:0x%x\n", __LINE__, __func__, handle);
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS) {
+		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
+		     handle, ret);
+		return ret;
+	}
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	if (GetPendingInst(pCodecInst->coreIdx)) {
+		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
+		{
+			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
+			     __func__, __LINE__);
+			msleep(50);
+			if (GetPendingInst(pCodecInst->coreIdx)) {
+				LeaveLock(pCodecInst->coreIdx);
+				VLOG(ERR,
+				     "[-] [%d]%s.h:0x%x.ret:RETCODE_FRAME_NOT_COMPLETE\n",
+				     __LINE__, __func__, handle);
+				return RETCODE_FRAME_NOT_COMPLETE;
+			}
+		} else {
+			LeaveLock(pCodecInst->coreIdx);
+			VLOG(ERR,
+			     "[-] [%d]%s.h:0x%x.ret:RETCODE_FRAME_NOT_COMPLETE\n",
+			     __LINE__, __func__, handle);
+			return RETCODE_FRAME_NOT_COMPLETE;
+		}
+	}
+
+	osal_memset((void *)retIndex, 0xff, sizeof(retIndex));
+
+	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
+	if (pAttr->supportCommandQueue == FALSE) {
+		EnterDispFlagLock(pCodecInst->coreIdx);
+		val = pDecInfo->frameDisplayFlag;
+		val |= pDecInfo->setDisplayIndexes;
+		val &= ~(Uint32)(pDecInfo->clearDisplayIndexes);
+		VpuWriteReg(pCodecInst->coreIdx,
+			    pDecInfo->frameDisplayFlagRegAddr, val);
+		pDecInfo->clearDisplayIndexes = 0;
+		pDecInfo->setDisplayIndexes = 0;
+		LeaveDispFlagLock(pCodecInst->coreIdx);
+	}
+
+	if ((ret = ProductVpuDecFlush(pCodecInst, retIndex, MAX_GDI_IDX)) !=
+	    RETCODE_SUCCESS) {
+		LeaveLock(pCodecInst->coreIdx);
+		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
+		     handle, ret);
+		return ret;
+	}
+
+	if (pRemainings != NULL) {
+		for (i = 0; i < MAX_GDI_IDX; i++) {
+			index = (pDecInfo->wtlEnable == TRUE) ?
+					retIndex[i].tiledIndex :
+					retIndex[i].linearIndex;
+			if (index < 0)
+				continue;
+			pRemainings[i] = pDecInfo->decOutInfo[index];
+			pOut = &pRemainings[i];
+			pOut->indexFrameDisplay = pOut->indexFrameDecoded;
+			pOut->indexFrameDisplayForTiled =
+				pOut->indexFrameDecodedForTiled;
+			if (pDecInfo->wtlEnable == TRUE)
+				pOut->dispFrame =
+					pDecInfo->frameBufPool
+						[pDecInfo->numFbsForDecoding +
+						 retIndex[i].linearIndex];
+			else
+				pOut->dispFrame = pDecInfo->frameBufPool[index];
+
+			pOut->dispFrame.sequenceNo = pOut->sequenceNo;
+			pOut->dispPicWidth = pOut->decPicWidth;
+			pOut->dispPicHeight = pOut->decPicHeight;
+
+			if (pDecInfo->rotationEnable) {
+				switch (pDecInfo->rotationAngle) {
+				case 90:
+					pOut->rcDisplay.left =
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.top;
+					pOut->rcDisplay.right =
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.bottom;
+					pOut->rcDisplay.top =
+						pOut->decPicWidth -
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.right;
+					pOut->rcDisplay.bottom =
+						pOut->decPicWidth -
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.left;
+					break;
+				case 270:
+					pOut->rcDisplay.left =
+						pOut->decPicHeight -
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.bottom;
+					pOut->rcDisplay.right =
+						pOut->decPicHeight -
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.top;
+					pOut->rcDisplay.top =
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.left;
+					pOut->rcDisplay.bottom =
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.right;
+					break;
+				case 180:
+					pOut->rcDisplay.left =
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.left;
+					pOut->rcDisplay.right =
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.right;
+					pOut->rcDisplay.top =
+						pOut->decPicHeight -
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.bottom;
+					pOut->rcDisplay.bottom =
+						pOut->decPicHeight -
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.top;
+					break;
+				default:
+					pOut->rcDisplay.left =
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.left;
+					pOut->rcDisplay.right =
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.right;
+					pOut->rcDisplay.top =
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.top;
+					pOut->rcDisplay.bottom =
+						pDecInfo->decOutInfo[index]
+							.rcDecoded.bottom;
+					break;
+				}
+			} else {
+				pOut->rcDisplay.left =
+					pDecInfo->decOutInfo[index]
+						.rcDecoded.left;
+				pOut->rcDisplay.right =
+					pDecInfo->decOutInfo[index]
+						.rcDecoded.right;
+				pOut->rcDisplay.top =
+					pDecInfo->decOutInfo[index]
+						.rcDecoded.top;
+				pOut->rcDisplay.bottom =
+					pDecInfo->decOutInfo[index]
+						.rcDecoded.bottom;
+			}
+			retRemainings++;
+		}
+	}
+
+	if (retNum)
+		*retNum = retRemainings;
+
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, DEC_BUF_FLUSH, 0);
+
+	LeaveLock(pCodecInst->coreIdx);
+
+	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__, handle,
+	     ret);
+	return ret;
+}
+
+RetCode VPU_DecSetRdPtr(DecHandle handle, PhysicalAddress addr, int updateWrPtr)
+{
+	CodecInst *pCodecInst;
+	CodecInst *pPendingInst;
+	DecInfo *pDecInfo;
+	RetCode ret;
+
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS) {
+		return ret;
+	}
+	pCodecInst = (CodecInst *)handle;
+	ret = ProductVpuDecCheckCapability(pCodecInst);
+	if (ret != RETCODE_SUCCESS) {
+		return ret;
+	}
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+	pPendingInst = GetPendingInst(pCodecInst->coreIdx);
+	if (pCodecInst == pPendingInst) {
+		VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamRdPtrRegAddr,
+			    addr);
+	} else {
+		EnterLock(pCodecInst->coreIdx);
+		VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamRdPtrRegAddr,
+			    addr);
+		LeaveLock(pCodecInst->coreIdx);
+	}
+
+	pDecInfo->streamRdPtr = addr;
+	pDecInfo->prevFrameEndPos = addr;
+	if (updateWrPtr == TRUE) {
+		pDecInfo->streamWrPtr = addr;
+	}
+	pDecInfo->rdPtrValidFlag = 1;
+	VLOG(TRACE, "[%d]%s.h:0x%x.addr:0x%x.updateWrPtr:%d\n", __LINE__,
+	     __func__, handle, addr, updateWrPtr);
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_EncSetWrPtr(EncHandle handle, PhysicalAddress addr, int updateRdPtr)
+{
+	CodecInst *pCodecInst;
+	CodecInst *pPendingInst;
+	EncInfo *pEncInfo;
+	RetCode ret;
+
+	ret = CheckEncInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+	pCodecInst = (CodecInst *)handle;
+
+	if (pCodecInst->productId == PRODUCT_ID_960 ||
+	    pCodecInst->productId == PRODUCT_ID_980) {
+		return RETCODE_NOT_SUPPORTED_FEATURE;
+	}
+
+	pEncInfo = &handle->CodecInfo->encInfo;
+	pPendingInst = GetPendingInst(pCodecInst->coreIdx);
+	if (pCodecInst == pPendingInst) {
+		VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamWrPtrRegAddr,
+			    addr);
+	} else {
+		EnterLock(pCodecInst->coreIdx);
+		VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamWrPtrRegAddr,
+			    addr);
+		LeaveLock(pCodecInst->coreIdx);
+	}
+	pEncInfo->streamWrPtr = addr;
+	if (updateRdPtr)
+		pEncInfo->streamRdPtr = addr;
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_DecClrDispFlag(DecHandle handle, int index)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	RetCode ret = RETCODE_SUCCESS;
+	Int32 endIndex;
+	VpuAttr *pAttr = NULL;
+	BOOL supportCommandQueue;
+
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
+
+	endIndex = (pDecInfo->openParam.wtlEnable == TRUE) ?
+			   pDecInfo->numFbsForWTL :
+			   pDecInfo->numFbsForDecoding;
+
+	if ((index < 0) || (index > (endIndex - 1))) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	supportCommandQueue = (pAttr->supportCommandQueue == TRUE);
+	if (supportCommandQueue == TRUE) {
+		EnterLock(pCodecInst->coreIdx);
+		LeaveLock(pCodecInst->coreIdx);
+	} else {
+		EnterDispFlagLock(pCodecInst->coreIdx);
+		pDecInfo->clearDisplayIndexes |= (1 << index);
+		LeaveDispFlagLock(pCodecInst->coreIdx);
+	}
+
+	VLOG(TRACE, "[%d]%s.h:0x%x.index:%d\n", __LINE__, __func__, handle,
+	     index);
+	return ret;
+}
+
+RetCode VPU_DecGiveCommand(DecHandle handle, CodecCommand cmd, void *param)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	RetCode ret;
+	DecOpenParam *pop = NULL;
+
+	VLOG(TRACE, "[%d]%s.h:0x%x.cmd:%d\n", __LINE__, __func__, handle, cmd);
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+	switch (cmd) {
+	case ENABLE_ROTATION: {
+		if (pDecInfo->rotatorStride == 0) {
+			return RETCODE_ROTATOR_STRIDE_NOT_SET;
+		}
+		pDecInfo->rotationEnable = 1;
+		break;
+	}
+
+	case DISABLE_ROTATION: {
+		pDecInfo->rotationEnable = 0;
+		break;
+	}
+
+	case ENABLE_MIRRORING: {
+		if (pDecInfo->rotatorStride == 0) {
+			return RETCODE_ROTATOR_STRIDE_NOT_SET;
+		}
+		pDecInfo->mirrorEnable = 1;
+		break;
+	}
+	case DISABLE_MIRRORING: {
+		pDecInfo->mirrorEnable = 0;
+		break;
+	}
+	case SET_MIRROR_DIRECTION: {
+		MirrorDirection mirDir;
+
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		mirDir = *(MirrorDirection *)param;
+		if (!(mirDir == MIRDIR_NONE) && !(mirDir == MIRDIR_HOR) &&
+		    !(mirDir == MIRDIR_VER) && !(mirDir == MIRDIR_HOR_VER)) {
+			return RETCODE_INVALID_PARAM;
+		}
+		pDecInfo->mirrorDirection = mirDir;
+
+		break;
+	}
+	case SET_ROTATION_ANGLE: {
+		int angle;
+
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		angle = *(int *)param;
+		if (angle != 0 && angle != 90 && angle != 180 && angle != 270) {
+			return RETCODE_INVALID_PARAM;
+		}
+		if (pDecInfo->rotatorStride != 0) {
+			if (angle == 90 || angle == 270) {
+				if (pDecInfo->initialInfo.picHeight >
+				    pDecInfo->rotatorStride) {
+					return RETCODE_INVALID_PARAM;
+				}
+			} else {
+				if (pDecInfo->initialInfo.picWidth >
+				    pDecInfo->rotatorStride) {
+					return RETCODE_INVALID_PARAM;
+				}
+			}
+		}
+
+		pDecInfo->rotationAngle = angle;
+		break;
+	}
+	case SET_ROTATOR_OUTPUT: {
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+		PhysicalAddress start, end, ppuAddr;
+#endif
+		FrameBuffer *frame;
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		frame = (FrameBuffer *)param;
+
+		pDecInfo->rotatorOutput = *frame;
+		pDecInfo->rotatorOutputValid = 1;
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+		start = pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+				.startAddress;
+		end = pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+			      .endAddress;
+		ppuAddr = GetXY2AXIAddr(&pDecInfo->mapCfg, 0, 0, 0,
+					pDecInfo->rotatorStride,
+					&pDecInfo->rotatorOutput);
+		start = (start < ppuAddr) ? start : ppuAddr;
+		ppuAddr += VPU_GetFrameBufSize(
+			pCodecInst->coreIdx, pDecInfo->rotatorStride,
+			pDecInfo->rotatorOutput.height,
+			pDecInfo->rotatorOutput.mapType, FORMAT_420,
+			pDecInfo->openParam.cbcrInterleave, &pDecInfo->dramCfg);
+		end = (end > ppuAddr) ? end : ppuAddr;
+
+		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+			.startAddress = start;
+		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+			.endAddress = end;
+		VLOG(INFO,
+		     "[%d]%s.set decRegion[WPROT_DEC_FRAME](%d,%d,0x%08x,0x%08x)\n",
+		     __LINE__, __func__,
+		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+			     .enable,
+		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+			     .isSecondary,
+		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+			     .startAddress,
+		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
+			     .endAddress);
+#endif
+		break;
+	}
+
+	case SET_ROTATOR_STRIDE: {
+		int stride;
+
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		stride = *(int *)param;
+		if (stride % 8 != 0 || stride == 0) {
+			return RETCODE_INVALID_STRIDE;
+		}
+
+		if (pDecInfo->rotationAngle == 90 ||
+		    pDecInfo->rotationAngle == 270) {
+			if (pDecInfo->initialInfo.picHeight > stride) {
+				return RETCODE_INVALID_STRIDE;
+			}
+		} else {
+			if (pDecInfo->initialInfo.picWidth > stride) {
+				return RETCODE_INVALID_STRIDE;
+			}
+		}
+
+		pDecInfo->rotatorStride = stride;
+		break;
+	}
+	case DEC_SET_SPS_RBSP: {
+		if (pCodecInst->codecMode != AVC_DEC &&
+		    pCodecInst->codecMode != W_AVC_DEC) {
+			return RETCODE_INVALID_COMMAND;
+		}
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		return SetParaSet(handle, 0, (DecParamSet *)param);
+	}
+
+	case DEC_SET_PPS_RBSP: {
+		if (pCodecInst->codecMode != AVC_DEC &&
+		    pCodecInst->codecMode != W_AVC_DEC) {
+			return RETCODE_INVALID_COMMAND;
+		}
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		return SetParaSet(handle, 1, (DecParamSet *)param);
+	}
+	case ENABLE_DERING: {
+		if (pDecInfo->rotatorStride == 0) {
+			return RETCODE_ROTATOR_STRIDE_NOT_SET;
+		}
+		pDecInfo->deringEnable = 1;
+		break;
+	}
+
+	case DISABLE_DERING: {
+		pDecInfo->deringEnable = 0;
+		break;
+	}
+	case SET_SEC_AXI: {
+		SecAxiUse secAxiUse;
+
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		secAxiUse = *(SecAxiUse *)param;
+
+		pDecInfo->secAxiInfo.u.coda9.useBitEnable =
+			secAxiUse.u.coda9.useBitEnable;
+		pDecInfo->secAxiInfo.u.coda9.useIpEnable =
+			secAxiUse.u.coda9.useIpEnable;
+		pDecInfo->secAxiInfo.u.coda9.useDbkYEnable =
+			secAxiUse.u.coda9.useDbkYEnable;
+		pDecInfo->secAxiInfo.u.coda9.useDbkCEnable =
+			secAxiUse.u.coda9.useDbkCEnable;
+		pDecInfo->secAxiInfo.u.coda9.useOvlEnable =
+			secAxiUse.u.coda9.useOvlEnable;
+		pDecInfo->secAxiInfo.u.coda9.useBtpEnable =
+			secAxiUse.u.coda9.useBtpEnable;
+
+		break;
+	}
+	case ENABLE_AFBCE: {
+		pDecInfo->enableAfbce = 1;
+		break;
+	}
+	case DISABLE_AFBCE: {
+		pDecInfo->enableAfbce = 0;
+		break;
+	}
+	case ENABLE_REP_USERDATA: {
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+		WriteMemProtectCfg *pCgf = &pDecInfo->writeMemProtectCfg;
+#endif
+		if (!pDecInfo->userDataBufAddr) {
+			return RETCODE_USERDATA_BUF_NOT_SET;
+		}
+		if (pDecInfo->userDataBufSize == 0) {
+			return RETCODE_USERDATA_BUF_NOT_SET;
+		}
+		switch (pCodecInst->productId) {
+		case PRODUCT_ID_420L:
+			pDecInfo->userDataEnable = *(Uint32 *)param;
+			break;
+		case PRODUCT_ID_960:
+		case PRODUCT_ID_980:
+			pDecInfo->userDataEnable = TRUE;
+			break;
+		default:
+			VLOG(INFO,
+			     "%s(ENABLE_REP_DATA) invalid productId(%d)\n",
+			     __FUNCTION__, pCodecInst->productId);
+			return RETCODE_INVALID_PARAM;
+		}
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+		pCgf->decRegion[WPROT_DEC_REPORT].enable = 1;
+		pCgf->decRegion[WPROT_DEC_REPORT].isSecondary = 0;
+		pCgf->decRegion[WPROT_DEC_REPORT].startAddress =
+			pDecInfo->userDataBufAddr;
+		pCgf->decRegion[WPROT_DEC_REPORT].endAddress =
+			pDecInfo->userDataBufAddr + pDecInfo->userDataBufSize;
+		VLOG(INFO,
+		     "[%d]%s.set decRegion[WPROT_DEC_REPORT](%d,%d,0x%08x,0x%08x)\n",
+		     __LINE__, __func__,
+		     pCgf->decRegion[WPROT_DEC_REPORT].enable,
+		     pCgf->decRegion[WPROT_DEC_REPORT].isSecondary,
+		     pCgf->decRegion[WPROT_DEC_REPORT].startAddress,
+		     pCgf->decRegion[WPROT_DEC_REPORT].endAddress);
+#endif
+		break;
+	}
+	case DISABLE_REP_USERDATA: {
+		pDecInfo->userDataEnable = 0;
+		break;
+	}
+	case SET_ADDR_REP_USERDATA: {
+		PhysicalAddress userDataBufAddr;
+
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		userDataBufAddr = *(PhysicalAddress *)param;
+		if (userDataBufAddr % 8 != 0 || userDataBufAddr == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		pDecInfo->userDataBufAddr = userDataBufAddr;
+		break;
+	}
+	case SET_VIRT_ADDR_REP_USERDATA: {
+		unsigned long userDataVirtAddr;
+
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		if (!pDecInfo->userDataBufAddr) {
+			return RETCODE_USERDATA_BUF_NOT_SET;
+		}
+		if (pDecInfo->userDataBufSize == 0) {
+			return RETCODE_USERDATA_BUF_NOT_SET;
+		}
+
+		userDataVirtAddr = *(unsigned long *)param;
+		if (!userDataVirtAddr) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		pDecInfo->vbUserData.phys_addr = pDecInfo->userDataBufAddr;
+		pDecInfo->vbUserData.size = pDecInfo->userDataBufSize;
+		pDecInfo->vbUserData.virt_addr =
+			(unsigned long)userDataVirtAddr;
+		if (vdi_attach_dma_memory(pCodecInst->coreIdx,
+					  &pDecInfo->vbUserData) != 0) {
+			return RETCODE_INSUFFICIENT_RESOURCE;
+		}
+		break;
+	}
+	case SET_SIZE_REP_USERDATA: {
+		PhysicalAddress userDataBufSize;
+
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		userDataBufSize = *(PhysicalAddress *)param;
+
+		pDecInfo->userDataBufSize = userDataBufSize;
+		break;
+	}
+
+	case SET_USERDATA_REPORT_MODE: {
+		int userDataMode;
+
+		userDataMode = *(int *)param;
+		if (userDataMode != 1 && userDataMode != 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		pDecInfo->userDataReportMode = userDataMode;
+		break;
+	}
+	case SET_CACHE_CONFIG: {
+		MaverickCacheConfig *mcCacheConfig;
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		mcCacheConfig = (MaverickCacheConfig *)param;
+		pDecInfo->cacheConfig = *mcCacheConfig;
+	} break;
+	case SET_LOW_DELAY_CONFIG: {
+		LowDelayInfo *lowDelayInfo;
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		if (pCodecInst->productId != PRODUCT_ID_980) {
+			return RETCODE_NOT_SUPPORTED_FEATURE;
+		}
+		lowDelayInfo = (LowDelayInfo *)param;
+
+		if (lowDelayInfo->lowDelayEn) {
+			if ((pCodecInst->codecMode != AVC_DEC &&
+			     pCodecInst->codecMode != W_AVC_DEC) ||
+			    pDecInfo->rotationEnable ||
+			    pDecInfo->mirrorEnable ||
+			    pDecInfo->tiled2LinearEnable ||
+			    pDecInfo->deringEnable) {
+				return RETCODE_INVALID_PARAM;
+			}
+		}
+
+		pDecInfo->lowDelayInfo.lowDelayEn = lowDelayInfo->lowDelayEn;
+		pDecInfo->lowDelayInfo.numRows = lowDelayInfo->numRows;
+	} break;
+
+	case SET_DECODE_FLUSH: // interrupt mode to pic_end
+		ret = ProductCpbFlush((CodecInst *)handle);
+		break;
+
+	case DEC_SET_FRAME_DELAY: {
+		pDecInfo->frameDelay = *(int *)param;
+		break;
+	}
+	case DEC_ENABLE_REORDER: {
+		if ((handle->productId == PRODUCT_ID_980) ||
+		    (handle->productId == PRODUCT_ID_960) ||
+		    (handle->productId == PRODUCT_ID_950)) {
+			if (pDecInfo->initialInfoObtained) {
+				return RETCODE_WRONG_CALL_SEQUENCE;
+			}
+		}
+
+		pDecInfo->reorderEnable = 1;
+		break;
+	}
+	case DEC_DISABLE_REORDER: {
+		if ((handle->productId == PRODUCT_ID_980) ||
+		    (handle->productId == PRODUCT_ID_960) ||
+		    (handle->productId == PRODUCT_ID_950)) {
+			if (pDecInfo->initialInfoObtained) {
+				return RETCODE_WRONG_CALL_SEQUENCE;
+			}
+
+			if (pCodecInst->codecMode != AVC_DEC &&
+			    pCodecInst->codecMode != VC1_DEC &&
+			    pCodecInst->codecMode != AVS_DEC &&
+			    pCodecInst->codecMode != W_AVC_DEC &&
+			    pCodecInst->codecMode != W_VC1_DEC &&
+			    pCodecInst->codecMode != W_AVS_DEC) {
+				return RETCODE_INVALID_COMMAND;
+			}
+		}
+
+		pDecInfo->reorderEnable = 0;
+		break;
+	}
+	case DEC_SET_AVC_ERROR_CONCEAL_MODE: {
+		if (pCodecInst->codecMode != AVC_DEC &&
+		    pCodecInst->codecMode != W_AVC_DEC) {
+			return RETCODE_INVALID_COMMAND;
+		}
+
+		pDecInfo->avcErrorConcealMode = *(int *)param;
+		break;
+	}
+	case DEC_FREE_FRAME_BUFFER: {
+		int i;
+		if (pDecInfo->vbSlice.size) {
+			VLOG(TRACE,
+			     "[%d]%s.vdi_free_dma_memory_no_mmap vbSlice(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, pDecInfo->vbSlice.phys_addr,
+			     pDecInfo->vbSlice.base,
+			     pDecInfo->vbSlice.virt_addr,
+			     pDecInfo->vbSlice.size,
+			     pDecInfo->vbSlice.req_spec_region);
+			vdi_free_dma_memory_no_mmap(pCodecInst->coreIdx,
+						    &pDecInfo->vbSlice);
+		}
+
+		if (pDecInfo->vbFrame.size) {
+			if (pDecInfo->frameAllocExt == 0) {
+				VLOG(TRACE,
+				     "[%d]%s.vdi_free_dma_memory vbFrame(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+				     __LINE__, __func__,
+				     pDecInfo->vbFrame.phys_addr,
+				     pDecInfo->vbFrame.base,
+				     pDecInfo->vbFrame.virt_addr,
+				     pDecInfo->vbFrame.size,
+				     pDecInfo->vbFrame.req_spec_region);
+				vdi_free_dma_memory(pCodecInst->coreIdx,
+						    &pDecInfo->vbFrame);
+			}
+		}
+		for (i = 0; i < MAX_REG_FRAME; i++) {
+			if (pDecInfo->vbFbcYTbl[i].size) {
+				if (pDecInfo->fbcTblAllocExt == 0) {
+					VLOG(TRACE,
+					     "[%d]%s.vdi_free_dma_memory vbFbcYTbl[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+					     __LINE__, __func__, i,
+					     pDecInfo->vbFbcYTbl[i].phys_addr,
+					     pDecInfo->vbFbcYTbl[i].base,
+					     pDecInfo->vbFbcYTbl[i].virt_addr,
+					     pDecInfo->vbFbcYTbl[i].size,
+					     pDecInfo->vbFbcYTbl[i]
+						     .req_spec_region);
+					vdi_free_dma_memory(
+						pCodecInst->coreIdx,
+						&pDecInfo->vbFbcYTbl[i]);
+				}
+			}
+
+			if (pDecInfo->vbFbcCTbl[i].size) {
+				if (pDecInfo->fbcTblAllocExt == 0) {
+					VLOG(TRACE,
+					     "[%d]%s.vdi_free_dma_memory vbFbcCTbl[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+					     __LINE__, __func__, i,
+					     pDecInfo->vbFbcCTbl[i].phys_addr,
+					     pDecInfo->vbFbcCTbl[i].base,
+					     pDecInfo->vbFbcCTbl[i].virt_addr,
+					     pDecInfo->vbFbcCTbl[i].size,
+					     pDecInfo->vbFbcCTbl[i]
+						     .req_spec_region);
+					vdi_free_dma_memory(
+						pCodecInst->coreIdx,
+						&pDecInfo->vbFbcCTbl[i]);
+				}
+			}
+
+#if !defined(DAH_222_PREALLOC_MV_SLICE_BUFFER)
+			if (pDecInfo->vbMV[i].size)
+				vdi_free_dma_memory_no_mmap(pCodecInst->coreIdx,
+							    &pDecInfo->vbMV[i]);
+#endif
+		}
+
+		if (pDecInfo->vbPPU.size) {
+			if (pDecInfo->ppuAllocExt == 0) {
+				VLOG(TRACE,
+				     "[%d]%s.vdi_free_dma_memory vbPPU(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+				     __LINE__, __func__,
+				     pDecInfo->vbPPU.phys_addr,
+				     pDecInfo->vbPPU.base,
+				     pDecInfo->vbPPU.virt_addr,
+				     pDecInfo->vbPPU.size,
+				     pDecInfo->vbPPU.req_spec_region);
+				vdi_free_dma_memory(pCodecInst->coreIdx,
+						    &pDecInfo->vbPPU);
+			}
+		}
+
+		if (pDecInfo->wtlEnable) {
+			if (pDecInfo->vbWTL.size) {
+				VLOG(TRACE,
+				     "[%d]%s.vdi_free_dma_memory vbWTL(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+				     __LINE__, __func__,
+				     pDecInfo->vbWTL.phys_addr,
+				     pDecInfo->vbWTL.base,
+				     pDecInfo->vbWTL.virt_addr,
+				     pDecInfo->vbWTL.size,
+				     pDecInfo->vbWTL.req_spec_region);
+				vdi_free_dma_memory(pCodecInst->coreIdx,
+						    &pDecInfo->vbWTL);
+			}
+		}
+		break;
+	}
+	case DEC_GET_FRAMEBUF_INFO: {
+		DecGetFramebufInfo *fbInfo = (DecGetFramebufInfo *)param;
+		Uint32 i;
+		fbInfo->vbFrame = pDecInfo->vbFrame;
+		fbInfo->vbWTL = pDecInfo->vbWTL;
+		for (i = 0; i < MAX_REG_FRAME; i++) {
+			fbInfo->vbFbcYTbl[i] = pDecInfo->vbFbcYTbl[i];
+			fbInfo->vbFbcCTbl[i] = pDecInfo->vbFbcCTbl[i];
+			fbInfo->vbMvCol[i] = pDecInfo->vbMV[i];
+		}
+
+		for (i = 0; i < MAX_GDI_IDX * 2; i++) {
+			fbInfo->framebufPool[i] = pDecInfo->frameBufPool[i];
+		}
+	} break;
+	case DEC_RESET_FRAMEBUF_INFO: {
+		int i;
+
+		pDecInfo->vbFrame.base = 0;
+		pDecInfo->vbFrame.phys_addr = 0;
+		pDecInfo->vbFrame.virt_addr = 0;
+		pDecInfo->vbFrame.size = 0;
+		pDecInfo->vbWTL.base = 0;
+		pDecInfo->vbWTL.phys_addr = 0;
+		pDecInfo->vbWTL.virt_addr = 0;
+		pDecInfo->vbWTL.size = 0;
+		for (i = 0; i < MAX_REG_FRAME; i++) {
+			pDecInfo->vbFbcYTbl[i].base = 0;
+			pDecInfo->vbFbcYTbl[i].phys_addr = 0;
+			pDecInfo->vbFbcYTbl[i].virt_addr = 0;
+			pDecInfo->vbFbcYTbl[i].size = 0;
+			pDecInfo->vbFbcCTbl[i].base = 0;
+			pDecInfo->vbFbcCTbl[i].phys_addr = 0;
+			pDecInfo->vbFbcCTbl[i].virt_addr = 0;
+			pDecInfo->vbFbcCTbl[i].size = 0;
+			pDecInfo->vbMV[i].base = 0;
+			pDecInfo->vbMV[i].phys_addr = 0;
+			pDecInfo->vbMV[i].virt_addr = 0;
+			pDecInfo->vbMV[i].size = 0;
+		}
+
+		pDecInfo->frameDisplayFlag = 0;
+		pDecInfo->setDisplayIndexes = 0;
+		pDecInfo->clearDisplayIndexes = 0;
+		break;
+	}
+	case DEC_GET_QUEUE_STATUS: {
+		DecQueueStatusInfo *queueInfo = (DecQueueStatusInfo *)param;
+		queueInfo->instanceQueueCount = pDecInfo->instanceQueueCount;
+		queueInfo->totalQueueCount = pDecInfo->totalQueueCount;
+		break;
+	}
+
+	case ENABLE_DEC_THUMBNAIL_MODE: {
+		pDecInfo->thumbnailMode = 1;
+		break;
+	}
+	case DEC_GET_SEQ_INFO: {
+		DecInitialInfo *seqInfo = (DecInitialInfo *)param;
+		*seqInfo = pDecInfo->initialInfo;
+		break;
+	}
+	case DEC_SET_SEQ_INFO: {
+		DecInitialInfo *seqInfo = (DecInitialInfo *)param;
+		pDecInfo->initialInfo = *seqInfo;
+		break;
+	}
+	case DEC_GET_FIELD_PIC_TYPE: {
+		return RETCODE_FAILURE;
+	}
+	case DEC_GET_DISPLAY_OUTPUT_INFO: {
+		DecOutputInfo *pDecOutInfo = (DecOutputInfo *)param;
+		*pDecOutInfo =
+			pDecInfo->decOutInfo[pDecOutInfo->indexFrameDisplay];
+		break;
+	}
+	case GET_TILEDMAP_CONFIG: {
+		TiledMapConfig *pMapCfg = (TiledMapConfig *)param;
+		if (!pMapCfg) {
+			return RETCODE_INVALID_PARAM;
+		}
+		if (!pDecInfo->stride) {
+			return RETCODE_WRONG_CALL_SEQUENCE;
+		}
+		*pMapCfg = pDecInfo->mapCfg;
+		break;
+	}
+	case SET_DRAM_CONFIG: {
+		DRAMConfig *cfg = (DRAMConfig *)param;
+
+		if (!cfg) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		pDecInfo->dramCfg = *cfg;
+		break;
+	}
+	case GET_DRAM_CONFIG: {
+		DRAMConfig *cfg = (DRAMConfig *)param;
+
+		if (!cfg) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		*cfg = pDecInfo->dramCfg;
+
+		break;
+	}
+	case GET_LOW_DELAY_OUTPUT: {
+		DecOutputInfo *lowDelayOutput;
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		if (!pDecInfo->lowDelayInfo.lowDelayEn ||
+		    pCodecInst->codecMode != AVC_DEC) {
+			return RETCODE_INVALID_COMMAND;
+		}
+
+		if (pCodecInst != GetPendingInst(pCodecInst->coreIdx)) {
+			return RETCODE_WRONG_CALL_SEQUENCE;
+		}
+
+		lowDelayOutput = (DecOutputInfo *)param;
+
+		GetLowDelayOutput(pCodecInst, lowDelayOutput);
+	} break;
+	case ENABLE_LOGGING: {
+		pCodecInst->loggingEnable = 1;
+	} break;
+	case DISABLE_LOGGING: {
+		pCodecInst->loggingEnable = 0;
+	} break;
+	case DEC_SET_SEQ_CHANGE_MASK:
+		if (PRODUCT_ID_NOT_W_SERIES(pCodecInst->productId))
+			return RETCODE_INVALID_PARAM;
+		pDecInfo->seqChangeMask = *(int *)param;
+		break;
+	case DEC_SET_WTL_FRAME_FORMAT:
+		pDecInfo->wtlFormat = *(FrameBufferFormat *)param;
+		break;
+	case DEC_SET_DISPLAY_FLAG: {
+		Int32 index;
+		VpuAttr *pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
+		BOOL supportCommandQueue = FALSE;
+
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		index = *(Int32 *)param;
+
+		supportCommandQueue = (pAttr->supportCommandQueue == TRUE);
+		if (supportCommandQueue == TRUE) {
+			EnterLock(pCodecInst->coreIdx);
+			LeaveLock(pCodecInst->coreIdx);
+		} else {
+			EnterDispFlagLock(pCodecInst->coreIdx);
+			pDecInfo->setDisplayIndexes |= (1 << index);
+			LeaveDispFlagLock(pCodecInst->coreIdx);
+		}
+
+	} break;
+	case DEC_GET_SCALER_INFO: {
+		ScalerInfo *scalerInfo = (ScalerInfo *)param;
+		if (scalerInfo == NULL) {
+			return RETCODE_INVALID_PARAM;
+		}
+		scalerInfo->enScaler = pDecInfo->scalerEnable;
+		scalerInfo->scaleWidth = pDecInfo->scaleWidth;
+		scalerInfo->scaleHeight = pDecInfo->scaleHeight;
+	} break;
+	case DEC_SET_SCALER_INFO: {
+		ScalerInfo *scalerInfo = (ScalerInfo *)param;
+
+		if (!pDecInfo->initialInfoObtained) {
+			return RETCODE_WRONG_CALL_SEQUENCE;
+		}
+
+		if (scalerInfo == NULL) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		pDecInfo->scalerEnable = scalerInfo->enScaler;
+		if (scalerInfo->enScaler == TRUE) {
+			// minW = Ceil8(picWidth/8), minH = Ceil8(picHeight/8)
+			Uint32 minScaleWidth =
+				VPU_ALIGN8(pDecInfo->initialInfo.picWidth >> 3);
+			Uint32 minScaleHeight = VPU_ALIGN8(
+				pDecInfo->initialInfo.picHeight >> 3);
+
+			if (minScaleWidth == 0)
+				minScaleWidth = 8;
+			if (minScaleHeight == 0)
+				minScaleHeight = 8;
+
+			if (scalerInfo->scaleWidth < minScaleWidth ||
+			    scalerInfo->scaleHeight < minScaleHeight) {
+				return RETCODE_INVALID_PARAM;
+			}
+
+			if (scalerInfo->scaleWidth > 0 ||
+			    scalerInfo->scaleHeight > 0) {
+				if ((scalerInfo->scaleWidth % 8) ||
+				    scalerInfo->scaleWidth >
+					    (Uint32)(VPU_ALIGN8(
+						    pDecInfo->initialInfo
+							    .picWidth))) {
+					return RETCODE_INVALID_PARAM;
+				}
+
+				if ((scalerInfo->scaleHeight % 8) ||
+				    scalerInfo->scaleHeight >
+					    (Uint32)(VPU_ALIGN8(
+						    pDecInfo->initialInfo
+							    .picHeight))) {
+					return RETCODE_INVALID_PARAM;
+				}
+				pDecInfo->scaleWidth = scalerInfo->scaleWidth;
+				pDecInfo->scaleHeight = scalerInfo->scaleHeight;
+				pDecInfo->scalerEnable = scalerInfo->enScaler;
+			}
+		}
+		break;
+	}
+	case DEC_SET_TARGET_TEMPORAL_ID:
+		if (param == NULL) {
+			return RETCODE_INVALID_PARAM;
+		}
+		if (pCodecInst->codecMode != HEVC_DEC) {
+			return RETCODE_NOT_SUPPORTED_FEATURE;
+		}
+		break;
+	case DEC_SET_BWB_CUR_FRAME_IDX:
+		pDecInfo->chBwbFrameIdx = *(Uint32 *)param;
+		break;
+	case DEC_SET_FBC_CUR_FRAME_IDX:
+		pDecInfo->chFbcFrameIdx = *(Uint32 *)param;
+		break;
+	case DEC_SET_INTER_RES_INFO_ON:
+		pDecInfo->interResChange = 1;
+		break;
+	case DEC_SET_INTER_RES_INFO_OFF:
+		pDecInfo->interResChange = 0;
+		break;
+	case DEC_FREE_FBC_TABLE_BUFFER: {
+		Uint32 fbcCurFrameIdx = *(Uint32 *)param;
+		if (pDecInfo->vbFbcYTbl[fbcCurFrameIdx].size > 0) {
+			VLOG(TRACE,
+			     "[%d]%s.vdi_free_dma_memory vbFbcYTbl[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, fbcCurFrameIdx,
+			     pDecInfo->vbFbcYTbl[fbcCurFrameIdx].phys_addr,
+			     pDecInfo->vbFbcYTbl[fbcCurFrameIdx].base,
+			     pDecInfo->vbFbcYTbl[fbcCurFrameIdx].virt_addr,
+			     pDecInfo->vbFbcYTbl[fbcCurFrameIdx].size,
+			     pDecInfo->vbFbcYTbl[fbcCurFrameIdx]
+				     .req_spec_region);
+			vdi_free_dma_memory(
+				pCodecInst->coreIdx,
+				&pDecInfo->vbFbcYTbl[fbcCurFrameIdx]);
+			pDecInfo->vbFbcYTbl[fbcCurFrameIdx].size = 0;
+		}
+		if (pDecInfo->vbFbcCTbl[fbcCurFrameIdx].size > 0) {
+			VLOG(TRACE,
+			     "[%d]%s.vdi_free_dma_memory vbFbcCTbl[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, fbcCurFrameIdx,
+			     pDecInfo->vbFbcCTbl[fbcCurFrameIdx].phys_addr,
+			     pDecInfo->vbFbcCTbl[fbcCurFrameIdx].base,
+			     pDecInfo->vbFbcCTbl[fbcCurFrameIdx].virt_addr,
+			     pDecInfo->vbFbcCTbl[fbcCurFrameIdx].size,
+			     pDecInfo->vbFbcCTbl[fbcCurFrameIdx]
+				     .req_spec_region);
+			vdi_free_dma_memory(
+				pCodecInst->coreIdx,
+				&pDecInfo->vbFbcCTbl[fbcCurFrameIdx]);
+			pDecInfo->vbFbcCTbl[fbcCurFrameIdx].size = 0;
+		}
+	} break;
+	case DEC_FREE_MV_BUFFER: {
+		Uint32 fbcCurFrameIdx = *(Uint32 *)param;
+		if (pDecInfo->vbMV[fbcCurFrameIdx].size > 0) {
+			VLOG(TRACE,
+			     "[%d]%s.vdi_free_dma_memory_no_mmap vbMV[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, fbcCurFrameIdx,
+			     pDecInfo->vbMV[fbcCurFrameIdx].phys_addr,
+			     pDecInfo->vbMV[fbcCurFrameIdx].base,
+			     pDecInfo->vbMV[fbcCurFrameIdx].virt_addr,
+			     pDecInfo->vbMV[fbcCurFrameIdx].size,
+			     pDecInfo->vbMV[fbcCurFrameIdx].req_spec_region);
+			vdi_free_dma_memory_no_mmap(
+				pCodecInst->coreIdx,
+				&pDecInfo->vbMV[fbcCurFrameIdx]);
+			pDecInfo->vbMV[fbcCurFrameIdx].size = 0;
+		}
+	} break;
+	case DEC_SET_YTBL_ADDR:
+	case DEC_SET_CTBL_ADDR:
+		if (param == NULL) {
+			return RETCODE_INVALID_PARAM;
+		}
+		if (pCodecInst->codecMode != HEVC_DEC &&
+		    pCodecInst->codecMode != W_VP9_DEC) {
+			return RETCODE_NOT_SUPPORTED_FEATURE;
+		} else {
+			int i = 0;
+			vpu_buffer_t *vb = (vpu_buffer_t *)param;
+			pDecInfo->fbcTblAllocExt = 1;
+			for (i = 0; i < MAX_GDI_IDX; i++) {
+				if (cmd == DEC_SET_YTBL_ADDR)
+					osal_memcpy((void *)&pDecInfo
+							    ->extVbFbcYTbls[i],
+						    &vb[i],
+						    sizeof(vpu_buffer_t));
+				else
+					osal_memcpy((void *)&pDecInfo
+							    ->extVbFbcCTbls[i],
+						    &vb[i],
+						    sizeof(vpu_buffer_t));
+			}
+		}
+		break;
+	case DEC_SET_WTL_MODE: {
+		if (param == NULL) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		pop = (DecOpenParam *)param;
+
+		pDecInfo->openParam.wtlEnable = pop->wtlEnable;
+		pDecInfo->openParam.wtlMode = pop->wtlMode;
+		pDecInfo->wtlEnable = pop->wtlEnable;
+		pDecInfo->wtlMode = pop->wtlMode;
+		if (!pDecInfo->wtlEnable)
+			pDecInfo->wtlMode = 0;
+	} break;
+	case DEC_SET_T2L_MODE: {
+		if (param == NULL) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		pop = (DecOpenParam *)param;
+
+		pDecInfo->openParam.tiled2LinearEnable =
+			pop->tiled2LinearEnable;
+		pDecInfo->openParam.tiled2LinearMode = pop->tiled2LinearMode;
+		pDecInfo->tiled2LinearEnable = pop->tiled2LinearEnable;
+		pDecInfo->tiled2LinearMode = pop->tiled2LinearMode;
+	} break;
+#ifdef SUPPORT_GET_NAL_START_POS
+	case DEC_GET_NAL_START_POS: {
+		PhysicalAddress *pos = (PhysicalAddress *)param;
+
+		*pos = pDecInfo->nalStartPtr;
+	} break;
+#endif
+
+	default:
+		return RETCODE_INVALID_COMMAND;
+	}
+
+	return ret;
+}
+
+RetCode VPU_DecAllocateFrameBuffer(DecHandle handle, FrameBufferAllocInfo info,
+				   FrameBuffer *frameBuffer)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	RetCode ret;
+	Uint32 gdiIndex;
+	int i;
+
+	VLOG(TRACE, "[+] [%d]%s.h:0x%x.mapType:%d.%d.%d.%d\n", __LINE__,
+	     __func__, handle, info.mapType, info.cbcrInterleave, info.nv21,
+	     info.format);
+	VLOG(TRACE, "[+] [%d]%s.h:0x%x.stride:%d.%d.%d.%d.%d\n", __LINE__,
+	     __func__, handle, info.stride, info.height, info.size,
+	     info.lumaBitDepth, info.chromaBitDepth);
+	VLOG(TRACE, "[+] [%d]%s.h:0x%x.endian:%d.%d.%d\n", __LINE__, __func__,
+	     handle, info.endian, info.num, info.type);
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS) {
+		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
+		     handle, ret);
+		return ret;
+	}
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	if (!frameBuffer) {
+		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:RETCODE_INVALID_PARAM\n",
+		     __LINE__, __func__, handle);
+		return RETCODE_INVALID_PARAM;
+	}
+
+	if (info.num) {
+		for (i = 0; i < info.num; i++) {
+			VLOG(TRACE,
+			     "[%d]%s.h:0x%x.size:%d.bufY:0x%x.0x%x.0x%x.updateFbInfo:%d\n",
+			     __LINE__, __func__, handle, frameBuffer[i].size,
+			     frameBuffer[i].bufY, frameBuffer[i].bufCb,
+			     frameBuffer[i].bufCr, frameBuffer[i].updateFbInfo);
+		}
+	}
+
+	if (info.type == FB_TYPE_PPU) {
+		if (pDecInfo->numFrameBuffers == 0)
+			return RETCODE_WRONG_CALL_SEQUENCE;
+		if (frameBuffer[0].updateFbInfo == TRUE) {
+			pDecInfo->ppuAllocExt = TRUE;
+		}
+		pDecInfo->ppuAllocExt = frameBuffer[0].updateFbInfo;
+		gdiIndex = pDecInfo->numFbsForDecoding;
+		ret = ProductVpuAllocateFramebuffer(
+			pCodecInst, frameBuffer, (TiledMapType)info.mapType,
+			(Int32)info.num, info.stride, info.height, info.format,
+			info.cbcrInterleave, info.nv21, info.endian,
+			&pDecInfo->vbPPU, gdiIndex, FB_TYPE_PPU);
+	} else if (info.type == FB_TYPE_CODEC) {
+		gdiIndex = 0;
+		if (frameBuffer[0].updateFbInfo == TRUE) {
+			pDecInfo->frameAllocExt = TRUE;
+		}
+		ret = ProductVpuAllocateFramebuffer(
+			pCodecInst, frameBuffer, (TiledMapType)info.mapType,
+			(Int32)info.num, info.stride, info.height, info.format,
+			info.cbcrInterleave, info.nv21, info.endian,
+			&pDecInfo->vbFrame, gdiIndex,
+			(FramebufferAllocType)info.type);
+
+		pDecInfo->mapCfg.tiledBaseAddr = pDecInfo->vbFrame.phys_addr;
+	}
+
+	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__, handle,
+	     ret);
+	return ret;
+}
+
+RetCode VPU_EncOpen(EncHandle *pHandle, EncOpenParam *pop)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	RetCode ret;
+
+	if ((ret = ProductCheckEncOpenParam(pop)) != RETCODE_SUCCESS)
+		return ret;
+
+	EnterLock(pop->coreIdx);
+
+	if (VPU_IsInit(pop->coreIdx) == 0) {
+		LeaveLock(pop->coreIdx);
+		return RETCODE_NOT_INITIALIZED;
+	}
+	ret = GetCodecInstance(pop->coreIdx, &pCodecInst, pop->filp);
+	if (ret == RETCODE_FAILURE) {
+		*pHandle = 0;
+		LeaveLock(pop->coreIdx);
+		return RETCODE_FAILURE;
+	}
+
+	pCodecInst->isDecoder = FALSE;
+	*pHandle = pCodecInst;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+
+	osal_memset(pEncInfo, 0x00, sizeof(EncInfo));
+	pEncInfo->openParam = *pop;
+
+	SetClockGate(pop->coreIdx, TRUE);
+	if ((ret = ProductVpuEncBuildUpOpenParam(pCodecInst, pop)) !=
+	    RETCODE_SUCCESS) {
+		*pHandle = 0;
+	}
+	SetClockGate(pop->coreIdx, FALSE);
+
+	LeaveLock(pCodecInst->coreIdx);
+
+	return ret;
+}
+
+RetCode VPU_EncClose(EncHandle handle)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	RetCode ret;
+
+	ret = CheckEncInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	if (pEncInfo->initialInfoObtained) {
+		VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamWrPtrRegAddr,
+			    pEncInfo->streamWrPtr);
+		VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamRdPtrRegAddr,
+			    pEncInfo->streamRdPtr);
+
+		if ((ret = ProductVpuEncFiniSeq(pCodecInst)) !=
+		    RETCODE_SUCCESS) {
+			if (pCodecInst->loggingEnable)
+				vdi_log(pCodecInst->coreIdx, ENC_SEQ_END, 0);
+
+			if (ret == RETCODE_VPU_STILL_RUNNING) {
+				LeaveLock(pCodecInst->coreIdx);
+				return ret;
+			}
+		}
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, ENC_SEQ_END, 0);
+		pEncInfo->streamWrPtr = VpuReadReg(
+			pCodecInst->coreIdx, pEncInfo->streamWrPtrRegAddr);
+	}
+
+	if (pEncInfo->vbScratch.size) {
+		VLOG(TRACE,
+		     "[%d]%s.vdi_free_dma_memory vbScratch(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+		     __LINE__, __func__, pEncInfo->vbScratch.phys_addr,
+		     pEncInfo->vbScratch.base, pEncInfo->vbScratch.virt_addr,
+		     pEncInfo->vbScratch.size,
+		     pEncInfo->vbScratch.req_spec_region);
+		vdi_free_dma_memory(pCodecInst->coreIdx, &pEncInfo->vbScratch);
+	}
+
+	if (pEncInfo->vbWork.size) {
+		VLOG(TRACE,
+		     "[%d]%s.vdi_free_dma_memory vbWork(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+		     __LINE__, __func__, pEncInfo->vbWork.phys_addr,
+		     pEncInfo->vbWork.base, pEncInfo->vbWork.virt_addr,
+		     pEncInfo->vbWork.size, pEncInfo->vbWork.req_spec_region);
+		vdi_free_dma_memory(pCodecInst->coreIdx, &pEncInfo->vbWork);
+	}
+
+	if (pEncInfo->vbFrame.size) {
+		if (pEncInfo->frameAllocExt == 0) {
+			VLOG(TRACE,
+			     "[%d]%s.vdi_free_dma_memory vbFrame(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, pEncInfo->vbFrame.phys_addr,
+			     pEncInfo->vbFrame.base,
+			     pEncInfo->vbFrame.virt_addr,
+			     pEncInfo->vbFrame.size,
+			     pEncInfo->vbFrame.req_spec_region);
+			vdi_free_dma_memory(pCodecInst->coreIdx,
+					    &pEncInfo->vbFrame);
+		}
+	}
+
+	if (pCodecInst->codecMode == W_AVC_ENC) {
+		if (pEncInfo->vbFbcYTbl.size) {
+			VLOG(TRACE,
+			     "[%d]%s.vdi_free_dma_memory vbFbcYTbl(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, pEncInfo->vbFbcYTbl.phys_addr,
+			     pEncInfo->vbFbcYTbl.base,
+			     pEncInfo->vbFbcYTbl.virt_addr,
+			     pEncInfo->vbFbcYTbl.size,
+			     pEncInfo->vbFbcYTbl.req_spec_region);
+			vdi_free_dma_memory(pCodecInst->coreIdx,
+					    &pEncInfo->vbFbcYTbl);
+		}
+
+		if (pEncInfo->vbFbcCTbl.size) {
+			VLOG(TRACE,
+			     "[%d]%s.vdi_free_dma_memory vbFbcCTbl(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, pEncInfo->vbFbcCTbl.phys_addr,
+			     pEncInfo->vbFbcCTbl.base,
+			     pEncInfo->vbFbcCTbl.virt_addr,
+			     pEncInfo->vbFbcCTbl.size,
+			     pEncInfo->vbFbcCTbl.req_spec_region);
+			vdi_free_dma_memory(pCodecInst->coreIdx,
+					    &pEncInfo->vbFbcCTbl);
+		}
+	}
+
+	if (pEncInfo->vbPPU.size) {
+		if (pEncInfo->ppuAllocExt == 0) {
+			VLOG(TRACE,
+			     "[%d]%s.vdi_free_dma_memory vbPPU(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+			     __LINE__, __func__, pEncInfo->vbPPU.phys_addr,
+			     pEncInfo->vbPPU.base, pEncInfo->vbPPU.virt_addr,
+			     pEncInfo->vbPPU.size,
+			     pEncInfo->vbPPU.req_spec_region);
+			vdi_free_dma_memory(pCodecInst->coreIdx,
+					    &pEncInfo->vbPPU);
+		}
+	}
+	if (pEncInfo->vbSubSampFrame.size) {
+		VLOG(TRACE,
+		     "[%d]%s.vdi_free_dma_memory vbSubSampFrame(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+		     __LINE__, __func__, pEncInfo->vbSubSampFrame.phys_addr,
+		     pEncInfo->vbSubSampFrame.base,
+		     pEncInfo->vbSubSampFrame.virt_addr,
+		     pEncInfo->vbSubSampFrame.size,
+		     pEncInfo->vbSubSampFrame.req_spec_region);
+		vdi_free_dma_memory(pCodecInst->coreIdx,
+				    &pEncInfo->vbSubSampFrame);
+	}
+	if (pEncInfo->vbMvcSubSampFrame.size) {
+		VLOG(TRACE,
+		     "[%d]%s.vdi_free_dma_memory vbMvcSubSampFrame(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
+		     __LINE__, __func__, pEncInfo->vbMvcSubSampFrame.phys_addr,
+		     pEncInfo->vbMvcSubSampFrame.base,
+		     pEncInfo->vbMvcSubSampFrame.virt_addr,
+		     pEncInfo->vbMvcSubSampFrame.size,
+		     pEncInfo->vbMvcSubSampFrame.req_spec_region);
+		vdi_free_dma_memory(pCodecInst->coreIdx,
+				    &pEncInfo->vbMvcSubSampFrame);
+	}
+
+	LeaveLock(pCodecInst->coreIdx);
+
+	FreeCodecInstance(pCodecInst);
+
+	return ret;
+}
+
+RetCode VPU_EncGetInitialInfo(EncHandle handle, EncInitialInfo *info)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	RetCode ret;
+
+	ret = CheckEncInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	if (info == 0) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	if (GetPendingInst(pCodecInst->coreIdx)) {
+		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
+		{
+			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
+			     __func__, __LINE__);
+			msleep(50);
+			if (GetPendingInst(pCodecInst->coreIdx)) {
+				LeaveLock(pCodecInst->coreIdx);
+				return RETCODE_FRAME_NOT_COMPLETE;
+			}
+		} else {
+			LeaveLock(pCodecInst->coreIdx);
+			return RETCODE_FRAME_NOT_COMPLETE;
+		}
+	}
+
+	if ((ret = ProductVpuEncSetup(pCodecInst)) != RETCODE_SUCCESS) {
+		LeaveLock(pCodecInst->coreIdx);
+		return ret;
+	}
+
+	if (pCodecInst->codecMode == AVC_ENC &&
+	    pCodecInst->codecModeAux == AVC_AUX_MVC)
+		info->minFrameBufferCount =
+			3; // reconstructed frame + 2 reference frame
+	else if (pCodecInst->codecMode == W_AVC_ENC &&
+		 pCodecInst->codecModeAux == AVC_AUX_MVC)
+		info->minFrameBufferCount =
+			3; // reconstructed frame + 2 reference frame
+	else
+		info->minFrameBufferCount =
+			2; // reconstructed frame + reference frame
+
+	pEncInfo->initialInfo = *info;
+	pEncInfo->initialInfoObtained = TRUE;
+
+	LeaveLock(pCodecInst->coreIdx);
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_EncRegisterFrameBuffer(EncHandle handle, FrameBuffer *bufArray,
+				   int num, int stride, int height, int mapType)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	Int32 i;
+	RetCode ret;
+	EncOpenParam *openParam;
+	FrameBuffer *fb;
+
+	ret = CheckEncInstanceValidity(handle);
+	// FIXME temp
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+	openParam = &pEncInfo->openParam;
+
+	if (pEncInfo->stride)
+		return RETCODE_CALLED_BEFORE;
+
+	if (!pEncInfo->initialInfoObtained)
+		return RETCODE_WRONG_CALL_SEQUENCE;
+
+	if (num < pEncInfo->initialInfo.minFrameBufferCount)
+		return RETCODE_INSUFFICIENT_FRAME_BUFFERS;
+
+	if (stride == 0 || (stride % 8 != 0) || stride < 0)
+		return RETCODE_INVALID_STRIDE;
+
+	if (height == 0 || height < 0)
+		return RETCODE_INVALID_PARAM;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	if (GetPendingInst(pCodecInst->coreIdx)) {
+		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
+		{
+			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
+			     __func__, __LINE__);
+			msleep(50);
+			if (GetPendingInst(pCodecInst->coreIdx)) {
+				LeaveLock(pCodecInst->coreIdx);
+				return RETCODE_FRAME_NOT_COMPLETE;
+			}
+		} else {
+			LeaveLock(pCodecInst->coreIdx);
+			return RETCODE_FRAME_NOT_COMPLETE;
+		}
+	}
+
+	pEncInfo->numFrameBuffers = num;
+	pEncInfo->stride = stride;
+	pEncInfo->frameBufferHeight = height;
+	pEncInfo->mapType = mapType;
+	pEncInfo->mapCfg.productId = pCodecInst->productId;
+
+	if (bufArray) {
+		for (i = 0; i < num; i++)
+			pEncInfo->frameBufPool[i] = bufArray[i];
+	}
+
+	if (pEncInfo->frameAllocExt == FALSE) {
+		fb = pEncInfo->frameBufPool;
+		if (bufArray) {
+			if (bufArray[0].bufCb == (Uint32)-1 &&
+			    bufArray[0].bufCr == (Uint32)-1) {
+				Uint32 size;
+				pEncInfo->frameAllocExt = TRUE;
+				size = ProductCalculateFrameBufSize(
+					pCodecInst->productId, stride, height,
+					(TiledMapType)mapType,
+					(FrameBufferFormat)openParam->srcFormat,
+					(BOOL)openParam->cbcrInterleave, NULL);
+				if (mapType == LINEAR_FRAME_MAP) {
+					pEncInfo->vbFrame.phys_addr =
+						bufArray[0].bufY;
+					pEncInfo->vbFrame.size = size * num;
+				}
+			}
+		}
+		ret = ProductVpuAllocateFramebuffer(
+			pCodecInst, fb, (TiledMapType)mapType, num, stride,
+			height, (FrameBufferFormat)openParam->srcFormat,
+			openParam->cbcrInterleave, FALSE,
+			openParam->frameEndian, &pEncInfo->vbFrame, 0,
+			FB_TYPE_CODEC);
+		if (ret != RETCODE_SUCCESS) {
+			LeaveLock(pCodecInst->coreIdx);
+			return ret;
+		}
+	}
+	ret = ProductVpuRegisterFramebuffer(pCodecInst);
+
+	LeaveLock(pCodecInst->coreIdx);
+
+	return ret;
+}
+
+RetCode VPU_EncGetFrameBuffer(EncHandle handle, int frameIdx,
+			      FrameBuffer *frameBuf)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	RetCode ret;
+
+	ret = CheckEncInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+
+	if (frameIdx < 0 || frameIdx > pEncInfo->numFrameBuffers)
+		return RETCODE_INVALID_PARAM;
+
+	if (frameBuf == 0)
+		return RETCODE_INVALID_PARAM;
+
+	*frameBuf = pEncInfo->frameBufPool[frameIdx];
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_EncGetBitstreamBuffer(EncHandle handle, PhysicalAddress *prdPrt,
+				  PhysicalAddress *pwrPtr, int *size)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	PhysicalAddress rdPtr;
+	PhysicalAddress wrPtr;
+	Uint32 room;
+	RetCode ret;
+
+	ret = CheckEncInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	if (prdPrt == 0 || pwrPtr == 0 || size == 0) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+
+	rdPtr = pEncInfo->streamRdPtr;
+
+	SetClockGate(pCodecInst->coreIdx, 1);
+
+	if (GetPendingInst(pCodecInst->coreIdx) == pCodecInst)
+		wrPtr = VpuReadReg(pCodecInst->coreIdx,
+				   pEncInfo->streamWrPtrRegAddr);
+	else
+		wrPtr = pEncInfo->streamWrPtr;
+
+	SetClockGate(pCodecInst->coreIdx, 0);
+	if (pEncInfo->ringBufferEnable == 1 || pEncInfo->lineBufIntEn == 1) {
+		if (wrPtr >= rdPtr) {
+			room = wrPtr - rdPtr;
+		} else {
+			room = (pEncInfo->streamBufEndAddr - rdPtr) +
+			       (wrPtr - pEncInfo->streamBufStartAddr);
+		}
+	} else {
+		if (wrPtr >= rdPtr)
+			room = wrPtr - rdPtr;
+		else
+			return RETCODE_INVALID_PARAM;
+	}
+
+	*prdPrt = rdPtr;
+	*pwrPtr = wrPtr;
+	*size = room;
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_EncUpdateBitstreamBuffer(EncHandle handle, int size)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	PhysicalAddress wrPtr;
+	PhysicalAddress rdPtr;
+	RetCode ret;
+	int room = 0;
+	ret = CheckEncInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+
+	rdPtr = pEncInfo->streamRdPtr;
+
+	SetClockGate(pCodecInst->coreIdx, 1);
+
+	if (GetPendingInst(pCodecInst->coreIdx) == pCodecInst)
+		wrPtr = VpuReadReg(pCodecInst->coreIdx,
+				   pEncInfo->streamWrPtrRegAddr);
+	else
+		wrPtr = pEncInfo->streamWrPtr;
+
+	if (rdPtr < wrPtr) {
+		if (rdPtr + size > wrPtr) {
+			SetClockGate(pCodecInst->coreIdx, 0);
+			return RETCODE_INVALID_PARAM;
+		}
+	}
+
+	if (pEncInfo->ringBufferEnable == TRUE ||
+	    pEncInfo->lineBufIntEn == TRUE) {
+		rdPtr += size;
+		if (rdPtr > pEncInfo->streamBufEndAddr) {
+			if (pEncInfo->lineBufIntEn == TRUE) {
+				return RETCODE_INVALID_PARAM;
+			}
+			room = rdPtr - pEncInfo->streamBufEndAddr;
+			rdPtr = pEncInfo->streamBufStartAddr;
+			rdPtr += room;
+		}
+
+		if (rdPtr == pEncInfo->streamBufEndAddr) {
+			rdPtr = pEncInfo->streamBufStartAddr;
+		}
+	} else {
+		rdPtr = pEncInfo->streamBufStartAddr;
+	}
+
+	pEncInfo->streamRdPtr = rdPtr;
+	pEncInfo->streamWrPtr = wrPtr;
+	if (GetPendingInst(pCodecInst->coreIdx) == pCodecInst)
+		VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamRdPtrRegAddr,
+			    rdPtr);
+
+	if (pEncInfo->lineBufIntEn == TRUE) {
+		pEncInfo->streamRdPtr = pEncInfo->streamBufStartAddr;
+	}
+
+	SetClockGate(pCodecInst->coreIdx, 0);
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_EncStartOneFrame(EncHandle handle, EncParam *param)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	RetCode ret;
+	VpuAttr *pAttr = NULL;
+	vpu_instance_pool_t *vip;
+
+	ret = CheckEncInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(pCodecInst->coreIdx);
+	if (!vip) {
+		return RETCODE_INVALID_HANDLE;
+	}
+
+	if (pEncInfo->stride ==
+	    0) { // This means frame buffers have not been registered.
+		return RETCODE_WRONG_CALL_SEQUENCE;
+	}
+
+	ret = CheckEncParam(handle, param);
+	if (ret != RETCODE_SUCCESS) {
+		return ret;
+	}
+
+	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
+
+	EnterLock(pCodecInst->coreIdx);
+
+	pEncInfo->ptsMap[param->srcIdx] =
+		(pEncInfo->openParam.enablePTS == TRUE) ? GetTimestamp(handle) :
+							  param->pts;
+
+	if (GetPendingInst(pCodecInst->coreIdx)) {
+		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
+		{
+			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
+			     __func__, __LINE__);
+			msleep(50);
+			if (GetPendingInst(pCodecInst->coreIdx)) {
+				LeaveLock(pCodecInst->coreIdx);
+				return RETCODE_FRAME_NOT_COMPLETE;
+			}
+		} else {
+			LeaveLock(pCodecInst->coreIdx);
+			return RETCODE_FRAME_NOT_COMPLETE;
+		}
+	}
+
+	ret = ProductVpuEncode(pCodecInst, param);
+
+	if (pAttr->supportCommandQueue == TRUE) {
+		SetPendingInst(pCodecInst->coreIdx, NULL);
+		LeaveLock(pCodecInst->coreIdx);
+	} else {
+		SetPendingInst(pCodecInst->coreIdx, pCodecInst);
+	}
+
+	return ret;
+}
+
+RetCode VPU_EncGetOutputInfo(EncHandle handle, EncOutputInfo *info)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	RetCode ret;
+	VpuAttr *pAttr;
+
+	ret = CheckEncInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS) {
+		return ret;
+	}
+
+	if (info == 0) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
+
+	if (pAttr->supportCommandQueue == TRUE) {
+		EnterLock(pCodecInst->coreIdx);
+	} else {
+		if (pCodecInst != GetPendingInst(pCodecInst->coreIdx)) {
+			SetPendingInst(pCodecInst->coreIdx, 0);
+			LeaveLock(pCodecInst->coreIdx);
+			return RETCODE_WRONG_CALL_SEQUENCE;
+		}
+	}
+
+	ret = ProductVpuEncGetResult(pCodecInst, info);
+
+	if (ret == RETCODE_SUCCESS) {
+		info->pts = pEncInfo->ptsMap[info->encSrcIdx];
+	} else {
+		info->pts = 0LL;
+	}
+
+	SetPendingInst(pCodecInst->coreIdx, 0);
+	LeaveLock(pCodecInst->coreIdx);
+
+	return ret;
+}
+
+RetCode VPU_EncGiveCommand(EncHandle handle, CodecCommand cmd, void *param)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	RetCode ret;
+
+	ret = CheckEncInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS) {
+		return ret;
+	}
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+	switch (cmd) {
+	case ENABLE_ROTATION: {
+		pEncInfo->rotationEnable = 1;
+	} break;
+	case DISABLE_ROTATION: {
+		pEncInfo->rotationEnable = 0;
+	} break;
+	case ENABLE_MIRRORING: {
+		pEncInfo->mirrorEnable = 1;
+	} break;
+	case DISABLE_MIRRORING: {
+		pEncInfo->mirrorEnable = 0;
+	} break;
+	case SET_MIRROR_DIRECTION: {
+		MirrorDirection mirDir;
+
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		mirDir = *(MirrorDirection *)param;
+		if (!(mirDir == MIRDIR_NONE) && !(mirDir == MIRDIR_HOR) &&
+		    !(mirDir == MIRDIR_VER) && !(mirDir == MIRDIR_HOR_VER)) {
+			return RETCODE_INVALID_PARAM;
+		}
+		pEncInfo->mirrorDirection = mirDir;
+	} break;
+	case SET_ROTATION_ANGLE: {
+		int angle;
+
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		angle = *(int *)param;
+		if (angle != 0 && angle != 90 && angle != 180 && angle != 270) {
+			return RETCODE_INVALID_PARAM;
+		}
+		if (pEncInfo->initialInfoObtained &&
+		    (angle == 90 || angle == 270)) {
+			return RETCODE_INVALID_PARAM;
+		}
+		pEncInfo->rotationAngle = angle;
+	} break;
+	case SET_CACHE_CONFIG: {
+		MaverickCacheConfig *mcCacheConfig;
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		mcCacheConfig = (MaverickCacheConfig *)param;
+		pEncInfo->cacheConfig = *mcCacheConfig;
+	} break;
+	case ENC_PUT_MP4_HEADER:
+	case ENC_PUT_AVC_HEADER:
+	case ENC_PUT_VIDEO_HEADER: {
+		EncHeaderParam *encHeaderParam;
+
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		encHeaderParam = (EncHeaderParam *)param;
+		if (pCodecInst->codecMode == MP4_ENC ||
+		    pCodecInst->codecMode == W_MP4_ENC) {
+			if (!(VOL_HEADER <= encHeaderParam->headerType &&
+			      encHeaderParam->headerType <= VIS_HEADER)) {
+				return RETCODE_INVALID_PARAM;
+			}
+		} else if (pCodecInst->codecMode == AVC_ENC ||
+			   pCodecInst->codecMode == W_AVC_ENC) {
+			if (!(SPS_RBSP <= encHeaderParam->headerType &&
+			      encHeaderParam->headerType <= PPS_RBSP_MVC)) {
+				return RETCODE_INVALID_PARAM;
+			}
+		} else
+			return RETCODE_INVALID_PARAM;
+
+		if (pEncInfo->ringBufferEnable == 0) {
+			if (encHeaderParam->buf % 8 ||
+			    encHeaderParam->size == 0) {
+				return RETCODE_INVALID_PARAM;
+			}
+		}
+
+		return GetEncHeader(handle, encHeaderParam);
+	}
+	case ENC_SET_ACTIVE_PPS: {
+		int ActivePPSIdx = (int)(*(int *)param);
+		if (pCodecInst->codecMode != AVC_ENC &&
+		    pCodecInst->codecMode != W_AVC_ENC)
+			return RETCODE_INVALID_COMMAND;
+		if (ActivePPSIdx < 0 ||
+		    ActivePPSIdx >
+			    pEncInfo->openParam.EncStdParam.avcParam.ppsNum)
+			return RETCODE_INVALID_COMMAND;
+
+		pEncInfo->ActivePPSIdx = ActivePPSIdx;
+		return EncParaSet(handle, PPS_RBSP);
+	} break;
+	case ENC_GET_ACTIVE_PPS:
+		if (pCodecInst->codecMode != AVC_ENC &&
+		    pCodecInst->codecMode != W_AVC_ENC)
+			return RETCODE_INVALID_COMMAND;
+		*((int *)param) = pEncInfo->ActivePPSIdx;
+		break;
+	case ENC_SET_GOP_NUMBER: {
+		int *pGopNumber = (int *)param;
+		if (pCodecInst->codecMode != MP4_ENC &&
+		    pCodecInst->codecMode != AVC_ENC &&
+		    pCodecInst->codecMode != W_MP4_ENC &&
+		    pCodecInst->codecMode != W_AVC_ENC) {
+			return RETCODE_INVALID_COMMAND;
+		}
+		if (*pGopNumber < 0)
+			return RETCODE_INVALID_PARAM;
+		pEncInfo->openParam.gopSize = *pGopNumber;
+		SetGopNumber(handle, (Uint32 *)pGopNumber);
+	} break;
+	case ENC_SET_INTRA_QP: {
+		int *pIntraQp = (int *)param;
+		if (pCodecInst->codecMode != MP4_ENC &&
+		    pCodecInst->codecMode != AVC_ENC &&
+		    pCodecInst->codecMode != W_MP4_ENC &&
+		    pCodecInst->codecMode != W_AVC_ENC) {
+			return RETCODE_INVALID_COMMAND;
+		}
+		if (pCodecInst->codecMode == MP4_ENC ||
+		    pCodecInst->codecMode == W_MP4_ENC) {
+			if (*pIntraQp < 1 || *pIntraQp > 31)
+				return RETCODE_INVALID_PARAM;
+		}
+		if (pCodecInst->codecMode == AVC_ENC ||
+		    pCodecInst->codecMode == W_AVC_ENC) {
+			if (*pIntraQp < 0 || *pIntraQp > 51)
+				return RETCODE_INVALID_PARAM;
+		}
+		SetIntraQp(handle, (Uint32 *)pIntraQp);
+	} break;
+	case ENC_SET_BITRATE: {
+		int *pBitrate = (int *)param;
+		if (pCodecInst->codecMode != MP4_ENC &&
+		    pCodecInst->codecMode != AVC_ENC &&
+		    pCodecInst->codecMode != W_MP4_ENC &&
+		    pCodecInst->codecMode != W_AVC_ENC) {
+			return RETCODE_INVALID_COMMAND;
+		}
+		if (pCodecInst->codecMode == AVC_ENC ||
+		    pCodecInst->codecMode == W_AVC_ENC) {
+			if (*pBitrate < 0 || *pBitrate > 524288) {
+				return RETCODE_INVALID_PARAM;
+			}
+
+		} else // MP4_ENC
+		{
+			if (*pBitrate < 0 || *pBitrate > 32767) {
+				return RETCODE_INVALID_PARAM;
+			}
+		}
+		SetBitrate(handle, (Uint32 *)pBitrate);
+	} break;
+	case ENC_SET_FRAME_RATE: {
+		int *pFramerate = (int *)param;
+
+		if (pCodecInst->codecMode != MP4_ENC &&
+		    pCodecInst->codecMode != AVC_ENC &&
+		    pCodecInst->codecMode != W_MP4_ENC &&
+		    pCodecInst->codecMode != W_AVC_ENC) {
+			return RETCODE_INVALID_COMMAND;
+		}
+		if (*pFramerate <= 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		SetFramerate(handle, (Uint32 *)pFramerate);
+	} break;
+	case ENC_SET_INTRA_MB_REFRESH_NUMBER: {
+		int *pIntraRefreshNum = (int *)param;
+		SetIntraRefreshNum(handle, (Uint32 *)pIntraRefreshNum);
+	} break;
+	case ENC_SET_SLICE_INFO: {
+		EncSliceMode *pSliceMode = (EncSliceMode *)param;
+		if (pSliceMode->sliceMode < 0 || pSliceMode->sliceMode > 1) {
+			return RETCODE_INVALID_PARAM;
+		}
+		if (pSliceMode->sliceSizeMode < 0 ||
+		    pSliceMode->sliceSizeMode > 1) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		SetSliceMode(handle, (EncSliceMode *)pSliceMode);
+	} break;
+	case ENC_ENABLE_HEC: {
+		if (pCodecInst->codecMode != MP4_ENC &&
+		    pCodecInst->codecMode != W_MP4_ENC) {
+			return RETCODE_INVALID_COMMAND;
+		}
+		SetHecMode(handle, 1);
+	} break;
+	case ENC_DISABLE_HEC: {
+		if (pCodecInst->codecMode != MP4_ENC &&
+		    pCodecInst->codecMode != W_MP4_ENC) {
+			return RETCODE_INVALID_COMMAND;
+		}
+		SetHecMode(handle, 0);
+	} break;
+	case SET_SEC_AXI: {
+		SecAxiUse secAxiUse;
+
+		if (param == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+		secAxiUse = *(SecAxiUse *)param;
+
+		// coda9 or coda7q or ...
+		pEncInfo->secAxiInfo.u.coda9.useBitEnable =
+			secAxiUse.u.coda9.useBitEnable;
+		pEncInfo->secAxiInfo.u.coda9.useIpEnable =
+			secAxiUse.u.coda9.useIpEnable;
+		pEncInfo->secAxiInfo.u.coda9.useDbkYEnable =
+			secAxiUse.u.coda9.useDbkYEnable;
+		pEncInfo->secAxiInfo.u.coda9.useDbkCEnable =
+			secAxiUse.u.coda9.useDbkCEnable;
+		pEncInfo->secAxiInfo.u.coda9.useOvlEnable =
+			secAxiUse.u.coda9.useOvlEnable;
+		pEncInfo->secAxiInfo.u.coda9.useBtpEnable =
+			secAxiUse.u.coda9.useBtpEnable;
+	} break;
+	case GET_TILEDMAP_CONFIG: {
+		TiledMapConfig *pMapCfg = (TiledMapConfig *)param;
+		if (!pMapCfg) {
+			return RETCODE_INVALID_PARAM;
+		}
+		*pMapCfg = pEncInfo->mapCfg;
+		break;
+	}
+	case SET_DRAM_CONFIG: {
+		DRAMConfig *cfg = (DRAMConfig *)param;
+
+		if (!cfg) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		pEncInfo->dramCfg = *cfg;
+		break;
+	}
+	case GET_DRAM_CONFIG: {
+		DRAMConfig *cfg = (DRAMConfig *)param;
+
+		if (!cfg) {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		*cfg = pEncInfo->dramCfg;
+
+		break;
+	}
+	case ENABLE_LOGGING: {
+		pCodecInst->loggingEnable = 1;
+	} break;
+	case DISABLE_LOGGING: {
+		pCodecInst->loggingEnable = 0;
+	} break;
+	case ENC_SET_PARA_CHANGE: {
+		return RETCODE_INVALID_PARAM;
+	} break;
+	default:
+		return RETCODE_INVALID_COMMAND;
+	}
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_EncAllocateFrameBuffer(EncHandle handle, FrameBufferAllocInfo info,
+				   FrameBuffer *frameBuffer)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	RetCode ret;
+	int gdiIndex;
+
+	ret = CheckEncInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+
+	if (!frameBuffer) {
+		return RETCODE_INVALID_PARAM;
+	}
+	if (info.num == 0 || info.num < 0) {
+		return RETCODE_INVALID_PARAM;
+	}
+	if (info.stride == 0 || info.stride < 0) {
+		return RETCODE_INVALID_PARAM;
+	}
+	if (info.height == 0 || info.height < 0) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	if (info.type == FB_TYPE_PPU) {
+		if (pEncInfo->numFrameBuffers == 0) {
+			return RETCODE_WRONG_CALL_SEQUENCE;
+		}
+		pEncInfo->ppuAllocExt = frameBuffer[0].updateFbInfo;
+		gdiIndex = pEncInfo->numFrameBuffers;
+		ret = ProductVpuAllocateFramebuffer(
+			pCodecInst, frameBuffer, (TiledMapType)info.mapType,
+			(Int32)info.num, info.stride, info.height, info.format,
+			info.cbcrInterleave, info.nv21, info.endian,
+			&pEncInfo->vbPPU, gdiIndex,
+			(FramebufferAllocType)info.type);
+	} else if (info.type == FB_TYPE_CODEC) {
+		gdiIndex = 0;
+		pEncInfo->frameAllocExt = frameBuffer[0].updateFbInfo;
+		ret = ProductVpuAllocateFramebuffer(
+			pCodecInst, frameBuffer, (TiledMapType)info.mapType,
+			(Int32)info.num, info.stride, info.height, info.format,
+			info.cbcrInterleave, FALSE, info.endian,
+			&pEncInfo->vbFrame, gdiIndex,
+			(FramebufferAllocType)info.type);
+	} else {
+		ret = RETCODE_INVALID_PARAM;
+	}
+
+	return ret;
+}
+
+RetCode VPU_EncIssueSeqInit(EncHandle handle)
+{
+	CodecInst *pCodecInst;
+	RetCode ret;
+	VpuAttr *pAttr;
+
+	ret = CheckEncInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	pCodecInst = handle;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
+
+	if (GetPendingInst(pCodecInst->coreIdx)) {
+		LeaveLock(pCodecInst->coreIdx);
+		return RETCODE_FRAME_NOT_COMPLETE;
+	}
+
+	ret = ProductVpuEncInitSeq(handle);
+	if (ret == RETCODE_SUCCESS) {
+		SetPendingInst(pCodecInst->coreIdx, pCodecInst);
+	}
+
+	if (pAttr->supportCommandQueue == TRUE) {
+		SetPendingInst(pCodecInst->coreIdx, NULL);
+		LeaveLock(pCodecInst->coreIdx);
+	}
+
+	return ret;
+}
+
+RetCode VPU_EncCompleteSeqInit(EncHandle handle, EncInitialInfo *info)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	RetCode ret;
+	VpuAttr *pAttr;
+
+	ret = CheckEncInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS) {
+		return ret;
+	}
+
+	if (info == 0) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+
+	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
+
+	if (pAttr->supportCommandQueue == TRUE) {
+		EnterLock(pCodecInst->coreIdx);
+	} else {
+		if (pCodecInst != GetPendingInst(pCodecInst->coreIdx)) {
+			SetPendingInst(pCodecInst->coreIdx, 0);
+			LeaveLock(pCodecInst->coreIdx);
+			return RETCODE_WRONG_CALL_SEQUENCE;
+		}
+	}
+
+	ret = ProductVpuEncGetSeqInfo(handle, info);
+	if (ret == RETCODE_SUCCESS) {
+		pEncInfo->initialInfoObtained = 1;
+	}
+
+	pEncInfo->initialInfo = *info;
+
+	SetPendingInst(pCodecInst->coreIdx, NULL);
+
+	LeaveLock(pCodecInst->coreIdx);
+
+	return ret;
+}
+
+RetCode VPU_DecGetRdPtr(DecHandle handle, PhysicalAddress *prdPtr)
+{
+	CodecInst *pCodecInst;
+	CodecInst *pPendingInst;
+	DecInfo *pDecInfo;
+	RetCode ret;
+
+	PhysicalAddress rdPtr;
+
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS) {
+		return ret;
+	}
+	pCodecInst = (CodecInst *)handle;
+	ret = ProductVpuDecCheckCapability(pCodecInst);
+	if (ret != RETCODE_SUCCESS) {
+		return ret;
+	}
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+	pPendingInst = GetPendingInst(pCodecInst->coreIdx);
+	if (pCodecInst == pPendingInst) {
+		rdPtr = VpuReadReg(pCodecInst->coreIdx,
+				   pDecInfo->streamRdPtrRegAddr);
+	} else {
+		EnterLock(pCodecInst->coreIdx);
+		rdPtr = VpuReadReg(pCodecInst->coreIdx,
+				   pDecInfo->streamRdPtrRegAddr);
+		LeaveLock(pCodecInst->coreIdx);
+	}
+
+	if (prdPtr)
+		*prdPtr = rdPtr;
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_DecSetWrPtr(DecHandle handle, PhysicalAddress addr, int updateRdPtr)
+{
+	CodecInst *pCodecInst;
+	CodecInst *pPendingInst;
+	DecInfo *pDecInfo;
+	RetCode ret;
+
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+	pCodecInst = (CodecInst *)handle;
+	pDecInfo = &handle->CodecInfo->decInfo;
+	pPendingInst = GetPendingInst(pCodecInst->coreIdx);
+	if (pCodecInst == pPendingInst) {
+		VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamWrPtrRegAddr,
+			    addr);
+	} else {
+		EnterLock(pCodecInst->coreIdx);
+		VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamWrPtrRegAddr,
+			    addr);
+		LeaveLock(pCodecInst->coreIdx);
+	}
+	pDecInfo->streamWrPtr = addr;
+	if (updateRdPtr)
+		pDecInfo->streamRdPtr = addr;
+
+	VLOG(TRACE, "[%d]%s.h:0x%x.addr:0x%x.updateRdPtr:%d\n", __LINE__,
+	     __func__, handle, addr, updateRdPtr);
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_DecGetBitstreamBufferNoHW(DecHandle handle, PhysicalAddress *prdPtr,
+				      PhysicalAddress *pwrPtr, Uint32 *size)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	PhysicalAddress rdPtr;
+	PhysicalAddress wrPtr;
+	PhysicalAddress tempPtr;
+	int room;
+	Int32 coreIdx;
+	VpuAttr *pAttr;
+
+	coreIdx = handle->coreIdx;
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	rdPtr = pDecInfo->streamRdPtr;
+	wrPtr = pDecInfo->streamWrPtr;
+
+	pAttr = &g_VpuCoreAttributes[coreIdx];
+
+	tempPtr = rdPtr;
+
+	if (pDecInfo->openParam.bitstreamMode != BS_MODE_PIC_END) {
+		if (wrPtr < tempPtr) {
+			room = tempPtr - wrPtr -
+			       pAttr->bitstreamBufferMargin * 2;
+		} else {
+			room = (pDecInfo->streamBufEndAddr - wrPtr) +
+			       (tempPtr - pDecInfo->streamBufStartAddr) -
+			       pAttr->bitstreamBufferMargin * 2;
+		}
+		room--;
+	} else {
+		room = (pDecInfo->streamBufEndAddr - wrPtr);
+	}
+
+	if (prdPtr)
+		*prdPtr = tempPtr;
+	if (pwrPtr)
+		*pwrPtr = wrPtr;
+	if (size)
+		*size = room;
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode VPU_DecUpdateBitstreamBufferNoHW(DecHandle handle, int size)
+{
+	CodecInst *pCodecInst;
+	DecInfo *pDecInfo;
+	PhysicalAddress wrPtr;
+	PhysicalAddress rdPtr;
+	RetCode ret;
+	BOOL running;
+
+	ret = CheckDecInstanceValidity(handle);
+	if (ret != RETCODE_SUCCESS)
+		return ret;
+
+	pCodecInst = handle;
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+	wrPtr = pDecInfo->streamWrPtr;
+
+	running = FALSE;
+
+	if (size > 0) {
+		Uint32 room = 0;
+
+		rdPtr = pDecInfo->streamRdPtr;
+
+		if (wrPtr < rdPtr) {
+			if (rdPtr <= wrPtr + size) {
+				return RETCODE_INVALID_PARAM;
+			}
+		}
+
+		wrPtr += size;
+
+		if (wrPtr > pDecInfo->streamBufEndAddr) {
+			room = wrPtr - pDecInfo->streamBufEndAddr;
+			wrPtr = pDecInfo->streamBufStartAddr;
+			wrPtr += room;
+		} else if (wrPtr == pDecInfo->streamBufEndAddr) {
+			wrPtr = pDecInfo->streamBufStartAddr;
+		}
+
+		pDecInfo->streamWrPtr = wrPtr;
+		pDecInfo->streamRdPtr = rdPtr;
+
+		if (running == TRUE) {
+			VpuAttr *pAttr =
+				&g_VpuCoreAttributes[pCodecInst->coreIdx];
+			if (pAttr->supportCommandQueue == FALSE) {
+				VpuWriteReg(pCodecInst->coreIdx,
+					    pDecInfo->streamWrPtrRegAddr,
+					    wrPtr);
+			}
+		}
+	}
+
+	ret = ProductVpuDecSetBitstreamFlag(pCodecInst, running, size);
+
+	return ret;
+}
+
+RetCode VPU_DBG_DUMP_SDATA(DecHandle handle, unsigned int phy_addr,
+			   unsigned char *dst_buf, int dst_buf_size)
+{
+	RetCode ret = RETCODE_SUCCESS;
+#ifdef ENABLE_TEE_DRM_FLOW
+	int taRet;
+	CodecInst *pCodecInst;
+	vpu_buffer_t *vb = NULL;
+
+	VLOG(TRACE,
+	     "[+] [%d]%s.handle:0x%px.phy_addr:0x%x.dst_buf:0x%px.dst_buf_size:%d\n",
+	     __LINE__, __func__, handle, phy_addr, dst_buf, dst_buf_size);
+
+	if (handle == NULL || phy_addr == 0 || dst_buf == NULL ||
+	    dst_buf_size <= 0) {
+		VLOG(ERR,
+		     "[-] [%d]%s.invalid parameters.handle:0x%px.phy_addr:0x%x.dst_buf:0x%px.dst_buf_size:%d\n",
+		     __LINE__, __func__, handle, phy_addr, dst_buf,
+		     dst_buf_size);
+		return RETCODE_INVALID_PARAM;
+	}
+	pCodecInst = handle;
+
+	vb = kzalloc(sizeof(DecOpenParam), GFP_KERNEL);
+	if (!vb) {
+		VLOG(ERR, "[%d]%s.handle:0x%px.kzalloc vb fail\n", __LINE__,
+		     __func__, handle);
+		goto exit;
+	}
+
+	vb->size = dst_buf_size;
+	vb->req_spec_region = VE_SECURE_PROTECTION;
+	if (vdi_allocate_dma_memory_no_mmap(pCodecInst->coreIdx, (void *)vb,
+					    pCodecInst->filp) < 0) {
+		VLOG(ERR,
+		     "[%d]%s.handle:0x%px.vdi_allocate_dma_memory_no_mmap() fail\n",
+		     __LINE__, __func__, handle);
+		ret = RETCODE_INSUFFICIENT_RESOURCE;
+		goto free_vb;
+	}
+
+	taRet = ta_TEEapi_memcpy((struct tee_context *)pCodecInst->teeapi_ctx,
+				 pCodecInst->teeapi_tee_session, vb->phys_addr,
+				 phy_addr, dst_buf_size);
+	if (taRet < 0) {
+		VLOG(ERR, "[%d]%s.ta_TEEapi_memcpy() fail.ret:%d\n", __LINE__,
+		     __func__, taRet);
+		ret = RETCODE_FAILURE;
+		goto free_vb_ion;
+	}
+
+	taRet = ta_TEEapi_bitstreamprint(
+		(struct tee_context *)pCodecInst->teeapi_ctx,
+		pCodecInst->teeapi_tee_session, vb->phys_addr, dst_buf_size);
+	if (taRet < 0) {
+		VLOG(ERR, "[%d]%s.ta_TEEapi_bitstreamprint() fail.ret:%d\n",
+		     __LINE__, __func__, taRet);
+		ret = RETCODE_FAILURE;
+		goto free_vb_ion;
+	}
+
+	taRet = ta_TEEapi_bitstreamout(
+		(struct tee_context *)pCodecInst->teeapi_ctx,
+		pCodecInst->teeapi_tee_session, vb->phys_addr, dst_buf,
+		dst_buf_size);
+	if (taRet < 0) {
+		VLOG(ERR, "[%d]%s.ta_TEEapi_bitstreamout() fail.ret:%d\n",
+		     __LINE__, __func__, taRet);
+		ret = RETCODE_FAILURE;
+		goto free_vb_ion;
+	}
+
+free_vb_ion:
+	vdi_free_dma_memory_no_mmap(pCodecInst->coreIdx, vb);
+free_vb:
+	kfree(vb);
+exit:
+	VLOG(TRACE, "[-] [%d]%s.ret:%d\n", __LINE__, __func__, ret);
+#else
+	VLOG(ERR, "[%d]%s.unsupport ifndef ENABLE_TEE_DRM_FLOW\n", __LINE__,
+	     __func__);
+	ret = RETCODE_FAILURE;
+#endif // #ifdef ENABLE_TEE_DRM_FLOW
+	return ret;
+}
\ No newline at end of file
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_vpuapi.h
@@ -0,0 +1,6535 @@
+//--=========================================================================--
+//  This file is a part of VPU Reference API project
+//-----------------------------------------------------------------------------
+//
+//       This confidential and proprietary software may be used only
+//     as authorized by a licensing agreement from Chips&Media Inc.
+//     In the event of publication, the following notice is applicable:
+//
+//            (C) COPYRIGHT 2006 - 2013  CHIPS&MEDIA INC.
+//                      ALL RIGHTS RESERVED
+//
+//       The entire notice above must be reproduced on all authorized
+//       copies.
+//
+//--=========================================================================--
+
+#ifndef VPUAPI_H_INCLUDED
+#define VPUAPI_H_INCLUDED
+
+#include "ve1config.h"
+#include "ve1_vputypes.h"
+#include "ve1_vdi.h"
+#include "ve1_vdi_osal.h"
+#include "ve1_vpuerror.h"
+
+#define MAX_GDI_IDX                                                            \
+	30 //31 //RTK, because 31 will causes memory overwrite when endian swap
+#define MAX_REG_FRAME MAX_GDI_IDX * 2 // 2 for WTL
+
+#define VPU_FIRMWARE_SIZE (272 * 1024)
+/* RTK DCSYS debug */
+#define REG_DC_PC_CTRL 0x30
+#define REG_DC_PC_TOTA_ACK_NUM_0 0x38
+#define REG_DC_PC_SYSH_prog_ctrl 0x50
+#define REG_DC_PC_SYSH_prog_ctrl_2 0x500
+#define REG_DC_PC_SYSH_prog_0_ACC_LAT 0x60
+#define REG_DC_PC_SYSH_prog_0_MAX_LAT 0x64
+#define REG_DC_PC_SYSH_prog_0_REQ_NUM 0x68
+#define REG_DC_PC_SYSH_prog_0_ACK_NUM 0x6C
+#define REG_DC_PC_SYSH_prog_1_ACK_NUM 0x7C
+#define REG_DC_PC_SYSH_prog_2_ACK_NUM 0x8C
+#define REG_DC_PC_SYSH_prog_3_ACK_NUM 0x51C
+#define ID_DC_VO1 0x0
+#define ID_DC_SCPU 0x20
+#define ID_DC_GPU 0x19
+#define ID_DC_VE1 0x30
+#define ID_DC_VE2 0x31
+#define VE2_DURATION_DEBUG 100 /* ms */
+
+#define REG_DMC_PC_GO_START 0xB00
+#define REG_DMC_PC_GO_CTRL 0xB04
+#define DMC_PC_CTRL 0x36
+#define DMC_PC_CPU_REQ_NUM 0x37
+#define DMC_PC_CPU_ACC_LAT 0x38
+#define DMC_PC_GPU_REQ_NUM 0x39
+#define DMC_PC_GPU_ACC_LAT 0x3a
+
+#define TYPE_DCSYS 0
+#define TYPE_DMC 1
+
+//------------------------------------------------------------------------------
+// common struct and definition
+//------------------------------------------------------------------------------
+/**
+* @brief
+@verbatim
+This is an enumeration for declaring codec standard type variables. Currently,
+VPU supports many different video standards such as H.265/HEVC, MPEG4 SP/ASP, H.263 Profile 3, H.264/AVC
+BP/MP/HP, VC1 SP/MP/AP, MPEG1, MPEG2, AVS, RealVideo 8/9/10, AVS Jizhun/Guangdian profile,
+ Theora, VP3, VP8, and VP9.
+
+NOTE: MPEG-1 decoder operation is handled as a special case of MPEG2 decoder.
+STD_THO must be always 9.
+@endverbatim
+*/
+typedef enum {
+	STD_AVC,
+	STD_VC1,
+	STD_MPEG2,
+	STD_MPEG4,
+	STD_H263,
+	STD_UNKNOWN3,
+	STD_RV,
+	STD_AVS,
+	STD_THO = 9,
+	STD_VP3,
+	STD_VP8,
+	STD_HEVC,
+	STD_VP9,
+	STD_AVS2,
+	STD_DOLBY_VISION,
+	STD_MAX
+} CodStd;
+
+/**
+* @brief
+@verbatim
+This is an enumeration for declaring SET_PARAM command options.
+Depending on this, SET_PARAM command parameter registers have different settings.
+
+NOTE: This is only for WAVE encoder IP.
+
+@endverbatim
+*/
+typedef enum {
+	OPT_COMMON = 0, /**< SET_PARAM command option for encoding sequence */
+	OPT_CUSTOM_GOP =
+		1, /**< SET_PARAM command option for setting custom GOP */
+	OPT_CUSTOM_HEADER =
+		2, /**< SET_PARAM command option for setting custom VPS/SPS/PPS */
+	OPT_VUI = 3, /**< SET_PARAM command option for encoding VUI  */
+	OPT_CHANGE_PARAM =
+		16 /**< SET_PARAM command option for parameters change (WAVE520 only)  */
+} SET_PARAM_OPTION;
+
+/**
+* @brief
+@verbatim
+This is an enumeration for declaring the operation mode of DEC_PIC_HDR command. (WAVE decoder only)
+
+@endverbatim
+*/
+typedef enum {
+	INIT_SEQ_NORMAL =
+		0x01, /**< It initializes some parameters (i.e. buffer mode) required for decoding sequence, performs sequence header, and returns information on the sequence. */
+	INIT_SEQ_W_THUMBNAIL =
+		0x11, /**< It decodes only the first I picture of sequence to get thumbnail. */
+} DEC_PIC_HDR_OPTION;
+
+/**
+* @brief
+@verbatim
+This is an enumeration for declaring the running option of DEC_PIC command. (WAVE decoder only)
+
+@endverbatim
+*/
+typedef enum {
+	DEC_PIC_NORMAL = 0x00, /**< It is normal mode of DEC_PIC command. */
+	DEC_PIC_W_THUMBNAIL =
+		0x10, /**< It handles CRA picture as BLA picture not to use reference from the previously decoded pictures. */
+	SKIP_NON_IRAP =
+		0x11, /**< It is thumbnail mode (skip non-IRAP without reference reg.) */
+	SKIP_NON_RECOVERY = 0x12, /**< It skips to decode non-IRAP pictures. */
+	SKIP_NON_REF_PIC =
+		0x13, /**< It skips to decode non-reference pictures which correspond to sub-layer non-reference picture with MAX_DEC_TEMP_ID. (The sub-layer non-reference picture is the one whose nal_unit_type equal to TRAIL_N, TSA_N, STSA_N, RADL_N, RASL_N, RSV_VCL_N10, RSV_VCL_N12, or RSV_VCL_N14. )*/
+	SKIP_TEMPORAL_LAYER =
+		0x14, /**< It decodes only frames whose temporal id is equal to or less than MAX_DEC_TEMP_ID. */
+} DEC_PIC_OPTION;
+
+/************************************************************************/
+/* Limitations                                                          */
+/************************************************************************/
+#define MAX_FRAMEBUFFER_COUNT 30 /* The 32nd framebuffer is reserved for WTL */
+
+/************************************************************************/
+/* PROFILE & LEVEL                                                      */
+/************************************************************************/
+/* HEVC */
+#define HEVC_PROFILE_MAIN 1
+#define HEVC_PROFILE_MAIN10 2
+#define HEVC_PROFILE_STILLPICTURE 3
+/* VP9 */
+#define VP9_PROFILE_0 0
+#define VP9_PROFILE_1 1
+#define VP9_PROFILE_2 2
+#define VP9_PROFILE_3 3
+/* Tier */
+#define HEVC_TIER_MAIN 0
+#define HEVC_TIER_HIGH 1
+/* Level */
+#define HEVC_LEVEL(_Major, _Minor) (_Major * 10 + _Minor)
+
+/* H.264 */
+#define H264_PROFILE_BASELINE 66
+#define H264_PROFILE_MAIN 77
+#define H264_PROFILE_EXTENDED 88
+#define H264_PROFILE_HIGH 100
+#define H264_PROFILE_HIGH10 110
+#define H264_PROFILE_HIGH10_INTRA 120
+#define H264_PROFILE_HIGH422 122
+#define H264_PROFILE_HIGH444 244
+#define H264_PROFILE_CAVLC_444_INTRA 44
+
+/* H265 USER_DATA(SPS & SEI) ENABLE FLAG */
+#define H265_USERDATA_FLAG_RESERVED_0 (0)
+#define H265_USERDATA_FLAG_RESERVED_1 (1)
+#define H265_USERDATA_FLAG_VUI (2)
+#define H265_USERDATA_FLAG_ALTERNATIVE_TRANSFER_CHARACTERISTICS (3)
+#define H265_USERDATA_FLAG_PIC_TIMING (4)
+#define H265_USERDATA_FLAG_ITU_T_T35_PRE                                       \
+	(5) /* SEI Prefix: user_data_registered_itu_t_t35 */
+#define H265_USERDATA_FLAG_UNREGISTERED_PRE                                    \
+	(6) /* SEI Prefix: user_data_unregistered */
+#define H265_USERDATA_FLAG_ITU_T_T35_SUF                                       \
+	(7) /* SEI Suffix: user_data_registered_itu_t_t35 */
+#define H265_USERDATA_FLAG_UNREGISTERED_SUF                                    \
+	(8) /* SEI Suffix: user_data_unregistered */
+#define H265_USERDATA_FLAG_RESERVED_9 (9) /* SEI RESERVED */
+#define H265_USERDATA_FLAG_MASTERING_COLOR_VOL                                 \
+	(10) /* SEI Prefix: mastering_display_color_volume */
+#define H265_USERDATA_FLAG_CHROMA_RESAMPLING_FILTER_HINT                       \
+	(11) /* SEI Prefix: chroma_resampling_filter_hint */
+#define H265_USERDATA_FLAG_KNEE_FUNCTION_INFO                                  \
+	(12) /* SEI Prefix: knee_function_info */
+#define H265_USERDATA_FLAG_TONE_MAPPING_INFO                                   \
+	(13) /* SEI Prefix: tone_mapping_info */
+#define H265_USER_DATA_FLAG_FILM_GRAIN_CHARACTERISTICS_INFO                    \
+	(14) /* SEI Prefix: film_grain_characteristics_info */
+#define H265_USER_DATA_FLAG_CONTENT_LIGHT_LEVEL_INFO                           \
+	(15) /* SEI Prefix: content_light_level_info */
+#define H265_USER_DATA_FLAG_COLOUR_REMAPPING_INFO                              \
+	(16) /* SEI Prefix: content_light_level_info */
+// SW-5517, rtk only, for using old TEE_API_HdrParse() interace and support both H265 and H264 user data parsing
+// so this value 27 can't be the same as any H265_USERDATA_FLAG_XXX or H265_USER_DATA_FLAG_XXX
+#define SPECIAL_H264_USERDATA_FLAG_RTK (27)
+#define H265_USERDATA_FLAG_ITU_T_T35_PRE_1                                     \
+	(28) /* SEI Prefix: additional user_data_registered_itu_t_t35 */
+#define H265_USERDATA_FLAG_ITU_T_T35_PRE_2                                     \
+	(29) /* SEI Prefix: additional user_data_registered_itu_t_t35 */
+#define H265_USERDATA_FLAG_ITU_T_T35_SUF_1                                     \
+	(30) /* SEI Suffix: additional user_data_registered_itu_t_t35 */
+#define H265_USERDATA_FLAG_ITU_T_T35_SUF_2                                     \
+	(31) /* SEI Suffix: additional user_data_registered_itu_t_t35 */
+
+/************************************************************************/
+/* Error codes                                                          */
+/************************************************************************/
+
+/**
+* @brief    This is an enumeration for declaring return codes from API function calls.
+The meaning of each return code is the same for all of the API functions, but the reasons of
+non-successful return might be different. Some details of those reasons are
+briefly described in the API definition chapter. In this chapter, the basic meaning
+of each return code is presented.
+*/
+typedef enum {
+	RETCODE_SUCCESS,
+	/**< This means that operation was done successfully.  */ /* 0  */
+	RETCODE_FAILURE, /**< This means that operation was not done successfully. When un-recoverable decoder error happens such as header parsing errors, this value is returned from VPU API.  */
+	RETCODE_INVALID_HANDLE, /**< This means that the given handle for the current API function call was invalid (for example, not initialized yet, improper function call for the given handle, etc.).  */
+	RETCODE_INVALID_PARAM, /**< This means that the given argument parameters (for example, input data structure) was invalid (not initialized yet or not valid anymore). */
+	RETCODE_INVALID_COMMAND, /**< This means that the given command was invalid (for example, undefined, or not allowed in the given instances).  */
+	RETCODE_ROTATOR_OUTPUT_NOT_SET,
+	/**< This means that rotator output buffer was not allocated even though postprocessor (rotation, mirroring, or deringing) is enabled. */ /* 5  */
+	RETCODE_ROTATOR_STRIDE_NOT_SET, /**< This means that rotator stride was not provided even though postprocessor (rotation, mirroring, or deringing) is enabled.  */
+	RETCODE_FRAME_NOT_COMPLETE, /**< This means that frame decoding operation was not completed yet, so the given API function call cannot be allowed.  */
+	RETCODE_INVALID_FRAME_BUFFER, /**< This means that the given source frame buffer pointers were invalid in encoder (not initialized yet or not valid anymore).  */
+	RETCODE_INSUFFICIENT_FRAME_BUFFERS, /**< This means that the given numbers of frame buffers were not enough for the operations of the given handle. This return code is only received when calling VPU_DecRegisterFrameBuffer() or VPU_EncRegisterFrameBuffer() function. */
+	RETCODE_INVALID_STRIDE,
+	/**< This means that the given stride was invalid (for example, 0, not a multiple of 8 or smaller than picture size). This return code is only allowed in API functions which set stride.  */ /* 10 */
+	RETCODE_WRONG_CALL_SEQUENCE, /**< This means that the current API function call was invalid considering the allowed sequences between API functions (for example, missing one crucial function call before this function call).  */
+	RETCODE_CALLED_BEFORE, /**< This means that multiple calls of the current API function for a given instance are invalid. */
+	RETCODE_NOT_INITIALIZED, /**< This means that VPU was not initialized yet. Before calling any API functions, the initialization API function, VPU_Init(), should be called at the beginning.  */
+	RETCODE_USERDATA_BUF_NOT_SET, /**< This means that there is no memory allocation for reporting userdata. Before setting user data enable, user data buffer address and size should be set with valid value. */
+	RETCODE_MEMORY_ACCESS_VIOLATION,
+	/**< This means that access violation to the protected memory has been occurred. */ /* 15 */
+	RETCODE_VPU_RESPONSE_TIMEOUT, /**< This means that VPU response time is too long, time out. */
+	RETCODE_INSUFFICIENT_RESOURCE, /**< This means that VPU cannot allocate memory due to lack of memory. */
+	RETCODE_NOT_FOUND_BITCODE_PATH, /**< This means that BIT_CODE_FILE_PATH has a wrong firmware path or firmware size is 0 when calling VPU_InitWithBitcode() function.  */
+	RETCODE_NOT_SUPPORTED_FEATURE, /**< This means that HOST application uses an API option that is not supported in current hardware.  */
+	RETCODE_NOT_FOUND_VPU_DEVICE,
+	/**< This means that HOST application uses the undefined product ID. */ /* 20 */
+	RETCODE_CP0_EXCEPTION, /**< This means that coprocessor exception has occurred. (WAVE only) */
+	RETCODE_STREAM_BUF_FULL, /**< This means that stream buffer is full in encoder. */
+	RETCODE_ACCESS_VIOLATION_HW, /**< This means that GDI access error has occurred. It might come from violation of write protection region or spec-out GDI read/write request. (WAVE only) */
+	RETCODE_QUERY_FAILURE, /**< This means that query command was not successful (WAVE5 only) */
+	RETCODE_QUEUEING_FAILURE, /**< This means that commands cannot be queued (WAVE5 only) */
+	RETCODE_VPU_STILL_RUNNING, /**< This means that VPU cannot be flushed or closed now. because VPU is running (WAVE5 only) */
+	RETCODE_REPORT_NOT_READY, /**< This means that report is not ready for Query(GET_RESULT) command (WAVE5 only) */
+} RetCode;
+
+/************************************************************************/
+/* Utility macros                                                       */
+/************************************************************************/
+#define VPU_ALIGN4(_x) (((_x) + 0x03) & ~0x03)
+#define VPU_ALIGN8(_x) (((_x) + 0x07) & ~0x07)
+#define VPU_ALIGN16(_x) (((_x) + 0x0f) & ~0x0f)
+#define VPU_ALIGN32(_x) (((_x) + 0x1f) & ~0x1f)
+#define VPU_ALIGN64(_x) (((_x) + 0x3f) & ~0x3f)
+#define VPU_ALIGN128(_x) (((_x) + 0x7f) & ~0x7f)
+#define VPU_ALIGN256(_x) (((_x) + 0xff) & ~0xff)
+#define VPU_ALIGN512(_x) (((_x) + 0x1ff) & ~0x1ff)
+#define VPU_ALIGN4096(_x) (((_x) + 0xfff) & ~0xfff)
+#define VPU_ALIGN16384(_x) (((_x) + 0x3fff) & ~0x3fff)
+
+/************************************************************************/
+/*                                                                      */
+/************************************************************************/
+#define INTERRUPT_TIMEOUT_VALUE (Uint32) - 1
+
+/**
+ * \brief   parameters of DEC_SET_SEQ_CHANGE_MASK
+ */
+#define SEQ_CHANGE_ENABLE_PROFILE (1 << 5)
+#define SEQ_CHANGE_ENABLE_SIZE (1 << 16)
+#define SEQ_CHANGE_ENABLE_BITDEPTH (1 << 18)
+#define SEQ_CHANGE_ENABLE_DPB_COUNT (1 << 19)
+
+#define SEQ_CHANGE_INTER_RES_CHANGE (1 << 17) /* VP9 */
+#define SEQ_CHANGE_ENABLE_ALL_VP9                                              \
+	(SEQ_CHANGE_ENABLE_PROFILE | SEQ_CHANGE_ENABLE_SIZE |                  \
+	 SEQ_CHANGE_INTER_RES_CHANGE | SEQ_CHANGE_ENABLE_BITDEPTH |            \
+	 SEQ_CHANGE_ENABLE_DPB_COUNT)
+
+#define SEQ_CHANGE_ENABLE_ALL_HEVC                                             \
+	(SEQ_CHANGE_ENABLE_PROFILE | SEQ_CHANGE_ENABLE_SIZE |                  \
+	 SEQ_CHANGE_ENABLE_BITDEPTH | SEQ_CHANGE_ENABLE_DPB_COUNT)
+
+#define DISPLAY_IDX_FLAG_SEQ_END -1
+#define DISPLAY_IDX_FLAG_NO_FB -3
+#define DECODED_IDX_FLAG_NO_FB -1
+#define DECODED_IDX_FLAG_SKIP -2
+#define RECON_IDX_FLAG_ENC_END -1
+#define RECON_IDX_FLAG_ENC_DELAY -2
+#define RECON_IDX_FLAG_HEADER_ONLY -3
+#define RECON_IDX_FLAG_CHANGE_PARAM -4
+
+#ifdef SUPPORT_ROI_50
+#define MAX_ROI_NUMBER 50
+#else
+#define MAX_ROI_NUMBER 10
+#endif
+
+/**
+* @brief    This is a special enumeration type for some configuration commands
+* which can be issued to VPU by HOST application. Most of these commands can be called occasionally,
+* not periodically for changing the configuration of decoder or encoder operation running on VPU.
+* Details of these commands are presented in <<vpuapi_h_VPU_DecGiveCommand>>.
+*/
+typedef enum {
+	ENABLE_ROTATION,
+	DISABLE_ROTATION,
+	ENABLE_MIRRORING,
+	DISABLE_MIRRORING,
+	SET_MIRROR_DIRECTION,
+	SET_ROTATION_ANGLE,
+	SET_ROTATOR_OUTPUT,
+	SET_ROTATOR_STRIDE,
+	DEC_GET_SEQ_INFO,
+	DEC_SET_SPS_RBSP,
+	DEC_SET_PPS_RBSP,
+	DEC_SET_SEQ_CHANGE_MASK,
+	ENABLE_DERING,
+	DISABLE_DERING,
+	SET_SEC_AXI,
+	SET_DRAM_CONFIG, //coda960 only
+	GET_DRAM_CONFIG, //coda960 only
+	ENABLE_AFBCE,
+	DISABLE_AFBCE,
+	ENABLE_REP_USERDATA,
+	DISABLE_REP_USERDATA,
+	SET_ADDR_REP_USERDATA,
+	SET_VIRT_ADDR_REP_USERDATA,
+	SET_SIZE_REP_USERDATA,
+	SET_USERDATA_REPORT_MODE,
+	SET_CACHE_CONFIG,
+	GET_TILEDMAP_CONFIG,
+	SET_LOW_DELAY_CONFIG,
+	GET_LOW_DELAY_OUTPUT,
+	SET_DECODE_FLUSH,
+	DEC_SET_FRAME_DELAY,
+	DEC_SET_WTL_FRAME_FORMAT,
+	DEC_SET_SEQ_INFO,
+	DEC_GET_FIELD_PIC_TYPE,
+	DEC_GET_DISPLAY_OUTPUT_INFO,
+	DEC_ENABLE_REORDER,
+	DEC_DISABLE_REORDER,
+	DEC_SET_AVC_ERROR_CONCEAL_MODE,
+	DEC_FREE_FRAME_BUFFER,
+	DEC_GET_FRAMEBUF_INFO,
+	DEC_RESET_FRAMEBUF_INFO,
+	ENABLE_DEC_THUMBNAIL_MODE,
+	DEC_SET_DISPLAY_FLAG,
+	DEC_GET_SCALER_INFO,
+	DEC_SET_SCALER_INFO,
+	DEC_SET_TARGET_TEMPORAL_ID, //!<< H.265 temporal scalability
+	DEC_SET_BWB_CUR_FRAME_IDX,
+	DEC_SET_FBC_CUR_FRAME_IDX,
+	DEC_SET_INTER_RES_INFO_ON,
+	DEC_SET_INTER_RES_INFO_OFF,
+	DEC_FREE_FBC_TABLE_BUFFER,
+	DEC_FREE_MV_BUFFER,
+	DEC_ALLOC_FBC_Y_TABLE_BUFFER,
+	DEC_ALLOC_FBC_C_TABLE_BUFFER,
+	DEC_ALLOC_MV_BUFFER,
+#ifdef SUPPORT_GET_NAL_START_POS
+	DEC_GET_NAL_START_POS,
+#endif
+	ENC_ADD_PPS,
+	ENC_SET_ACTIVE_PPS,
+	ENC_GET_ACTIVE_PPS,
+	//vpu put header stream to bitstream buffer
+	ENC_PUT_VIDEO_HEADER,
+	ENC_PUT_MP4_HEADER,
+	ENC_PUT_AVC_HEADER,
+	//host generate header bitstream
+	ENC_GET_VIDEO_HEADER,
+	ENC_SET_INTRA_MB_REFRESH_NUMBER,
+	ENC_ENABLE_HEC,
+	ENC_DISABLE_HEC,
+	ENC_SET_SLICE_INFO,
+	ENC_SET_GOP_NUMBER,
+	ENC_SET_INTRA_QP,
+	ENC_SET_BITRATE,
+	ENC_SET_FRAME_RATE,
+
+	ENC_SET_PARA_CHANGE,
+	ENABLE_LOGGING,
+	DISABLE_LOGGING,
+	DEC_GET_QUEUE_STATUS,
+	ENC_GET_BW_REPORT, // wave520 only
+
+	//RTK
+	DEC_SET_YTBL_ADDR,
+	DEC_SET_CTBL_ADDR,
+	DEC_SET_WTL_MODE,
+	DEC_SET_T2L_MODE,
+	ENC_SET_CROP_INFO,
+	CMD_END
+} CodecCommand;
+
+/**
+ * @brief   This is an enumeration type for representing error conceal modes. (H.264/AVC decoder only)
+ */
+typedef enum {
+	AVC_ERROR_CONCEAL_MODE_DEFAULT =
+		0, /**< basic error concealment and error concealment for missing reference frame, wrong frame_num syntax (default)  */
+	AVC_ERROR_CONCEAL_MODE_ENABLE_SELECTIVE_CONCEAL_MISSING_REFERENCE =
+		1, /**< error concealment - selective error concealment for missing reference frame */
+	AVC_ERROR_CONCEAL_MODE_DISABLE_CONCEAL_MISSING_REFERENCE =
+		2, /**< error concealment - disable error concealment for missing reference frame */
+	AVC_ERROR_CONCEAL_MODE_DISABLE_CONCEAL_WRONG_FRAME_NUM =
+		4, /**< error concealment - disable error concealment for wrong frame_num syntax */
+} AVCErrorConcealMode;
+
+/**
+ * @brief   This is an enumeration type for representing the way of writing chroma data in planar format of frame buffer.
+ */
+typedef enum {
+	CBCR_ORDER_NORMAL, /**< Cb data are written in Cb buffer, and Cr data are written in Cr buffer. */
+	CBCR_ORDER_REVERSED /**< Cr data are written in Cb buffer, and Cb data are written in Cr buffer. */
+} CbCrOrder;
+
+/**
+* @brief    This is an enumeration type for representing the mirroring direction.
+*/
+typedef enum {
+	MIRDIR_NONE,
+	MIRDIR_VER,
+	MIRDIR_HOR,
+	MIRDIR_HOR_VER
+} MirrorDirection;
+
+/**
+ * @brief   This is an enumeration type for representing chroma formats of the frame buffer and pixel formats in packed mode.
+ */
+typedef enum {
+	FORMAT_420 = 0, /* 8bit */
+	FORMAT_420_ARM = 0,
+	FORMAT_422, /* 8bit */
+	FORMAT_224, /* 8bit */
+	FORMAT_444, /* 8bit */
+	FORMAT_400, /* 8bit */
+
+	/* Little Endian Perspective     */
+	/*     | addr 0  | addr 1  |     */
+	FORMAT_420_P10_16BIT_LSB_ARM = 5,
+	FORMAT_420_P10_16BIT_MSB = 5, /* lsb | 00xxxxx |xxxxxxxx | msb */
+	FORMAT_420_P10_16BIT_LSB, /* lsb | xxxxxxx |xxxxxx00 | msb */
+	FORMAT_420_P10_32BIT_MSB, /* lsb |00xxxxxxxxxxxxxxxxxxxxxxxxxxx| msb */
+	FORMAT_420_P10_32BIT_LSB, /* lsb |xxxxxxxxxxxxxxxxxxxxxxxxxxx00| msb */
+
+	/* 4:2:2 packed format */
+	/* Little Endian Perspective     */
+	/*     | addr 0  | addr 1  |     */
+	FORMAT_422_P10_16BIT_MSB, /* lsb | 00xxxxx |xxxxxxxx | msb */
+	FORMAT_422_P10_16BIT_LSB, /* lsb | xxxxxxx |xxxxxx00 | msb */
+	FORMAT_422_P10_32BIT_MSB, /* lsb |00xxxxxxxxxxxxxxxxxxxxxxxxxxx| msb */
+	FORMAT_422_P10_32BIT_LSB, /* lsb |xxxxxxxxxxxxxxxxxxxxxxxxxxx00| msb */
+
+	FORMAT_YUYV, /**< 8bit packed format : Y0U0Y1V0 Y2U1Y3V1 ... */
+	FORMAT_YUYV_P10_16BIT_MSB,
+	/* lsb | 000000xxxxxxxxxx | msb */ /**< 10bit packed(YUYV) format(1Pixel=2Byte) */
+	FORMAT_YUYV_P10_16BIT_LSB,
+	/* lsb | xxxxxxxxxx000000 | msb */ /**< 10bit packed(YUYV) format(1Pixel=2Byte) */
+	FORMAT_YUYV_P10_32BIT_MSB,
+	/* lsb |00xxxxxxxxxxxxxxxxxxxxxxxxxxx| msb */ /**< 10bit packed(YUYV) format(3Pixel=4Byte) */
+	FORMAT_YUYV_P10_32BIT_LSB,
+	/* lsb |xxxxxxxxxxxxxxxxxxxxxxxxxxx00| msb */ /**< 10bit packed(YUYV) format(3Pixel=4Byte) */
+
+	FORMAT_YVYU, /**< 8bit packed format : Y0V0Y1U0 Y2V1Y3U1 ... */
+	FORMAT_YVYU_P10_16BIT_MSB,
+	/* lsb | 000000xxxxxxxxxx | msb */ /**< 10bit packed(YVYU) format(1Pixel=2Byte) */
+	FORMAT_YVYU_P10_16BIT_LSB,
+	/* lsb | xxxxxxxxxx000000 | msb */ /**< 10bit packed(YVYU) format(1Pixel=2Byte) */
+	FORMAT_YVYU_P10_32BIT_MSB,
+	/* lsb |00xxxxxxxxxxxxxxxxxxxxxxxxxxx| msb */ /**< 10bit packed(YVYU) format(3Pixel=4Byte) */
+	FORMAT_YVYU_P10_32BIT_LSB,
+	/* lsb |xxxxxxxxxxxxxxxxxxxxxxxxxxx00| msb */ /**< 10bit packed(YVYU) format(3Pixel=4Byte) */
+
+	FORMAT_UYVY, /**< 8bit packed format : U0Y0V0Y1 U1Y2V1Y3 ... */
+	FORMAT_UYVY_P10_16BIT_MSB,
+	/* lsb | 000000xxxxxxxxxx | msb */ /**< 10bit packed(UYVY) format(1Pixel=2Byte) */
+	FORMAT_UYVY_P10_16BIT_LSB,
+	/* lsb | 000000xxxxxxxxxx | msb */ /**< 10bit packed(UYVY) format(1Pixel=2Byte) */
+	FORMAT_UYVY_P10_32BIT_MSB,
+	/* lsb |00xxxxxxxxxxxxxxxxxxxxxxxxxxx| msb */ /**< 10bit packed(UYVY) format(3Pixel=4Byte) */
+	FORMAT_UYVY_P10_32BIT_LSB,
+	/* lsb |xxxxxxxxxxxxxxxxxxxxxxxxxxx00| msb */ /**< 10bit packed(UYVY) format(3Pixel=4Byte) */
+
+	FORMAT_VYUY, /**< 8bit packed format : V0Y0U0Y1 V1Y2U1Y3 ... */
+	FORMAT_VYUY_P10_16BIT_MSB,
+	/* lsb | 000000xxxxxxxxxx | msb */ /**< 10bit packed(VYUY) format(1Pixel=2Byte) */
+	FORMAT_VYUY_P10_16BIT_LSB,
+	/* lsb | xxxxxxxxxx000000 | msb */ /**< 10bit packed(VYUY) format(1Pixel=2Byte) */
+	FORMAT_VYUY_P10_32BIT_MSB,
+	/* lsb |00xxxxxxxxxxxxxxxxxxxxxxxxxxx| msb */ /**< 10bit packed(VYUY) format(3Pixel=4Byte) */
+	FORMAT_VYUY_P10_32BIT_LSB,
+	/* lsb |xxxxxxxxxxxxxxxxxxxxxxxxxxx00| msb */ /**< 10bit packed(VYUY) format(3Pixel=4Byte) */
+
+	FORMAT_MAX,
+} FrameBufferFormat;
+
+/**
+ * @brief   This is an enumeration type for representing output image formats of down scaler.
+ */
+typedef enum {
+	YUV_FORMAT_I420, /**< This format is a 420 planar format, which is described as forcc I420. */
+	YUV_FORMAT_NV12, /**< This format is a 420 semi-planar format with U and V interleaved, which is described as fourcc NV12. */
+	YUV_FORMAT_NV21, /**< This format is a 420 semi-planar format with V and U interleaved, which is described as fourcc NV21. */
+	YUV_FORMAT_I422, /**< This format is a 422 planar format, which is described as forcc I422. */
+	YUV_FORMAT_NV16, /**< This format is a 422 semi-planar format with U and V interleaved, which is described as fourcc NV16. */
+	YUV_FORMAT_NV61, /**< This format is a 422 semi-planar format with V and U interleaved, which is described as fourcc NV61. */
+	YUV_FORMAT_UYVY, /**< This format is a 422 packed mode with UYVY, which is described as fourcc UYVY. */
+	YUV_FORMAT_YUYV, /**< This format is a 422 packed mode with YUYV, which is described as fourcc YUYV. */
+} ScalerImageFormat;
+
+typedef enum {
+	NOT_PACKED = 0,
+	PACKED_YUYV,
+	PACKED_YVYU,
+	PACKED_UYVY,
+	PACKED_VYUY,
+} PackedFormatNum;
+
+/**
+* @brief    This is an enumeration type for representing interrupt bit positions for CODA series.
+*/
+typedef enum {
+	INT_BIT_INIT = 0,
+	INT_BIT_SEQ_INIT = 1,
+	INT_BIT_SEQ_END = 2,
+	INT_BIT_PIC_RUN = 3,
+	INT_BIT_FRAMEBUF_SET = 4,
+	INT_BIT_ENC_HEADER = 5,
+	INT_BIT_DEC_PARA_SET = 7,
+	INT_BIT_DEC_BUF_FLUSH = 8,
+	INT_BIT_USERDATA = 9,
+	INT_BIT_DEC_FIELD = 10,
+	INT_BIT_DEC_MB_ROWS = 13,
+	INT_BIT_BIT_BUF_EMPTY = 14,
+	INT_BIT_BIT_BUF_FULL = 15
+} InterruptBit;
+
+/* For backward compatibility */
+typedef InterruptBit Coda9InterruptBit;
+
+/**
+* @brief    This is an enumeration type for representing interrupt bit positions.
+
+NOTE: This is only for WAVE5 IP.
+*/
+typedef enum {
+	INT_WAVE5_INIT_VPU = 0,
+	INT_WAVE5_WAKEUP_VPU = 1,
+	INT_WAVE5_SLEEP_VPU = 2,
+	INT_WAVE5_CREATE_INSTANCE = 3,
+	INT_WAVE5_FLUSH_INSTANCE = 4,
+	INT_WAVE5_DESTORY_INSTANCE = 5,
+	INT_WAVE5_INIT_SEQ = 6,
+	INT_WAVE5_SET_FRAMEBUF = 7,
+	INT_WAVE5_DEC_PIC = 8,
+	INT_WAVE5_ENC_PIC = 8,
+	INT_WAVE5_ENC_SET_PARAM = 9,
+	INT_WAVE5_DEC_QUERY = 14,
+	INT_WAVE5_BSBUF_EMPTY = 15,
+	INT_WAVE5_BSBUF_FULL = 15,
+} Wave5InterruptBit;
+
+/**
+* @brief    This is an enumeration type for representing picture types.
+*/
+typedef enum {
+	PIC_TYPE_I = 0, /**< I picture */
+	PIC_TYPE_P = 1, /**< P picture */
+	PIC_TYPE_B = 2, /**< B picture (except VC1) */
+	PIC_TYPE_REPEAT = 2, /**< Repeat frame (VP9 only) */
+	PIC_TYPE_VC1_BI = 2, /**< VC1 BI picture (VC1 only) */
+	PIC_TYPE_VC1_B = 3, /**< VC1 B picture (VC1 only) */
+	PIC_TYPE_D =
+		3, /**< D picture in MPEG2 that is only composed of DC coefficients (MPEG2 only) */
+	PIC_TYPE_S =
+		3, /**< S picture in MPEG4 that is an acronym of Sprite and used for GMC (MPEG4 only)*/
+	PIC_TYPE_VC1_P_SKIP = 4, /**< VC1 P skip picture (VC1 only) */
+	PIC_TYPE_MP4_P_SKIP_NOT_CODED =
+		4, /**< Not Coded P Picture in mpeg4 packed mode */
+	PIC_TYPE_IDR = 5, /**< H.264/H.265 IDR picture */
+	PIC_TYPE_MAX /**< No Meaning */
+} PicType;
+
+/**
+* @brief    This is an enumeration type for H.264/AVC NPF (Non Paired Field) information.
+*/
+typedef enum {
+	PAIRED_FIELD = 0,
+	TOP_FIELD_MISSING = 1,
+	BOT_FIELD_MISSING = 2,
+} AvcNpfFieldInfo;
+
+/**
+* @brief    This is an enumeration type for specifying frame buffer types when tiled2linear or wtlEnable is used.
+*/
+typedef enum {
+	FF_NONE =
+		0, /**< Frame buffer type when tiled2linear or wtlEnable is disabled */
+	FF_FRAME = 1, /**< Frame buffer type to store one frame */
+	FF_FIELD =
+		2, /**< Frame buffer type to store top field or bottom field separately */
+} FrameFlag;
+
+/**
+ * @brief   This is an enumeration type for representing bitstream handling modes in decoder.
+ */
+typedef enum {
+	BS_MODE_INTERRUPT, /**< VPU returns an interrupt when bitstream buffer is empty while decoding. VPU waits for more bitstream to be filled. */
+	BS_MODE_ROLLBACK, /**< VPU tries to decode with very small amount of bitstream (not a complete 512-byte chunk). If it is not successful, VPU puts rdPtr back to the start in this mode. Host should give VPU DEC_PIC command again for the picture.  */
+	BS_MODE_PIC_END, /**< VPU tries to decode with very small amount of bitstream (not a complete 512-byte chunk). If it is not successful, VPU performs error concealment for the rest of the frame. */
+} BitStreamMode;
+
+/**
+ * @brief  This is an enumeration type for representing software reset options.
+ */
+typedef enum {
+	SW_RESET_SAFETY, /**< It resets VPU in safe way. It waits until pending bus transaction is completed and then perform reset. */
+	SW_RESET_FORCE, /**< It forces to reset VPU without waiting pending bus transaction to be completed. It is used for immediate termination such as system off. */
+	SW_RESET_ON_BOOT /**< This is the default reset mode that is executed since system booting.  This mode is actually executed in VPU_Init(), so does not have to be used independently. */
+} SWResetMode;
+
+/**
+ * @brief  This is an enumeration type for representing product IDs.
+ */
+typedef enum {
+	PRODUCT_ID_980,
+	PRODUCT_ID_960 = 1,
+	PRODUCT_ID_950 = 1, // same with CODA960
+	PRODUCT_ID_420L,
+	PRODUCT_ID_NONE,
+} ProductId;
+
+#define PRODUCT_ID_W_SERIES(x) (x == PRODUCT_ID_420L)
+#define PRODUCT_ID_NOT_W_SERIES(x) !PRODUCT_ID_W_SERIES(x)
+
+/**
+* @brief This is an enumeration type for representing map types for frame buffer.
+
+NOTE: Tiled maps are only for CODA9. Please find them in the CODA9 datasheet for detailed information.
+*/
+typedef enum {
+	/**
+    @verbatim
+    Linear frame map type
+
+    NOTE: Products earlier than CODA9 can only set this linear map type.
+    @endverbatim
+    */
+	LINEAR_FRAME_MAP = 0, /**< Linear frame map type */
+	TILED_FRAME_V_MAP =
+		1, /**< Tiled frame vertical map type (CODA9 only) */
+	TILED_FRAME_H_MAP =
+		2, /**< Tiled frame horizontal map type (CODA9 only) */
+	TILED_FIELD_V_MAP =
+		3, /**< Tiled field vertical map type (CODA9 only) */
+	TILED_MIXED_V_MAP =
+		4, /**< Tiled mixed vertical map type (CODA9 only) */
+	TILED_FRAME_MB_RASTER_MAP =
+		5, /**< Tiled frame MB raster map type (CODA9 only) */
+	TILED_FIELD_MB_RASTER_MAP =
+		6, /**< Tiled field MB raster map type (CODA9 only) */
+	TILED_FRAME_NO_BANK_MAP = 7,
+	/**< Tiled frame no bank map. (CODA9 only) */ // coda980 only
+	TILED_FIELD_NO_BANK_MAP = 8,
+	/**< Tiled field no bank map. (CODA9 only) */ // coda980 only
+	LINEAR_FIELD_MAP = 9,
+	/**< Linear field map type. (CODA9 only) */ // coda980 only
+	CODA_TILED_MAP_TYPE_MAX = 10,
+	COMPRESSED_FRAME_MAP = 10,
+	/**< Compressed frame map type (WAVE only) */ // WAVE4 only
+	ARM_COMPRESSED_FRAME_MAP = 11,
+	/**< AFBC(ARM Frame Buffer Compression) compressed frame map type */ // AFBC enabled WAVE decoder
+	TILED_MAP_TYPE_MAX
+} TiledMapType;
+
+/**
+* @brief    This is an enumeration for declaring a type of framebuffer that is allocated when VPU_DecAllocateFrameBuffer()
+and VPU_EncAllocateFrameBuffer() function call.
+*/
+typedef enum {
+	FB_TYPE_CODEC, /**< A framebuffer type used for decoding or encoding  */
+	FB_TYPE_PPU, /**< A framebuffer type used for additional allocation of framebuffer for postprocessing(rotation/mirror) or display (tiled2linear) purpose */
+} FramebufferAllocType;
+
+/**
+* @brief    This is for RTK debug
+*/
+typedef struct {
+	/* RTK DCSYS debug */
+	Uint32 dcsysVeAck;
+	Uint32 dcsysVeReq;
+	Uint32 dcsysVeLatency;
+	Uint32 dcsysScpuAck;
+	Uint32 dcsysGpuAck;
+	Uint32 dcsysVoAck;
+	Uint32 dcsysTotalAck;
+	Uint32 dmcCpuReq;
+	Uint32 dmcGpuReq;
+
+	/* for WAVE5 CQ */
+	Int32 duration;
+} RtkDcsysInfo;
+
+/**
+* @brief    This is data structure of product information. (WAVE only)
+*/
+typedef struct {
+	Uint32 productId; /**< The product id */
+	Uint32 fwVersion; /**< The firmware version */
+	Uint32 productName; /**< VPU hardware product name  */
+	Uint32 productVersion; /**< VPU hardware product version */
+	Uint32 customerId; /**< The customer id */
+	Uint32 stdDef0; /**< The system configuration information  */
+	Uint32 stdDef1; /**< The hardware configuration information  */
+	Uint32 confFeature; /**< The supported codec standard */
+	Uint32 configDate; /**< The date that the hardware has been configured in YYYYmmdd in digit */
+	Uint32 configRevision; /**< The revision number when the hardware has been configured */
+	Uint32 configType; /**< The define value used in hardware configuration */
+	Uint32 configVcore[4]; /**< VCORE Configuration Information */
+} ProductInfo;
+
+/**
+* @brief
+@verbatim
+This is a data structure of tiled map information.
+
+NOTE: WAVE4 does not support tiledmap type so this structure is not used in the product.
+@endverbatim
+*/
+typedef struct {
+	// gdi2.0
+	int xy2axiLumMap[32];
+	int xy2axiChrMap[32];
+	int xy2axiConfig;
+
+	// gdi1.0
+	int xy2caMap[16];
+	int xy2baMap[16];
+	int xy2raMap[16];
+	int rbc2axiMap[32];
+	int xy2rbcConfig;
+	unsigned long tiledBaseAddr;
+
+	// common
+	int mapType;
+	int productId;
+	int tbSeparateMap;
+	int topBotSplit;
+	int tiledMap;
+	int convLinear;
+} TiledMapConfig;
+
+/**
+* @brief    This is a data structure of DRAM information. (CODA960 and BODA950 only).
+VPUAPI sets default values for this structure.
+However, HOST application can configure if the default values are not associated with their DRAM
+    or desirable to change.
+*/
+typedef struct {
+	int rasBit; /**< This value is used for width of RAS bit. (13 on the CNM FPGA platform) */
+	int casBit; /**< This value is used for width of CAS bit. (9 on the CNM FPGA platform) */
+	int bankBit; /**< This value is used for width of BANK bit. (2 on the CNM FPGA platform) */
+	int busBit; /**< This value is used for width of system BUS bit. (3 on CNM FPGA platform) */
+} DRAMConfig;
+
+/**
+* @brief
+@verbatim
+This is a data structure for representing frame buffer information such as pointer of each YUV
+component, endian, map type, etc.
+
+All of the 3 component addresses must be aligned to AXI bus width.
+HOST application must allocate external SDRAM spaces for those components by using this data
+structure. For example, YCbCr 4:2:0, one pixel value
+of a component occupies one byte, so the frame data sizes of Cb and Cr buffer are 1/4 of Y buffer size.
+
+In case of CbCr interleave mode, Cb and Cr frame data are written to memory area started from bufCb address.
+Also, in case that the map type of frame buffer is a field type, the base addresses of frame buffer for bottom fields -
+bufYBot, bufCbBot and bufCrBot should be set separately.
+@endverbatim
+*/
+typedef struct {
+	PhysicalAddress
+		bufY; /**< It indicates the base address for Y component in the physical address space when linear map is used. It is the RAS base address for Y component when tiled map is used (CODA9). It is also compressed Y buffer or ARM compressed framebuffer (WAVE). */
+	PhysicalAddress
+		bufCb; /**< It indicates the base address for Cb component in the physical address space when linear map is used. It is the RAS base address for Cb component when tiled map is used (CODA9). It is also compressed CbCr buffer (WAVE) */
+	PhysicalAddress
+		bufCr; /**< It indicates the base address for Cr component in the physical address space when linear map is used. It is the RAS base address for Cr component when tiled map is used (CODA9). */
+	PhysicalAddress bufYBot;
+		/**< It indicates the base address for Y bottom field component in the physical address space when linear map is used. It is the RAS base address for Y bottom field component when tiled map is used (CODA980 only). */ // coda980 only
+	PhysicalAddress bufCbBot;
+		/**< It indicates the base address for Cb bottom field component in the physical address space when linear map is used. It is the RAS base address for Cb bottom field component when tiled map is used (CODA980 only). */ // coda980 only
+	PhysicalAddress bufCrBot;
+		/**< It indicates the base address for Cr bottom field component in the physical address space when linear map is used. It is the RAS base address for Cr bottom field component when tiled map is used (CODA980 only). */ // coda980 only
+	/**
+    @verbatim
+    It specifies a chroma interleave mode of frame buffer.
+
+    * 0 : CbCr data is written in their separate frame memory (chroma separate mode).
+    * 1 : CbCr data is interleaved in chroma memory (chroma interleave mode).
+    @endverbatim
+    */
+	int cbcrInterleave;
+	/**
+    @verbatim
+    It specifies the way chroma data is interleaved in the frame buffer, bufCb or bufCbBot.
+
+    @* 0 : CbCr data is interleaved in chroma memory (NV12).
+    @* 1 : CrCb data is interleaved in chroma memory (NV21).
+    @endverbatim
+    */
+	int nv21;
+	/**
+    @verbatim
+    It specifies endianess of frame buffer.
+
+    @* 0 : little endian format
+    @* 1 : big endian format
+    @* 2 : 32 bit little endian format
+    @* 3 : 32 bit big endian format
+    @* 16 ~ 31 : 128 bit endian format
+
+    NOTE: For setting specific values of 128 bit endiness, please refer to the 'WAVE Datasheet'.
+    @endverbatim
+    */
+	int endian;
+	int myIndex; /**< A frame buffer index to identify each frame buffer that is processed by VPU. */
+	int mapType; /**< A map type for GDI inferface or FBC (Frame Buffer Compression). NOTE: For detailed map types, please refer to <<vpuapi_h_TiledMapType>>. */
+	int stride; /**< A horizontal stride for given frame buffer */
+	int width; /**< A width for given frame buffer */
+	int height; /**< A height for given frame buffer */
+	int size; /**< A size for given frame buffer */
+	int lumaBitDepth; /**< Bit depth for luma component */
+	int chromaBitDepth; /**< Bit depth for chroma component  */
+	FrameBufferFormat format; /**< A YUV format of frame buffer */
+	int orgLumaBitDepth; /**< Bit depth of luma component to encode in AFBC format */
+	int orgChromaBitDepth; /**< Bit depth of chroma component to encode in AFBC format */
+	int lfEnable; /**< This variable reports whether a decoded frame has been loopfiltered or not. This information is used to derive a size of AFBC(ARM Frame Buffer Compression) stream. */
+	/**
+    @verbatim
+    It enables source frame data with long burst length to be loaded for reducing DMA latency (CODA9 encoder only).
+
+    @* 0 : disable the long-burst mode.
+    @* 1 : enable the long-burst mode.
+    @endverbatim
+    */
+	int sourceLBurstEn;
+	int srcBufState; /**< It indicates a status of each source buffer, whether the source buffer is used for encoding or not. */
+	int sequenceNo; /**< A sequence number that the frame belongs to. It increases by 1 every time a sequence changes in decoder.  */
+	int packedEnable; /**< It enables frames to be saved in YUV422 packed mode. */
+	/**
+    @verbatim
+
+    @* 00 : YUYV
+    @* 01 : UYVY
+    @* 10 : YVYU
+    @* 11 : VYUY
+    @endverbatim
+    */
+	int packedMode;
+	BOOL updateFbInfo; /**< If this is TRUE, VPU updates API-internal framebuffer information when any of the information is changed. */
+} FrameBuffer;
+
+/**
+* @brief    This is a data structure for representing framebuffer parameters.
+It is used when framebuffer allocation using VPU_DecAllocateFrameBuffer() or VPU_EncAllocateFrameBuffer().
+*/
+typedef struct {
+	int mapType; /**< <<vpuapi_h_TiledMapType>> */
+	int cbcrInterleave; /**< CbCr interleave mode of frame buffer  */
+	int nv21; /**< 1 : CrCb (NV21) , 0 : CbCr (NV12).  This is valid when cbcrInterleave is 1. */
+	FrameBufferFormat format; /**< <<vpuapi_h_FrameBufferFormat>>  */
+	int stride; /**< A stride value of frame buffer  */
+	int height; /**< A height of frame buffer  */
+	int size; /**< A size of frame buffer  */
+	int lumaBitDepth; /**< A bit-depth of luma sample */
+	int chromaBitDepth; /**< A bit-depth of chroma sample */
+	int endian; /**< An endianess of frame buffer  */
+	int num; /**< The number of frame buffer to allocate  */
+	int type; /**< <<vpuapi_h_FramebufferAllocType>>  */
+} FrameBufferAllocInfo;
+
+/**
+* @brief
+@verbatim
+This is a data structure for representing rectangular window information in a
+frame.
+
+In order to specify a display window (or display window after cropping), this structure is
+provided to HOST application. Each value means an offset from the start point of
+a frame and therefore, all variables have positive values.
+@endverbatim
+*/
+typedef struct {
+	Uint32 left; /**< A horizontal pixel offset of top-left corner of rectangle from (0, 0) */
+	Uint32 top; /**< A vertical pixel offset of top-left corner of rectangle from (0, 0) */
+	Uint32 right; /**< A horizontal pixel offset of bottom-right corner of rectangle from (0, 0) */
+	Uint32 bottom; /**< A vertical pixel offset of bottom-right corner of rectangle from (0, 0) */
+} VpuRect;
+
+//Theora specific display information
+/**
+* @brief    This is a data structure of picture size information. This structure is valid only for Theora decoding case.
+When HOST application allocates frame buffers and gets a displayable picture region, HOST application needs this information.
+*/
+typedef struct {
+	int frameWidth; /**< This value is used for width of frame buffer. */
+	int frameHeight; /**< This value is used for height of frame buffer. */
+	int picWidth; /**< This value is used for width of the displayable picture region. */
+	int picHeight; /**< This value is used for height of the displayable picture region. */
+	int picOffsetX; /**< This value is located at the lower-left corner of the displayable picture region. */
+	int picOffsetY; /**< This value is located at the lower-left corner of the displayable picture region. */
+} ThoScaleInfo;
+
+// VP8 specific display information
+/**
+* @brief    This is a data structure of picture upscaling information for post-processing out of decoding loop.
+This structure is valid only for VP8 decoding case and can never be used by VPU itself.
+If HOST application has an upsampling device, this information is useful for them.
+When the HOST application allocates a frame buffer, HOST application needs upscaled resolution derived by this information
+ to allocate enough (maximum) memory for variable resolution picture decoding.
+*/
+typedef struct {
+	/**
+    @verbatim
+    This is an upscaling factor for horizontal expansion.
+    The value could be 0 to 3, and meaning of each value is described in below table.
+
+    .Upsampling Ratio by Scale Factor
+    [separator="|", frame="all", grid="all"]
+    `50`50_70
+    h/vScaleFactor     | Upsampling Ratio
+    ________________________________________________________________________________
+    0                  |1
+    1                  |5/4
+    2                  |5/3
+    3                  |2/1
+    ________________________________________________________________________________
+
+    @endverbatim
+    */
+	unsigned hScaleFactor : 2;
+	unsigned vScaleFactor : 2; /**< This is an upscaling factor for vertical expansion. The value could be 0 to 3, meaning of each value is described in above table. */
+	unsigned picWidth : 14; /**< Picture width in units of sample */
+	unsigned picHeight : 14; /**< Picture height in units of sample */
+} Vp8ScaleInfo;
+
+typedef struct {
+	BOOL enScaler;
+	Uint32 scaleWidth;
+	Uint32 scaleHeight;
+} ScalerInfo;
+
+/**
+* @brief    The data structure to enable low delay decoding.
+*/
+typedef struct {
+	/**
+    @verbatim
+    This enables low delay decoding. (CODA980 H.264/AVC decoder only)
+
+    If this flag is 1, VPU sends an interrupt to HOST application when numRows decoding is done.
+
+    * 0 : disable
+    * 1 : enable
+
+    When this field is enabled, reorderEnable, tiled2LinearEnable, and the post-rotator should be disabled.
+    @endverbatim
+    */
+	int lowDelayEn;
+	/**
+    @verbatim
+    This field indicates the number of mb rows (macroblock unit).
+
+    The value is from 1 to height/16 - 1.
+    If the value of this field is 0 or picture height/16, low delay decoding is disabled even though lowDelayEn is 1.
+    @endverbatim
+    */
+	int numRows;
+} LowDelayInfo;
+
+/**
+* @brief    This is a data structure for representing use of secondary AXI for each hardware block.
+*/
+typedef struct {
+	union {
+		struct {
+			int useBitEnable; /**<  This enables AXI secondary channel for prediction data of the BIT-processor. */
+			int useIpEnable; /**<  This enables AXI secondary channel for row pixel data of IP.  */
+			int useDbkYEnable; /**<  This enables AXI secondary channel for temporal luminance data of the de-blocking filter. */
+			int useDbkCEnable; /**<  This enables AXI secondary channel for temporal chrominance data of the de-blocking filter.  */
+			int useOvlEnable; /**<   This enables AXI secondary channel for temporal data of the the overlap filter (VC1 only). */
+			int useBtpEnable; /**<  This enables AXI secondary channel for bit-plane data of the BIT-processor (VC1 only).  */
+		} coda9;
+	} u;
+} SecAxiUse;
+
+// For MaverickCache1
+/**
+* @brief    This is a data structure for representing cache rectangle area for each component of MC reference frame. (CODA9 only)
+*/
+typedef struct {
+	unsigned BufferSize : 8; /**< This is the cache buffer size for each component and can be set with 0 to 255. The unit of this value is fixed with 256byte. */
+	unsigned PageSizeX : 4; /**< This is the cache page size and can be set as 0 to 4. With this value(n), 8*(2^n) byte is requested as the width of a page. */
+	unsigned PageSizeY : 4; /**< This is the cache page size and can be set as 0 to 7. With this value(m), a page width*(2^m) byte is requested as the rectangle of a page.*/
+	unsigned CacheSizeX : 4; /**< This is the component data cache size, and it can be set as 0 to 7 in a page unit. Then there can be 2^n pages in x(y)-direction. Make sure that for luma component the CacheSizeX + CacheSizeY must be less than 8. For chroma components, CacheSizeX + CacheSizeY must be less than 7. */
+	unsigned CacheSizeY : 4; /**< This is the component data cache size, and it can be set as 0 to 7 in a page unit. Then there can be 2^n pages in x(y)-direction. Make sure that for luma component the CacheSizeX + CacheSizeY must be less than 8. For chroma components, CacheSizeX + CacheSizeY must be less than 7. */
+	unsigned Reserved : 8;
+} CacheSizeCfg;
+
+/**
+* @brief    This is a data structure for cache configuration. (CODA9 only)
+*/
+typedef struct {
+	struct {
+		union {
+			Uint32 word;
+			CacheSizeCfg cfg; /**< <<vpuapi_h_CacheSizeCfg>> */
+		} luma;
+		union {
+			Uint32 word;
+			CacheSizeCfg cfg; /**< <<vpuapi_h_CacheSizeCfg>> */
+		} chroma;
+		/**
+        @verbatim
+        It disables cache function.
+
+        @* 1 : Cache off
+        @* 0 : Cache on
+        @endverbatim
+        */
+		unsigned Bypass : 1;
+		/**
+        @verbatim
+        It enables two frame caching mode.
+
+        @* 1 : Dual mode (caching for FrameIndex0 and FrameIndex1)
+        @* 0 : Single mode (caching for FrameIndex0)
+        @endverbatim
+        */
+		unsigned DualConf : 1;
+		/**
+        @verbatim
+        Mode for page merging
+
+        @* 0 : Disable
+        @* 1 : Horizontal
+        @* 2 : Vertical
+
+        We recommend you to set 1 (horizontal) in tiled map or to set 2 (vertical) in linear map.
+        @endverbatim
+        */
+		unsigned PageMerge : 2;
+	} type1;
+	struct {
+		/**
+        @verbatim
+        CacheMode represents cache configuration.
+
+        @* [10:9] : Cache line processing direction and merge mode
+        @* [8:5] : CacheWayShape
+        @** [8:7] : CacheWayLuma
+        @** [6:5] : CacheWayChroma
+        @* [4] reserved
+        @* [3] CacheBurstMode
+        @** 0: burst 4
+        @** 1: bust 8
+        @* [2] CacheMapType
+        @** 0: linear
+        @** 1: tiled
+        @* [1] CacheBypassME
+        @** 0: Cache enable
+        @** 1: Cache disable (bypass)
+        @* [0] CacheBypassMC
+        @** 0: Cache enable
+        @** 1: Cache disable (bypass)
+        @endverbatim
+        */
+		unsigned int CacheMode;
+	} type2;
+} MaverickCacheConfig;
+
+/**
+* @brief    This structure is used when HOST application additionally wants to send SPS data
+or PPS data from external way. The resulting SPS data or PPS data can be used in
+real applications as a kind of out-of-band information.
+*/
+typedef struct {
+	Uint32 *paraSet; /**< The SPS/PPS rbsp data */
+	int size; /**< The size of stream in byte */
+} DecParamSet;
+
+/**
+* @brief    This is an enumeration for declaring memory regions for protecting memory when decoding process.
+*/
+typedef enum {
+	WPROT_DEC_TEMP,
+	WPROT_DEC_WORK,
+	WPROT_DEC_PIC_SAVE,
+	WPROT_DEC_USER = WPROT_DEC_PIC_SAVE,
+	WPROT_DEC_REPORT,
+	WPROT_DEC_FRAME,
+	WPROT_DEC_SEC_AXI,
+	WPROT_DEC_EXT_1,
+	WPROT_DEC_EXT_2,
+	WPROT_DEC_EXT_3,
+	WPROT_DEC_EXT_4,
+	WPROT_DEC_MAX = 10
+} WriteMemProtectDecType;
+
+/**
+* @brief    This is an enumeration for declaring memory regions for protecting memory when encoding process.
+*/
+typedef enum {
+	WPROT_ENC_TEMP,
+	WPROT_ENC_WORK,
+	WPROT_ENC_BITSTREAM,
+	WPROT_ENC_SCRATCH,
+	WPROT_ENC_FRAME,
+	WPROT_ENC_SEC_AXI,
+	WPROT_ENC_EXT_1,
+	WPROT_ENC_EXT_2,
+	WPROT_ENC_EXT_3,
+	WPROT_ENC_EXT_4,
+	WPROT_ENC_MAX = 10
+} WriteMemProtectEncType;
+
+/**
+* @brief    This is a data structure for representing a write-memory protection region
+*/
+typedef struct {
+	/**
+@verbatim
+This enables write-memory protection for this region.
+
+When regions whose secondary flag Rgn#Sec is 1 and their Rgn#En are all 0 (disabled),
+write memory protection over all the secondary channels are turned off.
+In the similar way, when regions whose secondary flag Rgn#Sec is 0 and their Rgn#En are all 0 (disabled),
+write memory protection over all the primary channels are turned off.
+For example, write protection regions are configured as follows.
+
+@* Region0: Rgn0En=0 Rgn0Sec=0
+@* Region1: Rgn1En=0 Rgn1Sec=0
+@* Region2: Rgn2En=0 Rgn2Sec=0
+@* Region3: Rgn3En=1 Rgn3Sec=1
+@* Region4: Rgn4En=1 Rgn4Sec=1
+@* Region5: Rgn5En=0 Rgn5Sec=1
+
+Then the above setting makes all the primary channels turn off write protection function,
+whereas it makes the secondary channels turn on.
+@endverbatim
+*/
+	int enable;
+	int isSecondary; /**< 0 represents AXI primary channel and 1 represents AXI secondary channel. */
+	PhysicalAddress
+		startAddress; /**< This is the start address of this region. */
+	PhysicalAddress
+		endAddress; /**< This is the end address of this region. */
+} WriteMemProtectRegion;
+
+/**
+* @brief    This is a data structure for representing the whole write-memory protection regions.
+*/
+typedef struct {
+	Uint32 numOfRegion;
+	WriteMemProtectRegion decRegion
+		[WPROT_DEC_MAX]; /**< This is 6 write-memory protection regions. Refer to <<vpuapi_h_WriteMemProtectDecType>>. */
+	WriteMemProtectRegion encRegion
+		[WPROT_ENC_MAX]; /**< This is 5 write-memory protection regions. Refer to <<vpuapi_h_WriteMemProtectEncType>>. */
+} WriteMemProtectCfg;
+
+struct CodecInst;
+
+//------------------------------------------------------------------------------
+// decode struct and definition
+//------------------------------------------------------------------------------
+
+#define VPU_HANDLE_INSTANCE_NO(_handle) (_handle->instIndex)
+#define VPU_HANDLE_CORE_INDEX(_handle) (((CodecInst *)_handle)->coreIdx)
+#define VPU_HANDLE_PRODUCT_ID(_handle) (((CodecInst *)_handle)->productId)
+#define VPU_CONVERT_WTL_INDEX(_handle, _index)                                 \
+	((((CodecInst *)_handle)->CodecInfo->decInfo).numFbsForDecoding +      \
+	 _index)
+#define VPU_HANDLE_TO_DECINFO(_handle)                                         \
+	(&(((CodecInst *)_handle)->CodecInfo->decInfo))
+#define VPU_HANDLE_TO_ENCINFO(_handle)                                         \
+	(&(((CodecInst *)_handle)->CodecInfo->encInfo))
+/**
+* @brief
+@verbatim
+This is a dedicated type for handle returned when a decoder instance or a encoder instance is
+opened.
+
+@endverbatim
+*/
+typedef struct CodecInst *VpuHandle;
+
+/**
+* @brief
+@verbatim
+This is a dedicated type for decoder handle returned when a decoder instance is
+opened. A decoder instance can be referred to by the corresponding handle. CodecInst
+is a type managed internally by API. Application does not need to care about it.
+
+NOTE: This type is vaild for decoder only.
+@endverbatim
+*/
+typedef struct CodecInst *DecHandle;
+
+/**
+* @brief    This is a data structure for H.264/AVC specific picture information. Only H.264/AVC decoder
+returns this structure after decoding a frame. For details about all these
+flags, please find them in H.264/AVC VUI syntax.
+*/
+typedef struct {
+	/**
+    @verbatim
+    @* 1 : It indicates that the temporal distance between the decoder output times of any
+    two consecutive pictures in output order is constrained as fixed_frame_rate_flag
+    in H.264/AVC VUI syntax.
+    @* 0 : It indicates that no such constraints apply to the temporal distance between
+    the decoder output times of any two consecutive pictures in output order
+    @endverbatim
+    */
+	int fixedFrameRateFlag;
+	/**
+    @verbatim
+    timing_info_present_flag in H.264/AVC VUI syntax
+
+    @* 1 : FixedFrameRateFlag is valid.
+    @* 0 : FixedFrameRateFlag is not valid.
+    @endverbatim
+    */
+	int timingInfoPresent;
+	int chromaLocBotField; /**< chroma_sample_loc_type_bottom_field in H.264/AVC VUI syntax. It specifies the location of chroma samples for the bottom field. */
+	int chromaLocTopField; /**< chroma_sample_loc_type_top_field in H.264/AVC VUI syntax. It specifiesf the location of chroma samples for the top field. */
+	int chromaLocInfoPresent; /**< chroma_loc_info_present_flag in H.264/AVC VUI syntax. */
+	/**
+    @verbatim
+    chroma_loc_info_present_flag in H.264/AVC VUI syntax
+
+    @* 1 : ChromaSampleLocTypeTopField and ChromaSampleLoc TypeTopField are valid.
+    @* 0 : ChromaSampleLocTypeTopField and ChromaSampleLoc TypeTopField are not valid.
+    @endverbatim
+    */
+	int colorPrimaries; /**< colour_primaries syntax in VUI parameter in H.264/AVC */
+	int colorDescPresent; /**< colour_description_present_flag in VUI parameter in H.264/AVC */
+	int isExtSAR; /**< This flag indicates whether aspectRateInfo represents 8bit aspect_ratio_idc or 32bit extended_SAR. If the aspect_ratio_idc is extended_SAR mode, this flag returns 1. */
+	int vidFullRange; /**< video_full_range in VUI parameter in H.264/AVC */
+	int vidFormat; /**< video_format in VUI parameter in H.264/AVC */
+	int vidSigTypePresent; /**< video_signal_type_present_flag in VUI parameter in H.264/AVC */
+	int vuiParamPresent; /**< vui_parameters_present_flag in VUI parameter in H.264/AVC */
+	int vuiPicStructPresent; /**< pic_struct_present_flag of VUI in H.264/AVC. This field is valid only for H.264/AVC decoding. */
+	int vuiPicStruct; /**< pic_struct in H.264/AVC VUI reporting (Table D-1 in H.264/AVC specification) */
+	int vuiTransferCharacteristics; /**< transfer_characteristics in VUI parameter in H.264/AVC */
+	int vuiMatrixCoefficients; /**< matrix_coefficients in VUI parameter in H.264/AVC */
+} AvcVuiInfo;
+
+/**
+* @brief    This is a data structure for bar information of MPEG2 user data.
+For more details on this, please refer to 'ATSC Digital Television Standard: Part 4:2009'.
+*/
+
+typedef struct {
+	/**
+    @verbatim
+    A 14-bit unsigned integer value representing the last horizontal
+    luminance sample of a vertical pillarbox bar area at the left side of the reconstructed frame.
+    Pixels shall be numbered from zero, starting with the leftmost pixel.
+
+    This variable is initialized to -1.
+    @endverbatim
+    */
+	int barLeft;
+	/**
+    @verbatim
+    A 14-bit unsigned integer value representing the first horizontal
+    luminance sample of a vertical pillarbox bar area at the right side of the reconstructed frame.
+    Pixels shall be numbered from zero, starting with the leftmost pixel.
+
+    This variable is initialized to -1.
+    @endverbatim
+    */
+	int barRight;
+	/**
+    @verbatim
+    A 14-bit unsigned integer value representing the first line of a
+    horizontal letterbox bar area at the top of the reconstructed frame. Designation of line
+    numbers shall be as defined per each applicable standard in Table 6.9.
+
+    This variable is initialized to -1.
+    @endverbatim
+    */
+	int barTop;
+	/**
+    @verbatim
+    A 14-bit unsigned integer value representing the first line of a
+    horizontal letterbox bar area at the bottom of the reconstructed frame. Designation of line
+    numbers shall be as defined per each applicable standard in Table 6.9.
+
+    This variable is initialized to -1.
+    @endverbatim
+    */
+	int barBottom;
+} MP2BarDataInfo;
+
+/**
+* @brief
+@verbatim
+This is a data structure for MP2PicDispExtInfo.
+
+NOTE: For detailed information on these fields,
+please refer to the MPEG2 standard specification.
+@endverbatim
+*/
+typedef struct {
+	Uint32 offsetNum; /**< This is number of frame_centre_offset with a range of 0 to 3, inclusive. */
+	Int16 horizontalOffset1; /**< A horizontal offset of display rectangle in units of 1/16th sample */
+	Int16 horizontalOffset2; /**< A horizontal offset of display rectangle in units of 1/16th sample */
+	Int16 horizontalOffset3; /**< A horizontal offset of display rectangle in units of 1/16th sample */
+
+	Int16 verticalOffset1; /**< A vertical offset of display rectangle in units of 1/16th sample */
+	Int16 verticalOffset2; /**< A vertical offset of display rectangle in units of 1/16th sample */
+	Int16 verticalOffset3; /**< A vertical offset of display rectangle in units of 1/16th sample */
+} MP2PicDispExtInfo;
+
+#define FBC_MODE_BEST_PREDICTION                                               \
+	0x00 //!<< Best for bandwidth, some performance overhead
+#define FBC_MODE_NORMAL_PREDICTION 0x0c //!<< Good for badnwidth and performance
+#define FBC_MODE_BASIC_PREDICTION 0x3c //!<< Best for performance
+
+/**
+* @brief    This data structure is a group of common decoder parameters to run VPU with a new decoding instance.
+This is used when HOST application calls VPU_Decopen().
+*/
+typedef struct {
+	CodStd bitstreamFormat; /**< A standard type of bitstream in decoder operation. It is one of codec standards defined in CodStd. */
+	PhysicalAddress
+		bitstreamBuffer; /**< The start address of bitstream buffer from which the decoder can get the next bitstream. This address must be aligned to AXI bus width. */
+	int bitstreamBufferSize; /**< The size of the buffer pointed by bitstreamBuffer in byte. This value must be a multiple of 1024.  */
+	/**
+    @verbatim
+    @* 0 : disable
+    @* 1 : enable
+
+    When this field is set in case of MPEG4, H.263 (post-processing), MPEG2 decoding,
+    VPU generates MPEG4 deblocking filtered output.
+    @endverbatim
+    */
+	int mp4DeblkEnable;
+	/**
+    @verbatim
+    @* 0 : No extension of H.264/AVC
+    @* 1 : MVC extension of H.264/AVC
+    @endverbatim
+    */
+	int avcExtension;
+	/**
+    @verbatim
+
+    @* 0 : MPEG4
+    @* 2 : Xvid
+    @* 6 : old Xvid
+    @* 256 : Sorenson Spark
+
+    NOTE: This variable is only valid when decoding MPEG4 stream.
+    @endverbatim
+    */
+	int mp4Class;
+	int tiled2LinearEnable; /**< It enables a tiled to linear map conversion feature for display. */
+	/**
+    @verbatim
+    It specifies which picture type is converted to. (CODA980 only)
+
+    @* 1 : conversion to linear frame map (when FrameFlag enum is FF_FRAME)
+    @* 2 : conversion to linear field map (when FrameFlag enum is FF_FIELD)
+
+    @endverbatim
+    */
+	int tiled2LinearMode;
+	/**
+    @verbatim
+    It enables WTL (Write Linear) function. If this field is enabled,
+    VPU writes a decoded frame to the frame buffer twice - first in linear map and second in tiled or compressed map.
+    Therefore, HOST application should allocate one more frame buffer for saving both formats of frame buffers.
+
+    @endverbatim
+    */
+	int wtlEnable;
+	/**
+    @verbatim
+    It specifies whether VPU writes in frame linear map or in field linear map when WTL is enabled. (CODA980 only)
+
+    @* 1 : write decoded frames in frame linear map (when FrameFlag enum is FF_FRAME)
+    @* 2 : write decoded frames in field linear map (when FrameFlag enum is FF_FIELD)
+
+    @endverbatim
+    */
+	int wtlMode;
+	/**
+    @verbatim
+    @* 0 : CbCr data is written in separate frame memories (chroma separate mode)
+    @* 1 : CbCr data is interleaved in chroma memory. (chroma interleave mode)
+    @endverbatim
+    */
+	int cbcrInterleave;
+	/**
+    @verbatim
+    CrCb interleaved mode (NV21).
+
+    @* 0 : Decoded chroma data is written in CbCr (NV12) format.
+    @* 1 : Decoded chroma data is written in CrCb (NV21) format.
+
+    This is only valid if cbcrInterleave is 1.
+    @endverbatim
+    */
+	int nv21;
+	/**
+    @verbatim
+    CbCr order in planar mode (YV12 format)
+
+    @* 0 : Cb data are written first and then Cr written in their separate plane.
+    @* 1 : Cr data are written first and then Cb written in their separate plane.
+    @endverbatim
+    */
+	int cbcrOrder;
+	/**
+    @verbatim
+    It writes output with 8 burst in linear map mode. (CODA9 only)
+
+    @* 0 : burst write back is disabled
+    @* 1 : burst write back is enabled.
+
+    @endverbatim
+    */
+	int bwbEnable;
+	/**
+    @verbatim
+    Frame buffer endianness
+
+    @* 0 : little endian format
+    @* 1 : big endian format
+    @* 2 : 32 bit little endian format
+    @* 3 : 32 bit big endian format
+    @* 16 ~ 31 : 128 bit endian format
+
+    NOTE: For setting specific values of 128 bit endiness, please refer to the 'WAVE Datasheet'.
+    @endverbatim
+    */
+	EndianMode frameEndian;
+	/**
+    @verbatim
+    Bitstream buffer endianess
+
+    @* 0 : little endian format
+    @* 1 : big endian format
+    @* 2 : 32 bits little endian format
+    @* 3 : 32 bits big endian format
+    @* 16 ~ 31 : 128 bit endian format
+
+    NOTE: For setting specific values of 128 bit endiness, please refer to the 'WAVE Datasheet'.
+    @endverbatim
+    */
+	EndianMode streamEndian;
+	/**
+    @verbatim
+    When read pointer reaches write pointer in the middle of decoding one picture,
+
+    @* 0 : VPU sends an interrupt to HOST application and waits for more bitstream to decode. (interrupt mode)
+    @* 1 : Reserved
+    @* 2 : VPU decodes bitstream from read pointer to write pointer. (PicEnd mode)
+    @endverbatim
+    */
+	int bitstreamMode;
+	Uint32 coreIdx; /**< VPU core index number (0 ~ [number of VPU core] - 1) */
+	/**
+    BIT processor work buffer SDRAM address/size information. In parallel decoding operation, work buffer is shared between VPU cores.
+    The work buffer address is set to this member variable when VPU_Decopen() is called.
+    Unless HOST application sets the address and size of work buffer, VPU allocates automatically work buffer
+    when VPU_DecOpen() is executed.
+    */
+	vpu_buffer_t vbWork;
+	/**
+    @verbatim
+    It determines prediction mode of frame buffer compression.
+
+    @* 0x00 : Best Predection (best for bandwidth, but some performance overhead might exist)
+    @* 0x0C : Normal Prediction (good for bandwidth and performance)
+    @* 0x3C : Basic Predcition (best for performance)
+    @endverbatim
+    */
+	int fbc_mode;
+	Uint32 virtAxiID; /**< AXI_ID to distinguish guest OS. For virtualization only. Set this value in highest bit order.*/
+	BOOL bwOptimization; /**< Bandwidth optimization feature which allows WTL(Write to Linear)-enabled VPU to skip writing compressed format of non-reference pictures or linear format of non-display pictures to the frame buffer for BW saving reason. */
+	int afbceEnable; /**< This field enables VPU to generate AFBC(Arm Frame Buffer Compression) format of decoded frames. */
+	Int32 afbceFormat; /**< This field specifies FrameBufferFormat to be encoded in AFBC format.  */
+
+	//ENABLE_TEE_DRM_FLOW //For RTK DRM flow
+	Uint32 isUseProtectBuffer;
+	void *sess;
+	void *rtk_sess;
+
+	Uint32 enableDcsysDebug;
+	void *filp; // rtk, rtd16xxb_vdi_ioctl_open_instance() need this filp
+	Uint32 frameWidth;
+	Uint32 frameHeight;
+} DecOpenParam;
+
+/**
+* @brief Data structure to get information necessary to start decoding from the decoder.
+*/
+
+typedef struct {
+	/**
+    @verbatim
+    Horizontal picture size in pixel
+
+    This width value is used while allocating decoder frame buffers. In some
+    cases, this returned value, the display picture width declared on stream header,
+    should be aligned to a specific value depending on product and video standard before allocating frame buffers.
+    @endverbatim
+    */
+	Int32 picWidth;
+	/**
+    @verbatim
+    Vertical picture size in pixel
+
+    This height value is used while allocating decoder frame buffers.
+    In some cases, this returned value, the display picture height declared on stream header,
+    should be aligned to a specific value depending on product and video standard before allocating frame buffers.
+    @endverbatim
+    */
+	Int32 picHeight;
+
+	/**
+    @verbatim
+    The numerator part of frame rate fraction
+
+    NOTE: The meaning of this flag can vary by codec standards.
+    For details about this,
+    please refer to 'Appendix: FRAME RATE NUMERATORS in programmer\'s guide'.
+    @endverbatim
+    */
+	Int32 fRateNumerator;
+	/**
+    @verbatim
+    The denominator part of frame rate fraction
+
+    NOTE: The meaning of this flag can vary by codec standards.
+    For details about this,
+    please refer to 'Appendix: FRAME RATE DENOMINATORS in programmer\'s guide'.
+    @endverbatim
+    */
+	Int32 fRateDenominator;
+	/**
+    @verbatim
+    Picture cropping rectangle information (H.264/H.265/AVS decoder only)
+
+    This structure specifies the cropping rectangle information.
+    The size and position of cropping window in full frame buffer is presented
+    by using this structure.
+    @endverbatim
+    */
+	VpuRect picCropRect;
+	Int32 mp4DataPartitionEnable; /**< data_partitioned syntax value in MPEG4 VOL header */
+	Int32 mp4ReversibleVlcEnable; /**< reversible_vlc syntax value in MPEG4 VOL header */
+	/**
+    @verbatim
+    @* 0 : not h.263 stream
+    @* 1 : h.263 stream(mpeg4 short video header)
+    @endverbatim
+    */
+	Int32 mp4ShortVideoHeader;
+	/**
+    @verbatim
+    @* 0 : Annex J disabled
+    @* 1 : Annex J (optional deblocking filter mode) enabled
+    @endverbatim
+    */
+	Int32 h263AnnexJEnable;
+	Int32 minFrameBufferCount; /**< This is the minimum number of frame buffers required for decoding. Applications must allocate at least as many as this number of frame buffers and register the number of buffers to VPU using VPU_DecRegisterFrameBuffer() before decoding pictures. */
+	Int32 frameBufDelay; /**< This is the maximum display frame buffer delay for buffering decoded picture reorder. VPU may delay decoded picture display for display reordering when H.264/H.265, pic_order_cnt_type 0 or 1 case and for B-frame handling in VC1 decoder. */
+	Int32 normalSliceSize; /**< This is the recommended size of buffer used to save slice in normal case. This value is determined by quarter of the memory size for one raw YUV image in KB unit. This is only for H.264. */
+	Int32 worstSliceSize; /**< This is the recommended size of buffer used to save slice in worst case. This value is determined by half of the memory size for one raw YUV image in KB unit. This is only for H.264. */
+
+	// Report Information
+	Int32 maxSubLayers; /**< Number of sub-layer for H.265/HEVC */
+	/**
+    @verbatim
+    @* H.265/H.264 : profile_idc
+    @* VC1
+    @** 0 : Simple profile
+    @** 1 : Main profile
+    @** 2 : Advanced profile
+    @* MPEG2
+    @** 3\'b101 : Simple
+    @** 3\'b100 : Main
+    @** 3\'b011 : SNR Scalable
+    @** 3\'b10 : SpatiallyScalable
+    @** 3\'b001 : High
+    @* MPEG4
+    @** 8\'b00000000 : SP
+    @** 8\'b00001111 : ASP
+    @* Real Video
+    @** 8 (version 8)
+    @** 9 (version 9)
+    @** 10 (version 10)
+    @* AVS
+    @** 8\'b0010 0000 : Jizhun profile
+    @** 8\'b0100 1000 : Guangdian profile
+    @* VP8 : 0 - 3
+    @endverbatim
+    */
+	Int32 profile;
+	/**
+    @verbatim
+    @* H.265/H.264 : level_idc
+    @* VC1 : level
+    @* MPEG2 :
+    @** 4\'b1010 : Low
+    @** 4\'b1000 : Main
+    @** 4\'b0110 : High 1440,
+    @** 4\'b0100 : High
+    @* MPEG4 :
+    @** SP
+    @*** 4\'b1000 : L0
+    @*** 4\'b0001 : L1
+    @*** 4\'b0010 : L2
+    @*** 4\'b0011 : L3
+    @** ASP
+    @*** 4\'b0000 : L0
+    @*** 4\'b0001 : L1
+    @*** 4\'b0010 : L2
+    @*** 4\'b0011 : L3
+    @*** 4\'b0100 : L4
+    @*** 4\'b0101 : L5
+    @* Real Video : N/A (real video does not have any level info).
+    @* AVS :
+    @** 4\'b0000 : L2.0
+    @** 4\'b0001 : L4.0
+    @** 4\'b0010 : L4.2
+    @** 4\'b0011 : L6.0
+    @** 4\'b0100 : L6.2
+    @* VC1 : level in struct B
+    @endverbatim
+    */
+	Int32 level;
+	/**
+    @verbatim
+    A tier indicator
+
+    @* 0 : Main
+    @* 1 : High
+    @endverbatim
+    */
+	Int32 tier;
+	Int32 interlace; /**< When this value is 1, decoded stream may be decoded into progressive or interlace frame. Otherwise, decoded stream is progressive frame. */
+	Int32 constraint_set_flag
+		[4]; /**< constraint_set0_flag ~ constraint_set3_flag in H.264/AVC SPS */
+	Int32 direct8x8Flag; /**< direct_8x8_inference_flag in H.264/AVC SPS */
+	Int32 vc1Psf; /**< Progressive Segmented Frame(PSF) in VC1 sequence layer */
+	Int32 isExtSAR;
+	/**
+    @verbatim
+    This is one of the SPS syntax elements in H.264.
+
+    @* 0 : max_num_ref_frames is 0.
+    @* 1 : max_num_ref_frames is not 0.
+    @endverbatim
+    */
+	Int32 maxNumRefFrmFlag;
+	Int32 maxNumRefFrm;
+	/**
+    @verbatim
+    @* H.264/AVC : When avcIsExtSAR is 0, this indicates aspect_ratio_idc[7:0]. When avcIsExtSAR is 1, this indicates sar_width[31:16] and sar_height[15:0].
+    If aspect_ratio_info_present_flag = 0, the register returns -1 (0xffffffff).
+    @* VC1 : This reports ASPECT_HORIZ_SIZE[15:8] and ASPECT_VERT_SIZE[7:0].
+    @* MPEG2 : This value is index of Table 6-3 in ISO/IEC 13818-2.
+    @* MPEG4/H.263 : This value is index of Table 6-12 in ISO/IEC 14496-2.
+    @* RV : aspect_ratio_info
+    @* AVS : This value is the aspect_ratio_info[3:0] which is used as index of Table 7-5 in AVS Part2
+    @endverbatim
+    */
+	Int32 aspectRateInfo;
+	Int32 bitRate; /**< The bitrate value written in bitstream syntax. If there is no bitRate, this reports -1. */
+	ThoScaleInfo
+		thoScaleInfo; /**< This is the Theora picture size information. Refer to <<vpuapi_h_ThoScaleInfo>>. */
+	Vp8ScaleInfo
+		vp8ScaleInfo; /**< This is VP8 upsampling information. Refer to <<vpuapi_h_Vp8ScaleInfo>>. */
+	Int32 mp2LowDelay; /**< This is low_delay syntax of sequence extension in MPEG2 specification. */
+	Int32 mp2DispVerSize; /**< This is display_vertical_size syntax of sequence display extension in MPEG2 specification. */
+	Int32 mp2DispHorSize; /**< This is display_horizontal_size syntax of sequence display extension in MPEG2 specification. */
+	Uint32 userDataHeader; /**< Refer to userDataHeader in <<vpuapi_h_DecOutputExtData>>. */
+	Int32 userDataNum; /**< Refer to userDataNum in <<vpuapi_h_DecOutputExtData>>. */
+	Int32 userDataSize; /**< Refer to userDataSize in <<vpuapi_h_DecOutputExtData>>. */
+	Int32 userDataBufFull; /**< Refer to userDataBufFull in <<vpuapi_h_DecOutputExtData>>. */
+	//VUI information
+	Int32 chromaFormatIDC; /**< A chroma format indicator */
+	Int32 lumaBitdepth; /**< A bit-depth of luma sample */
+	Int32 chromaBitdepth; /**< A bit-depth of chroma sample */
+	Int32 mp2ColorPrimaries;
+	Int32 mp2TransferChar;
+	Int32 mp2MatrixCoeff;
+	/**
+    @verbatim
+    This is an error reason of sequence header decoding.
+    For detailed meaning of returned value,
+    please refer to the 'Appendix: ERROR DEFINITION in programmer\'s guide'.
+
+    In addition, HOST application might have an error reason value on 20th bit (0x100000).
+    This happens when bitstream buffer mode is BS_MODE_ROLLBACK,
+    and VPU_DecGetInitialInfo() or VPU_DecCompleteSeqInit() function call returns RETCODE_FAILURE due to
+    unsufficient stream of sequence header.
+    HOST application can get informed that VPU has rolled back to the state before the funtion calling with this field,
+    and should fill more bitstream to the buffer and then call VPU_DecGetInitialInfo() or VPU_DecIssueSeqInit() again.
+    @endverbatim
+    */
+	Int32 seqInitErrReason;
+	Int32 warnInfo;
+	PhysicalAddress rdPtr; /**< A read pointer of bitstream buffer */
+	PhysicalAddress wrPtr; /**< A write pointer of bitstream buffer */
+	AvcVuiInfo
+		avcVuiInfo; /**< This is H.264/AVC VUI information. Refer to <<vpuapi_h_AvcVuiInfo>>. */
+	MP2BarDataInfo
+		mp2BardataInfo; /**< This is bar information in MPEG2 user data. For details about this, please see the document 'ATSC Digital Television Standard: Part 4:2009'. */
+	Uint32 sequenceNo; /**< This is the number of sequence information. This variable is increased by 1 when VPU detects change of sequence. */
+} DecInitialInfo;
+
+// Report Information
+
+/**
+* @brief    The data structure for options of picture decoding.
+*/
+#define WAVE_SKIPMODE_WAVE_NONE 0
+#define WAVE_SKIPMODE_NON_IRAP 1
+#define WAVE_SKIPMODE_NON_REF 2
+typedef struct {
+	/**
+    @verbatim
+    @* 0 : disable
+    @* 1 : enable
+    @* 2 : I frame search enable (H.264/AVC only)
+
+    If this option is enabled, then decoder performs skipping frame decoding until
+    decoder meets an I (IDR) frame. If there is no I frame in given stream, decoder
+    waits for I (IDR) frame.
+    Especially in H.264/AVC stream decoding, they might have I-frame and IDR frame.
+    Therefore HOST application should set iframeSearchEnable value according to frame type.
+    If HOST application wants to search IDR frame, this flag should be set to 1 like other standards.
+    Otherwise if HOST application wants to search I frame, this flag should be set to 2.
+
+    Note that when decoder meets EOS (End Of Sequence) code during I-Search, decoder
+    returns -1 (0xFFFF). And if this option is enabled,
+    skipframeMode options are ignored.
+
+    NOTE: CODA9 only supports it.
+    @endverbatim
+    */
+	Int32 iframeSearchEnable;
+	/**
+    @verbatim
+    Skip frame function enable and operation mode
+
+    In case of CODA9,
+
+    @* 0 : skip frame disable
+    @* 1 : skip frame enabled (skip frames but I (IDR) frame)
+    @* 2 : skip frame enabled (skip any frames),
+
+    If this option is enabled, decoder skips decoding as many as skipframeNum.
+
+    If skipframeMode is 1, decoder skips frames but I (IDR) frames and decodes I (IDR)
+    frames. If skipframeMode is 2, decoder skips any frames. After decoder skips
+    frames, decoder returns the decoded index -2 (0xFFFE) when decoder does not have any
+    frames displayed.
+
+    In case of WAVE4,
+
+    @* 0x0 : skip frame off
+    @* 0x1 : skip non-RAP pictures. That is, all pictures that are not IDR, CRA, or BLA are skipped.
+    @* 0x2 : skip non-reference pictures.
+    @* 0x3 : Reserved
+    @* 0x4~0xf : Reserved
+
+    NOTE: When decoder meets EOS (End Of Sequence) code during frame skip,
+    decoder returns -1(0xFFFF).
+    @endverbatim
+    */
+	Int32 skipframeMode;
+	union {
+		/**
+        @verbatim
+        Forces to flush a display index of the frame buffer that
+        delayed without decoding of the current picture.
+
+        @* 0 : disable
+        @* 1 : enable flushing
+        @endverbatim
+        */
+		Int32 mp2PicFlush;
+		/**
+        @verbatim
+        FSets a de-blocking filter mode for RV streams.
+
+        @* 0 : It enables de-blocking filter for all pictures.
+        @* 1 : It disables de-blocking filter for all pictures.
+        @* 2 : It disables de-blocking filter for P and B pictures.
+        @* 3 : It disables de-blocking filter only for B pictures.
+        @endverbatim
+        */
+		Int32 rvDbkMode;
+	} DecStdParam;
+
+	BOOL craAsBlaFlag; /**< It handles CRA picture as BLA picture not to use reference from the previous decoded pictures (H.265/HEVC only) */
+	Uint64 dts;
+} DecParam;
+
+// Report Information
+/**
+* @brief    The data structure to get result information from decoding a frame.
+*/
+
+typedef struct {
+	/**
+    @verbatim
+    This variable indicates which userdata is reported by VPU. (WAVE only)
+    When this variable is not zero, each bit corresponds to the `H265_USERDATA_FLAG_XXX`.
+
+     // H265 USER_DATA(SPS & SEI) ENABLE FLAG
+     #define H265_USERDATA_FLAG_RESERVED_0           (0)
+     #define H265_USERDATA_FLAG_RESERVED_1           (1)
+     #define H265_USERDATA_FLAG_VUI                  (2)
+     #define H265_USERDATA_FLAG_RESERVED_3           (3)
+     #define H265_USERDATA_FLAG_PIC_TIMING           (4)
+     #define H265_USERDATA_FLAG_ITU_T_T35_PRE        (5)
+     #define H265_USERDATA_FLAG_UNREGISTERED_PRE     (6)
+     #define H265_USERDATA_FLAG_ITU_T_T35_SUF        (7)
+     #define H265_USERDATA_FLAG_UNREGISTERED_SUF     (8)
+     #define H265_USERDATA_FLAG_RESERVED_9           (9)
+     #define H265_USERDATA_FLAG_MASTERING_COLOR_VOL  (10)
+     #define H265_USERDATA_FLAG_CHROMA_RESAMPLING_FILTER_HINT  (11)
+     #define H265_USERDATA_FLAG_KNEE_FUNCTION_INFO   (12)
+
+    Userdata are written from the memory address specified to SET_ADDR_REP_USERDATA,
+    and userdata consists of two parts, header (offset and size) and userdata as shown below.
+
+     -------------------------------------
+     | offset_00(32bit) | size_00(32bit) |
+     | offset_01(32bit) | size_01(32bit) |
+     |                  ...              | header
+     |                  ...              |
+     | offset_31(32bit) | size_31(32bit) |
+     -------------------------------------
+     |                                   | data
+     |                                   |
+
+    @endverbatim
+    */
+	Uint32 userDataHeader;
+	Uint32 userDataNum; /**< This is the number of user data. */
+	Uint32 userDataSize; /**< This is the size of user data. */
+	Uint32 userDataBufFull; /**< When userDataEnable is enabled, decoder reports frame buffer status into the userDataBufAddr and userDataSize in byte size. When user data report mode is 1 and the user data size is bigger than the user data buffer size, VPU reports user data as much as buffer size, skips the remainings and sets userDataBufFull. */
+	Uint32 activeFormat; /**< active_format (4bit syntax value) in AFD user data. The default value is 0000b. This is valid only for H.264/AVC and MPEG2 stream. */
+} DecOutputExtData;
+
+// VP8 specific header information
+/**
+* @brief    This is a data structure for VP8 specific hearder information and reference frame indices.
+Only VP8 decoder returns this structure after decoding a frame.
+*/
+typedef struct {
+	unsigned showFrame : 1; /**< This flag is the frame header syntax, meaning whether the current decoded frame is displayable or not. It is 0 when the current frame is not for display, and 1 when the current frame is for display. */
+	unsigned versionNumber : 3; /**< This is the VP8 profile version number information in the frame header. The version number enables or disables certain features in bitstream. It can be defined with one of the four different profiles, 0 to 3 and each of them indicates different decoding complexity. */
+	unsigned refIdxLast : 8; /**< This is the frame buffer index for the Last reference frame. This field is valid only for next inter frame decoding. */
+	unsigned refIdxAltr : 8; /**< This is the frame buffer index for the altref(Alternative Reference) reference frame. This field is valid only for next inter frame decoding. */
+	unsigned refIdxGold : 8; /**< This is the frame buffer index for the Golden reference frame. This field is valid only for next inter frame decoding. */
+} Vp8PicInfo;
+
+// MVC specific picture information
+/**
+* @brief    This is a data structure for MVC specific picture information. Only MVC decoder returns this structure after decoding a frame.
+*/
+typedef struct {
+	int viewIdxDisplay; /**< This is view index order of display frame buffer corresponding to indexFrameDisplay of DecOutputInfo structure. */
+	int viewIdxDecoded; /**< This is view index order of decoded frame buffer corresponding to indexFrameDecoded of DecOutputInfo structure. */
+} MvcPicInfo;
+
+// AVC specific SEI information (frame packing arrangement SEI)
+/**
+* @brief    This is a data structure for H.264/AVC FPA(Frame Packing Arrangement) SEI.
+For detailed information, refer to 'ISO/IEC 14496-10 D.2.25 Frame packing arrangement SEI message semantics'.
+*/
+typedef struct {
+	/**
+    @verbatim
+    This is a flag to indicate whether H.264/AVC FPA SEI exists or not.
+
+    @* 0 : H.264/AVC FPA SEI does not exist.
+    @* 1 : H.264/AVC FPA SEI exists.
+    @endverbatim
+    */
+	unsigned exist;
+	unsigned framePackingArrangementId; /**< 0 ~ 2^32-1 : An identifying number that may be used to identify the usage of the frame packing arrangement SEI message. */
+	unsigned framePackingArrangementCancelFlag; /**< 1 indicates that the frame packing arrangement SEI message cancels the persistence of any previous frame packing arrangement SEI message in output order. */
+	unsigned quincunxSamplingFlag; /**< It indicates whether each color component plane of each constituent frame is quincunx sampled.  */
+	unsigned spatialFlippingFlag; /**< It indicates that one of the two constituent frames is spatially flipped.  */
+	unsigned frame0FlippedFlag; /**< It indicates which one of the two constituent frames is flipped. */
+	unsigned fieldViewsFlag; /**< 1 indicates that all pictures in the current coded video sequence are coded as complementary field pairs.  */
+	unsigned currentFrameIsFrame0Flag; /**< It indicates the current decoded frame and the next decoded frame in output order.  */
+	unsigned frame0SelfContainedFlag; /**< It indicates whether inter prediction operations within the decoding process for the samples of constituent frame 0  of the coded video sequence refer to samples of any constituent frame 1.  */
+	unsigned frame1SelfContainedFlag; /**< It indicates whether inter prediction operations within the decoding process for the samples of constituent frame 1 of the coded video sequence refer to samples of any constituent frame 0.  */
+	unsigned framePackingArrangementExtensionFlag; /**< 0 indicates that no additional data follows within the frame packing arrangement SEI message.  */
+	unsigned framePackingArrangementType; /**< The type of packing arrangement of the frames */
+	unsigned contentInterpretationType; /**< It indicates the intended interpretation of the constituent frames. */
+	unsigned frame0GridPositionX; /**< It specifies the horizontal location of the upper left sample of constituent frame 0 to the right of the spatial reference point.  */
+	unsigned frame0GridPositionY; /**< It specifies the vertical location of the upper left sample of constituent frame 0 below the spatial reference point.  */
+	unsigned frame1GridPositionX; /**< It specifies the horizontal location of the upper left sample of constituent frame 1 to the right of the spatial reference point.  */
+	unsigned frame1GridPositionY; /**< It specifies the vertical location of the upper left sample of constituent frame 1 below the spatial reference point.  */
+	unsigned framePackingArrangementRepetitionPeriod; /**< It indicates persistence of the frame packing arrangement SEI message.  */
+} AvcFpaSei;
+
+// H.264/AVC specific HRD information
+/**
+* @brief    This is a data structure for H.264/AVC specific picture information. (H.264/AVC decoder only)
+VPU returns this structure after decoding a frame. For detailed information, refer to 'ISO/IEC 14496-10 E.1 VUI syntax'.
+*/
+typedef struct {
+	int cpbMinus1; /**< cpb_cnt_minus1 */
+	int vclHrdParamFlag; /**< vcl_hrd_parameters_present_flag */
+	int nalHrdParamFlag; /**< nal_hrd_parameters_present_flag */
+} AvcHrdInfo;
+
+// H.264/AVC specific Recovery Point information
+/**
+* @brief    This is a data structure for H.264/AVC specific picture information. (H.264/AVC decoder only)
+VPU returns this structure after decoding a frame. For detailed information, refer to 'ISO/IEC 14496-10 D.1.7 Recovery point SEI message syntax'.
+*/
+typedef struct {
+	/**
+    @verbatim
+    This is a flag to indicate whether H.264/AVC RP SEI exists or not.
+
+    @* 0 : H.264/AVC RP SEI does not exist.
+    @* 1 : H.264/AVC RP SEI exists.
+    @endverbatim
+    */
+	unsigned exist;
+	int recoveryFrameCnt; /**< recovery_frame_cnt */
+	int exactMatchFlag; /**< exact_match_flag */
+	int brokenLinkFlag; /**< broken_link_flag */
+	int changingSliceGroupIdc; /**< changing_slice_group_idc */
+} AvcRpSei;
+
+// HEVC specific Recovery Point information
+/**
+* @brief    This is a data structure for H.265/HEVC specific picture information. (H.265/HEVC decoder only)
+VPU returns this structure after decoding a frame.
+*/
+typedef struct {
+	/**
+    @verbatim
+    This is a flag to indicate whether H.265/HEVC Recovery Point SEI exists or not.
+
+    @* 0 : H.265/HEVC RP SEI does not exist.
+    @* 1 : H.265/HEVC RP SEI exists.
+    @endverbatim
+    */
+	unsigned exist;
+	int recoveryPocCnt; /**< recovery_poc_cnt */
+	int exactMatchFlag; /**< exact_match_flag */
+	int brokenLinkFlag; /**< broken_link_flag */
+
+} H265RpSei;
+
+/**
+* @brief    This is a data structure that H.265/HEVC decoder returns for reporting POC (Picture Order Count).
+*/
+typedef struct {
+	int decodedPOC; /**< A POC value of picture that has currently been decoded and with decoded index. When indexFrameDecoded is -1, it returns -1. */
+	int displayPOC; /**< A POC value of picture with display index. When indexFrameDisplay is -1, it returns -1. */
+	int temporalId; /**< A temporal ID of the picture */
+} H265Info;
+
+/**
+* @brief    The data structure to get result information from decoding a frame.
+*/
+typedef struct {
+	/**
+    @verbatim
+    This is a frame buffer index for the picture to be displayed at the moment among
+    frame buffers which are registered using VPU_DecRegisterFrameBuffer(). Frame
+    data to be displayed are stored into the frame buffer with this index.
+    When there is no display delay, this index is always
+    the same with indexFrameDecoded. However, if display delay does exist for display reordering in AVC
+    or B-frames in VC1), this index might be different with indexFrameDecoded.
+    By checking this index, HOST application can easily know whether sequence decoding has been finished or not.
+
+    @* -3(0xFFFD) : It is when decoder skip option is on.
+    @* -2(0xFFFE) : It is when decoder have decoded sequence but cannot give a display output due to reordering.
+    @* -1(0xFFFF) : It is when there is no more output for display at the end of sequence decoding.
+
+    @endverbatim
+    */
+	int indexFrameDisplay;
+	int indexFrameDisplayForTiled; /**< In case of WTL mode, this index indicates a display index of tiled or compressed framebuffer. */
+	/**
+    @verbatim
+    This is a frame buffer index of decoded picture among frame buffers which were
+    registered using VPU_DecRegisterFrameBuffer(). The currently decoded frame is stored into the frame buffer specified by
+    this index.
+
+    * -2 : It indicates that no decoded output is generated because decoder meets EOS (End Of Sequence) or skip.
+    * -1 : It indicates that decoder fails to decode a picture because there is no available frame buffer.
+    @endverbatim
+    */
+	int indexFrameDecoded;
+	int indexInterFrameDecoded; /**< In case of VP9 codec, this indicates an index of the frame buffer to reallocate for the next frame's decoding. VPU returns this information when detecting change of the inter-frame resolution. */
+	int indexFrameDecodedForTiled; /**< In case of WTL mode, this indicates a decoded index of tiled or compressed framebuffer. */
+	int nalType; /**< This is nal Type of decoded picture. Please refer to nal_unit_type in Table 7-1 - NAL unit type codes and NAL unit type classes in H.265/HEVC specification. (WAVE only) */
+	int picType; /**< This is the picture type of decoded picture. It reports the picture type of bottom field for interlaced stream. <<vpuapi_h_PicType>>. */
+	int picTypeFirst; /**< This is only valid in interlaced mode and indicates the picture type of the top field. */
+	int numOfErrMBs; /**< This is the number of error coded unit in a decoded picture. */
+	int numOfTotMBs; /**< This is the number of coded unit in a decoded picture. */
+	int numOfErrMBsInDisplay; /**< This is the number of error coded unit in a picture mapped to indexFrameDisplay. */
+	int numOfTotMBsInDisplay; /**< This is the number of coded unit in a picture mapped to indexFrameDisplay. */
+	BOOL refMissingFrameFlag; /**< This indicates that the current frame's references are missing in decoding. (WAVE only)  */
+	int notSufficientSliceBuffer; /**< This is a flag which represents whether slice save buffer is not sufficient to decode the current picture. VPU might not get the last part of the current picture stream due to buffer overflow, which leads to macroblock errors. HOST application can continue decoding the remaining pictures of the current bitstream without closing the current instance, even though several pictures could be error-corrupted. (H.264/AVC BP only) */
+	int notSufficientPsBuffer; /**< This is a flag which represents whether PS (SPS/PPS) save buffer is not sufficient to decode the current picture. VPU might not get the last part of the current picture stream due to buffer overflow. HOST application must close the current instance, since the following picture streams cannot be decoded properly for loss of SPS/PPS data. (H.264/AVC only) */
+	/**
+    @verbatim
+    This variable indicates whether decoding process was finished completely or not. If stream
+    has error in the picture header syntax or has the first slice header syntax of H.264/AVC
+    stream, VPU returns 0 without proceeding MB decode routine.
+
+    @* 0 : It indicates incomplete finish of decoding process
+    @* 1 : It indicates complete finish of decoding process
+
+    @endverbatim
+    */
+	int decodingSuccess;
+	/**
+    @verbatim
+    @* 0 : A progressive frame which consists of one picture
+    @* 1 : An interlaced frame which consists of two fields
+    @endverbatim
+    */
+	int interlacedFrame;
+	/**
+    @verbatim
+    This is a flag which represents whether chunk in bitstream buffer should be reused or not, even after VPU_DecStartOneFrame() is executed.
+    This flag is meaningful when bitstream buffer operates in PicEnd mode. In that mode, VPU consumes all the bitstream in bitstream buffer for the current VPU_DecStartOneFrame()
+    in assumption that one chunk is one frame.
+    However, there might be a few cases that chunk needs to be reused such as the following:
+
+    * XivD stream : One chunk can contain P frame and B frame to reduce display delay.
+    In that case after decoding P frame, this flag is set to 1. HOST application should try decoding with the rest of chunk data to get B frame.
+    * H.264/AVC NPF stream : After the first field has been decoded, this flag is set to 1. HOST application should check if the next field is NPF or not.
+    * No DPB available: It is when VPU is not able to consume chunk with no frame buffers available at the moment. Thus, the whole chunk should be provided again.
+    @endverbatim
+    */
+	int chunkReuseRequired;
+	VpuRect rcDisplay; /**< This field reports the rectangular region in pixel unit after decoding one frame - the region of `indexFrameDisplay` frame buffer. */
+	int dispPicWidth; /**< This field reports the width of a picture to be displayed in pixel unit after decoding one frame - width of `indexFrameDisplay` frame bufffer.  */
+	int dispPicHeight; /**< This field reports the height of a picture to be displayed in pixel unit after decoding one frame - height of `indexFrameDisplay` frame bufffer.  */
+	VpuRect rcDecoded; /**< This field reports the rectangular region in pixel unit after decoding one frame - the region of `indexFrameDecoded` frame buffer. */
+	int decPicWidth; /**< This field reports the width of a decoded picture in pixel unit after decoding one frame - width of `indexFrameDecoded` frame bufffer. */
+	int decPicHeight; /**< This field reports the height of a decoded picture in pixel unit after decoding one frame - height of `indexFrameDecoded` frame bufffer.  */
+	int aspectRateInfo; /**< This is aspect ratio information for each standard. Refer to aspectRateInfo of <<vpuapi_h_DecInitialInfo>>. */
+	int fRateNumerator; /**< The numerator part of frame rate fraction. Note that the meaning of this flag can vary by codec standards. For details about this, please refer to 'Appendix: FRAME RATE NUMERATORS in programmer\'s guide'.  */
+	int fRateDenominator; /**< The denominator part of frame rate fraction. Note that the meaning of this flag can vary by codec standards. For details about this, please refer to 'Appendix: FRAME RATE DENOMINATORS in programmer\'s guide'.  */
+	Vp8ScaleInfo
+		vp8ScaleInfo; /**< This is VP8 upsampling information. Refer to <<vpuapi_h_Vp8ScaleInfo>>. */
+	Vp8PicInfo
+		vp8PicInfo; /**< This is VP8 frame header information. Refer to <<vpuapi_h_Vp8PicInfo>>. */
+	MvcPicInfo
+		mvcPicInfo; /**< This is MVC related picture information. Refer to <<vpuapi_h_MvcPicInfo>>. */
+	AvcFpaSei avcFpaSei; /**< This is H.264/AVC frame packing arrangement SEI information. Refer to <<vpuapi_h_AvcFpaSei>>. */
+	AvcHrdInfo
+		avcHrdInfo; /**< This is H.264/AVC HRD information. Refer to <<vpuapi_h_AvcHrdInfo>>. */
+	AvcVuiInfo
+		avcVuiInfo; /**< This is H.264/AVC VUI information. Refer to <<vpuapi_h_AvcVuiInfo>>. */
+	H265Info h265Info; /**< This is H.265/HEVC picture information. Refer to <<vpuapi_h_H265Info>>. */
+	/**
+    @verbatim
+    This field is valid only for VC1 decoding. Field information of display frame index
+    is returned on `indexFrameDisplay`.
+
+    @* 0 : Paired fields
+    @* 1 : Bottom (top-field missing)
+    @* 2 : Top (bottom-field missing)
+    @endverbatim
+    */
+	int vc1NpfFieldInfo;
+	int mp2DispVerSize; /**< This is display_vertical_size syntax of sequence display extension in MPEG2 specification. */
+	int mp2DispHorSize; /**< This is display_horizontal_size syntax of sequence display extension in MPEG2 specification. */
+	/**
+    @verbatim
+    This field is valid only for MPEG2 decoding. Field information of display frame index
+    is returned on `indexFrameDisplay`.
+
+    @* 0 : Paired fields
+    @* 1 : Bottom (top-field missing)
+    @* 2 : Top (bottom-field missing)
+    @endverbatim
+    */
+	int mp2NpfFieldInfo;
+	MP2BarDataInfo
+		mp2BardataInfo; /**< This is bar information in MPEG2 user data. For details about this, please see the document 'ATSC Digital Television Standard: Part 4:2009'. */
+	int mp2ColorPrimaries;
+	int mp2TransferChar;
+	int mp2MatrixCoeff;
+	MP2PicDispExtInfo
+		mp2PicDispExtInfo; /**< For meaning of each field, please see <<vpuapi_h_MP2PicDispExtInfo>>. */
+	AvcRpSei avcRpSei; /**< This is H.264/AVC recovery point SEI information. Refer to <<vpuapi_h_AvcRpSei>>. */
+	H265RpSei h265RpSei; /**< This is H.265/HEVC recovery point SEI information. Refer to <<vpuapi_h_H265RpSei>>. */
+	/**
+    @verbatim
+    This field is valid only for H.264/AVC decoding.
+    Field information of display frame index is returned on `indexFrameDisplay`.
+    Refer to the <<vpuapi_h_AvcNpfFieldInfo>>.
+
+    @* 0 : Paired fields
+    @* 1 : Bottom (top-field missing)
+    @* 2 : Top (bottom-field missing)
+    @endverbatim
+    */
+	int avcNpfFieldInfo;
+	int avcPocPic; /**< This field reports the POC value of frame picture in case of H.264/AVC decoding. */
+	int avcPocTop; /**< This field reports the POC value of top field picture in case of H.264/AVC decoding. */
+	int avcPocBot; /**< This field reports the POC value of bottom field picture in case of H.264/AVC decoding. */
+	/**
+@verbatim
+Write protect error reason
+
+In case VPU_DecGetOutputInfo() returns RETCODE_MEMORY_ACCESS_VIOLATION,
+this value indicates memory write protection error. Each bit matches the following error information.
+
+@* [3:0] bit : Write-protect error with AWLEN
+@* [7:4] bit : Write-protect error with AWID
+@* [8] bit : A primary or secondary flag
+@* [9] bit : A write-protect error flag
+@endverbatim
+*/
+	int wprotErrReason;
+	PhysicalAddress
+		wprotErrAddress; /** This variable means write-protect error address. */
+	// Report Information
+	/**
+    @verbatim
+    This variable indicates that the decoded picture is progressive or interlaced
+    picture. The value of pictureStructure is used as below.
+
+    @* H.264/AVC : MBAFF
+    @* VC1 : FCM
+    @** 0 : Progressive
+    @** 2 : Frame interlace
+    @** 3 : Field interlaced
+    @* MPEG2 : picture structure
+    @** 1 : TopField
+    @** 2 : BotField
+    @** 3 : Frame
+    @* MPEG4 : N/A
+    @* Real Video : N/A
+    @* H.265/HEVC : N/A
+    @endverbatim
+    */
+	int pictureStructure;
+	/**
+    @verbatim
+    For decoded picture consisting of two fields, this variable reports
+
+    @ 0 : VPU decodes the bottom field and then top field.
+    @ 1 : VPU decodes the top field and then bottom field.
+
+    Regardless of this variable, VPU writes the decoded image of top field picture at each odd line and the decoded image of bottom field picture at each even line in frame buffer.
+    @endverbatim
+    */
+	int topFieldFirst;
+	int repeatFirstField; /**< This variable indicates Repeat First Field that repeats to display the first field. This flag is valid for VC1, AVS, and MPEG2. */
+	int progressiveFrame; /**< This variable indicates progressive_frame in MPEG2 picture coding extention or in AVS picture header. In the case of VC1, this variable means RPTFRM  (Repeat Frame Count), which is used during display process. */
+	int fieldSequence; /**< This variable indicates field_sequence in picture coding extention in MPEG2. */
+	int frameDct; /**< This variable indicates frame_pred_frame_dct in sequence extension of MPEG2. */
+	int nalRefIdc; /**< This variable indicates if the currently decoded frame is a reference frame or not. This flag is valid for H.264/AVC only.   */
+	/**
+    @verbatim
+    @* H.264/AVC, MPEG2, and VC1
+    @** 0 : The decoded frame has paired fields.
+    @** 1 : The decoded frame has a top-field missing.
+    @** 2 : The decoded frame has a bottom-field missing.
+    @endverbatim
+    */
+	int decFrameInfo;
+	int picStrPresent; /**< It indicates pic_struct_present_flag in H.264/AVC pic_timing SEI. */
+	int picTimingStruct; /**< It indicates pic_struct in H.264/AVC pic_timing SEI reporting. (Table D-1 in H.264/AVC specification.) If pic_timing SEI is not presented, pic_struct is inferred by the D.2.1. pic_struct part in H.264/AVC specification. This field is valid only for H.264/AVC decoding. */
+	int progressiveSequence; /**< It indicates progressive_sequence in sequence extension of MPEG2. */
+	int mp4TimeIncrement; /**< It indicates vop_time_increment_resolution in MPEG4 VOP syntax. */
+	int mp4ModuloTimeBase; /**< It indicates modulo_time_base in MPEG4 VOP syntax. */
+	DecOutputExtData
+		decOutputExtData; /**< The data structure to get additional information about a decoded frame. Refer to <<vpuapi_h_DecOutputExtData>>. */
+	int consumedByte; /**< The number of bytes that are consumed by VPU. */
+	int rdPtr; /**< A stream buffer read pointer for the current decoder instance */
+	int wrPtr; /**< A stream buffer write pointer for the current decoder instance */
+	/**
+    @verbatim
+    The start byte position of the current frame after decoding the frame for audio-to-video synchronization
+
+    H.265/HEVC or H.264/AVC decoder seeks only 3-byte start code
+    (0x000001) while other decoders seek 4-byte start code(0x00000001).
+    @endverbatim
+    */
+	PhysicalAddress bytePosFrameStart;
+	PhysicalAddress
+		bytePosFrameEnd; /**< It indicates the end byte position of the current frame after decoding. This information helps audio-to-video synchronization. */
+	FrameBuffer
+		dispFrame; /**< It indicates the display frame buffer address and information. Refer to <<vpuapi_h_FrameBuffer>>. */
+	int frameDisplayFlag; /**< It reports a frame buffer flag to be displayed.  */
+	/**
+    @verbatim
+    This variable reports that sequence has been changed while H.264/AVC stream decoding.
+    If it is 1, HOST application can get the new sequence information by calling VPU_DecGetInitialInfo() or VPU_DecIssueSeqInit().
+
+    For H.265/HEVC decoder, each bit has a different meaning as follows.
+
+    @* sequenceChanged[5] : It indicates that the profile_idc has been changed.
+    @* sequenceChanged[16] : It indicates that the resolution has been changed.
+    @* sequenceChanged[19] : It indicates that the required number of frame buffer has been changed.
+    @endverbatim
+    */
+	int sequenceChanged;
+	// CODA9: [0]   1 - sequence changed
+	// WAVEX: [5]   1 - H.265 profile changed
+	//        [16]  1 - resolution changed
+	//        [19]  1 - number of DPB changed
+
+	int streamEndFlag; /**< This variable reports the status of `end of stream` flag. This information can be used for low delay decoding (CODA980 only). */
+	int frameCycle; /**< This variable reports the cycle number of decoding one frame. */
+	int errorReason; /**< This variable reports the error reason that occurs while decoding. For error description, please find the 'Appendix: Error Definition' in the Programmer's Guide. */
+	int errorReasonExt; /**< This variable reports the specific reason of error. For error description, please find the 'Appendix: Error Definition' in the Programmer's Guide. (WAVE only) */
+	int warnInfo;
+	Uint32 sequenceNo; /**< This variable increases by 1 whenever sequence changes. If it happens, HOST should call VPU_DecFrameBufferFlush() to get the decoded result that remains in the buffer in the form of DecOutputInfo array. HOST can recognize with this variable whether this frame is in the current sequence or in the previous sequence when it is displayed. (WAVE only) */
+	int rvTr; /**< This variable reports RV timestamp for Ref frame. */
+	int rvTrB; /**< This variable reports RV timestamp for B frame. */
+
+	/**
+    @verbatim
+    This variable reports the result of pre-scan which is the start of decoding routine for DEC_PIC command. (WAVE4 only)
+    In the prescan phase, VPU parses bitstream and pre-allocates frame buffers.
+
+    @* -2 : It is when VPU prescanned bitstream(bitstream consumed), but a decode buffer was not allocated for the bitstream during pre-scan, since there was only header information.
+    @* -1 : It is when VPU detected full of framebuffer while pre-scannig (bitstream not consumed).
+    @* >= 0 : It indicates that prescan has been successfully done. This index is returned to a decoded index for the next decoding.
+    @endverbatim
+    */
+	int indexFramePrescan;
+#ifdef SUPPORT_REF_FLAG_REPORT
+	int frameReferenceFlag[31];
+#endif
+	Int32 lfEnable; /**< If this is 1, AFBCE starts encoding the first CTU row with padding zeros into the first 4 lines. */
+	Int32 seekCycle; /**< This variable reports the number of cycles in seeking phase on the command queue. (WAVE5 only) */
+	Int32 parseCycle; /**< This variable reports the number of cycles in prescan phase on the command queue. (WAVE5 only) */
+	Int32 decodeCycle; /**< This variable reports the number of cycles in decoding phase on the command queue. (WAVE5 only) */
+
+	/**
+    @verbatim
+    A CTU size (only for WAVE series)
+
+    @* 16 : CTU16x16
+    @* 32 : CTU32x32
+    @* 64 : CTU64x64
+    @endverbatim
+    */
+	Int32 ctuSize;
+	Int32 outputFlag; /**< This variable reports whether the current frame is bumped out or not. (WAVE5 only) */
+
+	RtkDcsysInfo dcsysInfo;
+} DecOutputInfo;
+
+/**
+ * @brief   This is a data structure of frame buffer information. It is used for parameter when host issues DEC_GET_FRAMEBUF_INFO of <<vpuapi_h_VPU_DecGiveCommand>>.
+ */
+typedef struct {
+	vpu_buffer_t
+		vbFrame; /**< The information of frame buffer where compressed frame is saved  */
+	vpu_buffer_t
+		vbWTL; /**< The information of frame buffer where decoded, uncompressed frame is saved with linear format if WTL is on   */
+	vpu_buffer_t vbFbcYTbl
+		[MAX_REG_FRAME]; /**< The information of frame buffer to save luma offset table of compressed frame  */
+	vpu_buffer_t vbFbcCTbl
+		[MAX_REG_FRAME]; /**< The information of frame buffer to save chroma offset table of compressed frame */
+	vpu_buffer_t vbMvCol
+		[MAX_REG_FRAME]; /**< The information of frame buffer to save motion vector collocated buffer */
+	FrameBuffer framebufPool
+		[64]; /**< This is an array of <<vpuapi_h_FrameBuffer>> which contains the information of each frame buffer. When WTL is enabled, the number of framebufPool would be [number of compressed frame buffer] x 2, and the starting index of frame buffer for WTL is framebufPool[number of compressed frame buffer].  */
+} DecGetFramebufInfo;
+
+/**
+ * @brief   This is a data structure of queue command information. It is used for parameter when host issues DEC_GET_QUEUE_STATUS of <<vpuapi_h_VPU_DecGiveCommand>>. (WAVE5 only)
+ */
+typedef struct {
+	Uint32 instanceQueueCount; /**< This variable indicates the number of queued commands of the instance.  */
+	Uint32 totalQueueCount; /**< This variable indicates the number of queued commands of all instances.  */
+} DecQueueStatusInfo;
+
+//------------------------------------------------------------------------------
+// encode struct and definition
+//------------------------------------------------------------------------------
+
+#define MAX_ENC_PPS_NUM 2
+
+#define MAX_NUM_TEMPORAL_LAYER 7
+#define MAX_GOP_NUM 8
+
+typedef struct CodecInst EncInst;
+
+/**
+* @brief
+@verbatim
+This is a dedicated type for encoder handle returned when an encoder instance is
+opened. An encoder instance can be referred by the corresponding handle. EncInst
+is a type managed internally by API. Application does not need to care about it.
+
+NOTE: This type is vaild for encoder only.
+@endverbatim
+*/
+typedef EncInst *EncHandle;
+
+/**
+* @brief    This is a data structure for configuring MPEG4-specific parameters in encoder applications. (CODA9 encoder only)
+*/
+typedef struct {
+	int mp4DataPartitionEnable; /**< It encodes with MPEG4 data_partitioned coding tool.   */
+	int mp4ReversibleVlcEnable; /**< It encodes with MPEG4 reversible_vlc coding tool. */
+	int mp4IntraDcVlcThr; /**< It encodes with MPEG4 intra_dc_vlc_thr coding tool. The valid range is 0 - 7. */
+	int mp4HecEnable; /**< It encodes with MPEG4 HEC (Header Extension Code) coding tool.  */
+	int mp4Verid; /**< It encodes with value of MPEG4 part 2 standard version ID. Version 1 and version 2 are allowed.  */
+} EncMp4Param;
+
+/**
+* @brief    This is a data structure for configuring H.263-specific parameters in encoder applications. (CODA9 encoder only)
+*/
+typedef struct {
+	int h263AnnexIEnable; /**< It encodes with H.263 Annex I - Advanced INTRA Coding mode. */
+	int h263AnnexJEnable; /**< It encodes with H.263 Annex J - Deblocking Filter mode. */
+	int h263AnnexKEnable; /**< It encodes with H.263 Annex K - Slice Structured mode. */
+	int h263AnnexTEnable; /**< It encodes with H.263 Annex T - Modified Quantization mode. */
+} EncH263Param;
+
+/**
+* @brief    This is a data structure for custom GOP parameters of the given picture. (WAVE encoder only)
+*/
+typedef struct {
+	int picType; /**< A picture type of Nth picture in the custom GOP */
+	int pocOffset; /**< A POC of Nth picture in the custom GOP */
+	int picQp; /**< A quantization parameter of Nth picture in the custom GOP */
+	int numRefPicL0;
+	int refPocL0; /**< A POC of reference L0 of Nth picture in the custom GOP */
+	int refPocL1; /**< A POC of reference L1 of Nth picture in the custom GOP */
+	int temporalId; /**< A temporal ID of Nth picture in the custom GOP */
+} CustomGopPicParam;
+
+/**
+* @brief    This is a data structure for custom GOP parameters. (WAVE encoder only)
+*/
+typedef struct {
+	int customGopSize; /**< The size of custom GOP (0~8) */
+	int useDeriveLambdaWeight; /**< It internally derives a lamda weight instead of using the given lamda weight. */
+	CustomGopPicParam picParam
+		[MAX_GOP_NUM]; /**< Picture parameters of Nth picture in custom GOP */
+	int gopPicLambda
+		[MAX_GOP_NUM]; /**< A lamda weight of Nth picture in custom GOP */
+} CustomGopParam;
+
+/**
+* @brief This is a data structure for encoding parameters that have changed.
+*/
+typedef struct {
+	/**
+@verbatim
+
+@* 0 : changes the COMMON parameters. 
+@* 1 : Reserved
+@endverbatim
+*/
+	int changeParaMode;
+	int enable_option; /**< <<vpuapi_h_ChangeCommonParam>> */
+
+	// ENC_SET_PPS_PARAM_CHANGE
+	int losslessEnable; /**< It enables lossless coding. */
+	int constIntraPredFlag; /**< It enables constrained intra prediction. */
+	int weightPredEnable;
+
+	// ENC_INTRA_PARAM_CHANGE
+	/**
+@verbatim
+The type of I picture to be inserted at every intraPeriod
+
+@* 0 : Non-IRAP
+@* 1 : CRA
+@* 2 : IDR
+@endverbatim
+*/
+	int decodingRefreshType;
+	int intraPeriod; /**< A period of intra picture in GOP size */
+	int intraQP; /**< A quantization parameter of intra picture */
+
+	// ENC_CONF_WIN_TOP_BOT_CHANGE
+	int confWinTop; /**< A top offset of conformance window */
+	int confWinBot; /**< A bottom offset of conformance window */
+
+	// ENC_CONF_WIN_LEFT_RIGHT_CHANGE
+	int confWinLeft; /**< A left offset of conformance window */
+	int confWinRight; /**< A right offset of conformance window */
+
+	// ENC_FRAME_RATE_CHANGE
+	int frameRate; /**< A frame rate indicator ( x 1024) */
+
+	// ENC_SET_INDEPEND_SLICE_CHANGE
+	/**
+    @verbatim
+    A slice mode for independent slice
+
+    @* 0 : no multi-slice
+    @* 1 : Slice in CTU number
+    @endverbatim
+    */
+	int independSliceMode;
+	int independSliceModeArg; /**< The number of CTU for a slice when independSliceMode is set with 1  */
+
+	// ENC_SET_DEPEND_SLICE_CHANGE
+	/**
+    @verbatim
+    A slice mode for dependent slice
+
+    @* 0 : no multi-slice
+    @* 1 : Slice in CTU number
+    @* 2 : Slice in number of byte
+    @endverbatim
+    */
+	int dependSliceMode;
+	int dependSliceModeArg; /**< The number of CTU or bytes for a slice when dependSliceMode is set with 1 or 2  */
+
+	// ENC_INTRA_REFRESH_CHANGE
+	/**
+@verbatim
+An intra refresh mode
+
+@* 0 : No intra refresh
+@* 1 : Row
+@* 2 : Column 
+@* 3 : Step size in CTU
+@endverbatim
+*/
+	int intraRefreshMode;
+	int intraRefreshArg; /**< The number of CTU (only valid when intraRefreshMode is 3.) */
+
+	// ENC_PARAM_CHANGE
+	/**
+    @verbatim
+    It uses a recommended ENC_PARAM setting.
+
+    @* 0 : Custom
+    @* 1 : Recommended ENC_PARAM
+    @* 2 ~ 3  : Reserved
+    @endverbatim
+    */
+	int useRecommendEncParam;
+	int coefClearDisable;
+	int scalingListEnable; /**< It enables a scaling list. */
+	/**
+    @verbatim
+    It enables CU(Coding Unit) size to be used in encoding process. Host application can also select multiple CU sizes.
+
+    @* 0 : 8x8
+    @* 1 : 16x16
+    @* 2 : 32x32
+    @endverbatim
+    */
+	int cuSizeMode;
+	int tmvpEnable; /**< It enables temporal motion vector prediction. */
+	int wppEnable; /**< It enables WPP (Wave-front Parallel Processing). WPP is unsupported in ring buffer mode of bitstream buffer.  */
+	int maxNumMerge; /**< Maximum number of merge candidates (0~2) */
+	int dynamicMerge8x8Enable; /**< It enables dynamic merge 8x8 candidates. */
+	int dynamicMerge16x16Enable; /**< It enables dynamic merge 16x16 candidates. */
+	int dynamicMerge32x32Enable; /**< It enables dynamic merge 32x32 candidates. */
+	int disableDeblk; /**< It disables in-loop deblocking filtering. */
+	int lfCrossSliceBoundaryEnable; /**< It enables filtering across slice boundaries for in-loop deblocking. */
+	int betaOffsetDiv2; /**< It enables BetaOffsetDiv2 for deblocking filter. */
+	int tcOffsetDiv2; /**< It enables TcOffsetDiv3 for deblocking filter. */
+	int skipIntraTrans; /**< It enables transform skip for an intra CU. */
+	int saoEnable; /**< It enables SAO (Sample Adaptive Offset). */
+	int intraInInterSliceEnable; /**< It enables to make intra CUs in an inter slice. */
+	int intraNxNEnable; /**< It enables intra NxN PUs. */
+	int customLambdaEnable;
+	int customMDEnable;
+	int monochromeEnable;
+
+	// ENC_SET_RC_PARAM_CHANGE
+	/**
+    @verbatim
+    @* WAVE420 
+    @** 0 : Rate control is off.
+    @** 1 : Rate control is on.
+
+    @* CODA9
+    @** 0 : Constant QP (VBR, rate control off)
+    @** 1 : Constant Bit-Rate (CBR)
+    @** 2 : Average Bit-Rate (ABR)
+    @** 4 : Picture level rate control
+    @endverbatim
+    */
+	int rcEnable;
+	int intraQpOffset; /**< It specifies an intra QP offset relative to an inter QP. It is only valid when RateControl is enabled. */
+	/**
+@verbatim
+It specifies encoder initial delay. It is only valid when RateControl is enabled.
+
+ encoder initial delay = InitialDelay * InitBufLevelx8 / 8
+
+@endverbatim
+*/
+	int initBufLevelx8;
+	/**
+    @verbatim
+    It specifies picture bits allocation mode.
+    It is only valid when RateControl is enabled and GOP size is larger than 1.
+
+    @* 0 : More referenced pictures have better quality than less referenced pictures
+    @* 1 : All pictures in a GOP have similar image quality
+    @* 2 : Each picture bits in a GOP is allocated according to FixedRatioN
+    @endverbatim
+    */
+	int bitAllocMode;
+	/**
+@verbatim
+A fixed bit ratio (1 ~ 255) for each picture of GOP's bit
+allocation
+
+@* N = 0 ~ (MAX_GOP_SIZE - 1)
+@* MAX_GOP_SIZE = 8
+
+For instance when MAX_GOP_SIZE is 3, FixedBitRatio0, FixedBitRatio1, and FixedBitRatio2 can be set as 2, 1, and 1 repsectively for
+the fixed bit ratio 2:1:1. This is only valid when BitAllocMode is 2.
+@endverbatim
+*/
+	int fixedBitRatio[MAX_GOP_NUM];
+
+	int cuLevelRCEnable; /**< It enables CU level rate control. */
+	int hvsQPEnable; /**< It enables CU QP adjustment for subjective quality enhancement. */
+	int hvsQpScaleEnable; /**< It enables QP scaling factor for CU QP adjustment when hvsQPEnable is 1. */
+	int hvsQpScale; /**< QP scaling factor for CU QP adjustment when hvcQpenable is 1. */
+	int initialDelay; /**< An initial cpb delay in msec */
+	Uint32 initialRcQp; /**< The value of initial QP by HOST application. This value is meaningless if INITIAL_RC_QP is 63. */
+	int seqRoiEnable;
+
+	// ENC_SET_RC_MIN_MAX_QP_CHANGE
+	int minQpI;
+	int maxQpI;
+
+	// ENC_RC_MIN_MAX_QP_CHANGE
+	int minQp; /**< Minimum QP for rate control */
+	int maxQp; /**< Maximum QP for rate control */
+
+	int maxDeltaQp; /**< Maximum delta QP for rate control */
+
+	// ENC_SET_RC_INTER_MIN_MAX_QP_CHANGE
+	int minQpP;
+	int minQpB;
+	int maxQpP;
+	int maxQpB;
+
+	// ENC_TARGET_RATE_CHANGE
+	int bitRate; /**< A target bitrate when separateBitrateEnable is 0 */
+
+	// ENC_TRANS_RATE_CHANGE
+	int transRate; /**< A peak transmission bitrate in bps */
+
+	// ENC_RC_INTRA_MIN_MAX_CHANGE
+	int intraMaxQp; /**< It specifies a maximum QP for intra picture (0 ~ 51). It is only valid when RateControl is 1. */
+	int intraMinQp; /**< It specifies a minimum QP for intra picture (0 ~ 51). It is only valid when RateControl is 1. */
+
+	// ENC_ROT_PARAM_CHANGE
+	int rotEnable; /**< It enables or disable rotation. */
+
+	// ENC_SET_RC_BIT_RATIO_LAYER_CHANGE
+	/**
+    @verbatim
+    A fixed bit ratio (1 ~ 255) for each picture of GOP's bit
+    allocation
+
+    @* N = 0 ~ (MAX_GOP_SIZE - 1)
+    @* MAX_GOP_SIZE = 8
+
+    For instance when MAX_GOP_SIZE is 3, FixedBitRatio0, FixedBitRatio1, and FixedBitRatio2 can be set as 2, 1, and 1 repsectively for
+    the fixed bit ratio 2:1:1. This is only valid when BitAllocMode is 2.
+    @endverbatim
+    */
+	int rotMode;
+
+	// ENC_NR_PARAM_CHANGE
+	Uint32 nrYEnable; /**< It enables noise reduction algorithm to Y component.  */
+	Uint32 nrCbEnable; /**< It enables noise reduction algorithm to Cb component. */
+	Uint32 nrCrEnable; /**< It enables noise reduction algorithm to Cr component. */
+	Uint32 nrNoiseEstEnable; /**< It enables noise estimation for reduction. When this is disabled, noise estimation is carried out ouside VPU. */
+	Uint32 nrNoiseSigmaY; /**< It specifies Y noise standard deviation if no use of noise estimation (nrNoiseEstEnable is 0). */
+	Uint32 nrNoiseSigmaCb; /**< It specifies Cb noise standard deviation if no use of noise estimation (nrNoiseEstEnable is 0). */
+	Uint32 nrNoiseSigmaCr; /**< It specifies Cr noise standard deviation if no use of noise estimation (nrNoiseEstEnable is 0). */
+
+	// ENC_NR_WEIGHT_CHANGE
+	Uint32 nrIntraWeightY; /**< A weight to Y noise level for intra picture (0 ~ 31). nrIntraWeight/4 is multiplied to the noise level that has been estimated. This weight is put for intra frame to be filtered more strongly or more weakly than just with the estimated noise level. */
+	Uint32 nrIntraWeightCb; /**< A weight to Cb noise level for intra picture (0 ~ 31).*/
+	Uint32 nrIntraWeightCr; /**< A weight to Cr noise level for intra picture (0 ~ 31).*/
+	Uint32 nrInterWeightY; /**< A weight to Y noise level for inter picture (0 ~ 31). nrInterWeight/4 is multiplied to the noise level that has been estimated. This weight is put for inter frame to be filtered more strongly or more weakly than just with the estimated noise level. */
+	Uint32 nrInterWeightCb; /**< A weight to Cb noise level for inter picture (0 ~ 31).*/
+	Uint32 nrInterWeightCr; /**< A weight to Cr noise level for inter picture (0 ~ 31).*/
+
+	// ENC_NUM_UNITS_IN_TICK_CHANGE
+	Uint32 numUnitsInTick; /**< It specifies the number of time units of a clock operating at the frequency time_scale Hz. */
+
+	// ENC_TIME_SCALE_CHANGE
+	Uint32 timeScale; /**< It specifies the number of time units that pass in one second. */
+
+} EncChangeParam;
+
+/**
+* @brief    This is a data structure for configuring PPS information at H.264/AVC.
+*/
+typedef struct {
+	int ppsId; /**< H.264 picture_parameter_set_id in PPS. This shall be in the range of 0 to 255, inclusive. */
+	/**
+    @verbatim
+    It selects the entropy coding method used in the encoding process.
+
+    @* 0 : CAVLC
+    @* 1 : CABAC
+    @* 2 : CAVLC/CABAC select according to PicType
+    @endverbatim
+    */
+	int entropyCodingMode;
+	int cabacInitIdc; /**< It specifies the index for determining the initialization table used in the initialisation process for CABAC. The value of cabac_init_idc shall be in the range of 0 ~ 2. */
+	/**
+    @verbatim
+    It specifies whether to enable 8x8 intra prediction and 8x8 transform or not.
+
+    @* 0 : disable 8x8 intra and 8x8 transform (BP)
+    @* 1 : enable 8x8 intra and 8x8 transform (HP)
+    @endverbatim
+    */
+	int transform8x8Mode;
+} AvcPpsParam;
+
+/**
+* @brief    This is a data structure for configuring H.264/AVC-specific parameters in encoder applications.
+*/
+typedef struct {
+	/**
+    @verbatim
+    @* 0 : disable
+    @* 1 : enable
+    @endverbatim
+    */
+	int constrainedIntraPredFlag;
+	/**
+    @verbatim
+    @* 0 : enable
+    @* 1 : disable
+    @* 2 : disable deblocking filter at slice boundaries
+    @endverbatim
+    */
+	int disableDeblk;
+	int deblkFilterOffsetAlpha; /**< deblk_filter_offset_alpha (-6 - 6) */
+	int deblkFilterOffsetBeta; /**< deblk_filter_offset_beta (-6 - 6)  */
+	int chromaQpOffset; /**< chroma_qp_offset (-12 - 12)  */
+	/**
+    @verbatim
+    @* 0 : disable
+    @* 1 : enable
+
+    If this is 1, the encoder generates AUD RBSP at the start of every picture.
+    @endverbatim
+    */
+	int audEnable;
+	/**
+    @verbatim
+    @* 0 : disable
+    @* 1 : enable
+
+    If this is 1, the encoder generates frame_cropping_flag syntax at the SPS header.
+    @endverbatim
+    */
+	int frameCroppingFlag;
+	int frameCropLeft; /**< The sample number of left cropping region in a line. See the frame_crop_left_offset syntax in AVC/H.264 SPS tabular form. The least significant bit of this parameter should be always zero. */
+	int frameCropRight; /**< The sample number of right cropping region in a line. See the frame_crop_right_offset syntax in AVC/H.264 SPS tabular form. The least significant bit of this parameter should be always zero. */
+	int frameCropTop; /**< The sample number of top cropping region in a picture column. See the frame_crop_top_offset syntax in AVC/H.264 SPS tabular form. The least significant bit of this parameter should be always zero. */
+	int frameCropBottom; /**< The sample number of bottom cropping region in a picture column. See the frame_crop_bottom_offset syntax in AVC/H.264 SPS tabular form. The least significant bit of this parameter should be always zero. */
+
+	int mvcExtension; /**< MVC extension */
+	int interviewEn; /**< MVC extension */
+	int parasetRefreshEn; /**< MVC extension */
+	int prefixNalEn; /**< MVC extension */
+
+	int level; /**< H.264/AVC level_idc in SPS */
+	/**
+    @verbatim
+    H.264 profile_idc parameter is derived from each coding tool usage.
+
+    @* 0 : Baseline profile
+    @* 1 : Main profile
+    @* 2 : High profile
+    @endverbatim
+    */
+	int profile;
+	// [START] CODA980 & WAVE320
+	/**
+    @verbatim
+    It selects the encoding type, progressive or interlaced.
+
+    @* 0 : Progressive frame encoding.
+    @* 1 : Interlaced field encoding.
+    @endverbatim
+    */
+	int fieldFlag;
+	/**
+    @verbatim
+    Reference mode for interlaced field encoding(avc_field_flag is 1).
+
+    @* 0 : Same parity field referencing
+    @* 1 : Opposite parity field referencing
+    @endverbatim
+    */
+	int fieldRefMode;
+	/**
+    @verbatim
+    It specifies type of chroma format.
+
+    @* 0 : YUV 420 format
+    @* 1 : YUV 400 monochrome format
+    @endverbatim
+    */
+	int chromaFormat400;
+	int ppsNum; /**< Number of PPS. If a PPS has the same pps_id, the last PPS is available. */
+
+	AvcPpsParam ppsParam[MAX_ENC_PPS_NUM];
+	Uint32 videoSignalTypePresent; /**< It sets video_signal_type_present_flag syntax in VUI parameter. (CODA980 only)*/
+	Uint32 videoFormat; /**< It sets video_format syntax in VUI parameter. (CODA980 only)*/
+	Uint32 videoFullRangeFlag; /**< It sets video_full_range_flag syntax in VUI parameter. (CODA980 only)*/
+	Uint32 colourDescripPresFlag; /**< It sets colour_description_present_flag syntax in VUI parameter. (CODA980 only)*/
+	Uint32 colourPrimaries; /**< It sets colour_primaries syntax in VUI parameter. (CODA980 only)*/
+	Uint32 transferCharacteristics; /**< It sets transfer_characteristics syntax in VUI parameter. (CODA980 only)*/
+	Uint32 matrixCoefficients; /**< It sets matrix_coeffs syntax in VUI parameter. (CODA980 only)*/
+
+	// [END] CODA980 & WAVE320
+} EncAvcParam;
+
+/**
+* @brief    This structure is used for declaring an encoder slice mode and its options. It is newly added for more flexible usage of slice mode control in encoder.
+*/
+typedef struct {
+	/**
+    @verbatim
+    @* 0 : one slice per picture
+    @* 1 : multiple slices per picture
+    @* 2 : multiple slice encoding mode 2 for H.264 only.
+
+    In normal MPEG4 mode, resync-marker and packet header are inserted between
+    slice boundaries. In short video header with Annex K of 0, GOB headers are inserted
+    at every GOB layer start. In short video header with Annex K of 1, multiple
+    slices are generated. In AVC mode, multiple slice layer RBSP is generated.
+    @endverbatim
+    */
+	int sliceMode;
+	/**
+    @verbatim
+    This parameter means the size of generated slice when sliceMode of 1.
+
+    @* 0 : sliceSize is defined by the amount of bits
+    @* 1 : sliceSize is defined by the number of MBs in a slice
+    @* 2 : sliceSize is defined by MBs run-length table (only for H.264)
+
+    This parameter is ignored when sliceMode of 0 or
+    in short video header mode with Annex K of 0.
+    @endverbatim
+    */
+	int sliceSizeMode;
+	int sliceSize; /**< The size of a slice in bits or in MB numbers included in a slice, which is specified by the variable, sliceSizeMode. This parameter is ignored when sliceMode is 0 or in short video header mode with Annex K of 0. */
+} EncSliceMode;
+
+/**
+* @brief    This data structure is used when HOST wants to open a new encoder instance.
+*/
+typedef struct {
+	PhysicalAddress
+		bitstreamBuffer; /**< The start address of bitstream buffer into which encoder puts bitstream. This address must be aligned to AXI bus width. */
+	Uint32 bitstreamBufferSize; /**< The size of the buffer in bytes pointed by bitstreamBuffer. This value must be a multiple of 1024. The maximum size is 16383 x 1024 bytes. */
+	CodStd bitstreamFormat; /**< The standard type of bitstream in encoder operation. It is one of STD_MPEG4, STD_H263, STD_AVC and STD_MJPG. */
+	/**
+    @verbatim
+    @* 0 : disable
+    @* 1 : enable
+
+    This flag declares the streaming mode for the current encoder instance. Two
+    streaming modes, packet-based streaming with ring-buffer (buffer-reset mode) and
+    frame-based streaming with line buffer (buffer-flush mode), can be configured by
+    using this flag.
+
+    When this field is set, packet-based streaming with ring-buffer is used.
+    And when this field is not set, frame-based streaming with line-buffer is used.
+
+    @endverbatim
+    */
+	int ringBufferEnable;
+	int picWidth; /**< The width of a picture to be encoded in pixels. */
+	int picHeight; /**< The height of a picture to be encoded in pixels. */
+	/**
+    @verbatim
+    It is a linear to tiled enable mode.
+    The map type can be changed from linear to tiled format while reading source frame
+    in the PrP (Pre-Processing) unit.
+
+    @* 0 : disable linear to tiled-map conversion for getting source image
+    @* 1 : enable linear to tiled-map conversion for getting source image
+    @endverbatim
+    */
+	int linear2TiledEnable;
+	/**
+    @verbatim
+    It can specify the map type of source frame buffer when linear2TiledEnable is enabled. (CODA980 only)
+
+    @* 1 : source frame buffer is in linear frame map.
+    @* 2 : source frame buffer is in linear field map.
+
+    @endverbatim
+    */
+	int linear2TiledMode;
+	/**
+    @verbatim
+    The 16 LSB bits, [15:0], is a numerator and 16 MSB bits, [31:16], is a
+    denominator for calculating frame rate. The numerator means clock ticks per
+    second, and the denominator is clock ticks between frames minus 1.
+
+    So the frame rate can be defined by (numerator/(denominator + 1)),
+    which equals to (frameRateInfo & 0xffff) /((frameRateInfo >> 16) + 1).
+
+    For example, the value 30 of frameRateInfo represents 30 frames/sec, and the
+    value 0x3e87530 represents 29.97 frames/sec.
+    @endverbatim
+    */
+	int frameRateInfo;
+	/**
+    @verbatim
+    The horizontal search range mode for Motion Estimation
+
+    @* 0 : Horizontal(-64 ~ 63)
+    @* 1 : Horizontal(-48 ~ 47)
+    @* 2 : Horizontal(-32 ~ 31)
+    @* 3 : Horizontal(-16 ~ 15)
+    @endverbatim
+    */
+	// [START] CODA980 & WAVE320
+	int MESearchRangeX;
+	/**
+    @verbatim
+    The vertical search range mode for Motion Estimation
+
+    @* 0 : Vertical(-48 ~ 47)
+    @* 1 : Vertical(-32 ~ 31)
+    @* 2 : Vertical(-16 ~ 15)
+    @endverbatim
+    */
+	int MESearchRangeY;
+	/**
+    @verbatim
+    An initial QP offset for I picture in GOP.
+
+    This setting can lower an I picture QP value
+    down to a user-defined value ranging -4 to 4.
+    This value is valid for AvcEnc and ignored
+    when when RcEnable is 0 or RcGopIQpOff-setEn is 0.
+    @endverbatim
+    */
+	int rcGopIQpOffsetEn;
+	/**
+    @verbatim
+    An enable flag for initial QP offset for I picture in GOP.
+
+    @* 0 : disable (default)
+    @* 1 : disable
+
+    This value is valid for AvcEnc and ignored when when RcEnable is 0.
+    @endverbatim
+    */
+	int rcGopIQpOffset;
+	/**
+    @verbatim
+    The search range mode for Motion Estimation
+
+    @* 0 : Horizontal(-128 ~ 127), Vertical(-64 ~ 63)
+    @* 1 : Horizontal(-64 ~ 63), Vertical(-32 ~ 31)
+    @* 2 : Horizontal(-32 ~ 31), Vertical(-16 ~ 15)
+    @* 3 : Horizontal(-16 ~ 15), Vertical(-16 ~ 15)
+    @endverbatim
+    */
+	int MESearchRange;
+	// [END] CODA980 & WAVE320
+	/**
+    @verbatim
+    vbv_buffer_size in bits
+
+    This value is ignored if rate control is disabled or
+    initialDelay is 0. The value 0 means the encoder does not check for reference
+    decoder buffer size constraints.
+    @endverbatim
+    */
+	// [START] CODA9xx & WAVE320
+	int vbvBufferSize;
+	/**
+    @verbatim
+    Frame skip indicates that encoder can skip frame encoding automatically when
+    bitstream has been generated much so far considering the given target bitrate. This parameter is
+    ignored if rate control is not used (bitRate is 0).
+
+    @* 0 : enables frame skip function in encoder.
+    @* 1 : disables frame skip function in encoder.
+    @endverbatim
+    */
+	int frameSkipDisable;
+
+	/**
+    @verbatim
+    This is the GOP size.
+
+    @* 0 : only first picture is I
+    @* 1 : all I pictures
+    @* 2 : IPIP...
+    @* 3 : IPPIPP...
+
+    The maximum value is 32767, but in practice, a smaller value should be
+    chosen by HOST application for proper error concealment operations. This value is
+    ignored in case of STD_MJPG
+    @endverbatim
+    */
+	int gopSize;
+	/**
+    An interval of adding an IDR picture
+    */
+	int idrInterval;
+	/**
+    @verbatim
+    A block mode enable flag for Motion Estimation. (H.264/AVC only).
+    A HOST can use some combination (bitwise or-ing) of each value under below.
+
+    @* 4'b0000 or 4'b1111 : Use all block mode
+    @* 4'b0001 : Enable 16x16 block mode
+    @* 4'b0010 : Enable 16x8 block mode
+    @* 4'b0100 : Enable 8x16 block mode
+    @* 4'b1000 : Enable 8x8 block mode
+    @endverbatim
+    */
+	int meBlkMode;
+	EncSliceMode sliceMode; /**< The parameter for slice mode */
+	/**
+    @verbatim
+    @* 0 : intra MB refresh is not used.
+    @* Otherwise : at least N MBs in every P-frame is encoded as intra MBs.
+
+    This value is ignored in case of STD_MJPG
+    @endverbatim
+    */
+	int intraRefresh;
+	/**
+    @verbatim
+    Consecutive intra MB refresh mode
+
+    This option is valid only when IntraMbRefresh-Num[15:0] is not 0.
+
+    @* 0 - ConscIntraRefreshEn is disabled. IntraMbRefreshNumnumber of MBs are encoded
+    as an intra MB at the defined interval by picture
+    size.
+    @* 1 - IntraMbRefreshNumnumber of consec-utive MBs are encoded as an intra MB.
+    @endverbatim
+    */
+	int ConscIntraRefreshEnable;
+	/**
+    @verbatim
+    Intra MB count enable
+
+    If it is enabled, VPU does not include intra MBs
+    from mode decision when counting IntraMbRefreshNum. This option is valid only when
+    IntraMbRefreshNum[15:0] is not 0.
+
+    @* 0 - intra mb counting is disabled.
+    @* 1 - intra mb counting is enabled.
+    @endverbatim
+    */
+	int CountIntraMbEnable;
+	/**
+    @verbatim
+    Field sequence intra refresh enable
+
+    This option is valid only when IntraMbRefresh-Num[15:0] is not 0 and interlaced encoding.
+
+    @* 0 - FieldSeqIntraRefreshEn is disabled.
+    @* 1 - Intra mb is sequentially refreshed at each
+    field.
+    @endverbatim
+    */
+	int FieldSeqIntraRefreshEnable;
+	/**
+    @verbatim
+    The maximum quantized step parameter for encoding process
+
+    In MPEG4/H.263 mode, the maximum value is 31.
+    In H.264 mode, allowed maximum value is 51.
+    @endverbatim
+    */
+	int userQpMax;
+
+	//h.264 only
+	int maxIntraSize; /**< The maximum bit size for intra frame or encoding process. It works only in H.264/AVC encoder. */
+	int userMaxDeltaQp; /**< The maximum delta QP for encoding process. It works only in the H.264/AVC mode. */
+	int userQpMin; /**< The minimum quantized step parameter for encoding process. It works only in the H.264/AVC mode. */
+	int userMinDeltaQp; /**< The minimum delta QP for encoding process. It works only in the H.264/AVC mode. */
+	/**
+    @verbatim
+    The PMV option for Motion Estimation.
+    If this field is 1, encoding quality could be worse than when it was zero.
+
+    @* 0 : Motion Estimation engine uses PMV that was derived from neighbor MV
+    @* 1 : Motion Estimation engine uses Zero PMV
+    @endverbatim
+    */
+	int MEUseZeroPmv;
+	/**
+    @verbatim
+    Additional weight of intra cost for mode decision to reduce intra MB density
+
+    By default, it could be zero.
+    If this register have some value W,
+    and the cost of best intra mode that was decided by Refine-Intra-Mode-Decision is ICOST,
+    the Final Intra Cost FIC is like below,
+
+    FIC = ICOST + W
+
+    So, if this field is not zero,
+    the Final Intra Cost have additional weight. Then the Intra/Inter mode decision logic tend to make more Inter-Macroblock.
+    @endverbatim
+    */
+	int intraCostWeight;
+	/**
+    @verbatim
+    The quantization parameter for I frame
+
+    When this value is -1, the quantization
+    parameter for I frames is automatically determined by VPU. This value is ignored
+    in case of STD_MJPG
+    @endverbatim
+    */
+	//mp4 only
+	int rcIntraQp;
+	/**
+    @verbatim
+    A gamma is a smoothing factor in motion estimation. A value for gamma is
+    factor * 32768, the factor value is selected from the range 0 &le; factor &ge; 1.
+
+    @* If the factor value getting close to 0, Qp changes slowly.
+    @* If the factor value getting close to 1, Qp changes quickly.
+
+    The default gamma value is 0.75 * 32768
+    @endverbatim
+    */
+	int userGamma;
+	/**
+    @verbatim
+    Encoder Rate Control Mode setting
+
+    @* 0 : Normal mode rate control
+    @* 1 : FRAME_LEVEL rate control
+    @* 2 : SLICE_LEVEL rate control
+    @* 3 : USER DEFINED MB LEVEL rate control
+    @endverbatim
+    */
+	int rcIntervalMode;
+	/**
+    @verbatim
+    The user defined MB interval value
+
+    This value is used only when rcIntervalMode is 3.
+    @endverbatim
+    */
+	int mbInterval;
+	/**
+    @verbatim
+    Target bit rate in kbps
+
+    If 0, there is no rate control, and pictures are encoded with a quantization parameter equal to quantParam in EncParam.
+    @endverbatim
+    */
+	// [END] CODA9xx & WAVE320
+	int bitRate;
+	/**
+    @verbatim
+    Time delay (in mili-seconds)
+
+    It takes for the bitstream to reach initial occupancy of the vbv buffer from zero level.
+
+    This value is ignored if rate
+    control is disabled. The value 0 means the encoder does not check for reference
+    decoder buffer delay constraints.
+    @endverbatim
+    */
+	int initialDelay;
+	/**
+    @verbatim
+    @* WAVE420 
+    @** 0 : Rate control is off.
+    @** 1 : Rate control is on.
+
+    @* CODA9
+    @** 0 : Constant QP (VBR, rate control off)
+    @** 1 : Constant Bit-Rate (CBR)
+    @** 2 : Average Bit-Rate (ABR)
+    @** 4 : Picture level rate control
+    @endverbatim
+    */
+	int rcEnable;
+	/**
+    @* CODA9
+    @**
+    @**Combined with rcEnable, to indicates CBR function has been enable
+    */
+	int strictCBR;
+
+	union {
+		EncMp4Param
+			mp4Param; /**< The parameters for MPEG4 part 2 Visual  */
+		EncH263Param h263Param; /**< The parameters for ITU-T H.263 */
+		EncAvcParam avcParam; /**< The parameters for ITU-T H.263 */
+	} EncStdParam;
+
+	// Maverick-II Cache Configuration
+	/**
+    @verbatim
+    Enable or disable frame buffer cache
+
+    @* 0 : ME/MC CACHE
+    @* 1 : ME BYPASS/MC CACHE
+    @* 2 : MC BYPASS/ME CACHE
+    @* 3 : ME/MC BYPASS
+    @endverbatim
+    */
+	int frameCacheBypass;
+	/**
+    @verbatim
+    Cache burst value
+
+    @* 0 : Burst 4
+    @* 1 : Burst 8
+    @endverbatim
+    */
+	int frameCacheBurst;
+	/**
+    @verbatim
+    @* 0 : Horizontal no merge
+    @* 1 : Horizontal merge
+    @* 2 : Vertical no merge
+    @* 3 : Vertical merge
+    @endverbatim
+    */
+	int frameCacheMerge;
+	/**
+    @verbatim
+    Cache way size of luma and chroma.
+    This value range is from 0 to 15.
+
+    [0-15] {chroma[1:0], luma[1:0]}
+
+    @* Luma   [0,1 : 64x64, 2,3 : 128x32]
+    @* Chroma Separated   [0,1: 32x32, 2,3: 64x16]
+    @* Chroma Interleaved [0,1: 32x64, 2: 64x32, 3: 128x16]
+    @endverbatim
+    */
+	int frameCacheWayShape;
+	/**
+    @verbatim
+    @* 0 : CbCr data is written in separate frame memories (chroma separate mode)
+    @* 1 : CbCr data is interleaved in chroma memory. (chroma interleave mode)
+    @endverbatim
+    */
+	int cbcrInterleave;
+	/**
+    @verbatim
+    CbCr order in planar mode (YV12 format)
+
+    @* 0 : Cb data are written first and then Cr written in their separate plane.
+    @* 1 : Cr data are written first and then Cb written in their separate plane.
+    @endverbatim
+    */
+	int cbcrOrder;
+	/**
+    @verbatim
+    Frame buffer endianness
+
+    @* 0 : little endian format
+    @* 1 : big endian format
+    @* 2 : 32 bit little endian format
+    @* 3 : 32 bit big endian format
+    @* 16 ~ 31 : 128 bit endian format
+
+    NOTE: For setting specific values of 128 bit endiness, please refer to the 'WAVE4 Datasheet'.
+    @endverbatim
+    */
+	int frameEndian;
+	/**
+    @verbatim
+    Bistream buffer endianness
+
+    @* 0 : little endian format
+    @* 1 : big endian format
+    @* 2 : 32 bit little endian format
+    @* 3 : 32 bit big endian format
+    @* 16 ~ 31 : 128 bit endian format
+
+    NOTE: For setting specific values of 128 bit endiness, please refer to the 'WAVE4 Datasheet'.
+    @endverbatim
+    */
+	int streamEndian;
+	/**
+    @verbatim
+    Endianness of source YUV
+
+    @* 0 : Little endian format
+    @* 1 : Big endian format
+    @* 2 : 32 bit little endian format
+    @* 3 : 32 bit big endian format
+    @* 16 ~ 31 : 128 bit endian format
+
+    NOTE: For setting specific values of 128 bit endiness, please refer to the 'WAVE4 Datasheet'.
+    @endverbatim
+    */
+	int sourceEndian;
+	/**
+    @verbatim
+    It writes output with 8 burst in linear map mode.
+
+    @* 0 : Burst write back is disabled
+    @* 1 : Burst write back is enabled.
+
+    NOTE: WAVE4 does not support it.
+    @endverbatim
+    */
+	int bwbEnable;
+	/**
+    @verbatim
+    @* 0 : Disable
+    @* 1 : Enable
+
+    This flag is used for AvcEnc frame-based streaming with line buffer.
+    If coding standard is not AvcEnc or ringBufferEnable is 1, this flag is ignored.
+
+    If this field is set, VPU sends a buffer full interrupt when line buffer is full, and waits until the interrupt is cleared.
+    HOST should read the bitstream in line buffer and clear the interrupt.
+    If this field is not set, VPU does not send a buffer full interrupt when line buffer is full.
+    In both cases, VPU sets RET_ENC_PIC_FLAG register to 1 if line buffer is full.
+    @endverbatim
+    */
+	int lineBufIntEn;
+	/**
+    @verbatim
+    This flag indicates whether source images are in packed format.
+
+    @* 0 : Not packed mode
+    @* 1 : Packed mode
+    @endverbatim
+    */
+	int packedFormat;
+	/**
+    This flag indicates a color format of source image which is one among <<vpuapi_h_FrameBufferFormat>>.
+    */
+	int srcFormat;
+	int srcBitDepth;
+
+	/**
+    @verbatim
+    VPU core index number
+
+    * 0 ~ number of VPU core - 1
+    @endverbatim
+    */
+	Uint32 coreIdx;
+	/**
+    @verbatim
+    @* 0 : CbCr data is interleaved in chroma source frame memory. (NV12)
+    @* 1 : CrCb data is interleaved in chroma source frame memory. (NV21)
+    @endverbatim
+    */
+	int nv21;
+
+	Uint32 virtAxiID;
+	BOOL enablePTS; /**< An enable flag to report PTS(Presentation Timestamp. */
+	void *filp; // rtk, rtd16xxb_vdi_ioctl_open_instance() need this filp
+} EncOpenParam;
+
+/**
+* @brief    This is a data structure for parameters of VPU_EncGetInitialInfo() which
+is required to get the minimum required buffer count in HOST application. This
+returned value is used to allocate frame buffers in
+VPU_EncRegisterFrameBuffer().
+*/
+typedef struct {
+	int minFrameBufferCount; /**< Minimum number of frame buffer */
+	int minSrcFrameCount; /**< Minimum number of source buffer */
+} EncInitialInfo;
+
+/**
+* @brief    This is a data structure for setting ROI. (CODA9 encoder only).
+ */
+typedef struct {
+	/**
+    @verbatim
+    @* 0 : It disables ROI.
+    @* 1 : User can set QP value for both ROI and non-ROI region
+    @* 2 : User can set QP value for only ROI region (Currently, not support)
+    @endverbatim
+    */
+	int mode;
+	/**
+    @verbatim
+    Total number of ROI
+
+    The maximum value is MAX_ROI_NUMBER.
+    MAX_ROI_NUMBER can be either 10 or 50. In order to use MAX_ROI_NUMBER as 50,
+    SUPPORT_ROI_50 define needs to be enabled in the reference SW.
+    @endverbatim
+    */
+	int number;
+	VpuRect region[MAX_ROI_NUMBER]; /**< Rectangle information for ROI */
+	int qp[MAX_ROI_NUMBER]; /**< QP value for ROI region */
+} AvcRoiParam;
+
+/**
+* @brief    This is a data structure for setting NAL unit coding options.
+ */
+typedef struct {
+	int implicitHeaderEncode; /**< Whether HOST application encodes a header implicitly or not. If this value is 1, below encode options are ignored. */
+	int encodeVCL; /**< A flag to encode VCL nal unit explicitly */
+	int encodeVPS; /**< A flag to encode VPS nal unit explicitly */
+	int encodeSPS; /**< A flag to encode SPS nal unit explicitly */
+	int encodePPS; /**< A flag to encode PPS nal unit explicitly */
+	int encodeAUD; /**< A flag to encode AUD nal unit explicitly */
+	int encodeEOS; /**< A flag to encode EOS nal unit explicitly. This should be set when to encode the last source picture of sequence. */
+	int encodeEOB; /**< A flag to encode EOB nal unit explicitly. This should be set when to encode the last source picture of sequence. */
+	int encodeVUI; /**< A flag to encode VUI nal unit explicitly */
+	int encodeFiller; /**< A flag to encode Filler nal unit explicitly (WAVE5 only) */
+} EncCodeOpt;
+
+/**
+* @brief This is a data structure for configuring one frame encoding operation.
+ */
+typedef struct {
+	FrameBuffer *
+		sourceFrame; /**< This member must represent the frame buffer containing source image to be encoded. */
+	/**
+    @verbatim
+    If this value is 0, the picture type is determined by VPU
+    according to the various parameters such as encoded frame number and GOP size.
+
+    If this value is 1, the frame is encoded as an I-picture regardless of the
+    frame number or GOP size, and I-picture period calculation is reset to
+    initial state. In MPEG4 and H.263 case, I-picture is sufficient for decoder
+    refresh. In H.264/AVC case, the picture is encoded as an IDR (Instantaneous
+    Decoding Refresh) picture.
+
+    This value is ignored if skipPicture is 1.
+    @endverbatim
+    */
+	int forceIPicture;
+	/**
+    @verbatim
+    If this value is 0, the encoder encodes a picture as normal.
+
+    If this value is 1, the encoder ignores sourceFrame and generates a skipped
+    picture. In this case, the reconstructed image at decoder side is a duplication
+    of the previous picture. The skipped picture is encoded as P-type regardless of
+    the GOP size.
+    @endverbatim
+    */
+	int skipPicture;
+	int quantParam; /**< This value is used for all quantization parameters in case of VBR (no rate control).  */
+	/**
+    @verbatim
+    The start address of a picture stream buffer under line-buffer mode and dynamic
+    buffer allocation. (CODA encoder only)
+
+    This variable represents the start of a picture stream for encoded output. In
+    buffer-reset mode, HOST might use multiple picture stream buffers for the
+    best performance. By using this variable, applications could re-register the
+    start position of the picture stream while issuing a picture encoding operation.
+    This start address of this buffer must be 4-byte aligned, and its size is
+    specified the following variable, picStreamBufferSize. In packet-based streaming
+    with ring-buffer, this variable is ignored.
+
+    NOTE: This variable is only meaningful when both line-buffer mode and dynamic
+    buffer allocation are enabled.
+    @endverbatim
+    */
+	PhysicalAddress picStreamBufferAddr;
+	/**
+    @verbatim
+    The byte size of a picture stream chunk
+
+    This variable represents the byte size of a picture stream buffer. This variable is
+    so crucial in line-buffer mode. That is because encoder output could be
+    corrupted if this size is smaller than any picture encoded output. So this value
+    should be big enough for storing multiple picture streams with average size. In
+    packet-based streaming with ring-buffer, this variable is ignored.
+    @endverbatim
+    */
+	int picStreamBufferSize;
+	/**
+    @verbatim
+    @* 0 : progressive (frame) encoding mode
+    @* 1 : interlaced (field) encoding mode
+    @endverbatim
+    */
+	int fieldRun;
+	AvcRoiParam
+		setROI; /**< This value sets ROI. If setROI mode is 0, ROI does work and other member value of setROI is ignored. */
+
+	int forcePicQpEnable; /**< A flag to use a force picture quantization parameter */
+	int forcePicQpSrcOrderEnable; /**< A flag to use a force picture QP by source index order */
+	int forcePicQpI; /**< A force picture quantization parameter for I picture */
+	int forcePicQpP; /**< A force picture quantization parameter for P picture */
+	int forcePicQpB; /**< A force picture quantization parameter for B picture */
+	int forcePicTypeEnable; /**< A flag to use a force picture type */
+	int forcePicTypeSrcOrderEnable; /**< A flag to use a force picture type by source index order */
+	int forcePicType; /**< A force picture type (I, P, B, IDR, CRA) */
+	int srcIdx; /**< A source frame buffer index */
+	int srcEndFlag; /**< A flag indicating that there is no more source frame buffer to encode */
+
+	EncCodeOpt codeOption; /**< <<vpuapi_h_EncCodeOpt>> */
+
+	Uint32 useCurSrcAsLongtermPic; /**< A flag for the current picture to be used as a longterm reference picture later when other picture's encoding  */
+	Uint32 useLongtermRef; /**< A flag to use a longterm reference picture in DPB when encoding the current picture */
+	Uint32 pts; /**< The presentation Timestamp (PTS) of input source */
+
+} EncParam;
+
+/**
+* @brief This structure is used for reporting encoder information.
+*/
+typedef struct {
+	/**
+    @verbatim
+    @* 0 : reporting disable
+    @* 1 : reporting enable
+    @endverbatim
+    */
+	int enable;
+	int type; /**< This value is used for picture type reporting in MVInfo. */
+	int sz; /**< This value means size for each reporting data (MBinfo, MVinfo, Sliceinfo).    */
+	PhysicalAddress
+		addr; /**< The start address of each reporting buffer into which encoder puts data.  */
+} EncReportInfo;
+
+/**
+* @brief    This is a data structure for reporting the results of picture encoding operations.
+*/
+typedef struct {
+	/**
+    @verbatim
+    The Physical address of the starting point of newly encoded picture stream
+
+    If dynamic buffer allocation is enabled in line-buffer mode, this value is
+    identical with the specified picture stream buffer address by HOST.
+    @endverbatim
+    */
+	PhysicalAddress bitstreamBuffer;
+	Uint32 bitstreamSize; /**< The byte size of encoded bitstream */
+	int bitstreamWrapAround; /**< This is a flag to indicate whether bitstream buffer operates in ring buffer mode in which read and write pointer are wrapped arounded. If this flag is 1, HOST application needs a larger buffer. */
+	/**
+    @verbatim
+    Coded picture type
+
+    @* H.263 and MPEG4
+    @** 0 : I picture
+    @** 1 : P picture
+
+    @* H.264/AVC
+    @** 0 : IDR picture
+    @** 1 : Non-IDR picture
+    @endverbatim
+    */
+	int picType;
+	int numOfSlices; /**<  The number of slices of the currently being encoded Picture  */
+	int reconFrameIndex; /**<  A reconstructed frame index. The reconstructed frame is used for reference of future frame.  */
+	FrameBuffer
+		reconFrame; /**<  A reconstructed frame address and information. Please refer to <<vpuapi_h_FrameBuffer>>.  */
+	int rdPtr; /**<  A read pointer in bitstream buffer, which is where HOST has read encoded bitstream from the buffer */
+	int wrPtr; /**<  A write pointer in bitstream buffer, which is where VPU has written encoded bitstream into the buffer  */
+
+	// for WAVE420
+	int picSkipped; /**< A flag which represents whether the current encoding has been skipped or not. */
+	int numOfIntra; /**< The number of intra coded block */
+	int numOfMerge; /**< The number of merge block in 8x8 */
+	int numOfSkipBlock; /**< The number of skip block in 8x8 */
+	int avgCtuQp; /**< The average value of CTU QPs */
+	int encPicByte; /**< The number of encoded picture bytes   */
+	int encGopPicIdx; /**< GOP index of the current picture */
+	int encPicPoc; /**< POC(picture order count) value of the current picture */
+	int encSrcIdx; /**< Source buffer index of the current encoded picture */
+	int encVclNal; /**< Encoded NAL unit type of VCL */
+	int encPicCnt; /**< Encoded picture number */
+
+	// Report Information
+	EncReportInfo
+		mbInfo; /**<  The parameter for reporting MB data . Please refer to <<vpuapi_h_EncReportInfo>> structure. */
+	EncReportInfo
+		mvInfo; /**<  The parameter for reporting motion vector. Please refer to <<vpuapi_h_EncReportInfo>> structure. */
+	EncReportInfo
+		sliceInfo; /**<  The parameter for reporting slice information. Please refer to <<vpuapi_h_EncReportInfo>> structure. */
+	int frameCycle; /**<  The parameter for reporting the cycle number of decoding/encoding one frame.*/
+	Uint64 pts; /**< Presentation Timestamp of encoded picture. */
+	Uint32 encInstIdx; /**< An index of instance which have finished encoding with a picture at this command. This is only for Multi-Core encoder product. */
+	Uint32 encPrepareCycle;
+	Uint32 encProcessingCycle;
+	Uint32 encEncodingCycle;
+} EncOutputInfo;
+
+/**
+ * @brief   This structure is used when HOST processor additionally wants to get SPS data or
+PPS data from encoder instance. The resulting SPS data or PPS data can be used
+in real applications as a kind of out-of-band information.
+*/
+typedef struct {
+	PhysicalAddress
+		paraSet; /**< An array of 32 bits which contains SPS RBSP */
+	int size; /**< The size of stream in byte */
+} EncParamSet;
+
+/**
+ * @brief   This structure is used for adding a header syntax layer into the encoded bit
+stream. The parameter headerType is the input parameter to VPU, and the
+other two parameters are returned values from VPU after completing
+requested operation.
+*/
+typedef struct {
+	PhysicalAddress
+		buf; /**< A physical address pointing the generated stream location  */
+	BYTE *pBuf; /**< The virtual address according to buf. This address is needed when a HOST wants to access encoder header bitstream buffer. */
+	size_t size; /**< The size of the generated stream in bytes */
+	Int32 headerType; /**< This is a type of header that HOST wants to generate and have values as VOL_HEADER, VOS_HEADER, VO_HEADER, SPS_RBSP or PPS_RBSP. */
+	BOOL zeroPaddingEnable; /**< It enables header to be padded at the end with zero for byte alignment. */
+	Int32 failReasonCode; /**< Not defined yet */
+} EncHeaderParam;
+
+/**
+ * @brief   This is a special enumeration type for MPEG4 top-level header classes such as
+visual sequence header, visual object header and video object layer header.
+It is for MPEG4 encoder only.
+*/
+typedef enum {
+	VOL_HEADER, /**< Video object layer header */
+	VOS_HEADER, /**< Visual object sequence header */
+	VIS_HEADER /**< Video object header */
+} Mp4HeaderType;
+
+/**
+ * @brief   This is a special enumeration type for AVC parameter sets such as sequence
+parameter set and picture parameter set. It is for AVC encoder only.
+*/
+typedef enum {
+	SPS_RBSP, /**< Sequence parameter set */
+	PPS_RBSP, /**< Picture parameter set  */
+	SPS_RBSP_MVC, /**< Subset sequence parameter set */
+	PPS_RBSP_MVC, /**< Picture parameter set for dependent view */
+} AvcHeaderType;
+
+/**
+ * @brief   This is a special enumeration type for explicit encoding headers such as VPS, SPS, PPS. (WAVE encoder only)
+*/
+typedef enum {
+	CODEOPT_ENC_VPS =
+		(1 << 2), /**< A flag to encode VPS nal unit explicitly */
+	CODEOPT_ENC_SPS =
+		(1 << 3), /**< A flag to encode SPS nal unit explicitly */
+	CODEOPT_ENC_PPS =
+		(1 << 4), /**< A flag to encode PPS nal unit explicitly */
+} HevcHeaderType;
+
+/**
+ * @brief   This is a special enumeration type for NAL unit coding options
+*/
+typedef enum {
+	CODEOPT_ENC_HEADER_IMPLICIT =
+		(1
+		 << 0), /**< A flag to encode (a) headers (VPS, SPS, PPS) implicitly for generating bitstreams conforming to spec. */
+	CODEOPT_ENC_VCL =
+		(1 << 1), /**< A flag to encode VCL nal unit explicitly */
+} ENC_PIC_CODE_OPTION;
+
+/**
+ * @brief   This is a special enumeration type for defining GOP structure presets.
+*/
+typedef enum {
+	PRESET_IDX_CUSTOM_GOP = 0, /**< User defined GOP structure */
+	PRESET_IDX_ALL_I = 1, /**< All Intra, gopsize = 1 */
+	PRESET_IDX_IPP = 2, /**< Consecutive P, cyclic gopsize = 1  */
+	PRESET_IDX_IBBB = 3, /**< Consecutive B, cyclic gopsize = 1  */
+	PRESET_IDX_IBPBP = 4, /**< gopsize = 2  */
+	PRESET_IDX_IBBBP = 5, /**< gopsize = 4  */
+	PRESET_IDX_IPPPP = 6, /**< Consecutive P, cyclic gopsize = 4 */
+	PRESET_IDX_IBBBB = 7, /**< Consecutive B, cyclic gopsize = 4 */
+	PRESET_IDX_RA_IB = 8, /**< Random Access, cyclic gopsize = 8 */
+} GOP_PRESET_IDX;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+* @brief This function returns whether processing a frame by VPU is completed or not.
+* @return
+@verbatim
+@* 0 : VPU hardware is idle.
+@* Non-zero value : VPU hardware is busy with processing a frame.
+@endverbatim
+*/
+Int32 VPU_IsBusy(Uint32 coreIdx /**< [input] An index of VPU core */
+);
+
+/**
+* @brief
+@verbatim
+This function makes HOST application wait until VPU finishes processing a frame,
+or check a busy flag of VPU during the given timeout period.
+The behavior of this function depends on VDI layer\'s implementation.
+
+NOTE: Timeout may not work according to implementation of VDI layer.
+@endverbatim
+* @param coreIdx [input] An index of VPU core
+* @param timeout [output] See return value.
+* @return
+@verbatim
+* 1 : Wait time out
+* Non -1 value : The value of InterruptBit
+@endverbatim
+*/
+Int32 VPU_WaitInterrupt(Uint32 coreIdx, int timeout);
+
+Int32 VPU_WaitInterruptEx(VpuHandle handle, int timeout);
+
+/**
+ * @brief This function returns whether VPU is currently running or not.
+ * @param coreIdx [input] An index of VPU core
+* @return
+@verbatim
+@* 0 : VPU is not running.
+@* 1 or more : VPU is running.
+@endverbatim
+ */
+Int32 VPU_IsInit(Uint32 coreIdx);
+
+/**
+* @brief
+@verbatim
+This function initializes VPU hardware and its data
+structures/resources. HOST application must call this function only once before calling
+VPU_DeInit().
+
+NOTE: Before use, HOST application needs to define the header file path of BIT firmware to BIT_CODE_FILE_PATH.
+@endverbatim
+*/
+RetCode VPU_Init(
+	Uint32 coreIdx, /**<[input] An index of VPU core. This value can be from 0 to (number of VPU core - 1).*/
+	void *videc_dev
+);
+
+/**
+* @brief
+@verbatim
+This function initializes VPU hardware and its data structures/resources.
+HOST application must call this function only once before calling VPU_DeInit().
+
+VPU_InitWithBitcodec() is basically same as VPU_Init() except that it takes additional arguments, a buffer pointer where
+BIT firmware binary is located and the size.
+HOST application can use this function when they wish to load a binary format of BIT firmware,
+instead of it including the header file of BIT firmware.
+Particularly in multi core running environment with different VPU products,
+this function must be used because each core needs to load different firmware.
+@endverbatim
+*
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means VPU has been initialized successfully.
+*RETCODE_CALLED_BEFORE* ::
+This function call is invalid which means multiple calls of the current API function
+for a given instance are not allowed. In this case, VPU has been already
+initialized, so that this function call is meaningless and not allowed anymore.
+*RETCODE_NOT_FOUND_BITCODE_PATH* ::
+The header file path of BIT firmware has not been defined.
+*RETCODE_VPU_RESPONSE_TIMEOUT* ::
+Operation has not received any response from VPU and has timed out.
+*RETCODE_FAILURE* ::
+Operation was failed.
+@endverbatim
+*/
+RetCode VPU_InitWithBitcode(
+	Uint32 coreIdx, /**< [Input] An index of VPU core */
+	const Uint16 *
+		bitcode, /**< [Input] Buffer where binary format of BIT firmware is located */
+	Uint32 sizeInWord, /**< [Input] Size of binary BIT firmware in short integer */
+	void *videc_dev
+);
+
+/**
+* @brief    This function frees all the resources allocated by VPUAPI and releases the device driver.
+VPU_Init() and VPU_DeInit() always work in pairs.
+* @return none
+*/
+RetCode VPU_DeInit(Uint32 coreIdx /**< [Input] An index of VPU core */
+);
+
+/**
+* @brief This function returns the number of instances opened.
+* @return      The number of instances opened
+*/
+int VPU_GetOpenInstanceNum(Uint32 coreIdx /**< [Input] An index of VPU core */
+);
+
+/**
+* @brief This function returns the product information of VPU which is currently running on the system.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means version information is acquired
+successfully.
+*RETCODE_FAILURE* ::
+Operation was failed, which means the current firmware does not contain any version
+information.
+*RETCODE_NOT_INITIALIZED* ::
+VPU was not initialized at all before calling this function. Application should
+initialize VPU by calling VPU_Init() before calling this function.
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding operation was not completed yet, so the given API
+function call cannot be performed this time. A frame-decoding operation should
+be completed by calling VPU_Dec Info(). Even though the result of the
+current frame operation is not necessary, HOST application should call
+VPU_DecGetOutputInfo() to proceed this function call.
+*RETCODE_VPU_RESPONSE_TIMEOUT* ::
+Operation has not received any response from VPU and has timed out.
+@endverbatim
+*/
+RetCode VPU_GetVersionInfo(
+	Uint32 coreIdx, /**< [Input] An index of VPU core */
+	/**
+    @verbatim
+    [Output]
+
+    @* Version_number[15:12] - Major revision
+    @* Version_number[11:8] - Hardware minor revision
+    @* Version_number[7:0] - Software minor revision
+    @endverbatim
+    */
+	Uint32 *versionInfo,
+	Uint32 *revision, /**< [Output] Revision information  */
+	Uint32 *productId /**< [Output] Product information. Refer to the <<vpuapi_h_ProductId>> enumeration */
+);
+
+/* RTK */
+RetCode VPU_DecSetDispFlag(DecHandle handle, int dispFlag);
+
+/**
+* @brief This function clears VPU interrupts that are pending.
+* @return      none
+*/
+void VPU_ClearInterrupt(Uint32 coreIdx /**< [Input] An index of VPU core */
+);
+
+void VPU_ClearInterruptEx(VpuHandle handle,
+			  Int32 intrFlag /**< An interrupt flag to be cleared */
+);
+
+/**
+* @brief
+@verbatim
+
+This function stops operation of the current frame and initializes VPU hardware by sending reset signals.
+It can be used when VPU is having a longer delay or seems hang-up.
+After VPU has completed initialization, the context is rolled back to the state
+before calling the previous VPU_DecStartOneFrame() or VPU_EncStartOneFrame().
+HOST can resume decoding from the next picture, instead of decoding from the sequence header.
+It works only for the current instance, so this function does not affect other instance\'s running in multi-instance operation.
+
+This is some applicable scenario of using `VPU_SWReset()` when a series of hang-up happens.
+For example, when VPU is hung up with frame 1, HOST application calls `VPU_SWReset()` to initialize VPU and then calls `VPU_DecStartOneFrame()` for frame 2
+with specifying the start address, read pointer.
+If there is still problem with frame 2, we recommend calling `VPU_SWReset()` and `seq_init()` or calling `VPU_SWReset()` and enabling iframe search.
+@endverbatim
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means required information of the stream data to be
+decoded was received successfully.
+@endverbatim
+ */
+RetCode VPU_SWReset(Uint32 coreIdx, /**<[Input] An index of VPU core */
+		    /**
+    @verbatim
+    [Input] Way of reset
+
+    @* SW_RESET_SAFETY : It waits until AXI bus completes ongoing tasks. If remaining bus transactions are done, VPU enters the reset process. (recommended mode)
+    @* SW_RESET_FORCE : It forces to reset VPU no matter whether bus transactions are completed or not. It might affect what other blocks do with bus, so we do not recommend using this mode.
+    @* SW_RESET_ON_BOOT : This is the default reset mode that is executed once system boots up. This mode is actually executed in VPU_Init(), so does not have to be used independently.
+    @endverbatim
+    */
+		    SWResetMode resetMode, void *pendingInst);
+
+/**
+* @brief
+@verbatim
+This function resets VPU as VPU_SWReset() does, but
+it is done by the system reset signal and all the internal contexts are initialized.
+Therefore after the `VPU_HWReset()`, HOST application needs to call `VPU_Init()`.
+
+`VPU_HWReset()` requires vdi_hw_reset part of VDI module to be implemented before use.
+@endverbatim
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means required information of the stream data to be decoded was received successfully.
+@endverbatim
+ */
+RetCode VPU_HWReset(Uint32 coreIdx /**<  [Input] An index of VPU core */
+);
+
+/**
+* @brief
+@verbatim
+This function saves or restores context when VPU powers on/off.
+
+NOTE: This is a tip for safe operation -
+    call this function to make VPU enter into a sleep state before power down, and
+    after the power off call this function again to return to a wake state.
+@endverbatim
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means required information of the stream data to be decoded was received successfully.
+@endverbatim
+ */
+RetCode VPU_SleepWake(Uint32 coreIdx, /**< [Input] An index of VPU core */
+		      /**
+    @verbatim
+    [Input]
+
+    @* 1 : saves all of the VPU contexts and converts into a sleep state.
+    @* 0 : restores all of the VPU contexts and converts back to a wake state.
+    @endverbatim
+    */
+		      int iSleepWake);
+
+/**
+* @brief    This function returns the size of motion vector co-located buffer that are needed to decode H.265/AVC stream.
+*           The mvcol buffer should be allocated along with frame buffers and given to VPU_DecRegisterFramebuffer() as an argument.
+* @return   It returns the size of required mvcol buffer in byte unit.
+*/
+int VPU_GetMvColBufSize(CodStd codStd, /**< [Input] Video coding standards */
+			int width, /**< [Input] Width of framebuffer */
+			int height, /**< [Input] Height of framebuffer */
+			int num /**< [Input] Number of framebuffers. */
+);
+
+/**
+* @brief    This function returns the size of FBC (Frame Buffer Compression) offset table for luma and chroma.
+*           The offset tables are to look up where compressed data is located.
+*           HOST should allocate the offset table buffers for luma and chroma as well as frame buffers
+*           and give their base addresses to VPU_DecRegisterFramebuffer() as an argument.
+*
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means given value is valid and setting is done successfully.
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, ysize, csize, or handle was NULL.
+@endverbatim
+*/
+RetCode VPU_GetFBCOffsetTableSize(
+	CodStd codStd, /**< [Input] Video coding standards */
+	int width, /**< [Input] Width of framebuffer */
+	int height, /**< [Input] Height of framebuffer  */
+	int *ysize, /**< [Output] Size of offset table for Luma in bytes */
+	int *csize /**< [Output] Size of offset table for Chroma in bytes */
+);
+
+/**
+*  @brief   This function returns the size of frame buffer that is required for VPU to decode or encode one frame.
+*
+*  @return  The size of frame buffer to be allocated
+*/
+int VPU_GetFrameBufSize(
+	int coreIdx, /**< [Input] VPU core index number */
+	int stride, /**< [Input] The stride of image  */
+	int height, /**< [Input] The height of image */
+	int mapType, /**< [Input] The map type of framebuffer */
+	int format, /**< [Input] The color format of framebuffer */
+	int interleave, /**< [Input] Whether to use CBCR interleave mode or not */
+	DRAMConfig *
+		pDramCfg /**< [Input] Attributes of DRAM. It is only valid for CODA960. Set NULL for this variable in case of other products. */
+);
+
+/**
+ *  @brief  This function returns the product ID of VPU which is currently running.
+ *  @return Product information. Please refer to the <<vpuapi_h_ProductId>> enumeration.
+ */
+int VPU_GetProductId(int coreIdx /**< [Input] VPU core index number */
+);
+
+// function for decode
+/**
+*  @brief In order to decode, HOST application must open the decoder. By calling this function, HOST application can get a handle by which they can refer to a decoder instance. Because the VPU is multiple instance codec, HOST application needs this kind of handle. Once a HOST application gets a handle, the HOST application must pass this handle to all subsequent decoder-related functions.
+*
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means a new decoder instance was created
+successfully.
+*RETCODE_FAILURE* ::
+Operation was failed, which means getting a new decoder instance was not done
+successfully. If there is no free instance anymore, this value is returned
+in this function call.
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, pOpenParam, was invalid, which means it has a null
+pointer, or given values for some member variables are improper values.
+*RETCODE_NOT_INITIALIZED* ::
+This means VPU was not initialized yet before calling this function.
+Applications should initialize VPU by calling VPU_Init() before calling this
+function.
+@endverbatim
+ */
+RetCode VPU_DecOpen(
+	DecHandle *
+		pHandle, /**< [Output] A pointer to a DecHandle type variable which specifies each instance for HOST application. */
+	DecOpenParam *
+		pop /**< [Input] A pointer to a DecOpenParam type structure which describes required parameters for creating a new decoder instance. */
+);
+
+/**
+ *  @brief      When HOST application finished decoding a sequence and wanted to release this
+instance for other processing, the applicaton should close this instance. After
+completion of this function call, the instance referred to by handle gets
+free. Once a HOST application closes an instance, the HOST application cannot call any further
+decoder-specific function with the current handle before re-opening a new
+decoder instance with the same handle.
+*  @return
+ @verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means the current decoder instance was closed
+successfully.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, handle, was invalid.
+This return code might be caused if
+
+* `handle` is not the handle which has been obtained by VPU_DecOpen()
+* `handle` is the handle of an instance which has been closed already, etc.
+--
+*RETCODE_VPU_RESPONSE_TIMEOUT* ::
+Operation has not received any response from VPU and has timed out.
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding operation was not completed yet, so the given API
+function call cannot be performed this time. A frame decoding operation should
+be completed by calling VPU_DecGetOutputInfo(). Even though the result of the
+current frame operation is not necessary, HOST application should call
+VPU_DecGetOutputInfo() to proceed this function call.
+function.
+@endverbatim
+ */
+RetCode VPU_DecClose(
+	DecHandle handle /**< [Output] A decoder handle obtained from VPU_DecOpen() */
+);
+
+/**
+ * @brief
+@verbatim
+Applications must pass the address of <<vpuapi_h_DecInitialInfo>> structure, where the
+decoder stores information such as picture size, number of necessary frame
+buffers, etc. For the details, see definition of <<vpuapi_h_DecInitialInfo>> data structure.
+This function should be called once after creating a decoder instance and before starting frame decoding.
+
+It is a HOST application\'s responsibility to provide sufficient amount of bitstream to
+the decoder by calling VPU_DecUpdateBitstreamBuffer() so that bitstream buffer
+does not get empty before this function returns.
+If HOST application cannot ensure to feed stream enough, they can use the Forced
+Escape option by using VPU_DecSetEscSeqInit().
+@endverbatim
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means required information of the stream
+data to be decoded was received successfully.
+*RETCODE_FAILURE* ::
+Operation was failed, which means there was an error in getting information for
+configuring the decoder.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid.
+This return code might be caused if
+
+* `handle` is not a handle which has been obtained by VPU_DecOpen().
+* `handle` is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, pInfo, was invalid, which means it has a null
+pointer, or given values for some member variables are improper values.
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding operation was not completed yet, so the given API
+function call cannot be performed this time. A frame decoding operation should
+be completed by calling  VPU_DecGetOutputInfo(). Even though the result of the
+current frame operation is not necessary, HOST should call
+VPU_DecGetOutputInfo() to proceed this function call.
+*RETCODE_WRONG_CALL_SEQUENCE* ::
+This means the current API function call was invalid considering the allowed
+sequences between API functions. In this case, HOST might call this
+function before successfully putting bitstream data by calling
+VPU_DecUpdateBitstreamBuffer(). In order to perform this functions call,
+bitstream data including sequence level header should be transferred into
+bitstream buffer before calling VPU_DecGetInitialInfo().
+*RETCODE_CALLED_BEFORE* ::
+This function call might be invalid, which means multiple calls of the current API
+function for a given instance are not allowed. In this case, decoder initial
+information has been already received, so that this function call is meaningless
+and not allowed anymore.
+*RETCODE_VPU_RESPONSE_TIMEOUT* ::
++
+--
+Operation has not received any response from VPU and has timed out.
+
+NOTE: When this function returns RETCODE_SUCCESS, HOST should call VPU_ClearInterrupt() function to clear out the interrupt pending status.
+--
+@endverbatim
+ */
+RetCode VPU_DecGetInitialInfo(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+	DecInitialInfo *
+		info /**< [Output] A pointer to <<vpuapi_h_DecInitialInfo>> data structure */
+);
+
+/**
+ * @brief
+@verbatim
+This function starts decoding sequence header. Returning from this function does not mean
+the completion of decoding sequence header, and it is just that decoding sequence header was initiated.
+Every call of this function should be matched with VPU_DecCompleteSeqInit() with the same handle.
+Without calling a pair of these funtions, HOST can not call any other API functions
+except for VPU_IsBusy(), VPU_DecGetBitstreamBuffer(), and VPU_DecUpdateBitstreamBuffer().
+
+A pair of this function and VPU_DecCompleteSeqInit() or VPU_DecGetInitialInfo() should be called
+at least once after creating a decoder instance and before starting frame decoding.
+@endverbatim
+*
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means required information of the stream data to be
+decoded was received successfully
+*RETCODE_FAILURE* ::
+Operation was failed, which means there was an error in getting information for configuring
+the decoder.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid. This return
+code might be caused if
+
+* `handle` is not a handle which has been obtained by VPU_DecOpen().
+* `handle` is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding operation was not completed yet, so the given API function call
+cannot be performed this time. A frame decoding operation should be completed by calling
+VPU_DecIssueSeqInit (). Even though the result of the current frame operation is not necessary,
+HOST should call VPU_DecIssueSeqInit () to proceed this function call.
+*RETCODE_WRONG_CALL_SEQUENCE* ::
+This means the current API function call was invalid considering the allowed sequences between
+API functions. In this case, HOST application might call this function before successfully putting
+bitstream data by calling VPU_DecUpdateBitstreamBuffer(). In order to perform this functions
+call, bitstream data including sequence level header should be transferred into bitstream buffer
+before calling VPU_ DecIssueSeqInit ().
+@endverbatim
+ */
+RetCode VPU_DecIssueSeqInit(
+	DecHandle handle /**<  [Input] A decoder handle obtained from VPU_DecOpen() */
+);
+
+/**
+ * @brief Application can get the information about sequence header.
+Applications must pass the address of DecInitialInfo structure, where the decoder stores
+information such as picture size, number of necessary frame buffers, etc.
+For more details, see definition of the section called the DecInitialInfo data structure.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means required information of the stream data to be
+decoded was received successfully.
+*RETCODE_FAILURE* ::
+Operation was failed, which means there was an error in getting information for configuring
+the decoder.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid. This return
+code might be caused if
+
+* `handle` is not a handle which has been obtained by VPU_DecOpen().
+* `handle` is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, pInfo, was invalid, which means it has a null pointer, or given
+values for some member variables are improper values.
+*RETCODE_WRONG_CALL_SEQUENCE* ::
+This means the current API function call was invalid considering the allowed sequences between
+API functions. It might happen because VPU_DecIssueSeqInit () with the same handle was
+not called before calling this function
+*RETCODE_CALLED_BEFORE* ::
+This function call might be invalid, which means multiple calls of the current API function for a given
+instance are not allowed. In this case, decoder initial information has been already received,
+so that this function call is meaningless and not allowed anymore.
+@endverbatim
+ */
+RetCode VPU_DecCompleteSeqInit(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+	DecInitialInfo *
+		info /**< [Output] A pointer to DecInitialInfo data structure */
+);
+
+/**
+ *  @brief  This is a special function to provide a way of escaping VPU hanging during DEC_SEQ_INIT.
+When this flag is set to 1 and stream buffer empty happens, VPU terminates automatically
+DEC_SEQ_INIT operation. If target applications ensure that high layer header syntax is
+periodically sent through the channel, they do not need to use this option. But if target applications
+cannot ensure that such as file-play, it might be very useful to avoid VPU hanging without HOST timeout caused
+by crucial errors in header syntax.
+*
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means Force escape flag is successfully provided to
+BIT Processor.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid. This return
+code might be caused if
+
+* `handle` is not the handle which has been obtained by VPU_DecOpen().
+* `handle` is the handle of an instance which has been closed already, etc.
+* bitstreamMode of DecOpenParam structure is not BS_MODE_INTERRUPT.
+--
+@endverbatim
+*/
+RetCode VPU_DecSetEscSeqInit(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+	int escape /**< [Input] A flag to enable or disable forced escape from SEQ_INIT */
+);
+
+/**
+ * @brief This function is used for registering frame buffers with the acquired
+information from VPU_DecGetInitialInfo(). The frame buffers pointed to by
+bufArray are managed internally within VPU. These include reference
+frames, reconstructed frame, etc. Applications must not change the contents of
+the array of frame buffers during the life time of the instance, and `num` must
+not be less than `minFrameBufferCount` obtained by VPU_DecGetInitialInfo().
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means registering frame buffer
+information was done successfully.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid.
+This return code might be caused if
+
+* `handle` is not a handle which has been obtained by VPU_DecOpen().
+* `handle` is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding operation was not completed yet, so the given API
+function call cannot be performed this time. A frame decoding operation should
+be completed by calling VPU_DecGetOutputInfo(). Even though the result of the
+current frame operation is not necessary, HOST should call
+VPU_DecGetOutputInfo() to proceed this function call.
+*RETCODE_WRONG_CALL_SEQUENCE* ::
+This means the current API function call was invalid considering the allowed
+sequences between API functions. A HOST might call this
+function before calling VPU_DecGetInitialInfo() successfully. This function
+should be called after successful calling VPU_DecGetInitialInfo().
+*RETCODE_INVALID_FRAME_BUFFER* ::
+This happens when pBuffer was invalid, which means pBuffer was not initialized
+yet or not valid anymore.
+*RETCODE_INSUFFICIENT_FRAME_BUFFERS* ::
+This means the given number of frame buffers, num, was not enough for the
+decoder operations of the given handle. It should be greater than or equal to
+the value   requested by VPU_DecGetInitialInfo().
+*RETCODE_INVALID_STRIDE* ::
+The given argument stride was invalid, which means it is smaller than the
+decoded picture width, or is not a multiple of 8 in this case.
+*RETCODE_CALLED_BEFORE* ::
+This function call is invalid which means multiple calls of the current API function
+for a given instance are not allowed. In this case, registering decoder frame
+buffers has been already done, so that this function call is meaningless and not
+allowed anymore.
+*RETCODE_VPU_RESPONSE_TIMEOUT* ::
+Operation has not recieved any response from VPU and has timed out.
+@endverbatim
+ */
+RetCode VPU_DecRegisterFrameBuffer(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+	FrameBuffer *
+		bufArray, /**< [Input] Allocated frame buffer address and information. If this parameter is set to 0, VPU allocates frame buffers. */
+	int num, /**< [Input] A number of frame buffers. VPU can allocate frame buffers as many as this given value. */
+	int stride, /**< [Input] A stride value of the given frame buffers  */
+	int height, /**< [Input] Frame height   */
+	/**
+    @verbatim
+    [Input]
+    Map type of frame buffer The distance between a pixel in a row and the corresponding pixel in the next
+    row is called a stride. It comes from 64-bit access unit of AXI.
+
+    The stride for luminance frame buffer should be at least equal or greater than the width of picture
+    and a multiple of 8. It means the least significant 3-bit of the 13-bit stride should be always 0.
+    The stride for chrominance frame buffers is the half of the luminance stride.
+    So in case Cb/Cr non-interleave (separate Cb/Cr) map is used, make sure the stride for luminance frame buffer
+     should be a multiple of 16 so that the stride for chrominance frame buffer can become a multiple of 8.
+    @endverbatim
+    */
+	int mapType);
+
+/**
+ * @brief This function is used for registering frame buffers with the acquired
+information from VPU_DecGetInitialInfo().
+This function is functionally same as VPU_DecRegisterFrameBuffer(), but
+it can give linear (display) frame buffers and compressed buffers separately with different numbers
+unlike the way VPU_DecRegisterFrameBuffer() does.
+VPU_DecRegisterFrameBuffer() assigns only the same number of frame buffers for linear buffer and for compressed buffer,
+which can take up huge memory space.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means registering frame buffer
+information was done successfully.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid.
+This return code might be caused if
+
+* `handle` is not a handle which has been obtained by VPU_DecOpen().
+* `handle` is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding operation was not completed yet, so the given API
+function call cannot be performed this time. A frame decoding operation should
+be completed by calling VPU_DecGetOutputInfo(). Even though the result of the
+current frame operation is not necessary, HOST should call
+VPU_DecGetOutputInfo() to proceed this function call.
+*RETCODE_WRONG_CALL_SEQUENCE* ::
+This means the current API function call was invalid considering the allowed
+sequences between API functions. A HOST might call this
+function before calling VPU_DecGetInitialInfo() successfully. This function
+should be called after successful calling VPU_DecGetInitialInfo().
+*RETCODE_INVALID_FRAME_BUFFER* ::
+This happens when pBuffer was invalid, which means pBuffer was not initialized
+yet or not valid anymore.
+*RETCODE_INSUFFICIENT_FRAME_BUFFERS* ::
+This means the given number of frame buffers, num, was not enough for the
+decoder operations of the given handle. It should be greater than or equal to
+the value   requested by VPU_DecGetInitialInfo().
+*RETCODE_INVALID_STRIDE* ::
+The given argument stride was invalid, which means it is smaller than the
+decoded picture width, or is not a multiple of 8 in this case.
+*RETCODE_CALLED_BEFORE* ::
+This function call is invalid which means multiple calls of the current API function
+for a given instance are not allowed. In this case, registering decoder frame
+buffers has been already done, so that this function call is meaningless and not
+allowed anymore.
+*RETCODE_VPU_RESPONSE_TIMEOUT* ::
+Operation has not recieved any response from VPU and has timed out.
+@endverbatim
+ */
+RetCode VPU_DecRegisterFrameBufferEx(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+	FrameBuffer *
+		bufArray, /**< [Input] Allocated frame buffer address and information. If this parameter is set to 0, VPU allocates frame buffers. */
+	int numOfDecFbs, /**< [Input] Number of compressed frame buffer  */
+	int numOfDisplayFbs, /**< [Input] Number of linear frame buffer when WTL is enabled. In WAVE4, this should be equal to or larger than framebufDelay of <<vpuapi_h_DecInitialInfo>> + 2. */
+	int stride, /**< [Input] A stride value of the given frame buffers  */
+	int height, /**< [Input] Frame height   */
+	int mapType /**< [Input] A Map type for GDI inferface or FBC (Frame Buffer Compression) For detailed map options, please refer to the <<vpuapi_h_TiledMapType>>.   */
+);
+
+RetCode VPU_DecUpdateFrameBuffer(DecHandle handle, FrameBuffer *fbcFb,
+				 FrameBuffer *linearFb, Int32 mvColIndex,
+				 Int32 picWidth, Int32 picHeight);
+
+/**
+* @brief
+This is a special function that enables HOST to allocate directly the frame buffer
+for decoding (Recon) or for display or post-processor unit (PPU) such as Rotator
+or Tiled2Linear.
+In normal operation, VPU API allocates frame buffers when the argument `bufArray` in VPU_DecRegisterFrameBuffer() is set to 0.
+However, for any other reason HOST can use this function to allocate frame buffers by themselves.
+ * @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means the framebuffer is allocated successfully.
+*RETCODE_INVALID_HANDLE* ::
+This means the given handle for the current API function call, handle, was invalid. This return code might be caused if
++
+--
+* `handle` is not the handle which has been obtained by VPU_DecOpen().
+* `handle` is the handle of an instance which has been closed already, etc.
+--
+*RETCODE_WRONG_CALL_SEQUENCE* ::
+This means the current API function call was invalid considering the allowed sequences between API functions.
+It might happen because VPU_DecRegisterFrameBuffer() for (FramebufferAllocType.FB_TYPE_CODEC) has not been called,
+before this function call for allocating frame buffer for PPU (FramebufferAllocType.FB_TYPE_PPU).
+*RETCODE_INSUFFICIENT_RESOURCE* ::
+Fail to allocate a framebuffer due to lack of memory
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, index, was invalid, which means it has improper values.
+@endverbatim
+
+ */
+RetCode VPU_DecAllocateFrameBuffer(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+	FrameBufferAllocInfo
+		info, /**< [Input] Information required for frame bufer allocation */
+	FrameBuffer *
+		frameBuffer /**< [Output] Data structure that holds information of allocated frame buffers */
+);
+
+/**
+* @brief
+@verbatim
+This function returns the frame buffer information that was allocated by VPU_DecRegisterFrameBuffer() function.
+
+It does not affect actual decoding and simply does obtain the information of frame buffer.
+This function is more helpful especially when frame buffers are automatically assigned by
+setting 0 to `bufArray` of VPU_DecRegisterFrameBuffer() and HOST wants to know about the allocated frame buffer.
+@endverbatim
+*
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means registering frame buffer
+information was done successfully.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid.
+This return code might be caused if
+
+* `handle` is not a handle which has been obtained by VPU_DecOpen().
+* `handle` is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, frameIdx, was invalid, which means frameIdx is larger than allocated framebuffer.
+@endverbatim
+ */
+RetCode VPU_DecGetFrameBuffer(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+	int frameIdx, /**< [Input] An index of frame buffer */
+	FrameBuffer *
+		frameBuf /**< [output] Allocated frame buffer address and information.  */
+);
+
+/**
+* @brief
+@verbatim
+Before decoding bitstream, HOST application must feed the decoder with bitstream. To
+do that, HOST application must know where to put bitstream and the maximum size.
+Applications can get the information by calling this function. This way is more
+efficient than providing arbitrary bitstream buffer to the decoder as far as
+VPU is concerned.
+
+The given size is the total sum of free space in ring buffer. So when
+a HOST application downloads this given size of bitstream, Wrptr could meet the end of
+stream buffer. In this case, the HOST application should wrap-around the Wrptr back to the
+beginning of stream buffer, and download the remaining bits. If not, decoder
+operation could be crashed.
+@endverbatim
+*
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means required information for decoder
+stream buffer was received successfully.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid.
+This return code might be caused if
+
+* `handle` is not the handle which has been obtained by VPU_DecOpen().
+* `handle` is the handle of an instance which has been closed already, etc.
+--
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, pRdptr, pWrptr or size, was invalid, which means
+it has a null pointer, or given values for some member variables are improper
+values.
+@endverbatim
+*/
+RetCode VPU_DecGetBitstreamBuffer(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen()   */
+	PhysicalAddress *
+		prdPrt, /**< [Output] A stream buffer read pointer for the current decoder instance  */
+	PhysicalAddress *
+		pwrPtr, /**< [Output] A stream buffer write pointer for the current decoder instance   */
+	Uint32 *size /**< [Output] A variable specifying the available space in bitstream buffer for the current decoder instance   */
+);
+
+// RTHA-133, for PIC_END + ring buffer
+RetCode VPU_DecGetBitstreamBufferEx(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen()   */
+	PhysicalAddress *
+		prdPrt, /**< [Output] A stream buffer read pointer for the current decoder instance  */
+	PhysicalAddress *
+		pwrPtr, /**< [Output] A stream buffer write pointer for the current decoder instance   */
+	Uint32 *size /**< [Output] A variable specifying the available space in bitstream buffer for the current decoder instance   */
+);
+/**
+* @brief
+@verbatim
+Before decoding bitstream, HOST application must feed the decoder with bitstream. To
+do that, HOST application must know where to put bitstream and the maximum size.
+Applications can get the information by calling this function. This way is more
+efficient than providing arbitrary bitstream buffer to the decoder as far as
+VPU is concerned.
+
+The given size is the total sum of free space in ring buffer. So when
+a HOST application downloads this given size of bitstream, Wrptr could meet the end of
+stream buffer. In this case, the HOST application should wrap-around the Wrptr back to the
+beginning of stream buffer, and download the remaining bits. If not, decoder
+operation could be crashed.
+@endverbatim
+*
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means required information for decoder
+stream buffer was received successfully.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid.
+This return code might be caused if
+
+* `handle` is not the handle which has been obtained by VPU_DecOpen().
+* `handle` is the handle of an instance which has been closed already, etc.
+--
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, pRdptr, pWrptr or size, was invalid, which means
+it has a null pointer, or given values for some member variables are improper
+values.
+@endverbatim
+*/
+
+/**
+* @brief   Applications must let decoder know how much bitstream has been transferred to the
+address obtained from VPU_DecGetBitstreamBuffer(). By just giving the size as
+an argument, API automatically handles pointer wrap-around and updates the write
+pointer.
+*
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means putting new stream data was done successfully.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid.
+This return code might be caused if
+
+* `handle` is not the handle which has been obtained by VPU_DecOpen().
+* `handle` is the handle of an instance which has been closed already, etc.
+--
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, size, was invalid, which means size is larger than
+the value obtained from VPU_DecGetBitstreamBuffer(), or than the available space
+in the bitstream buffer.
+@endverbatim
+*/
+RetCode VPU_DecUpdateBitstreamBuffer(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+
+	/**
+    @verbatim
+    [Input]
+    A variable specifying the amount of bits transferred into bitstream buffer for the current decoder instance.
+
+    @* 0 : It means that no more bitstream exists to feed (end of stream).
+    If 0 is set for `size`, VPU decodes just remaing bitstream and returns -1 to `indexFrameDisplay`.
+    @* -1: It allows VPU to continue to decode without VPU_DecClose(),
+    even after remaining stream has completely been decoded by VPU_DecUpdateBitstreamBuffer(handle, 0).
+    This is especially useful when a sequence changes in the middle of decoding.
+    @* -2 : It is for handling exception cases like error stream or
+    failure of finding frame boundaries in interrupt mode. If such cases happen, VPU is unable to continue decoding.
+    If -2 is set for `size`, VPU decodes until the current write pointer in the bitstream buffer and then force to end decoding. (WAVE only)
+
+    @endverbatim
+    */
+	int size);
+
+/**
+* @brief
+This function specifies the location of read pointer in bitstream buffer.
+It can also set a write pointer with same value of read pointer (addr) when updateWrPtr is not a zero value,
+which allows to flush up the bitstream buffer at once.
+This function is used to operate bitstream buffer in PicEnd mode.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means required information of the stream data to be
+decoded was received successfully.
+*RETCODE_FAILURE* ::
+Operation was failed, which means there was an error in getting information for configuring
+the decoder.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid. This return
+code might be caused if
+
+* `handle` is not a handle which has been obtained by VPU_DecOpen().
+* `handle` is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding operation was not completed yet, so the given API function call
+cannot be performed this time. A frame decoding operation should be completed by calling
+VPU_ DecSetRdPtr ().
+@endverbatim
+ */
+RetCode VPU_DecSetRdPtr(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+	PhysicalAddress addr, /**< [Input] Updated read or write pointer */
+	int updateWrPtr /**< [Input] A flag whether to move the write pointer to where the read pointer is located */
+);
+
+RetCode VPU_DecGetRdPtr(DecHandle handle, PhysicalAddress *prdPtr);
+RetCode VPU_DecSetWrPtr(DecHandle handle, PhysicalAddress addr,
+			int updateRdPtr);
+
+/**
+* @brief   This function is provided to let HOST have a certain level of freedom for
+re-configuring decoder operation after creating a decoder instance. Some options
+which can be changed dynamically during decoding as the video sequence has been
+included. Some command-specific return codes are also presented.
+* @return
+@verbatim
+*RETCODE_INVALID_COMMAND* ::
+The given argument, cmd, was invalid, which means the given cmd was undefined,
+or not allowed in the current instance.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid.
+This return code might be caused if
+
+* `handle` is not a handle which has been obtained by VPU_DecOpen().
+* `handle` is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding operation was not completed yet, so the given API
+function call cannot be performed this time. A frame decoding operation should
+be completed by calling VPU_DecGetOutputInfo(). Even though the result of the
+current frame operation is not necessary, HOST application should call
+VPU_DecGetOutputInfo() to proceed this function call.
+values.
+@endverbatim
+ * @note
+@verbatim
+The list of commands can be summarized as follows:
+
+@* ENABLE_ROTATION
+@* DIABLE_ROTATION
+@* ENABLE_MIRRORING
+@* DISABLE_MIRRORING
+@* ENABLE_DERING
+@* DISABLE_DERING
+@* SET_MIRROR_DIRECTION
+@* SET_ROTATION_ANGLE
+@* SET_ROTATOR_OUTPUT
+@* SET_ROTATOR_STRIDE
+@* ENABLE_DEC_THUMBNAIL_MODE,
+@* DEC_SET_SPS_RBSP
+@* DEC_SET_PPS_RBSP
+@* ENABLE_REP_USERDATA
+@* DISABLE_REP_USERDATA
+@* SET_ADDR_REP_USERDATA
+@* SET_VIRT_ADDR_REP_USERDATA
+@* SET_SIZE_REP_USERDATA
+@* SET_USERDATA_REPORT_MODE
+@* SET_SEC_AXI
+@* SET_DRAM_CONFIG
+@* GET_DRAM_CONFIG
+@* ENABLE_REP_BUFSTAT
+@* DISABLE_REP_BUFSTAT
+@* ENABLE_REP_MBPARAM
+@* DISABLE_REP_MBPARAM
+@* ENABLE_REP_MBMV
+@* DISABLE_REP_MBMV
+@* SET_ADDR_REP_PICPARAM
+@* SET_ADDR_REP_BUF_STATE
+@* SET_ADDR_REP_MBMV_DATA
+@* SET_CACHE_CONFIG
+@* GET_TILEDMAP_CONFIG
+@* SET_LOW_DELAY_CONFIG
+@* DEC_GET_DISPLAY_OUTPUT_INFO
+@* SET_DECODE_FLUSH
+@* DEC_SET_FRAME_DELAY
+@* DEC_FREE_FRAME_BUFFER
+@* DEC_GET_FIELD_PIC_TYPE
+@* DEC_ENABLE_REORDER
+@* DEC_DISABLE_REORDER
+@* DEC_GET_FRAMEBUF_INFO
+@* DEC_RESET_FRAMEBUF_INFO
+@* DEC_SET_DISPLAY_FLAG
+@* DEC_GET_SEQ_INFO
+@* ENABLE_LOGGING
+@* DISABLE_LOGGING
+@* DEC_SET_2ND_FIELD_INFO
+@* DEC_ENABLE_AVC_MC_INTERPOL
+@* DEC_DISABLE_AVC_MC_INTERPOL
+
+====== ENABLE_ROTATION
+This command enables rotation of the post-rotator.
+In this case, `parameter` is ignored. This command returns RETCODE_SUCCESS.
+
+====== DISABLE_ROTATION
+This command disables rotation of the post-rotator.
+In this case, `parameter` is ignored. This command returns RETCODE_SUCCESS.
+
+====== ENABLE_MIRRORING
+This command enables mirroring of the post-rotator.
+In this case, `parameter` is ignored. This command returns RETCODE_SUCCESS.
+
+====== DISABLE_MIRRORING
+This command disables mirroring of the post-rotator.
+In this case, `parameter` is ignored. This command returns RETCODE_SUCCESS.
+
+====== ENABLE_DERING
+This command enables deringring filter of the post-rotator.
+In this case, `parameter` is ignored. This command returns RETCODE_SUCCESS.
+
+====== DISABLE_DERING
+This command disables deringing filter of the post-rotator.
+In this case, `parameter` is ignored. This command returns RETCODE_SUCCESS.
+
+====== SET_MIRROR_DIRECTION
+This command sets mirror direction of the post-rotator, and `parameter` is
+interpreted as a pointer to MirrorDirection. The `parameter` should be one of
+MIRDIR_NONE, MIRDIR_VER, MIRDIR_HOR, and MIRDIR_HOR_VER.
+
+@* MIRDIR_NONE: No mirroring
+@* MIRDIR_VER: Vertical mirroring
+@* MIRDIR_HOR: Horizontal mirroring
+@* MIRDIR_HOR_VER: Both directions
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means given mirroring direction is valid.
+* RETCODE_INVALID_PARAM:
+The given argument parameter, `parameter`, was invalid, which means given mirroring
+direction is invalid.
+
+====== SET_ROTATION_ANGLE
+This command sets counter-clockwise angle for post-rotation, and `parameter` is
+interpreted as a pointer to the integer which represents rotation angle in
+degrees. Rotation angle should be one of 0, 90, 180, and 270.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means given rotation angle is valid.
+* RETCODE_INVALID_PARAM:
+The given argument parameter, `parameter`, was invalid, which means given rotation
+angle is invalid.
+
+====== SET_ROTATOR_OUTPUT
+This command sets rotator output buffer address, and `parameter` is interpreted as
+the pointer of a structure representing physical addresses of YCbCr components
+of output frame. For storing the rotated output for display, at least one more
+frame buffer should be allocated. When multiple display buffers are required,
+HOST application could change the buffer pointer of rotated output at every frame by
+issuing this command.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means given rotation angle is valid.
+* RETCODE_INVALID_PARAM:
+The given argument parameter, `parameter`, was invalid, which means given frame
+buffer pointer is invalid.
+
+====== SET_ROTATOR_STRIDE
+This command sets the stride size of the frame buffer containing rotated output,
+and `parameter` is interpreted as the value of stride of the rotated output.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means given rotation angle is valid.
+* RETCODE_INVALID_STRIDE:
+The given argument parameter, `parameter`, was invalid, which means given value of
+stride is invalid. The value of stride must be greater than 0 and a multiple of 8.
+
+====== ENABLE_DEC_THUMBNAIL_MODE
+This command decodes only an I-frame of picture from bitstream for using it as a thumbnail.
+It requires as little as size of frame buffer since I-picture does not need any reference picture.
+If HOST issues this command and sets one frame buffer address to FrameBuffer array in VPU_DecRegisterFrameBuffer(),
+only the frame buffer is used.
+And please make sure that the number of frame buffer `num` should be registered as minFrameBufferCount.
+
+====== DEC_SET_SPS_RBSP
+This command applies SPS stream received from a certain
+out-of-band reception scheme to the decoder.
+The stream should be in RBSP format and in big Endian.
+The argument `parameter` is interpreted as a pointer to DecParamSet structure.
+In this case, `paraSet` is an array of 32 bits which contains SPS RBSP, and `size`
+is the size of the stream in bytes.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means transferring an SPS RBSP to decoder
+was done successfully.
+* RETCODE_INVALID_COMMAND:
+The given argument `cmd` was invalid, which means the given `cmd` was undefined,
+or not allowed in the current instance. In this case, current instance might not
+be an H.264/AVC decoder instance.
+* RETCODE_INVALID_PARAM:
+The given argument parameter, `parameter`, was invalid, which means it has a null
+pointer, or given values for some member variables are improper values.
+
+====== DEC_SET_PPS_RBSP
+This command applies PPS stream received from a certain
+out-of-band reception scheme to the decoder. The stream should be in RBSP format and in
+big Endian. The argument `parameter` is interpreted as a pointer to a DecParamSet structure.
+In this case, paraSet is an array of 32 bits which contains PPS RBSP, and `size`
+is the size of the stream in bytes.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means transferring a PPS RBSP to decoder
+was done successfully.
+* RETCODE_INVALID_COMMAND:
+The given argument `cmd` was invalid, which means the given cmd was undefined,
+or not allowed in the current instance. In this case, current instance might not
+be an H.264/AVC decoder instance.
+* RETCODE_INVALID_PARAM:
+The given argument parameter, `parameter`, was invalid, which means it has a null
+pointer, or given values for some member variables are improper values.
+
+====== ENABLE_REP_USERDATA
+This command enables user data report. This command ignores `parameter`.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means enabling user data report is done
+successfully.
+* RETCODE_USERDATA_BUF_NOT_SET:
+This means user data buffer address and size have not set yet.
+
+====== DISABLE_REP_USERDATA
+This command disables user data report. This command ignores `parameter` and returns
+RETCODE_SUCCESS.
+
+====== SET_ADDR_REP_USERDATA
+This command sets user data buffer address. `parameter` is interpreted as a pointer
+to address. This command returns as follows.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means given value of address is valid and
+setting is done successfully.
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` was invalid, which means given value of
+address is invalid. The value of address must be greater than 0 and a multiple
+of 8.
+
+====== SET_VIRT_ADDR_REP_USERDATA
+This command sets user data buffer address (virtual address) as well as physical address by using SET_ADDR_REP_USERDATA
+`parameter` is interpreted as a pointer to address. This command returns as follows.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means given value of address is valid and setting is done successfully.
+* RETCODE_USERDATA_BUF_NOT_SET:
+SET_ADDR_REP_USERDATA command was not been executed
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` was invalid, which means given value of address is invalid.
+    The value of address must be greater than 0 and a multiple of 8.
+
+====== SET_SIZE_REP_USERDATA
+This command sets the size of user data buffer which is set with
+SET_ADDR_REP_USERDATA command. `parameter` is interpreted as a pointer to the value
+of size. This command returns RETCODE_SUCCESS.
+
+According to codec standards, user data type means as below.
+
+@* H.264/AVC
+@** 4 : user_data_registered_itu_t_t35
+@** 5 : user_data_unregistered
+
+More details are in Annex D of H.264 specifications.
+
+@* VC1
+@** 31 : Sequence Level user data
+@** 30 : Entry-point Level user data
+@** 29 : Frame Level user data
+@** 28 : Field Level user data
+@** 27 : Slice Level user data
+
+@* MPEG2
+@** 0 : Sequence user data
+@** 1 : GOP user data
+@** 2 : Picture user data
+
+@* MPEG4
+@** 0 : VOS user data
+@** 1 : VIS user data
+@** 2 : VOL user data
+@** 3 : GOV user data
+
+NOTE: This command is available soon.
+
+The user data size 0 - 15 is used to make offset from userDataBuf Base + 8x17.
+It specifies byte size of user data 0 to 15 excluding 0 padding byte,
+which exists between user data. So HOST reads 1 user data from
+userDataBuf Base + 8x17 + 0 User Data Size + 0 Padding.
+Size of 0 padding is (8 - (User Data Size % 8))%8.
+
+====== SET_USERDATA_REPORT_MODE
+TBD
+
+====== SET_SEC_AXI
+This command sets the secondary channel of AXI for saving memory bandwidth to
+dedicated memory. The argument `parameter` is interpreted as a pointer to SecAxiUse which
+represents an enable flag and physical address which is related with the secondary
+channel for BIT processor, IP/AC-DC predictor, de-blocking filter, overlap
+filter respectively.
+
+This command has one of the following return codes::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means given value for setting secondary
+AXI is valid.
+* RETCODE_INVALID_PARAM:
+The given argument parameter, `parameter`, was invalid, which means given value is
+invalid.
+
+====== SET_DRAM_CONFIG
+TBD
+
+====== GET_DRAM_CONFIG
+TBD
+
+====== ENABLE_REP_BUFSTAT
+This command enables frame buffer status report. This command ignores `parameter` and
+returns RETCODE_SUCCESS.
+
+If this option is enabled, frame buffer status is reported.
+Each frame buffers can be used for display, reference or not used. Decoder
+reports the status of each frame buffer by using 4 bits [3:0]
+
+@* [3] Not used
+@* [2] USE_DIS
+@* [1] USE_REF
+@* [0] Not used
+
+For example, if the value of frame buffer status is 6, then the frame buffer is
+used for reference and display. If 4, the frame buffer is used for display and
+is not used for reference.
+
+In H.264/AVC, bit field definition is as bellows:
+
+@* [3] Not used
+@* [2] USE_DIS
+@* [1] USE_OUT
+@* [0] USE_REF
+
+If USE_OUT is 1, it means that the Frame is in DPB buffer.
+
+====== DISABLE_REP_BUFSTAT
+This command disables frame buffer status report. This command ignores `parameter`
+and returns RETCODE_SUCCESS.
+
+====== ENABLE_REP_MBPARAM
+This command enables MB Parameter report. This command ignores `parameter` and
+returns RETCODE_SUCCESS.
+
+If this option is enabled, error flag, Slice Boundary and QP are reported using
+8 bits.
+
+@* [7] : Error Map. If error is detected in macroblock decoding, this bit field is set to 1.
+@* [6] : Slice Boundary. Whenever new slice header is decoded, this bit field is toggled.
+@* [5:0] : An macroblock QP value
+
+====== DISABLE_REP_MBPARAM
+This command disables MB Parameter report. This command ignores `parameter` and
+returns RETCODE_SUCCESS.
+
+====== ENABLE_REP_MV
+This command enables MV report. This command ignores `parameter` and returns
+RETCODE_SUCCESS.
+
+If this option is enabled, decoder reports 1 motion vector for P picture and 2
+motion vectors for B picture.
+
+====== DISABLE_REP_MV
+This command disables MV report. This command ignores `parameter` and returns
+RETCODE_SUCCESS.
+
+====== SET_ADDR_REP_PICPARAM
+This command sets the address of picture parameter base. `parameter` is interpreted
+as a pointer to a address.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means given value of address is valid and
+setting is done successfully.
+* RETCODE_INVALID_PARAM:
+The given argument parameter, `parameter`, was invalid, which means given value of
+address is invalid. The value of address must be greater than 0 and a multiple
+of 8.
+
+To report frame buffer status, MB parameter and Motion vector, VPU reads the base
+addresses of external memory, which are specified by PicParaBaseAddr.
+
+[[dec_picparam_address_struct]]
+.Decoder Picture parameter base address structure
+ifdef::pdf[]
+image::../figure/dec_picparam_address_struct.svg["Decoder Picture parameter base address structure", width=300]
+endif::pdf[]
+ifdef::html[]
+image::../figure/dec_picparam_address_struct.png[Decoder Picture parameter base address structure]
+endif::html[]
+
+When `picUserDataEnable`, `mvReportEnable`, `mbParamEnable` or `frmBufStaEnable` in
+CMD_DEC_PIC_OPTION register are enabled, HOST application should specify buffer addresses in
+<<dec_picparam_address_struct>>.
+VPU reports each data and fills info, Data Size and MV num fields to
+ these buffer addresses of external memory. For VPU to report data
+properly, HOST application needs to specify these 3 buffer addresses preserving 8 byte alignment
+and buffer sizes need to be multiples of 256.
+
+====== SET_ADDR_REP_BUF_STATE
+
+This command sets the buffer address of frame buffer status. The `parameter` is interpreted as a pointer to the address.
+
+This command has one of the following return codes::
+
+* RETCODE_SUCCESS: Operation was done successfully, which means given value of address
+is valid and setting is done successfully.
+* RETCODE_INVALID_PARAM: The given argument parameter, `parameter`, was invalid,
+which means given value of address is invalid. The value of address must be greater than 0
+and a multiple of 8.
+
+====== SET_ADDR_REP_MBMV_DATA
+
+This command sets the buffer address of motion vector information reporting array. The `parameter` is interpreted as a pointer to the address.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS: Operation was done successfully, which means given value of address
+is valid and setting is done successfully.
+* RETCODE_INVALID_PARAM: The given argument parameter, `parameter`, was invalid,
+which means given value of address is invalid. The value of address must be greater than 0
+and a multiple of 8.
+
+The motion vector information reporting array consists of below fields for each macroblock.
+The array element has 32 bit data per a macroblock.
+
+.Description of SET_ADDR_REP_MBMV_DATA
+[separator="|", frame="all", grid="all"]
+`15`20`65_80
+Bit range  | Field name      | Description
+________________________________________________________________________________
+31         | Inter MB        | A flag to indicate whether the macroblock is inter macroblock or not
+29:16      | Mv X            | Signed motion vector value for X axis
+13:00      | Mv Y            | Signed motion vector value for Y axis
+________________________________________________________________________________
+
+====== SET_CACHE_CONFIG
+
+This command sets the configuration of cache. The `parameter` is interpreted as a pointer to MaverickCacheConfig.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means given value is valid and setting is done successfully.
+* RETCODE_INVALID_PARAM:
+The given argument parameter, `parameter`, was invalid. The value of address must be not zero.
+
+====== GET_TILEDMAP_CONFIG
+This command gets tiled map configuration according to `TiledMapConfig` structure.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means given value is valid and setting is done successfully.
+* RETCODE_INVALID_PARAM:
+The given argument parameter, `parameter`, was invalid, which means it has a null pointer,
+ or given values for some member variables are improper values.
+
+====== SET_LOW_DELAY_CONFIG
+This command sets the low delay decoding options which enable low delay decoding and indicate the number of MB row.
+The argument `parameter` is interpreted as a pointer to LowDelayInfo which represents an enable flag and the number of MB row.
+If low delay decoding is enabled, VPU sends an interrupt and indexFrameDisplay to HOST when the number of MB row decoding is done.
+If the interrupt is issued, HOST should clear the interrupt and read indexFrameDisplay from the RET_DEC_PIC_FRAME_IDX register in order to display.
+
+====== DEC_GET_DISPLAY_OUTPUT_INFO
+HOST can get decoder output information according to display index in DecOutputInfo structure.
+HOST can set display index using member variable `indexFrameDisplay`.
+This command returns RETCODE_SUCCESS.
+
+* Example code
+.........................................................................
+DecOutputInfo decOutputInfo;
+decOutputInfo. indexFrameDisplay = disp_index;
+VPU_DecGiveCommand(handle, DEC_GET_DISPLAY_OUTPUT_INFO, & decOutputInfo);
+.........................................................................
+
+====== SET_DECODE_FLUSH
+This command is used to change bitstream buffer mode from Interrupt mode to Picture End mode.
+When HOST receives an interrupt about bistream buffer empty in Interrupt Mode, but there is no more bitstream for the current frame in bitstream buffer,
+this command completes decoding only with remaining bitstream.
+
+This command returns RETCODE_SUCCESS.
+
+====== DEC_SET_FRAME_DELAY
+HOST can set the number of frame to be delayed before display (H.264/AVC only) by using this command.
+This command is useful when display frame buffer delay is supposed to happen for buffering decoded picture reorder and
+HOST is sure of that.
+Unless this command is executed, VPU has display frame buffer delay as frameBufDelay value of DecInitialInfo structure.
+
+====== DEC_FREE_FRAME_BUFFER
+HOST can free all the frame buffers allocated by VPUAPI.
+This command is useful when VPU detects sequence change.
+For example, if HOST knows resolution change while decoding through `sequenceChanged` variable of DecOutputInfo structure,
+HOST should change the size of frame buffer accordingly.
+This command is used to release the frame buffers allocated for the previous sequence.
+Then VPU_DecGetInitialInfo() and VPU_DecIsseuSeqInit() are called before frame buffer allocation for a new sequence.
+
+====== DEC_SET_DISPLAY_FLAG
+Applications can set a display flag for each frame buffer by calling this function after creating
+decoder instance. If a certain display flag of frame buffer is set, the frame buffer cannot be used in the
+decoding process. Applications can control displaying a buffer with this command
+to prevent VPU from using buffer in every decoding process.
+
+This command is the opposite of what VPU_DecClrDispFlag() does.
+All of buffer flags are initialized with 0x00000000 which means being able to decode.
+Unless it is called, VPU starts decoding with available frame buffer that has been cleared
+in round robin order.
+
+====== DEC_GET_SEQ_INFO
+This command returns the information of the current sequence in the form of <<vpuapi_h_DecInitialInfo>> structure.
+HOST can get this information with more accuracy after VPU_DecIssueSeqInit() or VPU_DecGetOutputInfo() is called.
+
+====== ENABLE_LOGGING
+HOST can activate message logging once VPU_DecOpen() or VPU_EncOpen() is called.
+
+====== DISABLE_LOGGING
+HOST can deactivate message logging which is off as default.
+
+====== DEC_ENABLE_AVC_MC_INTERPOL
+This is option for enable fast MC interpolation. this command is only used for H.264/AVC decoder.
+
+====== DEC_DISABLE_AVC_MC_INTERPOL
+This is option for disable fast MC interpolation. this command is only used for H.264/AVC decoder.
+
+====== DEC_SET_2ND_FIELD_INFO
+This command sets bistream buffer information for a second field after a first field has been decoded.
+In case of H.264/AVC, MPEG2, or VC1 decoder, they issue an INT_BIT_DEC_FIELD interrupt after first field decoding.
+This command then can give VPU the address and size of bitstream buffer for a second field.
+This commands is used when first field and second field are in separate bistreams - not together in a bitstream.
+If HOST gives this command and clears the INT_BIT_DEC_FIELD interrupt,
+VPU starts decoding from the given base address until the size of bitstream buffer.
+
+====== DEC_GET_FIELD_PIC_TYPE
+This command gets a field picture type of decoded picture after INT_BIT_DEC_FIELD interrupt is issued.
+
+====== DEC_ENABLE_REORDER
+HOST can enable display buffer reordering when decoding H.264 streams. In H.264 case
+output decoded picture may be re-ordered if pic_order_cnt_type is 0 or 1. In that case, decoder
+must delay output display for re-ordering but some applications (ex. video telephony) do not
+want such display delay.
+
+====== DEC_DISABLE_REORDER
+HOST can disable output display buffer reorder-ing. Then BIT processor does not re-order output buffer when pic_order_cnt_type is 0 or 1. If
+In H.264/AVC case. pic_order_cnt_type is 2 or the other standard case, this flag is ignored because output display
+buffer reordering is not allowed.
+
+====== DEC_GET_FRAMEBUF_INFO
+This command gives HOST the information of framebuffer in the form of DecGetFramebufInfo structure.
+
+====== DEC_RESET_FRAMEBUF_INFO
+This command resets the information of framebuffer.
+Unlike DEC_FREE_FRAME_BUFFER, it does not release the assigned memory itself.
+This command is used for sequence change along with DEC_GET_FRAMEBUF_INFO.
+
+====== ENABLE_REP_CUDATA
+This command enables to report CU data.
+
+====== DISABLE_REP_CUDATA
+This command disables to report CU data.
+
+====== SET_ADDR_REP_CUDATA
+This command sets the address of buffer where CU data is written.
+
+====== SET_SIZE_REP_CUDATA
+This command sets the size of buffer where CU data is written.
+
+====== DEC_SET_WTL_FRAME_FORMAT
+This command sets FrameBufferFormat for WTL.
+
+====== DEC_SET_AVC_ERROR_CONCEAL_MODE
+This command sets error conceal mode for H.264 decoder.
+This command must be issued through VPU_DecGiveCommand() before calling VPU_DecGetInitialInfo() or VPU_DecIssueSeqInit().
+In other words, error conceal mode cannot be applied once a sequence initialized.
+
+@* AVC_ERROR_CONCEAL_MODE_DEFAULT - VPU performs error concealment in default mode.
+@* AVC_ERROR_CONCEAL_MODE_ENABLE_SELECTIVE_CONCEAL_MISSING_REFERENCE -
+VPU performs error concealment using another framebuffer if the error comes from missing reference frame.
+@* AVC_ERROR_CONCEAL_MODE_DISABLE_CONCEAL_MISSING_REFERENCE -
+VPU does not perform error concealment if the error comes from missing reference frame.
+@* AVC_ERROR_CONCEAL_MODE_DISABLE_CONCEAL_WRONG_FRAME_NUM -
+VPU does not perform error concealment if the error comes from wrong frame_num syntax.
+
+====== DEC_GET_SCALER_INFO
+This command returns setting information to downscale an image such as enable, width, and height.
+
+====== DEC_SET_SCALER_INFO
+This command sets information to downscale an image such as enable, width, and height.
+
+====== DEC_SET_TARGET_TEMPORAL_ID
+This command decodes only a frame whose temporal id is equal to or less than the given target temporal id.
+
+NOTE: It is only for H.265/HEVC decoder.
+
+====== DEC_SET_BWB_CUR_FRAME_IDX
+This command specifies the index of linear frame buffer which needs to be changed to due to change of inter-frame resolution while decoding.
+
+NOTE: It is only for VP9 decoder.
+
+====== DEC_SET_FBC_CUR_FRAME_IDX
+This command specifies the index of FBC frame buffer which needs to be changed to due to change of inter-frame resolution while decoding.
+
+NOTE: It is only for VP9 decoder.
+
+====== DEC_SET_INTER_RES_INFO_ON
+This command informs inter-frame resolution has been changed while decoding. After this command issued,
+VPU reallocates one frame buffer for the change.
+
+NOTE: It is only for VP9 decoder.
+
+====== DEC_SET_INTER_RES_INFO_OFF
+This command releases the flag informing inter-frame resolution change.
+It should be issued after reallocation of one frame buffer is completed.
+
+NOTE: It is only for VP9 decoder.
+
+====== DEC_FREE_FBC_TABLE_BUFFER
+This command frees one FBC table to deal with inter-frame resolution change.
+
+NOTE: It is only for VP9 decoder.
+
+====== DEC_FREE_MV_BUFFER
+This command frees one MV buffer to deal with inter-frame resolution change.
+
+NOTE: It is only for VP9 decoder.
+
+====== DEC_ALLOC_FBC_Y_TABLE_BUFFER
+This command allocates one FBC luma table to deal with inter-frame resolution change.
+
+NOTE: It is only for VP9 decoder.
+
+====== DEC_ALLOC_FBC_C_TABLE_BUFFER
+This command allocates one FBC chroma table to deal with inter-frame resolution change.
+
+NOTE: It is only for VP9 decoder.
+
+====== DEC_ALLOC_MV_BUFFER
+This command allocates one MV buffer to deal with inter-frame resolution change.
+
+NOTE: It is only for VP9 decoder.
+
+@endverbatim
+*/
+RetCode VPU_DecGiveCommand(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+	CodecCommand
+		cmd, /**< [Input] A variable specifying the given command of CodecComand type */
+	void *parameter /**< [Input/Output] A pointer to command-specific data structure which describes picture I/O parameters for the current decoder instance */
+);
+
+/**
+* @brief
+This function sets the secondary channel of AXI for saving memory bandwidth to dedicated
+memory.
+It works same as SET_SEC_AXI command which is only able to be called before VPU_DecRegisterFramebuffer().
+This function can be called before VPU_DecStartOneFrame() to change information about the secondary channel of AXI.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means given value for setting secondary AXI is valid.
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding operation was not completed yet, so the given API function call
+cannot be allowed.
+*RETCODE_INSUFFICIENT_RESOURCE* ::
+This means that VPU cannot allocate memory due to lack of memory.
+*RETCODE_VPU_RESPONSE_TIMEOUT* ::
+This means that VPU response time is too long, time out.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid. This return
+code might be caused if
+
+* `handle` is not a handle which has been obtained by VPU_DecOpen().
+* `handle` is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding operation was not completed yet, so the given API function call
+cannot be performed this time. A frame decoding operation should be completed by calling
+VPU_ DecSetRdPtr ().
+@endverbatim
+ */
+RetCode VPU_DecConfigSecondAxi(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+	int stride, /**< [Input] Width of framebuffer */
+	int height /**< [Input] Height of framebuffer */
+);
+
+/**
+ * @brief   This function starts decoding one frame. Returning from this function does not
+mean the completion of decoding one frame, and it is just that decoding one
+frame was initiated. Every call of this function should be matched with VPU_DecGetOutputInfo()
+with the same handle. Without calling a pair of these funtions, HOST cannot call any other
+API functions except for VPU_IsBusy(), VPU_DecGetBitstreamBuffer(), and
+VPU_DecUpdateBitstreamBuffer().
+ *
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
++
+--
+Operation was done successfully, which means decoding a new frame was started
+successfully.
+
+NOTE: This return value does not mean that decoding a frame was completed
+successfully.
+--
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid.
+This return code might be caused if
+
+* `handle` is not a handle which has been obtained by VPU_DecOpen().
+* `handle` is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding operation was not completed yet, so the given API
+function call cannot be performed this time. A frame decoding operation should
+be completed by calling VPU_DecGetOutputInfo(). Even though the result of the
+current frame operation is not necessary, HOST should call
+VPU_DecGetOutputInfo() to proceed this function call.
+*RETCODE_WRONG_CALL_SEQUENCE* ::
+This means the current API function call was invalid considering the allowed
+sequences between API functions. A HOST might call this
+function before successfully calling VPU_DecRegisterFrameBuffer(). This function
+should be called after calling VPU_ DecRegisterFrameBuffer() successfully.
+@endverbatim
+ */
+RetCode VPU_DecStartOneFrame(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+	DecParam *param /**< [Input] A pointer to a DecParam type structure which describes picture decoding parameters for the given decoder instance */
+);
+
+/**
+ * @brief   VPU returns the result of decoding which
+includes information on decoded picture, syntax value, frame buffer, other report values, and etc.
+HOST should call this function after frame decoding is finished and
+before starting the further processing.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means receiving the output information of the
+current frame was done successfully.
+*RETCODE_FAILURE* ::
+Operation was failed, which means there was an error in getting information for
+configuring the decoder.
+*RETCODE_INVALID_HANDLE* ::
+This means argument handle is invalid. This includes cases where `handle` is not
+a handle which has been obtained by VPU_DecOpen(), `handle` is a handle to an
+instance already closed, or `handle` is a handle to a decoder instance. Also,
+this value is returned when VPU_DecStartOneFrame() is matched with
+VPU_DecGetOutputInfo() with different handles.
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, pInfo, was invalid, which means it has a null
+pointer, or given values for some member variables are improper values.
+@endverbatim
+ */
+RetCode VPU_DecGetOutputInfo(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+	DecOutputInfo *
+		info /**< [Output] A pointer to a DecOutputInfo type structure which describes picture decoding results for the current decoder instance. */
+);
+
+/**
+* @brief
+@verbatim
+This function flushes all of the decoded framebuffer contexts that remain in decoder firmware.
+It is used to start seamless decoding operation without randome access to the buffer or calling VPU_DecClose().
+
+NOTE: In WAVE4, this function returns all of the decoded framebuffer contexts that remain.
+     pRetNum always has 0 in CODA9.
+@endverbatim
+*
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means receiving the output information of the
+current frame was done successfully.
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding operation was not completed yet, so the given API
+function call cannot be performed this time. A frame decoding operation should
+be completed by calling VPU_DecGetOutputInfo(). Even though the result of the
+current frame operation is not necessary, HOST should call
+VPU_DecGetOutputInfo() to proceed this function call.
+*RETCODE_INVALID_HANDLE* ::
+This means argument handle is invalid. This includes cases where `handle` is not
+a handle which has been obtained by VPU_DecOpen(), `handle` is a handle to an
+instance already closed, or `handle` is a handle to an decoder instance.
+Also,this value is returned when VPU_DecStartOneFrame() is matched with
+VPU_DecGetOutputInfo() with different handles.
+*RETCODE_VPU_RESPONSE_TIMEOUT* ::
+Operation has not recieved any response from VPU and has timed out.
+@endverbatim
+ */
+RetCode VPU_DecFrameBufferFlush(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+	DecOutputInfo *
+		pRemainingInfo, /**<  [Output] All of the decoded framebuffer contexts are stored in display order as array of DecOutputInfo.
+                                            If this is NULL, the remaining information is not returned.  */
+	Uint32 *pRetNum /**<  [Output] The number of the decoded frame buffer contexts. It this is null, the information is not returned.  */
+);
+
+/**
+* @brief   This function clears a display flag of frame buffer.
+If display flag of frame buffer is cleared, the
+frame buffer can be reused in the decoding process. With VPU_DecClrDispFlag(), HOST application can control
+display of frame buffer marked with the display index which is given by VPU.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means receiving the output information of the
+current frame was done successfully.
+*RETCODE_INVALID_HANDLE* ::
+This means argument handle is invalid. This includes cases where `handle` is not
+a handle which has been obtained by VPU_DecOpen(), `handle` is a handle to an
+instance already closed, or `handle` is a handle to an decoder instance.
+Also,this value is returned when VPU_DecStartOneFrame() is matched with
+VPU_DecGetOutputInfo() with different handles.
+*RETCODE_WRONG_CALL_SEQUENCE* ::
+This means the current API function call was invalid considering the allowed
+sequences between API functions.
+It might happen because VPU_DecRegisterFrameBuffer() with the
+same handle was not called before calling this function.
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, index, was invalid, which means it has improper
+values.
+@endverbatim
+ */
+RetCode VPU_DecClrDispFlag(
+	DecHandle handle, /**< [Input] A decoder handle obtained from VPU_DecOpen() */
+	int index /**< [Input] A frame buffer index to be cleared */
+);
+
+// function for encode
+/**
+* @brief    In order to start a new encoder operation, HOST application must open a new instance
+for this encoder operation. By calling this function, HOST application can get a
+handle specifying a new encoder instance. Because VPU supports multiple
+instances of codec operations, HOST application needs this kind of handles for the
+all codec instances now on running. Once a HOST application gets a handle, the HOST application
+must use this handle to represent the target instances for all subsequent
+encoder-related functions.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means a new encoder instance was opened
+successfully.
+
+*RETCODE_FAILURE* ::
+Operation was failed, which means getting a new encoder instance was not done
+successfully. If there is no free instance anymore, this value is returned
+in this function call.
+
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, pOpenParam, was invalid, which means it has a null
+pointer, or given values for some member variables are improper values.
+
+*RETCODE_NOT_INITIALIZED* ::
+VPU was not initialized at all before calling this function. Application should
+initialize VPU by calling VPU_Init() before calling this function.
+@endverbatim
+*/
+
+RetCode VPU_EncOpen(
+	EncHandle *
+		handle, /**< [Output] A pointer to a EncHandle type variable which specifies each instance for HOST application. If no instance is available, null handle is returned. */
+	EncOpenParam *
+		encOpParam /**< [Input] A pointer to a EncOpenParam type structure which describes required parameters for creating a new encoder instance. */
+);
+
+/**
+* @brief    When HOST application finished encoding operations and wanted to release this
+instance for other processing, the HOST application should close this instance by calling
+this function. After completion of this function call, the instance referred to
+by pHandle gets free. Once HOST application closes an instance, the HOST application
+cannot call any further encoder-specific function with the current handle before
+re-opening a new instance with the same handle.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully. That means the current encoder instance was closed
+successfully.
+
+*RETCODE_INVALID_HANDLE* ::
+This means the given handle for the current API function call, pHandle, was invalid.
+This return code might be caused if
++
+--
+* pHandle is not a handle which has been obtained by VPU_EncOpen().
+* pHandle is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding or encoding operation was not completed yet, so the
+given API function call cannot be performed this time. A frame encoding or
+decoding operation should be completed by calling VPU_EncGetOutputInfo() or
+VPU_DecGetOutputInfo(). Even though the result of the current frame operation is
+not necessary, HOST application should call VPU_EncGetOutputInfo() or
+VPU_DecGetOutputInfo() to proceed this function call.
+
+*RETCODE_VPU_RESPONSE_TIMEOUT* ::
+Operation has not recieved any response from VPU and has timed out.
+@endverbatim
+*/
+RetCode VPU_EncClose(
+	EncHandle handle /**< [Input] An encoder handle obtained from VPU_EncOpen() */
+);
+
+/**
+* @brief    Before starting encoder operation, HOST application must allocate frame buffers
+according to the information obtained from this function. This function returns
+the required parameters for VPU_EncRegisterFrameBuffer(), which follows right after
+this function call.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means receiving the initial parameters
+was done successfully.
+
+*RETCODE_FAILURE* ::
+Operation was failed, which means there was an error in getting information for
+configuring the encoder.
+
+*RETCODE_INVALID_HANDLE* ::
+This means the given handle for the current API function call, pHandle, was invalid.
+This return code might be caused if
+
+* pHandle is not a handle which has been obtained by VPU_EncOpen().
+* pHandle is a handle of an instance which has been closed already, etc.
+
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding or encoding operation was not completed yet, so the
+given API function call cannot be performed this time. A frame encoding or
+decoding operation should be completed by calling VPU_EncGetOutputInfo() or
+VPU_DecGetOutputInfo(). Even though the result of the current frame operation is
+not necessary, HOST application should call VPU_EncGetOutputInfo() or
+VPU_DecGetOutputInfo() to proceed this function call.
+
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, pInitialInfo, was invalid, which means it has a
+null pointer, or given values for some member variables are improper values.
+
+*RETCODE_CALLED_BEFORE* ::
+This function call is invalid which means multiple calls of the current API function
+for a given instance are not allowed. In this case, encoder initial information
+has been received already, so that this function call is meaningless and not
+allowed anymore.
+
+*RETCODE_VPU_RESPONSE_TIMEOUT* ::
+Operation has not recieved any response from VPU and has timed out.
+@endverbatim
+*/
+RetCode VPU_EncGetInitialInfo(
+	EncHandle handle, /**< [Input] An encoder handle obtained from VPU_EncOpen() */
+	EncInitialInfo *
+		encInitInfo /**< [Output] Minimum number of frame buffer for this encoder instance  */
+);
+
+/**
+* @brief
+@verbatim
+This function registers frame buffers requested by VPU_EncGetInitialInfo(). The
+frame buffers pointed to by pBuffer are managed internally within VPU.
+These include reference frames, reconstructed frames, etc. Applications must not
+change the contents of the array of frame buffers during the life time of the
+instance, and `num` must not be less than minFrameBufferCount obtained by
+VPU_EncGetInitialInfo().
+
+The distance between a pixel in a row and the corresponding pixel in the next
+row is called a stride. The value of stride must be a multiple of 8. The
+address of the first pixel in the second row does not necessarily coincide with
+the value next to the last pixel in the first row. In other words, a stride can
+be greater than the picture width in pixels.
+
+Applications should not set a stride value smaller than the picture width.
+So, for Y component, HOST application must allocate at least a space of size
+(frame height \* stride), and Cb or Cr component,
+(frame height/2 \* stride/2), respectively.
+But make sure that in Cb/Cr non-interleave (separate Cb/Cr) map,
+a stride for the luminance frame buffer should be multiple of 16 so that a stride
+for the luminance frame buffer becomes a multiple of 8.
+@endverbatim
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means registering frame buffers were done
+successfully.
+
+*RETCODE_INVALID_HANDLE* ::
+This means the given handle for the current API function call, pHandle, was invalid.
+This return code might be caused if
+
+* handle is not a handle which has been obtained by VPU_EncOpen().
+* handle is a handle of an instance which has been closed already, etc.
+
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding or encoding operation was not completed yet, so the
+given API function call cannot be performed this time. A frame encoding or
+decoding operation should be completed by calling VPU_EncGetOutputInfo() or
+VPU_DecGetOutputInfo(). Even though the result of the current frame operation is
+not necessary, HOST application should call VPU_EncGetOutputInfo() or
+VPU_DecGetOutputInfo() to proceed this function call.
+
+*RETCODE_WRONG_CALL_SEQUENCE* ::
+This means the current API function call was invalid considering the allowed
+sequences between API functions. HOST application might call this
+function before calling VPU_EncGetInitialInfo() successfully. This function
+should be called after successful calling of VPU_EncGetInitialInfo().
+
+*RETCODE_INVALID_FRAME_BUFFER* ::
+This means argument pBuffer were invalid, which means it was not initialized
+yet or not valid anymore.
+
+*RETCODE_INSUFFICIENT_FRAME_BUFFERS* ::
+This means the given number of frame buffers, num, was not enough for the
+encoder operations of the given handle. It should be greater than or equal to
+the value of  minFrameBufferCount obtained from VPU_EncGetInitialInfo().
+
+*RETCODE_INVALID_STRIDE* ::
+This means the given argument stride was invalid, which means it is 0, or is not
+a multiple of 8 in this case.
+
+*RETCODE_CALLED_BEFORE* ::
+This function call is invalid which means multiple calls of the current API function
+for a given instance are not allowed. It might happen when registering frame buffer for
+this instance has been done already so that this function call is meaningless
+and not allowed anymore.
+
+*RETCODE_VPU_RESPONSE_TIMEOUT* ::
+Operation has not recieved any response from VPU and has timed out.
+@endverbatim
+*/
+RetCode VPU_EncRegisterFrameBuffer(
+	EncHandle handle, /**< [Input] An encoder handle obtained from VPU_EncOpen() */
+	FrameBuffer *
+		bufArray, /**< [Input] Allocated frame buffer address and information. If this parameter is set to -1, VPU allocates frame buffers. */
+	int num, /**< [Input] A number of frame buffers. VPU can allocate frame buffers as many as this given value. */
+	int stride, /**< [Input] A stride value of the given frame buffers */
+	int height, /**< [Input] Frame height */
+	int mapType /**< [Input] Map type of frame buffer */
+);
+
+/**
+* @brief    This is a special function that enables HOST application to allocate directly the frame buffer
+for encoding or for Pre-processor (PRP) such as Rotator.
+In normal operation, VPU API allocates frame buffers when the argument `bufArray` in VPU_EncRegisterFrameBuffer() is set to 0.
+However, for any other reason HOST application can use this function to allocate frame buffers by themselves.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means the framebuffer is allocated successfully.
+
+*RETCODE_INVALID_HANDLE* ::
+This means the given handle for the current API function call, pHandle, was invalid. This return code might be caused if
++
+--
+* handle is not a handle which has been obtained by VPU_EncOpen().
+* handle is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_WRONG_CALL_SEQUENCE* ::
+This means the current API function call was invalid considering the allowed sequences between API functions.
+It might happen because VPU_EncRegisterFrameBuffer() for (FramebufferAllocType.FB_TYPE_CODEC) has not been called,
+before this function call for allocating frame buffer for PRP (FramebufferAllocType.FB_TYPE_PPU).
+
+*RETCODE_INSUFFICIENT_RESOURCE* ::
+Fail to allocate a framebuffer due to lack of memory
+
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, index, was invalid, which means it has improper values
+@endverbatim
+*/
+RetCode VPU_EncAllocateFrameBuffer(
+	EncHandle handle, /**< [Input] An encoder handle obtained from VPU_EncOpen()  */
+	FrameBufferAllocInfo
+		info, /**< [Input] Information required for frame bufer allocation  */
+	FrameBuffer *
+		frameBuffer /**< [Output]  Data structure that holds information of allocated frame buffers  */
+);
+
+/**
+* @brief
+@verbatim
+This function gets the frame buffer information that was allocated by VPU_EncRegisterFrameBuffer() function.
+
+It does not affect actual encoding and simply does obtain the information of frame buffer.
+This function is more helpful especially when frame buffers are automatically assigned by
+setting 0 to `bufArray` of VPU_EncRegisterFrameBuffer() and HOST wants to know about the allocated frame buffer.
+@endverbatim
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means registering frame buffer
+information was done successfully.
+
+*RETCODE_INVALID_HANDLE* ::
+This means the given handle for the current API function call, `handle`, was invalid.
+This return code might be caused if
++
+--
+* `handle` is not a handle which has been obtained by VPU_DecOpen().
+* `handle` is a handle of an instance which has been closed already, etc.
+--
+
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, frameIdx, was invalid, which means frameIdx is larger than allocated framebuffer.
+@endverbatim
+*/
+RetCode VPU_EncGetFrameBuffer(
+	EncHandle handle, /**< [Input] An encoder handle obtained from VPU_EncOpen()   */
+	int frameIdx, /**< [Input] An index of frame buffer  */
+	FrameBuffer *
+		frameBuf /**< [output] Allocated frame buffer address and information   */
+);
+
+/**
+* @brief    This function is provided to let HOST application have a certain level of freedom for
+re-configuring encoder operation after creating an encoder instance. Some
+options which can be changed dynamically during encoding as the video sequence has
+been included. Some command-specific return codes are also presented.
+* @return
+@verbatim
+*RETCODE_INVALID_COMMAND* ::
+This means the given argument, cmd, was invalid which means the given cmd was
+undefined, or not allowed in the current instance.
+
+*RETCODE_INVALID_HANDLE* ::
+This means the given handle for the current API function call, pHandle, was invalid.
+This return code might be caused if
++
+--
+* pHandle is not a handle which has been obtained by VPU_EncOpen().
+* pHandle is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding or encoding operation was not completed yet, so the
+given API function call cannot be performed this time. A frame encoding or
+decoding operation should be completed by calling VPU_EncGetOutputInfo() or
+VPU_DecGetOutputInfo(). Even though the result of the current frame operation is
+not necessary, HOST application should call VPU_EncGetOutputInfo() or
+VPU_DecGetOutputInfo() to proceed this function call.
+@endverbatim
+* @note
+@verbatim
+The list of commands can be summarized as follows:
+
+@* ENABLE_ROTATION
+@* DIABLE_ROTATION
+@* ENABLE_MIRRORING
+@* DISABLE_MIRRORING
+@* SET_MIRROR_DIRECTION
+@* SET_ROTATION_ANGLE
+@* ENC_ADD_PPS
+@* ENC_SET_ACTIVE_PPS
+@* ENC_GET_ACTIVE_PPS
+@* ENC_PUT_VIDEO_HEADER
+@* ENC_PUT_MP4_HEADER
+@* ENC_PUT_AVC_HEADER
+@* ENC_GET_VIDEO_HEADER
+@* ENC_SET_INTRA_MB_REFRESH_NUMBER
+@* ENC_ENABLE_HEC
+@* ENC_DISABLE_HEC
+@* ENC_SET_SLICE_INFO
+@* ENC_SET_GOP_NUMBER
+@* ENC_SET_INTRA_QP
+@* ENC_SET_BITRATE
+@* ENC_SET_FRAMERATE
+@* ENC_SET_SEARCHRAM_PARAM
+@* ENC_SET_REPORT_MBINFO
+@* ENC_SET_REPORT_MVINFO
+@* ENC_SET_REPORT_SLICEINFO
+@* ENC_SET_PIC_PARA_ADDR
+@* SET_SEC_AXI
+@* ENABLE_LOGGING
+@* DISABLE_LOGGING
+@* ENC_CONFIG_SUB_FRAME_SYNC
+@* ENC_SET_SUB_FRAME_SYNC
+
+====== ENABLE_ROTATION
+This command enables rotation of the pre-rotator.
+In this case, `parameter` is ignored. This command returns RETCODE_SUCCESS.
+
+====== DIABLE_ROTATION
+This command disables rotation of the pre-rotator.
+In this case, `parameter` is ignored. This command returns RETCODE_SUCCESS.
+
+====== ENABLE_MIRRORING
+This command enables mirroring of the pre-rotator.
+In this case, `parameter` is ignored. This command returns RETCODE_SUCCESS.
+
+====== DISABLE_MIRRORING
+This command disables mirroring of the pre-rotator.
+In this case, `parameter` is ignored. This command returns RETCODE_SUCCESS.
+
+====== SET_MIRROR_DIRECTION
+This command sets mirror direction of the pre-rotator, and `parameter` is
+interpreted as a pointer to MirrorDirection.
+The `parameter` should be one of MIRDIR_NONE, MIRDIR_VER, MIRDIR_HOR, and MIRDIR_HOR_VER.
+
+@* MIRDIR_NONE: No mirroring
+@* MIRDIR_VER: Vertical mirroring
+@* MIRDIR_HOR: Horizontal mirroring
+@* MIRDIR_HOR_VER: Both directions
+
+This command has one of the following return codes::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means given mirroring direction is valid.
+* RETCODE_INVALID_PARAM:
+The given argument parameter, `parameter`, was invalid, which means given mirroring
+direction is invalid.
+
+====== SET_ROTATION_ANGLE
+This command sets counter-clockwise angle for post-rotation, and `parameter` is
+interpreted as a pointer to the integer which represents
+rotation angle in degrees. Rotation angle should be one of 0, 90, 180, and 270.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means given rotation angle is valid.
+* RETCODE_INVALID_PARAM:
+The given argument parameter, `parameter`, was invalid, which means given rotation
+angle is invalid.
+
+NOTE: Rotation angle could not be changed after sequence initialization, because
+it might cause problems in handling frame buffers.
+
+====== ENC_ADD_PPS
+This command adds PPS header syntax of AVC/H.264 bitstream
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header
+syntax was successfully inserted.
+* RETCODE_INVALID_COMMAND:
+This means the given argument cmd was invalid
+which means the given cmd was undefined, or not allowed in the current instance. In this
+case, the current instance might not be an H.264/AVC encoder instance.
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` was invalid, which means
+it has a null pointer, or given values for some member variables are improper values.
+
+====== ENC_SET_ACTIVE_PPS
+This command sets active PPS header syntax of AVC/H.264 bitstream, and `parameter` is interpreted ]
+as an active PPS index.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header
+syntax was successfully inserted.
+* RETCODE_INVALID_COMMAND:
+This means the given argument cmd was invalid
+which means the given cmd was undefined, or not allowed in the current instance. In this
+case, the current instance might not be an MPEG4 encoder instance.
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` was invalid, which means
+it has a null pointer, or given values for some member variables are improper values.
+* RETCODE_VPU_RESPONSE_TIMEOUT:
+Operation has not recieved any response from VPU and has timed out.
+
+====== ENC_GET_ACTIVE_PPS
+This command gets active PPS header syntax of AVC/H.264 bitstream, and `parameter` is interpreted as an active PPS index.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header
+syntax was successfully inserted.
+* RETCODE_INVALID_COMMAND:
+This means the given argument cmd was invalid
+which means the given cmd was undefined, or not allowed in the current instance. In this
+case, the current instance might not be an MPEG4 encoder instance.
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` was invalid, which means
+it has a null pointer, or given values for some member variables are improper values.
+
+====== ENC_PUT_VIDEO_HEADER
+This command inserts an MPEG4 header syntax or SPS or PPS to the AVC/H.264 bitstream to the bitstream
+during encoding. The argument `parameter` is interpreted as a pointer to EncHeaderParam structure holding
+
+* buf is a physical address pointing the generated stream location
+* size is the size of generated stream in bytes
+* headerType is a type of header that HOST application wants to generate and have values as
+VOL_HEADER, VOS_HEADER,, VO_HEADER, SPS_RBSP or PPS_RBSP.
+
+This command has one of the following return codes.::
++
+--
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header
+syntax was successfully inserted.
+* RETCODE_INVALID_COMMAND:
+This means the given argument cmd was invalid
+which means the given cmd was undefined, or not allowed in the current instance. In this
+case, the current instance might not be an MPEG4 encoder instance.
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` or headerType
+was invalid, which means it has a null pointer, or given values for some member variables
+are improper values.
+* RETCODE_VPU_RESPONSE_TIMEOUT:
+Operation has not recieved any response from VPU and has timed out.
+--
+
+====== ENC_PUT_MP4_HEADER
+This command inserts an MPEG4 header syntax to the bitstream during encoding.
+The argument `parameter` is interpreted as a pointer to EncHeaderParam
+structure holding
+
+* `buf` is a physical address pointing the generated stream
+location
+* `size` is the size of generated stream in bytes
+* `headerType` is a type of header that HOST application wants to generate and have values as VOL_HEADER,
+VOS_HEADER, or VO_HEADER.
+
+This command has one of the following return codes.::
++
+--
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header syntax was
+successfully inserted.
+* RETCODE_INVALID_COMMAND:
+This means the given argument `cmd` was invalid which means the given cmd was
+undefined, or not allowed in the current instance. In this case, the current
+instance might not be an MPEG4 encoder instance.
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` or `headerType` was invalid, which means it
+has a null pointer, or given values for some member variables are improper
+values.
+* RETCODE_VPU_RESPONSE_TIMEOUT:
+Operation has not recieved any response from VPU and has timed out.
+--
+
+====== ENC_PUT_AVC_HEADER
+This command inserts an SPS or PPS to the AVC/H.264 bitstream during encoding.
+
+The argument `parameter` is interpreted as a pointer to EncHeaderParam
+structure holding
+
+* buf is a physical address pointing the generated stream location
+* size is the size of generated stream in bytes
+* headerType is type of header that HOST application wants to generate and have values as SPS_RBSP or
+PPS_RBSP.
+
+This command has one of the following return codes.::
++
+--
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header syntax was
+successfully inserted.
+* RETCODE_INVALID_COMMAND:
+This means the given argument `cmd` was invalid which means the given `cmd` was
+undefined, or not allowed in the current instance. In this case, the current
+instance might not be an AVC/H.264 encoder instance.
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` or `headerType` was invalid, which means it
+has a null pointer, or given values for some member variables are improper
+values.
+* RETCODE_VPU_RESPONSE_TIMEOUT:
+Operation has not recieved any response from VPU and has timed out.
+--
+
+====== ENC_GET_VIDEO_HEADER
+This command gets a SPS to the AVC/H.264 bitstream to the bitstream during encoding.
+Because VPU does not generate bitstream but HOST application generate bitstream in this command,
+HOST application has to set pBuf value to access bitstream buffer.
+The argument `parameter` is interpreted as a pointer to EncHeaderParam structure holding
+
+* buf is a physical address pointing the generated stream location
+* pBuf is a virtual address pointing the generated stream location
+* size is the size of generated stream in bytes
+* headerType is a type of header that HOST application wants to generate and have values as SPS_RBSP.
+
+This command has one of the following return codes.::
++
+--
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header
+syntax was successfully inserted.
+* RETCODE_INVALID_COMMAND:
+This means the given argument cmd was invalid
+which means the given cmd was undefined, or not allowed in the current instance. In this
+case, the current instance might not be an AVC/H.264 encoder instance.
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` or headerType
+was invalid, which means it has a null pointer, or given values for some member variables
+are improper values.
+* RETCODE_VPU_RESPONSE_TIMEOUT:
+Operation has not recieved any response from VPU and has timed out.
+--
+
+====== ENC_SET_INTRA_MB_REFRESH_NUMBER
+This command sets intra MB refresh number of header syntax.
+The argument `parameter` is interpreted as a pointer to integer which
+represents an intra refresh number. It should be between 0 and
+macroblock number of encoded picture.
+
+This command returns the following code.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header syntax was
+successfully inserted.
+* RETCODE_VPU_RESPONSE_TIMEOUT:
+Operation has not recieved any response from VPU and has timed out.
+
+====== ENC_ENABLE_HEC
+This command enables HEC(Header Extension Code) syntax of MPEG4.
+
+This command ignores the argument `parameter` and returns one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header syntax was
+successfully inserted.
+* RETCODE_INVALID_COMMAND:
+This means the given argument, cmd, was invalid which means the given cmd was
+undefined, or not allowed in the current instance. In this case, the current
+instance might not be an MPEG4 encoder instance.
+* RETCODE_VPU_RESPONSE_TIMEOUT:
+Operation has not recieved any response from VPU and has timed out.
+
+====== ENC_DISABLE_HEC
+This command disables HEC(Header Extension Code) syntax of MPEG4.
+
+This command ignores the argument `parameter` and returns one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header syntax was
+successfully inserted.
+* RETCODE_INVALID_COMMAND:
+This means the given argument, cmd, was invalid which means the given cmd was
+undefined, or not allowed in the current instance. In this case, the current
+instance might not be an MPEG4 encoder instance.
+* RETCODE_VPU_RESPONSE_TIMEOUT:
+Operation has not recieved any response from VPU and has timed out.
+
+====== ENC_SET_SLICE_INFO
+This command sets slice inforamtion of header syntax.
+The argument `parameter` is interpreted as a pointer to EncSliceMode
+structure holding
+
+* sliceModeuf is a mode which means enabling multi slice structure
+* sliceSizeMode is the mode representing mode of calculating one slicesize
+* sliceSize is the size of one slice.
+
+This command has one of the following return codes.::
++
+--
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header syntax was
+successfully inserted.
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` or `headerType` was invalid, which means it
+has a null pointer, or given values for some member variables are improper
+values.
+* RETCODE_VPU_RESPONSE_TIMEOUT:
+Operation has not recieved any response from VPU and has timed out.
+--
+
+====== ENC_SET_GOP_NUMBER
+This command sets GOP number of header syntax.
+The argument `parameter` is interpreted as a pointer to the integer which
+represents a GOP number.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header syntax was
+successfully inserted.
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` or `headerType` was invalid, which means it
+has a null pointer, or given values for some member variables are improper
+values.
+* RETCODE_VPU_RESPONSE_TIMEOUT:
+Operation has not recieved any response from VPU and has timed out.
+
+====== ENC_SET_INTRA_QP
+This command sets intra QP value of header syntax.
+The argument `parameter` is interpreted as a pointer to the integer which
+represents a Constant I frame QP. The Constant I frame QP should be between 1 and 31
+for MPEG4 and between 0 and 51 for AVC/H.264.
+
+This command has one of the following return codes::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header syntax was
+successfully inserted.
+* RETCODE_INVALID_COMMAND:
+This means the given argument `cmd` was invalid which means the given cmd was
+undefined, or not allowed in the current instance. In this case, the current
+instance might not be an encoder instance.
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` or `headerType` was invalid, which means it
+has a null pointer, or given values for some member variables are improper
+values.
+* RETCODE_VPU_RESPONSE_TIMEOUT:
+Operation has not recieved any response from VPU and has timed out.
+
+====== ENC_SET_BITRATE
+This command sets bitrate inforamtion of header syntax.
+The argument `parameter` is interpreted as a pointer to the integer which
+represents a bitrate. It should be between 0 and 32767.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header syntax was
+successfully inserted.
+* RETCODE_INVALID_COMMAND:
+This means the given argument `cmd` was invalid which means the given `cmd` was
+undefined, or not allowed in the current instance. In this case, the current
+instance might not be an encoder instance.
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` or `headerType` was invalid, which means it
+has a null pointer, or given values for some member variables are improper
+values.
+* RETCODE_VPU_RESPONSE_TIMEOUT:
+Operation has not recieved any response from VPU and has timed out.
+
+====== ENC_SET_FRAMERATE
+This command sets frame rate of header syntax.
+The argument `parameter` is interpreted as a pointer to the integer which
+represents a frame rate value. The fraem rate should be greater than 0.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header syntax was
+successfully inserted.
+* RETCODE_INVALID_COMMAND:
+This means the given argument `cmd` was invalid which means the given `cmd` was
+undefined, or not allowed in the current instance. In this case, the current
+instance might not be an encoder instance.
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` or `headerType` was invalid, which means it
+has a null pointer, or given values for some member variables are improper
+values.
+* RETCODE_VPU_RESPONSE_TIMEOUT:
+Operation has not recieved any response from VPU and has timed out.
+
+====== ENC_SET_SEARCHRAM_PARAM
+This command sets the parameter of search sram used in encoder.
+The `parameter` is interpreted as a pointer to SearchRamParam.
+
+This command has one of the following return codes.::
+
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` or `SearchRamSize` was invalid,
+which means it has a null pointer, or given values for some member variables are improper values.
+
+====== ENC_SET_REPORT_MBINFO
+This command sets MB data report structure. The argument `parameter` is interpreted as a pointer
+to address and returns RETCODE_SUCCESS.
+
+If this option is set, the slice boundary and QP are reported using 1 bytes.
+
+* [7] : Reserved
+* [6] : Slice Boundary. Whenever a new slice header is decoded, this bit field is
+toggled.
+* [5:0] : An macroblock QP value
+
+====== ENC_SET_REPORT_MVINFO
+This command sets motion vector report structure. The argument `parameter` is interpreted as a
+pointer to address and returns RETCODE_SUCCESS.
+
+If this option is set, the motion vector information are reported using 4 bytes.
+
+* [31] : Intra Flag (1: intra, 0: inter)
+* [30:16] : X value of motion vector
+* [16:0] : Y value of motion vector
+
+====== ENC_SET_REPORT_SLICEINFO
+This command sets slice information report structure.
+The argument `parameter` is interpreted as a pointer to address and returns RETCODE_SUCCESS.
+
+If this option is set, the slice information are reported using 8 bytes.
+
+* [63:48] : Reserved.
+* [47:32] :The last macroblock indeed of a slice (zero based-index)
+* [31:0] : Total of bits used for encoding a slice.
+
+====== ENC_SET_PIC_PARA_ADDR
+This command sets the address of picture parameter base. The argument `parameter` is interpreted
+as a pointer to `address` and returns RETCODE_SUCCESS.
+
+To report MB data, Motion Vector, and Slice information, VPU should reads the base
+address of external memory, which all are specified by picParaBaseAddr.
+
+[[enc_pic_param_baseaddr_struct]]
+.Encoder Picture parameter base address structure
+ifdef::pdf[]
+image::../figure/enc_pic_param_baseaddr_struct.svg["Encoder Picture parameter base address structure", width=300]
+endif::pdf[]
+ifdef::html[]
+image::../figure/enc_pic_param_baseaddr_struct.png[Encoder Picture parameter base address structure]
+endif::html[]
+
+When `enReportMBInfo`, `enReportMVInfo`, and `enReportSliceinfo` in CMD_ENC_PIC_OPTION
+register are enabled, HOST application should specify the buffer addresses in <<enc_pic_param_baseaddr_struct>>.
+VPU reports each data and fills info, Data Size and other fields
+to these buffer addresses of external memory. For VPU to report data properly,
+HOST application needs to specify these 3 buffer addresses preserving 8 byte alignment and
+buffer sizes need to be multiples of 256.
+
+====== SET_SEC_AXI
+This command sets the secondary channel of AXI for saving memory bandwidth to
+dedicated memory. The argument `parameter` is interpreted as a pointer to SecAxiUse which
+represents an enable flag and physical address which is related with the secondary
+channel for BIT processor, IP/AC-DC predictor, de-blocking filter, overlap
+filter respectively.
+
+This command has one of the following return codes.::
+
+* RETCODE_SUCCESS:
+Operation was done successfully, which means given value for setting secondary
+AXI is valid.
+* RETCODE_INVALID_PARAM:
+The given argument parameter, `parameter`, was invalid, which means given value is
+invalid.
+
+====== ENABLE_LOGGING
+HOST can activate message logging once VPU_DecOpen() or VPU_EncOpen() is called.
+
+====== DISABLE_LOGGING
+HOST can deactivate message logging which is off as default.
+
+====== ENC_CONFIG_SUB_FRAME_SYNC
+This command sets the configuration of sub frame sync mode.
+The `parameter` is interpreted as a pointer to EncSubFrameSyncConfig. This command returns RETCODE_SUCCESS.
+
+====== ENC_SET_SUB_FRAME_SYNC
+This command sets the status of sub frame sync signal.
+The `parameter` is interpreted as a pointer to EncSubFrameSyncState. This command returns RETCODE_SUCCESS.
+
+====== ENC_SET_PARA_CHANGE
+This command changes encoding parameter(s) during the encoding operation in H.265/AVC encoder
+The argument `parameter` is interpreted as a pointer to <<vpuapi_h_EncChangeParam>> structure holding
+
+* enable_option : Set an enum value that is associated with parameters to change (multiple option allowed).
+
+For instance, if bitrate and framerate need to be changed in the middle of encoding, that requires some setting like below.
+
+ EncChangeParam changeParam;
+  changeParam.enable_option     = ENC_RC_TARGET_RATE_CHANGE | ENC_FRAME_RATE_CHANGE;
+
+ changeParam.bitrate           = 14213000;
+ changeParam.frameRate         = 15;
+ VPU_EncGiveCommand(handle, ENC_SET_PARA_CHANGE, &changeParam);
+
+This command has one of the following return codes.::
++
+--
+* RETCODE_SUCCESS:
+Operation was done successfully, which means the requested header syntax was
+successfully inserted.
+* RETCODE_INVALID_COMMAND:
+This means the given argument `cmd` was invalid which means the given `cmd` was
+undefined, or not allowed in the current instance. In this case, the current
+instance might not be an AVC/H.264 encoder instance.
+* RETCODE_INVALID_PARAM:
+The given argument parameter `parameter` or `headerType` was invalid, which means it
+has a null pointer, or given values for some member variables are improper
+values.
+* RETCODE_VPU_RESPONSE_TIMEOUT:
+Operation has not recieved any response from VPU and has timed out.
+--
+
+====== ENC_SET_PROFILE
+
+This command encodes videos into H.264/AVC stream with HOST application-given profile in header syntax. (CODA9 only)
+
+====== SET_ENC_WTL_INFO
+This command sets information of frame buffer such as Y/Cb/Cr addr, cbcrinterleave, nv21, and number of linear framebuffer for WTL-enabled encoder.
+
+====== SET_ADDR_ENC_RC_REPORT_BASE
+This command sets the base address of report buffer.
+It should be specified when any of these bitInfoReportEnable, frameDistortionReportEnable,
+ or qpHistogramReportEnable in EncParam is on.
+In total 144bytes of data are reported to the report buffer from w4EncReportBaseAddr in the following order.
+If a certain ReportEnable flag is diabled i.e frameDistortionReportEnable, dummy data are written into the frameDistortion region of the buffer.
+
+image::../figure/rc_report.png["Report Buffer", width=150]
+
+--
+* bit information
+
+@* Header bits : total slice header bits of the current frame except start code
+@* Residual bits : total residual bits of the current frame
+
+header bits are in the beginning 32bits of w4EncReportBaseAddr,
+ and header bits are in the following 32bits of the report buffer.
+
+* frame distortion
+
+With this command,
+frame distortion data - frame distortion sum, y, cb, and cr for each 8bytes, totally 32bytes) are
+reported 8bytes away from w4EncReportBaseAddr (w4EncReportBaseAddr + 8) when picture encoding is completed.
+
+* QP histogram
+
+With this command,
+QP histogram for every subCTU(CU32) taking 16bits are reported 40bytes away from w4EncReportBaseAddr
+(w4EncReportBaseAddr + 40) when picture encoding is completed.
+--
+
+====== SET_SIZE_ENC_RC_REPORT
+This command sets the size of report buffer.
+It should be specified when any of these bitInfoReportEnable, frameDistortionReportEnable,
+ or qpHistogramReportEnable in EncParam is on.
+
+@endverbatim
+*/
+RetCode VPU_EncGiveCommand(
+	EncHandle handle, /**< [Input] An encoder handle obtained from VPU_EncOpen() */
+	CodecCommand
+		cmd, /**< [Input] A variable specifying the given command of CodecComand type */
+	void *parameter /**< [Input/Output] A pointer to command-specific data structure which describes picture I/O parameters for the current encoder instance */
+);
+
+/**
+* @brief
+@verbatim
+This function starts encoding one frame. Returning from this function does not
+mean the completion of encoding one frame, and it is just that encoding one
+frame was initiated.
+
+Every call of this function should be matched with VPU_EncGetOutputInfo()
+with the same handle. Without calling a pair of these funtions,
+HOST application cannot call any other API functions
+except for VPU_IsBusy(), VPU_EncGetBitstreamBuffer(), and
+VPU_EncUpdateBitstreamBuffer().
+@endverbatim
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means encoding a new frame was started
+successfully.
++
+--
+NOTE: This return value does not mean that encoding a frame was completed
+successfully.
+--
+*RETCODE_INVALID_HANDLE* ::
+This means the given handle for the current API function call, pHandle, was invalid.
+This return code might be caused if
++
+--
+* handle is not a handle which has been obtained by VPU_EncOpen().
+* handle is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame decoding or encoding operation was not completed yet, so the
+given API function call cannot be performed this time. A frame encoding or
+decoding operation should be completed by calling VPU_EncGetOutputInfo() or
+VPU_DecGetOutputInfo(). Even though the result of the current frame operation is
+not necessary, HOST application should call VPU_EncGetOutputInfo() or
+VPU_DecGetOutputInfo() to proceed this function call.
+
+*RETCODE_WRONG_CALL_SEQUENCE* ::
+This means the current API function call was invalid considering the allowed
+sequences between API functions. In this case, HOST application might call this
+function before successfully calling VPU_EncRegisterFrameBuffer(). This function
+should be called after successfully calling VPU_EncRegisterFrameBuffer().
+
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, `parameter`, was invalid, which means it has a null
+pointer, or given values for some member variables are improper values.
+
+*RETCODE_INVALID_FRAME_BUFFER* ::
+This means sourceFrame in input structure EncParam was invalid, which means
+sourceFrame was not valid even though picture-skip is disabled.
+@endverbatim
+*/
+RetCode VPU_EncStartOneFrame(
+	EncHandle handle, /**< [Input] An encoder handle obtained from VPU_EncOpen()  */
+	EncParam *param /**< [Input] A pointer to EncParam type structure which describes picture encoding parameters for the current encoder instance.  */
+);
+
+/**
+* @brief    This function gets information of the output of encoding. Application can know
+about picture type, the address and size of the generated bitstream, the number
+of generated slices, the end addresses of the slices, and macroblock bit
+position information. HOST application should call this function after frame
+encoding is finished, and before starting the further processing.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means the output information of the current
+frame encoding was received successfully.
+
+*RETCODE_INVALID_HANDLE* ::
+The given handle for the current API function call, pHandle, was invalid. This
+return code might be caused if
++
+--
+* handle is not a handle which has been obtained by VPU_EncOpen(), for example
+a decoder handle,
+* handle is a handle of an instance which has been closed already,
+* handle is not the same handle as the last VPU_EncStartOneFrame() has, etc.
+--
+*RETCODE_WRONG_CALL_SEQUENCE* ::
+This means the current API function call was invalid considering the allowed
+sequences between API functions. HOST application might call this
+function before calling VPU_EncStartOneFrame() successfully. This function
+should be called after successful calling of VPU_EncStartOneFrame().
+
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, pInfo, was invalid, which means it has a null
+pointer, or given values for some member variables are improper values.
+@endverbatim
+*/
+RetCode VPU_EncGetOutputInfo(
+	EncHandle handle, /**<  [Input] An encoder handle obtained from VPU_EncOpen().  */
+	EncOutputInfo *
+		info /**<  [Output] A pointer to a EncOutputInfo type structure which describes picture encoding results for the current encoder instance. */
+);
+
+/**
+* @brief    After encoding frame, HOST application must get bitstream from the encoder. To do
+that, they must know where to get bitstream and the maximum size.
+Applications can get the information by calling this function.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully. That means the current encoder instance was closed
+successfully.
+
+*RETCODE_INVALID_HANDLE* ::
+This means the given handle for the current API function call, pHandle, was invalid.
+This return code might be caused if
++
+--
+* pHandle is not a handle which has been obtained by VPU_EncOpen().
+* pHandle is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, pRdptr, pWrptr or size, was invalid, which means
+it has a null pointer, or given values for some member variables are improper
+values.
+@endverbatim
+*/
+RetCode VPU_EncGetBitstreamBuffer(
+	EncHandle handle, /**<  [Input] An encoder handle obtained from VPU_EncOpen()  */
+	PhysicalAddress *
+		prdPrt, /**<  [Output] A stream buffer read pointer for the current encoder instance */
+	PhysicalAddress *
+		pwrPtr, /**<  [Output] A stream buffer write pointer for the current encoder instance */
+	int *size /**<  [Output] A variable specifying the available space in bitstream buffer for the current encoder instance */
+);
+
+/**
+* @brief    Applications must let encoder know how much bitstream has been transferred from
+the address obtained from VPU_EncGetBitstreamBuffer(). By just giving the size
+as an argument, API automatically handles pointer wrap-around and updates the read
+pointer.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully. That means the current encoder instance was closed
+successfully.
+
+*RETCODE_INVALID_HANDLE* ::
+This means the given handle for the current API function call, pHandle, was invalid.
+This return code might be caused if
++
+--
+* pHandle is not a handle which has been obtained by VPU_EncOpen().
+* pHandle is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_INVALID_PARAM* ::
+The given argument parameter, size, was invalid, which means size is larger than
+the value obtained from VPU_EncGetBitstreamBuffer().
+@endverbatim
+*/
+RetCode VPU_EncUpdateBitstreamBuffer(
+	EncHandle handle, /**< [Input] An encoder handle obtained from VPU_EncOpen() */
+	int size /**< [Input] A variable specifying the amount of bits being filled from bitstream buffer for the current encoder instance */
+);
+
+/**
+* @brief    This function specifies the location of write pointer in bitstream buffer. It can also set a read
+pointer with the same value of write pointer (addr) when updateRdPtr is not a zero value.
+This function can be used regardless of bitstream buffer mode.
+* @return
+@verbatim
+*RETCODE_SUCCESS* ::
+Operation was done successfully, which means required information of the stream data to be
+encoded was received successfully.
+*RETCODE_FAILURE* ::
+Operation was failed, which means there was an error in getting information for configuring
+the encoder.
+*RETCODE_INVALID_HANDLE* ::
++
+--
+This means the given handle for the current API function call, `handle`, was invalid. This return
+code might be caused if
+
+* `handle` is not a handle which has been obtained by VPU_EncOpen().
+* `handle` is a handle of an instance which has been closed already, etc.
+--
+*RETCODE_FRAME_NOT_COMPLETE* ::
+This means frame encoding operation was not completed yet, so the given API function call
+cannot be performed this time. A frame encoding operation should be completed by calling
+VPU_ EncSetRdPtr ().
+@endverbatim
+*/
+RetCode VPU_EncSetWrPtr(
+	EncHandle handle, /**< [Input] An encoder handle obtained from VPU_EncOpen()  */
+	PhysicalAddress addr, /**< [Input] Updated write or read pointer */
+	int updateRdPtr /**< [Input] A flag whether to move the read pointer to where the write pointer is located */
+);
+
+/**
+Not used
+*/
+void VPU_EncSetHostParaAddr(PhysicalAddress baseAddr, PhysicalAddress paraAddr);
+
+RetCode VPU_EncIssueSeqInit(
+	EncHandle handle /**<  [Input] A encoder handle obtained from VPU_EncOpen() */
+);
+
+RetCode VPU_DecGetBitstreamBufferNoHW(DecHandle handle, PhysicalAddress *prdPrt,
+				      PhysicalAddress *pwrPtr, Uint32 *size);
+
+RetCode VPU_DecUpdateBitstreamBufferNoHW(DecHandle handle, int size);
+
+#ifdef ENABLE_TEE_DRM_FLOW
+RetCode VPU_InitWithBitcodeProtect(
+	Uint32 coreIdx, /**< [Input] An index of VPU core */
+	const Uint16 *
+		bitcode, /**< [Input] Buffer where binary format of BIT firmware is located */
+	Uint32 sizeInWord, /**< [Input] Size of binary BIT firmware in short integer */
+	void *sess, void *rtk_sess, void *filp);
+#endif
+
+RetCode VPU_DBG_DUMP_SDATA(DecHandle handle, unsigned int phy_addr,
+			   unsigned char *dst_buf, int dst_buf_size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_vpuapifunc.c
@@ -0,0 +1,5174 @@
+//--=========================================================================--
+//  This file is a part of VPU Reference API project
+//-----------------------------------------------------------------------------
+//
+//       This confidential and proprietary software may be used only
+//     as authorized by a licensing agreement from Chips&Media Inc.
+//     In the event of publication, the following notice is applicable:
+//
+//            (C) COPYRIGHT 2006 - 2011  CHIPS&MEDIA INC.
+//                      ALL RIGHTS RESERVED
+//
+//       The entire notice above must be reproduced on all authorized
+//       copies.
+//
+//--=========================================================================--
+
+#include <linux/module.h>
+#include "ve1_vpuapifunc.h"
+#include "ve1_product.h"
+#include "ve1_vpu.h"
+#include "ve1_regdefine.h"
+#include "ve1_vpuconfig.h"
+
+#ifndef MIN
+#define MIN(a, b) (((a) < (b)) ? (a) : (b))
+#endif
+#ifndef MAX
+#define MAX(a, b) (((a) > (b)) ? (a) : (b))
+#endif
+#define MAX_LAVEL_IDX 16
+static const int g_anLevel[MAX_LAVEL_IDX] = { 10, 11, 11, 12, 13,
+					      20, 21, 22, 30, 31, 32, 40, 41,
+					      42, 50, 51 };
+
+static const int g_anLevelMaxMBPS[MAX_LAVEL_IDX] = {
+	1485,  1485,   3000,   6000,   11880,  11880,  19800,  20250,
+	40500, 108000, 216000, 245760, 245760, 522240, 589824, 983040
+};
+
+static const int g_anLevelMaxFS[MAX_LAVEL_IDX] = { 99,	 99,   396,   396,
+						   396,	 396,  792,   1620,
+						   1620, 3600, 5120,  8192,
+						   8192, 8704, 22080, 36864 };
+
+static const int g_anLevelMaxBR[MAX_LAVEL_IDX] = {
+	64,    64,    192,   384,   768,   2000,  4000,	  4000,
+	10000, 14000, 20000, 20000, 50000, 50000, 135000, 240000
+};
+
+static const int g_anLevelSliceRate[MAX_LAVEL_IDX] = { 0,  0,  0,  0,  0,  0,
+						       0,  0,  22, 60, 60, 60,
+						       24, 24, 24, 24 };
+
+static const int g_anLevelMaxMbs[MAX_LAVEL_IDX] = {
+	28, 28, 56, 56, 56, 56, 79, 113, 113, 169, 202, 256, 256, 263, 420, 543
+};
+
+/******************************************************************************
+    define value
+******************************************************************************/
+
+/******************************************************************************
+    Codec Instance Slot Management
+******************************************************************************/
+
+RetCode InitCodecInstancePool(Uint32 coreIdx)
+{
+	int i;
+	CodecInst *pCodecInst;
+	vpu_instance_pool_t *vip;
+
+	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(coreIdx);
+	if (!vip)
+		return RETCODE_INSUFFICIENT_RESOURCE;
+
+	if (vip->instance_pool_inited == 0) {
+		for (i = 0; i < MAX_NUM_INSTANCE; i++) {
+			pCodecInst = (CodecInst *)vip->codecInstPool[i];
+			pCodecInst->instIndex = i;
+			pCodecInst->inUse = 0;
+		}
+		vip->instance_pool_inited = 1;
+	}
+	return RETCODE_SUCCESS;
+}
+
+/*
+ * GetCodecInstance() obtains a instance.
+ * It stores a pointer to the allocated instance in *ppInst
+ * and returns RETCODE_SUCCESS on success.
+ * Failure results in 0(null pointer) in *ppInst and RETCODE_FAILURE.
+ */
+
+RetCode GetCodecInstance(Uint32 coreIdx, CodecInst **ppInst, void *filp)
+{
+	int i;
+	CodecInst *pCodecInst = 0;
+	vpu_instance_pool_t *vip;
+	Uint32 handleSize;
+	int instIdx;
+
+	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(coreIdx);
+	if (!vip)
+		return RETCODE_INSUFFICIENT_RESOURCE;
+
+	for (i = 0; i < MAX_NUM_INSTANCE; i++) {
+		pCodecInst = (CodecInst *)vip->codecInstPool[i];
+
+		if (!pCodecInst) {
+			return RETCODE_FAILURE;
+		}
+
+		if (!pCodecInst->inUse) {
+			break;
+		}
+	}
+
+	if (i == MAX_NUM_INSTANCE) {
+		*ppInst = 0;
+		return RETCODE_FAILURE;
+	}
+
+	instIdx = pCodecInst->instIndex; //RTK
+	osal_memset(pCodecInst, 0x00, sizeof(CodecInst));
+
+	pCodecInst->inUse = 1;
+	pCodecInst->coreIdx = coreIdx;
+	pCodecInst->codecMode = -1;
+	pCodecInst->codecModeAux = -1;
+	pCodecInst->loggingEnable = 0;
+	pCodecInst->isDecoder = TRUE;
+	pCodecInst->productId = ProductVpuGetId(coreIdx);
+	pCodecInst->instIndex = instIdx;
+	pCodecInst->filp = filp;
+	osal_memset((void *)&pCodecInst->CodecInfo, 0x00,
+		    sizeof(pCodecInst->CodecInfo));
+
+	handleSize = sizeof(DecInfo);
+	if (handleSize < sizeof(EncInfo)) {
+		handleSize = sizeof(EncInfo);
+	}
+	if ((pCodecInst->CodecInfo = (void *)osal_malloc(handleSize)) == NULL) {
+		return RETCODE_INSUFFICIENT_RESOURCE;
+	}
+	osal_memset(pCodecInst->CodecInfo, 0x00, sizeof(handleSize));
+
+	*ppInst = pCodecInst;
+
+	if (vdi_open_instance(pCodecInst->coreIdx, pCodecInst->instIndex,
+			      filp) < 0) {
+		return RETCODE_FAILURE;
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+void FreeCodecInstance(CodecInst *pCodecInst)
+{
+	pCodecInst->inUse = 0;
+	pCodecInst->codecMode = -1;
+	pCodecInst->codecModeAux = -1;
+
+	vdi_close_instance(pCodecInst->coreIdx, pCodecInst->instIndex);
+
+	osal_free(pCodecInst->CodecInfo);
+	pCodecInst->CodecInfo = NULL;
+}
+
+RetCode CheckInstanceValidity(CodecInst *pCodecInst)
+{
+	int i;
+	vpu_instance_pool_t *vip;
+
+	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(pCodecInst->coreIdx);
+	if (!vip)
+		return RETCODE_INSUFFICIENT_RESOURCE;
+
+	for (i = 0; i < MAX_NUM_INSTANCE; i++) {
+		if ((CodecInst *)vip->codecInstPool[i] == pCodecInst)
+			return RETCODE_SUCCESS;
+	}
+
+	return RETCODE_INVALID_HANDLE;
+}
+
+/******************************************************************************
+    API Subroutines
+******************************************************************************/
+
+RetCode CheckDecOpenParam(DecOpenParam *pop)
+{
+	if (pop == 0) {
+		return RETCODE_INVALID_PARAM;
+	}
+	if (pop->bitstreamBuffer % 8) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	if (pop->bitstreamBufferSize % 1024 ||
+	    pop->bitstreamBufferSize < 1024 ||
+	    pop->bitstreamBufferSize > (256 * 1024 * 1024 - 1)) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	if (pop->bitstreamFormat != STD_AVC &&
+	    pop->bitstreamFormat != STD_VC1 &&
+	    pop->bitstreamFormat != STD_MPEG2 &&
+	    pop->bitstreamFormat != STD_H263 &&
+	    pop->bitstreamFormat != STD_MPEG4 &&
+	    pop->bitstreamFormat != STD_UNKNOWN3 &&
+	    pop->bitstreamFormat != STD_RV && pop->bitstreamFormat != STD_AVS &&
+	    pop->bitstreamFormat != STD_THO &&
+	    pop->bitstreamFormat != STD_VP3 &&
+	    pop->bitstreamFormat != STD_VP8 &&
+	    pop->bitstreamFormat != STD_HEVC &&
+	    pop->bitstreamFormat != STD_VP9) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	if (pop->mp4DeblkEnable == 1 &&
+	    !(pop->bitstreamFormat == STD_MPEG4 ||
+	      pop->bitstreamFormat == STD_MPEG2 ||
+	      pop->bitstreamFormat == STD_UNKNOWN3)) {
+		return RETCODE_INVALID_PARAM;
+	}
+	if (pop->wtlEnable && pop->tiled2LinearEnable) {
+		return RETCODE_INVALID_PARAM;
+	}
+	if (pop->wtlEnable) {
+		if (pop->wtlMode != FF_FRAME && pop->wtlMode != FF_FIELD) {
+			return RETCODE_INVALID_PARAM;
+		}
+	}
+
+	if (pop->coreIdx > MAX_NUM_VPU_CORE) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+void ConfigDecWPROTRegion(int coreIdx, DecInfo *pDecInfo)
+{
+	PhysicalAddress tempBuffer;
+	vpu_instance_pool_t *vip;
+	WriteMemProtectCfg *pCgf = &pDecInfo->writeMemProtectCfg;
+	vpu_buffer_t *pvbWorkPs = &pDecInfo->vbWork;
+
+	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(coreIdx);
+	if (!vip)
+		return;
+
+	tempBuffer = vip->vpu_common_buffer.phys_addr + CODE_BUF_SIZE;
+	pCgf->decRegion[WPROT_DEC_TEMP].enable = 1;
+	pCgf->decRegion[WPROT_DEC_TEMP].isSecondary = 0;
+	pCgf->decRegion[WPROT_DEC_TEMP].startAddress = tempBuffer;
+	pCgf->decRegion[WPROT_DEC_TEMP].endAddress =
+		tempBuffer + TEMP_BUF_SIZE + PARA_BUF_SIZE;
+	VLOG(INFO,
+	     "[%d]%s.set decRegion[WPROT_DEC_TEMP](%d,%d,0x%08x,0x%08x)\n",
+	     __LINE__, __func__, pCgf->decRegion[WPROT_DEC_TEMP].enable,
+	     pCgf->decRegion[WPROT_DEC_TEMP].isSecondary,
+	     pCgf->decRegion[WPROT_DEC_TEMP].startAddress,
+	     pCgf->decRegion[WPROT_DEC_TEMP].endAddress);
+
+	if (pvbWorkPs->size) {
+		pCgf->decRegion[WPROT_DEC_WORK].enable = 1;
+		pCgf->decRegion[WPROT_DEC_WORK].isSecondary = 0;
+		pCgf->decRegion[WPROT_DEC_WORK].startAddress =
+			pvbWorkPs->phys_addr;
+		pCgf->decRegion[WPROT_DEC_WORK].endAddress =
+			pvbWorkPs->phys_addr + pvbWorkPs->size;
+		VLOG(INFO,
+		     "[%d]%s.set decRegion[WPROT_DEC_WORK](%d,%d,0x%08x,0x%08x)\n",
+		     __LINE__, __func__, pCgf->decRegion[WPROT_DEC_WORK].enable,
+		     pCgf->decRegion[WPROT_DEC_WORK].isSecondary,
+		     pCgf->decRegion[WPROT_DEC_WORK].startAddress,
+		     pCgf->decRegion[WPROT_DEC_WORK].endAddress);
+	}
+}
+#endif // #ifdef ENABLE_CODA9_WRITE_PROTECT
+
+Uint64 GetTimestamp(EncHandle handle)
+{
+	CodecInst *pCodecInst = (CodecInst *)handle;
+	EncInfo *pEncInfo = NULL;
+	Uint64 pts;
+	Uint32 fps;
+
+	if (pCodecInst == NULL) {
+		return 0;
+	}
+
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+	fps = pEncInfo->openParam.frameRateInfo;
+	if (fps == 0) {
+		fps = 30; /* 30 fps */
+	}
+
+	pts = pEncInfo->curPTS;
+	pEncInfo->curPTS += 90000 / fps; /* 90KHz/fps */
+
+	return pts;
+}
+
+int DecBitstreamBufEmpty(DecInfo *pDecInfo)
+{
+	return (pDecInfo->streamRdPtr == pDecInfo->streamWrPtr);
+}
+
+RetCode SetParaSet(DecHandle handle, int paraSetType, DecParamSet *para)
+{
+	CodecInst *pCodecInst;
+	PhysicalAddress paraBuffer;
+	int i;
+	Uint32 *src;
+
+	pCodecInst = handle;
+	src = para->paraSet;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	paraBuffer = VpuReadReg(pCodecInst->coreIdx, BIT_PARA_BUF_ADDR);
+	for (i = 0; i < para->size; i += 4) {
+		VpuWriteReg(pCodecInst->coreIdx, paraBuffer + i, *src++);
+	}
+	VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PARA_SET_TYPE,
+		    paraSetType); // 0: SPS, 1: PPS
+	VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PARA_SET_SIZE, para->size);
+
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst, DEC_PARA_SET);
+	if (vdi_wait_vpu_busy(pCodecInst->coreIdx, __VPU_BUSY_TIMEOUT,
+			      BIT_BUSY_FLAG) == -1) {
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, DEC_PARA_SET, 0);
+		LeaveLock(pCodecInst->coreIdx);
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, DEC_PARA_SET, 0);
+
+	LeaveLock(pCodecInst->coreIdx);
+	return RETCODE_SUCCESS;
+}
+
+void DecSetHostParaAddr(Uint32 coreIdx, PhysicalAddress baseAddr,
+			PhysicalAddress paraBuffer)
+{
+	BYTE tempBuf[8] = {
+		0,
+	}; // 64bit bus & endian
+	Uint32 val;
+
+	val = paraBuffer;
+	tempBuf[0] = 0;
+	tempBuf[1] = 0;
+	tempBuf[2] = 0;
+	tempBuf[3] = 0;
+	tempBuf[4] = (val >> 24) & 0xff;
+	tempBuf[5] = (val >> 16) & 0xff;
+	tempBuf[6] = (val >> 8) & 0xff;
+	tempBuf[7] = (val >> 0) & 0xff;
+	VpuWriteMem(coreIdx, baseAddr, (BYTE *)tempBuf, 8, VDI_BIG_ENDIAN);
+}
+
+RetCode CheckEncInstanceValidity(EncHandle handle)
+{
+	CodecInst *pCodecInst;
+	RetCode ret;
+
+	if (handle == NULL)
+		return RETCODE_INVALID_HANDLE;
+
+	pCodecInst = handle;
+	ret = CheckInstanceValidity(pCodecInst);
+	if (ret != RETCODE_SUCCESS) {
+		return RETCODE_INVALID_HANDLE;
+	}
+	if (!pCodecInst->inUse) {
+		return RETCODE_INVALID_HANDLE;
+	}
+
+	if (pCodecInst->codecMode != MP4_ENC &&
+	    pCodecInst->codecMode != HEVC_ENC &&
+	    pCodecInst->codecMode != AVC_ENC &&
+	    pCodecInst->codecMode != W_MP4_ENC &&
+	    pCodecInst->codecMode != W_AVC_ENC) {
+		return RETCODE_INVALID_HANDLE;
+	}
+	return RETCODE_SUCCESS;
+}
+
+RetCode CheckEncParam(EncHandle handle, EncParam *param)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+
+	if (param == 0) {
+		return RETCODE_INVALID_PARAM;
+	}
+	if (param->setROI.mode && (pCodecInst->codecMode == AVC_ENC ||
+				   pCodecInst->codecMode == W_AVC_ENC)) {
+		if (param->setROI.number < 0 ||
+		    param->setROI.number > MAX_ROI_NUMBER)
+			return RETCODE_INVALID_PARAM;
+	}
+	if (param->skipPicture != 0 && param->skipPicture != 1) {
+		return RETCODE_INVALID_PARAM;
+	}
+	if (param->skipPicture == 0) {
+		if (param->sourceFrame == 0) {
+			return RETCODE_INVALID_FRAME_BUFFER;
+		}
+		if (param->forceIPicture != 0 && param->forceIPicture != 1) {
+			return RETCODE_INVALID_PARAM;
+		}
+	}
+	if (pEncInfo->openParam.bitRate == 0) { // no rate control
+		if (pCodecInst->codecMode == MP4_ENC ||
+		    pCodecInst->codecMode == W_MP4_ENC) {
+			if (param->quantParam < 1 || param->quantParam > 31) {
+				return RETCODE_INVALID_PARAM;
+			}
+		} else if (pCodecInst->codecMode == HEVC_ENC) {
+			if (param->forcePicQpEnable == 1) {
+				if (param->forcePicQpI < 0 ||
+				    param->forcePicQpI > 51)
+					return RETCODE_INVALID_PARAM;
+
+				if (param->forcePicQpP < 0 ||
+				    param->forcePicQpP > 51)
+					return RETCODE_INVALID_PARAM;
+
+				if (param->forcePicQpB < 0 ||
+				    param->forcePicQpB > 51)
+					return RETCODE_INVALID_PARAM;
+			}
+			if (pEncInfo->ringBufferEnable == 0) {
+				if (param->picStreamBufferAddr % 16 ||
+				    param->picStreamBufferSize == 0)
+					return RETCODE_INVALID_PARAM;
+			}
+		} else { // AVC_ENC
+			if (param->quantParam < 0 || param->quantParam > 51) {
+				return RETCODE_INVALID_PARAM;
+			}
+		}
+	}
+	if (pEncInfo->ringBufferEnable == 0) {
+		if (param->picStreamBufferAddr % 8 ||
+		    param->picStreamBufferSize == 0) {
+			return RETCODE_INVALID_PARAM;
+		}
+	}
+
+	return RETCODE_SUCCESS;
+}
+RetCode SetCropInfo(EncHandle handle, EncOpenParam *newOP)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	EncOpenParam *encOP;
+
+	if (handle == NULL || newOP == NULL) {
+		return RETCODE_INVALID_PARAM;
+	}
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+	encOP = &(pEncInfo->openParam);
+
+	if (newOP->EncStdParam.avcParam.frameCroppingFlag == 1) {
+		pEncInfo->openParam.picHeight = newOP->picHeight;
+		encOP->EncStdParam.avcParam.frameCroppingFlag =
+			newOP->EncStdParam.avcParam.frameCroppingFlag;
+		encOP->EncStdParam.avcParam.frameCropLeft =
+			newOP->EncStdParam.avcParam.frameCropLeft;
+		encOP->EncStdParam.avcParam.frameCropRight =
+			newOP->EncStdParam.avcParam.frameCropRight;
+		encOP->EncStdParam.avcParam.frameCropTop =
+			newOP->EncStdParam.avcParam.frameCropTop;
+		encOP->EncStdParam.avcParam.frameCropBottom =
+			newOP->EncStdParam.avcParam.frameCropBottom;
+	}
+
+	return RETCODE_SUCCESS;
+}
+/**
+ * GetEncHeader()
+ *  1. Generate encoder header bitstream
+ * @param handle         : encoder handle
+ * @param encHeaderParam : encoder header parameter (buffer, size, type)
+ * @return none
+ */
+RetCode GetEncHeader(EncHandle handle, EncHeaderParam *encHeaderParam)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	EncOpenParam *encOP;
+	int encHeaderCode;
+	int ppsCopySize = 0;
+	unsigned char pps_temp[256];
+	int spsID = 0;
+	PhysicalAddress rdPtr;
+	PhysicalAddress wrPtr;
+	int flag = 0;
+	Uint32 val = 0;
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+	encOP = &(pEncInfo->openParam);
+
+	EnterLock(pCodecInst->coreIdx);
+
+	SetPendingInst(pCodecInst->coreIdx, pCodecInst);
+
+	if (pEncInfo->ringBufferEnable == 0) {
+		if (pEncInfo->lineBufIntEn)
+			val |= (0x1 << 6);
+		val |= (0x1 << 5);
+		val |= (0x1 << 4);
+
+	} else {
+		val |= (0x1 << 3);
+	}
+	val |= pEncInfo->openParam.streamEndian;
+	VpuWriteReg(pCodecInst->coreIdx, BIT_BIT_STREAM_CTRL, val);
+
+	if (pEncInfo->ringBufferEnable == 0) {
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_HEADER_BB_START,
+			    encHeaderParam->buf);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_HEADER_BB_SIZE,
+			    encHeaderParam->size / 1024);
+	}
+	if ((encHeaderParam->headerType == SPS_RBSP ||
+	     encHeaderParam->headerType == SPS_RBSP_MVC) &&
+	    pEncInfo->openParam.bitstreamFormat == STD_AVC) {
+		Uint32 CropV, CropH;
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_HEADER_PROFILE,
+			    encOP->EncStdParam.avcParam.profile);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_HEADER_CHROMA_FORMAT,
+			    encOP->EncStdParam.avcParam.chromaFormat400);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_HEADER_FIELD_FLAG,
+			    (encOP->EncStdParam.avcParam.fieldRefMode << 1) |
+				    encOP->EncStdParam.avcParam.fieldFlag);
+		if (encOP->EncStdParam.avcParam.frameCroppingFlag == 1) {
+			flag = 1;
+			CropH = encOP->EncStdParam.avcParam.frameCropLeft << 16;
+			CropH |= encOP->EncStdParam.avcParam.frameCropRight;
+			CropV = encOP->EncStdParam.avcParam.frameCropTop << 16;
+			CropV |= encOP->EncStdParam.avcParam.frameCropBottom;
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_FRAME_CROP_H, CropH);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_FRAME_CROP_V, CropV);
+		}
+	}
+	if (encHeaderParam->headerType == SPS_RBSP_MVC)
+		spsID = 1;
+	encHeaderCode =
+		encHeaderParam->headerType |
+		(flag
+		 << 2); //paraSetType>> SPS: 0, PPS: 1, VOS: 1, VO: 2, VOL: 0
+	encHeaderCode |= (pEncInfo->openParam.EncStdParam.avcParam.level) << 8;
+	encHeaderCode |= (spsID << 24);
+	if ((encHeaderParam->headerType == PPS_RBSP ||
+	     encHeaderParam->headerType == PPS_RBSP_MVC) &&
+	    pEncInfo->openParam.bitstreamFormat == STD_AVC) {
+		int ActivePPSIdx = pEncInfo->ActivePPSIdx;
+		AvcPpsParam *ActivePPS =
+			&encOP->EncStdParam.avcParam.ppsParam[ActivePPSIdx];
+		if (ActivePPS->entropyCodingMode != 2) {
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_CABAC_MODE,
+				    ActivePPS->entropyCodingMode);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_CABAC_INIT_IDC,
+				    ActivePPS->cabacInitIdc);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_TRANSFORM_8X8,
+				    ActivePPS->transform8x8Mode);
+			if (encHeaderParam->headerType == PPS_RBSP)
+				encHeaderCode |= (ActivePPS->ppsId << 16);
+			else if (encHeaderParam->headerType == PPS_RBSP_MVC)
+				encHeaderCode |= (1 << 24) |
+						 ((ActivePPS->ppsId + 1) << 16);
+		} else {
+			int mvcPPSOffset = 0;
+			if (encHeaderParam->headerType == PPS_RBSP_MVC) {
+				encHeaderCode |= (1 << 24); /* sps_id: 1 */
+				mvcPPSOffset = 2;
+			}
+			// PPS for I frame (CAVLC)
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_CABAC_MODE, 0);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_CABAC_INIT_IDC,
+				    ActivePPS->cabacInitIdc);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_TRANSFORM_8X8,
+				    ActivePPS->transform8x8Mode);
+			encHeaderCode |=
+				((ActivePPS->ppsId + mvcPPSOffset) << 16);
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_HEADER_CODE,
+				    encHeaderCode);
+
+			Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst,
+					     ENCODE_HEADER);
+			if (vdi_wait_vpu_busy(pCodecInst->coreIdx,
+					      __VPU_BUSY_TIMEOUT,
+					      BIT_BUSY_FLAG) == -1) {
+				if (pCodecInst->loggingEnable)
+					vdi_log(pCodecInst->coreIdx,
+						ENCODE_HEADER, 2);
+				SetPendingInst(pCodecInst->coreIdx, 0);
+				LeaveLock(pCodecInst->coreIdx);
+				return RETCODE_VPU_RESPONSE_TIMEOUT;
+			}
+			if (pCodecInst->loggingEnable)
+				vdi_log(pCodecInst->coreIdx, ENCODE_HEADER, 0);
+
+			if (pEncInfo->ringBufferEnable == 0) {
+				ppsCopySize =
+					VpuReadReg(
+						pCodecInst->coreIdx,
+						pEncInfo->streamWrPtrRegAddr) -
+					encHeaderParam->buf;
+				VpuReadMem(pCodecInst->coreIdx,
+					   encHeaderParam->buf, &pps_temp[0],
+					   ppsCopySize,
+					   pEncInfo->openParam.streamEndian);
+			}
+
+			// PPS for P frame (CABAC)
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_CABAC_MODE, 1);
+			encHeaderCode |= ((ActivePPS->ppsId + mvcPPSOffset + 1)
+					  << 16); // ppsId=1;
+		}
+	}
+	encHeaderCode |= (encHeaderParam->zeroPaddingEnable & 1) << 31;
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_HEADER_CODE, encHeaderCode);
+
+	VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamRdPtrRegAddr,
+		    pEncInfo->streamRdPtr);
+	VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamWrPtrRegAddr,
+		    pEncInfo->streamWrPtr);
+
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst, ENCODE_HEADER);
+	if (vdi_wait_vpu_busy(pCodecInst->coreIdx, __VPU_BUSY_TIMEOUT,
+			      BIT_BUSY_FLAG) == -1) {
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, ENCODE_HEADER, 2);
+		SetPendingInst(pCodecInst->coreIdx, 0);
+		LeaveLock(pCodecInst->coreIdx);
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, ENCODE_HEADER, 0);
+
+	if (pEncInfo->ringBufferEnable == 0) {
+		rdPtr = encHeaderParam->buf;
+		wrPtr = VpuReadReg(pCodecInst->coreIdx,
+				   pEncInfo->streamWrPtrRegAddr);
+
+		if (ppsCopySize) {
+			int size = wrPtr - rdPtr;
+			VpuReadMem(pCodecInst->coreIdx, rdPtr,
+				   &pps_temp[ppsCopySize], size,
+				   pEncInfo->openParam.streamEndian);
+			ppsCopySize += size;
+			VpuWriteMem(pCodecInst->coreIdx, rdPtr, &pps_temp[0],
+				    ppsCopySize,
+				    pEncInfo->openParam.streamEndian);
+			encHeaderParam->size = ppsCopySize;
+			wrPtr = rdPtr + ppsCopySize;
+			VpuWriteReg(pCodecInst->coreIdx,
+				    pEncInfo->streamWrPtrRegAddr, wrPtr);
+		} else {
+			encHeaderParam->size = wrPtr - rdPtr;
+		}
+	} else {
+		rdPtr = VpuReadReg(pCodecInst->coreIdx,
+				   pEncInfo->streamRdPtrRegAddr);
+		wrPtr = VpuReadReg(pCodecInst->coreIdx,
+				   pEncInfo->streamWrPtrRegAddr);
+		encHeaderParam->buf = rdPtr;
+		encHeaderParam->size = wrPtr - rdPtr;
+	}
+
+	pEncInfo->streamWrPtr = wrPtr;
+	pEncInfo->streamRdPtr = rdPtr;
+
+	SetPendingInst(pCodecInst->coreIdx, 0);
+	LeaveLock(pCodecInst->coreIdx);
+	return RETCODE_SUCCESS;
+}
+
+/**
+ * EncParaSet()
+ *  1. Setting encoder header option
+ *  2. Get RBSP format header in PARA_BUF
+ * @param handle      : encoder handle
+ * @param paraSetType : encoder header type >> SPS: 0, PPS: 1, VOS: 1, VO: 2, VOL: 0
+ * @return none
+ */
+RetCode EncParaSet(EncHandle handle, int paraSetType)
+{
+	CodecInst *pCodecInst;
+	EncInfo *pEncInfo;
+	int flag = 0;
+	int encHeaderCode = paraSetType;
+	EncOpenParam *encOP;
+
+	pCodecInst = handle;
+	pEncInfo = &pCodecInst->CodecInfo->encInfo;
+	encOP = &(pEncInfo->openParam);
+
+	EnterLock(pCodecInst->coreIdx);
+
+	if (paraSetType == 0 &&
+	    pEncInfo->openParam.bitstreamFormat == STD_AVC) {
+		Uint32 CropV, CropH;
+
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_HEADER_CHROMA_FORMAT,
+			    encOP->EncStdParam.avcParam.chromaFormat400);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_HEADER_FIELD_FLAG,
+			    encOP->EncStdParam.avcParam.fieldFlag |
+				    encOP->EncStdParam.avcParam.fieldFlag);
+		VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_HEADER_PROFILE,
+			    encOP->EncStdParam.avcParam.profile);
+		if (encOP->EncStdParam.avcParam.frameCroppingFlag == 1) {
+			flag = 1;
+			CropH = encOP->EncStdParam.avcParam.frameCropLeft << 16;
+			CropH |= encOP->EncStdParam.avcParam.frameCropRight;
+			CropV = encOP->EncStdParam.avcParam.frameCropTop << 16;
+			CropV |= encOP->EncStdParam.avcParam.frameCropBottom;
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_FRAME_CROP_H, CropH);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_FRAME_CROP_V, CropV);
+		}
+	}
+	encHeaderCode =
+		paraSetType |
+		(flag
+		 << 2); //paraSetType>> SPS: 0, PPS: 1, VOS: 1, VO: 2, VOL: 0
+
+	encHeaderCode |= (pEncInfo->openParam.EncStdParam.avcParam.level) << 8;
+	if (paraSetType == 1 &&
+	    pEncInfo->openParam.bitstreamFormat == STD_AVC) {
+		int ActivePPSIdx = pEncInfo->ActivePPSIdx;
+		AvcPpsParam *ActvePPS =
+			&encOP->EncStdParam.avcParam.ppsParam[ActivePPSIdx];
+
+		//PPS ID
+		if (ActvePPS->entropyCodingMode != 2) {
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_CABAC_MODE,
+				    ActvePPS->entropyCodingMode);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_CABAC_INIT_IDC,
+				    ActvePPS->cabacInitIdc);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_TRANSFORM_8X8,
+				    ActvePPS->transform8x8Mode);
+			encHeaderCode |= (ActvePPS->ppsId << 16);
+
+		} else // CAVLC for I frame, CABAC for P frame.
+		{
+			// 1st PPS
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_CABAC_MODE, 0);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_CABAC_INIT_IDC,
+				    ActvePPS->cabacInitIdc);
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_TRANSFORM_8X8,
+				    ActvePPS->transform8x8Mode);
+
+			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARA_SET_TYPE,
+				    encHeaderCode);
+			Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst,
+					     ENC_PARA_SET);
+			if (vdi_wait_vpu_busy(pCodecInst->coreIdx,
+					      __VPU_BUSY_TIMEOUT,
+					      BIT_BUSY_FLAG) == -1) {
+				if (pCodecInst->loggingEnable)
+					vdi_log(pCodecInst->coreIdx,
+						ENC_PARA_SET, 2);
+				LeaveLock(pCodecInst->coreIdx);
+				return RETCODE_VPU_RESPONSE_TIMEOUT;
+			}
+			if (pCodecInst->loggingEnable)
+				vdi_log(pCodecInst->coreIdx, ENC_PARA_SET, 0);
+			//2nd PPS
+			VpuWriteReg(pCodecInst->coreIdx,
+				    CMD_ENC_HEADER_CABAC_MODE, 1);
+			encHeaderCode |= (1 << 16);
+		}
+	}
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARA_SET_TYPE, encHeaderCode);
+
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst, ENC_PARA_SET);
+	if (vdi_wait_vpu_busy(pCodecInst->coreIdx, __VPU_BUSY_TIMEOUT,
+			      BIT_BUSY_FLAG) == -1) {
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, ENC_PARA_SET, 2);
+		LeaveLock(pCodecInst->coreIdx);
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, ENC_PARA_SET, 0);
+
+	LeaveLock(pCodecInst->coreIdx);
+	return RETCODE_SUCCESS;
+}
+
+RetCode SetGopNumber(EncHandle handle, Uint32 *pGopNumber)
+{
+	CodecInst *pCodecInst;
+	int data = 0;
+	Uint32 gopNumber = *pGopNumber;
+
+	pCodecInst = handle;
+
+	data = 1;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARAM_CHANGE_ENABLE, data);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARAM_CHANGE_GOP_NUM,
+		    gopNumber);
+
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst,
+			     RC_CHANGE_PARAMETER);
+	if (vdi_wait_vpu_busy(pCodecInst->coreIdx, __VPU_BUSY_TIMEOUT,
+			      BIT_BUSY_FLAG) == -1) {
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, RC_CHANGE_PARAMETER, 2);
+		LeaveLock(pCodecInst->coreIdx);
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, RC_CHANGE_PARAMETER, 0);
+
+	LeaveLock(pCodecInst->coreIdx);
+	return RETCODE_SUCCESS;
+}
+
+RetCode SetIntraQp(EncHandle handle, Uint32 *pIntraQp)
+{
+	CodecInst *pCodecInst;
+	int data = 0;
+	Uint32 intraQp = *pIntraQp;
+
+	pCodecInst = handle;
+
+	data = 1 << 1;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARAM_CHANGE_ENABLE, data);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARAM_CHANGE_INTRA_QP,
+		    intraQp);
+
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst,
+			     RC_CHANGE_PARAMETER);
+	if (vdi_wait_vpu_busy(pCodecInst->coreIdx, __VPU_BUSY_TIMEOUT,
+			      BIT_BUSY_FLAG) == -1) {
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, RC_CHANGE_PARAMETER, 2);
+		LeaveLock(pCodecInst->coreIdx);
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, RC_CHANGE_PARAMETER, 0);
+	LeaveLock(pCodecInst->coreIdx);
+	return RETCODE_SUCCESS;
+}
+
+RetCode SetBitrate(EncHandle handle, Uint32 *pBitrate)
+{
+	CodecInst *pCodecInst;
+	int data = 0;
+	Uint32 bitrate = *pBitrate;
+
+	pCodecInst = handle;
+
+	data = 1 << 2;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARAM_CHANGE_ENABLE, data);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARAM_CHANGE_BITRATE, bitrate);
+
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst,
+			     RC_CHANGE_PARAMETER);
+	if (vdi_wait_vpu_busy(pCodecInst->coreIdx, __VPU_BUSY_TIMEOUT,
+			      BIT_BUSY_FLAG) == -1) {
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, RC_CHANGE_PARAMETER, 2);
+		LeaveLock(pCodecInst->coreIdx);
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, RC_CHANGE_PARAMETER, 0);
+	LeaveLock(pCodecInst->coreIdx);
+	return RETCODE_SUCCESS;
+}
+
+RetCode SetFramerate(EncHandle handle, Uint32 *pFramerate)
+{
+	CodecInst *pCodecInst;
+	int data = 0;
+	Uint32 frameRate = *pFramerate;
+
+	pCodecInst = handle;
+
+	data = 1 << 3;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARAM_CHANGE_ENABLE, data);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARAM_CHANGE_F_RATE,
+		    frameRate);
+
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst,
+			     RC_CHANGE_PARAMETER);
+	if (vdi_wait_vpu_busy(pCodecInst->coreIdx, __VPU_BUSY_TIMEOUT,
+			      BIT_BUSY_FLAG) == -1) {
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, RC_CHANGE_PARAMETER, 2);
+		LeaveLock(pCodecInst->coreIdx);
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, RC_CHANGE_PARAMETER, 0);
+
+	LeaveLock(pCodecInst->coreIdx);
+	return RETCODE_SUCCESS;
+}
+
+RetCode SetIntraRefreshNum(EncHandle handle, Uint32 *pIntraRefreshNum)
+{
+	CodecInst *pCodecInst;
+	Uint32 intraRefreshNum = *pIntraRefreshNum;
+	int data = 0;
+
+	pCodecInst = handle;
+
+	data = 1 << 4;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARAM_CHANGE_ENABLE, data);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARAM_CHANGE_INTRA_REFRESH,
+		    intraRefreshNum);
+
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst,
+			     RC_CHANGE_PARAMETER);
+	if (vdi_wait_vpu_busy(pCodecInst->coreIdx, __VPU_BUSY_TIMEOUT,
+			      BIT_BUSY_FLAG) == -1) {
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, RC_CHANGE_PARAMETER, 2);
+		LeaveLock(pCodecInst->coreIdx);
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, RC_CHANGE_PARAMETER, 0);
+	LeaveLock(pCodecInst->coreIdx);
+	return RETCODE_SUCCESS;
+}
+
+RetCode SetSliceMode(EncHandle handle, EncSliceMode *pSliceMode)
+{
+	CodecInst *pCodecInst;
+	Uint32 data = 0;
+	int data2 = 0;
+
+	pCodecInst = handle;
+	EnterLock(pCodecInst->coreIdx);
+
+	data = 0;
+	if (pSliceMode->sliceMode != 0) {
+		data = (pSliceMode->sliceSize << 2) |
+		       (pSliceMode->sliceSizeMode + 1); // encoding mode
+	}
+	data2 = 1 << 5;
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARAM_CHANGE_ENABLE, data2);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARAM_CHANGE_SLICE_MODE, data);
+
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst,
+			     RC_CHANGE_PARAMETER);
+	if (vdi_wait_vpu_busy(pCodecInst->coreIdx, __VPU_BUSY_TIMEOUT,
+			      BIT_BUSY_FLAG) == -1) {
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, RC_CHANGE_PARAMETER, 2);
+		LeaveLock(pCodecInst->coreIdx);
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, RC_CHANGE_PARAMETER, 0);
+	LeaveLock(pCodecInst->coreIdx);
+
+	return RETCODE_SUCCESS;
+}
+
+RetCode SetHecMode(EncHandle handle, int mode)
+{
+	CodecInst *pCodecInst;
+	Uint32 HecMode = mode;
+	int data = 0;
+
+	pCodecInst = handle;
+
+	data = 1 << 6;
+
+	EnterLock(pCodecInst->coreIdx);
+
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARAM_CHANGE_ENABLE, data);
+	VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARAM_CHANGE_HEC_MODE,
+		    HecMode);
+
+	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst,
+			     RC_CHANGE_PARAMETER);
+	if (vdi_wait_vpu_busy(pCodecInst->coreIdx, __VPU_BUSY_TIMEOUT,
+			      BIT_BUSY_FLAG) == -1) {
+		if (pCodecInst->loggingEnable)
+			vdi_log(pCodecInst->coreIdx, RC_CHANGE_PARAMETER, 2);
+		LeaveLock(pCodecInst->coreIdx);
+		return RETCODE_VPU_RESPONSE_TIMEOUT;
+	}
+	if (pCodecInst->loggingEnable)
+		vdi_log(pCodecInst->coreIdx, RC_CHANGE_PARAMETER, 0);
+	LeaveLock(pCodecInst->coreIdx);
+	return RETCODE_SUCCESS;
+}
+
+void EncSetHostParaAddr(Uint32 coreIdx, PhysicalAddress baseAddr,
+			PhysicalAddress paraAddr)
+{
+	BYTE tempBuf[8] = {
+		0,
+	}; // 64bit bus & endian
+	Uint32 val;
+
+	val = paraAddr;
+	tempBuf[0] = 0;
+	tempBuf[1] = 0;
+	tempBuf[2] = 0;
+	tempBuf[3] = 0;
+	tempBuf[4] = (val >> 24) & 0xff;
+	tempBuf[5] = (val >> 16) & 0xff;
+	tempBuf[6] = (val >> 8) & 0xff;
+	tempBuf[7] = (val >> 0) & 0xff;
+	VpuWriteMem(coreIdx, baseAddr, (BYTE *)tempBuf, 8, VDI_BIG_ENDIAN);
+}
+
+RetCode EnterDispFlagLock(Uint32 coreIdx)
+{
+	if (vdi_disp_lock(coreIdx) != 0)
+		return RETCODE_FAILURE;
+	return RETCODE_SUCCESS;
+}
+
+RetCode LeaveDispFlagLock(Uint32 coreIdx)
+{
+	vdi_disp_unlock(coreIdx);
+	return RETCODE_SUCCESS;
+}
+
+RetCode EnterLock(Uint32 coreIdx)
+{
+	if (vdi_lock(coreIdx) != 0)
+		return RETCODE_FAILURE;
+	SetClockGate(coreIdx, 1);
+	return RETCODE_SUCCESS;
+}
+
+RetCode LeaveLock(Uint32 coreIdx)
+{
+	SetClockGate(coreIdx, 0);
+	vdi_unlock(coreIdx);
+	return RETCODE_SUCCESS;
+}
+
+RetCode SetClockGate(Uint32 coreIdx, Uint32 on)
+{
+	CodecInst *inst;
+	vpu_instance_pool_t *vip;
+
+	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(coreIdx);
+	if (!vip) {
+		VLOG(ERR, "SetClockGate: RETCODE_INSUFFICIENT_RESOURCE\n");
+		return RETCODE_INSUFFICIENT_RESOURCE;
+	}
+
+	inst = (CodecInst *)vip->pendingInst;
+
+	if (!on && (inst || !vdi_lock_check(coreIdx)))
+		return RETCODE_SUCCESS;
+
+	vdi_set_clock_gate(coreIdx, on);
+
+	return RETCODE_SUCCESS;
+}
+
+void SetPendingInst(Uint32 coreIdx, CodecInst *inst)
+{
+	vpu_instance_pool_t *vip;
+
+	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(coreIdx);
+	if (!vip)
+		return;
+
+	vip->pendingInst = inst;
+	if (inst)
+		vip->pendingInstIdxPlus1 = (inst->instIndex + 1);
+	else
+		vip->pendingInstIdxPlus1 = 0;
+}
+
+void ClearPendingInst(Uint32 coreIdx)
+{
+	vpu_instance_pool_t *vip;
+
+	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(coreIdx);
+	if (!vip)
+		return;
+
+	if (vip->pendingInst) {
+		vip->pendingInst = 0;
+		vip->pendingInstIdxPlus1 = 0;
+	}
+}
+
+CodecInst *GetPendingInst(Uint32 coreIdx)
+{
+	vpu_instance_pool_t *vip;
+	int pendingInstIdx;
+
+	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(coreIdx);
+	if (!vip)
+		return NULL;
+
+	if (!vip->pendingInst)
+		return NULL;
+
+	pendingInstIdx = vip->pendingInstIdxPlus1 - 1;
+	if (pendingInstIdx < 0)
+		return NULL;
+	if (pendingInstIdx > MAX_NUM_INSTANCE)
+		return NULL;
+
+	return (CodecInst *)vip->codecInstPool[pendingInstIdx];
+}
+
+int GetPendingInstIdx(Uint32 coreIdx)
+{
+	vpu_instance_pool_t *vip;
+
+	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(coreIdx);
+	if (!vip)
+		return -1;
+
+	return (vip->pendingInstIdxPlus1 - 1);
+}
+
+Int32 MaverickCache2Config(MaverickCacheConfig *pCache, BOOL decoder,
+			   BOOL interleave, Uint32 bypass, Uint32 burst,
+			   Uint32 merge, TiledMapType mapType, Uint32 wayshape)
+{
+	unsigned int cacheConfig = 0;
+
+	if (decoder == TRUE) {
+		if (mapType == 0) { // LINEAR_FRAME_MAP
+			//VC1 opposite field padding is not allowable in UV separated, burst 8 and linear map
+			if (!interleave)
+				burst = 0;
+
+			wayshape = 15;
+
+			if (merge == 1)
+				merge = 3;
+
+			//GDI constraint. Width should not be over 64
+			if ((merge == 1) && (burst))
+				burst = 0;
+		} else {
+			//horizontal merge constraint in tiled map
+			if (merge == 1)
+				merge = 3;
+		}
+	} else { // encoder
+		if (mapType == LINEAR_FRAME_MAP) {
+			wayshape = 15;
+			//GDI constraint. Width should not be over 64
+			if ((merge == 1) && (burst))
+				burst = 0;
+		} else {
+			//horizontal merge constraint in tiled map
+			if (merge == 1)
+				merge = 3;
+		}
+	}
+
+	cacheConfig = (merge & 0x3) << 9;
+	cacheConfig = cacheConfig | ((wayshape & 0xf) << 5);
+	cacheConfig = cacheConfig | ((burst & 0x1) << 3);
+	cacheConfig = cacheConfig | (bypass & 0x3);
+
+	if (mapType != 0) //LINEAR_FRAME_MAP
+		cacheConfig = cacheConfig | 0x00000004;
+
+	///{16'b0, 5'b0, merge[1:0], wayshape[3:0], 1'b0, burst[0], map[0], bypass[1:0]};
+	pCache->type2.CacheMode = cacheConfig;
+
+	return 1;
+}
+
+int GetLowDelayOutput(CodecInst *pCodecInst, DecOutputInfo *info)
+{
+	Uint32 val = 0;
+	Uint32 val2 = 0;
+	Int32 endIndex;
+	VpuRect rectInfo;
+	DecInfo *pDecInfo;
+
+	pDecInfo = &pCodecInst->CodecInfo->decInfo;
+
+	info->indexFrameDisplay =
+		VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_DISPLAY_IDX);
+	info->indexFrameDecoded =
+		VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_DECODED_IDX);
+
+	val = VpuReadReg(pCodecInst->coreIdx,
+			 RET_DEC_PIC_SIZE); // decoding picture size
+	info->decPicWidth = (val >> 16) & 0xFFFF;
+	info->decPicHeight = (val)&0xFFFF;
+
+	if (info->indexFrameDecoded >= 0 &&
+	    info->indexFrameDecoded < MAX_GDI_IDX) {
+		//default value
+		rectInfo.left = 0;
+		rectInfo.right = info->decPicWidth;
+		rectInfo.top = 0;
+		rectInfo.bottom = info->decPicHeight;
+
+		if (pCodecInst->codecMode == AVC_DEC ||
+		    pCodecInst->codecMode == MP2_DEC ||
+		    pCodecInst->codecMode == W_AVC_DEC ||
+		    pCodecInst->codecMode == W_MP2_DEC) {
+			val = VpuReadReg(
+				pCodecInst->coreIdx,
+				RET_DEC_PIC_CROP_LEFT_RIGHT); // frame crop information(left, right)
+			val2 = VpuReadReg(
+				pCodecInst->coreIdx,
+				RET_DEC_PIC_CROP_TOP_BOTTOM); // frame crop information(top, bottom)
+
+			if (val == (Uint32)-1 || val == 0) {
+				rectInfo.left = 0;
+				rectInfo.right = info->decPicWidth;
+			} else {
+				rectInfo.left = ((val >> 16) & 0xFFFF);
+				rectInfo.right =
+					info->decPicWidth - (val & 0xFFFF);
+			}
+			if (val2 == (Uint32)-1 || val2 == 0) {
+				rectInfo.top = 0;
+				rectInfo.bottom = info->decPicHeight;
+			} else {
+				rectInfo.top = ((val2 >> 16) & 0xFFFF);
+				rectInfo.bottom =
+					info->decPicHeight - (val2 & 0xFFFF);
+			}
+		}
+
+		info->rcDecoded.left =
+			pDecInfo->decOutInfo[info->indexFrameDecoded]
+				.rcDecoded.left = rectInfo.left;
+		info->rcDecoded.right =
+			pDecInfo->decOutInfo[info->indexFrameDecoded]
+				.rcDecoded.right = rectInfo.right;
+		info->rcDecoded.top =
+			pDecInfo->decOutInfo[info->indexFrameDecoded]
+				.rcDecoded.top = rectInfo.top;
+		info->rcDecoded.bottom =
+			pDecInfo->decOutInfo[info->indexFrameDecoded]
+				.rcDecoded.bottom = rectInfo.bottom;
+	} else {
+		info->rcDecoded.left = 0;
+		info->rcDecoded.right = info->decPicWidth;
+		info->rcDecoded.top = 0;
+		info->rcDecoded.bottom = info->decPicHeight;
+	}
+
+	if (info->indexFrameDisplay >= 0 &&
+	    info->indexFrameDisplay < MAX_GDI_IDX) {
+		if (pCodecInst->codecMode == VC1_DEC ||
+		    pCodecInst->codecMode ==
+			    W_VC1_DEC) // vc1 rotates decoded frame buffer region. the other std rotated whole frame buffer region.
+		{
+			if (pDecInfo->rotationEnable &&
+			    (pDecInfo->rotationAngle == 90 ||
+			     pDecInfo->rotationAngle == 270)) {
+				info->rcDisplay.left =
+					pDecInfo->decOutInfo
+						[info->indexFrameDisplay]
+							.rcDecoded.top;
+				info->rcDisplay.right =
+					pDecInfo->decOutInfo
+						[info->indexFrameDisplay]
+							.rcDecoded.bottom;
+				info->rcDisplay.top =
+					pDecInfo->decOutInfo
+						[info->indexFrameDisplay]
+							.rcDecoded.left;
+				info->rcDisplay.bottom =
+					pDecInfo->decOutInfo
+						[info->indexFrameDisplay]
+							.rcDecoded.right;
+			} else {
+				info->rcDisplay.left =
+					pDecInfo->decOutInfo
+						[info->indexFrameDisplay]
+							.rcDecoded.left;
+				info->rcDisplay.right =
+					pDecInfo->decOutInfo
+						[info->indexFrameDisplay]
+							.rcDecoded.right;
+				info->rcDisplay.top =
+					pDecInfo->decOutInfo
+						[info->indexFrameDisplay]
+							.rcDecoded.top;
+				info->rcDisplay.bottom =
+					pDecInfo->decOutInfo
+						[info->indexFrameDisplay]
+							.rcDecoded.bottom;
+			}
+		} else {
+			if (pDecInfo->rotationEnable) {
+				switch (pDecInfo->rotationAngle) {
+				case 90:
+				case 270:
+					info->rcDisplay.left =
+						pDecInfo->decOutInfo
+							[info->indexFrameDisplay]
+								.rcDecoded.top;
+					info->rcDisplay.right =
+						pDecInfo->decOutInfo
+							[info->indexFrameDisplay]
+								.rcDecoded
+								.bottom;
+					info->rcDisplay.top =
+						pDecInfo->rotatorOutput.height -
+						pDecInfo->decOutInfo
+							[info->indexFrameDisplay]
+								.rcDecoded.right;
+					info->rcDisplay.bottom =
+						pDecInfo->rotatorOutput.height -
+						pDecInfo->decOutInfo
+							[info->indexFrameDisplay]
+								.rcDecoded.left;
+					break;
+				default:
+					info->rcDisplay.left =
+						pDecInfo->decOutInfo
+							[info->indexFrameDisplay]
+								.rcDecoded.left;
+					info->rcDisplay.right =
+						pDecInfo->decOutInfo
+							[info->indexFrameDisplay]
+								.rcDecoded.right;
+					info->rcDisplay.top =
+						pDecInfo->decOutInfo
+							[info->indexFrameDisplay]
+								.rcDecoded.top;
+					info->rcDisplay.bottom =
+						pDecInfo->decOutInfo
+							[info->indexFrameDisplay]
+								.rcDecoded
+								.bottom;
+					break;
+				}
+
+				if (pDecInfo->mirrorEnable) {
+					Uint32 temp;
+					if (pDecInfo->mirrorDirection &
+					    MIRDIR_VER) {
+						temp = info->rcDisplay.top;
+						info->rcDisplay.top =
+							info->decPicHeight -
+							info->rcDisplay.bottom;
+						info->rcDisplay.bottom =
+							info->decPicHeight -
+							temp;
+					}
+					if (pDecInfo->mirrorDirection &
+					    MIRDIR_HOR) {
+						temp = info->rcDisplay.left;
+						info->rcDisplay.left =
+							info->decPicWidth -
+							info->rcDisplay.right;
+						info->rcDisplay.right =
+							info->decPicWidth -
+							temp;
+					}
+				}
+			} else {
+				info->rcDisplay.left =
+					pDecInfo->decOutInfo
+						[info->indexFrameDisplay]
+							.rcDecoded.left;
+				info->rcDisplay.right =
+					pDecInfo->decOutInfo
+						[info->indexFrameDisplay]
+							.rcDecoded.right;
+				info->rcDisplay.top =
+					pDecInfo->decOutInfo
+						[info->indexFrameDisplay]
+							.rcDecoded.top;
+				info->rcDisplay.bottom =
+					pDecInfo->decOutInfo
+						[info->indexFrameDisplay]
+							.rcDecoded.bottom;
+			}
+		}
+
+		if (info->indexFrameDisplay == info->indexFrameDecoded) {
+			info->dispPicWidth = info->decPicWidth;
+			info->dispPicHeight = info->decPicHeight;
+		} else {
+			info->dispPicWidth =
+				pDecInfo->decOutInfo[info->indexFrameDisplay]
+					.decPicWidth;
+			info->dispPicHeight =
+				pDecInfo->decOutInfo[info->indexFrameDisplay]
+					.decPicHeight;
+		}
+	} else {
+		info->rcDisplay.left = 0;
+		info->rcDisplay.right = 0;
+		info->rcDisplay.top = 0;
+		info->rcDisplay.bottom = 0;
+
+		info->dispPicWidth = 0;
+		info->dispPicHeight = 0;
+	}
+
+	val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_TYPE);
+	info->interlacedFrame = (val >> 18) & 0x1;
+	info->topFieldFirst = (val >> 21) & 0x0001; // TopFieldFirst[21]
+	if (info->interlacedFrame) {
+		info->picTypeFirst = (val & 0x38) >> 3; // pic_type of 1st field
+		info->picType = val & 7; // pic_type of 2nd field
+
+	} else {
+		info->picTypeFirst = PIC_TYPE_MAX; // no meaning
+		info->picType = val & 7;
+	}
+
+	info->pictureStructure =
+		(val >> 19) & 0x0003; // MbAffFlag[17], FieldPicFlag[16]
+	info->repeatFirstField = (val >> 22) & 0x0001;
+	info->progressiveFrame = (val >> 23) & 0x0003;
+
+	if (pCodecInst->codecMode == AVC_DEC ||
+	    pCodecInst->codecMode == W_AVC_DEC) {
+		info->nalRefIdc = (val >> 7) & 0x03;
+		info->decFrameInfo = (val >> 15) & 0x0001;
+		info->picStrPresent = (val >> 27) & 0x0001;
+		info->picTimingStruct = (val >> 28) & 0x000f;
+		//update picture type when IDR frame
+		if (val & 0x40) { // 6th bit
+			if (info->interlacedFrame)
+				info->picTypeFirst = PIC_TYPE_IDR;
+			else
+				info->picType = PIC_TYPE_IDR;
+		}
+		info->decFrameInfo = (val >> 16) & 0x0003;
+		if (info->indexFrameDisplay >= 0) {
+			if (info->indexFrameDisplay == info->indexFrameDecoded)
+				info->avcNpfFieldInfo = info->decFrameInfo;
+			else if (info->indexFrameDisplay < MAX_GDI_IDX) {
+				info->avcNpfFieldInfo =
+					pDecInfo->decOutInfo
+						[info->indexFrameDisplay]
+							.decFrameInfo;
+			}
+		}
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_HRD_INFO);
+		info->avcHrdInfo.cpbMinus1 = val >> 2;
+		info->avcHrdInfo.vclHrdParamFlag = (val >> 1) & 1;
+		info->avcHrdInfo.nalHrdParamFlag = val & 1;
+
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_VUI_INFO);
+		info->avcVuiInfo.fixedFrameRateFlag = val & 1;
+		info->avcVuiInfo.timingInfoPresent = (val >> 1) & 0x01;
+		info->avcVuiInfo.chromaLocBotField = (val >> 2) & 0x07;
+		info->avcVuiInfo.chromaLocTopField = (val >> 5) & 0x07;
+		info->avcVuiInfo.chromaLocInfoPresent = (val >> 8) & 0x01;
+		info->avcVuiInfo.colorPrimaries = (val >> 16) & 0xff;
+		info->avcVuiInfo.colorDescPresent = (val >> 24) & 0x01;
+		info->avcVuiInfo.isExtSAR = (val >> 25) & 0x01;
+		info->avcVuiInfo.vidFullRange = (val >> 26) & 0x01;
+		info->avcVuiInfo.vidFormat = (val >> 27) & 0x07;
+		info->avcVuiInfo.vidSigTypePresent = (val >> 30) & 0x01;
+		info->avcVuiInfo.vuiParamPresent = (val >> 31) & 0x01;
+		val = VpuReadReg(pCodecInst->coreIdx,
+				 RET_DEC_PIC_VUI_PIC_STRUCT);
+		info->avcVuiInfo.vuiPicStructPresent = (val & 0x1);
+		info->avcVuiInfo.vuiPicStruct = (val >> 1);
+	}
+
+	info->fRateNumerator = VpuReadReg(
+		pCodecInst->coreIdx,
+		RET_DEC_PIC_FRATE_NR); //Frame rate, Aspect ratio can be changed frame by frame.
+	info->fRateDenominator =
+		VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_FRATE_DR);
+	if ((pCodecInst->codecMode == AVC_DEC ||
+	     pCodecInst->codecMode == W_AVC_DEC) &&
+	    info->fRateDenominator > 0)
+		info->fRateDenominator *= 2;
+
+	info->aspectRateInfo =
+		VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_ASPECT);
+
+	// User Data
+	if (pDecInfo->userDataEnable) {
+		int userDataNum;
+		int userDataSize;
+		BYTE tempBuf[8] = {
+			0,
+		};
+
+		VpuReadMem(pCodecInst->coreIdx, pDecInfo->userDataBufAddr + 0,
+			   tempBuf, 8, VPU_USER_DATA_ENDIAN);
+
+		val = ((tempBuf[0] << 24) & 0xFF000000) |
+		      ((tempBuf[1] << 16) & 0x00FF0000) |
+		      ((tempBuf[2] << 8) & 0x0000FF00) |
+		      ((tempBuf[3] << 0) & 0x000000FF);
+
+		userDataNum = (val >> 16) & 0xFFFF;
+		userDataSize = (val >> 0) & 0xFFFF;
+		if (userDataNum == 0)
+			userDataSize = 0;
+
+		info->decOutputExtData.userDataNum = userDataNum;
+		info->decOutputExtData.userDataSize = userDataSize;
+
+		val = ((tempBuf[4] << 24) & 0xFF000000) |
+		      ((tempBuf[5] << 16) & 0x00FF0000) |
+		      ((tempBuf[6] << 8) & 0x0000FF00) |
+		      ((tempBuf[7] << 0) & 0x000000FF);
+
+		if (userDataNum == 0)
+			info->decOutputExtData.userDataBufFull = 0;
+		else
+			info->decOutputExtData.userDataBufFull =
+				(val >> 16) & 0xFFFF;
+
+		info->decOutputExtData.activeFormat =
+			VpuReadReg(pCodecInst->coreIdx,
+				   RET_DEC_PIC_ATSC_USER_DATA_INFO) &
+			0xf;
+	}
+
+	info->numOfErrMBs = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_ERR_MB);
+
+	val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_SUCCESS);
+	info->decodingSuccess = val;
+	info->sequenceChanged = ((val >> 20) & 0x1);
+	info->streamEndFlag = ((pDecInfo->streamEndflag >> 2) & 0x01);
+
+	endIndex = (pDecInfo->openParam.wtlEnable == TRUE) ?
+			   pDecInfo->numFbsForWTL :
+			   pDecInfo->numFbsForDecoding;
+	if (0 <= info->indexFrameDisplay &&
+	    info->indexFrameDisplay < endIndex) {
+		info->dispFrame =
+			pDecInfo->frameBufPool[info->indexFrameDisplay];
+		if (pDecInfo->openParam.wtlEnable) { // coda980 only
+			info->dispFrame = pDecInfo->frameBufPool
+						  [info->indexFrameDisplay +
+						   pDecInfo->numFbsForDecoding];
+		}
+	}
+
+	if (pDecInfo->deringEnable || pDecInfo->mirrorEnable ||
+	    pDecInfo->rotationEnable || pDecInfo->tiled2LinearEnable) {
+		info->dispFrame = pDecInfo->rotatorOutput;
+	}
+
+	if ((pCodecInst->codecMode == AVC_DEC ||
+	     pCodecInst->codecMode == W_AVC_DEC) &&
+	    pCodecInst->codecModeAux == AVC_AUX_MVC) {
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_MVC_REPORT);
+		info->mvcPicInfo.viewIdxDisplay = (val >> 0) & 1;
+		info->mvcPicInfo.viewIdxDecoded = (val >> 1) & 1;
+	}
+
+	if (pCodecInst->codecMode == AVC_DEC ||
+	    pCodecInst->codecMode == W_AVC_DEC) {
+		val = VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_AVC_FPA_SEI0);
+
+		if (val == (Uint32)-1) {
+			info->avcFpaSei.exist = 0;
+		} else {
+			info->avcFpaSei.exist = 1;
+			info->avcFpaSei.framePackingArrangementId = val;
+
+			val = VpuReadReg(pCodecInst->coreIdx,
+					 RET_DEC_PIC_AVC_FPA_SEI1);
+			info->avcFpaSei.contentInterpretationType =
+				val & 0x3F; // [5:0]
+			info->avcFpaSei.framePackingArrangementType =
+				(val >> 6) & 0x7F; // [12:6]
+			info->avcFpaSei.framePackingArrangementExtensionFlag =
+				(val >> 13) & 0x01; // [13]
+			info->avcFpaSei.frame1SelfContainedFlag =
+				(val >> 14) & 0x01; // [14]
+			info->avcFpaSei.frame0SelfContainedFlag =
+				(val >> 15) & 0x01; // [15]
+			info->avcFpaSei.currentFrameIsFrame0Flag =
+				(val >> 16) & 0x01; // [16]
+			info->avcFpaSei.fieldViewsFlag =
+				(val >> 17) & 0x01; // [17]
+			info->avcFpaSei.frame0FlippedFlag =
+				(val >> 18) & 0x01; // [18]
+			info->avcFpaSei.spatialFlippingFlag =
+				(val >> 19) & 0x01; // [19]
+			info->avcFpaSei.quincunxSamplingFlag =
+				(val >> 20) & 0x01; // [20]
+			info->avcFpaSei.framePackingArrangementCancelFlag =
+				(val >> 21) & 0x01; // [21]
+
+			val = VpuReadReg(pCodecInst->coreIdx,
+					 RET_DEC_PIC_AVC_FPA_SEI2);
+			info->avcFpaSei.framePackingArrangementRepetitionPeriod =
+				val & 0x7FFF; // [14:0]
+			info->avcFpaSei.frame1GridPositionY =
+				(val >> 16) & 0x0F; // [19:16]
+			info->avcFpaSei.frame1GridPositionX =
+				(val >> 20) & 0x0F; // [23:20]
+			info->avcFpaSei.frame0GridPositionY =
+				(val >> 24) & 0x0F; // [27:24]
+			info->avcFpaSei.frame0GridPositionX =
+				(val >> 28) & 0x0F; // [31:28]
+		}
+
+		info->avcPocTop =
+			VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_POC_TOP);
+		info->avcPocBot =
+			VpuReadReg(pCodecInst->coreIdx, RET_DEC_PIC_POC_BOT);
+
+		if (info->interlacedFrame) {
+			if (info->avcPocTop > info->avcPocBot) {
+				info->avcPocPic = info->avcPocBot;
+			} else {
+				info->avcPocPic = info->avcPocTop;
+			}
+		} else
+			info->avcPocPic = VpuReadReg(pCodecInst->coreIdx,
+						     RET_DEC_PIC_POC);
+	}
+
+	//pDecInfo->streamRdPtr //NA
+	pDecInfo->frameDisplayFlag = VpuReadReg(
+		pCodecInst->coreIdx, pDecInfo->frameDisplayFlagRegAddr);
+	//info->consumedByte //NA
+	//info->notSufficientSliceBuffer; // NA
+	//info->notSufficientPsBuffer;  // NA
+	//info->bytePosFrameStart //NA
+	//info->bytePosFrameEnd   //NA
+	//info->rdPtr //NA
+	//info->wrPtr //NA
+
+	//info->frameCycle  //NA
+	//Vp8ScaleInfo vp8ScaleInfo; //NA
+	//Vp8PicInfo vp8PicInfo; //NA
+	//MvcPicInfo mvcPicInfo; ////NA
+	//info->wprotErrReason; avcVuiInfo
+	//PhysicalAddress wprotErrAddress; avcVuiInfo
+
+	// Report Information
+	//info->frameDct; //NA
+	//info->progressiveSequence; //NA
+	//info->mp4TimeIncrement; //NA
+	//info->mp4ModuloTimeBase; //NA
+
+	return 1;
+}
+
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+int SetDecWriteProtectRegions(CodecInst *inst)
+{
+	Uint32 i;
+	WriteMemProtectCfg *pCfg;
+	Uint32 regionEnable = 0;
+	Uint32 wprotStart;
+	Uint32 wprotEnd;
+	Uint32 wprotEnable;
+	Uint32 regions;
+	DecInfo *pDecInfo = &inst->CodecInfo->decInfo;
+
+	wprotEnable = GDI_WPROT_RGN_EN;
+	wprotStart = GDI_WPROT_RGN0_STA;
+	wprotEnd = GDI_WPROT_RGN0_END;
+	regions = GDI_WPROT_REGIONS;
+
+	pCfg = &pDecInfo->writeMemProtectCfg;
+
+	for (i = 0; i < pCfg->numOfRegion; i++) {
+		WriteMemProtectRegion *p = &pCfg->decRegion[i];
+		int enable = p->enable != 0;
+		int isSecondary = p->isSecondary != 0;
+
+		VLOG(INFO,
+		     "[%d]%s.region:%d.enable:%d.isSecondary:%d.VpuWriteReg wprotStart:0x%08x wprotEnd:0x%08x.start:0x%08x end:0x%08x\n",
+		     __LINE__, __func__, i, enable, isSecondary, wprotStart,
+		     wprotEnd, p->startAddress, p->endAddress);
+		regionEnable |= (enable << i);
+		regionEnable |= (isSecondary << (i + regions));
+		VpuWriteReg(inst->coreIdx, wprotStart,
+			    p->startAddress >> 12); // round down
+		VpuWriteReg(inst->coreIdx, wprotEnd,
+			    (p->endAddress + 0xFFF) >> 12); // round up
+		wprotStart += 8;
+		wprotEnd += 8;
+	}
+	VLOG(INFO,
+	     "[%d]%s.VpuWriteReg wprotEnable:0x%08x regionEnable:0x%08x\n",
+	     __LINE__, __func__, wprotEnable, regionEnable);
+	VpuWriteReg(inst->coreIdx, wprotEnable, regionEnable);
+
+	return 1;
+}
+#endif // #ifdef ENABLE_CODA9_WRITE_PROTECT
+
+RetCode AllocateLinearFrameBuffer(TiledMapType mapType, FrameBuffer *fbArr,
+				  Uint32 numOfFrameBuffers, Uint32 sizeLuma,
+				  Uint32 sizeChroma)
+{
+	Uint32 i;
+	BOOL yuv422Interleave = FALSE;
+	BOOL fieldFrame = (BOOL)(mapType == LINEAR_FIELD_MAP);
+	BOOL cbcrInterleave = (BOOL)(mapType == COMPRESSED_FRAME_MAP ||
+				     fbArr[0].cbcrInterleave == TRUE);
+	BOOL reuseFb = FALSE;
+
+	if (mapType != COMPRESSED_FRAME_MAP &&
+	    mapType !=
+		    ARM_COMPRESSED_FRAME_MAP) { // [r] what is ARM_COMPRESSED_FRAME_MAP
+		switch (fbArr[0].format) {
+		case FORMAT_YUYV:
+		case FORMAT_YUYV_P10_16BIT_MSB:
+		case FORMAT_YUYV_P10_16BIT_LSB:
+		case FORMAT_YUYV_P10_32BIT_MSB:
+		case FORMAT_YUYV_P10_32BIT_LSB:
+		case FORMAT_YVYU:
+		case FORMAT_YVYU_P10_16BIT_MSB:
+		case FORMAT_YVYU_P10_16BIT_LSB:
+		case FORMAT_YVYU_P10_32BIT_MSB:
+		case FORMAT_YVYU_P10_32BIT_LSB:
+		case FORMAT_UYVY:
+		case FORMAT_UYVY_P10_16BIT_MSB:
+		case FORMAT_UYVY_P10_16BIT_LSB:
+		case FORMAT_UYVY_P10_32BIT_MSB:
+		case FORMAT_UYVY_P10_32BIT_LSB:
+		case FORMAT_VYUY:
+		case FORMAT_VYUY_P10_16BIT_MSB:
+		case FORMAT_VYUY_P10_16BIT_LSB:
+		case FORMAT_VYUY_P10_32BIT_MSB:
+		case FORMAT_VYUY_P10_32BIT_LSB:
+			yuv422Interleave = TRUE;
+			break;
+		default:
+			yuv422Interleave = FALSE;
+			break;
+		}
+	}
+
+	for (i = 0; i < numOfFrameBuffers; i++) {
+		reuseFb = (fbArr[i].bufY != (Uint32)-1 &&
+			   fbArr[i].bufCb != (Uint32)-1 &&
+			   fbArr[i].bufCr != (Uint32)-1);
+		if (reuseFb == FALSE) {
+			if (yuv422Interleave == TRUE) {
+				fbArr[i].bufCb = (PhysicalAddress)-1;
+				fbArr[i].bufCr = (PhysicalAddress)-1;
+			} else {
+				if (fbArr[i].bufCb == (PhysicalAddress)-1) {
+					fbArr[i].bufCb =
+						fbArr[i].bufY +
+						(sizeLuma >> fieldFrame);
+				}
+				if (fbArr[i].bufCr == (PhysicalAddress)-1) {
+					if (cbcrInterleave == TRUE) {
+						fbArr[i].bufCr =
+							(PhysicalAddress)-1;
+					} else {
+						fbArr[i].bufCr =
+							fbArr[i].bufCb +
+							(sizeChroma >>
+							 fieldFrame);
+					}
+				}
+			}
+		}
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+/* \brief   Allocate tiled framebuffer on GDI version 1.0 H/W.
+ */
+RetCode AllocateTiledFrameBufferGdiV1(TiledMapType mapType,
+				      PhysicalAddress tiledBaseAddr,
+				      FrameBuffer *fbArr,
+				      Uint32 numOfFrameBuffers, Uint32 sizeLuma,
+				      Uint32 sizeChroma, DRAMConfig *pDramCfg)
+{
+	Uint32 rasLowBitsForHor;
+	Uint32 i;
+	Uint32 cas, ras, bank, bus;
+	Uint32 lumRasTop, lumRasBot, chrRasTop, chrRasBot;
+	Uint32 lumFrameRasSize, lumFieldRasSize, chrFieldRasSize;
+	PhysicalAddress addrY, addrYRas;
+
+	if (mapType == TILED_FRAME_MB_RASTER_MAP ||
+	    mapType == TILED_FIELD_MB_RASTER_MAP) {
+		for (i = 0; i < numOfFrameBuffers; i++) {
+			int lum_top_base;
+			int lum_bot_base;
+			int chr_top_base;
+			int chr_bot_base;
+
+			addrY = ((fbArr[i].bufY + (16384 - 1)) & ~(16384 - 1));
+
+			lum_top_base = addrY;
+			lum_bot_base = addrY + sizeLuma / 2;
+			chr_top_base = addrY + sizeLuma;
+			chr_bot_base = addrY + sizeLuma +
+				       sizeChroma; // cbcr is interleaved
+
+			lum_top_base = (lum_top_base >> 12) & 0xfffff;
+			lum_bot_base = (lum_bot_base >> 12) & 0xfffff;
+			chr_top_base = (chr_top_base >> 12) & 0xfffff;
+			chr_bot_base = (chr_bot_base >> 12) & 0xfffff;
+
+			fbArr[i].bufY =
+				(lum_top_base << 12) | (chr_top_base >> 8);
+			fbArr[i].bufCb = ((chr_top_base & 0xff) << 24) |
+					 (lum_bot_base << 4) |
+					 (chr_bot_base >> 16);
+			fbArr[i].bufCr = ((chr_bot_base & 0xffff) << 16);
+			fbArr[i].bufYBot = (PhysicalAddress)-1;
+			fbArr[i].bufCbBot = (PhysicalAddress)-1;
+			fbArr[i].bufCrBot = (PhysicalAddress)-1;
+		}
+	} else {
+		cas = pDramCfg->casBit;
+		ras = pDramCfg->rasBit;
+		bank = pDramCfg->bankBit;
+		bus = pDramCfg->busBit;
+		if (cas == 9 && bank == 2 && ras == 13) {
+			rasLowBitsForHor = 3;
+		} else if (cas == 10 && bank == 3 && ras == 13) {
+			rasLowBitsForHor = 2;
+		} else {
+			return RETCODE_INVALID_PARAM;
+		}
+
+		for (i = 0; i < numOfFrameBuffers; i++) {
+			addrY = fbArr[i].bufY - tiledBaseAddr;
+			// align base_addr to RAS boundary
+			addrYRas = (addrY + ((1 << (bank + cas + bus)) - 1)) >>
+				   (bank + cas + bus);
+			// round up RAS lower 3(or 4) bits
+			addrYRas =
+				((addrYRas + ((1 << (rasLowBitsForHor)) - 1)) >>
+				 rasLowBitsForHor)
+				<< rasLowBitsForHor;
+
+			chrFieldRasSize = sizeChroma >>
+					  (pDramCfg->bankBit +
+					   pDramCfg->casBit + pDramCfg->busBit);
+			lumFieldRasSize = (sizeLuma >> 1) >>
+					  (pDramCfg->bankBit +
+					   pDramCfg->casBit + pDramCfg->busBit);
+			lumFrameRasSize = lumFieldRasSize * 2;
+			lumRasTop = addrYRas;
+			lumRasBot = lumRasTop + lumFieldRasSize;
+			chrRasTop = lumRasTop + lumFrameRasSize;
+			chrRasBot = chrRasTop + chrFieldRasSize;
+
+			fbArr[i].bufY = (lumRasBot << 16) + lumRasTop;
+			fbArr[i].bufCb = (chrRasBot << 16) + chrRasTop;
+			if (rasLowBitsForHor == 4) {
+				fbArr[i].bufCr =
+					((((chrRasBot >> 4) << 4) + 8) << 16) +
+					(((chrRasTop >> 4) << 4) + 8);
+			} else if (rasLowBitsForHor == 3) {
+				fbArr[i].bufCr =
+					((((chrRasBot >> 3) << 3) + 4) << 16) +
+					(((chrRasTop >> 3) << 3) + 4);
+			} else if (rasLowBitsForHor == 2) {
+				fbArr[i].bufCr =
+					((((chrRasBot >> 2) << 2) + 2) << 16) +
+					(((chrRasTop >> 2) << 2) + 2);
+			} else if (rasLowBitsForHor == 1) {
+				fbArr[i].bufCr =
+					((((chrRasBot >> 1) << 1) + 1) << 16) +
+					(((chrRasTop >> 1) << 1) + 1);
+			} else {
+				return RETCODE_INSUFFICIENT_RESOURCE; // Invalid RasLowBit value
+			}
+		}
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+/* \brief   Allocate tiled framebuffer on GDI version 2.0 H/W
+ */
+RetCode AllocateTiledFrameBufferGdiV2(TiledMapType mapType, FrameBuffer *fbArr,
+				      Uint32 numOfFrameBuffers, Uint32 sizeLuma,
+				      Uint32 sizeChroma)
+{
+	Uint32 i;
+	Uint32 fieldFrame;
+	Uint32 sizeFb;
+	BOOL cbcrInterleave;
+
+	sizeFb = sizeLuma + sizeChroma * 2;
+	fieldFrame = (mapType == TILED_FIELD_V_MAP ||
+		      mapType == TILED_FIELD_NO_BANK_MAP ||
+		      mapType == LINEAR_FIELD_MAP);
+
+	for (i = 0; i < numOfFrameBuffers; i++) {
+		cbcrInterleave = fbArr[0].cbcrInterleave;
+		fbArr[i].bufCb = fbArr[i].bufY + (sizeLuma >> fieldFrame);
+		fbArr[i].bufCr = fbArr[i].bufCb + (sizeChroma >> fieldFrame);
+
+		switch (mapType) {
+		case TILED_FIELD_V_MAP:
+		case TILED_FIELD_NO_BANK_MAP:
+			fbArr[i].bufYBot =
+				fbArr[i].bufY + (sizeFb >> fieldFrame);
+			fbArr[i].bufCbBot =
+				fbArr[i].bufYBot + (sizeLuma >> fieldFrame);
+			if (cbcrInterleave == FALSE) {
+				fbArr[i].bufCrBot = fbArr[i].bufCbBot +
+						    (sizeChroma >> fieldFrame);
+			}
+			break;
+		case TILED_FRAME_V_MAP:
+		case TILED_FRAME_H_MAP:
+		case TILED_MIXED_V_MAP:
+		case TILED_FRAME_NO_BANK_MAP:
+			fbArr[i].bufYBot = fbArr[i].bufY;
+			fbArr[i].bufCbBot = fbArr[i].bufCb;
+			if (cbcrInterleave == FALSE) {
+				fbArr[i].bufCrBot = fbArr[i].bufCr;
+			}
+			break;
+		case TILED_FIELD_MB_RASTER_MAP:
+			fbArr[i].bufYBot = fbArr[i].bufY + (sizeLuma >> 1);
+			fbArr[i].bufCbBot = fbArr[i].bufCb + sizeChroma;
+			break;
+		default:
+			fbArr[i].bufYBot = 0;
+			fbArr[i].bufCbBot = 0;
+			fbArr[i].bufCrBot = 0;
+			break;
+		}
+	}
+
+	return RETCODE_SUCCESS;
+}
+
+Int32 ConfigSecAXICoda9(Uint32 coreIdx, Int32 codecMode, SecAxiInfo *sa,
+			Uint32 width, Uint32 height, Uint32 profile)
+{
+	vpu_buffer_t vb;
+	int offset;
+	Uint32 MbNumX = ((width & 0xFFFF) + 15) / 16;
+	Uint32 MbNumY = ((height & 0xFFFF) + 15) / 16;
+	Uint32 productId;
+	Int32 ret = -1;
+
+	VLOG(TRACE, "[%s:%d] coreIdx:%d.width:%d.height:%d.profile:%d.",
+	     __FUNCTION__, __LINE__, coreIdx, width, height, profile);
+
+	ret = vdi_get_sram_memory(coreIdx, &vb);
+	if (ret < 0) {
+		VLOG(ERR, "[%s:%d] coreIdx:%d.vdi_get_sram_memory() ret < 0.",
+		     __FUNCTION__, __LINE__, coreIdx);
+		return 0;
+	}
+
+	productId = ProductVpuGetId(coreIdx);
+
+	if (!vb.size || ret == 1) {
+		sa->bufSize = 0;
+		sa->u.coda9.useBitEnable = 0;
+		sa->u.coda9.useIpEnable = 0;
+		sa->u.coda9.useDbkYEnable = 0;
+		sa->u.coda9.useDbkCEnable = 0;
+		sa->u.coda9.useOvlEnable = 0;
+		sa->u.coda9.useBtpEnable = 0;
+		if (ret == 1) /* RTK, 2nd SRAM is used by other VE */
+		{
+			VLOG(ERR,
+			     "\033[0;35mIn[%s][%d] 2nd SRAM is unavailable\033[m\n",
+			     __FUNCTION__, __LINE__);
+			return 1;
+		} else
+			return 0;
+	}
+
+	if (codecMode == AVC_DEC && MbNumX >= 240) // width >= 3840
+	{
+		sa->u.coda9.useBitEnable = 1;
+		sa->u.coda9.useIpEnable = 1;
+		sa->u.coda9.useDbkYEnable = 1;
+		sa->u.coda9.useDbkCEnable = 0;
+		sa->u.coda9.useOvlEnable = 0;
+		sa->u.coda9.useBtpEnable = 0;
+		VLOG(ERR,
+		     "== In[%s][%d] AVC, width >= 3840.enable useBitEnable + useIpEnable + useDbkYEnable ==\n",
+		     __FUNCTION__, __LINE__);
+	}
+
+	if (codecMode == VC1_DEC && profile == 2 && MbNumX > 110) {
+		VLOG(ERR,
+		     "== In[%s][%d]  workaround for VC1 %dx%d, profile == 2, fix later ==\n",
+		     __FUNCTION__, __LINE__, width, height);
+		sa->u.coda9.useDbkCEnable = 0;
+		sa->u.coda9.useIpEnable = 0;
+	}
+
+	sa->bufBase = vb.phys_addr;
+	offset = 0;
+	//BIT
+	if (sa->u.coda9.useBitEnable) {
+		sa->u.coda9.useBitEnable = 1;
+		sa->u.coda9.bufBitUse = vb.phys_addr + offset;
+
+		switch (codecMode) {
+		case AVC_DEC:
+			offset = offset + MbNumX * 144;
+			break; // AVC
+		case RV_DEC:
+			offset = offset + MbNumX * 128;
+			break;
+		case VC1_DEC:
+			offset = offset + MbNumX * 64;
+			break;
+		case AVS_DEC:
+			offset = offset + ((MbNumX + 3) & ~3) * 32;
+			break;
+		case MP2_DEC:
+			offset = offset + MbNumX * 0;
+			break;
+		case VPX_DEC:
+			offset = offset + MbNumX * 0;
+			break;
+		case AVC_ENC: {
+			if (productId == PRODUCT_ID_960)
+				offset = offset + MbNumX * 128;
+			else
+				offset = offset + MbNumX * 16;
+		} break;
+		case MP4_ENC:
+			offset = offset + MbNumX * 16;
+			break;
+		default:
+			offset = offset + MbNumX * 16;
+			break; // MPEG-4
+		}
+
+		if (offset > vb.size) {
+			sa->bufSize = 0;
+			VLOG(ERR, "[%s:%d] coreIdx:%d.offset:%d > size:%d.",
+			     __FUNCTION__, __LINE__, coreIdx, offset, vb.size);
+			return 0;
+		}
+		VLOG(TRACE,
+		     "[%s:%d] useBitEnable.coreIdx:%d.bufBitUse:0x%x.offset:%d.",
+		     __FUNCTION__, __LINE__, coreIdx, sa->u.coda9.bufBitUse,
+		     offset);
+	}
+
+	//Intra Prediction, ACDC
+	if (sa->u.coda9.useIpEnable) {
+		sa->u.coda9.bufIpAcDcUse = vb.phys_addr + offset;
+		sa->u.coda9.useIpEnable = 1;
+
+		switch (codecMode) {
+		case AVC_DEC:
+			offset = offset + MbNumX * 64;
+			break; // AVC
+		case RV_DEC:
+			offset = offset + MbNumX * 64;
+			break;
+		case VC1_DEC:
+			offset = offset + MbNumX * 128;
+			break;
+		case AVS_DEC:
+			offset = offset + MbNumX * 64;
+			break;
+		case MP2_DEC:
+			offset = offset + MbNumX * 0;
+			break;
+		case VPX_DEC:
+			offset = offset + MbNumX * 64;
+			break;
+		case AVC_ENC:
+			offset = offset + MbNumX * 64;
+			break;
+		case MP4_ENC:
+			offset = offset + MbNumX * 128;
+			break;
+		default:
+			offset = offset + MbNumX * 128;
+			break; // MPEG-4
+		}
+
+		if (offset > vb.size) {
+			sa->bufSize = 0;
+			VLOG(ERR, "[%s:%d] coreIdx:%d.offset:%d > size:%d.",
+			     __FUNCTION__, __LINE__, coreIdx, offset, vb.size);
+			return 0;
+		}
+		VLOG(TRACE,
+		     "[%s:%d] useIpEnable.coreIdx:%d.bufIpAcDcUse:0x%x.offset:%d.",
+		     __FUNCTION__, __LINE__, coreIdx, sa->u.coda9.bufIpAcDcUse,
+		     offset);
+	}
+
+	//Deblock Chroma
+	if (sa->u.coda9.useDbkCEnable) {
+		sa->u.coda9.bufDbkCUse = vb.phys_addr + offset;
+		sa->u.coda9.useDbkCEnable = 1;
+		switch (codecMode) {
+		case AVC_DEC:
+			offset = (profile == 66 /*AVC BP decoder*/) ?
+					 offset + (MbNumX * 64) :
+					 offset + (MbNumX * 128);
+			break; // AVC
+		case RV_DEC:
+			offset = offset + MbNumX * 128;
+			break;
+		case VC1_DEC:
+			offset = profile == 2 ? offset + MbNumX * 256 :
+						offset + MbNumX * 128;
+			break;
+		case AVS_DEC:
+			offset = offset + MbNumX * 64;
+			break;
+		case MP2_DEC:
+			offset = offset + MbNumX * 64;
+			break;
+		case VPX_DEC:
+			offset = offset + MbNumX * 128;
+			break;
+		case MP4_DEC:
+			offset = offset + MbNumX * 64;
+			break;
+		case AVC_ENC:
+			offset = offset + MbNumX * 64;
+			break;
+		case MP4_ENC:
+			offset = offset + MbNumX * 64;
+			break;
+		default:
+			offset = offset + MbNumX * 64;
+			break;
+		}
+		if (offset > vb.size) {
+			sa->bufSize = 0;
+			VLOG(ERR, "[%s:%d] coreIdx:%d.offset:%d > size:%d.",
+			     __FUNCTION__, __LINE__, coreIdx, offset, vb.size);
+			return 0;
+		}
+		VLOG(TRACE,
+		     "[%s:%d] useDbkCEnable.coreIdx:%d.bufDbkCUse:0x%x.offset:%d.",
+		     __FUNCTION__, __LINE__, coreIdx, sa->u.coda9.bufDbkCUse,
+		     offset);
+	}
+
+	//Deblock Luma
+	if (sa->u.coda9.useDbkYEnable) {
+		sa->u.coda9.bufDbkYUse = vb.phys_addr + offset;
+		sa->u.coda9.useDbkYEnable = 1;
+
+		switch (codecMode) {
+		case AVC_DEC:
+			offset = (profile == 66 /*AVC BP decoder*/) ?
+					 offset + (MbNumX * 64) :
+					 offset + (MbNumX * 128);
+			break; // AVC
+		case RV_DEC:
+			offset = offset + MbNumX * 128;
+			break;
+		case VC1_DEC:
+			offset = profile == 2 ? offset + MbNumX * 256 :
+						offset + MbNumX * 128;
+			break;
+		case AVS_DEC:
+			offset = offset + MbNumX * 64;
+			break;
+		case MP2_DEC:
+			offset = offset + MbNumX * 128;
+			break;
+		case VPX_DEC:
+			offset = offset + MbNumX * 128;
+			break;
+		case MP4_DEC:
+			offset = offset + MbNumX * 64;
+			break;
+		case AVC_ENC:
+			offset = offset + MbNumX * 64;
+			break;
+		case MP4_ENC:
+			offset = offset + MbNumX * 64;
+			break;
+		default:
+			offset = offset + MbNumX * 128;
+			break;
+		}
+
+		if (offset > vb.size) {
+			sa->bufSize = 0;
+			VLOG(ERR, "[%s:%d] coreIdx:%d.offset:%d > size:%d.",
+			     __FUNCTION__, __LINE__, coreIdx, offset, vb.size);
+			return 0;
+		}
+		VLOG(TRACE,
+		     "[%s:%d] useDbkYEnable.coreIdx:%d.bufDbkYUse:0x%x.offset:%d.",
+		     __FUNCTION__, __LINE__, coreIdx, sa->u.coda9.bufDbkYUse,
+		     offset);
+	}
+
+	// check the buffer address which is 256 byte is available.
+	if (((offset + 255) & (~255)) > vb.size) {
+		VLOG(ERR, "%s:%d NOT ENOUGH SRAM: required(%d), sram(%d)\n",
+		     __FUNCTION__, __LINE__, offset, vb.size);
+		sa->bufSize = 0;
+		return 0;
+	}
+
+	//VC1 Bit-plane
+	if (sa->u.coda9.useBtpEnable) {
+		if (codecMode != VC1_DEC) {
+			sa->u.coda9.useBtpEnable = 0;
+		} else {
+			int oneBTP;
+
+			offset = ((offset + 255) & ~255);
+			sa->u.coda9.bufBtpUse = vb.phys_addr + offset;
+			sa->u.coda9.useBtpEnable = 1;
+
+			oneBTP = (((MbNumX + 15) / 16) * MbNumY + 1) * 2;
+			oneBTP = (oneBTP % 256) ? ((oneBTP / 256) + 1) * 256 :
+						  oneBTP;
+
+			offset = offset + oneBTP * 3;
+
+			if (offset > vb.size) {
+				sa->bufSize = 0;
+				VLOG(ERR,
+				     "[%s:%d] coreIdx:%d.offset:%d > size:%d.",
+				     __FUNCTION__, __LINE__, coreIdx, offset,
+				     vb.size);
+				return 0;
+			}
+			VLOG(TRACE,
+			     "[%s:%d] useBtpEnable.coreIdx:%d.bufBtpUse:0x%x.offset:%d.",
+			     __FUNCTION__, __LINE__, coreIdx,
+			     sa->u.coda9.bufBtpUse, offset);
+		}
+	}
+
+	//VC1 Overlap
+	if (sa->u.coda9.useOvlEnable) {
+		if (codecMode != VC1_DEC) {
+			sa->u.coda9.useOvlEnable = 0;
+		} else {
+			sa->u.coda9.bufOvlUse = vb.phys_addr + offset;
+			sa->u.coda9.useOvlEnable = 1;
+
+			offset = offset + MbNumX * 80;
+
+			if (offset > vb.size) {
+				sa->bufSize = 0;
+				VLOG(ERR,
+				     "[%s:%d] coreIdx:%d.offset:%d > size:%d.",
+				     __FUNCTION__, __LINE__, coreIdx, offset,
+				     vb.size);
+				return 0;
+			}
+			VLOG(TRACE,
+			     "[%s:%d] useOvlEnable.coreIdx:%d.bufOvlUse:0x%x.offset:%d.",
+			     __FUNCTION__, __LINE__, coreIdx,
+			     sa->u.coda9.bufOvlUse, offset);
+		}
+	}
+
+	sa->bufSize = offset;
+	VLOG(TRACE, "[%s:%d] coreIdx:%d.bufSize:%d.", __FUNCTION__, __LINE__,
+	     coreIdx, sa->bufSize);
+
+	return 1;
+}
+
+Int32 ConfigSecAXIWave(Uint32 coreIdx, Int32 codecMode, SecAxiInfo *sa,
+		       Uint32 width, Uint32 height, Uint32 profile,
+		       Uint32 levelIdc)
+{
+	vpu_buffer_t vb;
+	int offset;
+	Uint32 lumaSize;
+	Uint32 chromaSize;
+	Uint32 productId;
+	Int32 ret = -1;
+
+	UNREFERENCED_PARAMETER(codecMode);
+	UNREFERENCED_PARAMETER(height);
+
+	VLOG(TRACE,
+	     "[%s:%d] coreIdx:%d.width:%d.height:%d.profile:%d.levelIdc:%d.\n",
+	     __FUNCTION__, __LINE__, coreIdx, width, height, profile, levelIdc);
+
+	ret = vdi_get_sram_memory(coreIdx, &vb);
+	if (ret < 0) {
+		VLOG(TRACE,
+		     "[%s:%d] coreIdx:%d.vdi_get_sram_memory() ret < 0.\n",
+		     __FUNCTION__, __LINE__, coreIdx);
+		return 0;
+	}
+
+	productId = ProductVpuGetId(coreIdx);
+
+	if (!vb.size || ret == 1) {
+		sa->bufSize = 0;
+		sa->u.wave4.useIpEnable = 0;
+		sa->u.wave4.useLfRowEnable = 0;
+		sa->u.wave4.useBitEnable = 0;
+		sa->u.wave4.useSclEnable = 0;
+		sa->u.wave4.useSclPackedModeEnable = FALSE;
+		sa->u.wave4.useEncImdEnable = 0;
+		sa->u.wave4.useEncLfEnable = 0;
+		sa->u.wave4.useEncRdoEnable = 0;
+		if (ret == 1) /* RTK, 2nd SRAM is used by other VE */
+		{
+			VLOG(TRACE,
+			     "\033[0;35mIn[%s][%d] 2nd SRAM is unavailable\033[m\n",
+			     __FUNCTION__, __LINE__);
+			return 1;
+		} else
+			return 0;
+	}
+
+#if 1 //RTK
+	if (width > 1920) //RTK didn't need scalar packed mode (YUYV)
+	{
+		sa->u.wave4.useSclPackedModeEnable = FALSE;
+		if (codecMode == W_VP9_DEC) {
+			//sa->u.wave.useBitEnable = FALSE;
+		}
+	}
+#endif
+
+	sa->bufBase = vb.phys_addr;
+	offset = 0;
+	if (sa->u.wave4.useEncLfEnable == TRUE) {
+		/* Main   profile(8bit) :
+         *              Luma   = Align64(picWidth) * 5
+         *              Chroma = Align64(picWidth) * 3
+         * Main10 profile(10bit) :
+         *              Luma   = Align64(picWidth) * 7
+         *              Chroma = Align64(picWidth) * 5
+         */
+		Uint32 luma = (profile == HEVC_PROFILE_MAIN10 ? 7 : 5);
+		Uint32 chroma = (profile == HEVC_PROFILE_MAIN10 ? 5 : 3);
+
+		sa->u.wave4.bufLf = sa->bufBase + offset;
+
+		lumaSize = VPU_ALIGN64(width) * luma;
+		chromaSize = VPU_ALIGN64(width) * chroma;
+		offset += lumaSize + chromaSize;
+
+		if (offset > vb.size) {
+			sa->bufSize = 0;
+			VLOG(ERR, "[%s:%d] coreIdx:%d.offset:%d > size:%d.\n",
+			     __FUNCTION__, __LINE__, coreIdx, offset, vb.size);
+			return 0;
+		}
+		VLOG(TRACE,
+		     "[%s:%d] useEncLfEnable.coreIdx:%d.bufLf:0x%x.offset:%d.\n",
+		     __FUNCTION__, __LINE__, coreIdx, sa->u.wave4.bufLf,
+		     offset);
+	}
+
+	if (sa->u.wave4.useEncRdoEnable == TRUE) {
+		switch (productId) {
+		default:
+			/* Main   profile(8bit) : (Align64(picWidth)/64) * 336
+            * Main10 profile(10bit): (Align64(picWidth)/64) * 336
+            */
+			sa->u.wave4.bufRdo = sa->bufBase + offset;
+			offset += (VPU_ALIGN64(width) / 64) * 256;
+			break;
+		}
+
+		if (offset > vb.size) {
+			sa->bufSize = 0;
+			VLOG(ERR, "[%s:%d] coreIdx:%d.offset:%d > size:%d.\n",
+			     __FUNCTION__, __LINE__, coreIdx, offset, vb.size);
+			return 0;
+		}
+		VLOG(TRACE,
+		     "[%s:%d] useEncRdoEnable.coreIdx:%d.bufRdo:0x%x.offset:%d.\n",
+		     __FUNCTION__, __LINE__, coreIdx, sa->u.wave4.bufRdo,
+		     offset);
+	}
+
+	sa->bufSize = offset;
+	VLOG(TRACE, "[%s:%d] coreIdx:%d.bufSize:%d.\n", __FUNCTION__, __LINE__,
+	     coreIdx, sa->bufSize);
+
+	return 1;
+}
+
+static int SetTiledMapTypeV20(Uint32 coreIdx, TiledMapConfig *pMapCfg,
+			      int mapType, int width, int interleave)
+{
+#define GEN_XY2AXI(INV, ZER, TBX, XY, BIT)                                     \
+	((INV) << 7 | (ZER) << 6 | (TBX) << 5 | (XY) << 4 | (BIT))
+#define GEN_CONFIG(A, B, C, D, E, F, G, H, I)                                  \
+	((A) << 20 | (B) << 19 | (C) << 18 | (D) << 17 | (E) << 16 |           \
+	 (F) << 12 | (G) << 8 | (H) << 4 | (I))
+#define X_SEL 0
+#define Y_SEL 1
+
+	const int luma_map =
+		0x40; // zero, inv = 1'b0, zero = 1'b1 , tbxor = 1'b0, xy = 1'b0, bit = 4'd0
+	const int chro_map =
+		0x40; // zero, inv = 1'b0, zero = 1'b1 , tbxor = 1'b0, xy = 1'b0, bit = 4'd0
+	int width_chr;
+	int i;
+
+	pMapCfg->mapType = mapType;
+
+	for (i = 0; i < 32; i = i + 1) {
+		pMapCfg->xy2axiLumMap[i] = luma_map;
+		pMapCfg->xy2axiChrMap[i] = chro_map;
+	}
+	pMapCfg->xy2axiConfig = 0;
+
+	width_chr = (interleave) ? width : width / 2;
+
+	switch (mapType) {
+	case LINEAR_FRAME_MAP:
+	case LINEAR_FIELD_MAP:
+		pMapCfg->xy2axiConfig = 0;
+		return 1;
+		break;
+	case TILED_FRAME_V_MAP: {
+		// luma
+		pMapCfg->xy2axiLumMap[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		pMapCfg->xy2axiLumMap[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		pMapCfg->xy2axiLumMap[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		pMapCfg->xy2axiLumMap[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		pMapCfg->xy2axiLumMap[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		pMapCfg->xy2axiLumMap[8] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		pMapCfg->xy2axiLumMap[9] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		pMapCfg->xy2axiLumMap[10] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		pMapCfg->xy2axiLumMap[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 4);
+		pMapCfg->xy2axiLumMap[12] = GEN_XY2AXI(0, 0, 0, X_SEL, 7);
+		pMapCfg->xy2axiLumMap[13] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+
+		if (width <= 512) {
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 1024) {
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 2048) {
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else { // 4K size
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+		// chroma
+		pMapCfg->xy2axiChrMap[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		pMapCfg->xy2axiChrMap[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		pMapCfg->xy2axiChrMap[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		pMapCfg->xy2axiChrMap[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		pMapCfg->xy2axiChrMap[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		pMapCfg->xy2axiChrMap[8] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		pMapCfg->xy2axiChrMap[9] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		pMapCfg->xy2axiChrMap[10] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		pMapCfg->xy2axiChrMap[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		pMapCfg->xy2axiChrMap[12] = GEN_XY2AXI(1, 0, 0, X_SEL, 7);
+		pMapCfg->xy2axiChrMap[13] = GEN_XY2AXI(1, 0, 0, Y_SEL, 4);
+
+		if (width_chr <= 512) {
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 1024) {
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 2048) {
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else { // 4K size
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+		// xy2axiConfig
+		pMapCfg->xy2axiConfig = GEN_CONFIG(0, 0, 0, 1, 1, 15, 0, 15, 0);
+		break;
+	} // case TILED_FRAME_V_MAP
+	case TILED_FRAME_H_MAP: {
+		pMapCfg->xy2axiLumMap[3] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		pMapCfg->xy2axiLumMap[4] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		pMapCfg->xy2axiLumMap[5] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		pMapCfg->xy2axiLumMap[6] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		pMapCfg->xy2axiLumMap[7] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		pMapCfg->xy2axiLumMap[8] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		pMapCfg->xy2axiLumMap[9] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		pMapCfg->xy2axiLumMap[10] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		pMapCfg->xy2axiLumMap[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 4);
+		pMapCfg->xy2axiLumMap[12] = GEN_XY2AXI(0, 0, 0, X_SEL, 7);
+		pMapCfg->xy2axiLumMap[13] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		if (width <= 512) {
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 1024) {
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 2048) {
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else { // 4K size
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+		pMapCfg->xy2axiChrMap[3] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		pMapCfg->xy2axiChrMap[4] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		pMapCfg->xy2axiChrMap[5] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		pMapCfg->xy2axiChrMap[6] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		pMapCfg->xy2axiChrMap[7] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		pMapCfg->xy2axiChrMap[8] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		pMapCfg->xy2axiChrMap[9] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		pMapCfg->xy2axiChrMap[10] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		pMapCfg->xy2axiChrMap[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		pMapCfg->xy2axiChrMap[12] = GEN_XY2AXI(1, 0, 0, X_SEL, 7);
+		pMapCfg->xy2axiChrMap[13] = GEN_XY2AXI(1, 0, 0, Y_SEL, 4);
+		if (width_chr <= 512) {
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 1024) {
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 2048) {
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else { // 4K size
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+		// xy2axiConfig
+		pMapCfg->xy2axiConfig =
+			GEN_CONFIG(0, 0, 0, 1, 0, 15, 15, 15, 15);
+		break;
+	} //case TILED_FRAME_H_MAP:
+	case TILED_FIELD_V_MAP: {
+		pMapCfg->xy2axiLumMap[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		pMapCfg->xy2axiLumMap[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		pMapCfg->xy2axiLumMap[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		pMapCfg->xy2axiLumMap[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		pMapCfg->xy2axiLumMap[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		pMapCfg->xy2axiLumMap[8] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		pMapCfg->xy2axiLumMap[9] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		pMapCfg->xy2axiLumMap[10] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		pMapCfg->xy2axiLumMap[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 4);
+		pMapCfg->xy2axiLumMap[12] = GEN_XY2AXI(0, 0, 0, X_SEL, 7);
+		pMapCfg->xy2axiLumMap[13] = GEN_XY2AXI(0, 0, 1, Y_SEL, 5);
+		if (width <= 512) {
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 1024) {
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 2048) {
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else { // 4K size
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+		pMapCfg->xy2axiChrMap[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		pMapCfg->xy2axiChrMap[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		pMapCfg->xy2axiChrMap[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		pMapCfg->xy2axiChrMap[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		pMapCfg->xy2axiChrMap[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		pMapCfg->xy2axiChrMap[8] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		pMapCfg->xy2axiChrMap[9] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		pMapCfg->xy2axiChrMap[10] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		pMapCfg->xy2axiChrMap[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		pMapCfg->xy2axiChrMap[12] = GEN_XY2AXI(1, 0, 0, X_SEL, 7);
+		pMapCfg->xy2axiChrMap[13] = GEN_XY2AXI(1, 0, 1, Y_SEL, 4);
+		if (width_chr <= 512) {
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 1024) {
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 2048) {
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else { // 4K size
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+
+		//xy2axiConfig
+		pMapCfg->xy2axiConfig =
+			GEN_CONFIG(0, 1, 1, 1, 1, 15, 15, 15, 15);
+		break;
+	}
+	case TILED_MIXED_V_MAP: {
+		pMapCfg->xy2axiLumMap[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		pMapCfg->xy2axiLumMap[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		pMapCfg->xy2axiLumMap[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		pMapCfg->xy2axiLumMap[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		pMapCfg->xy2axiLumMap[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		pMapCfg->xy2axiLumMap[8] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		pMapCfg->xy2axiLumMap[9] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		pMapCfg->xy2axiLumMap[10] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		pMapCfg->xy2axiLumMap[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 4);
+		pMapCfg->xy2axiLumMap[12] = GEN_XY2AXI(0, 0, 0, X_SEL, 7);
+		pMapCfg->xy2axiLumMap[13] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		if (width <= 512) {
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 1024) {
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 2048) {
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else { // 4K size
+			pMapCfg->xy2axiLumMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiLumMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+		pMapCfg->xy2axiChrMap[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		pMapCfg->xy2axiChrMap[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		pMapCfg->xy2axiChrMap[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		pMapCfg->xy2axiChrMap[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		pMapCfg->xy2axiChrMap[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		pMapCfg->xy2axiChrMap[8] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		pMapCfg->xy2axiChrMap[9] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		pMapCfg->xy2axiChrMap[10] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		pMapCfg->xy2axiChrMap[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		pMapCfg->xy2axiChrMap[12] = GEN_XY2AXI(1, 0, 0, X_SEL, 7);
+		pMapCfg->xy2axiChrMap[13] = GEN_XY2AXI(1, 0, 0, Y_SEL, 4);
+		if (width_chr <= 512) {
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 1024) {
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 2048) {
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else {
+			pMapCfg->xy2axiChrMap[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			pMapCfg->xy2axiChrMap[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+		//xy2axiConfig
+		pMapCfg->xy2axiConfig = GEN_CONFIG(0, 0, 1, 1, 1, 7, 7, 7, 7);
+		break;
+	}
+	case TILED_FRAME_MB_RASTER_MAP: {
+		pMapCfg->xy2axiLumMap[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		pMapCfg->xy2axiLumMap[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		pMapCfg->xy2axiLumMap[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		pMapCfg->xy2axiLumMap[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		pMapCfg->xy2axiLumMap[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+
+		pMapCfg->xy2axiChrMap[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		pMapCfg->xy2axiChrMap[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		pMapCfg->xy2axiChrMap[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		pMapCfg->xy2axiChrMap[6] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+
+		//-----------------------------------------------------------
+		// mb_addr = mby*stride + mbx
+		// mb_addr mapping:
+		//   luma   : axi_addr[~:8] => axi_addr = {mb_addr[23:0],map_addr[7:0]}
+		//   chroma : axi_addr[~:7] => axi_addr = {mb_addr[23:0],map_addr[6:0]}
+		//-----------------------------------------------------------
+
+		//xy2axiConfig
+		pMapCfg->xy2axiConfig = GEN_CONFIG(0, 0, 0, 1, 1, 15, 0, 7, 0);
+		break;
+	}
+	case TILED_FIELD_MB_RASTER_MAP: {
+		pMapCfg->xy2axiLumMap[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		pMapCfg->xy2axiLumMap[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		pMapCfg->xy2axiLumMap[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		pMapCfg->xy2axiLumMap[6] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+
+		pMapCfg->xy2axiChrMap[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		pMapCfg->xy2axiChrMap[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		pMapCfg->xy2axiChrMap[5] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+
+		//-----------------------------------------------------------
+		// mb_addr = mby*stride + mbx
+		// mb_addr mapping:
+		//   luma   : axi_addr[~:7] => axi_addr = {mb_addr[23:0],map_addr[6:0]}
+		//   chroma : axi_addr[~:6] => axi_addr = {mb_addr[23:0],map_addr[5:0]}
+		//-----------------------------------------------------------
+
+		//xy2axiConfig
+		pMapCfg->xy2axiConfig = GEN_CONFIG(0, 1, 1, 1, 1, 7, 7, 3, 3);
+
+		break;
+	}
+	case TILED_FRAME_NO_BANK_MAP:
+	case TILED_FIELD_NO_BANK_MAP: {
+		// luma
+		pMapCfg->xy2axiLumMap[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		pMapCfg->xy2axiLumMap[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		pMapCfg->xy2axiLumMap[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		pMapCfg->xy2axiLumMap[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		pMapCfg->xy2axiLumMap[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		pMapCfg->xy2axiLumMap[8] = GEN_XY2AXI(0, 0, 0, Y_SEL, 4);
+		pMapCfg->xy2axiLumMap[9] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		pMapCfg->xy2axiLumMap[10] = GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+		pMapCfg->xy2axiLumMap[11] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		pMapCfg->xy2axiLumMap[12] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		pMapCfg->xy2axiLumMap[13] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		pMapCfg->xy2axiLumMap[14] = GEN_XY2AXI(0, 0, 0, X_SEL, 7);
+		pMapCfg->xy2axiLumMap[15] = GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+		if (width <= 512) {
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 1024) {
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 2048) {
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else {
+			pMapCfg->xy2axiLumMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiLumMap[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiLumMap[18] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			pMapCfg->xy2axiLumMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiLumMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiLumMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiLumMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiLumMap[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+		// chroma
+		pMapCfg->xy2axiChrMap[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		pMapCfg->xy2axiChrMap[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		pMapCfg->xy2axiChrMap[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		pMapCfg->xy2axiChrMap[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		pMapCfg->xy2axiChrMap[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		pMapCfg->xy2axiChrMap[8] = GEN_XY2AXI(0, 0, 0, Y_SEL, 4);
+		pMapCfg->xy2axiChrMap[9] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		pMapCfg->xy2axiChrMap[10] = GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+		pMapCfg->xy2axiChrMap[11] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		pMapCfg->xy2axiChrMap[12] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		pMapCfg->xy2axiChrMap[13] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		pMapCfg->xy2axiChrMap[14] = GEN_XY2AXI(0, 0, 0, X_SEL, 7);
+		pMapCfg->xy2axiChrMap[15] = GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+
+		if (width_chr <= 512) {
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 1024) {
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 2048) {
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else {
+			pMapCfg->xy2axiChrMap[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			pMapCfg->xy2axiChrMap[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			pMapCfg->xy2axiChrMap[18] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			pMapCfg->xy2axiChrMap[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			pMapCfg->xy2axiChrMap[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			pMapCfg->xy2axiChrMap[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			pMapCfg->xy2axiChrMap[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			pMapCfg->xy2axiChrMap[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+
+		//xy2axiConfig
+		if (mapType == TILED_FRAME_NO_BANK_MAP)
+			pMapCfg->xy2axiConfig =
+				GEN_CONFIG(0, 0, 0, 1, 1, 15, 0, 15, 0);
+		else
+			pMapCfg->xy2axiConfig =
+				GEN_CONFIG(0, 1, 1, 1, 1, 15, 15, 15, 15);
+
+		break;
+	}
+	default:
+		return 0;
+		break;
+	}
+
+	for (i = 0; i < 32; i++) { //xy2axiLumMap
+		VpuWriteReg(coreIdx, GDI_XY2AXI_LUM_BIT00 + 4 * i,
+			    pMapCfg->xy2axiLumMap[i]);
+	}
+
+	for (i = 0; i < 32; i++) { //xy2axiChrMap
+		VpuWriteReg(coreIdx, GDI_XY2AXI_CHR_BIT00 + 4 * i,
+			    pMapCfg->xy2axiChrMap[i]);
+	}
+
+	//xy2axiConfig
+	VpuWriteReg(coreIdx, GDI_XY2AXI_CONFIG, pMapCfg->xy2axiConfig);
+
+	// fast access for reading
+	pMapCfg->tbSeparateMap = (pMapCfg->xy2axiConfig >> 19) & 0x1;
+	pMapCfg->topBotSplit = (pMapCfg->xy2axiConfig >> 18) & 0x1;
+	pMapCfg->tiledMap = (pMapCfg->xy2axiConfig >> 17) & 0x1;
+
+	return 1;
+}
+
+static int GetXY2AXILogic(int map_val, int xpos, int ypos, int tb)
+{
+	int invert;
+	int assign_zero;
+	int tbxor;
+	int xysel;
+	int bitsel;
+
+	int xypos, xybit, xybit_st1, xybit_st2, xybit_st3;
+
+	invert = map_val >> 7;
+	assign_zero = (map_val & 0x78) >> 6;
+	tbxor = (map_val & 0x3C) >> 5;
+	xysel = (map_val & 0x1E) >> 4;
+	bitsel = map_val & 0x0f;
+
+	xypos = (xysel) ? ypos : xpos;
+	xybit = (xypos >> bitsel) & 0x01;
+	xybit_st1 = (tbxor) ? xybit ^ tb : xybit;
+	xybit_st2 = (assign_zero) ? 0 : xybit_st1;
+	xybit_st3 = (invert) ? !xybit_st2 : xybit_st2;
+
+	return xybit_st3;
+}
+
+static int GetXY2AXIAddr20(TiledMapConfig *pMapCfg, int ycbcr, int posY,
+			   int posX, int stride, FrameBuffer *fb)
+{
+	int tbSeparateMap;
+	int use_linear_field;
+	int ypos_field;
+	int tb;
+	int chr_flag;
+	int ypos_mod;
+	int i;
+	int mbx, mby;
+	int mbx_num;
+	int mb_addr;
+	int xy2axiLumMap;
+	int xy2axiChrMap;
+	int xy2axi_map_sel;
+	int temp_bit;
+	int tmp_addr;
+	int axi_conv;
+
+	int y_top_base;
+	int cb_top_base;
+	int cr_top_base;
+	int y_bot_base;
+	int cb_bot_base;
+	int cr_bot_base;
+	int top_base_addr;
+	int bot_base_addr;
+	int base_addr;
+	int pix_addr;
+	int mapType;
+	mapType = fb->mapType;
+
+	if (!pMapCfg)
+		return -1;
+
+	tbSeparateMap = pMapCfg->tbSeparateMap;
+	use_linear_field = (mapType == 9);
+	ypos_field = posY / 2;
+	tb = posY & 1;
+	ypos_mod = (tbSeparateMap | use_linear_field) ? ypos_field : posY;
+	chr_flag = (ycbcr >> 1) & 0x1;
+
+	mbx_num = stride / 16;
+
+	y_top_base = fb->bufY;
+	cb_top_base = fb->bufCb;
+	cr_top_base = fb->bufCr;
+	y_bot_base = fb->bufYBot;
+	cb_bot_base = fb->bufCbBot;
+	cr_bot_base = fb->bufCrBot;
+
+	if (mapType == LINEAR_FRAME_MAP) {
+		base_addr = (ycbcr == 0) ?
+				    y_top_base :
+				    (ycbcr == 2) ? cb_top_base : cr_top_base;
+		pix_addr = ((posY * stride) + posX) + base_addr;
+	} else if (mapType == LINEAR_FIELD_MAP) {
+		top_base_addr =
+			(ycbcr == 0) ? y_top_base :
+				       (ycbcr == 2) ? cb_top_base : cr_top_base;
+		bot_base_addr =
+			(ycbcr == 0) ? y_bot_base :
+				       (ycbcr == 2) ? cb_bot_base : cr_bot_base;
+		base_addr = tb ? bot_base_addr : top_base_addr;
+
+		pix_addr = ((ypos_mod * stride) + posX) + base_addr;
+	} else if (mapType == TILED_FRAME_MB_RASTER_MAP ||
+		   mapType == TILED_FIELD_MB_RASTER_MAP) {
+		top_base_addr =
+			(ycbcr == 0) ? y_top_base :
+				       (ycbcr == 2) ? cb_top_base : cr_top_base;
+		bot_base_addr =
+			(ycbcr == 0) ? y_bot_base :
+				       (ycbcr == 2) ? cb_bot_base : cr_bot_base;
+
+		if (tbSeparateMap & tb)
+			base_addr = bot_base_addr;
+		else
+			base_addr = top_base_addr;
+
+		if (ycbcr == 0) {
+			mbx = posX / 16;
+			mby = posY / 16;
+		} else { //always interleave
+			mbx = posX / 16;
+			mby = posY / 8;
+		}
+
+		mb_addr = mbx_num * mby + mbx;
+
+		// axi_conv[7:0]
+		axi_conv = 0;
+		for (i = 0; i < 8; i++) {
+			xy2axiLumMap = pMapCfg->xy2axiLumMap[i];
+			xy2axiChrMap = pMapCfg->xy2axiChrMap[i];
+			xy2axi_map_sel =
+				(chr_flag) ? xy2axiChrMap : xy2axiLumMap;
+			temp_bit = GetXY2AXILogic(xy2axi_map_sel, posX,
+						  ypos_mod, tb);
+			axi_conv = axi_conv + (temp_bit << i);
+		}
+
+		if (mapType == TILED_FRAME_MB_RASTER_MAP) {
+			if (chr_flag == 0)
+				tmp_addr = (mb_addr << 8) + axi_conv;
+			else // chroma, interleaved only
+				tmp_addr = (mb_addr << 7) + axi_conv;
+		} else { // TILED_FIELD_MB_RASTER_MAP
+			if (chr_flag == 0)
+				tmp_addr = (mb_addr << 7) + axi_conv;
+			else // chroma, interleaved only
+				tmp_addr = (mb_addr << 6) + axi_conv;
+		}
+
+		pix_addr = tmp_addr + base_addr;
+	} else {
+		top_base_addr =
+			(ycbcr == 0) ? y_top_base :
+				       (ycbcr == 2) ? cb_top_base : cr_top_base;
+		bot_base_addr =
+			(ycbcr == 0) ? y_bot_base :
+				       (ycbcr == 2) ? cb_bot_base : cr_bot_base;
+		if (tbSeparateMap & tb)
+			base_addr = bot_base_addr;
+		else
+			base_addr = top_base_addr;
+
+		// axi_conv[31:0]
+		axi_conv = 0;
+		for (i = 0; i < 32; i++) {
+			xy2axiLumMap = pMapCfg->xy2axiLumMap[i];
+			xy2axiChrMap = pMapCfg->xy2axiChrMap[i];
+			xy2axi_map_sel =
+				(chr_flag) ? xy2axiChrMap : xy2axiLumMap;
+			temp_bit = GetXY2AXILogic(xy2axi_map_sel, posX,
+						  ypos_mod, tb);
+			axi_conv = axi_conv + (temp_bit << i);
+		}
+
+		pix_addr = axi_conv + base_addr;
+	}
+
+	return pix_addr;
+}
+
+// GDI related functios for GDI 1.0
+PhysicalAddress GetTiledFrameBase(Uint32 coreIdx, FrameBuffer *frame, int num)
+{
+	PhysicalAddress baseAddr;
+	int i;
+
+	UNREFERENCED_PARAMETER(coreIdx);
+	baseAddr = frame[0].bufY;
+	for (i = 0; i < num; i++) {
+		if (frame[i].bufY < baseAddr)
+			baseAddr = frame[i].bufY;
+	}
+
+	return baseAddr;
+}
+
+void SetTiledFrameBase(Uint32 coreIdx, PhysicalAddress baseAddr)
+{
+	VpuWriteReg(coreIdx, GDI_TILEDBUF_BASE, baseAddr);
+}
+
+static int SetTiledMapTypeV10(Uint32 coreIdx, TiledMapConfig *pMapCfg,
+			      DRAMConfig *dramCfg, int stride, int mapType)
+{
+#define XY2CONFIG(A, B, C, D, E, F, G, H, I)                                   \
+	((A) << 20 | (B) << 19 | (C) << 18 | (D) << 17 | (E) << 16 |           \
+	 (F) << 12 | (G) << 8 | (H) << 4 | (I))
+#define XY2(A, B, C, D) ((A) << 12 | (B) << 8 | (C) << 4 | (D))
+#define XY2BANK(A, B, C, D, E, F)                                              \
+	((A) << 13 | (B) << 12 | (C) << 8 | (D) << 5 | (E) << 4 | (F))
+#define RBC(A, B, C, D) ((A) << 10 | (B) << 6 | (C) << 4 | (D))
+#define RBC_SAME(A, B) ((A) << 10 | (B) << 6 | (A) << 4 | (B))
+#define X_SEL 0
+#define Y_SEL 1
+#define CA_SEL 0
+#define BA_SEL 1
+#define RA_SEL 2
+#define Z_SEL 3
+	int ret;
+	int luma_map;
+	int chro_map;
+	int i;
+
+	UNREFERENCED_PARAMETER(stride);
+	pMapCfg->mapType = mapType;
+	luma_map = 64;
+	chro_map = 64;
+
+	for (i = 0; i < 16; i = i + 1) {
+		pMapCfg->xy2caMap[i] = luma_map << 8 | chro_map;
+	}
+
+	for (i = 0; i < 4; i = i + 1) {
+		pMapCfg->xy2baMap[i] = luma_map << 8 | chro_map;
+	}
+
+	for (i = 0; i < 16; i = i + 1) {
+		pMapCfg->xy2raMap[i] = luma_map << 8 | chro_map;
+	}
+
+	ret = stride; // this will be removed after map size optimizing.
+	ret = 0;
+	switch (mapType) {
+	case LINEAR_FRAME_MAP:
+		pMapCfg->xy2rbcConfig = 0;
+		ret = 1;
+		break;
+	case TILED_FRAME_V_MAP:
+		if (dramCfg->casBit == 9 && dramCfg->bankBit == 2 &&
+		    dramCfg->rasBit == 13) // CNN setting
+		{
+			//cas
+			pMapCfg->xy2caMap[0] = XY2(Y_SEL, 0, Y_SEL, 0);
+			pMapCfg->xy2caMap[1] = XY2(Y_SEL, 1, Y_SEL, 1);
+			pMapCfg->xy2caMap[2] = XY2(Y_SEL, 2, Y_SEL, 2);
+			pMapCfg->xy2caMap[3] = XY2(Y_SEL, 3, Y_SEL, 3);
+			pMapCfg->xy2caMap[4] = XY2(X_SEL, 3, X_SEL, 3);
+			pMapCfg->xy2caMap[5] = XY2(X_SEL, 4, X_SEL, 4);
+			pMapCfg->xy2caMap[6] = XY2(X_SEL, 5, X_SEL, 5);
+			pMapCfg->xy2caMap[7] = XY2(X_SEL, 6, X_SEL, 6);
+			pMapCfg->xy2caMap[8] = XY2(Y_SEL, 4, Y_SEL, 5);
+
+			//bank
+			pMapCfg->xy2baMap[0] =
+				XY2BANK(0, X_SEL, 7, 4, X_SEL, 7);
+			pMapCfg->xy2baMap[1] =
+				XY2BANK(0, Y_SEL, 5, 4, Y_SEL, 4);
+
+			//ras
+			pMapCfg->xy2raMap[0] = XY2(X_SEL, 8, X_SEL, 8);
+			pMapCfg->xy2raMap[1] = XY2(X_SEL, 9, X_SEL, 9);
+			pMapCfg->xy2raMap[2] = XY2(X_SEL, 10, X_SEL, 10);
+			pMapCfg->xy2raMap[3] = XY2(Y_SEL, 6, Y_SEL, 6);
+			pMapCfg->xy2raMap[4] = XY2(Y_SEL, 7, Y_SEL, 7);
+			pMapCfg->xy2raMap[5] = XY2(Y_SEL, 8, Y_SEL, 8);
+			pMapCfg->xy2raMap[6] = XY2(Y_SEL, 9, Y_SEL, 9);
+			pMapCfg->xy2raMap[7] = XY2(Y_SEL, 10, Y_SEL, 10);
+			pMapCfg->xy2raMap[8] = XY2(Y_SEL, 11, Y_SEL, 11);
+			pMapCfg->xy2raMap[9] = XY2(Y_SEL, 12, Y_SEL, 12);
+			pMapCfg->xy2raMap[10] = XY2(Y_SEL, 13, Y_SEL, 13);
+			pMapCfg->xy2raMap[11] = XY2(Y_SEL, 14, Y_SEL, 14);
+			pMapCfg->xy2raMap[12] = XY2(Y_SEL, 15, Y_SEL, 15);
+
+		} else if (dramCfg->casBit == 10 && dramCfg->bankBit == 3 &&
+			   dramCfg->rasBit == 13) {
+			//cas
+			pMapCfg->xy2caMap[0] = XY2(Z_SEL, 0, Z_SEL, 0);
+			pMapCfg->xy2caMap[1] = XY2(Y_SEL, 0, Y_SEL, 0);
+			pMapCfg->xy2caMap[2] = XY2(Y_SEL, 1, Y_SEL, 1);
+			pMapCfg->xy2caMap[3] = XY2(Y_SEL, 2, Y_SEL, 2);
+			pMapCfg->xy2caMap[4] = XY2(Y_SEL, 3, Y_SEL, 3);
+			pMapCfg->xy2caMap[5] = XY2(X_SEL, 3, X_SEL, 3);
+			pMapCfg->xy2caMap[6] = XY2(X_SEL, 4, X_SEL, 4);
+			pMapCfg->xy2caMap[7] = XY2(X_SEL, 5, X_SEL, 5);
+			pMapCfg->xy2caMap[8] = XY2(X_SEL, 6, X_SEL, 6);
+			pMapCfg->xy2caMap[9] = XY2(Y_SEL, 4, Y_SEL, 4);
+
+			//bank
+			pMapCfg->xy2baMap[0] =
+				XY2BANK(0, X_SEL, 7, 4, X_SEL, 7);
+			pMapCfg->xy2baMap[1] =
+				XY2BANK(0, X_SEL, 8, 4, X_SEL, 8);
+			pMapCfg->xy2baMap[2] =
+				XY2BANK(0, Y_SEL, 5, 4, Y_SEL, 5);
+
+			//ras
+			pMapCfg->xy2raMap[0] = XY2(X_SEL, 9, X_SEL, 9);
+			pMapCfg->xy2raMap[1] = XY2(X_SEL, 10, X_SEL, 10);
+			pMapCfg->xy2raMap[2] = XY2(Y_SEL, 6, Y_SEL, 6);
+			pMapCfg->xy2raMap[3] = XY2(Y_SEL, 7, Y_SEL, 7);
+			pMapCfg->xy2raMap[4] = XY2(Y_SEL, 8, Y_SEL, 8);
+			pMapCfg->xy2raMap[5] = XY2(Y_SEL, 9, Y_SEL, 9);
+			pMapCfg->xy2raMap[6] = XY2(Y_SEL, 10, Y_SEL, 10);
+			pMapCfg->xy2raMap[7] = XY2(Y_SEL, 11, Y_SEL, 11);
+			pMapCfg->xy2raMap[8] = XY2(Y_SEL, 12, Y_SEL, 12);
+			pMapCfg->xy2raMap[9] = XY2(Y_SEL, 13, Y_SEL, 13);
+			pMapCfg->xy2raMap[10] = XY2(Y_SEL, 14, Y_SEL, 14);
+			pMapCfg->xy2raMap[11] = XY2(Y_SEL, 15, Y_SEL, 15);
+		}
+
+		//xy2rbcConfig
+		pMapCfg->xy2rbcConfig = XY2CONFIG(0, 0, 0, 1, 1, 15, 0, 15, 0);
+		break;
+	case TILED_FRAME_H_MAP:
+		if (dramCfg->casBit == 9 && dramCfg->bankBit == 2 &&
+		    dramCfg->rasBit == 13) // CNN setting
+		{
+			//cas
+			pMapCfg->xy2caMap[0] = XY2(X_SEL, 3, X_SEL, 3);
+			pMapCfg->xy2caMap[1] = XY2(X_SEL, 4, X_SEL, 4);
+			pMapCfg->xy2caMap[2] = XY2(X_SEL, 5, X_SEL, 5);
+			pMapCfg->xy2caMap[3] = XY2(X_SEL, 6, X_SEL, 6);
+			pMapCfg->xy2caMap[4] = XY2(Y_SEL, 0, Y_SEL, 0);
+			pMapCfg->xy2caMap[5] = XY2(Y_SEL, 1, Y_SEL, 1);
+			pMapCfg->xy2caMap[6] = XY2(Y_SEL, 2, Y_SEL, 2);
+			pMapCfg->xy2caMap[7] = XY2(Y_SEL, 3, Y_SEL, 3);
+			pMapCfg->xy2caMap[8] = XY2(Y_SEL, 4, Y_SEL, 5);
+
+			//bank
+			pMapCfg->xy2baMap[0] =
+				XY2BANK(0, X_SEL, 7, 4, X_SEL, 7);
+			pMapCfg->xy2baMap[1] =
+				XY2BANK(0, Y_SEL, 5, 4, Y_SEL, 4);
+
+			//ras
+			pMapCfg->xy2raMap[0] = XY2(X_SEL, 8, X_SEL, 8);
+			pMapCfg->xy2raMap[1] = XY2(X_SEL, 9, X_SEL, 9);
+			pMapCfg->xy2raMap[2] = XY2(X_SEL, 10, X_SEL, 10);
+			pMapCfg->xy2raMap[3] = XY2(Y_SEL, 6, Y_SEL, 6);
+			pMapCfg->xy2raMap[4] = XY2(Y_SEL, 7, Y_SEL, 7);
+			pMapCfg->xy2raMap[5] = XY2(Y_SEL, 8, Y_SEL, 8);
+			pMapCfg->xy2raMap[6] = XY2(Y_SEL, 9, Y_SEL, 9);
+			pMapCfg->xy2raMap[7] = XY2(Y_SEL, 10, Y_SEL, 10);
+			pMapCfg->xy2raMap[8] = XY2(Y_SEL, 11, Y_SEL, 11);
+			pMapCfg->xy2raMap[9] = XY2(Y_SEL, 12, Y_SEL, 12);
+			pMapCfg->xy2raMap[10] = XY2(Y_SEL, 13, Y_SEL, 13);
+			pMapCfg->xy2raMap[11] = XY2(Y_SEL, 14, Y_SEL, 14);
+			pMapCfg->xy2raMap[12] = XY2(Y_SEL, 15, Y_SEL, 15);
+
+		} else if (dramCfg->casBit == 10 && dramCfg->bankBit == 3 &&
+			   dramCfg->rasBit == 13) {
+			//cas
+			pMapCfg->xy2caMap[0] = XY2(Z_SEL, 0, Z_SEL, 0);
+			pMapCfg->xy2caMap[1] = XY2(X_SEL, 3, X_SEL, 3);
+			pMapCfg->xy2caMap[2] = XY2(X_SEL, 4, X_SEL, 4);
+			pMapCfg->xy2caMap[3] = XY2(X_SEL, 5, X_SEL, 5);
+			pMapCfg->xy2caMap[4] = XY2(X_SEL, 6, X_SEL, 6);
+			pMapCfg->xy2caMap[5] = XY2(Y_SEL, 0, Y_SEL, 0);
+			pMapCfg->xy2caMap[6] = XY2(Y_SEL, 1, Y_SEL, 1);
+			pMapCfg->xy2caMap[7] = XY2(Y_SEL, 2, Y_SEL, 2);
+			pMapCfg->xy2caMap[8] = XY2(Y_SEL, 3, Y_SEL, 3);
+			pMapCfg->xy2caMap[9] = XY2(Y_SEL, 4, Y_SEL, 4);
+
+			//bank
+			pMapCfg->xy2baMap[0] =
+				XY2BANK(0, X_SEL, 7, 4, X_SEL, 7);
+			pMapCfg->xy2baMap[1] =
+				XY2BANK(0, X_SEL, 8, 4, X_SEL, 8);
+			pMapCfg->xy2baMap[2] =
+				XY2BANK(0, Y_SEL, 5, 4, Y_SEL, 5);
+			pMapCfg->xy2raMap[0] = XY2(X_SEL, 9, X_SEL, 9);
+			pMapCfg->xy2raMap[1] = XY2(X_SEL, 10, X_SEL, 10);
+			pMapCfg->xy2raMap[2] = XY2(Y_SEL, 6, Y_SEL, 6);
+			pMapCfg->xy2raMap[3] = XY2(Y_SEL, 7, Y_SEL, 7);
+			pMapCfg->xy2raMap[4] = XY2(Y_SEL, 8, Y_SEL, 8);
+			pMapCfg->xy2raMap[5] = XY2(Y_SEL, 9, Y_SEL, 9);
+			pMapCfg->xy2raMap[6] = XY2(Y_SEL, 10, Y_SEL, 10);
+			pMapCfg->xy2raMap[7] = XY2(Y_SEL, 11, Y_SEL, 11);
+			pMapCfg->xy2raMap[8] = XY2(Y_SEL, 12, Y_SEL, 12);
+			pMapCfg->xy2raMap[9] = XY2(Y_SEL, 13, Y_SEL, 13);
+			pMapCfg->xy2raMap[10] = XY2(Y_SEL, 14, Y_SEL, 14);
+			pMapCfg->xy2raMap[11] = XY2(Y_SEL, 15, Y_SEL, 15);
+		}
+		//xy2rbcConfig
+		pMapCfg->xy2rbcConfig =
+			XY2CONFIG(0, 0, 0, 1, 0, 15, 15, 15, 15);
+		break;
+	case TILED_FIELD_V_MAP:
+		if (dramCfg->casBit == 9 && dramCfg->bankBit == 2 &&
+		    dramCfg->rasBit == 13) // CNN setting
+		{
+			//cas
+			pMapCfg->xy2caMap[0] = XY2(Y_SEL, 0, Y_SEL, 0);
+			pMapCfg->xy2caMap[1] = XY2(Y_SEL, 1, Y_SEL, 1);
+			pMapCfg->xy2caMap[2] = XY2(Y_SEL, 2, Y_SEL, 2);
+			pMapCfg->xy2caMap[3] = XY2(Y_SEL, 3, Y_SEL, 3);
+			pMapCfg->xy2caMap[4] = XY2(X_SEL, 3, X_SEL, 3);
+			pMapCfg->xy2caMap[5] = XY2(X_SEL, 4, X_SEL, 4);
+			pMapCfg->xy2caMap[6] = XY2(X_SEL, 5, X_SEL, 5);
+			pMapCfg->xy2caMap[7] = XY2(X_SEL, 6, X_SEL, 6);
+			pMapCfg->xy2caMap[8] = XY2(Y_SEL, 4, Y_SEL, 5);
+
+			//bank
+			pMapCfg->xy2baMap[0] =
+				XY2BANK(0, X_SEL, 7, 4, X_SEL, 7);
+			pMapCfg->xy2baMap[1] =
+				XY2BANK(1, Y_SEL, 5, 5, Y_SEL, 4);
+
+			//ras
+			pMapCfg->xy2raMap[0] = XY2(X_SEL, 8, X_SEL, 8);
+			pMapCfg->xy2raMap[1] = XY2(X_SEL, 9, X_SEL, 9);
+			pMapCfg->xy2raMap[2] = XY2(X_SEL, 10, X_SEL, 10);
+			pMapCfg->xy2raMap[3] = XY2(Y_SEL, 6, Y_SEL, 6);
+			pMapCfg->xy2raMap[4] = XY2(Y_SEL, 7, Y_SEL, 7);
+			pMapCfg->xy2raMap[5] = XY2(Y_SEL, 8, Y_SEL, 8);
+			pMapCfg->xy2raMap[6] = XY2(Y_SEL, 9, Y_SEL, 9);
+			pMapCfg->xy2raMap[7] = XY2(Y_SEL, 10, Y_SEL, 10);
+			pMapCfg->xy2raMap[8] = XY2(Y_SEL, 11, Y_SEL, 11);
+			pMapCfg->xy2raMap[9] = XY2(Y_SEL, 12, Y_SEL, 12);
+			pMapCfg->xy2raMap[10] = XY2(Y_SEL, 13, Y_SEL, 13);
+			pMapCfg->xy2raMap[11] = XY2(Y_SEL, 14, Y_SEL, 14);
+			pMapCfg->xy2raMap[12] = XY2(Y_SEL, 15, Y_SEL, 15);
+		} else if (dramCfg->casBit == 10 && dramCfg->bankBit == 3 &&
+			   dramCfg->rasBit == 13) {
+			//cas
+			pMapCfg->xy2caMap[0] = XY2(Z_SEL, 0, Z_SEL, 0);
+			pMapCfg->xy2caMap[1] = XY2(Y_SEL, 0, Y_SEL, 0);
+			pMapCfg->xy2caMap[2] = XY2(Y_SEL, 1, Y_SEL, 1);
+			pMapCfg->xy2caMap[3] = XY2(Y_SEL, 2, Y_SEL, 2);
+			pMapCfg->xy2caMap[4] = XY2(Y_SEL, 3, Y_SEL, 3);
+			pMapCfg->xy2caMap[5] = XY2(X_SEL, 3, X_SEL, 3);
+			pMapCfg->xy2caMap[6] = XY2(X_SEL, 4, X_SEL, 4);
+			pMapCfg->xy2caMap[7] = XY2(X_SEL, 5, X_SEL, 5);
+			pMapCfg->xy2caMap[8] = XY2(X_SEL, 6, X_SEL, 6);
+			pMapCfg->xy2caMap[9] = XY2(Y_SEL, 4, Y_SEL, 4);
+
+			//bank
+			pMapCfg->xy2baMap[0] =
+				XY2BANK(0, X_SEL, 7, 4, X_SEL, 7);
+			pMapCfg->xy2baMap[1] =
+				XY2BANK(0, X_SEL, 8, 4, X_SEL, 8);
+			pMapCfg->xy2baMap[2] =
+				XY2BANK(0, Y_SEL, 5, 4, Y_SEL, 5);
+			pMapCfg->xy2raMap[0] = XY2(X_SEL, 9, X_SEL, 9);
+			pMapCfg->xy2raMap[1] = XY2(X_SEL, 10, X_SEL, 10);
+			pMapCfg->xy2raMap[2] = XY2(Y_SEL, 6, Y_SEL, 6);
+			pMapCfg->xy2raMap[3] = XY2(Y_SEL, 7, Y_SEL, 7);
+			pMapCfg->xy2raMap[4] = XY2(Y_SEL, 8, Y_SEL, 8);
+			pMapCfg->xy2raMap[5] = XY2(Y_SEL, 9, Y_SEL, 9);
+			pMapCfg->xy2raMap[6] = XY2(Y_SEL, 10, Y_SEL, 10);
+			pMapCfg->xy2raMap[7] = XY2(Y_SEL, 11, Y_SEL, 11);
+			pMapCfg->xy2raMap[8] = XY2(Y_SEL, 12, Y_SEL, 12);
+			pMapCfg->xy2raMap[9] = XY2(Y_SEL, 13, Y_SEL, 13);
+			pMapCfg->xy2raMap[10] = XY2(Y_SEL, 14, Y_SEL, 14);
+			pMapCfg->xy2raMap[11] = XY2(Y_SEL, 15, Y_SEL, 15);
+		}
+
+		//xy2rbcConfig
+		pMapCfg->xy2rbcConfig =
+			XY2CONFIG(0, 1, 1, 1, 1, 15, 15, 15, 15);
+		break;
+	case TILED_MIXED_V_MAP:
+		//cas
+		if (dramCfg->casBit == 9 && dramCfg->bankBit == 2 &&
+		    dramCfg->rasBit == 13) // CNN setting
+		{
+			pMapCfg->xy2caMap[0] = XY2(Y_SEL, 1, Y_SEL, 1);
+			pMapCfg->xy2caMap[1] = XY2(Y_SEL, 2, Y_SEL, 2);
+			pMapCfg->xy2caMap[2] = XY2(Y_SEL, 3, Y_SEL, 3);
+			pMapCfg->xy2caMap[3] = XY2(Y_SEL, 0, Y_SEL, 0);
+			pMapCfg->xy2caMap[4] = XY2(X_SEL, 3, X_SEL, 3);
+			pMapCfg->xy2caMap[5] = XY2(X_SEL, 4, X_SEL, 4);
+			pMapCfg->xy2caMap[6] = XY2(X_SEL, 5, X_SEL, 5);
+			pMapCfg->xy2caMap[7] = XY2(X_SEL, 6, X_SEL, 6);
+			pMapCfg->xy2caMap[8] = XY2(Y_SEL, 4, Y_SEL, 5);
+
+			pMapCfg->xy2baMap[0] =
+				XY2BANK(0, X_SEL, 7, 4, X_SEL, 7);
+			pMapCfg->xy2baMap[1] =
+				XY2BANK(0, Y_SEL, 5, 4, Y_SEL, 4);
+
+			pMapCfg->xy2raMap[0] = XY2(X_SEL, 8, X_SEL, 8);
+			pMapCfg->xy2raMap[1] = XY2(X_SEL, 9, X_SEL, 9);
+			pMapCfg->xy2raMap[2] = XY2(X_SEL, 10, X_SEL, 10);
+			pMapCfg->xy2raMap[3] = XY2(Y_SEL, 6, Y_SEL, 6);
+			pMapCfg->xy2raMap[4] = XY2(Y_SEL, 7, Y_SEL, 7);
+			pMapCfg->xy2raMap[5] = XY2(Y_SEL, 8, Y_SEL, 8);
+			pMapCfg->xy2raMap[6] = XY2(Y_SEL, 9, Y_SEL, 9);
+			pMapCfg->xy2raMap[7] = XY2(Y_SEL, 10, Y_SEL, 10);
+			pMapCfg->xy2raMap[8] = XY2(Y_SEL, 11, Y_SEL, 11);
+			pMapCfg->xy2raMap[9] = XY2(Y_SEL, 12, Y_SEL, 12);
+			pMapCfg->xy2raMap[10] = XY2(Y_SEL, 13, Y_SEL, 13);
+			pMapCfg->xy2raMap[11] = XY2(Y_SEL, 14, Y_SEL, 14);
+			pMapCfg->xy2raMap[12] = XY2(Y_SEL, 15, Y_SEL, 15);
+		} else if (dramCfg->casBit == 10 && dramCfg->bankBit == 3 &&
+			   dramCfg->rasBit == 13) {
+			//cas
+			pMapCfg->xy2caMap[0] = XY2(Z_SEL, 0, Z_SEL, 0);
+			pMapCfg->xy2caMap[1] = XY2(Y_SEL, 1, Y_SEL, 1);
+			pMapCfg->xy2caMap[2] = XY2(Y_SEL, 2, Y_SEL, 2);
+			pMapCfg->xy2caMap[3] = XY2(Y_SEL, 3, Y_SEL, 3);
+			pMapCfg->xy2caMap[4] = XY2(Y_SEL, 0, Y_SEL, 0);
+			pMapCfg->xy2caMap[5] = XY2(X_SEL, 3, X_SEL, 3);
+			pMapCfg->xy2caMap[6] = XY2(X_SEL, 4, X_SEL, 4);
+			pMapCfg->xy2caMap[7] = XY2(X_SEL, 5, X_SEL, 5);
+			pMapCfg->xy2caMap[8] = XY2(X_SEL, 6, X_SEL, 6);
+			pMapCfg->xy2caMap[9] = XY2(Y_SEL, 4, Y_SEL, 4);
+
+			//bank
+			pMapCfg->xy2baMap[0] =
+				XY2BANK(0, X_SEL, 7, 4, X_SEL, 7);
+			pMapCfg->xy2baMap[1] =
+				XY2BANK(0, X_SEL, 8, 4, X_SEL, 8);
+			pMapCfg->xy2baMap[2] =
+				XY2BANK(0, Y_SEL, 5, 4, Y_SEL, 5);
+			pMapCfg->xy2raMap[0] = XY2(X_SEL, 9, X_SEL, 9);
+			pMapCfg->xy2raMap[1] = XY2(X_SEL, 10, X_SEL, 10);
+			pMapCfg->xy2raMap[2] = XY2(Y_SEL, 6, Y_SEL, 6);
+			pMapCfg->xy2raMap[3] = XY2(Y_SEL, 7, Y_SEL, 7);
+			pMapCfg->xy2raMap[4] = XY2(Y_SEL, 8, Y_SEL, 8);
+			pMapCfg->xy2raMap[5] = XY2(Y_SEL, 9, Y_SEL, 9);
+			pMapCfg->xy2raMap[6] = XY2(Y_SEL, 10, Y_SEL, 10);
+			pMapCfg->xy2raMap[7] = XY2(Y_SEL, 11, Y_SEL, 11);
+			pMapCfg->xy2raMap[8] = XY2(Y_SEL, 12, Y_SEL, 12);
+			pMapCfg->xy2raMap[9] = XY2(Y_SEL, 13, Y_SEL, 13);
+			pMapCfg->xy2raMap[10] = XY2(Y_SEL, 14, Y_SEL, 14);
+			pMapCfg->xy2raMap[11] = XY2(Y_SEL, 15, Y_SEL, 15);
+		}
+
+		//xy2rbcConfig
+		pMapCfg->xy2rbcConfig = XY2CONFIG(0, 0, 1, 1, 1, 7, 7, 7, 7);
+		break;
+	case TILED_FRAME_MB_RASTER_MAP:
+		//cas
+		pMapCfg->xy2caMap[0] = XY2(Y_SEL, 0, Y_SEL, 0);
+		pMapCfg->xy2caMap[1] = XY2(Y_SEL, 1, Y_SEL, 1);
+		pMapCfg->xy2caMap[2] = XY2(Y_SEL, 2, Y_SEL, 2);
+		pMapCfg->xy2caMap[3] = XY2(Y_SEL, 3, X_SEL, 3);
+		pMapCfg->xy2caMap[4] = XY2(X_SEL, 3, 4, 0);
+
+		//xy2rbcConfig
+		pMapCfg->xy2rbcConfig = XY2CONFIG(0, 0, 0, 1, 1, 15, 0, 7, 0);
+		break;
+	case TILED_FIELD_MB_RASTER_MAP:
+		//cas
+		pMapCfg->xy2caMap[0] = XY2(Y_SEL, 0, Y_SEL, 0);
+		pMapCfg->xy2caMap[1] = XY2(Y_SEL, 1, Y_SEL, 1);
+		pMapCfg->xy2caMap[2] = XY2(Y_SEL, 2, X_SEL, 3);
+		pMapCfg->xy2caMap[3] = XY2(X_SEL, 3, 4, 0);
+
+		//xy2rbcConfig
+		pMapCfg->xy2rbcConfig = XY2CONFIG(0, 1, 1, 1, 1, 7, 7, 3, 3);
+		break;
+	default:
+		return 0;
+		break;
+	}
+
+	if (mapType == TILED_FRAME_MB_RASTER_MAP) {
+		pMapCfg->rbc2axiMap[0] = RBC(Z_SEL, 0, Z_SEL, 0);
+		pMapCfg->rbc2axiMap[1] = RBC(Z_SEL, 0, Z_SEL, 0);
+		pMapCfg->rbc2axiMap[2] = RBC(Z_SEL, 0, Z_SEL, 0);
+		pMapCfg->rbc2axiMap[3] = RBC(CA_SEL, 0, CA_SEL, 0);
+		pMapCfg->rbc2axiMap[4] = RBC(CA_SEL, 1, CA_SEL, 1);
+		pMapCfg->rbc2axiMap[5] = RBC(CA_SEL, 2, CA_SEL, 2);
+		pMapCfg->rbc2axiMap[6] = RBC(CA_SEL, 3, CA_SEL, 3);
+		pMapCfg->rbc2axiMap[7] = RBC(CA_SEL, 4, CA_SEL, 8);
+		pMapCfg->rbc2axiMap[8] = RBC(CA_SEL, 8, CA_SEL, 9);
+		pMapCfg->rbc2axiMap[9] = RBC(CA_SEL, 9, CA_SEL, 10);
+		pMapCfg->rbc2axiMap[10] = RBC(CA_SEL, 10, CA_SEL, 11);
+		pMapCfg->rbc2axiMap[11] = RBC(CA_SEL, 11, CA_SEL, 12);
+		pMapCfg->rbc2axiMap[12] = RBC(CA_SEL, 12, CA_SEL, 13);
+		pMapCfg->rbc2axiMap[13] = RBC(CA_SEL, 13, CA_SEL, 14);
+		pMapCfg->rbc2axiMap[14] = RBC(CA_SEL, 14, CA_SEL, 15);
+		pMapCfg->rbc2axiMap[15] = RBC(CA_SEL, 15, RA_SEL, 0);
+		pMapCfg->rbc2axiMap[16] = RBC(RA_SEL, 0, RA_SEL, 1);
+		pMapCfg->rbc2axiMap[17] = RBC(RA_SEL, 1, RA_SEL, 2);
+		pMapCfg->rbc2axiMap[18] = RBC(RA_SEL, 2, RA_SEL, 3);
+		pMapCfg->rbc2axiMap[19] = RBC(RA_SEL, 3, RA_SEL, 4);
+		pMapCfg->rbc2axiMap[20] = RBC(RA_SEL, 4, RA_SEL, 5);
+		pMapCfg->rbc2axiMap[21] = RBC(RA_SEL, 5, RA_SEL, 6);
+		pMapCfg->rbc2axiMap[22] = RBC(RA_SEL, 6, RA_SEL, 7);
+		pMapCfg->rbc2axiMap[23] = RBC(RA_SEL, 7, RA_SEL, 8);
+		pMapCfg->rbc2axiMap[24] = RBC(RA_SEL, 8, RA_SEL, 9);
+		pMapCfg->rbc2axiMap[25] = RBC(RA_SEL, 9, RA_SEL, 10);
+		pMapCfg->rbc2axiMap[26] = RBC(RA_SEL, 10, RA_SEL, 11);
+		pMapCfg->rbc2axiMap[27] = RBC(RA_SEL, 11, RA_SEL, 12);
+		pMapCfg->rbc2axiMap[28] = RBC(RA_SEL, 12, RA_SEL, 13);
+		pMapCfg->rbc2axiMap[29] = RBC(RA_SEL, 13, RA_SEL, 14);
+		pMapCfg->rbc2axiMap[30] = RBC(RA_SEL, 14, RA_SEL, 15);
+		pMapCfg->rbc2axiMap[31] = RBC(RA_SEL, 15, Z_SEL, 0);
+		ret = 1;
+	} else if (mapType == TILED_FIELD_MB_RASTER_MAP) {
+		pMapCfg->rbc2axiMap[0] = RBC(Z_SEL, 0, Z_SEL, 0);
+		pMapCfg->rbc2axiMap[1] = RBC(Z_SEL, 0, Z_SEL, 0);
+		pMapCfg->rbc2axiMap[2] = RBC(Z_SEL, 0, Z_SEL, 0);
+		pMapCfg->rbc2axiMap[3] = RBC(CA_SEL, 0, CA_SEL, 0);
+		pMapCfg->rbc2axiMap[4] = RBC(CA_SEL, 1, CA_SEL, 1);
+		pMapCfg->rbc2axiMap[5] = RBC(CA_SEL, 2, CA_SEL, 2);
+		pMapCfg->rbc2axiMap[6] = RBC(CA_SEL, 3, CA_SEL, 8);
+		pMapCfg->rbc2axiMap[7] = RBC(CA_SEL, 8, CA_SEL, 9);
+		pMapCfg->rbc2axiMap[8] = RBC(CA_SEL, 9, CA_SEL, 10);
+		pMapCfg->rbc2axiMap[9] = RBC(CA_SEL, 10, CA_SEL, 11);
+		pMapCfg->rbc2axiMap[10] = RBC(CA_SEL, 11, CA_SEL, 12);
+		pMapCfg->rbc2axiMap[11] = RBC(CA_SEL, 12, CA_SEL, 13);
+		pMapCfg->rbc2axiMap[12] = RBC(CA_SEL, 13, CA_SEL, 14);
+		pMapCfg->rbc2axiMap[13] = RBC(CA_SEL, 14, CA_SEL, 15);
+		pMapCfg->rbc2axiMap[14] = RBC(CA_SEL, 15, RA_SEL, 0);
+
+		pMapCfg->rbc2axiMap[15] = RBC(RA_SEL, 0, RA_SEL, 1);
+		pMapCfg->rbc2axiMap[16] = RBC(RA_SEL, 1, RA_SEL, 2);
+		pMapCfg->rbc2axiMap[17] = RBC(RA_SEL, 2, RA_SEL, 3);
+		pMapCfg->rbc2axiMap[18] = RBC(RA_SEL, 3, RA_SEL, 4);
+		pMapCfg->rbc2axiMap[19] = RBC(RA_SEL, 4, RA_SEL, 5);
+		pMapCfg->rbc2axiMap[20] = RBC(RA_SEL, 5, RA_SEL, 6);
+		pMapCfg->rbc2axiMap[21] = RBC(RA_SEL, 6, RA_SEL, 7);
+		pMapCfg->rbc2axiMap[22] = RBC(RA_SEL, 7, RA_SEL, 8);
+		pMapCfg->rbc2axiMap[23] = RBC(RA_SEL, 8, RA_SEL, 9);
+		pMapCfg->rbc2axiMap[24] = RBC(RA_SEL, 9, RA_SEL, 10);
+		pMapCfg->rbc2axiMap[25] = RBC(RA_SEL, 10, RA_SEL, 11);
+		pMapCfg->rbc2axiMap[26] = RBC(RA_SEL, 11, RA_SEL, 12);
+		pMapCfg->rbc2axiMap[27] = RBC(RA_SEL, 12, RA_SEL, 13);
+		pMapCfg->rbc2axiMap[28] = RBC(RA_SEL, 13, RA_SEL, 14);
+		pMapCfg->rbc2axiMap[29] = RBC(RA_SEL, 14, RA_SEL, 15);
+		pMapCfg->rbc2axiMap[30] = RBC(RA_SEL, 15, Z_SEL, 0);
+		pMapCfg->rbc2axiMap[31] = RBC(Z_SEL, 0, Z_SEL, 0);
+		ret = 1;
+	} else {
+		if (dramCfg->casBit == 9 && dramCfg->bankBit == 2 &&
+		    dramCfg->rasBit == 13) {
+			pMapCfg->rbc2axiMap[0] = RBC(Z_SEL, 0, Z_SEL, 0);
+			pMapCfg->rbc2axiMap[1] = RBC(Z_SEL, 0, Z_SEL, 0);
+			pMapCfg->rbc2axiMap[2] = RBC(Z_SEL, 0, Z_SEL, 0);
+			pMapCfg->rbc2axiMap[3] = RBC(CA_SEL, 0, CA_SEL, 0);
+			pMapCfg->rbc2axiMap[4] = RBC(CA_SEL, 1, CA_SEL, 1);
+			pMapCfg->rbc2axiMap[5] = RBC(CA_SEL, 2, CA_SEL, 2);
+			pMapCfg->rbc2axiMap[6] = RBC(CA_SEL, 3, CA_SEL, 3);
+			pMapCfg->rbc2axiMap[7] = RBC(CA_SEL, 4, CA_SEL, 4);
+			pMapCfg->rbc2axiMap[8] = RBC(CA_SEL, 5, CA_SEL, 5);
+			pMapCfg->rbc2axiMap[9] = RBC(CA_SEL, 6, CA_SEL, 6);
+			pMapCfg->rbc2axiMap[10] = RBC(CA_SEL, 7, CA_SEL, 7);
+			pMapCfg->rbc2axiMap[11] = RBC(CA_SEL, 8, CA_SEL, 8);
+
+			pMapCfg->rbc2axiMap[12] = RBC(BA_SEL, 0, BA_SEL, 0);
+			pMapCfg->rbc2axiMap[13] = RBC(BA_SEL, 1, BA_SEL, 1);
+
+			pMapCfg->rbc2axiMap[14] = RBC(RA_SEL, 0, RA_SEL, 0);
+			pMapCfg->rbc2axiMap[15] = RBC(RA_SEL, 1, RA_SEL, 1);
+			pMapCfg->rbc2axiMap[16] = RBC(RA_SEL, 2, RA_SEL, 2);
+			pMapCfg->rbc2axiMap[17] = RBC(RA_SEL, 3, RA_SEL, 3);
+			pMapCfg->rbc2axiMap[18] = RBC(RA_SEL, 4, RA_SEL, 4);
+			pMapCfg->rbc2axiMap[19] = RBC(RA_SEL, 5, RA_SEL, 5);
+			pMapCfg->rbc2axiMap[20] = RBC(RA_SEL, 6, RA_SEL, 6);
+			pMapCfg->rbc2axiMap[21] = RBC(RA_SEL, 7, RA_SEL, 7);
+			pMapCfg->rbc2axiMap[22] = RBC(RA_SEL, 8, RA_SEL, 8);
+			pMapCfg->rbc2axiMap[23] = RBC(RA_SEL, 9, RA_SEL, 9);
+			pMapCfg->rbc2axiMap[24] = RBC(RA_SEL, 10, RA_SEL, 10);
+			pMapCfg->rbc2axiMap[25] = RBC(RA_SEL, 11, RA_SEL, 11);
+			pMapCfg->rbc2axiMap[26] = RBC(RA_SEL, 12, RA_SEL, 12);
+			pMapCfg->rbc2axiMap[27] = RBC(RA_SEL, 13, RA_SEL, 13);
+			pMapCfg->rbc2axiMap[28] = RBC(RA_SEL, 14, RA_SEL, 14);
+			pMapCfg->rbc2axiMap[29] = RBC(RA_SEL, 15, RA_SEL, 15);
+			pMapCfg->rbc2axiMap[30] = RBC(Z_SEL, 0, Z_SEL, 0);
+			pMapCfg->rbc2axiMap[31] = RBC(Z_SEL, 0, Z_SEL, 0);
+
+			ret = 1;
+		} else if (dramCfg->casBit == 10 && dramCfg->bankBit == 3 &&
+			   dramCfg->rasBit == 13) {
+			pMapCfg->rbc2axiMap[0] = RBC(Z_SEL, 0, Z_SEL, 0);
+			pMapCfg->rbc2axiMap[1] = RBC(Z_SEL, 0, Z_SEL, 0);
+			pMapCfg->rbc2axiMap[2] = RBC(CA_SEL, 0, CA_SEL, 0);
+			pMapCfg->rbc2axiMap[3] = RBC(CA_SEL, 1, CA_SEL, 1);
+			pMapCfg->rbc2axiMap[4] = RBC(CA_SEL, 2, CA_SEL, 2);
+			pMapCfg->rbc2axiMap[5] = RBC(CA_SEL, 3, CA_SEL, 3);
+			pMapCfg->rbc2axiMap[6] = RBC(CA_SEL, 4, CA_SEL, 4);
+			pMapCfg->rbc2axiMap[7] = RBC(CA_SEL, 5, CA_SEL, 5);
+			pMapCfg->rbc2axiMap[8] = RBC(CA_SEL, 6, CA_SEL, 6);
+			pMapCfg->rbc2axiMap[9] = RBC(CA_SEL, 7, CA_SEL, 7);
+			pMapCfg->rbc2axiMap[10] = RBC(CA_SEL, 8, CA_SEL, 8);
+			pMapCfg->rbc2axiMap[11] = RBC(CA_SEL, 9, CA_SEL, 9);
+
+			pMapCfg->rbc2axiMap[12] = RBC(BA_SEL, 0, BA_SEL, 0);
+			pMapCfg->rbc2axiMap[13] = RBC(BA_SEL, 1, BA_SEL, 1);
+			pMapCfg->rbc2axiMap[14] = RBC(BA_SEL, 2, BA_SEL, 2);
+
+			pMapCfg->rbc2axiMap[15] = RBC(RA_SEL, 0, RA_SEL, 0);
+			pMapCfg->rbc2axiMap[16] = RBC(RA_SEL, 1, RA_SEL, 1);
+			pMapCfg->rbc2axiMap[17] = RBC(RA_SEL, 2, RA_SEL, 2);
+			pMapCfg->rbc2axiMap[18] = RBC(RA_SEL, 3, RA_SEL, 3);
+			pMapCfg->rbc2axiMap[19] = RBC(RA_SEL, 4, RA_SEL, 4);
+			pMapCfg->rbc2axiMap[20] = RBC(RA_SEL, 5, RA_SEL, 5);
+			pMapCfg->rbc2axiMap[21] = RBC(RA_SEL, 6, RA_SEL, 6);
+			pMapCfg->rbc2axiMap[22] = RBC(RA_SEL, 7, RA_SEL, 7);
+			pMapCfg->rbc2axiMap[23] = RBC(RA_SEL, 8, RA_SEL, 8);
+			pMapCfg->rbc2axiMap[24] = RBC(RA_SEL, 9, RA_SEL, 9);
+			pMapCfg->rbc2axiMap[25] = RBC(RA_SEL, 10, RA_SEL, 10);
+			pMapCfg->rbc2axiMap[26] = RBC(RA_SEL, 11, RA_SEL, 11);
+			pMapCfg->rbc2axiMap[27] = RBC(RA_SEL, 12, RA_SEL, 12);
+			pMapCfg->rbc2axiMap[28] = RBC(Z_SEL, 0, Z_SEL, 0);
+			pMapCfg->rbc2axiMap[29] = RBC(Z_SEL, 0, Z_SEL, 0);
+			pMapCfg->rbc2axiMap[30] = RBC(Z_SEL, 0, Z_SEL, 0);
+			pMapCfg->rbc2axiMap[31] = RBC(Z_SEL, 0, Z_SEL, 0);
+
+			ret = 1;
+		}
+	}
+
+	for (i = 0; i < 16; i++) { //xy2ca_map
+		VpuWriteReg(coreIdx, GDI_XY2_CAS_0 + 4 * i,
+			    pMapCfg->xy2caMap[i]);
+	}
+
+	for (i = 0; i < 4; i++) { //xy2baMap
+		VpuWriteReg(coreIdx, GDI_XY2_BA_0 + 4 * i,
+			    pMapCfg->xy2baMap[i]);
+	}
+
+	for (i = 0; i < 16; i++) { //xy2raMap
+		VpuWriteReg(coreIdx, GDI_XY2_RAS_0 + 4 * i,
+			    pMapCfg->xy2raMap[i]);
+	}
+
+	//xy2rbcConfig
+	VpuWriteReg(coreIdx, GDI_XY2_RBC_CONFIG, pMapCfg->xy2rbcConfig);
+	//// fast access for reading
+	pMapCfg->tbSeparateMap = (pMapCfg->xy2rbcConfig >> 19) & 0x1;
+	pMapCfg->topBotSplit = (pMapCfg->xy2rbcConfig >> 18) & 0x1;
+	pMapCfg->tiledMap = (pMapCfg->xy2rbcConfig >> 17) & 0x1;
+
+	// RAS, BA, CAS -> Axi Addr
+	for (i = 0; i < 32; i++) {
+		VpuWriteReg(coreIdx, GDI_RBC2_AXI_0 + 4 * i,
+			    pMapCfg->rbc2axiMap[i]);
+	}
+
+	return ret;
+}
+
+static int GetXY2RBCLogic(int map_val, int xpos, int ypos, int tb)
+{
+	int invert;
+	int assign_zero;
+	int tbxor;
+	int xysel;
+	int bitsel;
+
+	int xypos, xybit, xybit_st1, xybit_st2, xybit_st3;
+
+	invert = map_val >> 7;
+	assign_zero = (map_val & 0x78) >> 6;
+	tbxor = (map_val & 0x3C) >> 5;
+	xysel = (map_val & 0x1E) >> 4;
+	bitsel = map_val & 0x0f;
+
+	xypos = (xysel) ? ypos : xpos;
+	xybit = (xypos >> bitsel) & 0x01;
+	xybit_st1 = (tbxor) ? xybit ^ tb : xybit;
+	xybit_st2 = (assign_zero) ? 0 : xybit_st1;
+	xybit_st3 = (invert) ? !xybit_st2 : xybit_st2;
+
+	return xybit_st3;
+}
+
+static int GetRBC2AXILogic(int map_val, int ra_in, int ba_in, int ca_in)
+{
+	int rbc;
+	int rst_bit;
+	int rbc_sel = map_val >> 4;
+	int bit_sel = map_val & 0x0f;
+
+	if (rbc_sel == 0)
+		rbc = ca_in;
+	else if (rbc_sel == 1)
+		rbc = ba_in;
+	else if (rbc_sel == 2)
+		rbc = ra_in;
+	else
+		rbc = 0;
+
+	rst_bit = ((rbc >> bit_sel) & 1);
+
+	return rst_bit;
+}
+
+static int GetXY2AXIAddrV10(TiledMapConfig *pMapCfg, int ycbcr, int posY,
+			    int posX, int stride, FrameBuffer *fb)
+{
+	int ypos_mod;
+	int temp;
+	int temp_bit;
+	int i;
+	int tb;
+	int ra_base;
+	int ras_base;
+	int ra_conv, ba_conv, ca_conv;
+
+	int pix_addr;
+
+	int lum_top_base, chr_top_base;
+	int lum_bot_base, chr_bot_base;
+
+	int mbx, mby, mb_addr;
+	int temp_val12bit, temp_val6bit;
+	int Addr;
+	int mb_raster_base;
+
+	if (!pMapCfg)
+		return -1;
+
+	pix_addr = 0;
+	mb_raster_base = 0;
+	ra_conv = 0;
+	ba_conv = 0;
+	ca_conv = 0;
+
+	tb = posY & 0x1;
+
+	ypos_mod = pMapCfg->tbSeparateMap ? posY >> 1 : posY;
+
+	Addr = ycbcr == 0 ? fb->bufY : ycbcr == 2 ? fb->bufCb : fb->bufCr;
+
+	if (fb->mapType == LINEAR_FRAME_MAP)
+		return ((posY * stride) + posX) + Addr;
+
+	// 20bit = AddrY [31:12]
+	lum_top_base = fb->bufY >> 12;
+
+	// 20bit = AddrY [11: 0], AddrCb[31:24]
+	chr_top_base = ((fb->bufY & 0xfff) << 8) |
+		       ((fb->bufCb >> 24) & 0xff); //12bit +  (32-24) bit
+
+	// 20bit = AddrCb[23: 4]
+	lum_bot_base = (fb->bufCb >> 4) & 0xfffff;
+
+	// 20bit = AddrCb[ 3: 0], AddrCr[31:16]
+	chr_bot_base = ((fb->bufCb & 0xf) << 16) | ((fb->bufCr >> 16) & 0xffff);
+
+	if (fb->mapType == TILED_FRAME_MB_RASTER_MAP ||
+	    fb->mapType == TILED_FIELD_MB_RASTER_MAP) {
+		if (ycbcr == 0) {
+			mbx = posX / 16;
+			mby = posY / 16;
+		} else //always interleave
+		{
+			mbx = posX / 16;
+			mby = posY / 8;
+		}
+
+		mb_addr = (stride / 16) * mby + mbx;
+
+		// ca[7:0]
+		for (i = 0; i < 8; i++) {
+			if (ycbcr == 2 || ycbcr == 3)
+				temp = pMapCfg->xy2caMap[i] & 0xff;
+			else
+				temp = pMapCfg->xy2caMap[i] >> 8;
+			temp_bit = GetXY2RBCLogic(temp, posX, ypos_mod, tb);
+			ca_conv = ca_conv + (temp_bit << i);
+		}
+
+		// ca[15:8]
+		ca_conv = ca_conv + ((mb_addr & 0xff) << 8);
+
+		// ra[15:0]
+		ra_conv = mb_addr >> 8;
+
+		// ra,ba,ca -> axi
+		for (i = 0; i < 32; i++) {
+			temp_val12bit = pMapCfg->rbc2axiMap[i];
+			temp_val6bit = (ycbcr == 0) ? (temp_val12bit >> 6) :
+						      (temp_val12bit & 0x3f);
+
+			temp_bit = GetRBC2AXILogic(temp_val6bit, ra_conv,
+						   ba_conv, ca_conv);
+
+			pix_addr = pix_addr + (temp_bit << i);
+		}
+
+		if (pMapCfg->tbSeparateMap == 1 && tb == 1)
+			mb_raster_base =
+				ycbcr == 0 ? lum_bot_base : chr_bot_base;
+		else
+			mb_raster_base =
+				ycbcr == 0 ? lum_top_base : chr_top_base;
+
+		pix_addr = pix_addr + (mb_raster_base << 12);
+	} else {
+		// ca
+		for (i = 0; i < 16; i++) {
+			if (ycbcr == 0 ||
+			    ycbcr == 1) // clair : there are no case ycbcr = 1
+				temp = pMapCfg->xy2caMap[i] >> 8;
+			else
+				temp = pMapCfg->xy2caMap[i] & 0xff;
+
+			temp_bit = GetXY2RBCLogic(temp, posX, ypos_mod, tb);
+			ca_conv = ca_conv + (temp_bit << i);
+		}
+
+		// ba
+		for (i = 0; i < 4; i++) {
+			if (ycbcr == 2 || ycbcr == 3)
+				temp = pMapCfg->xy2baMap[i] & 0xff;
+			else
+				temp = pMapCfg->xy2baMap[i] >> 8;
+
+			temp_bit = GetXY2RBCLogic(temp, posX, ypos_mod, tb);
+			ba_conv = ba_conv + (temp_bit << i);
+		}
+
+		// ras
+		for (i = 0; i < 16; i++) {
+			if (ycbcr == 2 || ycbcr == 3)
+				temp = pMapCfg->xy2raMap[i] & 0xff;
+			else
+				temp = pMapCfg->xy2raMap[i] >> 8;
+
+			temp_bit = GetXY2RBCLogic(temp, posX, ypos_mod, tb);
+			ra_conv = ra_conv + (temp_bit << i);
+		}
+
+		if (pMapCfg->tbSeparateMap == 1 && tb == 1)
+			ras_base = Addr >> 16;
+		else
+			ras_base = Addr & 0xffff;
+
+		ra_base = ra_conv + ras_base;
+		pix_addr = 0;
+
+		// ra,ba,ca -> axi
+		for (i = 0; i < 32; i++) {
+			temp_val12bit = pMapCfg->rbc2axiMap[i];
+			temp_val6bit = (ycbcr == 0) ? (temp_val12bit >> 6) :
+						      (temp_val12bit & 0x3f);
+
+			temp_bit = GetRBC2AXILogic(temp_val6bit, ra_base,
+						   ba_conv, ca_conv);
+
+			pix_addr = pix_addr + (temp_bit << i);
+		}
+		pix_addr += pMapCfg->tiledBaseAddr;
+	}
+
+	return pix_addr;
+}
+
+int GetXY2AXIAddr(TiledMapConfig *pMapCfg, int ycbcr, int posY, int posX,
+		  int stride, FrameBuffer *fb)
+{
+	if (pMapCfg->productId == PRODUCT_ID_980 ||
+	    PRODUCT_ID_W_SERIES(pMapCfg->productId))
+		return GetXY2AXIAddr20(pMapCfg, ycbcr, posY, posX, stride, fb);
+	else if (pMapCfg->productId == PRODUCT_ID_960)
+		return GetXY2AXIAddrV10(pMapCfg, ycbcr, posY, posX, stride, fb);
+
+	return 0;
+}
+
+int SetTiledMapType(Uint32 coreIdx, TiledMapConfig *pMapCfg, int mapType,
+		    int stride, int interleave, DRAMConfig *pDramCfg)
+{
+	int ret;
+
+	switch (pMapCfg->productId) {
+	case PRODUCT_ID_980:
+		ret = SetTiledMapTypeV20(coreIdx, pMapCfg, mapType, stride,
+					 interleave);
+		break;
+	case PRODUCT_ID_960:
+		ret = SetTiledMapTypeV10(coreIdx, pMapCfg, pDramCfg, stride,
+					 mapType);
+		break;
+	case PRODUCT_ID_420L:
+		ret = 1;
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+	return ret;
+}
+
+Int32 CalcStride(Uint32 width, Uint32 height, FrameBufferFormat format,
+		 BOOL cbcrInterleave, TiledMapType mapType, BOOL isVP9)
+{
+	Uint32 lumaStride = 0;
+	Uint32 chromaStride = 0;
+
+	lumaStride = VPU_ALIGN32(width);
+
+	if (height > width) {
+		if ((mapType >= TILED_FRAME_V_MAP &&
+		     mapType <= TILED_MIXED_V_MAP) ||
+		    mapType == TILED_FRAME_NO_BANK_MAP ||
+		    mapType == TILED_FIELD_NO_BANK_MAP)
+			width = VPU_ALIGN16(height); // TiledMap constraints
+	}
+
+	if (mapType == LINEAR_FRAME_MAP || mapType == LINEAR_FIELD_MAP) {
+		Uint32 twice = 0;
+
+		twice = cbcrInterleave == TRUE ? 2 : 1;
+		switch (format) {
+		case FORMAT_420:
+			/* nothing to do */
+			break;
+		case FORMAT_420_P10_16BIT_LSB:
+		case FORMAT_420_P10_16BIT_MSB:
+		case FORMAT_422_P10_16BIT_MSB:
+		case FORMAT_422_P10_16BIT_LSB:
+			lumaStride = VPU_ALIGN32(width) * 2;
+			break;
+		case FORMAT_420_P10_32BIT_LSB:
+		case FORMAT_420_P10_32BIT_MSB:
+		case FORMAT_422_P10_32BIT_MSB:
+		case FORMAT_422_P10_32BIT_LSB:
+			if (isVP9 == TRUE) {
+				lumaStride =
+					VPU_ALIGN32(((width + 11) / 12) * 16);
+				chromaStride =
+					(((width / 2) + 11) * twice / 12) * 16;
+			} else {
+				width = VPU_ALIGN32(width);
+				lumaStride =
+					((VPU_ALIGN16(width) + 11) / 12) * 16;
+				chromaStride = ((VPU_ALIGN16(width / 2) + 11) *
+						twice / 12) *
+					       16;
+				//if ( isWAVE410 == TRUE ) {
+				if ((chromaStride * 2) > lumaStride) {
+					lumaStride = chromaStride * 2;
+					VLOG(ERR,
+					     "double chromaStride size is bigger than lumaStride\n");
+				}
+				//}
+			}
+			if (cbcrInterleave == TRUE) {
+				lumaStride = MAX(lumaStride, chromaStride);
+			}
+			break;
+		case FORMAT_422:
+			/* nothing to do */
+			break;
+		case FORMAT_YUYV: // 4:2:2 8bit packed
+		case FORMAT_YVYU:
+		case FORMAT_UYVY:
+		case FORMAT_VYUY:
+			lumaStride = VPU_ALIGN32(width) * 2;
+			break;
+		case FORMAT_YUYV_P10_16BIT_MSB: // 4:2:2 10bit packed
+		case FORMAT_YUYV_P10_16BIT_LSB:
+		case FORMAT_YVYU_P10_16BIT_MSB:
+		case FORMAT_YVYU_P10_16BIT_LSB:
+		case FORMAT_UYVY_P10_16BIT_MSB:
+		case FORMAT_UYVY_P10_16BIT_LSB:
+		case FORMAT_VYUY_P10_16BIT_MSB:
+		case FORMAT_VYUY_P10_16BIT_LSB:
+			lumaStride = VPU_ALIGN32(width) * 4;
+			break;
+		case FORMAT_YUYV_P10_32BIT_MSB:
+		case FORMAT_YUYV_P10_32BIT_LSB:
+		case FORMAT_YVYU_P10_32BIT_MSB:
+		case FORMAT_YVYU_P10_32BIT_LSB:
+		case FORMAT_UYVY_P10_32BIT_MSB:
+		case FORMAT_UYVY_P10_32BIT_LSB:
+		case FORMAT_VYUY_P10_32BIT_MSB:
+		case FORMAT_VYUY_P10_32BIT_LSB:
+			lumaStride = VPU_ALIGN32(width * 2) * 2;
+			break;
+		default:
+			break;
+		}
+	} else if (mapType == COMPRESSED_FRAME_MAP) {
+		switch (format) {
+		case FORMAT_420:
+		case FORMAT_422:
+		case FORMAT_YUYV:
+		case FORMAT_YVYU:
+		case FORMAT_UYVY:
+		case FORMAT_VYUY:
+			break;
+		case FORMAT_420_P10_16BIT_LSB:
+		case FORMAT_420_P10_16BIT_MSB:
+		case FORMAT_420_P10_32BIT_LSB:
+		case FORMAT_420_P10_32BIT_MSB:
+		case FORMAT_422_P10_16BIT_MSB:
+		case FORMAT_422_P10_16BIT_LSB:
+		case FORMAT_422_P10_32BIT_MSB:
+		case FORMAT_422_P10_32BIT_LSB:
+		case FORMAT_YUYV_P10_16BIT_MSB:
+		case FORMAT_YUYV_P10_16BIT_LSB:
+		case FORMAT_YVYU_P10_16BIT_MSB:
+		case FORMAT_YVYU_P10_16BIT_LSB:
+		case FORMAT_YVYU_P10_32BIT_MSB:
+		case FORMAT_YVYU_P10_32BIT_LSB:
+		case FORMAT_UYVY_P10_16BIT_MSB:
+		case FORMAT_UYVY_P10_16BIT_LSB:
+		case FORMAT_VYUY_P10_16BIT_MSB:
+		case FORMAT_VYUY_P10_16BIT_LSB:
+		case FORMAT_YUYV_P10_32BIT_MSB:
+		case FORMAT_YUYV_P10_32BIT_LSB:
+		case FORMAT_UYVY_P10_32BIT_MSB:
+		case FORMAT_UYVY_P10_32BIT_LSB:
+		case FORMAT_VYUY_P10_32BIT_MSB:
+		case FORMAT_VYUY_P10_32BIT_LSB:
+			lumaStride = VPU_ALIGN32(VPU_ALIGN16(width) * 5) / 4;
+			lumaStride = VPU_ALIGN32(lumaStride);
+			break;
+		default:
+			return -1;
+		}
+	} else if (mapType == ARM_COMPRESSED_FRAME_MAP) {
+		switch (format) {
+		case FORMAT_420_ARM:
+			lumaStride = VPU_ALIGN32(width);
+			break;
+		case FORMAT_420_P10_16BIT_LSB_ARM:
+			lumaStride = VPU_ALIGN32(width) * 2;
+			break;
+		default:
+			return -1;
+		}
+	} else if (mapType == TILED_FRAME_NO_BANK_MAP ||
+		   mapType == TILED_FIELD_NO_BANK_MAP) {
+		lumaStride = (width > 4096) ? 8192 :
+					      (width > 2048) ?
+					      4096 :
+					      (width > 1024) ?
+					      2048 :
+					      (width > 512) ? 1024 : 512;
+	} else if (mapType == TILED_FRAME_MB_RASTER_MAP ||
+		   mapType == TILED_FIELD_MB_RASTER_MAP) {
+		lumaStride = VPU_ALIGN32(width);
+	} else {
+		width = (width < height) ? height : width;
+
+		lumaStride = (width > 4096) ? 8192 :
+					      (width > 2048) ?
+					      4096 :
+					      (width > 1024) ?
+					      2048 :
+					      (width > 512) ? 1024 : 512;
+	}
+
+	return lumaStride;
+}
+
+int LevelCalculation(int MbNumX, int MbNumY, int frameRateInfo,
+		     int interlaceFlag, int BitRate, int SliceNum)
+{
+	int mbps;
+	int frameRateDiv, frameRateRes, frameRate;
+	int mbPicNum = (MbNumX * MbNumY);
+	int mbFrmNum;
+	int MaxSliceNum;
+
+	int LevelIdc = 0;
+	int i, maxMbs;
+
+	if (interlaceFlag) {
+		mbFrmNum = mbPicNum * 2;
+		MbNumY *= 2;
+	} else
+		mbFrmNum = mbPicNum;
+
+	frameRateDiv = (frameRateInfo >> 16) + 1;
+	frameRateRes = frameRateInfo & 0xFFFF;
+	frameRate = math_div(frameRateRes, frameRateDiv);
+	mbps = mbFrmNum * frameRate;
+
+	for (i = 0; i < MAX_LAVEL_IDX; i++) {
+		maxMbs = g_anLevelMaxMbs[i];
+		if (mbps <= g_anLevelMaxMBPS[i] &&
+		    mbFrmNum <= g_anLevelMaxFS[i] && MbNumX <= maxMbs &&
+		    MbNumY <= maxMbs && BitRate <= g_anLevelMaxBR[i]) {
+			LevelIdc = g_anLevel[i];
+			break;
+		}
+	}
+
+	if (i == MAX_LAVEL_IDX)
+		i = MAX_LAVEL_IDX - 1;
+
+	if (SliceNum) {
+		SliceNum = math_div(mbPicNum, SliceNum);
+
+		if (g_anLevelSliceRate[i]) {
+			MaxSliceNum = math_div(
+				MAX(mbPicNum,
+				    g_anLevelMaxMBPS[i] /
+					    (172 / (1 + interlaceFlag))),
+				g_anLevelSliceRate[i]);
+
+			if (SliceNum > MaxSliceNum)
+				return -1;
+		}
+	}
+
+	return LevelIdc;
+}
+
+Int32 CalcLumaSize(Int32 productId, Int32 stride, Int32 height,
+		   FrameBufferFormat format, BOOL cbcrIntl,
+		   TiledMapType mapType, DRAMConfig *pDramCfg)
+{
+	Int32 unit_size_hor_lum, unit_size_ver_lum, size_dpb_lum, field_map,
+		size_dpb_lum_4k;
+	UNREFERENCED_PARAMETER(cbcrIntl);
+
+	if (mapType == TILED_FIELD_V_MAP ||
+	    mapType == TILED_FIELD_NO_BANK_MAP || mapType == LINEAR_FIELD_MAP) {
+		field_map = 1;
+	} else {
+		field_map = 0;
+	}
+
+	if (mapType == LINEAR_FRAME_MAP || mapType == LINEAR_FIELD_MAP) {
+		size_dpb_lum = stride * height;
+	} else if (mapType == COMPRESSED_FRAME_MAP) {
+		size_dpb_lum = stride * height;
+	} else if (mapType == ARM_COMPRESSED_FRAME_MAP) {
+		Uint32 mbw, mbh, header_size, uncomp_b16_size;
+
+		mbw = VPU_ALIGN16(stride) >> 4;
+		mbh = VPU_ALIGN16(height + 4) >> 4;
+		header_size = VPU_ALIGN128(16 * mbw * mbh);
+		uncomp_b16_size = (format == FORMAT_420_ARM) ? 384 : 512;
+
+		size_dpb_lum = header_size + (uncomp_b16_size * mbw * mbh);
+	} else if (mapType == TILED_FRAME_NO_BANK_MAP ||
+		   mapType == TILED_FIELD_NO_BANK_MAP) {
+		unit_size_hor_lum = stride;
+		unit_size_ver_lum =
+			(((height >> field_map) + 127) / 128) *
+			128; // unit vertical size is 128 pixel (8MB)
+		size_dpb_lum =
+			unit_size_hor_lum * (unit_size_ver_lum << field_map);
+	} else if (mapType == TILED_FRAME_MB_RASTER_MAP ||
+		   mapType == TILED_FIELD_MB_RASTER_MAP) {
+		if (productId == PRODUCT_ID_960) {
+			size_dpb_lum = stride * height;
+
+			// aligned to 8192*2 (0x4000) for top/bot field
+			// use upper 20bit address only
+			size_dpb_lum_4k =
+				((size_dpb_lum + 16383) / 16384) * 16384;
+
+			if (mapType == TILED_FIELD_MB_RASTER_MAP) {
+				size_dpb_lum_4k =
+					((size_dpb_lum_4k + (0x8000 - 1)) &
+					 ~(0x8000 - 1));
+			}
+
+			size_dpb_lum = size_dpb_lum_4k;
+		} else {
+			size_dpb_lum = stride * (height >> field_map);
+			size_dpb_lum_4k =
+				((size_dpb_lum + (16384 - 1)) / 16384) * 16384;
+			size_dpb_lum = size_dpb_lum_4k << field_map;
+		}
+	} else {
+		if (productId == PRODUCT_ID_960) {
+			Int32 VerSizePerRas, Ras1DBit;
+			Int32 ChrSizeYField;
+			Int32 ChrFieldRasSize, ChrFrameRasSize, LumFieldRasSize,
+				LumFrameRasSize;
+
+			ChrSizeYField = ((height / 2) + 1) >> 1;
+
+			if (mapType == TILED_FRAME_V_MAP) {
+				if (pDramCfg->casBit == 9 &&
+				    pDramCfg->bankBit == 2 &&
+				    pDramCfg->rasBit == 13) { // CNN setting
+					VerSizePerRas = 64;
+					Ras1DBit = 3;
+				} else if (pDramCfg->casBit == 10 &&
+					   pDramCfg->bankBit == 3 &&
+					   pDramCfg->rasBit == 13) {
+					VerSizePerRas = 64;
+					Ras1DBit = 2;
+				} else
+					return 0;
+
+			} else if (mapType == TILED_FRAME_H_MAP) {
+				if (pDramCfg->casBit == 9 &&
+				    pDramCfg->bankBit == 2 &&
+				    pDramCfg->rasBit == 13) { // CNN setting
+					VerSizePerRas = 64;
+					Ras1DBit = 3;
+				} else if (pDramCfg->casBit == 10 &&
+					   pDramCfg->bankBit == 3 &&
+					   pDramCfg->rasBit == 13) {
+					VerSizePerRas = 64;
+					Ras1DBit = 2;
+				} else
+					return 0;
+
+			} else if (mapType == TILED_FIELD_V_MAP) {
+				if (pDramCfg->casBit == 9 &&
+				    pDramCfg->bankBit == 2 &&
+				    pDramCfg->rasBit == 13) { // CNN setting
+					VerSizePerRas = 64;
+					Ras1DBit = 3;
+				} else if (pDramCfg->casBit == 10 &&
+					   pDramCfg->bankBit == 3 &&
+					   pDramCfg->rasBit == 13) {
+					VerSizePerRas = 64;
+					Ras1DBit = 2;
+				} else
+					return 0;
+			} else { // TILED_FIELD_H_MAP
+				if (pDramCfg->casBit == 9 &&
+				    pDramCfg->bankBit == 2 &&
+				    pDramCfg->rasBit == 13) { // CNN setting
+					VerSizePerRas = 64;
+					Ras1DBit = 3;
+				} else if (pDramCfg->casBit == 10 &&
+					   pDramCfg->bankBit == 3 &&
+					   pDramCfg->rasBit == 13) {
+					VerSizePerRas = 64;
+					Ras1DBit = 2;
+				} else
+					return 0;
+			}
+			ChrFieldRasSize =
+				((ChrSizeYField + (VerSizePerRas - 1)) /
+				 VerSizePerRas)
+				<< Ras1DBit;
+			ChrFrameRasSize = ChrFieldRasSize * 2;
+			LumFieldRasSize = ChrFrameRasSize;
+			LumFrameRasSize = LumFieldRasSize * 2;
+			size_dpb_lum = LumFrameRasSize
+				       << (pDramCfg->bankBit +
+					   pDramCfg->casBit + pDramCfg->busBit);
+		} else { // productId != 960
+			unit_size_hor_lum = stride;
+			unit_size_ver_lum =
+				(((height >> field_map) + 63) / 64) *
+				64; // unit vertical size is 64 pixel (4MB)
+			size_dpb_lum = unit_size_hor_lum *
+				       (unit_size_ver_lum << field_map);
+		}
+	}
+
+	return size_dpb_lum;
+}
+
+Int32 CalcChromaSize(Int32 productId, Int32 stride, Int32 height,
+		     FrameBufferFormat format, BOOL cbcrIntl,
+		     TiledMapType mapType, DRAMConfig *pDramCfg)
+{
+	Int32 chr_size_y, chr_size_x;
+	Int32 chr_vscale, chr_hscale;
+	Int32 unit_size_hor_chr, unit_size_ver_chr;
+	Int32 size_dpb_chr, size_dpb_chr_4k;
+	Int32 field_map;
+
+	unit_size_hor_chr = 0;
+	unit_size_ver_chr = 0;
+
+	chr_hscale = 1;
+	chr_vscale = 1;
+
+	switch (format) {
+	case FORMAT_420_P10_16BIT_LSB:
+	case FORMAT_420_P10_16BIT_MSB:
+	case FORMAT_420_P10_32BIT_LSB:
+	case FORMAT_420_P10_32BIT_MSB:
+	case FORMAT_420:
+		chr_hscale = 2;
+		chr_vscale = 2;
+		break;
+	case FORMAT_224:
+		chr_vscale = 2;
+		break;
+	case FORMAT_422:
+	case FORMAT_422_P10_16BIT_LSB:
+	case FORMAT_422_P10_16BIT_MSB:
+	case FORMAT_422_P10_32BIT_LSB:
+	case FORMAT_422_P10_32BIT_MSB:
+		chr_hscale = 2;
+		break;
+	case FORMAT_444:
+	case FORMAT_400:
+#ifdef SUPPORT_PACKED_STREAM_FORMAT
+	case FORMAT_YUYV:
+	case FORMAT_YVYU:
+	case FORMAT_UYVY:
+	case FORMAT_VYUY:
+	case FORMAT_YUYV_P10_16BIT_MSB: // 4:2:2 10bit packed
+	case FORMAT_YUYV_P10_16BIT_LSB:
+	case FORMAT_YVYU_P10_16BIT_MSB:
+	case FORMAT_YVYU_P10_16BIT_LSB:
+	case FORMAT_UYVY_P10_16BIT_MSB:
+	case FORMAT_UYVY_P10_16BIT_LSB:
+	case FORMAT_VYUY_P10_16BIT_MSB:
+	case FORMAT_VYUY_P10_16BIT_LSB:
+	case FORMAT_YUYV_P10_32BIT_MSB:
+	case FORMAT_YUYV_P10_32BIT_LSB:
+	case FORMAT_YVYU_P10_32BIT_MSB:
+	case FORMAT_YVYU_P10_32BIT_LSB:
+	case FORMAT_UYVY_P10_32BIT_MSB:
+	case FORMAT_UYVY_P10_32BIT_LSB:
+	case FORMAT_VYUY_P10_32BIT_MSB:
+	case FORMAT_VYUY_P10_32BIT_LSB:
+		break;
+#endif
+	default:
+		return 0;
+	}
+
+	if (mapType == TILED_FIELD_V_MAP ||
+	    mapType == TILED_FIELD_NO_BANK_MAP || mapType == LINEAR_FIELD_MAP) {
+		field_map = 1;
+	} else {
+		field_map = 0;
+	}
+
+	if (mapType == LINEAR_FRAME_MAP || mapType == LINEAR_FIELD_MAP) {
+		switch (format) {
+		case FORMAT_420:
+			unit_size_hor_chr = stride / 2;
+			unit_size_ver_chr = height / 2;
+			break;
+		case FORMAT_420_P10_16BIT_LSB:
+		case FORMAT_420_P10_16BIT_MSB:
+			unit_size_hor_chr = stride / 2;
+			unit_size_ver_chr = height / 2;
+			break;
+		case FORMAT_420_P10_32BIT_LSB:
+		case FORMAT_420_P10_32BIT_MSB:
+			unit_size_hor_chr = VPU_ALIGN16(stride / 2);
+			unit_size_ver_chr = height / 2;
+			break;
+		case FORMAT_422:
+		case FORMAT_422_P10_16BIT_LSB:
+		case FORMAT_422_P10_16BIT_MSB:
+		case FORMAT_422_P10_32BIT_LSB:
+		case FORMAT_422_P10_32BIT_MSB:
+			unit_size_hor_chr = VPU_ALIGN32(stride / 2);
+			unit_size_ver_chr = height;
+			break;
+#ifdef SUPPORT_PACKED_STREAM_FORMAT
+		case FORMAT_YUYV:
+		case FORMAT_YVYU:
+		case FORMAT_UYVY:
+		case FORMAT_VYUY:
+		case FORMAT_YUYV_P10_16BIT_MSB: // 4:2:2 10bit packed
+		case FORMAT_YUYV_P10_16BIT_LSB:
+		case FORMAT_YVYU_P10_16BIT_MSB:
+		case FORMAT_YVYU_P10_16BIT_LSB:
+		case FORMAT_UYVY_P10_16BIT_MSB:
+		case FORMAT_UYVY_P10_16BIT_LSB:
+		case FORMAT_VYUY_P10_16BIT_MSB:
+		case FORMAT_VYUY_P10_16BIT_LSB:
+		case FORMAT_YUYV_P10_32BIT_MSB:
+		case FORMAT_YUYV_P10_32BIT_LSB:
+		case FORMAT_YVYU_P10_32BIT_MSB:
+		case FORMAT_YVYU_P10_32BIT_LSB:
+		case FORMAT_UYVY_P10_32BIT_MSB:
+		case FORMAT_UYVY_P10_32BIT_LSB:
+		case FORMAT_VYUY_P10_32BIT_MSB:
+		case FORMAT_VYUY_P10_32BIT_LSB:
+			unit_size_hor_chr = 0;
+			unit_size_ver_chr = 0;
+			break;
+#endif
+		default:
+			break;
+		}
+		size_dpb_chr = (format == FORMAT_400) ?
+				       0 :
+				       unit_size_ver_chr * unit_size_hor_chr;
+	} else if (mapType == COMPRESSED_FRAME_MAP) {
+		switch (format) {
+		case FORMAT_420:
+#ifdef SUPPORT_PACKED_STREAM_FORMAT
+		case FORMAT_YUYV: // 4:2:2 8bit packed
+		case FORMAT_YVYU:
+		case FORMAT_UYVY:
+		case FORMAT_VYUY:
+#endif
+			size_dpb_chr = VPU_ALIGN16(stride / 2) * height;
+			break;
+		default:
+			/* 10bit */
+			stride = VPU_ALIGN64(stride / 2) +
+				 12; /* FIXME: need width information */
+			size_dpb_chr = VPU_ALIGN32(stride) * VPU_ALIGN4(height);
+			break;
+		}
+		size_dpb_chr = size_dpb_chr / 2;
+	} else if (mapType == ARM_COMPRESSED_FRAME_MAP) {
+		size_dpb_chr = 0;
+	} else if (mapType == TILED_FRAME_NO_BANK_MAP ||
+		   mapType == TILED_FIELD_NO_BANK_MAP) {
+		chr_size_y = (height >> field_map) / chr_hscale;
+		chr_size_x = stride / chr_vscale;
+
+		unit_size_hor_chr = (chr_size_x > 4096) ?
+					    8192 :
+					    (chr_size_x > 2048) ?
+					    4096 :
+					    (chr_size_x > 1024) ?
+					    2048 :
+					    (chr_size_x > 512) ? 1024 : 512;
+		unit_size_ver_chr =
+			((chr_size_y + 127) / 128) *
+			128; // unit vertical size is 128 pixel (8MB)
+
+		size_dpb_chr = (format == FORMAT_400) ?
+				       0 :
+				       (unit_size_hor_chr *
+					(unit_size_ver_chr << field_map));
+	} else if (mapType == TILED_FRAME_MB_RASTER_MAP ||
+		   mapType == TILED_FIELD_MB_RASTER_MAP) {
+		if (productId == PRODUCT_ID_960) {
+			chr_size_x = stride / chr_hscale;
+			chr_size_y = height / chr_hscale;
+			size_dpb_chr = chr_size_y * chr_size_x;
+
+			// aligned to 8192*2 (0x4000) for top/bot field
+			// use upper 20bit address only
+			size_dpb_chr_4k =
+				((size_dpb_chr + 16383) / 16384) * 16384;
+
+			if (mapType == TILED_FIELD_MB_RASTER_MAP) {
+				size_dpb_chr_4k =
+					((size_dpb_chr_4k + (0x8000 - 1)) &
+					 ~(0x8000 - 1));
+			}
+
+			size_dpb_chr = size_dpb_chr_4k;
+		} else {
+			size_dpb_chr =
+				(format == FORMAT_400) ?
+					0 :
+					((stride * (height >> field_map)) /
+					 (chr_hscale * chr_vscale));
+			size_dpb_chr_4k =
+				((size_dpb_chr + (16384 - 1)) / 16384) * 16384;
+			size_dpb_chr = size_dpb_chr_4k << field_map;
+		}
+	} else {
+		if (productId == PRODUCT_ID_960) {
+			int VerSizePerRas, Ras1DBit;
+			int ChrSizeYField;
+			int divY;
+			int ChrFieldRasSize, ChrFrameRasSize;
+
+			divY = format == FORMAT_420 || format == FORMAT_224 ?
+				       2 :
+				       1;
+
+			ChrSizeYField = ((height / divY) + 1) >> 1;
+
+			if (mapType == TILED_FRAME_V_MAP) {
+				if (pDramCfg->casBit == 9 &&
+				    pDramCfg->bankBit == 2 &&
+				    pDramCfg->rasBit == 13) { // CNN setting
+					VerSizePerRas = 64;
+					Ras1DBit = 3;
+				} else if (pDramCfg->casBit == 10 &&
+					   pDramCfg->bankBit == 3 &&
+					   pDramCfg->rasBit == 13) {
+					VerSizePerRas = 64;
+					Ras1DBit = 2;
+				} else
+					return 0;
+
+			} else if (mapType == TILED_FRAME_H_MAP) {
+				if (pDramCfg->casBit == 9 &&
+				    pDramCfg->bankBit == 2 &&
+				    pDramCfg->rasBit == 13) { // CNN setting
+					VerSizePerRas = 64;
+					Ras1DBit = 3;
+				} else if (pDramCfg->casBit == 10 &&
+					   pDramCfg->bankBit == 3 &&
+					   pDramCfg->rasBit == 13) {
+					VerSizePerRas = 64;
+					Ras1DBit = 2;
+				} else
+					return 0;
+
+			} else if (mapType == TILED_FIELD_V_MAP) {
+				if (pDramCfg->casBit == 9 &&
+				    pDramCfg->bankBit == 2 &&
+				    pDramCfg->rasBit == 13) { // CNN setting
+					VerSizePerRas = 64;
+					Ras1DBit = 3;
+				} else if (pDramCfg->casBit == 10 &&
+					   pDramCfg->bankBit == 3 &&
+					   pDramCfg->rasBit == 13) {
+					VerSizePerRas = 64;
+					Ras1DBit = 2;
+				} else
+					return 0;
+			} else { // TILED_FIELD_H_MAP
+				if (pDramCfg->casBit == 9 &&
+				    pDramCfg->bankBit == 2 &&
+				    pDramCfg->rasBit == 13) { // CNN setting
+					VerSizePerRas = 64;
+					Ras1DBit = 3;
+				} else if (pDramCfg->casBit == 10 &&
+					   pDramCfg->bankBit == 3 &&
+					   pDramCfg->rasBit == 13) {
+					VerSizePerRas = 64;
+					Ras1DBit = 2;
+				} else
+					return 0;
+			}
+			ChrFieldRasSize =
+				((ChrSizeYField + (VerSizePerRas - 1)) /
+				 VerSizePerRas)
+				<< Ras1DBit;
+			ChrFrameRasSize = ChrFieldRasSize * 2;
+			size_dpb_chr =
+				(ChrFrameRasSize
+				 << (pDramCfg->bankBit + pDramCfg->casBit +
+				     pDramCfg->busBit)) /
+				2; // divide 2  = to calucate one Cb(or Cr) size;
+
+		} else { // productId != 960
+			chr_size_y = (height >> field_map) / chr_hscale;
+			chr_size_x =
+				cbcrIntl == TRUE ? stride : stride / chr_vscale;
+
+			unit_size_hor_chr =
+				(chr_size_x > 4096) ?
+					8192 :
+					(chr_size_x > 2048) ?
+					4096 :
+					(chr_size_x > 1024) ?
+					2048 :
+					(chr_size_x > 512) ? 1024 : 512;
+			unit_size_ver_chr =
+				((chr_size_y + 63) / 64) *
+				64; // unit vertical size is 64 pixel (4MB)
+
+			size_dpb_chr =
+				(format == FORMAT_400) ?
+					0 :
+					unit_size_hor_chr * (unit_size_ver_chr
+							     << field_map);
+			size_dpb_chr /= (cbcrIntl == TRUE ? 2 : 1);
+		}
+	}
+	return size_dpb_chr;
+}
+
+#ifdef SUPPORT_SW_UART
+#include <string.h>
+#include <pthread.h>
+#include <unistd.h>
+typedef struct {
+	int core_idx;
+	pthread_t thread_id;
+	int sw_uart_thread_run;
+} SwUartContext;
+static SwUartContext s_SwUartContext;
+
+static pthread_mutex_t s_SwUartMutex = PTHREAD_MUTEX_INITIALIZER;
+void sw_uart_mutex_lock()
+{
+	pthread_mutex_lock(&s_SwUartMutex);
+}
+void sw_uart_mutex_unlock()
+{
+	pthread_mutex_unlock(&s_SwUartMutex);
+}
+
+void SwUartHandler(void *context)
+{
+	unsigned int regSwUartStatus;
+	unsigned int regSwUartTxData;
+	unsigned char *strRegSwUartTxData;
+	int i = 0;
+	char uartTx[1024];
+	osal_memset(uartTx, 0, sizeof(char) * 1024);
+	while (s_SwUartContext.sw_uart_thread_run == 1) {
+		sw_uart_mutex_lock();
+		regSwUartStatus = vdi_read_register(s_SwUartContext.core_idx,
+						    W4_SW_UART_STATUS);
+		if (regSwUartStatus == (unsigned int)-1) {
+			sw_uart_mutex_unlock();
+			continue;
+		}
+
+		if ((regSwUartStatus & (1 << 1))) {
+			regSwUartTxData = vdi_read_register(
+				s_SwUartContext.core_idx, W4_SW_UART_TX_DATA);
+			if (regSwUartTxData == (unsigned int)-1) {
+				sw_uart_mutex_unlock();
+				continue;
+			}
+			regSwUartStatus &= ~(1 << 1);
+			vdi_write_register(s_SwUartContext.core_idx,
+					   W4_SW_UART_STATUS, regSwUartStatus);
+
+			strRegSwUartTxData = (unsigned char *)&regSwUartTxData;
+			for (i = 0; i < 4; i++) {
+				if (strRegSwUartTxData[i] == '\n') {
+					VLOG(ERR, "%s \n", uartTx);
+					osal_memset(uartTx, 0,
+						    sizeof(unsigned char) *
+							    1024);
+				} else if (strRegSwUartTxData != NULL) {
+					strncat((char *)uartTx,
+						(const char
+							 *)(strRegSwUartTxData +
+							    i),
+						1);
+				} else
+					usleep(1);
+			}
+		} else
+			usleep(1);
+		sw_uart_mutex_unlock();
+	}
+
+	return;
+}
+
+int create_sw_uart_thread(unsigned long coreIdx)
+{
+	unsigned int regSwUartStatus;
+	int ret;
+
+	if (s_SwUartContext.sw_uart_thread_run == 1)
+		return 1;
+
+	vdi_write_register(
+		coreIdx, W4_SW_UART_STATUS,
+		(1
+		 << 0)); // enable SW UART. this will be checked by firmware to know SW UART enabled
+	s_SwUartContext.core_idx = coreIdx;
+	s_SwUartContext.sw_uart_thread_run = 1;
+	ret = pthread_create(&s_SwUartContext.thread_id, NULL,
+			     (void *)SwUartHandler, &s_SwUartContext);
+	ret = 1;
+
+	return ret;
+}
+
+void destory_sw_uart_thread()
+{
+	int inst_num;
+	int i;
+
+	inst_num = 0;
+	for (i = 0; i < MAX_NUM_VPU_CORE; i++) {
+		inst_num = inst_num + vdi_get_instance_num(i);
+	}
+
+	if (inst_num > 0)
+		return;
+
+	if (s_SwUartContext.sw_uart_thread_run == 1) {
+		s_SwUartContext.sw_uart_thread_run = 0;
+		vdi_write_register(
+			s_SwUartContext.core_idx, W4_SW_UART_STATUS,
+			0); // disable SW UART. this will be checked by firmware to know SW UART enabled
+		if (s_SwUartContext.thread_id) {
+			pthread_join(s_SwUartContext.thread_id, NULL);
+			s_SwUartContext.thread_id = 0;
+		}
+	}
+	return;
+}
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_vpuapifunc.h
@@ -0,0 +1,751 @@
+//--=========================================================================--
+//  This file is a part of VPU Reference API project
+//-----------------------------------------------------------------------------
+//
+//       This confidential and proprietary software may be used only
+//     as authorized by a licensing agreement from Chips&Media Inc.
+//     In the event of publication, the following notice is applicable:
+//
+//            (C) COPYRIGHT 2006 - 2011  CHIPS&MEDIA INC.
+//                      ALL RIGHTS RESERVED
+//
+//       The entire notice above must be reproduced on all authorized
+//       copies.
+//
+//--=========================================================================--
+
+#ifndef VPUAPI_UTIL_H_INCLUDED
+#define VPUAPI_UTIL_H_INCLUDED
+
+#include "ve1_vpuapi.h"
+
+// COD_STD
+enum { HEVC_DEC = 0,
+       AVC_DEC = 0,
+       VC1_DEC = 1,
+       HEVC_ENC = 1,
+       MP2_DEC = 2,
+       MP4_DEC = 3,
+       DV3_DEC = 3,
+       RV_DEC = 4,
+       AVS_DEC = 5,
+       VPX_DEC = 7,
+       MAX_DEC = 7,
+       AVC_ENC = 8,
+       MP4_ENC = 11,
+       MAX_CODECS,
+};
+
+// new COD_STD since WAVE series
+enum { W_HEVC_DEC = 0x00,
+       W_HEVC_ENC = 0x01,
+
+       W_AVC_DEC = 0x10,
+       W_VC1_DEC = 0x11,
+       W_MP2_DEC = 0x12,
+       W_MP4_DEC = 0x13,
+       W_DV3_DEC = 0x13,
+       W_RVX_DEC = 0x14,
+       W_AVS_DEC = 0x15,
+       W_VP9_DEC = 0x16,
+       W_VP8_DEC = 0x17,
+       W_AVS2_DEC = 0x18,
+
+       W_VP9_ENC = 0x19,
+       W_SVAC_DEC = 0x20,
+       W_SVAC_ENC = 0x21,
+
+       W_AVC_ENC = 0x88, /* The original value is 0x18 */
+       W_MP4_ENC = 0x89, /* The original value is 0x19 */
+
+       STD_UNKNOWN = 0xFF };
+
+// AUX_COD_STD
+enum { MP4_AUX_MPEG4 = 0, MP4_AUX_UNKNOWN3 = 1 };
+
+enum { VPX_AUX_THO = 0, VPX_AUX_VP6 = 1, VPX_AUX_VP8 = 2, VPX_AUX_NUM };
+
+enum { AVC_AUX_AVC = 0, AVC_AUX_MVC = 1 };
+
+// BIT_RUN command
+enum { DEC_SEQ_INIT = 1,
+       ENC_SEQ_INIT = 1,
+       DEC_SEQ_END = 2,
+       ENC_SEQ_END = 2,
+       PIC_RUN = 3,
+       SET_FRAME_BUF = 4,
+       ENCODE_HEADER = 5,
+       ENC_PARA_SET = 6,
+       DEC_PARA_SET = 7,
+       DEC_BUF_FLUSH = 8,
+       RC_CHANGE_PARAMETER = 9,
+       VPU_SLEEP = 10,
+       VPU_WAKE = 11,
+       ENC_ROI_INIT = 12,
+       FIRMWARE_GET = 0xf };
+
+enum { SRC_BUFFER_EMPTY = 0, //!< source buffer doesn't allocated.
+       SRC_BUFFER_ALLOCATED = 1, //!< source buffer has been allocated.
+       SRC_BUFFER_SRC_LOADED = 2, //!< source buffer has been allocated.
+       SRC_BUFFER_USE_ENCODE =
+	       3 //!< source buffer was sent to VPU. but it was not used for encoding.
+};
+#define MAX(_a, _b) (_a >= _b ? _a : _b)
+
+#define HEVC_MAX_SUB_LAYER_ID 6
+
+//#define API_DEBUG
+#ifdef API_DEBUG
+#ifdef _MSC_VER
+#define APIDPRINT(_fmt, ...) printf(_fmt, __VA_ARGS__)
+#else
+#define APIDPRINT(_fmt, ...) printf(_fmt, ##__VA_ARGS__)
+#endif
+#else
+#define APIDPRINT(_fmt, ...)
+#endif
+
+extern Uint32 __VPU_BUSY_TIMEOUT;
+/**
+ * PRODUCT: CODA960/CODA980/WAVE320
+ */
+typedef struct {
+	union {
+		struct {
+			int useBitEnable;
+			int useIpEnable;
+			int useDbkYEnable;
+			int useDbkCEnable;
+			int useOvlEnable;
+			int useBtpEnable;
+			PhysicalAddress bufBitUse;
+			PhysicalAddress bufIpAcDcUse;
+			PhysicalAddress bufDbkYUse;
+			PhysicalAddress bufDbkCUse;
+			PhysicalAddress bufOvlUse;
+			PhysicalAddress bufBtpUse;
+		} coda9;
+		struct {
+			int useIpEnable;
+			int useSclEnable;
+			int useSclPackedModeEnable;
+			int useLfRowEnable;
+			int useBitEnable;
+			PhysicalAddress bufIp;
+			PhysicalAddress bufLfRow;
+			PhysicalAddress bufBit;
+			PhysicalAddress bufScaler;
+			PhysicalAddress bufScalerPackedData;
+			int useEncImdEnable;
+			int useEncRdoEnable;
+			int useEncLfEnable;
+			PhysicalAddress bufImd;
+			PhysicalAddress bufRdo;
+			PhysicalAddress bufLf;
+		} wave4;
+	} u;
+	int bufSize;
+	PhysicalAddress bufBase;
+} SecAxiInfo;
+
+typedef struct {
+	DecOpenParam openParam;
+	DecInitialInfo initialInfo;
+	DecInitialInfo newSeqInfo; /* Temporal new sequence information */
+	PhysicalAddress streamWrPtr;
+	PhysicalAddress streamRdPtr;
+	Int32 streamBufFull;
+	int streamEndflag;
+	int frameDisplayFlag;
+	int clearDisplayIndexes;
+	int setDisplayIndexes;
+	PhysicalAddress streamRdPtrRegAddr;
+	PhysicalAddress streamWrPtrRegAddr;
+	PhysicalAddress streamBufStartAddr;
+	PhysicalAddress streamBufEndAddr;
+	PhysicalAddress frameDisplayFlagRegAddr;
+	PhysicalAddress currentPC;
+	PhysicalAddress busyFlagAddr;
+	int streamBufSize;
+	FrameBuffer frameBufPool[MAX_REG_FRAME];
+	vpu_buffer_t vbFrame;
+	vpu_buffer_t vbWTL;
+	vpu_buffer_t vbPPU;
+	vpu_buffer_t vbMV[MAX_REG_FRAME];
+	vpu_buffer_t vbFbcYTbl[MAX_REG_FRAME];
+	vpu_buffer_t vbFbcCTbl[MAX_REG_FRAME];
+	int chBwbFrameIdx;
+	int chFbcFrameIdx;
+	BOOL interResChange;
+
+	//RTK
+	vpu_buffer_t extVbFbcYTbls[MAX_GDI_IDX];
+	vpu_buffer_t extVbFbcCTbls[MAX_GDI_IDX];
+	int fbcTblAllocExt;
+
+	int frameAllocExt;
+	int ppuAllocExt;
+	int numFrameBuffers;
+	int numFbsForDecoding; /*!<< number of framebuffers used in decoding */
+	int numFbsForWTL; /*!<< number of linear framebuffer for displaying when DecInfo::wtlEnable is set to 1 */
+	int stride;
+	int frameBufferHeight;
+	int rotationEnable;
+	int mirrorEnable;
+	int deringEnable;
+	MirrorDirection mirrorDirection;
+	int rotationAngle;
+	FrameBuffer rotatorOutput;
+	int rotatorStride;
+	int rotatorOutputValid;
+	int initialInfoObtained;
+	int vc1BframeDisplayValid;
+	int mapType;
+	int tiled2LinearEnable;
+	int tiled2LinearMode;
+	int wtlEnable;
+	int wtlMode;
+	FrameBufferFormat wtlFormat; /*!<< default value: FORMAT_420 8bit */
+	SecAxiInfo secAxiInfo;
+	MaverickCacheConfig cacheConfig;
+	int chunkSize;
+	int seqInitEscape;
+
+	// Report Information
+	PhysicalAddress userDataBufAddr;
+	vpu_buffer_t vbUserData;
+
+	BOOL userDataEnable; /* User Data Enable Flag
+                                                          CODA9xx: TRUE or FALSE
+                                                          WAVE4xx: Refer to H265_USERDATA_FLAG_xxx values in vpuapi.h */
+	int userDataBufSize;
+	int userDataReportMode; // User Data report mode (0 : interrupt mode, 1 interrupt disable mode)
+
+	BOOL cuDataEnable; //!<< Enable reporting CU data
+	Int32 cuDataBufSize; //!<< Size of CU buffer in bytes
+	PhysicalAddress cuDataBufAddr; //!<< Physical address
+
+	WriteMemProtectCfg writeMemProtectCfg;
+
+	LowDelayInfo lowDelayInfo;
+	int frameStartPos;
+	int frameEndPos;
+	int frameDelay;
+	vpu_buffer_t vbSlice; // AVC, VP8 only
+	vpu_buffer_t vbWork;
+	vpu_buffer_t vbTemp;
+	vpu_buffer_t vbReport;
+	int workBufferAllocExt;
+	DecOutputInfo decOutInfo[MAX_GDI_IDX];
+	TiledMapConfig mapCfg;
+	int reorderEnable;
+	Uint32 avcErrorConcealMode;
+	DRAMConfig dramCfg; //coda960 only
+	int thumbnailMode;
+	int seqChangeMask; // WAVE410
+	Uint32 prevFrameEndPos; //!<< WAVE410v2: end position of previous frame
+	BOOL scalerEnable;
+	Uint32 scaleWidth;
+	Uint32 scaleHeight;
+	Int32 targetSubLayerId; //!<< H.265 temporal scalability
+
+	BOOL enableAfbce;
+	Int32 afbceFormat;
+	int rdPtrValidFlag;
+
+	Int32 instanceQueueCount;
+	Int32 totalQueueCount;
+#ifdef VE1_CHECKSUM
+	vpu_buffer_t hashTable;
+#endif
+#ifdef SUPPORT_GET_NAL_START_POS
+	PhysicalAddress nalStartPtr;
+#endif
+	Uint32 outputinfoSN; // for debug
+	Uint32 decodedFrmNum; // for debug
+} DecInfo;
+
+typedef struct {
+	EncOpenParam openParam;
+	EncInitialInfo initialInfo;
+	PhysicalAddress streamRdPtr;
+	PhysicalAddress streamWrPtr;
+	int streamEndflag;
+	PhysicalAddress streamRdPtrRegAddr;
+	PhysicalAddress streamWrPtrRegAddr;
+	PhysicalAddress streamBufStartAddr;
+	PhysicalAddress streamBufEndAddr;
+	PhysicalAddress currentPC;
+	PhysicalAddress busyFlagAddr;
+	int streamBufSize;
+	int linear2TiledEnable;
+	int linear2TiledMode; // coda980 only
+	int mapType;
+	int userMapEnable;
+	FrameBuffer frameBufPool[MAX_REG_FRAME];
+	vpu_buffer_t vbFrame;
+	vpu_buffer_t vbPPU;
+	int frameAllocExt;
+	int ppuAllocExt;
+	vpu_buffer_t vbSubSampFrame; /*!<< CODA960 only */
+	vpu_buffer_t vbMvcSubSampFrame; /*!<< CODA960 only */
+	int numFrameBuffers;
+	int stride;
+	int frameBufferHeight;
+	int rotationEnable;
+	int mirrorEnable;
+	MirrorDirection mirrorDirection;
+	int rotationAngle;
+	int initialInfoObtained;
+	int ringBufferEnable;
+	SecAxiInfo secAxiInfo;
+	MaverickCacheConfig cacheConfig;
+
+	int sliceIntEnable; /*!<< WAVE420 only */
+
+	int ActivePPSIdx; /*!<< CODA980 */
+	int frameIdx; /*!<< CODA980 */
+	int fieldDone; /*!<< CODA980 */
+	int encoded_frames_in_gop;
+	int lineBufIntEn;
+	vpu_buffer_t vbWork;
+	vpu_buffer_t vbScratch;
+
+	vpu_buffer_t vbTemp; //!< Temp buffer (WAVE420)
+	vpu_buffer_t vbMV; //!< colMV buffer (WAVE420)
+	vpu_buffer_t vbFbcYTbl; //!< FBC Luma table buffer (WAVE420)
+	vpu_buffer_t vbFbcCTbl; //!< FBC Chroma table buffer (WAVE420)
+	vpu_buffer_t vbSubSamBuf; //!< Sub-sampled buffer for ME (WAVE420)
+
+	TiledMapConfig mapCfg;
+	DRAMConfig dramCfg; /*!<< CODA960 */
+
+	Uint32 prefixSeiNalEnable;
+	Uint32 prefixSeiDataSize;
+	Uint32 prefixSeiDataEncOrder;
+	PhysicalAddress prefixSeiNalAddr;
+	Uint32 suffixSeiNalEnable;
+	Uint32 suffixSeiDataSize;
+	Uint32 suffixSeiDataEncOrder;
+	PhysicalAddress suffixSeiNalAddr;
+
+	Int32 errorReasonCode;
+	Uint64 curPTS; /**! Current timestamp in 90KHz */
+	Uint64 ptsMap[32]; /**! PTS mapped with source frame index */
+	Uint32 instanceQueueCount;
+	Uint32 totalQueueCount;
+} EncInfo;
+
+typedef struct CodecInst {
+	Int32 inUse;
+	Int32 instIndex;
+	Int32 coreIdx;
+	Int32 codecMode;
+	Int32 codecModeAux;
+	Int32 productId;
+	Int32 loggingEnable;
+	Uint32 isDecoder;
+	//ENABLE_TEE_DRM_FLOW //For RTK DRM flow
+	Uint32 isUseProtectBuffer;
+	void *sess;
+	void *rtk_sess;
+	void *teeapi_ctx;
+	unsigned int teeapi_tee_session;
+	Uint32 enableDcsysDebug;
+	union {
+		EncInfo encInfo;
+		DecInfo decInfo;
+	} * CodecInfo;
+	Uint32 noInterruptCnt; // for debug
+	void *filp; // for vdi_allocate_dma_memory
+} CodecInst;
+
+/*******************************************************************************
+ * H.265 USER DATA(VUI and SEI)                                           *
+ *******************************************************************************/
+#define H265_MAX_DPB_SIZE 17
+#define H265_MAX_NUM_SUB_LAYER 8
+#define H265_MAX_NUM_ST_RPS 64
+#define H265_MAX_CPB_CNT 32
+#define H265_MAX_NUM_VERTICAL_FILTERS 5
+#define H265_MAX_NUM_HORIZONTAL_FILTERS 3
+#define H265_MAX_TAP_LENGTH 32
+#define H265_MAX_NUM_KNEE_POINT 999
+
+#define H265_MAX_NUM_TONE_VALUE 1024
+#define H265_MAX_NUM_FILM_GRAIN_COMPONENT 3
+#define H265_MAX_NUM_INTENSITY_INTERVALS 256
+#define H265_MAX_NUM_MODEL_VALUES 5
+
+#define H265_MAX_LUT_NUM_VAL 3
+#define H265_MAX_LUT_NUM_VAL_MINUS1 33
+#define H265_MAX_COLOUR_REMAP_COEFFS 3
+typedef struct {
+	Uint32 offset;
+	Uint32 size;
+} user_data_entry_t;
+
+typedef struct {
+	Int16 left;
+	Int16 right;
+	Int16 top;
+	Int16 bottom;
+} win_t;
+
+typedef struct {
+	Uint8 nal_hrd_param_present_flag;
+	Uint8 vcl_hrd_param_present_flag;
+	Uint8 sub_pic_hrd_params_present_flag;
+	Uint8 tick_divisor_minus2;
+	Int8 du_cpb_removal_delay_inc_length_minus1;
+	Int8 sub_pic_cpb_params_in_pic_timing_sei_flag;
+	Int8 dpb_output_delay_du_length_minus1;
+	Int8 bit_rate_scale;
+	Int8 cpb_size_scale;
+	Int8 initial_cpb_removal_delay_length_minus1;
+	Int8 cpb_removal_delay_length_minus1;
+	Int8 dpb_output_delay_length_minus1;
+
+	Uint8 fixed_pic_rate_gen_flag[H265_MAX_NUM_SUB_LAYER];
+	Uint8 fixed_pic_rate_within_cvs_flag[H265_MAX_NUM_SUB_LAYER];
+	Uint8 low_delay_hrd_flag[H265_MAX_NUM_SUB_LAYER];
+	Int8 cpb_cnt_minus1[H265_MAX_NUM_SUB_LAYER];
+	Int16 elemental_duration_in_tc_minus1[H265_MAX_NUM_SUB_LAYER];
+
+	Uint32 nal_bit_rate_value_minus1[H265_MAX_NUM_SUB_LAYER]
+					[H265_MAX_CPB_CNT];
+	Uint32 nal_cpb_size_value_minus1[H265_MAX_NUM_SUB_LAYER]
+					[H265_MAX_CPB_CNT];
+	Uint32 nal_cpb_size_du_value_minus1[H265_MAX_NUM_SUB_LAYER];
+	Uint32 nal_bit_rate_du_value_minus1[H265_MAX_NUM_SUB_LAYER];
+	Uint8 nal_cbr_flag[H265_MAX_NUM_SUB_LAYER][H265_MAX_CPB_CNT];
+
+	Uint32 vcl_bit_rate_value_minus1[H265_MAX_NUM_SUB_LAYER]
+					[H265_MAX_CPB_CNT];
+	Uint32 vcl_cpb_size_value_minus1[H265_MAX_NUM_SUB_LAYER]
+					[H265_MAX_CPB_CNT];
+	Uint32 vcl_cpb_size_du_value_minus1[H265_MAX_NUM_SUB_LAYER];
+	Uint32 vcl_bit_rate_du_value_minus1[H265_MAX_NUM_SUB_LAYER];
+	Uint8 vcl_cbr_flag[H265_MAX_NUM_SUB_LAYER][H265_MAX_CPB_CNT];
+} h265_hrd_param_t;
+
+typedef struct {
+	Uint8 aspect_ratio_info_present_flag;
+	Uint8 aspect_ratio_idc;
+	Uint8 overscan_info_present_flag;
+	Uint8 overscan_appropriate_flag;
+
+	Uint8 video_signal_type_present_flag;
+	Int8 video_format;
+
+	Uint8 video_full_range_flag;
+	Uint8 colour_description_present_flag;
+
+	Uint16 sar_width;
+	Uint16 sar_height;
+
+	Uint8 colour_primaries;
+	Uint8 transfer_characteristics;
+	Uint8 matrix_coefficients;
+
+	Uint8 chroma_loc_info_present_flag;
+	Int8 chroma_sample_loc_type_top_field;
+	Int8 chroma_sample_loc_type_bottom_field;
+
+	Uint8 neutral_chroma_indication_flag;
+
+	Uint8 field_seq_flag;
+
+	Uint8 frame_field_info_present_flag;
+	Uint8 default_display_window_flag;
+	Uint8 vui_timing_info_present_flag;
+	Uint8 vui_poc_proportional_to_timing_flag;
+
+	Uint32 vui_num_units_in_tick;
+	Uint32 vui_time_scale;
+
+	Uint8 vui_hrd_parameters_present_flag;
+	Uint8 bitstream_restriction_flag;
+
+	Uint8 tiles_fixed_structure_flag;
+	Uint8 motion_vectors_over_pic_boundaries_flag;
+	Uint8 restricted_ref_pic_lists_flag;
+	Int8 min_spatial_segmentation_idc;
+	Int8 max_bytes_per_pic_denom;
+	Int8 max_bits_per_mincu_denom;
+
+	Int16 vui_num_ticks_poc_diff_one_minus1;
+	Int8 log2_max_mv_length_horizontal;
+	Int8 log2_max_mv_length_vertical;
+
+	win_t def_disp_win;
+	h265_hrd_param_t hrd_param;
+} h265_vui_param_t;
+
+typedef struct {
+	Uint32 display_primaries_x[3];
+	Uint32 display_primaries_y[3];
+	Uint32 white_point_x : 16;
+	Uint32 white_point_y : 16;
+	Uint32 max_display_mastering_luminance : 32;
+	Uint32 min_display_mastering_luminance : 32;
+} h265_mastering_display_colour_volume_t;
+
+typedef struct {
+	Uint32 ver_chroma_filter_idc : 8;
+	Uint32 hor_chroma_filter_idc : 8;
+	Uint32 ver_filtering_field_processing_flag : 1;
+	Uint32 target_format_idc : 2;
+	Uint32 num_vertical_filters : 3;
+	Uint32 num_horizontal_filters : 3;
+	Uint8 ver_tap_length_minus1[H265_MAX_NUM_VERTICAL_FILTERS];
+	Uint8 hor_tap_length_minus1[H265_MAX_NUM_HORIZONTAL_FILTERS];
+	Int32 ver_filter_coeff[H265_MAX_NUM_VERTICAL_FILTERS]
+			      [H265_MAX_TAP_LENGTH];
+	Int32 hor_filter_coeff[H265_MAX_NUM_HORIZONTAL_FILTERS]
+			      [H265_MAX_TAP_LENGTH];
+} h265_chroma_resampling_filter_hint_t;
+
+typedef struct {
+	Uint32 knee_function_id;
+	Uint8 knee_function_cancel_flag;
+
+	Uint8 knee_function_persistence_flag;
+	Uint32 input_disp_luminance;
+	Uint32 input_d_range;
+	Uint32 output_d_range;
+	Uint32 output_disp_luminance;
+	Uint16 num_knee_points_minus1;
+	Uint16 input_knee_point[H265_MAX_NUM_KNEE_POINT];
+	Uint16 output_knee_point[H265_MAX_NUM_KNEE_POINT];
+} h265_knee_function_info_t;
+
+typedef struct {
+	Uint16 max_content_light_level;
+	Uint16 max_pic_average_light_level;
+} h265_content_light_level_info_t;
+
+typedef struct {
+	Uint32 colour_remap_id;
+	Uint8 colour_remap_cancel_flag;
+	Uint8 colour_remap_persistence_flag;
+	Uint8 colour_remap_video_signal_info_present_flag;
+	Uint8 colour_remap_full_range_flag;
+
+	Uint8 colour_remap_primaries;
+	Uint8 colour_remap_transfer_function;
+	Uint8 colour_remap_matrix_coefficients;
+	Uint8 colour_remap_input_bit_depth;
+
+	Uint8 colour_remap_bit_depth;
+	Uint8 pre_lut_num_val_minus1[H265_MAX_LUT_NUM_VAL];
+	Uint16 pre_lut_coded_value[H265_MAX_LUT_NUM_VAL]
+				  [H265_MAX_LUT_NUM_VAL_MINUS1];
+	Uint16 pre_lut_target_value[H265_MAX_LUT_NUM_VAL]
+				   [H265_MAX_LUT_NUM_VAL_MINUS1];
+
+	Uint8 colour_remap_matrix_present_flag;
+	Uint8 log2_matrix_denom;
+	Uint8 colour_remap_coeffs[H265_MAX_COLOUR_REMAP_COEFFS]
+				 [H265_MAX_COLOUR_REMAP_COEFFS];
+
+	Uint8 post_lut_num_val_minus1[H265_MAX_LUT_NUM_VAL];
+	Uint16 post_lut_coded_value[H265_MAX_LUT_NUM_VAL]
+				   [H265_MAX_LUT_NUM_VAL_MINUS1];
+	Uint16 post_lut_target_value[H265_MAX_LUT_NUM_VAL]
+				    [H265_MAX_LUT_NUM_VAL_MINUS1];
+
+} h265_colour_remapping_info_t;
+
+typedef struct {
+	Uint8 film_grain_characteristics_cancel_flag;
+	Uint8 film_grain_model_id;
+	Uint8 separate_colour_description_present_flag;
+	Uint8 film_grain_bit_depth_luma_minus8;
+	Uint8 film_grain_bit_depth_chroma_minus8;
+	Uint8 film_grain_full_range_flag;
+	Uint8 film_grain_colour_primaries;
+	Uint8 film_grain_transfer_characteristics;
+	Uint8 film_grain_matrix_coeffs;
+
+	Uint8 blending_mode_id;
+	Uint8 log2_scale_factor;
+
+	Uint8 comp_model_present_flag[H265_MAX_NUM_FILM_GRAIN_COMPONENT];
+	Uint8 num_intensity_intervals_minus1[H265_MAX_NUM_FILM_GRAIN_COMPONENT];
+	Uint8 num_model_values_minus1[H265_MAX_NUM_FILM_GRAIN_COMPONENT];
+	Uint8 intensity_interval_lower_bound[H265_MAX_NUM_FILM_GRAIN_COMPONENT]
+					    [H265_MAX_NUM_INTENSITY_INTERVALS];
+	Uint8 intensity_interval_upper_bound[H265_MAX_NUM_FILM_GRAIN_COMPONENT]
+					    [H265_MAX_NUM_INTENSITY_INTERVALS];
+	Uint32 comp_model_value[H265_MAX_NUM_FILM_GRAIN_COMPONENT]
+			       [H265_MAX_NUM_INTENSITY_INTERVALS]
+			       [H265_MAX_NUM_MODEL_VALUES];
+
+	Uint8 film_grain_characteristics_persistence_flag;
+} h265_film_grain_characteristics_t;
+
+typedef struct {
+	Uint32 tone_map_id;
+	Uint8 tone_map_cancel_flag;
+
+	Uint8 tone_map_persistence_flag;
+	Uint32 coded_data_bit_depth;
+	Uint32 target_bit_depth;
+	Uint8 tone_map_model_id;
+	Uint32 min_value;
+	Uint32 max_value;
+	Uint32 sigmoid_midpoint;
+	Uint32 sigmoid_width;
+	Uint16 start_of_coded_interval
+		[H265_MAX_NUM_TONE_VALUE]; // [1 << target_bit_depth] // 10bits
+	Uint16 num_pivots; // [(1 << coded_data_bit_depth)?1][(1 << target_bit_depth)-1] // 10bits
+	Uint16 coded_pivot_value[H265_MAX_NUM_TONE_VALUE];
+	Uint16 target_pivot_value[H265_MAX_NUM_TONE_VALUE];
+	Uint8 camera_iso_speed_idc;
+	Uint32 camera_iso_speed_value;
+	Uint8 exposure_index_idc;
+	Uint32 exposure_index_value;
+	Uint8 exposure_compensation_value_sign_flag;
+	Uint16 exposure_compensation_value_numerator;
+	Uint16 exposure_compensation_value_denom_idc;
+	Uint32 ref_screen_luminance_white;
+	Uint32 extended_range_white_level;
+	Uint16 nominal_black_level_code_value;
+	Uint16 nominal_white_level_code_value;
+	Uint16 extended_white_level_code_value;
+} h265_tone_mapping_info_t;
+
+typedef struct {
+	Int8 status; // 0 : empty, 1 : occupied
+	Int8 pic_struct;
+	Int8 source_scan_type;
+	Int8 duplicate_flag;
+} h265_sei_pic_timing_t;
+
+typedef struct {
+	Int8 preferred_transfer_characteristics;
+} h265_alternative_transfer_characteristics_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+RetCode InitCodecInstancePool(Uint32 coreIdx);
+RetCode GetCodecInstance(Uint32 coreIdx, CodecInst **ppInst, void *filp);
+void FreeCodecInstance(CodecInst *pCodecInst);
+
+RetCode CheckDecOpenParam(DecOpenParam *pop);
+int DecBitstreamBufEmpty(DecInfo *pDecInfo);
+
+RetCode SetParaSet(DecHandle handle, int paraSetType, DecParamSet *para);
+void DecSetHostParaAddr(Uint32 coreIdx, PhysicalAddress baseAddr,
+			PhysicalAddress paraAddr);
+
+#ifdef ENABLE_CODA9_WRITE_PROTECT
+int SetDecWriteProtectRegions(CodecInst *inst);
+void ConfigDecWPROTRegion(int coreIdx, DecInfo *pDecInfo);
+#endif
+
+Int32 ConfigSecAXICoda9(Uint32 coreIdx, Int32 codecMode, SecAxiInfo *sa,
+			Uint32 width, Uint32 height, Uint32 profile);
+
+Int32 ConfigSecAXIWave(Uint32 coreIdx, Int32 codecMode, SecAxiInfo *sa,
+		       Uint32 width, Uint32 height, Uint32 profile,
+		       Uint32 level);
+
+RetCode AllocateLinearFrameBuffer(TiledMapType mapType, FrameBuffer *fbArr,
+				  Uint32 numOfFrameBuffers, Uint32 sizeLuma,
+				  Uint32 sizeChroma);
+
+RetCode AllocateTiledFrameBufferGdiV1(TiledMapType mapType,
+				      PhysicalAddress tiledBaseAddr,
+				      FrameBuffer *fbArr,
+				      Uint32 numOfFrameBuffers, Uint32 sizeLuma,
+				      Uint32 sizeChroma, DRAMConfig *pDramCfg);
+
+RetCode AllocateTiledFrameBufferGdiV2(TiledMapType mapType, FrameBuffer *fbArr,
+				      Uint32 numOfFrameBuffers, Uint32 sizeLuma,
+				      Uint32 sizeChroma);
+
+RetCode CheckEncInstanceValidity(EncHandle handle);
+RetCode CheckEncOpenParam(EncOpenParam *pop);
+RetCode CheckEncParam(EncHandle handle, EncParam *param);
+RetCode GetEncHeader(EncHandle handle, EncHeaderParam *encHeaderParam);
+RetCode EncParaSet(EncHandle handle, int paraSetType);
+RetCode SetGopNumber(EncHandle handle, Uint32 *gopNumber);
+RetCode SetIntraQp(EncHandle handle, Uint32 *intraQp);
+RetCode SetBitrate(EncHandle handle, Uint32 *bitrate);
+RetCode SetFramerate(EncHandle handle, Uint32 *frameRate);
+RetCode SetIntraRefreshNum(EncHandle handle, Uint32 *pIntraRefreshNum);
+RetCode SetSliceMode(EncHandle handle, EncSliceMode *pSliceMode);
+RetCode SetHecMode(EncHandle handle, int mode);
+void EncSetHostParaAddr(Uint32 coreIdx, PhysicalAddress baseAddr,
+			PhysicalAddress paraAddr);
+void EncMBISR_Init(Uint32 coreIdx);
+
+RetCode EnterLock(Uint32 coreIdx);
+RetCode LeaveLock(Uint32 coreIdx);
+RetCode SetClockGate(Uint32 coreIdx, Uint32 on);
+
+RetCode EnterDispFlagLock(Uint32 coreIdx);
+RetCode LeaveDispFlagLock(Uint32 coreIdx);
+
+void SetPendingInst(Uint32 coreIdx, CodecInst *inst);
+void ClearPendingInst(Uint32 coreIdx);
+CodecInst *GetPendingInst(Uint32 coreIdx);
+int GetPendingInstIdx(Uint32 coreIdx);
+
+Int32 MaverickCache2Config(MaverickCacheConfig *pCache, BOOL decoder,
+			   BOOL interleave, Uint32 bypass, Uint32 burst,
+			   Uint32 merge, TiledMapType mapType, Uint32 wayshape);
+
+int SetTiledMapType(Uint32 coreIdx, TiledMapConfig *pMapCfg, int mapType,
+		    int stride, int interleave, DRAMConfig *dramCfg);
+int GetXY2AXIAddr(TiledMapConfig *pMapCfg, int ycbcr, int posY, int posX,
+		  int stride, FrameBuffer *fb);
+int GetLowDelayOutput(CodecInst *pCodecInst, DecOutputInfo *lowDelayOutput);
+//for GDI 1.0
+void SetTiledFrameBase(Uint32 coreIdx, PhysicalAddress baseAddr);
+PhysicalAddress GetTiledFrameBase(Uint32 coreIdx, FrameBuffer *frame, int num);
+
+/**
+ * \brief   It returns the stride of framebuffer in byte.
+ *
+ * \param   width           picture width in pixel.
+ * \param   format          YUV format. see FrameBufferFormat structure in vpuapi.h
+ * \param   cbcrInterleave
+ * \param   mapType         map type. see TiledMapType in vpuapi.h
+ */
+Int32 CalcStride(Uint32 width, Uint32 height, FrameBufferFormat format,
+		 BOOL cbcrInterleave, TiledMapType mapType, BOOL isVP9);
+
+Int32 CalcLumaSize(Int32 productId, Int32 stride, Int32 height,
+		   FrameBufferFormat format, BOOL cbcrIntl,
+		   TiledMapType mapType, DRAMConfig *pDramCfg);
+
+Int32 CalcChromaSize(Int32 productId, Int32 stride, Int32 height,
+		     FrameBufferFormat format, BOOL cbcrIntl,
+		     TiledMapType mapType, DRAMConfig *pDramCfg);
+
+int LevelCalculation(int MbNumX, int MbNumY, int frameRateInfo,
+		     int interlaceFlag, int BitRate, int SliceNum);
+
+/* timescale: 1/90000 */
+Uint64 GetTimestamp(EncHandle handle);
+
+RetCode SetCropInfo(EncHandle handle, EncOpenParam *newOP);
+
+#ifdef SUPPORT_SW_UART
+void SwUartHandler(void *context);
+int create_sw_uart_thread(unsigned long coreIdx);
+void destory_sw_uart_thread();
+void sw_uart_mutex_lock();
+void sw_uart_mutex_unlock();
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // endif VPUAPI_UTIL_H_INCLUDED
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_vpuconfig.h
@@ -0,0 +1,147 @@
+//--=========================================================================--
+//  This file is a part of VPU Reference API project
+//-----------------------------------------------------------------------------
+//
+//       This confidential and proprietary software may be used only
+//     as authorized by a licensing agreement from Chips&Media Inc.
+//     In the event of publication, the following notice is applicable:
+//
+//            (C) COPYRIGHT 2006 - 2011  CHIPS&MEDIA INC.
+//                      ALL RIGHTS RESERVED
+//
+//       The entire notice above must be reproduced on all authorized
+//       copies.
+//		This file should be modified by some customers according to their SOC configuration.
+//--=========================================================================--
+
+#ifndef __CODA9_VPU_CONFIG_H__
+#define __CODA9_VPU_CONFIG_H__
+
+#include "ve1config.h"
+#include "ve1_vputypes.h"
+
+#if MAX_DEC_PIC_WIDTH > 1920 // 4K
+
+#define USE_WTL 0 // not support 4K WTL
+#define MAX_EXTRA_FRAME_BUFFER_NUM 1
+#define MAX_PP_SRC_NUM                                                         \
+	2 //PPU buffer(decoding case) or Source buffer(encoding case)
+
+#define MAX_DPB_MBS 110400 // 32768 for level 5
+
+#elif MAX_DEC_PIC_WIDTH > 720
+
+#define USE_WTL 0 // for WTL (needs MAX_DPB_NUM*2 frame)
+#define MAX_EXTRA_FRAME_BUFFER_NUM 4
+#define MAX_PP_SRC_NUM                                                         \
+	2 //PPU buffer(decoding case) or Source buffer(encoding case)
+
+#define MAX_DPB_MBS 32768 // 32768 for level 4.1
+
+#else
+
+#define USE_WTL 0 // for WTL (needs MAX_DPB_NUM*2 frame)
+#define MAX_EXTRA_FRAME_BUFFER_NUM 4
+#define MAX_PP_SRC_NUM                                                         \
+	2 //PPU buffer(decoding case) or Source buffer(encoding case)
+
+#define MAX_DPB_MBS 32768 // 32768 for level 4.1
+
+#endif
+
+// codec specific configuration
+#define VPU_REORDER_ENABLE                                                     \
+	1 // it can be set to 1 to handle reordering DPB in host side.
+#define VPU_GMC_PROCESS_METHOD 0
+#define VPU_AVC_X264_SUPPORT 1
+
+// DRAM configuration for TileMap access
+#define EM_RAS 13
+#define EM_BANK 3
+#define EM_CAS 10
+#define EM_WIDTH 2
+
+/************************************************************************/
+/* VPU_ME_LINEBUFFER_MODE configuration
+Config_0
+- LINE_BUFFER : 72kbyte
+- IME_SR_MEM :  13.75kbyte
+- Config_0: 36 lines
+- search range y is -16 ~ 15.
+
+Config_1
+- LINE_BUFFER : 136kbyte
+- IME_SR_MEM :  8.25kbyte
+- Config_1: 68 lines
+- search range y is -32 ~ 31.
+
+Config_2
+- LINE_BUFFER : 200kbyte
+- IME_SR_MEM :  2.75kbyt
+- Config_2: 100 lines
+- search range y is -48 ~ 47.                                           */
+/************************************************************************/
+/* RTK need to check */
+#define VPU_ME_LINEBUFFER_MODE 0 /*!<< CODA980, WAVE320 */
+
+#define VPU_GBU_SIZE 1024
+
+//********************************************//
+//      External Memory Map Table
+//********************************************//
+/* RTK need to check */
+#define CODE_BUF_SIZE (248 * 1024)
+#define TEMP_BUF_SIZE (204 * 1024)
+#define WORK_BUF_SIZE (80 * 1024)
+#define PARA_BUF_SIZE (10 * 1024)
+
+//=====2. VPU BITSTREAM MEMORY ===================//
+#define MAX_STREAM_BUF_SIZE 0x300000 // max bitstream size
+
+//===== 3. VPU PPS Save Size ===================//
+//----- SPS/PPS save buffer --------------------//
+#define PS_SAVE_SIZE                                                           \
+	((320 + 8) * 1024 *                                                    \
+	 4) // sps[64], pps[256], backupPsBuf[8] for rollback, error concealment (each 4Kbyte)
+//----- VP8 MB save buffer -------------------//
+#define VP8_MB_SAVE_SIZE                                                       \
+	(17 * 4 *                                                              \
+	 (MAX_DEC_PIC_WIDTH * MAX_DEC_PIC_HEIGHT /                             \
+	  256)) // MB information + split MVs)*4*MbNumbyte
+//----- slice save buffer --------------------//
+#define SLICE_SAVE_SIZE                                                        \
+	(MAX_DEC_PIC_WIDTH * MAX_DEC_PIC_HEIGHT * 3 /                          \
+	 4) // this buffer for ASO/FMO
+
+//=====5. VPU Encoder Scratch buffer ssize ======================//
+#define SIZE_AVCENC_QMAT_TABLE ((16 * 6) + (64 * 2)) // 4x4 6, 8x8 2
+#define SIZE_MP4ENC_DATA_PARTITION                                             \
+	(MAX_ENC_PIC_WIDTH * MAX_ENC_PIC_HEIGHT * 3 / 4)
+
+//=====6. Check VPU required memory size =======================//
+#define MAX_FRM_SIZE ((MAX_DEC_PIC_WIDTH * MAX_DEC_PIC_HEIGHT * 3) / 2)
+#define MAX_DEC_FRAME_BUFFERING                                                \
+	(MAX_DPB_MBS / ((MAX_DEC_PIC_WIDTH * MAX_DEC_PIC_HEIGHT) / 256))
+#define MAX_DPB_NUM                                                            \
+	(16 < MAX_DEC_FRAME_BUFFERING ?                                        \
+		 (16 + 2 + MAX_EXTRA_FRAME_BUFFER_NUM) :                       \
+		 (MAX_DEC_FRAME_BUFFERING + 2 +                                \
+		  MAX_EXTRA_FRAME_BUFFER_NUM)) //  (+2 for current and display_delay)
+#define MAX_DPB_SIZE                                                           \
+	(((MAX_FRM_SIZE + 0x3fff) & (~0x3fff)) *                               \
+	 MAX_DPB_NUM) // frame buffer for codec (MAX_DPB_NUM)
+#define MAX_MV_COL_SIZE (((MAX_FRM_SIZE + 4) / 5) * MAX_DPB_NUM)
+#define MAX_PP_SRC_SIZE (((MAX_FRM_SIZE + 0x3fff) & (~0x3fff)) * MAX_PP_SRC_NUM)
+
+#define CODEC_FRAME_BASE                                                       \
+	((((MAX_STREAM_BUF_SIZE * MAX_NUM_INSTANCE)) + 0xff) & (~0xff))
+#define REQUIRED_VPU_MEMORY_SIZE                                               \
+	(CODEC_FRAME_BASE + ((MAX_DPB_SIZE * (1 + USE_WTL)) +                  \
+			     MAX_MV_COL_SIZE + MAX_PP_SRC_SIZE) *              \
+				    MAX_NUM_INSTANCE)
+
+#define PREALLOC_MV_BUFFER_COUNT 11
+#define PREALLOC_MV_WIDTH 1920
+#define PREALLOC_MV_HEIGHT 1080
+
+#endif /* __CODA9_VPU_CONFIG_H__ */
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_vpuerror.h
@@ -0,0 +1,229 @@
+//--=========================================================================--
+//  This file is a part of VPU Reference API project
+//-----------------------------------------------------------------------------
+//
+//       This confidential and proprietary software may be used only
+//     as authorized by a licensing agreement from Chips&Media Inc.
+//     In the event of publication, the following notice is applicable:
+//
+//            (C) COPYRIGHT 2006 - 2013  CHIPS&MEDIA INC.
+//                      ALL RIGHTS RESERVED
+//
+//       The entire notice above must be reproduced on all authorized
+//       copies.
+//
+//--=========================================================================--
+
+/************************************************************************/
+/* Error code definitions depending on product                          */
+/************************************************************************/
+
+#ifndef ERROR_CODE_H_INCLUDED
+#define ERROR_CODE_H_INCLUDED
+
+/*
+ * CODA9(CODA960, CODA980, WAVE320)
+ */
+
+/*
+ * WAVE410
+ */
+
+/************************************************************************/
+/* WAVE4 SYSTEM ERROR                                                   */
+/************************************************************************/
+#define WAVE4_CODEC_ERROR 0x00000001
+#define WAVE4_SYSERR_STREAM_BUF_FULL 0x00000100
+#define WAVE4_SYSERR_ACCESS_VIOLATION_HW 0x00001000
+#define WAVE4_SYSERR_UNSPECIFIED 0x00002000
+#define WAVE4_SYSERR_WRITEPROTECTION 0x00004000
+#define WAVE4_SYSERR_CP0_EXCEPTION 0x00006000
+#define WAVE4_SYSERR_WATCHDOG_TIMEOUT 0x00008000
+
+/************************************************************************/
+/*  WAVE4 CODEC ERROR ON DEC_PIC_HDR                                    */
+/************************************************************************/
+#define WAVE4_SPSERR_MAX_SUB_LAYERS_MINUS1                                     \
+	0x00000001 // WARNING	sps_max_sub_layer_minus1 shall be 0 to 6
+#define WAVE4_SPSERR_GENERAL_RESERVED_ZERO_44BITS                              \
+	0x00000002 // WARNING	general_reserved_zero_44bits shall be 0
+#define WAVE4_SPSERR_RESERVED_ZERO_2BITS                                       \
+	0x00000004 // WARNING	reserved_zero_2bits shall be 0
+#define WAVE4_SPSERR_SUB_LAYER_RESERVED_ZERO_44BITS                            \
+	0x00000008 // WARNING	sub_layer_reserved_zero_44bits shall be 0
+#define WAVE4_SPSERR_GENERAL_LEVEL_IDC                                         \
+	0x00000010 // WARNING	general_level_idc shall have one of level of Table A.1
+#define WAVE4_SPSERR_SPS_MAX_DEC_PIC_BUFFERING_VALUE_OVER                      \
+	0x00000020 // WARNING	sps_max_dec_pic_buffering[i] <= MaxDpbSize
+#define WAVE4_SPSERR_RBSP_TRAILING_BITS                                        \
+	0x00000040 // WARNING	trailing bits shall be 1000... pattern, 7.3.2.1
+
+#define WAVE4_SPSERR_BASE 0x00000100
+#define WAVE4_SPSERR_SEQ_PARAMETER_SET_ID                                      \
+	0x00000100 // ERROR	seq_parameter_set_id golomb decode error
+#define WAVE4_SPSERR_CHROMA_FORMAT_IDC                                         \
+	0x00000200 // ERROR	chroma_format_idc golomb decode error
+#define WAVE4_SPSERR_PIC_WIDTH_IN_LUMA_SAMPLES                                 \
+	0x00000300 // ERROR	pic_width_in_luma_samples golomb decode error
+#define WAVE4_SPSERR_PIC_HEIGHT_IN_LUMA_SAMPLES                                \
+	0x00000400 // ERROR	pic_height_in_luma_samples golomb decode error
+#define WAVE4_SPSERR_CONF_WIN_LEFT_OFFSET                                      \
+	0x00000500 // ERROR	conf_win_left_offset golomb decode error
+#define WAVE4_SPSERR_CONF_WIN_RIGHT_OFFSET                                     \
+	0x00000600 // ERROR	conf_win_right_offset golomb decode error
+#define WAVE4_SPSERR_CONF_WIN_TOP_OFFSET                                       \
+	0x00000700 // ERROR	conf_win_top_offset golomb decode error
+#define WAVE4_SPSERR_CONF_WIN_BOTTOM_OFFSET                                    \
+	0x00000800 // ERROR	conf_win_top_offset golomb decode error
+#define WAVE4_SPSERR_BIT_DEPTH_LUMA_MINUS8                                     \
+	0x00000900 // ERROR	bit_depth_luma_minus8 golomb decode error
+#define WAVE4_SPSERR_BIT_DEPTH_CHROMA_MINUS8                                   \
+	0x00000A00 // ERROR	bit_depth_chroma_minus8 golomb decode error
+#define WAVE4_SPSERR_LOG2_MAX_PIC_ORDER_CNT_LSB_MINUS4                         \
+	0x00000B00 // ERROR	log2_max_pic_order_cnt_lsb_minus4 golomb decode error
+#define WAVE4_SPSERR_SPS_MAX_DEC_PIC_BUFFERING                                 \
+	0x00000C00 // ERROR	sps_max_dec_pic_buffering[i] golomb decode error
+#define WAVE4_SPSERR_SPS_MAX_NUM_REORDER_PICS                                  \
+	0x00000D00 // ERROR	sps_max_num_reorder_pics[i] golomb decode error
+#define WAVE4_SPSERR_SPS_MAX_LATENCY_INCREASE                                  \
+	0x00000E00 // ERROR	sps_sps_max_latency_increase[i] golomb decode error
+#define WAVE4_SPSERR_LOG2_MIN_LUMA_CODING_BLOCK_SIZE_MINUS3                    \
+	0x00000F00 // ERROR	log2_min_luma_coding_block_size_minus3 golomb decode error
+#define WAVE4_SPSERR_LOG2_DIFF_MAX_MIN_LUMA_CODING_BLOCK_SIZE                  \
+	0x00001000 // ERROR	log2_diff_max_min_luma_coding_block_size golomb decode error
+#define WAVE4_SPSERR_LOG2_MIN_TRANSFORM_BLOCK_SIZE_MINUS2                      \
+	0x00001100 // ERROR	log2_min_transform_block_size_minus2 golomb decode error
+#define WAVE4_SPSERR_LOG2_DIFF_MAX_MIN_TRANSFORM_BLOCK_SIZE                    \
+	0x00001200 // ERROR	log2_diff_max_min_transform_block_size golomb decode error
+#define WAVE4_SPSERR_MAX_TRANSFORM_HIERARCHY_DEPTH_INTER                       \
+	0x00001300 // ERROR	max_transform_hierarchy_depth_inter golomb decode error
+#define WAVE4_SPSERR_MAX_TRANSFORM_HIERARCHY_DEPTH_INTRA                       \
+	0x00001400 // ERROR	max_transform_hierarchy_depth_intra golomb decode error
+#define WAVE4_SPSERR_SCALING_LIST                                              \
+	0x00001500 // ERROR	scaling list parsing error in scaling_list_data()
+#define WAVE4_SPSERR_LOG2_DIFF_MIN_PCM_LUMA_CODING_BLOCK_SIZE_MINUS3           \
+	0x00001600 // ERROR	log2_diff_min_pcm_luma_coding_block_size_minus3 golomb decode error
+#define WAVE4_SPSERR_LOG2_DIFF_MAX_MIN_PCM_LUMA_CODING_BLOCK_SIZE              \
+	0x00001700 // ERROR	log2_diff_max_min_pcm_luma_coding_block_size golomb decode error
+#define WAVE4_SPSERR_NUM_SHORT_TERM_REF_PIC_SETS                               \
+	0x00001800 // ERROR	num_short_term_ref_pic_sets golomb decode error
+#define WAVE4_SPSERR_NUM_LONG_TERM_REF_PICS_SPS                                \
+	0x00001900 // ERROR	num_long_term_ref_pics_sps golomb decode error
+
+//  WAVE4 CODEC ERROR SPEC OVER SECTION : shared with DEC_PIC command
+#define WAVE4_SPEC_OVER_PICTURE_WIDTH_SIZE                                     \
+	0x00010000 // Spec over	ERROR	decoded picture width size over
+#define WAVE4_SPEC_OVER_PICTURE_HEIGHT_SIZE                                    \
+	0x00020000 // Spec over	ERROR	decoded picture height size over
+#define WAVE4_SPEC_OVER_CHROMA_FORMAT                                          \
+	0x00040000 // Spec over	ERROR	chroma format is not 4:2:0
+#define WAVE4_SPEC_OVER_BIT_DEPTH                                              \
+	0x00080000
+     // luma or chroma bit depth over.
+		// In WAVE410 v1.0 luma and chroma bit depth should be 8 bits.
+		// In WAVE410 v2.0 luma and chroma bit depth should be up to 10 bits repectively.
+#define WAVE4_SPEC_OVER_PROFILE                                                                                             \
+	0x00100000 // Spec over	WARNING
+		// general_profile_idc and general_profile_compatibility_flag over.
+		// In WAVE410 v1.0. general_profile_idc and general_profile_compatibility_flag should specify Main profile.
+		// In WAVE410 v2.0. general_profile_idc and general_profile_compatibility_flag should specify Main or Main10 profile.
+#define WAVE4_SPEC_OVER_LEVEL                                                  \
+	0x00200000 // Spec over	WARNING	general_level_idc over.
+
+/************************************************************************/
+/*  WAVE4 CODEC ERROR NO SEQUENCE INFORMATION SECTION                   */
+/************************************************************************/
+#define WAVE4_SPSERR_NOT_FOUND 0x01000000
+#define WAVE4_SPS_PARSING_ERROR 0x02000000
+
+/************************************************************************/
+/*  WAVE4 CODEC ERROR ON DEC_PIC                                        */
+/************************************************************************/
+/* Syntax error */
+#define WAVE4_SHERR_FIRST_SLICE_SEGMENT_IN_PIC_FLAG                            \
+	0x00000001 // WARNING first_slice_in_pic_flag shall be 1 at first slice
+#define WAVE4_SHERR_NO_OUTPUT_OF_PRIOR_PICS_FLAG                               \
+	0x00000002 // WARNING no_output_of_prior_pics_flag shall be equal to the first slice
+#define WAVE4_SHERR_PIC_OUTPUT_FLAG                                            \
+	0x00000004 // WARNING pic_output_flag shall be equal to the first slice
+#define WAVE4_SHERR_SLICE_PIC_PARAMETER_SET_ID                                 \
+	0x00000100 // ERROR slice_pic_parameter_set_id decode error
+#define WAVE4_SHERR_ACTIVATE_PPS 0x00000200 // ERROR activate_pps decode error
+#define WAVE4_SHERR_SLICE_TYPE 0x00000300 // ERROR slice_type decode error
+#define WAVE4_SHERR_FIRST_SLICE_IS_DEPENDENT_SLICE                             \
+	0x00000400 // ERROR first_slice must be independent slice
+#define WAVE4_SHERR_SHORT_TERM_REF_PIC_SET_SPS_FLAG                            \
+	0x00000500 // ERROR short_term_ref_pic_set_sps_flag shall be equal to the first slice
+#define WAVE4_SHERR_SHORT_TERM_REF_PIC_SET                                     \
+	0x00000600 // ERROR short_term_ref_pic_set decode error
+#define WAVE4_SHERR_SHORT_TERM_REF_PIC_SET_IDX                                 \
+	0x00000700 // ERROR short_term_ref_pic_set_idx shall be equal to the first slice
+#define WAVE4_SHERR_NUM_LONG_TERM_SPS                                          \
+	0x00000800 // ERROR num_long_term_sps decode error
+#define WAVE4_SHERR_NUM_LONG_TERM_PICS                                         \
+	0x00000900 // ERROR num_long_term_pics decode error
+#define WAVE4_SHERR_LT_IDX_SPS_IS_OUT_OF_RANGE                                 \
+	0x00000A00 // ERROR lt_idx_sps is out of range
+#define WAVE4_SHERR_DELTA_POC_MSB_CYCLE_LT                                     \
+	0x00000B00 // ERROR delta_poc_msb_cycle_lt decode error
+#define WAVE4_SHERR_NUM_REF_IDX_L0_ACTIVE_MINUS1                               \
+	0x00000C00 // ERROR num_ref_idx_l0_active_minus1 decode error
+#define WAVE4_SHERR_NUM_REF_IDX_L1_ACTIVE_MINUS1                               \
+	0x00000D00 // ERROR num_ref_idx_l1_active_minus1 decode error
+#define WAVE4_SHERR_COLLOCATED_REF_IDX                                         \
+	0x00000E00 // ERROR collocated_ref_idx decode error
+#define WAVE4_SHERR_PRED_WEIGHT_TABLE                                          \
+	0x00000F00 // ERROR pred_weight_table decode error
+#define WAVE4_SHERR_FIVE_MINUS_MAX_NUM_MERGE_CAND                              \
+	0x00001000 // ERROR five_minus_max_num_merge_cand decode error
+#define WAVE4_SHERR_SLICE_QP_DELTA                                             \
+	0x00001100 // ERROR slice_qp_delta decode error
+#define WAVE4_SHERR_SLICE_QP_DELTA_IS_OUT_OF_RANGE                             \
+	0x00001200 // ERROR slice_qp_delta is out of range
+#define WAVE4_SHERR_SLICE_CB_QP_OFFSET                                         \
+	0x00001300 // ERROR slice_cb_qp_offset decode error
+#define WAVE4_SHERR_SLICE_CR_QP_OFFSET                                         \
+	0x00001400 // ERROR slice_cr_qp_offset decode error
+#define WAVE4_SHERR_SLICE_BETA_OFFSET_DIV2                                     \
+	0x00001500 // ERROR slice_beta_offset_div2 decode error
+#define WAVE4_SHERR_SLICE_TC_OFFSET_DIV2                                       \
+	0x00001600 // ERROR slice_tc_offset_div2 decode error
+#define WAVE4_SHERR_NUM_ENTRY_POINT_OFFSETS                                    \
+	0x00001700 // ERROR num_entry_point_offsets decode error
+#define WAVE4_SHERR_OFFSET_LEN_MINUS1                                          \
+	0x00001800 // ERROR offset_len_minus1 decode error
+#define WAVE4_SHERR_SLICE_SEGMENT_HEADER_EXTENSION_LENGTH                      \
+	0x00001900 // ERROR slice_segment_header_extension_length decode error
+#define WAVE4_SHERR_SLICE_HEADER_OVER_CONSUMED                                 \
+	0x00001A00 // ERROR slice header over-consumed
+#define WAVE4_SHERR_DPB_OVERFLOW 0x00001B00 // ERROR DPB overflow
+
+// ETC
+#define WAVE4_ETCERR_NEXT_AU_SLICE 0x01000000 // WARNING  slice of next au found
+#define WAVE4_ETCERR_SLICE_NOT_FOUND 0x02000000 // WARNING  slice not found
+#define WAVE4_ETCERR_SEQ_CHANGE_DETECT                                         \
+	0x04000000 // ERROR    sequence change detected
+#define WAVE4_ETCERR_PPS_NOT_FOUND 0x08000000 // ERROR    PPS not found
+#define WAVE4_ETCERR_SPS_NOT_FOUND 0x10000000 // ERROR    SPS not found
+#define WAVE4_ETCERR_MISSING_REFERENCE_PICTURE                                 \
+	0x20000000 // WARNING  Reference picture was missing
+#define WAVE4_ETCERR_LACK_OF_STREAM                                            \
+	0x40000000 // ERROR    notice lack_of_stream for support roll-back mode
+#define WAVE4_ETCERR_SH_PARSING_ERROR                                          \
+	0x80000000 // ERROR    syntax parsing error detected
+
+/*
+ * WAVE5
+ */
+
+/************************************************************************/
+/* WAVE5 SYSTEM ERROR                                                   */
+/************************************************************************/
+#define WAVE5_CODEC_ERROR 0x00000001
+#define WAVE5_SYSERR_ACCESS_VIOLATION_HW 0x00000040
+#define WAVE5_RESULT_NOT_READY 0x00000800
+#define WAVE5_VPU_STILL_RUNNING 0x00001000
+#define WAVE5_INSTANCE_DESTROYED 0x00004000
+#define WAVE5_SYSERR_WATCHDOG_TIMEOUT 0x00008000
+
+#endif /* ERROR_CODE_H_INCLUDED */
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_vputypes.h
@@ -0,0 +1,104 @@
+//--=========================================================================--
+//  This file is a part of VPU Reference API project
+//-----------------------------------------------------------------------------
+//
+//       This confidential and proprietary software may be used only
+//     as authorized by a licensing agreement from Chips&Media Inc.
+//     In the event of publication, the following notice is applicable:
+//
+//            (C) COPYRIGHT 2006 - 2013  CHIPS&MEDIA INC.
+//                      ALL RIGHTS RESERVED
+//
+//       The entire notice above must be reproduced on all authorized
+//       copies.
+//
+//--=========================================================================--
+
+#ifndef _VPU_TYPES_H_
+#define _VPU_TYPES_H_
+
+#include <linux/types.h>
+//#include <stdint.h>
+
+/**
+* @brief    This type is an 8-bit unsigned integral type, which is used for declaring pixel data.
+*/
+typedef uint8_t Uint8;
+
+/**
+* @brief    This type is a 32-bit unsigned integral type, which is used for declaring variables with wide ranges and no signs such as size of buffer.
+*/
+typedef uint32_t Uint32;
+
+/**
+* @brief    This type is a 16-bit unsigned integral type.
+*/
+typedef uint16_t Uint16;
+
+/**
+* @brief    This type is an 8-bit signed integral type.
+*/
+typedef int8_t Int8;
+
+/**
+* @brief    This type is a 32-bit signed integral type.
+*/
+typedef int32_t Int32;
+
+/**
+* @brief    This type is a 16-bit signed integral type.
+*/
+typedef int16_t Int16;
+#if defined(_MSC_VER)
+typedef unsigned __int64 Uint64;
+typedef __int64 Int64;
+#else
+typedef uint64_t Uint64;
+typedef int64_t Int64;
+#endif
+#ifndef PhysicalAddress
+/**
+* @brief    This is a type for representing physical addresses which are recognizable by VPU.
+In general, VPU hardware does not know about virtual address space
+which is set and handled by host processor. All these virtual addresses are
+translated into physical addresses by Memory Management Unit.
+All data buffer addresses such as stream buffer and frame buffer should be given to
+VPU as an address on physical address space.
+*/
+typedef Uint32 PhysicalAddress;
+#endif
+#ifndef BYTE
+/**
+* @brief This type is an 8-bit unsigned integral type.
+*/
+typedef unsigned char BYTE;
+#endif
+#ifndef BOOL
+typedef int BOOL;
+#endif
+#ifndef TRUE
+#define TRUE 1
+#endif /* TRUE */
+#ifndef FALSE
+#define FALSE 0
+#endif /* FALSE */
+#ifndef NULL
+#define NULL 0
+#endif
+
+#ifndef UNREFERENCED_PARAMETER
+#define UNREFERENCED_PARAMETER(P)                                              \
+	/*lint -save -e527 -e530 */                                            \
+	{                                                                      \
+		(P) = (P);                                                     \
+	}                                                                      \
+	/*lint -restore */
+#endif
+
+#ifdef __GNUC__
+#define UNREFERENCED_FUNCTION __attribute__((unused))
+#else
+#define UNREFERENCED_FUNCTION
+#endif
+
+#endif /* _VPU_TYPES_H_ */
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_wrapper.c
@@ -0,0 +1,4268 @@
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/tee_drv.h>
+#include <linux/dma-buf.h>
+#include <media/v4l2-mem2mem.h>
+#include <linux/dma-map-ops.h>
+#include <soc/realtek/memory.h>
+#include <soc/realtek/rtk_media_heap.h>
+#include "ve1_vpuapifunc.h"
+#include "ve1_wrapper.h"
+#include "ve1_v4l2.h"
+#include "ve1_mem.h"
+#include "drv_if.h"
+#include "ve_common.h"
+#include "vpu.h"
+#include "ve1_config.h"
+#define VE1_WRAPPER_TAG "[VE1_WRAPPER]"
+
+// if #define VE1_ALLOC_FRAME_BUFFER_BY_VDI, ve1_wrapper allocate frame buffer by vdi_allocate_dma_memory_no_mmap()
+// or ve1_wrapper allocate frame buffer by ve1_alloc_frame_buffer()
+//#define VE1_ALLOC_FRAME_BUFFER_BY_VDI
+
+//#define VE1_CHECK_DPB_MD5_EN
+//#define VE1_CHECK_DPB_MD5_TO_FILE_EN
+//#define VE1_CHECK_DPB_MD5_FILEPATH "/tmp/ve1.dpbmd5"
+#if defined(VE1_CHECK_DPB_MD5_EN) || defined(VE1_CHECK_USERDATA_MD5_EN)
+#include <crypto/hash.h>
+#define VE1_MD5_DIGEST_SIZE 16
+static unsigned char ve1_md5_digest[VE1_MD5_DIGEST_SIZE];
+#endif
+
+//#define RTKVE1_DUMP_BS_EN
+#if defined(RTKVE1_DUMP_BS_EN)
+static int gBsDumpSerial = 0;
+#endif
+
+//#define RTKVE1_DUMP_YUV_EN
+#if defined(RTKVE1_DUMP_YUV_EN)
+//#define VE1_TEST_DUMP_YUV_FRAME_NUM 30
+static int gYuvDumpSerial = 0;
+#endif
+
+#include <linux/dma-map-ops.h>
+#include <soc/realtek/memory.h>
+
+#define IS_4K(w, h) (((w) * (h)) > (3200 * 1800))
+#define MAX_CHUNK_HEADER_SIZE                                                  \
+	256 * 1024 //DEFAULT_STREAMBUFFER_SIZE //Fuchun 20131225 don't need big size
+#define MAKE_FOURCC(a, b, c, d)                                                \
+	(((unsigned char)a) | ((unsigned char)b << 8) |                        \
+	 ((unsigned char)c << 16) | ((unsigned char)d << 24))
+
+#define EXTRA_DEC_PIC_BUF 2
+
+extern void rtkve1_add_displayble_frame_to_list(struct ve1_ctx *ctx);
+extern void ve1_show_displayable_frame_list(struct ve1_ctx *ctx);
+#if defined(ENABLE_TEE_DRM_FLOW)
+extern int ta_TEEapi_memcpy_a7(struct tee_context *teeapi_ctx,
+			       unsigned int teeapi_tee_session,
+			       unsigned int dstPAddr, unsigned char *buf,
+			       int size);
+extern int ta_TEEapi_memcpy(struct tee_context *teeapi_ctx,
+			    unsigned int teeapi_tee_session,
+			    unsigned int dstPhysAddr, unsigned int srtPhysAddr,
+			    int size);
+#endif
+extern int ta_TEEapi_OMX_CC_API(struct tee_context *teeapi_ctx,
+				unsigned int teeapi_tee_session,
+				unsigned int src_addr, unsigned char *dst_addr,
+				unsigned int size, unsigned int codec_type,
+				unsigned int mode);
+
+extern unsigned int vpu_debug;
+
+enum { H264_PIC_STRUCT_FRAME,
+       H264_PIC_STRUCT_TOP_FIELD,
+       H264_PIC_STRUCT_BOTTOM_FIELD,
+       H264_PIC_STRUCT_TOP_BOTTOM,
+       H264_PIC_STRUCT_BOTTOM_TOP,
+       H264_PIC_STRUCT_TOP_BOTTOM_TOP,
+       H264_PIC_STRUCT_BOTTOM_TOP_BOTTOM,
+       H264_PIC_STRUCT_FRAME_DOUBLING,
+       H264_PIC_STRUCT_FRAME_TRIPLING } VE1_H264_PIC_STRUCT;
+
+char *GetGitVersion(void)
+{
+#if defined(VPUAPIGITVER)
+	return (char *)VPUAPIGITVER;
+#else
+	return NULL;
+#endif
+}
+
+#ifdef VPU_GET_CC
+int ParseUserDataInfo(USER_DATA_INFO *pUserDataInfo, char *pUserDataBuf)
+{
+	char *pTmpBuf = NULL;
+	int ret = 0, i, offset;
+
+	pTmpBuf = pUserDataBuf;
+	pUserDataInfo->nUserDataNum =
+		(short)((pTmpBuf[0] << 8) | (pTmpBuf[1] << 0));
+	pUserDataInfo->nTotalUserDataSize =
+		(short)((pTmpBuf[2] << 8) | (pTmpBuf[3] << 0));
+	pTmpBuf = pUserDataBuf + 8;
+	for (i = 0, offset = USER_DATA_INFO_OFFSET;
+	     i < pUserDataInfo->nUserDataNum; ++i, pTmpBuf += 8) {
+		pUserDataInfo->nUserDataType[i] =
+			(short)((pTmpBuf[0] << 8) | (pTmpBuf[1] << 0));
+		pUserDataInfo->nUserDataSize[i] =
+			(short)((pTmpBuf[2] << 8) | (pTmpBuf[3] << 0));
+		pUserDataInfo->nUserDataOffset[i] = offset;
+
+		offset += (pUserDataInfo->nUserDataSize[i] + 7) / 8 * 8;
+		ret++;
+	}
+	return ret;
+}
+
+#define CC_MAGIC_NUMBER 0x01020304
+#define SEI_USER_DATA_REGISTERED_ITU_T_T35 4 //temp define
+#define itu_t_t35_country_code 181
+
+void FindH264CCInUserData(USER_DATA_INFO *pUserDataInfo, char *pUserDataBuf,
+			  long long PTS, char *dst)
+{
+	int i;
+	char *pCCdata = NULL;
+	short itu_t_t35_provider_code;
+	unsigned int nUserDataSize = 0;
+	int offset = 0;
+	int dst_offset = 72;
+	int magic = CC_MAGIC_NUMBER;
+	int packet_num = 0;
+	int *header = (int *)dst;
+
+	for (i = 0; i < pUserDataInfo->nUserDataNum; ++i) {
+		if (pUserDataInfo->nUserDataType[i] ==
+		    SEI_USER_DATA_REGISTERED_ITU_T_T35) {
+			pCCdata = (pUserDataBuf +
+				   pUserDataInfo->nUserDataOffset[i]);
+			if (pCCdata[0] != itu_t_t35_country_code) {
+				ve1_err(VE1_WRAPPER_TAG,
+					"[H264 CC] ERR @ %s %d\n", __func__,
+					__LINE__);
+				continue;
+			}
+			itu_t_t35_provider_code =
+				(short)((pCCdata[1] << 8) |
+					(pCCdata[2])); // ARM is little-endian
+
+			switch (itu_t_t35_provider_code) {
+			case 47: // Direct TV
+				if (pCCdata[3] == 3) {
+					int *packet_start = (int *)dst;
+					unsigned int *pCCValue =
+						(unsigned int *)(dst +
+								 dst_offset);
+
+					offset = pUserDataInfo
+							 ->nUserDataOffset[i] +
+						 2;
+					nUserDataSize =
+						pUserDataInfo->nUserDataSize[i] -
+						2;
+					packet_start[3 + packet_num] =
+						dst_offset;
+					pCCValue[0] = RTK_CC_SYNC;
+					pCCValue[1] = nUserDataSize;
+					dst_offset += 16;
+					memcpy(dst + dst_offset,
+					       pUserDataBuf + offset,
+					       nUserDataSize);
+					dst_offset += nUserDataSize;
+					packet_num++;
+				}
+				break;
+			case 49: // ATSC
+				if (pCCdata[3] == 'G' && pCCdata[4] == 'A' &&
+				    pCCdata[5] == '9' && pCCdata[6] == '4' &&
+				    pCCdata[7] == 3) {
+					int *packet_start = (int *)dst;
+					unsigned int *pCCValue =
+						(unsigned int *)(dst +
+								 dst_offset);
+
+					offset = pUserDataInfo
+							 ->nUserDataOffset[i] +
+						 3;
+					nUserDataSize =
+						pUserDataInfo->nUserDataSize[i] -
+						3;
+					packet_start[3 + packet_num] =
+						dst_offset;
+					pCCValue[0] = RTK_CC_SYNC;
+					pCCValue[1] = nUserDataSize;
+					dst_offset += 16;
+					memcpy(dst + dst_offset,
+					       pUserDataBuf + offset,
+					       nUserDataSize);
+					dst_offset += nUserDataSize;
+					packet_num++;
+				}
+				break;
+			default:
+				break;
+			}
+		}
+	}
+
+	header = (int *)dst;
+	header[0] = magic;
+	header[1] = dst_offset;
+	header[2] = packet_num;
+}
+
+void FindMpeg2CCInUserData(USER_DATA_INFO *pUserDataInfo, char *pUserDataBuf,
+			   long long PTS, char *dst)
+{
+	int i;
+	char *p = NULL;
+	unsigned int nUserDataSize = 0;
+	int offset = 0;
+	int dst_offset = 72;
+	int magic = CC_MAGIC_NUMBER;
+	int packet_num = 0;
+	bool have_ga94 = false;
+	int *header = (int *)dst;
+
+	for (i = 0; i < pUserDataInfo->nUserDataNum; ++i) {
+		p = pUserDataBuf + pUserDataInfo->nUserDataOffset[i];
+		if (p[0] == 'G' && p[1] == 'A' && p[2] == '9' && p[3] == '4') {
+			have_ga94 = true;
+		}
+	}
+
+	for (i = 0; i < pUserDataInfo->nUserDataNum; ++i) {
+		p = pUserDataBuf + pUserDataInfo->nUserDataOffset[i];
+
+		if (p[0] == 'G' && p[1] == 'A' && p[2] == '9' && p[3] == '4') {
+			int *packet_start = (int *)dst;
+			unsigned int *pCCValue =
+				(unsigned int *)(dst + dst_offset);
+
+			offset = pUserDataInfo->nUserDataOffset[i];
+			nUserDataSize = pUserDataInfo->nUserDataSize[i];
+			packet_start[3 + packet_num] = dst_offset;
+			pCCValue[0] = RTK_CC_SYNC;
+			pCCValue[1] = nUserDataSize;
+			dst_offset += 16;
+			memcpy(dst + dst_offset, pUserDataBuf + offset,
+			       nUserDataSize);
+			dst_offset += nUserDataSize;
+			packet_num++;
+
+		} else if (p[0] == 0x03 && (p[1] & 0x7f) == 0x01) {
+			if (have_ga94 == false) {
+				int *packet_start = (int *)dst;
+				unsigned int *pCCValue =
+					(unsigned int *)(dst + dst_offset);
+
+				offset = pUserDataInfo->nUserDataOffset[i];
+				nUserDataSize = pUserDataInfo->nUserDataSize[i];
+				packet_start[3 + packet_num] = dst_offset;
+				pCCValue[0] = RTK_CC_SYNC;
+				pCCValue[1] = nUserDataSize;
+				dst_offset += 16;
+				memcpy(dst + dst_offset, pUserDataBuf + offset,
+				       nUserDataSize);
+				dst_offset += nUserDataSize;
+				packet_num++;
+			}
+		}
+	}
+
+	header = (int *)dst;
+	header[0] = magic;
+	header[1] = dst_offset;
+	header[2] = packet_num;
+}
+
+int ProcessCC(struct ve1_ctx *ctx, unsigned char *cc_buf, unsigned int cc_size,
+	      long long PTS, int decode_index, int display_index,
+	      int codec_type)
+{
+	if (display_index >= MPEG2_CC_REG_FRAME_MAX) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"display_index is overflow!!! display_index %d > %d\n",
+			display_index, MPEG2_CC_REG_FRAME_MAX);
+		return -1;
+	}
+
+	if (!cc_size)
+		return 0;
+
+	if (ctx->is_svp) {
+		DecHandle decHandle = NULL;
+
+		if (ctx->decHandle == NULL) {
+			ve1_err(VE1_WRAPPER_TAG, "decHandle == NULL\n");
+			return -1;
+		}
+		decHandle = (DecHandle)ctx->decHandle;
+
+		if (decode_index >= 0 &&
+		    ctx->m_CCDecodeOrderWp[decode_index] != NULL) {
+			if (ta_TEEapi_OMX_CC_API(
+				    (struct tee_context *)decHandle->teeapi_ctx,
+				    decHandle->teeapi_tee_session,
+				    ctx->userDataBufPhysAddr,
+				    ctx->m_CCDecodeOrderWp[decode_index],
+				    USER_DATA_SRC_BUF_SIZE, codec_type,
+				    ENUM_CC_P) < 0) {
+				ve1_err(VE1_WRAPPER_TAG,
+					"In[%s][%d] ta_TEEapi_OMX_CC_API fail!!",
+					__func__, __LINE__);
+			}
+		}
+	} else {
+		USER_DATA_INFO nUserDataInfo;
+		ParseUserDataInfo(&nUserDataInfo, (char *)cc_buf);
+		switch (codec_type) {
+		case ENUM_CC_MPGE2:
+			FindMpeg2CCInUserData(
+				&nUserDataInfo, (char *)cc_buf, PTS,
+				ctx->m_CCDecodeOrderWp[decode_index]);
+			break;
+		case ENUM_CC_H264:
+			FindH264CCInUserData(
+				&nUserDataInfo, (char *)cc_buf, PTS,
+				ctx->m_CCDecodeOrderWp[decode_index]);
+			break;
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
+
+void ProcessCC_Display(void *pCtx, long long PTS,
+		       int display_index) //send CC to AP
+{
+	struct ve1_ctx *ctx;
+	int i;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (display_index >= 0 &&
+	    ctx->m_CCDecodeOrderWp[display_index] != NULL) {
+		int *header = (int *)ctx->m_CCDecodeOrderWp[display_index];
+
+		if (cc_isCCInit()) {
+			ve1_err(VE1_WRAPPER_TAG, " cc_isCCInit = false/n");
+			cc_data_channel_init();
+		}
+		// send data back to AP via fifo
+		if (cc_isCCReaderReady()) {
+			int total_size;
+			long long *pRTKHeader;
+			char *check;
+
+			if (header[0] != CC_MAGIC_NUMBER) {
+				return;
+			}
+
+			total_size = header[1] - 72;
+			if (total_size <= 0) {
+				ve1_err(VE1_WRAPPER_TAG,
+					"get wrong cc header - magic:%x size:%d packet_num:%d\n",
+					header[0], header[1], header[2]);
+				return;
+			}
+
+			for (i = 0; i < header[2]; i++) {
+				int offset = header[3 + i];
+
+				if (offset >
+				    USER_DATA_SRC_BUF_SIZE -
+					    RTK_CC_HEADER_SIZE) { //USER_DATA_SRC_BUF_SIZE
+					if ((ctx->cc_error_count % 100) == 0) {
+						ve1_err(VE1_WRAPPER_TAG,
+							"MPEG2 cc get wrong offset:%d index:%d\n",
+							offset, i);
+					}
+					ctx->cc_error_count++;
+					return;
+				}
+
+				pRTKHeader =
+					(long long *)(ctx->m_CCDecodeOrderWp
+							      [display_index] +
+						      offset);
+				pRTKHeader[1] = PTS;
+			}
+
+			check = ctx->m_CCDecodeOrderWp[display_index] + 72;
+			if (check[0] == 0x63 && check[1] == 0x4b &&
+			    check[2] == 0x74 && check[3] == 0x52) {
+				cc_data_channel_send(
+					ctx->m_CCDecodeOrderWp[display_index] +
+						72,
+					total_size, cc_getCCReaderPid());
+			}
+		}
+		// reset rtk header
+		for (i = 0; i < RTK_CC_HEADER_SIZE + 72; i++)
+			ctx->m_CCDecodeOrderWp[display_index][i] = 0;
+	}
+}
+#endif //defined(VPU_GET_CC)
+
+#if defined(VE1_CHECK_DPB_MD5_EN) || defined(VE1_CHECK_USERDATA_MD5_EN)
+int ve1_md5_hash(unsigned char *result, int resultLen, char *data, int dataLen)
+{
+	int ret = 0;
+	struct crypto_shash *tfm = NULL;
+	struct shash_desc *desc = NULL;
+
+	if ((result == NULL) || (resultLen <= 0) || (data == NULL) ||
+	    (dataLen <= 0)) {
+		return -1;
+	}
+	//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "data:0x%px.dataLen:%d\n", data,
+	//	dataLen);
+	memset(result, 0, resultLen);
+
+	tfm = crypto_alloc_shash("md5", 0, 0);
+	if (IS_ERR(tfm)) {
+		tfm = NULL;
+		ve1_err(VE1_WRAPPER_TAG, "IS_ERR(tfm)\n");
+		ret = -1;
+		goto out;
+	}
+
+	desc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
+	if (desc == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "kmalloc desc fail\n");
+		ret = -1;
+		goto out;
+	}
+
+	desc->tfm = tfm;
+
+	if (crypto_shash_init(desc) < 0) {
+		ve1_err(VE1_WRAPPER_TAG, "crypto_shash_init() fail\n");
+		ret = -1;
+		goto out;
+	}
+	//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "crypto_shash_init() ok\n");
+
+	if (crypto_shash_update(desc, data, dataLen) < 0) {
+		ve1_err(VE1_WRAPPER_TAG, "crypto_shash_update() fail\n");
+		ret = -1;
+		goto out;
+	}
+	//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "crypto_shash_update() ok\n");
+
+	if (crypto_shash_final(desc, result) < 0) {
+		ve1_err(VE1_WRAPPER_TAG, "crypto_shash_final() fail\n");
+		ret = -1;
+		goto out;
+	}
+	//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "crypto_shash_final() ok\n");
+
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
+		result[0], result[1], result[2], result[3], result[4],
+		result[5], result[6], result[7], result[8], result[9],
+		result[10], result[11], result[12], result[13], result[14],
+		result[15]);
+out:
+	if (desc) {
+		kfree(desc);
+	}
+	if (tfm) {
+		crypto_free_shash(tfm);
+	}
+
+	return ret;
+}
+#endif // #if defined(VE1_CHECK_DPB_MD5_EN)
+
+void rtkve1_recycle_dpb(struct ve1_ctx *ctx)
+{
+	int i = 0;
+	struct rtkve1_dpb_t *dpb = NULL;
+
+	if (ctx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx == NULL\n");
+		return;
+	}
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
+		return;
+	}
+
+	mutex_lock(&ctx->ve1_dma_mutex);
+	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
+		dpb = &(ctx->dpb[i]);
+		if (IS_RTKVE1_DPB_VALID(dpb->status) &&
+			IS_RTKVE1_DPB_REG(dpb->status) &&
+			IS_RTKVE1_DPB_WAIT_RECYCLE(dpb->status)) {
+			if (dpb->seqNo != ctx->currSequenceNo) {
+				ve1_err(VE1_WRAPPER_TAG,
+					"unexpect to recyle old sequence dpb[%d].seq(%u, %u).regIndex:%d.phys_addr:0x%lx.vb2_v4l2_buf:0x%px\n",
+					i, dpb->seqNo, ctx->currSequenceNo,
+					dpb->regIndex, dpb->phys_addr, dpb->vb2_v4l2_buf);
+				mutex_unlock(&ctx->ve1_dma_mutex);
+				WARN_ON(1);
+				return;
+			}
+
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"i:%d.status:0x%x.seqNo:%u\n",
+				i,dpb->status,dpb->seqNo);
+			dpb->status &= ~RTKVE1_DPB_ST_WAIT_RECYCLE;
+			if (dpb->regIndex < ctx->regFbCount) {
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"VPU_DecClrDispFlag(%d).phys_addr:0x%lx\n",
+					dpb->regIndex, dpb->phys_addr);
+				VPU_DecClrDispFlag((DecHandle)ctx->decHandle, dpb->regIndex);
+			}
+			else {
+				ve1_err(VE1_WRAPPER_TAG,
+					"invalid dpb regIndex:%d, not recycle.phys_addr:0x%lx\n",
+					dpb->regIndex, dpb->phys_addr);
+			}
+		}
+	}
+	mutex_unlock(&ctx->ve1_dma_mutex);
+}
+
+int rtkve1_add_capbuf_to_dpb(void *pCtx, unsigned long size,
+			     unsigned long phys_addr, void *vb2_v4l2_buf)
+{
+	int ret = -1;
+
+	struct ve1_ctx *ctx;
+	int i = 0;
+
+	if ((pCtx == NULL) || (size == 0) || (phys_addr == 0) ||
+	    (vb2_v4l2_buf == NULL)) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"invalid parameters.pCtx:0x%px.size:%ld.phys_addr:0x%lx.vb2_v4l2_buf:0x%px\n",
+			pCtx, size, phys_addr, vb2_v4l2_buf);
+		return ret;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	mutex_lock(&ctx->ve1_dma_mutex);
+	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
+		if (IS_RTKVE1_DPB_EMPTY(ctx->dpb[i].status)) {
+			break;
+		}
+	}
+	if (i == VE1_ION_STRUCT_NUM) {
+		ve1_err(VE1_WRAPPER_TAG, "all ctx->dpb[] are used\n");
+		mutex_unlock(&ctx->ve1_dma_mutex);
+		return ret;
+	}
+	ctx->dpb[i].size = size;
+	ctx->dpb[i].status |= RTKVE1_DPB_ST_VALID;
+	ctx->dpb[i].phys_addr = phys_addr;
+	ctx->dpb[i].vb2_v4l2_buf = vb2_v4l2_buf;
+	ctx->dpb[i].seqNo = ctx->currSequenceNo;
+	ctx->cntCap2Dpb++;
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"add capbuf to dpb[%d].status:0x%x.phys_addr:0x%lx.size:%u.vb2_v4l2_buf:0x%px.seqNo:%u.cntCap2Dpb:%d\n",
+		i, ctx->dpb[i].status, ctx->dpb[i].phys_addr, ctx->dpb[i].size,
+		ctx->dpb[i].vb2_v4l2_buf,
+		ctx->dpb[i].seqNo,
+		ctx->cntCap2Dpb);
+	ret = i;
+	mutex_unlock(&ctx->ve1_dma_mutex);
+
+	return ret;
+}
+
+void *rtkve1_find_dpb_unreg(void *pCtx)
+{
+	int i = 0;
+	struct ve1_ctx *ctx;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return NULL;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
+		if ((ctx->dpb[i].seqNo == ctx->currSequenceNo) &&
+			IS_RTKVE1_DPB_VALID(ctx->dpb[i].status) &&
+			!IS_RTKVE1_DPB_REG(ctx->dpb[i].status)) {
+				return (void *)&(ctx->dpb[i]);
+		}
+	}
+
+	return NULL;
+}
+
+void *rtkve1_find_dpb_undequeue(void *pCtx, unsigned int seqNo)
+{
+	int i = 0;
+	struct ve1_ctx *ctx;
+	struct rtkve1_dpb_t *dpb = NULL;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return NULL;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
+		if ((ctx->dpb[i].seqNo == seqNo) &&
+			IS_RTKVE1_DPB_VALID(ctx->dpb[i].status) &&
+			IS_RTKVE1_DPB_REG(ctx->dpb[i].status) &&
+			!IS_RTKVE1_DPB_DQ(ctx->dpb[i].status)) {
+			dpb = &(ctx->dpb[i]);
+		}
+	}
+
+	return (void *)dpb;
+}
+
+int rtkve1_unreg_dpbs(void *pCtx)
+{
+	int ret = 0;
+	struct ve1_ctx *ctx;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
+		return -1;
+	}
+
+	if (ctx->regFbCount == 0) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "ignore due to not reg dpb yet\n");
+		return 0;
+	}
+
+	//mutex_lock(&ctx->ve1_mutex);
+	ret = VPU_DecGiveCommand((DecHandle)ctx->decHandle, DEC_FREE_FRAME_BUFFER, 0x00);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG, "VPU_DecGiveCommand(DEC_FREE_FRAME_BUFFER) fail\n");
+		//mutex_unlock(&ctx->ve1_mutex);
+		return ret;
+	}
+
+	mutex_lock(&ctx->ve1_dma_mutex);
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "clear ctx->dpb[]\n");
+	memset(ctx->dpb, 0, sizeof(struct rtkve1_dpb_t)*VE1_ION_STRUCT_NUM);
+	mutex_unlock(&ctx->ve1_dma_mutex);
+
+	ctx->cntCap2Dpb = 0;
+	ctx->capReqBufsCnt = 0;
+	ctx->regFbCount = 0;
+
+	if (ctx->fbAllocInfo) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree fbAllocInfo\n");
+		kfree(ctx->fbAllocInfo);
+		ctx->fbAllocInfo = NULL;
+	}
+	if (ctx->fbUser) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree fbUser\n");
+		kfree(ctx->fbUser);
+		ctx->fbUser = NULL;
+	}
+	ctx->ve1DecState = VE1_STATE_DEC_SEQ_INIT_DONE;
+	//mutex_unlock(&ctx->ve1_mutex);
+
+	return ret;
+}
+
+void rtkve1_show_dpbs(struct ve1_ctx *ctx)
+{
+	int i = 0;
+
+	if (ctx == NULL) {
+		return;
+	}
+
+	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
+		if (ctx->dpb[i].size == 0) {
+			continue;
+		}
+		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			"dpb[%d].status:0x%x.size:%d.phys_addr:0x%lx.vb2_v4l2_buf:0x%px.regIndex:%d.seqNo:%d\n",i,
+			ctx->dpb[i].status, ctx->dpb[i].size,
+			ctx->dpb[i].phys_addr,
+			ctx->dpb[i].vb2_v4l2_buf,
+			ctx->dpb[i].regIndex,
+			ctx->dpb[i].seqNo);
+	}
+}
+
+int rtkve1_register_dpbs(void *pCtx)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	struct ve1_ctx *ctx;
+	int i = 0;
+	DecOpenParam *decOP;
+	DecInitialInfo *initialInfo;
+	int mapType = LINEAR_FRAME_MAP;
+	int fbHeight;
+	int fbStride;
+	FrameBufferFormat fbFormat;
+	FrameBufferFormat wtlFormat;
+	FrameBufferAllocInfo *fbAllocInfo;
+	FrameBuffer *fbUser;
+	struct rtkve1_dpb_t *dpb_unreg = NULL;
+	unsigned int dispFlag = 0;
+	unsigned int clearDispIndex = 0;
+	SecAxiUse *secAxiUse;
+	MaverickCacheConfig *decCacheConfig;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"invalid parameters.pCtx:0x%px\n",
+			pCtx);
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
+		return -1;
+	}
+
+	if (ctx->fbAllocInfo == NULL) {
+		ctx->fbAllocInfo =
+			kzalloc(sizeof(FrameBufferAllocInfo), GFP_KERNEL);
+		if (ctx->fbAllocInfo == NULL) {
+			ve1_err(VE1_WRAPPER_TAG, "kzalloc fbAllocInfo fail\n");
+			return -1;
+		}
+	}
+
+	if (ctx->fbUser == NULL) {
+		ctx->fbUser = kzalloc(sizeof(FrameBuffer) * MAX_REG_FRAME,
+				      GFP_KERNEL);
+		if (ctx->fbUser == NULL) {
+			ve1_err(VE1_WRAPPER_TAG, "kzalloc fbUser fail\n");
+			return -1;
+		}
+	}
+
+	decOP = (DecOpenParam *)ctx->decOP;
+	initialInfo = (DecInitialInfo *)ctx->initialInfo;
+	fbAllocInfo = (FrameBufferAllocInfo *)ctx->fbAllocInfo;
+
+	fbFormat = FORMAT_420;
+	wtlFormat = FORMAT_420;
+
+	if ((mapType == TILED_FRAME_V_MAP) && (decOP->wtlEnable == 0) &&
+	    (decOP->tiled2LinearEnable == 0)) {
+		// trace VPU_GetFrameBufSize -> ProductCalculateFrameBufSize -> CalcLumaSize
+		// if TILED_FRAME_V_MAP and CODA980, VPU force use 64 align to calculate the frame buffer height (unit_size_ver_lum),
+		// it will influence the U_addr of YUV_STATE
+		fbHeight = VPU_ALIGN64(initialInfo->picHeight);
+	} else {
+		fbHeight = VPU_ALIGN32(initialInfo->picHeight);
+		//fbHeight = VPU_ALIGN16(initialInfo->picHeight);
+	}
+	fbStride = CalcStride(initialInfo->picWidth, initialInfo->picHeight,
+			      fbFormat, decOP->cbcrInterleave,
+			      (TiledMapType)mapType, 0);
+	ctx->framebufSize =
+		VPU_GetFrameBufSize(VE1_COREIDX, fbStride, fbHeight, mapType,
+				    fbFormat, decOP->cbcrInterleave, NULL);
+	ve1_info(
+		VE1_WRAPPER_TAG,
+		"af VPU_GetFrameBufSize().framebufSize:%d.fbStride:%d.fbHeight:%d.mapType:%d\n",
+		ctx->framebufSize, fbStride, fbHeight, mapType);
+
+	if (fbHeight == 0 || fbStride == 0 || ctx->framebufSize == 0) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"incorrect fbHeight:%d.fbStride:%d.framebufSize:%d\n",
+			fbHeight, fbStride, ctx->framebufSize);
+		return -1;
+	}
+
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"cntCap2Dpb:%d.capReqBufsCnt:%d.regFbCount:%d\n",
+			ctx->cntCap2Dpb, ctx->capReqBufsCnt, ctx->regFbCount);
+
+	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
+		if ((ctx->dpb[i].seqNo == ctx->currSequenceNo) &&
+			(ctx->dpb[i].size > 0) &&
+			(!IS_RTKVE1_DPB_REG(ctx->dpb[i].status)) &&
+			(ctx->dpb[i].size < ctx->framebufSize)) {
+			ctx->error = TRUE;
+			ve1_err(VE1_WRAPPER_TAG,
+				"dpb[%d].seqNo:%d.size:%u < expected framebufSize:%d\n",
+				i, ctx->currSequenceNo,
+				ctx->dpb[i].size,
+				ctx->framebufSize);
+			WARN_ON(1);
+			return -1;
+		}
+	}
+
+	fbAllocInfo->format = fbFormat;
+	fbAllocInfo->cbcrInterleave = decOP->cbcrInterleave;
+	fbAllocInfo->mapType = mapType;
+	fbAllocInfo->stride = fbStride;
+	fbAllocInfo->height = fbHeight;
+	fbAllocInfo->lumaBitDepth = initialInfo->lumaBitdepth;
+	fbAllocInfo->chromaBitDepth = initialInfo->chromaBitdepth;
+	fbAllocInfo->num = ctx->capReqBufsCnt;
+	fbAllocInfo->endian = decOP->frameEndian;
+	fbAllocInfo->type = FB_TYPE_CODEC;
+
+	mutex_lock(&ctx->ve1_dma_mutex);
+	for (i = 0; i < ctx->capReqBufsCnt; i++) {
+		dpb_unreg = (struct rtkve1_dpb_t *)rtkve1_find_dpb_unreg((void *)ctx);
+		if (dpb_unreg == NULL) {
+			break;
+		}
+		fbUser = ((FrameBuffer *)ctx->fbUser) + i;
+		dpb_unreg->regIndex = i;
+		dpb_unreg->status |= RTKVE1_DPB_ST_REG;
+		fbUser->size = dpb_unreg->size;
+		fbUser->bufY = dpb_unreg->phys_addr;
+		fbUser->bufCb = -1;
+		fbUser->bufCr = -1;
+		fbUser->updateFbInfo = TRUE;
+		ctx->regFbCount++;
+		clearDispIndex |= (1<<i);
+		dispFlag = ~clearDispIndex;
+		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			"regFbCount:%d.dispFlag:0x%x\n",
+			ctx->regFbCount,dispFlag);
+	}
+	mutex_unlock(&ctx->ve1_dma_mutex);
+
+	ret = VPU_DecAllocateFrameBuffer((DecHandle)ctx->decHandle,
+					 *((FrameBufferAllocInfo *)fbAllocInfo),
+					 (FrameBuffer *)ctx->fbUser);
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"af VPU_DecAllocateFrameBuffer.ret:%d\n", ret);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"VPU_DecAllocateFrameBuffer fail.ret:%d\n", ret);
+		return -1;
+	}
+	for (i = 0; i < ctx->capReqBufsCnt; i++) {
+		fbUser = ((FrameBuffer *)ctx->fbUser) + i;
+		ve1_dbg(
+			VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			"fbUser[%d].bufY:0x%x.size:%d.myIndex:%d.stride:%d.h:%d.seqNo:%d\n",
+			i, fbUser->bufY, fbUser->size, fbUser->myIndex,
+			fbUser->stride, fbUser->height, ctx->currSequenceNo);
+	}
+
+	if (ctx->secAxiUse == NULL) {
+		ctx->secAxiUse = kzalloc(sizeof(SecAxiUse), GFP_KERNEL);
+		if (ctx->secAxiUse == NULL) {
+			ve1_err(VE1_WRAPPER_TAG, "kzalloc secAxiUse fail\n");
+			return -1;
+		}
+	}
+	secAxiUse = (SecAxiUse *)ctx->secAxiUse;
+	memset(secAxiUse, 0, sizeof(SecAxiUse));
+	secAxiUse->u.coda9.useBitEnable = USE_BIT_INTERNAL_BUF;
+	secAxiUse->u.coda9.useIpEnable = USE_IP_INTERNAL_BUF;
+	secAxiUse->u.coda9.useDbkYEnable = USE_DBKY_INTERNAL_BUF;
+	secAxiUse->u.coda9.useDbkCEnable = USE_DBKC_INTERNAL_BUF;
+	secAxiUse->u.coda9.useOvlEnable = USE_OVL_INTERNAL_BUF;
+	secAxiUse->u.coda9.useBtpEnable = USE_BTP_INTERNAL_BUF;
+	VPU_DecGiveCommand((DecHandle)ctx->decHandle, SET_SEC_AXI, secAxiUse);
+
+	if (ctx->decCacheConfig == NULL) {
+		ctx->decCacheConfig =
+			kzalloc(sizeof(MaverickCacheConfig), GFP_KERNEL);
+		if (ctx->decCacheConfig == NULL) {
+			ve1_err(VE1_WRAPPER_TAG,
+				"kzalloc decCacheConfig fail\n");
+			return -1;
+		}
+	}
+	decCacheConfig = (MaverickCacheConfig *)ctx->decCacheConfig;
+	MaverickCache2Config(decCacheConfig,
+			     TRUE, // decoder
+			     (BOOL)decOP->cbcrInterleave, 0, 0, 3,
+			     (TiledMapType)mapType, 15);
+	VPU_DecGiveCommand((DecHandle)ctx->decHandle, SET_CACHE_CONFIG,
+			   decCacheConfig);
+
+	fbStride =
+		CalcStride(initialInfo->picWidth, initialInfo->picHeight,
+			fbFormat, decOP->cbcrInterleave,
+			(decOP->wtlEnable == TRUE ? LINEAR_FRAME_MAP :
+			(TiledMapType)(mapType)),
+			0);
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"fbStride:%d.fbFormat:%d.mapType:%d\n", fbStride, fbFormat,
+		mapType);
+
+	ret = VPU_DecRegisterFrameBuffer((DecHandle)ctx->decHandle,
+					 (FrameBuffer *)ctx->fbUser,
+					 ctx->capReqBufsCnt, fbStride, fbHeight,
+					 mapType);
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"af VPU_DecRegisterFrameBuffer.ret:%d\n", ret);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"VPU_DecRegisterFrameBuffer fail.ret:%d\n", ret);
+		return -1;
+	}
+
+	ret = VPU_DecSetDispFlag((DecHandle)ctx->decHandle, dispFlag);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"VPU_DecSetDispFlag fail.ret:%d\n", ret);
+		return -1;
+	}
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"VPU_DecSetDispFlag.dispFlag:0x%x\n", dispFlag);
+
+	return ret;
+}
+
+int rtkve1_register_new_dpb(void *pCtx, void* pDpb)
+{
+	int ret = 0;
+	struct ve1_ctx *ctx;
+	DecOpenParam *decOP;
+	DecInitialInfo *initialInfo;
+	int mapType = LINEAR_FRAME_MAP;
+	int fbHeight;
+	int fbStride;
+	FrameBufferFormat fbFormat;
+	FrameBufferFormat wtlFormat;
+	FrameBufferAllocInfo *fbAllocInfo;
+	FrameBuffer *fbUser;
+	struct rtkve1_dpb_t *dpb = NULL;
+	unsigned int clrDispFlagIndex = 0;
+	unsigned long clrDispFlagPhysAddr = 0;
+
+	if ((pCtx == NULL) || (pDpb == NULL)) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"invalid parameters.pCtx:0x%px.pDpb:0x%px\n",
+			pCtx,pDpb);
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+	dpb = (struct rtkve1_dpb_t *)pDpb;
+
+	if ((ctx->decHandle == NULL) || (ctx->fbAllocInfo == NULL) || (ctx->fbUser == NULL)) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"ctx->decHandle == NULL || ctx->fbAllocInfo == NULL || ctx->fbUser == NULL\n");
+		return -1;
+	}
+
+	decOP = (DecOpenParam *)ctx->decOP;
+	initialInfo = (DecInitialInfo *)ctx->initialInfo;
+	fbAllocInfo = (FrameBufferAllocInfo *)ctx->fbAllocInfo;
+
+	fbFormat = FORMAT_420;
+	wtlFormat = FORMAT_420;
+
+	if ((mapType == TILED_FRAME_V_MAP) && (decOP->wtlEnable == 0) &&
+		(decOP->tiled2LinearEnable == 0)) {
+		// trace VPU_GetFrameBufSize -> ProductCalculateFrameBufSize -> CalcLumaSize
+		// if TILED_FRAME_V_MAP and CODA980, VPU force use 64 align to calculate the frame buffer height (unit_size_ver_lum),
+		// it will influence the U_addr of YUV_STATE
+		fbHeight = VPU_ALIGN64(initialInfo->picHeight);
+	} else {
+		fbHeight = VPU_ALIGN32(initialInfo->picHeight);
+	}
+	fbStride = CalcStride(initialInfo->picWidth, initialInfo->picHeight,
+				fbFormat, decOP->cbcrInterleave,
+				(TiledMapType)mapType, 0);
+
+	if (fbHeight == 0 || fbStride == 0) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"incorrect fbHeight:%d.fbStride:%d.framebufSize:%d\n",
+			fbHeight, fbStride, ctx->framebufSize);
+		return -1;
+	}
+
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"cntCap2Dpb:%d.capReqBufsCnt:%d.regFbCount:%d\n",
+		ctx->cntCap2Dpb, ctx->capReqBufsCnt, ctx->regFbCount);
+
+	if (dpb->size < ctx->framebufSize) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"dpb.size:%u < expected framebufSize:%d\n",
+			dpb->size,
+			ctx->framebufSize);
+		WARN_ON(1);
+		return -1;
+	}
+
+	mutex_lock(&ctx->ve1_dma_mutex);
+	dpb->regIndex = ctx->regFbCount;
+	dpb->status |= RTKVE1_DPB_ST_REG;
+	fbUser = ((FrameBuffer *)ctx->fbUser) + ctx->regFbCount;
+	fbUser->size = dpb->size;
+	fbUser->bufY = dpb->phys_addr;
+	fbUser->bufCb = -1;
+	fbUser->bufCr = -1;
+	fbUser->updateFbInfo = TRUE;
+	clrDispFlagIndex = ctx->regFbCount;
+	clrDispFlagPhysAddr = dpb->phys_addr;
+	ctx->regFbCount++;
+	mutex_unlock(&ctx->ve1_dma_mutex);
+
+	ret = VPU_DecAllocateFrameBuffer((DecHandle)ctx->decHandle,
+			*((FrameBufferAllocInfo *)fbAllocInfo),
+			(FrameBuffer *)ctx->fbUser);
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"af VPU_DecAllocateFrameBuffer.ret:%d\n", ret);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"VPU_DecAllocateFrameBuffer fail.ret:%d\n", ret);
+		return -1;
+	}
+	ve1_dbg(
+		VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"fbUser[%d].bufY:0x%x.size:%d.myIndex:%d.stride:%d.h:%d.seqNo:%d\n",
+		(ctx->regFbCount-1), fbUser->bufY, fbUser->size, fbUser->myIndex,
+		fbUser->stride, fbUser->height, ctx->currSequenceNo);
+
+	ret = VPU_DecRegisterFrameBuffer((DecHandle)ctx->decHandle,
+			(FrameBuffer *)ctx->fbUser,
+			ctx->capReqBufsCnt, fbStride, fbHeight,
+			mapType);
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"af VPU_DecRegisterFrameBuffer.ret:%d\n", ret);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"VPU_DecRegisterFrameBuffer fail.ret:%d\n", ret);
+		return -1;
+	}
+
+	ret = VPU_DecClrDispFlag((DecHandle)ctx->decHandle, clrDispFlagIndex);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"VPU_DecClrDispFlag fail.ret:%d\n", ret);
+		return -1;
+	}
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"VPU_DecClrDispFlag(%d).phys_addr:0x%lx\n",
+		clrDispFlagIndex, clrDispFlagPhysAddr);
+
+	return ret;
+}
+
+int rtkve1_check_new_dpb(void *pCtx)
+{
+	int ret = 0;
+	struct ve1_ctx *ctx;
+	struct rtkve1_dpb_t *dpb_unreg = NULL;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"invalid parameters.pCtx:0x%px\n",
+			pCtx);
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	do {
+		mutex_lock(&ctx->ve1_dma_mutex);
+		dpb_unreg = (struct rtkve1_dpb_t *)rtkve1_find_dpb_unreg((void *)ctx);
+		mutex_unlock(&ctx->ve1_dma_mutex);
+		if (dpb_unreg == NULL) {
+			break;
+		}
+		ret = rtkve1_register_new_dpb(pCtx, dpb_unreg);
+		if (ret != 0) {
+			ve1_err(VE1_WRAPPER_TAG,
+				"rtkve1_register_new_dpb() fail.ret:%d\n",
+				ret);
+			break;
+		}
+	} while (1);
+
+	return ret;
+}
+
+void rtkve1_flush_dpbs(void *pCtx)
+{
+	struct ve1_ctx *ctx;
+	int i = 0;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "invalid parameters.pCtx:0x%px\n",
+			pCtx);
+		return;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	mutex_lock(&ctx->ve1_dma_mutex);
+	//rtkve1_show_dpbs(ctx);
+	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
+		if ((ctx->dpb[i].seqNo == ctx->currSequenceNo) &&
+			IS_RTKVE1_DPB_VALID(ctx->dpb[i].status) &&
+			IS_RTKVE1_DPB_REG(ctx->dpb[i].status) &&
+			!IS_RTKVE1_DPB_DQ(ctx->dpb[i].status)) {
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"v4l2_m2m_buf_done.status:0x%x.regIndex:%d.vb2_v4l2_buf:0x%px.phys_addr:0x%lx.seqNo:%u\n",
+				ctx->dpb[i].status,
+				ctx->dpb[i].regIndex,
+				ctx->dpb[i].vb2_v4l2_buf,
+				ctx->dpb[i].phys_addr,
+				ctx->dpb[i].seqNo);
+			v4l2_m2m_buf_done(
+				(struct vb2_v4l2_buffer *)(ctx->dpb[i].vb2_v4l2_buf),
+				VB2_BUF_STATE_ERROR);
+		}
+		// for those cap_bufs which cap_qbuf before new seq inited after seq changed, its size may not match new seq
+		if (IS_RTKVE1_DPB_VALID(ctx->dpb[i].status) &&
+			!IS_RTKVE1_DPB_REG(ctx->dpb[i].status)) {
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"v4l2_m2m_buf_done.status:0x%x.regIndex:%d.vb2_v4l2_buf:0x%px.phys_addr:0x%lx.seqNo:%u\n",
+				ctx->dpb[i].status,
+				ctx->dpb[i].regIndex,
+				ctx->dpb[i].vb2_v4l2_buf,
+				ctx->dpb[i].phys_addr,
+				ctx->dpb[i].seqNo);
+			v4l2_m2m_buf_done(
+				(struct vb2_v4l2_buffer *)(ctx->dpb[i].vb2_v4l2_buf),
+				VB2_BUF_STATE_ERROR);
+		}
+		if (IS_RTKVE1_DPB_VALID(ctx->dpb[i].status)) {
+			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			//	"clear valid status.status:0x%x.regIndex:%d.vb2_v4l2_buf:0x%px.phys_addr:0x%lx.seqNo:%u\n",
+			//	ctx->dpb[i].status,
+			//	ctx->dpb[i].regIndex,
+			//	ctx->dpb[i].vb2_v4l2_buf,
+			//	ctx->dpb[i].phys_addr,
+			//	ctx->dpb[i].seqNo);
+			ctx->dpb[i].status &= ~RTKVE1_DPB_ST_VALID;
+		}
+		if (IS_RTKVE1_DPB_DQ(ctx->dpb[i].status)) {
+			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			//	"clear dq status.status:0x%x.regIndex:%d.vb2_v4l2_buf:0x%px.phys_addr:0x%lx.seqNo:%u\n",
+			//	ctx->dpb[i].status,
+			//	ctx->dpb[i].regIndex,
+			//	ctx->dpb[i].vb2_v4l2_buf,
+			//	ctx->dpb[i].phys_addr,
+			//	ctx->dpb[i].seqNo);
+			ctx->dpb[i].status &= ~RTKVE1_DPB_ST_DQ;
+		}
+		if (IS_RTKVE1_DPB_WAIT_RECYCLE(ctx->dpb[i].status)) {
+			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			//	"clear wait recycle status.status:0x%x.regIndex:%d.vb2_v4l2_buf:0x%px.phys_addr:0x%lx.seqNo:%u\n",
+			//	ctx->dpb[i].status,
+			//	ctx->dpb[i].regIndex,
+			//	ctx->dpb[i].vb2_v4l2_buf,
+			//	ctx->dpb[i].phys_addr,
+			//	ctx->dpb[i].seqNo);
+			ctx->dpb[i].status &= ~RTKVE1_DPB_ST_WAIT_RECYCLE;
+		}
+	}
+
+	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
+		if ((ctx->dpb[i].seqNo != ctx->currSequenceNo) &&
+		    IS_RTKVE1_DPB_VALID(ctx->dpb[i].status)) {
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"unexpected different dpb seqNo.status:0x%x.regIndex:%d.vb2_v4l2_buf:0x%px.phys_addr:0x%lx.seqNo:%u\n",
+				ctx->dpb[i].status,
+				ctx->dpb[i].regIndex,
+				ctx->dpb[i].vb2_v4l2_buf,
+				ctx->dpb[i].phys_addr,
+				ctx->dpb[i].seqNo);
+		}
+	}
+	//rtkve1_show_dpbs(ctx);
+	mutex_unlock(&ctx->ve1_dma_mutex);
+}
+#if 0
+int ve1_alloc_frame_buffer(void *pCtx, unsigned int size,
+			   unsigned long *phys_addr)
+{
+	int ret = -1;
+	struct ve1_ctx *ctx;
+
+	if ((pCtx == NULL) || (size == 0) || (phys_addr == NULL)) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"invalid parameters.pCtx:0x%px.size:%d.phys_addr:0x%px\n",
+			pCtx, size, phys_addr);
+		return ret;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	mutex_lock(&ctx->ve1_dma_mutex);
+	do {
+		int i = 0;
+		unsigned int flags = 0;
+		dma_addr_t dma_phys_addr = 0;
+		void *virt_addr = NULL;
+		ve1_mem_reg_entry_t *entry;
+
+		if (ctx->is_svp) {
+			flags = RTK_FLAG_NONCACHED | RTK_FLAG_HWIPACC |
+				RTK_FLAG_PROTECTED_V2_VO_POOL;
+		} else {
+			flags = RTK_FLAG_NONCACHED | RTK_FLAG_HWIPACC |
+				RTK_FLAG_SCPUACC;
+		}
+
+		for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
+			if (IS_RTKVE1_DPB_EMPTY(ctx->dpb[i].status)) {
+				break;
+			}
+		}
+		if (i == VE1_ION_STRUCT_NUM) {
+			ve1_err(VE1_WRAPPER_TAG,
+				"all ve1_ion_buffer[] are used\n");
+			break;
+		}
+
+		/* We can't limit the address from dma_alloc_coherent when size <= 4096 */
+		if (size < SZ_8K)
+			size = SZ_8K;
+
+		virt_addr = dma_alloc_coherent(ctx->pdev, PAGE_ALIGN(size),
+					       &dma_phys_addr,
+					       (GFP_DMA | GFP_KERNEL));
+		if (virt_addr == NULL) {
+			ve1_err(VE1_WRAPPER_TAG,
+				"dma_alloc_coherent() fail.size:%d(%d).flags:0x%x\n",
+				PAGE_ALIGN(size), size, flags);
+			break;
+		}
+		ctx->totIonAllocatedBytes += PAGE_ALIGN(size);
+
+		*phys_addr = (unsigned long)dma_phys_addr;
+
+		ctx->dpb[i].size = PAGE_ALIGN(size);
+		ctx->dpb[i].status |= RTKVE1_DPB_ST_VALID;
+		ctx->dpb[i].phys_addr = (unsigned long)*phys_addr;
+		ctx->dpb[i].virt_addr = (unsigned long)virt_addr;
+
+		// register dpb[i] to ve1_mem
+		entry = kzalloc(sizeof(ve1_mem_reg_entry_t), GFP_KERNEL);
+		if (entry) {
+			entry->dev = ctx->pdev;
+			entry->phys_addr = ctx->dpb[i].phys_addr;
+			entry->addr = (void *) ctx->dpb[i].virt_addr;
+			entry->size = ctx->dpb[i].size;
+			ve1_mem_reg_add(entry);
+			ctx->dpb[i].reg_entry = (void *)entry;
+		}
+
+		ret = i;
+		break;
+	} while (0);
+	mutex_unlock(&ctx->ve1_dma_mutex);
+
+	return ret;
+}
+
+void ve1_free_frame_buffer(void *pCtx, unsigned long phys_addr)
+{
+	struct ve1_ctx *ctx;
+
+	if ((pCtx == NULL) || (phys_addr == 0)) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"invalid parameters.pCtx:0x%px.phys_addr:0x%lx\n", pCtx,
+			phys_addr);
+		return;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	mutex_lock(&ctx->ve1_dma_mutex);
+	do {
+		int i = 0;
+
+		for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
+			if (ctx->dpb[i].phys_addr == phys_addr) {
+				break;
+			}
+		}
+		if (i == VE1_ION_STRUCT_NUM) {
+			ve1_err(VE1_WRAPPER_TAG,
+				"not find phys_addr:0x%lx in dpb\n", phys_addr);
+			break;
+		}
+
+		if (ctx->dpb[i].reg_entry) {
+			ve1_mem_reg_remove(phys_addr);
+			kfree(ctx->dpb[i].reg_entry);
+		}
+
+		if (ctx->dpb[i].virt_addr) {
+			dma_free_coherent(ctx->pdev, ctx->dpb[i].size,
+					  (void *)ctx->dpb[i].virt_addr,
+					  (dma_addr_t)phys_addr);
+			ctx->totIonAllocatedBytes -= ctx->dpb[i].size;
+		}
+
+		memset(&ctx->dpb[i], 0, sizeof(struct rtkve1_dpb_t));
+	} while (0);
+	mutex_unlock(&ctx->ve1_dma_mutex);
+}
+#endif
+
+#ifdef VPU_GET_CC
+int ve1_enable_userdata(struct ve1_ctx *ctx)
+{
+	int ret = 0;
+	vpu_buffer_t vdb;
+	DecHandle decHandle = NULL;
+	DecOpenParam *pDecOp;
+
+	if (ctx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "invalid parameters.ctx:0x%px\n", ctx);
+		return VE1_DEC_RETURN_INVALID;
+	}
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "decHandle == NULL\n");
+		return -1;
+	}
+	decHandle = (DecHandle)ctx->decHandle;
+	pDecOp = (DecOpenParam *)ctx->decOP;
+
+	if (ctx->userDataBufPhysAddr == 0) {
+		unsigned int nBufSize =
+			USER_DATA_SRC_BUF_SIZE; //(pDecOp->bitstreamFormat == STD_MPEG2 ? VPU_CC_BUF_SIZE : MVC_USERDATA_BUF_SIZE);
+		unsigned int codec_type =
+			(pDecOp->bitstreamFormat == STD_MPEG2 ? ENUM_CC_MPGE2 :
+								ENUM_CC_H264);
+		memset(&vdb, 0, sizeof(vpu_buffer_t));
+		vdb.size = SIZE_REPORT_BUF;
+		vdb.req_spec_region = 0;
+		if (ctx->is_svp) {
+			vdb.req_spec_region = VE_SECURE_PROTECTION;
+		}
+
+		if (vdi_allocate_dma_memory(VE1_COREIDX, &vdb, ctx->filp) < 0) {
+			ve1_err(VE1_WRAPPER_TAG,
+				"vdi_allocate_dma_memory fail\n");
+			return VE1_DEC_RETURN_INVALID;
+		}
+		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			"vdi_allocate_dma_memory userdata(0x%lx,0x%lx,0x%lx,%d,%d)\n",
+			vdb.phys_addr, vdb.virt_addr, vdb.base, vdb.size,
+			vdb.req_spec_region);
+
+		ctx->userDataBufSize = vdb.size;
+		ctx->userDataBufPhysAddr = vdb.phys_addr;
+		ctx->pUserDataBufVirtAddr = (void *)vdb.virt_addr;
+		if (ctx->is_svp) {
+			ta_TEEapi_OMX_CC_API(
+				(struct tee_context *)decHandle->teeapi_ctx,
+				decHandle->teeapi_tee_session,
+				ctx->userDataBufPhysAddr, ctx->pUserDataSrcBuf,
+				nBufSize, codec_type, ENUM_CC_AU);
+			ta_TEEapi_OMX_CC_API(
+				(struct tee_context *)decHandle->teeapi_ctx,
+				decHandle->teeapi_tee_session,
+				ctx->userDataBufPhysAddr, ctx->pUserDataSrcBuf,
+				nBufSize, codec_type, ENUM_CC_S);
+		}
+	}
+
+	ctx->userDataEnable = 1;
+	ctx->userDataReportMode = 0;
+	VPU_DecGiveCommand(decHandle, SET_ADDR_REP_USERDATA,
+			   &ctx->userDataBufPhysAddr);
+	VPU_DecGiveCommand(decHandle, SET_SIZE_REP_USERDATA,
+			   &ctx->userDataBufSize);
+	VPU_DecGiveCommand(decHandle, SET_USERDATA_REPORT_MODE,
+			   &ctx->userDataReportMode);
+	VPU_DecGiveCommand(decHandle, ENABLE_REP_USERDATA, 0);
+	ve1_info(
+		VE1_WRAPPER_TAG,
+		"alloc & enable ve1 userdata(size:%d,phys:0x%x,virt:0x%px).tot:%d\n",
+		ctx->userDataBufSize, ctx->userDataBufPhysAddr,
+		ctx->pUserDataBufVirtAddr, ctx->totIonAllocatedBytes);
+
+	return ret;
+}
+
+int ve1_get_userdata(struct ve1_ctx *ctx, unsigned char *pBuf,
+		     unsigned int nBufSize)
+{
+	int ret = 0;
+	DecOutputInfo *outputInfo = NULL;
+	unsigned int totalSize;
+
+	if ((ctx == NULL) || (pBuf == NULL) || (nBufSize == 0)) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"invalid parameters.ctx:0x%px.pBuf:0x%px.nBufSize:%d\n",
+			ctx, pBuf, nBufSize);
+		return -1;
+	}
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
+		return VE1_DEC_RETURN_INVALID;
+	}
+
+	if (ctx->outputInfo == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->outputInfo == NULL\n");
+		return VE1_DEC_RETURN_INVALID;
+	}
+	outputInfo = (DecOutputInfo *)ctx->outputInfo;
+
+	if (outputInfo->decOutputExtData.userDataSize) {
+		// The first USER_DATA_INFO_OFFSET bytes in user data buffer is header including userDataNum/userDataSize/userDataBufFull
+		// (userDataSize+7)/8*8: the actual user data bytes occupied are align to 8. If the user data size is 804, the actual bytes occupied are 808.
+		totalSize = (outputInfo->decOutputExtData.userDataSize + 7) /
+				    8 * 8 +
+			    USER_DATA_INFO_OFFSET;
+		if (totalSize > nBufSize) {
+			ve1_err(VE1_WRAPPER_TAG,
+				"buffer size:%d to get user data is smaller than user data size:%d\n",
+				nBufSize, totalSize);
+			return VE1_DEC_RETURN_INVALID;
+		}
+		vdi_read_memory(VE1_COREIDX, ctx->userDataBufPhysAddr, pBuf,
+				totalSize, VDI_LITTLE_ENDIAN);
+		ret = totalSize;
+	}
+	return ret;
+}
+#endif
+
+int VE1_DecInit(void *pCtx, void *videc_dev)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	struct ve1_ctx *ctx;
+	struct videc_dev *dev;
+	int productId;
+
+	if (pCtx == NULL || videc_dev == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL || videc_dev == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+	dev = (struct videc_dev *)videc_dev;
+
+	if (ctx->ve1DecState != VE1_STATE_DEC_UNINIT) {
+		ve1_err(VE1_WRAPPER_TAG, "invalid ve1DecState:%d\n",
+			ctx->ve1DecState);
+		return -1;
+	}
+
+	productId = VPU_GetProductId(VE1_COREIDX);
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "productId:%d\n", productId);
+	ret = VPU_Init(VE1_COREIDX, videc_dev);
+	ve1_info(VE1_WRAPPER_TAG, "af VPU_Init.ret:%d\n", ret);
+	if (ret == RETCODE_NOT_FOUND_BITCODE_PATH) {
+#if defined(ENABLE_TEE_DRM_FLOW)
+		ret = VPU_InitWithBitcodeProtect(VE1_COREIDX,
+				(const Uint16 *)dev->ve1fw_binary, dev->ve1fw_size_in_word,
+				NULL, NULL, ctx->filp);
+		ve1_info(VE1_WRAPPER_TAG,
+			 "af VPU_InitWithBitcodeProtect.ret:%d\n", ret);
+#else
+		ret = VPU_InitWithBitcode(VE1_COREIDX,
+				(const Uint16 *)dev->ve1fw_binary, dev->ve1fw_size_in_word, videc_dev);
+		ve1_info(VE1_WRAPPER_TAG, "af VPU_InitWithBitcode.ret:%d\n",
+			 ret);
+#endif
+	}
+	if (ret == RETCODE_SUCCESS || ret == RETCODE_CALLED_BEFORE) {
+		ctx->ve1DecState = VE1_STATE_DEC_INITED;
+		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			"ret:%d.set ve1DecState:%d\n", ret, ctx->ve1DecState);
+	} else {
+		ve1_err(VE1_WRAPPER_TAG, "unexpected ret:%d\n", ret);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+int VE1_DecOpen(void *pCtx, void *pParam)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	struct ve1_ctx *ctx;
+	struct ve1_decopen_param *param;
+	DecOpenParam *pDecOp;
+	CodStd codec_type;
+#ifdef VPU_GET_CC
+	int i;
+#endif
+	unsigned int version;
+	unsigned int revision;
+	unsigned int productId;
+
+	if ((pCtx == NULL) || (pParam == NULL)) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL or pParam == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+	param = (struct ve1_decopen_param *)pParam;
+
+	if (ctx->ve1DecState != VE1_STATE_DEC_INITED &&
+	    ctx->ve1DecState != VE1_STATE_DEC_CLOSED) {
+		ve1_err(VE1_WRAPPER_TAG, "invalid ve1DecState:%d\n",
+			ctx->ve1DecState);
+		return -1;
+	}
+
+	VPU_GetVersionInfo(VE1_COREIDX, &version, &revision, &productId);
+    ve1_info(VE1_WRAPPER_TAG, "Firmware : CustomerCode: %04x | version : %d.%d.%d rev.%d\n",
+         (unsigned int)(version>>16), (unsigned int)((version>>(12))&0x0f), (unsigned int)((version>>(8))&0x0f), (unsigned int)((version)&0xff), revision);
+	ve1_info(VE1_WRAPPER_TAG, "Hardware : %04x\n", productId);
+	ve1_info(VE1_WRAPPER_TAG, "API      : %d.%d.%d\n\n", API_VERSION_MAJOR, API_VERSION_MINOR, API_VERSION_PATCH);
+
+	if (ctx->decOP == NULL) {
+		ctx->decOP = kzalloc(sizeof(DecOpenParam), GFP_KERNEL);
+		if (ctx->decOP == NULL) {
+			ve1_err(VE1_WRAPPER_TAG, "kzalloc decOP fail\n");
+			return -1;
+		}
+	}
+	pDecOp = (DecOpenParam *)ctx->decOP;
+
+	switch (param->src_fmt_fourcc) {
+	case V4L2_PIX_FMT_MPEG1:
+	case V4L2_PIX_FMT_MPEG2:
+		codec_type = STD_MPEG2;
+		break;
+	case V4L2_PIX_FMT_MPEG4:
+		codec_type = STD_MPEG4;
+		break;
+	case V4L2_PIX_FMT_VP8:
+		codec_type = STD_VP8;
+		break;
+	case V4L2_PIX_FMT_VC1_ANNEX_G:
+		codec_type = STD_VC1;
+		break;
+	case V4L2_PIX_FMT_VC1_ANNEX_L:
+		codec_type = STD_VC1;
+		break;
+	case V4L2_PIX_FMT_H263:
+		codec_type = STD_H263;
+		break;
+	case V4L2_PIX_FMT_H264:
+	default:
+		codec_type = STD_AVC;
+		break;
+	}
+
+	memset(pDecOp, 0, sizeof(DecOpenParam));
+	pDecOp->coreIdx = VE1_COREIDX;
+	pDecOp->bitstreamFormat = codec_type;
+	pDecOp->bitstreamBuffer = ctx->bitstream.paddr;
+	pDecOp->bitstreamBufferSize = ctx->bitstream.size;
+	ve1_info(VE1_WRAPPER_TAG,
+		 "bitstreamBuffer:0x%x.bitstreamBufferSize:%d\n",
+		 pDecOp->bitstreamBuffer, pDecOp->bitstreamBufferSize);
+	pDecOp->avcExtension = 0;
+	pDecOp->bitstreamMode = BS_MODE_PIC_END;
+
+	if (param->dst_fmt_fourcc == V4L2_PIX_FMT_NV21 ||
+	    param->dst_fmt_fourcc == V4L2_PIX_FMT_NV12) {
+		pDecOp->cbcrInterleave = 1;
+		if (param->dst_fmt_fourcc == V4L2_PIX_FMT_NV21) {
+			pDecOp->nv21 = 1;
+		}
+	}
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"src_fourcc:%4s.dst_fourcc:%4s.cbcrInterleave:%d.nv21:%d\n",
+		(char *)&param->src_fmt_fourcc, (char *)&param->dst_fmt_fourcc,
+		pDecOp->cbcrInterleave, pDecOp->nv21);
+
+	pDecOp->cbcrOrder = CBCR_ORDER_NORMAL;
+	pDecOp->frameEndian = VPU_FRAME_ENDIAN;
+	pDecOp->streamEndian = VPU_STREAM_ENDIAN;
+	pDecOp->bwbEnable = VPU_ENABLE_BWB;
+	pDecOp->filp = ctx->filp;
+	pDecOp->frameWidth = param->width;
+	pDecOp->frameHeight = param->height;
+
+	pDecOp->isUseProtectBuffer = ctx->is_svp;
+
+	ve1_info(
+		VE1_WRAPPER_TAG,
+		"------------------------------ DECODER OPTIONS ------------------------------\n");
+	ve1_info(VE1_WRAPPER_TAG, "[bitstreamFormat    ]: %d\n",
+		 pDecOp->bitstreamFormat);
+	ve1_info(VE1_WRAPPER_TAG, "[bitstreamBuffer    ]: 0x%x\n",
+		 pDecOp->bitstreamBuffer);
+	ve1_info(VE1_WRAPPER_TAG, "[bitstreamBufferSize]: %d\n",
+		 pDecOp->bitstreamBufferSize);
+	ve1_info(VE1_WRAPPER_TAG, "[mp4DeblkEnable     ]: %d\n",
+		 pDecOp->mp4DeblkEnable);
+	ve1_info(VE1_WRAPPER_TAG, "[avcExtension       ]: %d\n",
+		 pDecOp->avcExtension);
+	ve1_info(VE1_WRAPPER_TAG, "[mp4Class           ]: %d\n",
+		 pDecOp->mp4Class);
+	ve1_info(VE1_WRAPPER_TAG, "[tiled2LinearEnable ]: %d\n",
+		 pDecOp->tiled2LinearEnable);
+	ve1_info(VE1_WRAPPER_TAG, "[tiled2LinearMode   ]: %d\n",
+		 pDecOp->tiled2LinearMode);
+	ve1_info(VE1_WRAPPER_TAG, "[wtlEnable          ]: %d\n",
+		 pDecOp->wtlEnable);
+	ve1_info(VE1_WRAPPER_TAG, "[wtlMode            ]: %d\n",
+		 pDecOp->wtlMode);
+	ve1_info(VE1_WRAPPER_TAG, "[cbcrInterleave     ]: %d\n",
+		 pDecOp->cbcrInterleave);
+	ve1_info(VE1_WRAPPER_TAG, "[nv21               ]: %d\n", pDecOp->nv21);
+	ve1_info(VE1_WRAPPER_TAG, "[cbcrOrder          ]: %d\n",
+		 pDecOp->cbcrOrder);
+	ve1_info(VE1_WRAPPER_TAG, "[BWB                ]: %d\n",
+		 pDecOp->bwbEnable);
+	ve1_info(VE1_WRAPPER_TAG, "[frameEndian        ]: %d\n",
+		 pDecOp->frameEndian);
+	ve1_info(VE1_WRAPPER_TAG, "[streamEndian       ]: %d\n",
+		 pDecOp->streamEndian);
+	ve1_info(VE1_WRAPPER_TAG, "[bitstreamMode      ]: %d\n",
+		 pDecOp->bitstreamMode);
+	ve1_info(VE1_WRAPPER_TAG, "[coreIdx            ]: %d\n",
+		 pDecOp->coreIdx);
+	ve1_info(VE1_WRAPPER_TAG, "[vbWork.size        ]: %d\n",
+		 pDecOp->vbWork.size);
+	ve1_info(VE1_WRAPPER_TAG, "[vbWork.phys_addr   ]: 0x%lx\n",
+		 pDecOp->vbWork.phys_addr);
+	ve1_info(VE1_WRAPPER_TAG, "[vbWork.base        ]: 0x%lx\n",
+		 pDecOp->vbWork.base);
+	ve1_info(VE1_WRAPPER_TAG, "[vbWork.virt_addr   ]: 0x%lx\n",
+		 pDecOp->vbWork.virt_addr);
+	ve1_info(VE1_WRAPPER_TAG, "[fbc_mode           ]: %d\n",
+		 pDecOp->fbc_mode);
+	ve1_info(VE1_WRAPPER_TAG, "[virtAxiID          ]: %d\n",
+		 pDecOp->virtAxiID);
+	ve1_info(VE1_WRAPPER_TAG, "[bwOptimization     ]: %d\n",
+		 pDecOp->bwOptimization);
+	ve1_info(VE1_WRAPPER_TAG, "[afbceEnable        ]: %d\n",
+		 pDecOp->afbceEnable);
+	ve1_info(VE1_WRAPPER_TAG, "[afbceFormat        ]: %d\n",
+		 pDecOp->afbceFormat);
+	ve1_info(VE1_WRAPPER_TAG, "[isUseProtectBuffer ]: %d\n",
+		 pDecOp->isUseProtectBuffer);
+	ve1_info(
+		VE1_WRAPPER_TAG,
+		"-----------------------------------------------------------------------------\n");
+
+	ret = VPU_DecOpen((DecHandle *)&ctx->decHandle, pDecOp);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG, "VPU_DecOpen fail.ret:%d\n", ret);
+		return -1;
+	}
+	ve1_info(VE1_WRAPPER_TAG, "af VPU_DecOpen.ret:%d.handle:0x%px\n", ret,
+		 ctx->decHandle);
+
+#ifdef VPU_GET_CC
+	if ((pDecOp->bitstreamFormat == STD_AVC) ||
+	    (pDecOp->bitstreamFormat == STD_MPEG2)) {
+		// allocate user data buffer and enable ve1 user data
+		ctx->pUserDataSrcBuf = (unsigned char *)kmalloc(
+			USER_DATA_SRC_BUF_SIZE, GFP_KERNEL);
+		ve1_enable_userdata(ctx);
+	}
+#endif
+
+	ctx->ve1DecState = VE1_STATE_DEC_OPENED;
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "[-] set ve1DecState:%d\n",
+		ctx->ve1DecState);
+
+#ifdef VPU_GET_CC
+	if (pDecOp->bitstreamFormat == STD_MPEG2 ||
+	    pDecOp->bitstreamFormat == STD_AVC) {
+		for (i = 0; i < MPEG2_CC_REG_FRAME_MAX; i++) {
+			ctx->m_CCDecodeOrderWp[i] = kmalloc(
+				USER_DATA_SRC_BUF_SIZE +
+					USER_DATA_NUM_MAX * RTK_CC_HEADER_SIZE,
+				GFP_KERNEL);
+			if (ctx->m_CCDecodeOrderWp[i])
+				memset(ctx->m_CCDecodeOrderWp[i], 0,
+				       USER_DATA_SRC_BUF_SIZE +
+					       USER_DATA_NUM_MAX *
+						       RTK_CC_HEADER_SIZE);
+		}
+		ctx->cc_error_count = 0;
+
+		cc_data_channel_init();
+	}
+#endif
+	return ret;
+}
+
+int VE1_DecGetRdWrPtr(void *pCtx)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	struct ve1_ctx *ctx;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decHandle != NULL) {
+		if (((DecOpenParam *)ctx->decOP)->bitstreamMode ==
+		    BS_MODE_PIC_END) {
+			ret = VPU_DecGetBitstreamBufferEx(
+				(DecHandle)ctx->decHandle, &ctx->vpuRdPtr,
+				&ctx->vpuWrPtr, &ctx->vpuBsRingRoom);
+		} else {
+			ret = VPU_DecGetBitstreamBuffer(
+				(DecHandle)ctx->decHandle, &ctx->vpuRdPtr,
+				&ctx->vpuWrPtr, &ctx->vpuBsRingRoom);
+		}
+	}
+
+	return ret;
+}
+
+int VE1_SetStreamEnd(void *pCtx)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	struct ve1_ctx *ctx;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
+		return -1;
+	}
+
+	ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
+					   STREAM_END_SIZE);
+	ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
+		"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+		ret, STREAM_END_SIZE, ctx->accuBsFeedBytes);
+	return ret;
+}
+
+int VE1_DecSeqInit(void *pCtx)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	struct ve1_ctx *ctx;
+	BOOL seqInitEscape = FALSE;
+	int int_reason;
+	int bSeqInited = 0;
+	DecInitialInfo *initialInfo;
+	unsigned long long pts_unit = PTS_UNIT;
+	unsigned int fps;
+	unsigned long valid_data = 0;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
+		return -1;
+	}
+
+	VE1_DecGetRdWrPtr(ctx);
+	if (((DecOpenParam *)ctx->decOP)->bitstreamMode == BS_MODE_INTERRUPT) {
+		valid_data = ve1_ring_valid_data(ctx->bitstream.paddr,
+						 ctx->bitstream.paddr +
+							 ctx->bitstream.size,
+						 ctx->vpuRdPtr, ctx->vpuWrPtr);
+		if (valid_data < 1024) {
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"valid data size:%ld < 1024.vpuRdPtr:0x%x.vpuWrPtr:0x%x\n",
+				valid_data, ctx->vpuRdPtr, ctx->vpuWrPtr);
+			ctx->bBufEmptyFlag = true;
+			return ret;
+		}
+	}
+
+	if (ctx->initialInfo == NULL) {
+		ctx->initialInfo = kzalloc(sizeof(DecInitialInfo), GFP_KERNEL);
+		if (ctx->initialInfo == NULL) {
+			ve1_err(VE1_WRAPPER_TAG, "kzalloc initialInfo fail\n");
+			return -1;
+		}
+	}
+	initialInfo = (DecInitialInfo *)ctx->initialInfo;
+
+	if (seqInitEscape) {
+		if (ctx->ve1DecState >= VE1_STATE_DEC_OPENED &&
+		    ctx->ve1DecState != VE1_STATE_DEC_SEQ_INIT_ISSUED) {
+			ret = VPU_DecSetEscSeqInit((DecHandle)ctx->decHandle,
+						   seqInitEscape);
+			if (ret != RETCODE_SUCCESS) {
+				ve1_err(VE1_WRAPPER_TAG,
+					"VPU_DecSetEscSeqInit fail.ret:%d\n",
+					ret);
+				return -1;
+			}
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"af VPU_DecSetEscSeqInit.ret:%d\n", ret);
+
+			ret = VPU_DecGetInitialInfo((DecHandle)ctx->decHandle,
+						    initialInfo);
+			if (ret != RETCODE_SUCCESS) {
+				ctx->ve1DecState = VE1_STATE_DEC_SEQ_INIT_DONE;
+				ve1_err(VE1_WRAPPER_TAG,
+					"VPU_DecGetInitialInfo fail.ret:%d\n",
+					ret);
+				return -1;
+			} else {
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"af VPU_DecGetInitialInfo.ret:%d\n",
+					ret);
+				ctx->seqInited = 1;
+				ctx->ve1DecState = VE1_STATE_DEC_SEQ_INIT_DONE;
+				ctx->currSequenceNo++;
+				ctx->timeTick = div_u64(pts_unit * 100, 2997);
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"set ve1DecState:%d.currSequenceNo:%d.timeTick:%lld\n",
+					ctx->ve1DecState, ctx->currSequenceNo,
+					ctx->timeTick);
+
+				if (initialInfo->fRateDenominator != -1) {
+					fps = initialInfo->fRateNumerator *
+					      100 /
+					      initialInfo->fRateDenominator;
+					ctx->timeTick =
+						div_u64(pts_unit * 100, fps);
+				}
+
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"min:%d.%dx%d(%dx%d).fps(%d/%d).timeTick:%lld\n",
+					initialInfo->minFrameBufferCount,
+					initialInfo->picWidth,
+					initialInfo->picHeight,
+					(initialInfo->picCropRect.right -
+					 initialInfo->picCropRect.left),
+					(initialInfo->picCropRect.bottom -
+					 initialInfo->picCropRect.top),
+					initialInfo->fRateNumerator,
+					initialInfo->fRateDenominator,
+					ctx->timeTick);
+			}
+		}
+	} else {
+		if (ctx->ve1DecState == VE1_STATE_DEC_SEQ_INIT_ISSUED) {
+			goto waitSeqInitDone;
+		}
+
+		if (ctx->ve1DecState >= VE1_STATE_DEC_OPENED &&
+		    ctx->ve1DecState != VE1_STATE_DEC_SEQ_INIT_ISSUED) {
+			ret = VPU_DecIssueSeqInit((DecHandle)ctx->decHandle);
+			if (ret != RETCODE_SUCCESS) {
+				ve1_err(VE1_WRAPPER_TAG,
+					"VPU_DecIssueSeqInit fail.ret:%d\n",
+					ret);
+				return -1;
+			}
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"af VPU_DecIssueSeqInit.ret:%d\n", ret);
+			ctx->ve1DecState = VE1_STATE_DEC_SEQ_INIT_ISSUED;
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"set ve1DecState:%d\n", ctx->ve1DecState);
+		}
+
+	waitSeqInitDone:
+		while (1) {
+			int_reason = VPU_WaitInterrupt(VE1_COREIDX, 10);
+			if (int_reason == -1) {
+				int_reason = 0;
+			}
+			if (int_reason) {
+				VPU_ClearInterrupt(VE1_COREIDX);
+				if (int_reason & (1 << INT_BIT_SEQ_INIT)) {
+					ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+						"INT_BIT_SEQ_INIT\n");
+					bSeqInited = 1;
+				} else if (int_reason &
+					   (1 << INT_BIT_BIT_BUF_EMPTY)) {
+					ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+						"INT_BIT_BIT_BUF_EMPTY\n");
+					ctx->bBufEmptyFlag = true;
+				}
+				break;
+			}
+		}
+
+		if (bSeqInited) {
+			ret = VPU_DecCompleteSeqInit((DecHandle)ctx->decHandle,
+						     initialInfo);
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"af VPU_DecCompleteSeqInit.ret:%d.seqInitErrReason:0x%x\n",
+				ret, initialInfo->seqInitErrReason);
+			if (ret != RETCODE_SUCCESS) {
+				ctx->ve1DecState = VE1_STATE_DEC_SEQ_INIT_DONE;
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"VPU_DecCompleteSeqInit fail.ret:%d\n",
+					ret);
+
+				if (((DecOpenParam *)ctx->decOP)->bitstreamMode ==
+					    BS_MODE_ROLLBACK &&
+				    initialInfo->seqInitErrReason & (1 << 31)) {
+					// this happens only ROLLBACK mode case
+				}
+				return -1;
+			}
+			ctx->seqInited = 1;
+			ctx->ve1DecState = VE1_STATE_DEC_SEQ_INIT_DONE;
+			ctx->currSequenceNo++;
+			ctx->timeTick = div_u64(pts_unit * 100, 2997);
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"set ve1DecState:%d.currSequenceNo:%d.timeTick:%lld\n",
+				ctx->ve1DecState, ctx->currSequenceNo,
+				ctx->timeTick);
+
+			if (initialInfo->fRateDenominator != -1) {
+				fps = initialInfo->fRateNumerator * 100 /
+				      initialInfo->fRateDenominator;
+				ctx->timeTick = div_u64(pts_unit * 100, fps);
+			}
+
+			ve1_info(
+				VE1_WRAPPER_TAG,
+				"min:%d.%dx%d(%dx%d).fps(%d/%d).timeTick:%lld\n",
+				initialInfo->minFrameBufferCount,
+				initialInfo->picWidth, initialInfo->picHeight,
+				(initialInfo->picCropRect.right -
+				 initialInfo->picCropRect.left),
+				(initialInfo->picCropRect.bottom -
+				 initialInfo->picCropRect.top),
+				initialInfo->fRateNumerator,
+				initialInfo->fRateDenominator, ctx->timeTick);
+
+			// update vpuRdPtr to bsRdPtr
+			VE1_DecGetRdWrPtr(pCtx);
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"vpuRdPtr:0x%x.vpuWrPtr:0x%x\n",
+				ctx->vpuRdPtr, ctx->vpuWrPtr);
+			ctx->bsRdPtr = ctx->vpuRdPtr;
+		} else {
+			ve1_err(VE1_WRAPPER_TAG, "seq init failed\n");
+			return -1;
+		}
+	}
+
+	return ret;
+}
+
+int VE1_DecStartDecode(void *pCtx)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	struct ve1_ctx *ctx;
+	unsigned long valid_data = 0;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
+		return -1;
+	}
+
+	if (ctx->decParam == NULL) {
+		ctx->decParam = kzalloc(sizeof(DecParam), GFP_KERNEL);
+		if (ctx->decParam == NULL) {
+			ve1_err(VE1_WRAPPER_TAG, "kzalloc decParam fail\n");
+			return -1;
+		}
+	}
+
+	if (ctx->seqInited &&
+		(ctx->ve1DecState == VE1_STATE_DEC_SET_DPB ||
+		ctx->ve1DecState == VE1_STATE_DEC_PIC_DONE)) {
+		VE1_DecGetRdWrPtr(ctx);
+		if ((((DecOpenParam *)ctx->decOP)->bitstreamMode ==
+		     BS_MODE_INTERRUPT) &&
+		    (!ctx->streamEnd)) {
+			valid_data = ve1_ring_valid_data(
+				ctx->bitstream.paddr,
+				ctx->bitstream.paddr + ctx->bitstream.size,
+				ctx->vpuRdPtr, ctx->vpuWrPtr);
+			if (valid_data < 1024) {
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"valid data size:%ld < 1024.vpuRdPtr:0x%x.vpuWrPtr:0x%x\n",
+					valid_data, ctx->vpuRdPtr,
+					ctx->vpuWrPtr);
+				ctx->bBufEmptyFlag = true;
+				return ret;
+			}
+		} else if (((DecOpenParam *)ctx->decOP)->bitstreamMode ==
+			   BS_MODE_PIC_END) {
+			if ((ctx->vpuRdPtr == ctx->vpuWrPtr) &&
+			    (!ctx->streamEnd)) {
+				ctx->bBufEmptyFlag = true;
+				return ret;
+			}
+		}
+
+		rtkve1_recycle_dpb(ctx);
+		ret = VPU_DecStartOneFrame((DecHandle)ctx->decHandle,
+					   (DecParam *)ctx->decParam);
+		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			"af VPU_DecStartOneFrame.ret:%d\n", ret);
+		if (ret != RETCODE_SUCCESS) {
+			ve1_err(VE1_WRAPPER_TAG,
+				"VPU_DecStartOneFrame fail.ret:%d\n", ret);
+			return -1;
+		}
+		ctx->ve1DecState = VE1_STATE_DEC_START_DEC_ISSUED;
+		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "set ve1DecState:%d\n",
+			ctx->ve1DecState);
+	}
+
+	return ret;
+}
+
+int VE1_DecWaitPicDone(void *pCtx)
+{
+	struct ve1_ctx *ctx;
+	int bPicDone = 0;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+	ctx->timeoutCount = 0;
+
+	while (1) {
+		ctx->int_reason = VPU_WaitInterrupt(VE1_COREIDX, 10);
+		if (ctx->int_reason == -1) {
+			ctx->int_reason = 0;
+			ctx->timeoutCount++;
+			if (ctx->timeoutCount > 10000) {
+				ve1_err(VE1_WRAPPER_TAG,
+					"wait interrupt timeoutCount:%d > 10000\n",
+					ctx->timeoutCount);
+				VPU_DecUpdateBitstreamBuffer(
+					(DecHandle)ctx->decHandle,
+					STREAM_END_SIZE);
+				VPU_SWReset(VE1_COREIDX, SW_RESET_FORCE,
+					    (DecHandle)ctx->decHandle);
+				VPU_DecUpdateBitstreamBuffer(
+					(DecHandle)ctx->decHandle,
+					STREAM_END_CLEAR_FLAG);
+				bPicDone = -1;
+				break;
+			}
+		}
+		if (ctx->int_reason) {
+			if (ctx->bGotNextField) {
+				ctx->bGotNextField = false;
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"bWaitNextField.clear bGotNextField.int_reason:0x%x\n",
+					ctx->int_reason);
+			}
+			ctx->timeoutCount = 0;
+			if (ctx->int_reason & (1 << INT_BIT_PIC_RUN)) {
+				VPU_ClearInterrupt(VE1_COREIDX);
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"INT_BIT_PIC_RUN(0x%x)\n",
+					ctx->int_reason);
+				ctx->int_reason = 0;
+				bPicDone = 1;
+			} else if (ctx->int_reason &
+				   (1 << INT_BIT_BIT_BUF_EMPTY)) {
+				VPU_ClearInterrupt(VE1_COREIDX);
+				VE1_DecGetRdWrPtr(ctx);
+				ctx->bufEmptyVpuWrPtr = ctx->vpuWrPtr;
+				ctx->bBufEmptyFlag = true;
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"INT_BIT_BIT_BUF_EMPTYY(0x%x).bufEmptyVpuWrPtr:0x%x\n",
+					ctx->int_reason, ctx->bufEmptyVpuWrPtr);
+			} else if (ctx->int_reason & (1 << INT_BIT_DEC_FIELD)) {
+				if (ctx->bPostponeUpBs) {
+					ctx->bPostponeUpBs = false;
+					ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+						"bPostponeUpBs.clear bPostponeUpBs.int_reason:0x%x\n",
+						ctx->int_reason);
+				}
+				VE1_DecGetRdWrPtr(ctx);
+				ctx->bWaitNextField = true;
+				ctx->bGotNextField = false;
+				ctx->fldDoneVpuRp = ctx->vpuRdPtr;
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"INT_BIT_DEC_FIELD(0x%x).bWaitNextField.frmNum:%u.fld_rp:0x%x.vpu(0x%x,0x%x)\n",
+					ctx->int_reason, ctx->decodedFrmNum,
+					ctx->fldDoneVpuRp, ctx->vpuRdPtr,
+					ctx->vpuWrPtr);
+			}
+			break;
+		}
+	}
+
+	return bPicDone;
+}
+
+void *rtkve1_find_dpb(void *pCtx, unsigned long dpb_paddr, unsigned int seqNo)
+{
+	int i = 0;
+	struct ve1_ctx *ctx;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return NULL;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	mutex_lock(&ctx->ve1_dma_mutex);
+	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
+		if ((ctx->dpb[i].seqNo == seqNo) &&
+		    (ctx->dpb[i].phys_addr == dpb_paddr)) {
+			mutex_unlock(&ctx->ve1_dma_mutex);
+			return (void *)&(ctx->dpb[i]);
+		}
+	}
+
+	mutex_unlock(&ctx->ve1_dma_mutex);
+	return NULL;
+}
+
+int VE1_UpdateDPBStatus(void *pCtx, unsigned int dpb_paddr,
+			 unsigned int sequenceNo, unsigned int status)
+{
+	int ret = 0;
+	struct ve1_ctx *ctx;
+#if defined(VE1_ALLOC_FRAME_BUFFER_BY_VDI)
+	vpu_buffer_t vdb;
+#endif
+	void *tmp_dpb = NULL;
+	struct rtkve1_dpb_t *dpb = NULL;
+	unsigned int regIndex = 0;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decHandle == NULL || ctx->decOP == NULL) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"ctx->decHandle == NULL || ctx->decOP == NULL\n");
+		return -1;
+	}
+
+	tmp_dpb = rtkve1_find_dpb(pCtx, dpb_paddr, sequenceNo);
+	if (!tmp_dpb) {
+		//ve1_err(VE1_WRAPPER_TAG, "can't find dpb_paddr:0x%x in dpb[]\n",
+		//	dpb_paddr);
+		return -1;
+	}
+	dpb = (struct rtkve1_dpb_t *)tmp_dpb;
+	regIndex = dpb->regIndex;
+
+	mutex_lock(&ctx->ve1_dma_mutex);
+	// recycle the frame buffer
+	if (IS_RTKVE1_DPB_VALID(status)) {
+		dpb->status |= RTKVE1_DPB_ST_VALID;
+		dpb->status &= ~RTKVE1_DPB_ST_DQ;
+		// recycle the frame buffer of previous sequence
+		if (sequenceNo < ctx->currSequenceNo) {
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"dpb_paddr:0x%x.vb2_v4l2_buf:0x%px.recycle prev seq dpb.status:0x%x.seq(%d,%d).regIndex:%d\n",
+				dpb_paddr, dpb->vb2_v4l2_buf, dpb->status,
+				sequenceNo, ctx->currSequenceNo, regIndex);
+		}
+		// recycle the frame buffer of current sequence
+		else if (sequenceNo == ctx->currSequenceNo) {
+			if (ctx->seqChangeDone) {
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"dpb_paddr:0x%x.vb2_v4l2_buf:0x%px.recycle prev seq dpb.status:0x%x.seq(%d,%d).regIndex:%d\n",
+					dpb_paddr, dpb->vb2_v4l2_buf, dpb->status,
+					sequenceNo, ctx->currSequenceNo, regIndex);
+			} else {
+				// normal case, call VPU_DecClrDispFlag() to recyle the frame buffer
+				dpb->status |= RTKVE1_DPB_ST_WAIT_RECYCLE;
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"dpb_paddr:0x%x.vb2_v4l2_buf:0x%px.set status:0x%x.seq(%d,%d).regIndex:%d\n",
+					dpb_paddr, dpb->vb2_v4l2_buf, dpb->status,
+					sequenceNo, ctx->currSequenceNo, regIndex);
+			}
+		} else {
+			ve1_err(VE1_WRAPPER_TAG,
+				"invalid sequenceNo:%d.currSequenceNo:%d\n",
+				sequenceNo, ctx->currSequenceNo);
+		}
+	}
+	// cap_dqbuf the frame buffer
+	else if (IS_RTKVE1_DPB_DQ(status)) {
+		if (sequenceNo <= ctx->currSequenceNo) {
+			dpb->status |= RTKVE1_DPB_ST_DQ;
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"dpb_paddr:0x%x.set status:0x%x.seq(%d,%d).regIndex:%d\n",
+				dpb_paddr, dpb->status, sequenceNo,
+				ctx->currSequenceNo, regIndex);
+		} else {
+			ve1_err(VE1_WRAPPER_TAG,
+				"invalid sequenceNo:%d.currSequenceNo:%d\n",
+				sequenceNo, ctx->currSequenceNo);
+		}
+	} else {
+		ve1_err(VE1_WRAPPER_TAG, "invalid status:0x%x\n", status);
+	}
+
+	mutex_unlock(&ctx->ve1_dma_mutex);
+	return ret;
+}
+
+void ve1_seq_change_free_fb(struct ve1_ctx *ctx)
+{
+	FrameBuffer *fbUser;
+#if defined(VE1_ALLOC_FRAME_BUFFER_BY_VDI)
+	vpu_buffer_t vdb;
+#endif
+	int i;
+	unsigned long flags;
+	struct ve1_displayable_frame *frame;
+
+	if (ctx == NULL || ctx->decHandle == NULL || ctx->decOP == NULL ||
+	    ctx->fbUser == NULL) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"ctx == NULL || ctx->decHandle == NULL || ctx->decOP == NULL || ctx->fbUser == NULL\n");
+		return;
+	}
+
+	if (((DecOpenParam *)ctx->decOP)->wtlEnable) {
+	} else {
+		// print displayable_frame_list for debug
+		ve1_show_displayable_frame_list(ctx);
+
+		// free DPBs which not use for display (not in displayable_frame_list)
+		for (i = 0; i < ctx->regFbCount; i++) {
+			bool bFound = false;
+			fbUser = ((FrameBuffer *)ctx->fbUser) + i;
+			spin_lock_irqsave(&ctx->displayable_frame_lock, flags);
+			if (!list_empty(&ctx->displayable_frame_list)) {
+				list_for_each_entry (
+					frame, &ctx->displayable_frame_list,
+					list) {
+					if (frame->dpb_paddr == fbUser->bufY) {
+						bFound = true;
+						break;
+					}
+				}
+			}
+			spin_unlock_irqrestore(&ctx->displayable_frame_lock,
+					       flags);
+			if (!bFound) {
+				// this DPB is not in displayable_frame_list, it can be freed
+				ve1_info(
+					VE1_WRAPPER_TAG,
+					"free fbUser[%d].bufY:0x%x.size:%d.myIndex:%d.stride:%d.h:%d.seqNo:%d.tot:%d\n",
+					i, fbUser->bufY, fbUser->size,
+					fbUser->myIndex, fbUser->stride,
+					fbUser->height, ctx->currSequenceNo,
+					ctx->totIonAllocatedBytes);
+				memset(fbUser, 0, sizeof(FrameBuffer));
+			}
+		}
+	}
+}
+
+int ve1_prepare_seq_change(void *pCtx)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	struct ve1_ctx *ctx;
+	DecOutputInfo *outputInfo;
+	PhysicalAddress seqChangedRdPtr;
+	PhysicalAddress seqChangedWrPtr;
+	int seqChangedStreamEndFlag;
+	int bPicDone = 0;
+	int i = 0;
+	unsigned long flags;
+	struct ve1_displayable_frame *frame = NULL;
+	int found = 0;
+
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "[+]\n");
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return VE1_DEC_RETURN_INVALID;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
+		return VE1_DEC_RETURN_INVALID;
+	}
+
+	if (ctx->outputInfo == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->outputInfo == NULL\n");
+		return VE1_DEC_RETURN_INVALID;
+	}
+	outputInfo = (DecOutputInfo *)ctx->outputInfo;
+
+	ctx->seqChangeRequest = 1;
+	seqChangedRdPtr = outputInfo->bytePosFrameEnd;
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"use bytePosFrameEnd:0x%x instead of rdPtr:0x%x\n",
+		outputInfo->bytePosFrameEnd, outputInfo->rdPtr);
+	seqChangedWrPtr = outputInfo->wrPtr;
+	seqChangedStreamEndFlag = outputInfo->streamEndFlag;
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"seqChangedRdPtr:0x%x.seqChangedWrPtr:0x%x.seqChangedStreamEndFlag:0x%x\n",
+		seqChangedRdPtr, seqChangedWrPtr, seqChangedStreamEndFlag);
+	ret = VPU_DecSetRdPtr((DecHandle)ctx->decHandle, seqChangedRdPtr, 1);
+	VE1_DecGetRdWrPtr(pCtx);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG, "VPU_DecSetRdPtr fail.ret:%d\n", ret);
+		return VE1_DEC_RETURN_INVALID;
+	}
+	ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle, 1);
+	ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
+		"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:1.accuBsFeedBytes:%d\n",
+		ret, ctx->accuBsFeedBytes);
+	VE1_DecGetRdWrPtr(pCtx);
+	ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
+					   STREAM_END_SET_FLAG);
+	ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
+		"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+		ret, STREAM_END_SET_FLAG, ctx->accuBsFeedBytes);
+	VE1_DecGetRdWrPtr(pCtx);
+
+	while (outputInfo->indexFrameDisplay != -1) {
+		if (ctx->seqInited &&
+		    (ctx->ve1DecState == VE1_STATE_DEC_SET_DPB ||
+		     ctx->ve1DecState == VE1_STATE_DEC_PIC_DONE)) {
+			rtkve1_recycle_dpb(ctx);
+			ret = VPU_DecStartOneFrame((DecHandle)ctx->decHandle,
+						   (DecParam *)ctx->decParam);
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"af VPU_DecStartOneFrame.ret:%d\n", ret);
+			if (ret != RETCODE_SUCCESS) {
+				ve1_err(VE1_WRAPPER_TAG,
+					"VPU_DecStartOneFrame fail.ret:%d\n",
+					ret);
+				return VE1_DEC_RETURN_INVALID;
+			}
+			ctx->ve1DecState = VE1_STATE_DEC_START_DEC_ISSUED;
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"set ve1DecState:%d\n", ctx->ve1DecState);
+
+			while (1) {
+				ctx->int_reason =
+					VPU_WaitInterrupt(VE1_COREIDX, 10);
+				if (ctx->int_reason == -1) {
+					ctx->int_reason = 0;
+				}
+				if (ctx->int_reason) {
+					VPU_ClearInterrupt(VE1_COREIDX);
+					if (ctx->int_reason &
+					    (1 << INT_BIT_PIC_RUN)) {
+						ve1_dbg(VPU_DBG_NONE,
+							VE1_WRAPPER_TAG,
+							"INT_BIT_PIC_RUN\n");
+						ctx->int_reason = 0;
+						bPicDone = 1;
+					} else if (ctx->int_reason &
+						   (1
+						    << INT_BIT_BIT_BUF_EMPTY)) {
+						VE1_DecGetRdWrPtr(ctx);
+						ctx->bufEmptyVpuWrPtr =
+							ctx->vpuWrPtr;
+						ve1_dbg(VPU_DBG_NONE,
+							VE1_WRAPPER_TAG,
+							"INT_BIT_BIT_BUF_EMPTY.bufEmptyVpuWrPtr:0x%x\n",
+							ctx->bufEmptyVpuWrPtr);
+					}
+					break;
+				}
+			}
+
+			if (bPicDone) {
+				ret = VPU_DecGetOutputInfo(
+					(DecHandle)ctx->decHandle, outputInfo);
+				if (ret != RETCODE_SUCCESS) {
+					ve1_err(VE1_WRAPPER_TAG,
+						"VPU_DecGetOutputInfo fail.ret:%d\n",
+						ret);
+					return VE1_DEC_RETURN_INVALID;
+				}
+				ctx->lastIndexFrameDecoded =
+					outputInfo->indexFrameDecoded;
+				ctx->lastIndexFrameDisplay =
+					outputInfo->indexFrameDisplay;
+				ctx->lastDisplayFrmBufY =
+					outputInfo->dispFrame.bufY;
+				ctx->ve1DecState = VE1_STATE_DEC_PIC_DONE;
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"set ve1DecState:%d\n",
+					ctx->ve1DecState);
+
+				ctx->outputinfoSN++;
+
+				if (outputInfo->indexFrameDecoded >= 0) {
+					ctx->decodedFrmNum++;
+				}
+				if (outputInfo->indexFrameDisplay >= 0) {
+					ctx->displayFrmNum++;
+				}
+
+				ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
+					"%d.%d.%d.h:0x%px.seq:%d.dec:%d.dis:%d.POC:%d(%d,%d).type:%d(%d).pos(0x%x 0x%x 0x%x).size:%ld.suc:0x%x.err:%d.frmDisFlg:0x%x.warn:%d.nalRefIdc:%d.decFrameInfo:%d.\n",
+					ctx->outputinfoSN, ctx->decodedFrmNum,
+					ctx->displayFrmNum,
+					ctx->decHandle, ctx->currSequenceNo,
+					outputInfo->indexFrameDecoded,
+					outputInfo->indexFrameDisplay,
+					outputInfo->avcPocPic,
+					outputInfo->avcPocTop,
+					outputInfo->avcPocBot,
+					outputInfo->picType,
+					outputInfo->picTypeFirst,
+					outputInfo->bytePosFrameStart,
+					outputInfo->bytePosFrameEnd,
+					outputInfo->rdPtr,
+					ve1_ring_valid_data(
+						ctx->bitstream.paddr,
+						ctx->bitstream.paddr +
+							ctx->bitstream.size,
+						outputInfo->bytePosFrameStart,
+						outputInfo->bytePosFrameEnd),
+					outputInfo->decodingSuccess,
+					outputInfo->numOfErrMBs,
+					outputInfo->frameDisplayFlag,
+					outputInfo->warnInfo,
+					outputInfo->nalRefIdc,
+					outputInfo->decFrameInfo);
+
+				VE1_UpdateFrameQueueInfo(pCtx);
+				// update vpuRdPtr to bsRdPtr
+				VE1_DecGetRdWrPtr(pCtx);
+				ctx->bsRdPtr = ctx->vpuRdPtr;
+
+				rtkve1_add_displayble_frame_to_list(ctx);
+			}
+		} else {
+			ve1_err(VE1_WRAPPER_TAG,
+				"fail to continue decoding original sequence.ve1DecState:%d\n",
+				ctx->ve1DecState);
+		}
+	}
+
+	for (i = 0; i < ctx->regFbCount; i++) {
+		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			"VPU_DecClrDispFlag(%d)\n", i);
+		ret = VPU_DecClrDispFlag((DecHandle)ctx->decHandle, i);
+	}
+
+	ret = VPU_DecFrameBufferFlush((DecHandle)ctx->decHandle, NULL, NULL);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"VPU_DecFrameBufferFlush fail.ret:%d\n", ret);
+		return VE1_DEC_RETURN_INVALID;
+	}
+
+	ctx->seqChangeRequest = 0;
+	ctx->outputinfoSN = 0;
+	ctx->decodedFrmNum = 0;
+	ctx->displayFrmNum = 0;
+	ctx->seqHeaderSize = 0;
+
+	VPU_DecSetRdPtr((DecHandle)ctx->decHandle, seqChangedRdPtr, 1);
+	VE1_DecGetRdWrPtr(pCtx);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG, "VPU_DecSetRdPtr fail.ret:%d\n", ret);
+		return VE1_DEC_RETURN_INVALID;
+	}
+
+	if (seqChangedStreamEndFlag == 1) {
+		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
+						   STREAM_END_SET_FLAG);
+		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+			ret, STREAM_END_SET_FLAG, ctx->accuBsFeedBytes);
+	} else {
+		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
+						   STREAM_END_CLEAR_FLAG);
+		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+			ret, STREAM_END_CLEAR_FLAG, ctx->accuBsFeedBytes);
+	}
+	VE1_DecGetRdWrPtr(pCtx);
+
+	if (seqChangedWrPtr >= seqChangedRdPtr) {
+		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
+						   seqChangedWrPtr -
+							   seqChangedRdPtr);
+		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+			ret, (seqChangedWrPtr - seqChangedRdPtr),
+			ctx->accuBsFeedBytes);
+	} else {
+		ret = VPU_DecUpdateBitstreamBuffer(
+			(DecHandle)ctx->decHandle,
+			(((DecOpenParam *)ctx->decOP)->bitstreamBuffer +
+			 ((DecOpenParam *)ctx->decOP)->bitstreamBufferSize) -
+				seqChangedRdPtr +
+				(seqChangedWrPtr -
+				 ((DecOpenParam *)ctx->decOP)->bitstreamBuffer));
+		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+			ret,
+			((((DecOpenParam *)ctx->decOP)->bitstreamBuffer +
+			  ((DecOpenParam *)ctx->decOP)->bitstreamBufferSize) -
+			 seqChangedRdPtr +
+			 (seqChangedWrPtr -
+			  ((DecOpenParam *)ctx->decOP)->bitstreamBuffer)),
+			ctx->accuBsFeedBytes);
+	}
+	VE1_DecGetRdWrPtr(pCtx);
+
+	VPU_DecGiveCommand((DecHandle)ctx->decHandle, DEC_FREE_FRAME_BUFFER,
+			   0x00);
+
+	//ve1_seq_change_free_fb(ctx);
+
+	//memset(ctx->fbUser, 0, sizeof(FrameBuffer) * MAX_REG_FRAME);
+
+	ctx->cntCap2Dpb = 0;
+	ctx->capReqBufsCnt = 0;
+	ctx->regFbCount = 0;
+	if (ctx->fbAllocInfo) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree fbAllocInfo\n");
+		kfree(ctx->fbAllocInfo);
+		ctx->fbAllocInfo = NULL;
+	}
+	if (ctx->fbUser) {
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree fbUser\n");
+		kfree(ctx->fbUser);
+		ctx->fbUser = NULL;
+	}
+
+	mutex_lock(&ctx->ve1_dma_mutex);
+	rtkve1_show_dpbs(ctx);
+	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
+		if (ctx->dpb[i].seqNo == ctx->currSequenceNo)
+		{
+			if (!IS_RTKVE1_DPB_DQ(ctx->dpb[i].status) &&
+				IS_RTKVE1_DPB_VALID(ctx->dpb[i].status)) {
+				if ((ctx->lastDoneCapBuf != NULL) && (ctx->dpb[i].vb2_v4l2_buf != ctx->lastDoneCapBuf)) {
+					ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+						"v4l2_m2m_buf_done.status:0x%x.regIndex:%d.vb2_v4l2_buf:0x%px.phys_addr:0x%lx.seqNo:%u\n",
+						ctx->dpb[i].status,
+						ctx->dpb[i].regIndex,
+						ctx->dpb[i].vb2_v4l2_buf,
+						ctx->dpb[i].phys_addr,
+						ctx->dpb[i].seqNo);
+					v4l2_m2m_buf_done((struct vb2_v4l2_buffer
+						*)(ctx->dpb[i].vb2_v4l2_buf),
+						VB2_BUF_STATE_ERROR);
+				}
+				else if (ctx->lastDoneCapBuf == NULL) {
+					found = 0;
+					spin_lock_irqsave(&ctx->displayable_frame_lock, flags);
+					if (!list_empty(&ctx->displayable_frame_list)) {
+						list_for_each_entry (frame, &ctx->displayable_frame_list,
+									list) {
+							if (ctx->dpb[i].phys_addr == frame->dpb_paddr) {
+								found = 1;
+								ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+									"found displayable and undequeued dpb.status:0x%x.regIndex:%d.vb2_v4l2_buf:0x%px.phys_addr:0x%lx.seqNo:%u\n",
+									ctx->dpb[i].status,
+									ctx->dpb[i].regIndex,
+									ctx->dpb[i].vb2_v4l2_buf,
+									ctx->dpb[i].phys_addr,
+									ctx->dpb[i].seqNo);
+								break;
+							}
+						}
+					}
+					if (list_empty(&ctx->displayable_frame_list) || (!found)) {
+						ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+							"v4l2_m2m_buf_done.status:0x%x.regIndex:%d.vb2_v4l2_buf:0x%px.phys_addr:0x%lx.seqNo:%u\n",
+							ctx->dpb[i].status,
+							ctx->dpb[i].regIndex,
+							ctx->dpb[i].vb2_v4l2_buf,
+							ctx->dpb[i].phys_addr,
+							ctx->dpb[i].seqNo);
+						v4l2_m2m_buf_done((struct vb2_v4l2_buffer
+							*)(ctx->dpb[i].vb2_v4l2_buf),
+							VB2_BUF_STATE_ERROR);
+					}
+					spin_unlock_irqrestore(&ctx->displayable_frame_lock, flags);
+				}
+			}
+			memset(&ctx->dpb[i], 0, sizeof(struct rtkve1_dpb_t));
+		}
+	}
+	mutex_unlock(&ctx->ve1_dma_mutex);
+
+	ctx->seqInited = 0;
+	// for trigger queue_work pic_run_work in ve1_out_qbuf()
+	ctx->startDecode = 0;
+	ctx->seqChangeDone = 1;
+
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "[-]\n");
+
+	return VE1_DEC_RETURN_SEQ_CHANGE;
+}
+
+static int rtkve1_dump_yuv(void *pCtx, int fbIndex)
+{
+#if defined(RTKVE1_DUMP_YUV_EN)
+	struct ve1_ctx *ctx;
+	unsigned long fb_phys_addr = 0;
+	void *fb_virt_addr = NULL;
+	FrameBuffer *fbUser = NULL;
+	void *tmp_dpb = NULL;
+	struct rtkve1_dpb_t *dpb = NULL;
+	struct vb2_v4l2_buffer *vb2_v4l2_buf = NULL;
+	struct vb2_buffer *vb2_buf = NULL;
+	unsigned int dump_size = 0;
+	int filp_open_flags;
+	ssize_t bytes = 0;
+	loff_t pos = 0;
+
+	if ((pCtx == NULL) || (fbIndex < 0)) {
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	//if ((fbIndex >= 0) &&
+	//    (ctx->displayFrmNum == 300)) {
+	if (fbIndex >= 0) {
+		fbUser = ((FrameBuffer *)ctx->fbUser) + fbIndex;
+		fb_phys_addr = fbUser->bufY;
+		tmp_dpb = rtkve1_find_dpb((void *)ctx, fb_phys_addr, ctx->currSequenceNo);
+		if (!tmp_dpb) {
+			ve1_err(VE1_WRAPPER_TAG,
+					"can't find framePhysAddr:0x%lx in dpb[]\n",
+					fb_phys_addr);
+			return -1;
+		}
+		dpb = (struct rtkve1_dpb_t *)tmp_dpb;
+		vb2_v4l2_buf = (struct vb2_v4l2_buffer *)(dpb->vb2_v4l2_buf);
+		vb2_buf = &(vb2_v4l2_buf->vb2_buf);
+		fb_virt_addr = vb2_plane_vaddr(vb2_buf, 0);
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+		fb_virt_addr += METADATA_OFFSET;
+		dump_size = dpb->size - METADATA_OFFSET;
+#endif
+		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"dpb.index:%d.virt:0x%px.phys:0x%lx.vb2_v4l2_buf:0x%px.vb2_buf:0x%px.size:%u.dump_size:%u\n",
+				fbIndex, fb_virt_addr, fb_phys_addr,
+				(void *)vb2_v4l2_buf, (void *)vb2_buf, dpb->size,
+				dump_size);
+
+		if ((fb_virt_addr != NULL) && (dpb->size > 0)) {
+			if (ctx->bNewYuvDumpFile == 1) {
+				ctx->bNewYuvDumpFile = 0;
+				filp_open_flags = O_CREAT | O_WRONLY;
+				memset(ctx->yuvDumpFileName, 0, sizeof(unsigned char)*256);
+				snprintf(ctx->yuvDumpFileName, 256,
+						"/mnt/ve1yuv_%d.yuv",
+						gYuvDumpSerial);
+				gYuvDumpSerial++;
+				vpu_info("%d.%s.create new ve1yuv dump:%s\n",__LINE__,__func__,
+						ctx->yuvDumpFileName);
+			} else {
+				filp_open_flags = O_APPEND | O_WRONLY;
+			}
+			ctx->yuvDumpFile =
+				(void *)filp_open(ctx->yuvDumpFileName, filp_open_flags, 0);
+			if (IS_ERR((struct file *)ctx->yuvDumpFile)) {
+				ve1_err(VE1_WRAPPER_TAG, "filp_open %s fail\n",
+						ctx->yuvDumpFileName);
+			} else {
+				//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				//	"filp_open %s ok\n",
+				//	ctx->yuvDumpFileName);
+				bytes =
+					kernel_write((struct file *)(ctx->yuvDumpFile),
+								(void *)fb_virt_addr, (size_t)dump_size, &pos);
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+						"kernel_write bytes:%ld.pos:%lld\n", bytes, pos);
+				filp_close((struct file *)(ctx->yuvDumpFile), NULL);
+				//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				//		"filp_close %s\n",
+				//		ctx->yuvDumpFileName);
+				ctx->yuvDumpFile = NULL;
+			}
+		}
+	}
+	return 0;
+#else
+	return -1;
+#endif
+}
+
+static char ve1_check_if_paired_field_frm(struct ve1_ctx *ctx, int index)
+{
+	DecOpenParam *decOP;
+	DecOutputInfo *info;
+	struct ve1_decoded_frame *frame;
+	char isPairedFld = 0;
+	bool isH264PicStructPaired;
+
+	if (index < 0) {
+		return 0;
+	}
+
+	decOP = (DecOpenParam *)ctx->decOP;
+	info = (DecOutputInfo *)ctx->outputInfo;
+	frame = (struct ve1_decoded_frame *)&ctx
+			->frameQueue[index];
+
+	if (info->picTimingStruct == H264_PIC_STRUCT_TOP_BOTTOM ||
+	    info->picTimingStruct == H264_PIC_STRUCT_BOTTOM_TOP ||
+	    info->picTimingStruct == H264_PIC_STRUCT_TOP_BOTTOM_TOP ||
+	    info->picTimingStruct == H264_PIC_STRUCT_BOTTOM_TOP_BOTTOM) {
+		isH264PicStructPaired = true;
+	} else {
+		isH264PicStructPaired = false;
+	}
+
+	if (((decOP->bitstreamFormat == STD_MPEG2) &&
+	     (info->pictureStructure == 3) &&
+	     (frame->picMode != CONSECUTIVE_FRAME)) ||
+	    ((decOP->bitstreamFormat == STD_AVC) &&
+	     ((info->pictureStructure == 1) ||
+	      ((info->decFrameInfo == 0) &&
+	       (frame->picMode != CONSECUTIVE_FRAME)) ||
+	      ((info->picStrPresent == 1) && isH264PicStructPaired))) ||
+	    ((decOP->bitstreamFormat == STD_MPEG4) &&
+	     (info->interlacedFrame == 1) &&
+	     (frame->picMode != CONSECUTIVE_FRAME))) {
+		isPairedFld = 1;
+	}
+
+	return isPairedFld;
+}
+
+static void ve1_update_mpeg2_pic_mode(struct ve1_ctx *ctx, int index)
+{
+	struct ve1_decoded_frame *frame;
+	bool telecine_2_fld_frame = false;
+	enum PICTURE_MODE mode;
+
+	if (ctx == NULL) {
+		return;
+	}
+
+	frame = (struct ve1_decoded_frame *)&ctx->frameQueue[index];
+	telecine_2_fld_frame = (!frame->repeatFirstField) && (ctx->prev_repeatFirstField == 1);
+	ctx->prev_repeatFirstField = frame->repeatFirstField;
+
+	if (frame->picMode == MPEG2_PIC_MODE_NOT_PROG) {
+		if (telecine_2_fld_frame) {
+			mode = CONSECUTIVE_FRAME;
+		}
+		else {
+			if (frame->topFieldFirst) {
+				mode = INTERLEAVED_TOP_FIELD;
+			}
+			else {
+				mode = INTERLEAVED_BOT_FIELD;
+			}
+		}
+		frame->picMode = mode;
+		frame->pairedFldFrm = ve1_check_if_paired_field_frm(ctx, index);
+		//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+		//	"index:%d.picMode:%d.pairedFldFrm:%d\n",
+		//	index, frame->picMode, frame->pairedFldFrm);
+	}
+}
+
+int VE1_DecPicDone(void *pCtx)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	struct ve1_ctx *ctx;
+	DecOutputInfo *outputInfo;
+#if defined(VE1_CHECK_DPB_MD5_EN)
+	int fbIndex = 0;
+	unsigned long fb_phys_addr = 0;
+	void *fb_virt_addr = NULL;
+	FrameBuffer *fbUser = NULL;
+	void *tmp_dpb = NULL;
+	struct rtkve1_dpb_t *dpb = NULL;
+	struct vb2_v4l2_buffer *vb2_v4l2_buf = NULL;
+	struct vb2_buffer *vb2_buf = NULL;
+	unsigned int dump_size = 0;
+#if defined(VE1_CHECK_DPB_MD5_TO_FILE_EN)
+	int filp_open_flags;
+	ssize_t bytes = 0;
+	loff_t pos = 0;
+	char md5Log[64] = {0};
+#endif
+#endif
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return VE1_DEC_RETURN_INVALID;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
+		return VE1_DEC_RETURN_INVALID;
+	}
+
+	if (ctx->outputInfo == NULL) {
+		ctx->outputInfo = kzalloc(sizeof(DecOutputInfo), GFP_KERNEL);
+		if (ctx->outputInfo == NULL) {
+			ve1_err(VE1_WRAPPER_TAG, "kzalloc outputInfo fail\n");
+			return VE1_DEC_RETURN_INVALID;
+		}
+	}
+	outputInfo = (DecOutputInfo *)ctx->outputInfo;
+
+	ret = VPU_DecGetOutputInfo((DecHandle)ctx->decHandle, outputInfo);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG, "VPU_DecGetOutputInfo fail.ret:%d\n",
+			ret);
+		return VE1_DEC_RETURN_INVALID;
+	}
+
+	if (outputInfo->indexFrameDecoded != -1) {
+		if (ctx->bPostponeUpBs) {
+			ctx->bPostponeUpBs = false;
+			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+				"bPostponeUpBs.clear bPostponeUpBs.int_reason:0x%x\n",
+				ctx->int_reason);
+		}
+	}
+
+	if (outputInfo->indexFrameDecoded >= 0) {
+		ctx->decodedFrmNum++;
+	}
+	if (outputInfo->indexFrameDisplay >= 0) {
+		ctx->displayFrmNum++;
+	}
+
+	if ((((DecOpenParam *)ctx->decOP)->bitstreamFormat == STD_VP8) &&
+		(outputInfo->vp8PicInfo.showFrame == 0)) {
+		ctx->noshowframe = 1;
+	}
+	else {
+		ctx->noshowframe = 0;
+	}
+	if (!((ctx->lastInfoFrmStart == outputInfo->bytePosFrameStart) &&
+	      (ctx->lastInfoFrmEnd == outputInfo->bytePosFrameEnd) &&
+	      (outputInfo->indexFrameDecoded == -2) &&
+	      (outputInfo->indexFrameDisplay == -3) &&
+		  (ctx->lastIndexFrameDecoded != -1))) {
+		ctx->outputinfoSN++;
+		ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
+			"%d.%d.%d.h:0x%px.seq:%d.dec:%d.dis:%d.POC:%d(%d,%d).type:%d(%d).pos(0x%x 0x%x 0x%x).size:%ld.suc:0x%x.err:%d.frmDisFlg:0x%x.warn:%d.nalRefIdc:%d.decFrameInfo:%d.vpu_debug:0x%x.noshow:%d\n",
+			ctx->outputinfoSN, ctx->decodedFrmNum,
+			ctx->displayFrmNum, ctx->decHandle,
+			ctx->currSequenceNo, outputInfo->indexFrameDecoded,
+			outputInfo->indexFrameDisplay, outputInfo->avcPocPic,
+			outputInfo->avcPocTop, outputInfo->avcPocBot,
+			outputInfo->picType, outputInfo->picTypeFirst,
+			outputInfo->bytePosFrameStart,
+			outputInfo->bytePosFrameEnd, outputInfo->rdPtr,
+			ve1_ring_valid_data(ctx->bitstream.paddr,
+				ctx->bitstream.paddr +
+				ctx->bitstream.size,
+				outputInfo->bytePosFrameStart,
+				outputInfo->bytePosFrameEnd),
+			outputInfo->decodingSuccess, outputInfo->numOfErrMBs,
+			outputInfo->frameDisplayFlag, outputInfo->warnInfo,
+			outputInfo->nalRefIdc, outputInfo->decFrameInfo,
+			vpu_debug,
+			ctx->noshowframe);
+	}
+	ctx->lastInfoFrmStart = outputInfo->bytePosFrameStart;
+	ctx->lastInfoFrmEnd = outputInfo->bytePosFrameEnd;
+
+	ctx->lastIndexFrameDecoded = outputInfo->indexFrameDecoded;
+	ctx->lastIndexFrameDisplay = outputInfo->indexFrameDisplay;
+	ctx->lastDisplayFrmBufY = outputInfo->dispFrame.bufY;
+	ctx->ve1DecState = VE1_STATE_DEC_PIC_DONE;
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "set ve1DecState:%d\n",
+		ctx->ve1DecState);
+
+	if ((((DecOpenParam *)ctx->decOP)->bitstreamFormat == STD_AVC) &&
+	    (outputInfo->indexFrameDecoded >= 0)) {
+
+		if ((outputInfo->decodingSuccess & 0x00200000) &&
+		    (outputInfo->nalRefIdc != 0)) {
+			ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
+				"dec:%d.AVC missing reference\n",
+				outputInfo->indexFrameDecoded);
+		}
+		if (outputInfo->decFrameInfo != 0) {
+			ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
+				"dec:%d.AVC missing field\n",
+				outputInfo->indexFrameDecoded);
+		}
+	}
+	if (outputInfo->numOfErrMBs) {
+		bool isThisFrmBeRefer = true;
+
+		if ((((DecOpenParam *)ctx->decOP)->bitstreamFormat ==
+		     STD_AVC) &&
+		    (outputInfo->nalRefIdc == 0)) {
+			isThisFrmBeRefer = false;
+		}
+		ve1_info(VE1_WRAPPER_TAG,
+			"%d.%d.dec:%d.ErrorBlock:%d.type:%d(%d).ifRefFrame:%d\n",
+			ctx->outputinfoSN, ctx->decodedFrmNum,
+			outputInfo->indexFrameDecoded, outputInfo->numOfErrMBs,
+			outputInfo->picType, outputInfo->picTypeFirst,
+			isThisFrmBeRefer);
+	}
+
+	if (((DecOpenParam *)ctx->decOP)->bitstreamMode == BS_MODE_ROLLBACK &&
+	    (outputInfo->decodingSuccess & 0x10)) {
+		ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
+			"BS_MODE_ROLLBACK.empty.dec:%d.dis:%d.suc:0x%x\n",
+			outputInfo->indexFrameDecoded,
+			outputInfo->indexFrameDisplay,
+			outputInfo->decodingSuccess);
+	}
+
+	VE1_UpdateFrameQueueInfo(pCtx);
+	// update vpuRdPtr to bsRdPtr
+	VE1_DecGetRdWrPtr(pCtx);
+	ctx->bsRdPtr = ctx->vpuRdPtr;
+
+#if defined(VE1_CHECK_DPB_MD5_EN)
+	fbIndex = outputInfo->indexFrameDecoded;
+	if (fbIndex >= 0) {
+		fbUser = ((FrameBuffer *)ctx->fbUser) + fbIndex;
+		fb_phys_addr = fbUser->bufY;
+		tmp_dpb = rtkve1_find_dpb((void *)ctx, fb_phys_addr, ctx->currSequenceNo);
+		if (!tmp_dpb) {
+			ve1_err(VE1_WRAPPER_TAG,
+				"can't find framePhysAddr:0x%lx in dpb[]\n",
+				fb_phys_addr);
+			return VE1_DEC_RETURN_INVALID;
+		}
+		dpb = (struct rtkve1_dpb_t *)tmp_dpb;
+		vb2_v4l2_buf = (struct vb2_v4l2_buffer *)(dpb->vb2_v4l2_buf);
+		vb2_buf = &(vb2_v4l2_buf->vb2_buf);
+		fb_virt_addr = vb2_plane_vaddr(vb2_buf, 0);
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+		fb_virt_addr += METADATA_OFFSET;
+		dump_size = dpb->size - METADATA_OFFSET;
+#endif
+		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			"dpb.index:%d.virt:0x%px.phys:0x%lx.vb2_v4l2_buf:0x%px.vb2_buf:0x%px.size:%u.dump_size:%u\n",
+			fbIndex, fb_virt_addr, fb_phys_addr,
+			(void *)vb2_v4l2_buf, (void *)vb2_buf, dpb->size,
+			dump_size);
+		ve1_md5_hash(ve1_md5_digest, VE1_MD5_DIGEST_SIZE,
+			(char *)fb_virt_addr, dump_size);
+#if defined(VE1_CHECK_DPB_MD5_TO_FILE_EN)
+		if (ctx->bNewChecksumFile) {
+			ctx->bNewChecksumFile = 0;
+			filp_open_flags = O_CREAT | O_WRONLY;
+		}
+		else {
+			filp_open_flags = O_APPEND | O_WRONLY;
+		}
+		ctx->fpChecksum =
+			(void *)filp_open(VE1_CHECK_DPB_MD5_FILEPATH, filp_open_flags, 0);
+		if (IS_ERR((struct file *)ctx->fpChecksum)) {
+			ve1_err(VE1_WRAPPER_TAG, "filp_open %s fail\n",
+					VE1_CHECK_DPB_MD5_FILEPATH);
+		} else {
+			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			//	"filp_open %s ok\n",
+			//	VE1_CHECK_DPB_MD5_FILEPATH);
+			snprintf(md5Log, 64, "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
+                ve1_md5_digest[0],ve1_md5_digest[1],ve1_md5_digest[2],ve1_md5_digest[3],ve1_md5_digest[4],ve1_md5_digest[5],ve1_md5_digest[6],ve1_md5_digest[7],
+                ve1_md5_digest[8],ve1_md5_digest[9],ve1_md5_digest[10],ve1_md5_digest[11],ve1_md5_digest[12],ve1_md5_digest[13],ve1_md5_digest[14],ve1_md5_digest[15]);
+			bytes =
+				kernel_write((struct file *)(ctx->fpChecksum),
+							(void *)md5Log, strlen(md5Log), &pos);
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"kernel_write bytes:%ld.pos:%lld\n", bytes, pos);
+			filp_close((struct file *)(ctx->fpChecksum), NULL);
+			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			//		"filp_close %s\n",
+			//		VE1_CHECK_DPB_MD5_FILEPATH);
+			ctx->fpChecksum = NULL;
+		}
+#endif
+	}
+#endif
+
+	rtkve1_dump_yuv((void *)ctx, outputInfo->indexFrameDisplay);
+
+	if (((outputInfo->decodingSuccess & 0x1) != 0) &&
+	    (outputInfo->sequenceChanged)) {
+		//profileIdc/MbNumX/MbNumY/MaxDecFrameBuffering are changed
+		ve1_info(VE1_WRAPPER_TAG,
+			 "Sequence information has been changed (0x%x)\n",
+			 outputInfo->sequenceChanged);
+		ret = ve1_prepare_seq_change(pCtx);
+		return ret;
+	}
+
+	if ((outputInfo->indexFrameDisplay == -1) && ctx->streamEnd) {
+		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
+											STREAM_END_CLEAR_FLAG);
+		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d\n",
+			ret, STREAM_END_CLEAR_FLAG);
+		VE1_DecGetRdWrPtr(ctx);
+		ctx->streamEnd = 0;
+		ctx->handle_eos_by = VE1_HANDLE_EOS_DEC_FINISH;
+	}
+
+	if ((((DecOpenParam *)ctx->decOP)->bitstreamFormat == STD_MPEG2) && (outputInfo->indexFrameDisplay >= 0)) {
+		ve1_update_mpeg2_pic_mode(ctx, outputInfo->indexFrameDisplay);
+	}
+
+	return VE1_DEC_RETURN_OK;
+}
+
+int VE1_DecCheckComplete(void *pCtx)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	struct ve1_ctx *ctx;
+	int int_reason;
+	unsigned int interrupt_timeout_cnt = 10;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
+		return -1;
+	}
+
+	if (ctx->ve1DecState == VE1_STATE_DEC_SEQ_INIT_ISSUED ||
+		ctx->ve1DecState == VE1_STATE_DEC_START_DEC_ISSUED) {
+		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
+						   STREAM_END_SET_FLAG);
+		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+			ret, STREAM_END_SET_FLAG, ctx->accuBsFeedBytes);
+		VE1_DecGetRdWrPtr(ctx);
+
+		int_reason = 1 << INT_BIT_BIT_BUF_EMPTY;
+		while ((int_reason & (1 << INT_BIT_BIT_BUF_EMPTY)) &&
+		       (interrupt_timeout_cnt > 0)) {
+			int_reason = VPU_WaitInterrupt(VE1_COREIDX, 100);
+			if (int_reason) {
+				VPU_ClearInterrupt(VE1_COREIDX);
+			}
+			interrupt_timeout_cnt--;
+		}
+		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			"int_reason:0x%x.interrupt_timeout_cnt:%d\n",
+			int_reason, interrupt_timeout_cnt);
+		ret = VPU_DecGetOutputInfo((DecHandle)ctx->decHandle,
+					   (DecOutputInfo *)ctx->outputInfo);
+		if (ret != RETCODE_SUCCESS) {
+			ve1_err(VE1_WRAPPER_TAG,
+				"VPU_DecGetOutputInfo fail.ret:%d\n", ret);
+		}
+		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
+						   STREAM_END_CLEAR_FLAG);
+		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+			ret, STREAM_END_CLEAR_FLAG, ctx->accuBsFeedBytes);
+		VE1_DecGetRdWrPtr(ctx);
+		ctx->ve1DecState = VE1_STATE_DEC_PIC_DONE;
+	}
+
+	return ret;
+}
+//EXPORT_SYMBOL(VE1_DecCheckComplete);
+
+int VE1_DecClose(void *pCtx)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	struct ve1_ctx *ctx;
+	FrameBuffer *fbUser;
+	int i;
+	DecHandle decHandle = NULL;
+	DecOpenParam *pDecOp;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
+		return -1;
+	}
+	decHandle = (DecHandle)ctx->decHandle;
+	pDecOp = (DecOpenParam *)ctx->decOP;
+
+	if (ctx->ve1DecState < VE1_STATE_DEC_OPENED) {
+		ve1_err(VE1_WRAPPER_TAG, "invalid ve1DecState:%d\n",
+			ctx->ve1DecState);
+		return -1;
+	}
+
+	/* This software reset for corner case is neccessary when VPU_DecStartOneFrame()
+	 * EnterLock and doesn't LeaveLock, during this moment the system stops streaming.
+	 * The next start will be deadlock at EnterLock().
+	 */
+	if (ctx->ve1DecState != VE1_STATE_DEC_OPENED &&
+		ctx->ve1DecState != VE1_STATE_DEC_SEQ_INIT_DONE &&
+	    ctx->ve1DecState != VE1_STATE_DEC_PIC_DONE) {
+		ve1_info(VE1_WRAPPER_TAG,
+			"%s: ve1DecState=%d, VPU_SWReset for corner case\n",
+			__func__, ctx->ve1DecState);
+		VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
+			STREAM_END_SIZE);
+		VPU_SWReset(VE1_COREIDX, SW_RESET_SAFETY,
+			(DecHandle)ctx->decHandle);
+		VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
+			STREAM_END_CLEAR_FLAG);
+		ve1_info(VE1_WRAPPER_TAG, "%s: VPU_SWReset done\n", __func__);
+	}
+
+#ifdef VPU_GET_CC
+	if (pDecOp->bitstreamFormat == STD_MPEG2 ||
+	    pDecOp->bitstreamFormat == STD_AVC) {
+		cc_data_channel_exit();
+
+		for (i = 0; i < MPEG2_CC_REG_FRAME_MAX; i++) {
+			if (ctx->m_CCDecodeOrderWp[i]) {
+				kfree(ctx->m_CCDecodeOrderWp[i]);
+				ctx->m_CCDecodeOrderWp[i] = NULL;
+			}
+		}
+
+		ctx->cc_error_count = 0;
+	}
+#endif
+	// clear frame buffers
+	for (i = 0; i < ctx->regFbCount * 2; i++) {
+		fbUser = ((FrameBuffer *)ctx->fbUser) + i;
+		if (fbUser->size > 0) {
+			ve1_info(
+				VE1_WRAPPER_TAG,
+				"clear fbUser[%d].bufY:0x%x.size:%d.myIndex:%d.stride:%d.h:%d.seqNo:%d.tot:%d\n",
+				i, fbUser->bufY, fbUser->size, fbUser->myIndex,
+				fbUser->stride, fbUser->height,
+				ctx->currSequenceNo, ctx->totIonAllocatedBytes);
+			memset(fbUser, 0, sizeof(FrameBuffer));
+		}
+	}
+
+#ifdef VPU_GET_CC
+	if (ctx->pUserDataSrcBuf) {
+		unsigned int codec_type =
+			(pDecOp->bitstreamFormat == STD_MPEG2 ? ENUM_CC_MPGE2 :
+								ENUM_CC_H264);
+		if (ctx->is_svp)
+			ta_TEEapi_OMX_CC_API(
+				(struct tee_context *)decHandle->teeapi_ctx,
+				decHandle->teeapi_tee_session,
+				ctx->userDataBufPhysAddr, ctx->pUserDataSrcBuf,
+				USER_DATA_SRC_BUF_SIZE, codec_type, ENUM_CC_U);
+
+		kfree(ctx->pUserDataSrcBuf);
+		ctx->pUserDataSrcBuf = NULL;
+	}
+	if (ctx->userDataBufPhysAddr != 0) {
+		vpu_buffer_t vdb;
+		memset(&vdb, 0, sizeof(vpu_buffer_t));
+		vdb.size = ctx->userDataBufSize;
+		vdb.phys_addr = ctx->userDataBufPhysAddr;
+		vdi_free_dma_memory(VE1_COREIDX, &vdb);
+		ve1_info(VE1_WRAPPER_TAG, "free userdata(size:%d,phys:0x%x)\n",
+			 ctx->userDataBufSize, ctx->userDataBufPhysAddr);
+		ctx->userDataBufSize = 0;
+		ctx->userDataBufPhysAddr = 0;
+	}
+
+	// clear user data variables
+	ctx->userDataEnable = 0;
+	ctx->userDataReportMode = 0;
+#endif
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "decHandle == NULL\n");
+		return -1;
+	}
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"bf VPU_DecClose.ve1DecState:%d\n", ctx->ve1DecState);
+	ret = VPU_DecClose((DecHandle)ctx->decHandle);
+	ve1_info(VE1_WRAPPER_TAG, "af VPU_DecClose.ret:%d\n", ret);
+	ctx->decHandle = NULL;
+	ctx->ve1DecState = VE1_STATE_DEC_CLOSED;
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "set ve1DecState:%d\n",
+		ctx->ve1DecState);
+
+	return ret;
+}
+
+int VE1_DecDeInit(void *pCtx)
+{
+	RetCode ret = RETCODE_SUCCESS;
+	struct ve1_ctx *ctx;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->ve1DecState != VE1_STATE_DEC_INITED &&
+	    ctx->ve1DecState != VE1_STATE_DEC_CLOSED) {
+		ve1_err(VE1_WRAPPER_TAG, "invalid ve1DecState:%d\n",
+			ctx->ve1DecState);
+		return -1;
+	}
+
+	ret = VPU_DeInit(VE1_COREIDX);
+	ve1_info(VE1_WRAPPER_TAG, "af VPU_DeInit.ret:%d\n", ret);
+	ctx->ve1DecState = VE1_STATE_DEC_UNINIT;
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "set ve1DecState:%d\n",
+		ctx->ve1DecState);
+
+	return ret;
+}
+
+void VE1_GetParsedInfo(void *pCtx, void *pInfo)
+{
+	struct ve1_ctx *ctx;
+	DecInitialInfo *initialInfo;
+	struct ve1_parsed_initial_info *info;
+
+	if (pCtx == NULL || pInfo == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL or pInfo == NULL\n");
+		return;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (!ctx->seqInited) {
+		ve1_err(VE1_WRAPPER_TAG, "not seqInited\n");
+		return;
+	}
+
+	initialInfo = (DecInitialInfo *)ctx->initialInfo;
+	info = (struct ve1_parsed_initial_info *)pInfo;
+
+	info->pic_width = initialInfo->picWidth;
+	info->pic_height = initialInfo->picHeight;
+	info->visible_rect_left = initialInfo->picCropRect.left;
+	info->visible_rect_top = initialInfo->picCropRect.top;
+	info->visible_rect_w =
+		initialInfo->picCropRect.right - initialInfo->picCropRect.left;
+	info->visible_rect_h =
+		initialInfo->picCropRect.bottom - initialInfo->picCropRect.top;
+	info->minDpbCount =
+		initialInfo->minFrameBufferCount + EXTRA_DEC_PIC_BUF;
+	info->interlace = initialInfo->interlace;
+}
+
+void VE1_GetDisplayFrameInfo(void *pCtx, void *displayFrameInfo)
+{
+	struct ve1_ctx *ctx;
+	DecOpenParam *decOP;
+	DecInitialInfo *initialInfo;
+	DecOutputInfo *outputInfo;
+	struct ve1_displayable_frame *frame;
+	struct ve1_decoded_frame *frmInfo;
+
+	if (pCtx == NULL || displayFrameInfo == NULL) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"pCtx == NULL or displayFrameInfo == NULL\n");
+		return;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decOP == NULL || ctx->initialInfo == NULL ||
+	    ctx->outputInfo == NULL) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"decOP == NULL or initialInfo == NULL or outputInfo == NULL\n");
+		return;
+	}
+
+	decOP = (DecOpenParam *)ctx->decOP;
+	initialInfo = (DecInitialInfo *)ctx->initialInfo;
+	outputInfo = (DecOutputInfo *)ctx->outputInfo;
+	frame = (struct ve1_displayable_frame *)displayFrameInfo;
+	frmInfo = (struct ve1_decoded_frame *)&ctx
+			  ->frameQueue[outputInfo->indexFrameDisplay];
+
+	frame->frameBufIndex = outputInfo->indexFrameDisplay;
+	frame->Y_addr = outputInfo->dispFrame.bufY;
+	frame->U_addr =
+		(outputInfo->dispFrame.bufY +
+		 outputInfo->dispFrame.stride * outputInfo->dispFrame.height);
+	frame->bufStride = outputInfo->dispFrame.stride;
+	frame->bufHeight = outputInfo->dispFrame.height;
+	frame->picWidth = initialInfo->picWidth;
+	frame->picHeight = initialInfo->picHeight;
+	frame->rectLeft = outputInfo->rcDisplay.left;
+	frame->rectTop = outputInfo->rcDisplay.top;
+	frame->rectRight = outputInfo->rcDisplay.right;
+	frame->rectBottom = outputInfo->rcDisplay.bottom;
+	frame->bitDepth = initialInfo->lumaBitdepth;
+	if (frmInfo->pairedFldFrm) {
+		frame->mode = (frmInfo->picMode == INTERLEAVED_BOT_FIELD) ?
+				      INTERLEAVED_BOT_TOP_FIELD :
+				      INTERLEAVED_TOP_BOT_FIELD;
+	} else {
+		frame->mode = frmInfo->picMode;
+	}
+	if (decOP->nv21 == 1) {
+		frame->mode |=
+			0x1u << 16; // todo, VO_NV21_MASK of VP_PICTURE_MODE_EXT
+	}
+	frame->timeTick = ctx->timeTick;
+	frame->video_full_range_flag = frmInfo->video_full_range_flag;
+	frame->transfer_characteristics = frmInfo->transfer_characteristics;
+	frame->matrix_coefficients = frmInfo->matrix_coefficients;
+	frame->POC = frmInfo->POC;
+	frame->picType = frmInfo->picType;
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"idx:%d.0x%x,0x%x.%d,%d,%d,%d.(%d,%d,%d,%d).%d.%d.%lld.avcvui(%d,%d,%d).POC:%d.picType:%d\n",
+		frame->frameBufIndex, frame->Y_addr, frame->U_addr,
+		frame->bufStride, frame->bufHeight, frame->picWidth,
+		frame->picHeight, frame->rectLeft, frame->rectTop,
+		frame->rectRight, frame->rectBottom, frame->bitDepth,
+		frame->mode, frame->timeTick, frame->video_full_range_flag,
+		frame->transfer_characteristics, frame->matrix_coefficients,
+		frame->POC, frame->picType);
+}
+
+int VE1_AllocateBitstreamBuffer(struct device *dev, unsigned long *phys_addr,
+				unsigned long *virt_addr, unsigned long size,
+				unsigned int is_svp)
+{
+	int ret = 0;
+	unsigned int flags = 0;
+	dma_addr_t dma_phys_addr = 0;
+	void *dma_virt_addr = NULL;
+
+	if (dev == NULL || phys_addr == NULL || virt_addr == NULL ||
+	    size == 0) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"dev == NULL or phys_addr == NULL or virt_addr == NULL or size == 0\n");
+		return -1;
+	}
+
+	if (is_svp) {
+		flags = RTK_FLAG_NONCACHED | RTK_FLAG_HWIPACC |
+			RTK_FLAG_PROTECTED_V2_VIDEO_POOL;
+	} else {
+		flags = RTK_FLAG_NONCACHED | RTK_FLAG_HWIPACC |
+			RTK_FLAG_SCPUACC;
+	}
+
+	mutex_lock(&dev->mutex);
+	rheap_setup_dma_pools(dev, "rtk_media_heap",
+	                      RTK_FLAG_NONCACHED | RTK_FLAG_SCPUACC |
+	                      RTK_FLAG_VO_U_POOL, __func__);
+	dma_virt_addr = dma_alloc_coherent(
+		dev, PAGE_ALIGN(size), &dma_phys_addr, (GFP_DMA | GFP_KERNEL));
+	mutex_unlock(&dev->mutex);
+	if (dma_virt_addr == NULL) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"dma_alloc_coherent() fail.size:%lu(%ld).flags:0x%x\n",
+			PAGE_ALIGN(size), size, flags);
+		ret = -ENOMEM;
+		return ret;
+	}
+	*phys_addr = (unsigned long)dma_phys_addr;
+	*virt_addr = (unsigned long)dma_virt_addr;
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"dma_alloc_coherent() ok.phys_addr:0x%lx.virt_addr:0x%lx.size:%lu(%ld).flags:0x%x\n",
+		*phys_addr, *virt_addr, PAGE_ALIGN(size), size, flags);
+
+	return ret;
+}
+
+int VE1_FreeBitstreamBuffer(struct device *dev, unsigned long virt_addr,
+			    unsigned long phys_addr, unsigned int size)
+{
+	int ret = 0;
+
+	if (dev == NULL || virt_addr == 0 || phys_addr == 0 || size == 0) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"dev == NULL or virt_addr == 0 or phys_addr == 0 or size == 0\n");
+		return -1;
+	}
+
+	if (virt_addr != 0) {
+		dma_free_coherent(dev, PAGE_ALIGN(size), (void *)virt_addr,
+				  (dma_addr_t)phys_addr);
+		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			"dma_free_coherent() ok.phys_addr:0x%lx.virt_addr:0x%lx.size:%d(%d)\n",
+			phys_addr, virt_addr, PAGE_ALIGN(size), size);
+	}
+
+	return ret;
+}
+
+static enum PICTURE_MODE ve1_get_picture_mode(struct ve1_ctx *ctx)
+{
+	DecOpenParam *decOP;
+	DecOutputInfo *info;
+	struct ve1_decoded_frame *frame;
+	enum PICTURE_MODE mode = CONSECUTIVE_FRAME;
+
+	decOP = (DecOpenParam *)ctx->decOP;
+	info = (DecOutputInfo *)ctx->outputInfo;
+	frame = (struct ve1_decoded_frame *)&ctx
+			->frameQueue[info->indexFrameDecoded];
+
+	if (decOP->bitstreamFormat == STD_MPEG2) {
+		if (info->pictureStructure == 3) // 1:TOP, 2: BOT, 3:FRAME
+		{
+			char is_prog = 0;
+			// LINUX-74, mark the condition of "info->repeatFirstField" below,
+			// according to ISO/IEC 13818-2: 1995 (E), pg 63, the explanation of repeat_first_field,
+			// if progressive_sequence is equal to 0, whether progressive_frame is equal to 0 to 1, this reconstructed frame consists fields:
+			// repeat_first_field is 1 -> consists 3 fields, repeat_first_field is 0 -> consists 2 fields,
+			// so this frame is not progressive.
+			// ref 1185 MpegDec_SetupLinks()
+			is_prog =
+				(info->progressiveSequence /* progressive sequence */
+				 ||
+				 frame->stillVOBU); /* progressive I-picture in a DVD still-VOBU */
+
+			if (is_prog)
+				mode = CONSECUTIVE_FRAME;
+			else
+				mode = MPEG2_PIC_MODE_NOT_PROG;
+		} else {
+			if (info->pictureStructure == 1)
+				mode = INTERLEAVED_TOP_FIELD;
+			if (info->pictureStructure == 2)
+				mode = INTERLEAVED_BOT_FIELD;
+		}
+	} else if (decOP->bitstreamFormat == STD_AVC) {
+		if (info->pictureStructure) // MbaffFrameFlag = ( mb_adaptive_frame_field_flag && !field_pic_flag )
+		{
+			if (info->picStrPresent == 1) {
+				if (info->picTimingStruct == 4)
+					mode = INTERLEAVED_BOT_FIELD;
+				else
+					mode = INTERLEAVED_TOP_FIELD;
+			} else // according to poc
+			{
+				if (info->avcPocBot < info->avcPocTop)
+					mode = INTERLEAVED_BOT_FIELD;
+				else
+					mode = INTERLEAVED_TOP_FIELD;
+			}
+		} else {
+			/**decFrameInfo:  H.264/AVC, MPEG-2, and VC-1
+            @** 0 : The decoded frame has paired fields.
+            @** 1 : The decoded frame has a top-field missing.
+            @** 2 : The decoded frame has a bottom-field missing.*/
+			if (info->decFrameInfo ==
+			    0) //decoded frame is paired field or frame.
+			{
+				if (info->interlacedFrame) //field_pic_flag
+				{
+					if (info->topFieldFirst)
+						mode = INTERLEAVED_TOP_FIELD;
+					else
+						mode = INTERLEAVED_BOT_FIELD;
+				} else if (info->picStrPresent == 1) {
+					if (info->picTimingStruct ==
+						    H264_PIC_STRUCT_FRAME ||
+					    info->picTimingStruct ==
+						    H264_PIC_STRUCT_FRAME_DOUBLING ||
+					    info->picTimingStruct ==
+						    H264_PIC_STRUCT_FRAME_TRIPLING) {
+						mode = CONSECUTIVE_FRAME;
+					} else if (info->picTimingStruct == 4) {
+						mode = INTERLEAVED_BOT_FIELD;
+					} else {
+						mode = INTERLEAVED_TOP_FIELD;
+					}
+				} else {
+					mode = CONSECUTIVE_FRAME;
+				}
+			} else if (info->picStrPresent == 1) {
+				if (info->picTimingStruct == 0)
+					mode = CONSECUTIVE_FRAME;
+				else if (info->picTimingStruct == 4)
+					mode = INTERLEAVED_BOT_FIELD;
+				else
+					mode = INTERLEAVED_TOP_FIELD;
+			} else //(info->decFrameInfo != 0) //decoded frame is NPF.
+			{
+				if (info->avcNpfFieldInfo == 1)
+					mode = INTERLEAVED_BOT_FIELD; //top missing
+				else if (info->avcNpfFieldInfo == 2)
+					mode = INTERLEAVED_TOP_FIELD; //bot missing
+				else if (info->avcNpfFieldInfo == 3) {
+					ve1_err(VE1_WRAPPER_TAG,
+						"AVC: top and bot fld are missing!\n");
+				} else if (info->avcNpfFieldInfo == 0) {
+					if (info->avcPocBot <
+					    info->avcPocTop) { //if pocPic = pocTop = pocBot, still assume top fld first
+						mode = INTERLEAVED_BOT_FIELD;
+					} else
+						mode = INTERLEAVED_TOP_FIELD;
+				}
+			}
+		}
+	} else if (decOP->bitstreamFormat == STD_MPEG4) {
+		if (info->interlacedFrame == 1) {
+			if (info->topFieldFirst)
+				mode = INTERLEAVED_TOP_FIELD;
+			else
+				mode = INTERLEAVED_BOT_FIELD;
+		}
+	} else {
+		mode = CONSECUTIVE_FRAME;
+	}
+
+	return mode;
+}
+
+static int ve1_get_frame_poc(struct ve1_ctx *ctx)
+{
+	DecOpenParam *decOP;
+	DecOutputInfo *outputInfo;
+	struct ve1_decoded_frame *frame;
+	int retPOC = -1;
+
+	decOP = (DecOpenParam *)ctx->decOP;
+	outputInfo = (DecOutputInfo *)ctx->outputInfo;
+	frame = (struct ve1_decoded_frame *)&ctx
+			->frameQueue[outputInfo->indexFrameDecoded];
+
+	if (decOP->bitstreamFormat == STD_AVC) {
+		if (frame->picMode == CONSECUTIVE_FRAME) {
+			retPOC = outputInfo->avcPocPic;
+		} else {
+			if (frame->picMode == INTERLEAVED_TOP_FIELD) {
+				retPOC = outputInfo->avcPocTop;
+			} else {
+				retPOC = outputInfo->avcPocBot;
+			}
+
+			if (retPOC == 0) {
+				retPOC = outputInfo->avcPocPic;
+			}
+		}
+	}
+
+	return retPOC;
+}
+
+void VE1_UpdateFrameQueueInfo(void *pCtx)
+{
+	struct ve1_ctx *ctx;
+	DecOpenParam *decOP;
+	DecOutputInfo *outputInfo;
+	struct ve1_decoded_frame *frame;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decOP == NULL || ctx->outputInfo == NULL) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"decOP == NULL or outputInfo == NULL\n");
+		return;
+	}
+
+	decOP = (DecOpenParam *)ctx->decOP;
+	outputInfo = (DecOutputInfo *)ctx->outputInfo;
+
+	if (outputInfo->indexFrameDecoded >= 0) {
+		frame = (struct ve1_decoded_frame *)&ctx
+				->frameQueue[outputInfo->indexFrameDecoded];
+
+		frame->picType = (outputInfo->interlacedFrame ?
+					  outputInfo->picTypeFirst :
+					  outputInfo->picType);
+		frame->repeatFirstField =
+			(signed char)outputInfo->repeatFirstField;
+		frame->errorBlock = outputInfo->numOfErrMBs;
+		frame->mvcPairIdx = -1;
+		frame->reSend = 0;
+		frame->mvcViewIdx =
+			(signed char)outputInfo->mvcPicInfo.viewIdxDecoded;
+		frame->topFieldFirst = (signed char)outputInfo->topFieldFirst;
+		frame->stillVOBU = 0;
+		frame->qualityLevel = 0;
+		frame->picMode = ve1_get_picture_mode(ctx);
+		frame->POC = ve1_get_frame_poc(ctx);
+		frame->pairedFldFrm = ve1_check_if_paired_field_frm(ctx, outputInfo->indexFrameDecoded);
+		frame->decodingSuccess = outputInfo->decodingSuccess;
+		frame->bytePosFrameStart = outputInfo->bytePosFrameStart;
+		frame->bytePosFrameEnd = outputInfo->bytePosFrameEnd;
+		if (outputInfo->avcVuiInfo.vidSigTypePresent) {
+			frame->video_full_range_flag =
+				outputInfo->avcVuiInfo.vidFullRange;
+			if (outputInfo->avcVuiInfo.colorDescPresent) {
+				frame->colour_primaries =
+					outputInfo->avcVuiInfo.colorPrimaries;
+				frame->transfer_characteristics =
+					outputInfo->avcVuiInfo
+						.vuiTransferCharacteristics;
+				frame->matrix_coefficients =
+					outputInfo->avcVuiInfo
+						.vuiMatrixCoefficients;
+			} else {
+				frame->colour_primaries = 0;
+				frame->transfer_characteristics = 0;
+				frame->matrix_coefficients = 0;
+			}
+		} else {
+			frame->video_full_range_flag = 0;
+		}
+		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			"type:%d.mode:%d.poc:%d.paired:%d.err:%d.avcvui(%d,%d,%d,%d)\n",
+			frame->picType, frame->picMode, frame->POC,
+			frame->pairedFldFrm, frame->errorBlock,
+			frame->video_full_range_flag, frame->colour_primaries,
+			frame->transfer_characteristics,
+			frame->matrix_coefficients);
+	}
+}
+
+static void rtkve1_dump_bs(struct ve1_ctx *ctx, uint8_t *buf,
+					uint32_t size)
+{
+#if defined(RTKVE1_DUMP_BS_EN)
+	int filp_open_flags;
+	ssize_t bytes = 0;
+	loff_t pos = 0;
+
+	if (ctx == NULL) {
+		return;
+	}
+
+	if ((buf != NULL) && (size != 0)) {
+		if (ctx->bNewBsDumpFile == 1) {
+			ctx->bNewBsDumpFile = 0;
+			filp_open_flags = O_CREAT | O_WRONLY;
+			memset(ctx->bsDumpFileName, 0, sizeof(unsigned char)*256);
+			snprintf(ctx->bsDumpFileName, 256,
+					"/mnt/ve1bs_%d.es",
+					gBsDumpSerial);
+			gBsDumpSerial++;
+			vpu_info("%d.%s.create new ve1bs dump:%s\n",__LINE__,__func__,
+					ctx->bsDumpFileName);
+		} else {
+			filp_open_flags = O_APPEND | O_WRONLY;
+		}
+		ctx->bsDumpFile =
+			(void *)filp_open(ctx->bsDumpFileName, filp_open_flags, 0);
+		if (IS_ERR((struct file *)ctx->bsDumpFile)) {
+			ve1_err(VE1_WRAPPER_TAG, "filp_open %s fail\n",
+					ctx->bsDumpFileName);
+		} else {
+			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			//		"filp_open %s ok\n",
+			//		ctx->bsDumpFileName);
+			bytes =
+				kernel_write((struct file *)(ctx->bsDumpFile),
+							(void *)buf, (size_t)size, &pos);
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"kernel_write bytes:%ld.pos:%lld\n", bytes, pos);
+			filp_close((struct file *)(ctx->bsDumpFile), NULL);
+			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+			//		"filp_close %s\n",
+			//		ctx->bsDumpFileName);
+			ctx->bsDumpFile = NULL;
+		}
+	}
+#endif
+}
+
+void rtkve1_copy_to_bitstream_buffer(struct ve1_ctx *ctx, uint8_t *buf,
+				     uint32_t size)
+{
+	unsigned long bsEndAddr = 0; // physical address
+	unsigned long newBsWrPtr = 0; // physical address
+	unsigned long virtBsWrPtr = 0; // virtual address
+	int size0 = 0;
+	int size1 = 0;
+
+	rtkve1_dump_bs(ctx, buf, size);
+
+	bsEndAddr = ctx->bitstream.paddr + ctx->bitstream.size;
+	newBsWrPtr = ctx->bsWrPtr + size;
+	virtBsWrPtr =
+		ve1_ring_phys_to_virt(ctx->bsWrPtr, ctx->bitstream.paddr,
+				      (unsigned long)ctx->bitstream.vaddr);
+
+	if (newBsWrPtr >= bsEndAddr) {
+		size0 = bsEndAddr - ctx->bsWrPtr;
+		size1 = size - size0;
+
+		if (ctx->is_svp) {
+#if defined(ENABLE_TEE_DRM_FLOW)
+			if (ctx->out_vb2_q_memory == V4L2_MEMORY_MMAP) {
+				ret = ta_TEEapi_memcpy_a7(
+					(struct tee_context *)
+						decHandle->teeapi_ctx,
+					decHandle->teeapi_tee_session,
+					ctx->bsWrPtr, buf, size0);
+				if (ret < 0) {
+					ve1_err(VE1_WRAPPER_TAG,
+						"ta_TEEapi_memcpy_a7() fail.bsWrPtr:0x%lx.buf:0x%px.size0:%d\n",
+						ctx->bsWrPtr, buf, size0);
+					return -1;
+				}
+
+				ret = ta_TEEapi_memcpy_a7(
+					(struct tee_context *)
+						decHandle->teeapi_ctx,
+					decHandle->teeapi_tee_session,
+					ctx->bitstream.paddr, buf + size0,
+					size1);
+				if (ret < 0) {
+					ve1_err(VE1_WRAPPER_TAG,
+						"ta_TEEapi_memcpy_a7() fail.bsStartAddr:0x%lx.buf+size0:0x%px.size1:%d\n",
+						ctx->bitstream.paddr,
+						buf + size0, size1);
+					return -1;
+				}
+			} else if (ctx->out_vb2_q_memory ==
+				   V4L2_MEMORY_DMABUF) {
+				ret = ta_TEEapi_memcpy(
+					(struct tee_context *)
+						decHandle->teeapi_ctx,
+					decHandle->teeapi_tee_session,
+					ctx->bsWrPtr, (uintptr_t)buf, size0);
+				if (ret < 0) {
+					ve1_err(VE1_WRAPPER_TAG,
+						"ta_TEEapi_memcpy() fail.bsWrPtr:0x%lx.buf:0x%px.size0:%d\n",
+						ctx->bsWrPtr, buf, size0);
+					return -1;
+				}
+
+				ret = ta_TEEapi_memcpy(
+					(struct tee_context *)
+						decHandle->teeapi_ctx,
+					decHandle->teeapi_tee_session,
+					ctx->bitstream.paddr,
+					(uintptr_t)buf + size0, size1);
+				if (ret < 0) {
+					ve1_err(VE1_WRAPPER_TAG,
+						"ta_TEEapi_memcpy() fail.bsStartAddr:0x%lx.buf+size0:0x%px.size1:%d\n",
+						ctx->bitstream.paddr,
+						buf + size0, size1);
+					return -1;
+				}
+			}
+#endif // #if defined(ENABLE_TEE_DRM_FLOW)
+		} else {
+			osal_memcpy((void *)virtBsWrPtr, (void *)buf, size0);
+			osal_memcpy((void *)ctx->bitstream.vaddr,
+				    (void *)(buf + size0), size1);
+		}
+		ctx->bsWrPtr = ctx->bitstream.paddr + size1;
+	} else {
+		if (ctx->is_svp) {
+#if defined(ENABLE_TEE_DRM_FLOW)
+			if (ctx->out_vb2_q_memory == V4L2_MEMORY_MMAP) {
+				ret = ta_TEEapi_memcpy_a7(
+					(struct tee_context *)
+						decHandle->teeapi_ctx,
+					decHandle->teeapi_tee_session,
+					ctx->bsWrPtr, buf, size);
+				if (ret < 0) {
+					ve1_err(VE1_WRAPPER_TAG,
+						"ta_TEEapi_memcpy_a7() fail.bsWrPtr:0x%lx.buf:0x%px.size:%d\n",
+						ctx->bsWrPtr, buf, size);
+					return -1;
+				}
+			} else if (ctx->out_vb2_q_memory ==
+				   V4L2_MEMORY_DMABUF) {
+				ret = ta_TEEapi_memcpy(
+					(struct tee_context *)
+						decHandle->teeapi_ctx,
+					decHandle->teeapi_tee_session,
+					ctx->bsWrPtr, (uintptr_t)buf, size);
+				if (ret < 0) {
+					ve1_err(VE1_WRAPPER_TAG,
+						"ta_TEEapi_memcpy() fail.bsWrPtr:0x%lx.buf:0x%px.size:%d\n",
+						ctx->bsWrPtr, buf, size);
+					return -1;
+				}
+			}
+#endif // #if defined(ENABLE_TEE_DRM_FLOW)
+		} else {
+			osal_memcpy((void *)virtBsWrPtr, (void *)buf, size);
+		}
+		ctx->bsWrPtr = newBsWrPtr;
+	}
+}
+
+int32_t BuildSeqHeader(void *pCtx, uint8_t *buf, uint32_t buf_size)
+{
+	struct ve1_ctx *ctx;
+	DecOpenParam *decOP;
+	uint8_t *pbMetaData = buf;
+	uint8_t *p = pbMetaData;
+	int32_t size = 0; // metadata header size
+	uint32_t codingType = 0;
+	uint32_t nFrameWidth, nFrameHeight, picWidth, picHeight;
+	uint32_t width_in_pixels, height_in_pixels;
+	uint32_t signature = MAKE_FOURCC('D', 'K', 'I', 'F');
+	uint32_t version = 0x00;
+	uint32_t length_of_header_in_bytes = 0x20;
+	uint32_t codec_FourCC = MAKE_FOURCC('V', 'P', '8', '0');
+	uint32_t time_base_denominator = 30;
+//	uint32_t time_base_numerator = -1;
+	uint32_t number_of_frames_in_file = 0;
+	uint32_t unused = 0;
+
+
+	if (buf == NULL || buf_size <= 0) {
+		ve1_err(VE1_WRAPPER_TAG, "buf == NULL || size <= 0\n");
+		return -1;
+	}
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+
+	ctx = (struct ve1_ctx *)pCtx;
+	decOP = (DecOpenParam *)ctx->decOP;
+
+	if (ctx->seqHeader == NULL) {
+		ctx->seqHeader = kmalloc(MAX_CHUNK_HEADER_SIZE, GFP_KERNEL);
+	}
+
+	codingType = decOP->bitstreamFormat;
+	size = 0;
+
+	if (codingType == STD_VP8) {
+		if (ctx->seqHeaderSize == 0) {
+			nFrameWidth = decOP->frameWidth;
+			nFrameHeight = decOP->frameHeight;
+			//20160926, workaround for invalid resolution
+			if (buf_size >= 10) {
+				picWidth =
+					(uint32_t)(p[7] << 8 | p[6]);
+				picHeight =
+					(uint32_t)(p[9] << 8 | p[8]);
+				if (picWidth <= 1920 && picHeight <= 1088) {
+					nFrameWidth = picWidth;
+					nFrameHeight = picHeight;
+				}
+			}
+			width_in_pixels = nFrameWidth;
+			height_in_pixels = nFrameHeight;
+
+			//signature 'DKIF'
+			ctx->seqHeader[0] = (unsigned char)(signature >> 0);
+			ctx->seqHeader[1] = (unsigned char)(signature >> 8);
+			ctx->seqHeader[2] = (unsigned char)(signature >> 16);
+			ctx->seqHeader[3] = (unsigned char)(signature >> 24);
+			//version
+			ctx->seqHeader[4] = (unsigned char)(version >> 0);
+			ctx->seqHeader[5] = (unsigned char)(version >> 8);
+			//length of header in bytes
+			ctx->seqHeader[6] =
+				(unsigned char)(length_of_header_in_bytes >> 0);
+			ctx->seqHeader[7] =
+				(unsigned char)(length_of_header_in_bytes >> 8);
+			//codec FourCC of VP80
+			ctx->seqHeader[8] = (unsigned char)(codec_FourCC >> 0);
+			ctx->seqHeader[9] = (unsigned char)(codec_FourCC >> 8);
+			ctx->seqHeader[10] =
+				(unsigned char)(codec_FourCC >> 16);
+			ctx->seqHeader[11] =
+				(unsigned char)(codec_FourCC >> 24);
+			//width
+			ctx->seqHeader[12] =
+				(unsigned char)(width_in_pixels >> 0);
+			ctx->seqHeader[13] =
+				(unsigned char)(width_in_pixels >> 8);
+			//height
+			ctx->seqHeader[14] =
+				(unsigned char)(height_in_pixels >> 0);
+			ctx->seqHeader[15] =
+				(unsigned char)(height_in_pixels >> 8);
+			//frame rate
+			ctx->seqHeader[16] =
+				(unsigned char)(time_base_denominator >> 0);
+			ctx->seqHeader[17] =
+				(unsigned char)(time_base_denominator >> 8);
+			ctx->seqHeader[18] =
+				(unsigned char)(time_base_denominator >> 16);
+			ctx->seqHeader[19] =
+				(unsigned char)(time_base_denominator >> 24);
+			//time scale(?)
+			ctx->seqHeader[20] =
+				(unsigned char)(number_of_frames_in_file >> 0);
+			ctx->seqHeader[21] =
+				(unsigned char)(number_of_frames_in_file >> 8);
+			ctx->seqHeader[22] =
+				(unsigned char)(number_of_frames_in_file >> 16);
+			ctx->seqHeader[23] =
+				(unsigned char)(number_of_frames_in_file >> 24);
+			//number of frames in file
+			ctx->seqHeader[24] =
+				(unsigned char)(number_of_frames_in_file >> 0);
+			ctx->seqHeader[25] =
+				(unsigned char)(number_of_frames_in_file >> 8);
+			ctx->seqHeader[26] =
+				(unsigned char)(number_of_frames_in_file >> 16);
+			ctx->seqHeader[27] =
+				(unsigned char)(number_of_frames_in_file >> 24);
+			//unused
+			ctx->seqHeader[28] = (unsigned char)(unused >> 0);
+			ctx->seqHeader[29] = (unsigned char)(unused >> 8);
+			ctx->seqHeader[30] = (unsigned char)(unused >> 16);
+			ctx->seqHeader[31] = (unsigned char)(unused >> 24);
+			size += 32;
+		}
+	} else {
+		size = 0;
+	}
+
+	ctx->seqHeaderSize += size;
+
+	return size;
+}
+
+int32_t BuildPicHeader(void *pCtx, uint8_t *buf, uint32_t buf_size)
+{
+	struct ve1_ctx *ctx;
+	DecOpenParam *decOP;
+	int32_t size = 0;
+	uint32_t codingType = 0;
+
+	if (buf == NULL || buf_size <= 0) {
+		ve1_err(VE1_WRAPPER_TAG, "buf == NULL || size <= 0\n");
+		return -1;
+	}
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+
+	ctx = (struct ve1_ctx *)pCtx;
+	decOP = (DecOpenParam *)ctx->decOP;
+
+	if (ctx->picHeader == NULL) {
+		ctx->picHeader = kmalloc(MAX_CHUNK_HEADER_SIZE, GFP_KERNEL);
+	}
+
+	codingType = decOP->bitstreamFormat;
+	size = 0;
+
+	if (codingType == STD_VP8) {
+		//size of frame in bytes (not including the 12-byte header)
+		ctx->picHeader[0] = (unsigned char)(buf_size >> 0);
+		ctx->picHeader[1] = (unsigned char)(buf_size >> 8);
+		ctx->picHeader[2] = (unsigned char)(buf_size >> 16);
+		ctx->picHeader[3] = (unsigned char)(buf_size >> 24);
+		//64-bit presentation timestamp
+		ctx->picHeader[4] = 0;
+		ctx->picHeader[5] = 0;
+		ctx->picHeader[6] = 0;
+		ctx->picHeader[7] = 0;
+		ctx->picHeader[8] = 0;
+		ctx->picHeader[9] = 0;
+		ctx->picHeader[10] = 0;
+		ctx->picHeader[11] = 0;
+		size += 12;
+	}
+
+	return size;
+}
+
+int VE1_DecUpdateBS(void *pCtx, uint8_t *buf, uint32_t size)
+{
+	struct ve1_ctx *ctx;
+	DecHandle decHandle = NULL;
+	int ret = 0;
+	unsigned long valid_data = 0;
+	bool queueRet = false;
+	DecOpenParam *decOP;
+	unsigned int seqHdrSize = 0;
+	unsigned int picHdrSize = 0;
+	unsigned int totalUpBsSize = 0;
+	unsigned int frame_chunk_len = 0;
+
+	if (buf == NULL || size <= 0) {
+		ve1_err(VE1_WRAPPER_TAG, "buf == NULL || size <= 0\n");
+		return -1;
+	}
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "decHandle == NULL\n");
+		return -1;
+	}
+	decHandle = (DecHandle)ctx->decHandle;
+
+	if (ctx->decOP == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->decOP is NULL\n");
+		return -1;
+	}
+	decOP = (DecOpenParam *)ctx->decOP;
+
+	if (decOP->bitstreamFormat == STD_VP8) {
+		seqHdrSize = BuildSeqHeader((void *)ctx, buf, size);
+		if (seqHdrSize > 0) {
+			rtkve1_copy_to_bitstream_buffer(ctx, ctx->seqHeader,
+							seqHdrSize);
+			totalUpBsSize += seqHdrSize;
+		}
+		picHdrSize = BuildPicHeader((void *)ctx, buf, size);
+		if (picHdrSize > 0) {
+			frame_chunk_len = (ctx->picHeader[0]) |
+					  (ctx->picHeader[1] << 8) |
+					  (ctx->picHeader[2] << 16) |
+					  (ctx->picHeader[3] << 24);
+			rtkve1_copy_to_bitstream_buffer(ctx, ctx->picHeader,
+							picHdrSize);
+			totalUpBsSize += picHdrSize;
+		}
+	}
+
+	rtkve1_copy_to_bitstream_buffer(ctx, buf, size);
+	totalUpBsSize += size;
+
+	ret = VPU_DecUpdateBitstreamBuffer(decHandle, totalUpBsSize);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"VPU_DecUpdateBitstreamBuffer fail.ret:%d.size:%d\n",
+			ret, totalUpBsSize);
+		return -1;
+	} else {
+		if ((ctx->seqInited) &&
+			(decOP->bitstreamMode == BS_MODE_PIC_END) &&
+		    (decOP->bitstreamFormat == STD_AVC ||
+		     decOP->bitstreamFormat == STD_MPEG2 ||
+			 decOP->bitstreamFormat == STD_VP8)) {
+			ctx->bPostponeUpBs = true;
+		}
+		ctx->accuBsFeedBytes += totalUpBsSize;
+		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+			ret, totalUpBsSize, ctx->accuBsFeedBytes);
+
+		VE1_DecGetRdWrPtr(ctx);
+		// handle priority of bWaitNextField is higher than bBufEmptyFlag
+		if (ctx->bWaitNextField) {
+			if (ctx->bBufEmptyFlag) {
+				ctx->bBufEmptyFlag = false;
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"bWaitNextField.clear bBufEmptyFlag\n");
+			}
+			ctx->bGotNextField = true;
+			if (ctx->fldDoneVpuRp != ctx->vpuRdPtr) {
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"FATAL.bWaitNextField.fld_rp:0x%x != vpu_rp:0x%x\n",
+					ctx->fldDoneVpuRp, ctx->vpuRdPtr);
+			}
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"bWaitNextField.set rdPtr:0x%x.clear int_reason\n",
+				ctx->vpuRdPtr);
+			VPU_DecSetRdPtr((DecHandle)ctx->decHandle,
+					ctx->vpuRdPtr, 0);
+			VPU_ClearInterrupt(VE1_COREIDX);
+			ctx->int_reason = 0;
+			ctx->bWaitNextField = false;
+			queueRet =
+				queue_work(ctx->workqueue, &ctx->pic_run_work);
+			if (queueRet)
+				ctx->cntQueuePicRunWorkOk++;
+			else
+				ctx->cntQueuePicRunWorkFail++;
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"queue_work pic_run_work.cnt(%d,%d).ret:%d\n",
+				ctx->cntQueuePicRunWorkOk,
+				ctx->cntQueuePicRunWorkFail, queueRet);
+			ret = 1; /* return 1 to tell ve1_fill_bitstream() not add meta */
+		} else if (ctx->bBufEmptyFlag) {
+			if (((DecOpenParam *)ctx->decOP)->bitstreamMode ==
+			    BS_MODE_INTERRUPT) {
+				valid_data = ve1_ring_valid_data(
+					ctx->bitstream.paddr,
+					ctx->bitstream.paddr +
+						ctx->bitstream.size,
+					ctx->vpuRdPtr, ctx->vpuWrPtr);
+				if (valid_data >= 1024) {
+					ctx->bBufEmptyFlag = false;
+				}
+			} else {
+				ctx->bBufEmptyFlag = false;
+			}
+			if (!ctx->bBufEmptyFlag) {
+				queueRet = queue_work(ctx->workqueue,
+						      &ctx->pic_run_work);
+				if (queueRet)
+					ctx->cntQueuePicRunWorkOk++;
+				else
+					ctx->cntQueuePicRunWorkFail++;
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"queue_work pic_run_work.cnt(%d,%d).ret:%d\n",
+					ctx->cntQueuePicRunWorkOk,
+					ctx->cntQueuePicRunWorkFail, queueRet);
+			}
+		}
+	}
+
+	return ret;
+}
+
+int rtkve1_flush_bitstream(void *pCtx)
+{
+	int ret = 0;
+	struct ve1_ctx *ctx;
+	DecHandle decHandle = NULL;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "decHandle == NULL\n");
+		return -1;
+	}
+	decHandle = (DecHandle)ctx->decHandle;
+
+	mutex_lock(&ctx->ve1_mutex);
+	ctx->accuBsFeedBytes = 0;
+	ctx->bsRdPtr = ctx->bsWrPtr;
+	ret = VPU_DecSetRdPtr(decHandle, ctx->bsWrPtr, 1);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"VPU_DecSetRdPtr fail.ret:%d\n", ret);
+		ret = -1;
+		goto out;
+	}
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"VPU_DecSetRdPtr(0x%x, 1)\n",
+		(unsigned int)ctx->bsWrPtr);
+	VE1_DecGetRdWrPtr(pCtx);
+
+	if (ctx->streamEnd) {
+		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
+											STREAM_END_CLEAR_FLAG);
+		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d\n",
+			ret, STREAM_END_CLEAR_FLAG);
+		VE1_DecGetRdWrPtr(ctx);
+		ctx->streamEnd = 0;
+	}
+	ctx->handle_eos_by = VE1_HANDLE_EOS_BY_NONE;
+	ctx->bPostponeUpBs = false;
+	ctx->dpbFull = 0;
+
+out:
+	mutex_unlock(&ctx->ve1_mutex);
+	return ret;
+}
+
+int rtkve1_flush(void *pCtx)
+{
+	int ret = 0;
+	struct ve1_ctx *ctx;
+	DecHandle decHandle = NULL;
+    int vpu_timeout_cnt = 1000;
+	unsigned int dispFlag = 0xffffffff;
+
+	if (pCtx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
+		return -1;
+	}
+	ctx = (struct ve1_ctx *)pCtx;
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "decHandle == NULL\n");
+		return -1;
+	}
+	decHandle = (DecHandle)ctx->decHandle;
+
+	mutex_lock(&ctx->ve1_mutex);
+	ctx->bFlush = true;
+	mutex_unlock(&ctx->ve1_mutex);
+
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+		"bf flush_work pic_run_work\n");
+	flush_work(&ctx->pic_run_work);
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+		"af flush_work pic_run_work\n");
+
+	mutex_lock(&ctx->ve1_mutex);
+	ctx->bFlush = false;
+	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+		"VE1_DecCheckComplete\n");
+	VE1_DecCheckComplete(ctx);
+
+    if (VPU_IsBusy(VE1_COREIDX)) {
+        VPU_DecUpdateBitstreamBuffer(decHandle, STREAM_END_SET_FLAG);
+		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d\n",
+			ret, STREAM_END_SET_FLAG);
+		VE1_DecGetRdWrPtr(pCtx);
+        while (VPU_IsBusy(VE1_COREIDX) && vpu_timeout_cnt > 0) {
+            vpu_timeout_cnt --;
+            usleep_range(1000, 1000);
+        }
+        VPU_DecUpdateBitstreamBuffer(decHandle, STREAM_END_CLEAR_FLAG);
+		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d\n",
+			ret, STREAM_END_CLEAR_FLAG);
+		VE1_DecGetRdWrPtr(pCtx);
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"vpu_timeout_cnt:%d\n",vpu_timeout_cnt);
+    }
+
+	if (ctx->ve1DecState >= VE1_STATE_DEC_SET_DPB) {
+		ret = VPU_DecFrameBufferFlush(decHandle, NULL, NULL);
+		if (ret != RETCODE_SUCCESS) {
+			ve1_err(VE1_WRAPPER_TAG,
+				"VPU_DecFrameBufferFlush fail.ret:%d\n", ret);
+			ret = -1;
+			goto out;
+		}
+		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
+			"af VPU_DecFrameBufferFlush.ret:%d\n", ret);
+	}
+
+	ret = VPU_DecSetDispFlag(decHandle, dispFlag);
+	if (ret != RETCODE_SUCCESS) {
+		ve1_err(VE1_WRAPPER_TAG,
+			"VPU_DecSetDispFlag fail.ret:%d\n", ret);
+		ret = -1;
+		goto out;
+	}
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"VPU_DecSetDispFlag.dispFlag:0x%x\n", dispFlag);
+
+	ctx->dpbFull = 0;
+	ctx->outputinfoSN = 0;
+	ctx->decodedFrmNum = 0;
+	ctx->displayFrmNum = 0;
+	ctx->lastInfoFrmStart = 0;
+	ctx->lastInfoFrmEnd = 0;
+	ctx->prev_repeatFirstField = 0;
+	//ctx->bPostponeUpBs = false;
+	//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+	//	"set bPostponeUpBs:%d\n", ctx->bPostponeUpBs);
+
+	ret = 0;
+out:
+	mutex_unlock(&ctx->ve1_mutex);
+	return ret;
+}
\ No newline at end of file
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve1_wrapper.h
@@ -0,0 +1,82 @@
+#ifndef __VE1_WRAPPER_H__
+#define __VE1_WRAPPER_H__
+
+#define VE1_COREIDX 0
+
+#define USER_DATA_INFO_OFFSET (8 * 17)
+#define USER_DATA_SRC_BUF_SIZE (2048) //jim.hsu, 512 for MPEG, 2048 for AVC
+
+struct ve1_decopen_param {
+	unsigned int src_fmt_fourcc; // ex: V4L2_PIX_FMT_H264
+	unsigned int dst_fmt_fourcc; // ex: V4L2_PIX_FMT_NV21
+	unsigned int width;
+	unsigned int height;
+};
+
+typedef enum {
+	VE1_STATE_DEC_UNINIT = 0,
+	VE1_STATE_DEC_INITED,
+	VE1_STATE_DEC_CLOSED,
+	VE1_STATE_DEC_OPENED,
+	VE1_STATE_DEC_SEQ_INIT_ISSUED,
+	VE1_STATE_DEC_SEQ_INIT_DONE,
+	VE1_STATE_DEC_SET_DPB,
+	VE1_STATE_DEC_START_DEC_ISSUED,
+	VE1_STATE_DEC_PIC_DONE,
+	VE1_STATE_DEC_MAX_NUM
+} ve1_dec_state;
+
+typedef enum {
+	VE1_DEC_RETURN_INVALID = -1,
+	VE1_DEC_RETURN_OK = 0,
+	VE1_DEC_RETURN_SEQ_CHANGE
+} VE1_DEC_RETURN_VALUE;
+
+enum { ENUM_CC_S = 0x0324,
+       ENUM_CC_U = 0x1107,
+       ENUM_CC_P = 0x2418,
+       ENUM_CC_AU = 0x9631,
+}; // for tee_api
+
+int VE1_DecInit(void *pCtx, void *videc_dev);
+int VE1_DecOpen(void *pCtx, void *pParam);
+int VE1_DecGetRdWrPtr(void *pCtx);
+int VE1_SetStreamEnd(void *pCtx);
+int VE1_DecSeqInit(void *pCtx);
+int VE1_DecStartDecode(void *pCtx);
+int VE1_DecWaitPicDone(void *pCtx);
+int VE1_UpdateDPBStatus(void *pCtx, unsigned int dpb_paddr,
+			 unsigned int sequenceNo, unsigned int status);
+/**
+* @brief Do original sequence remain decoding and flush, prepare for new sequence
+* @return VE1_DEC_RETURN_VALUE
+*/
+int ve1_prepare_seq_change(void *pCtx);
+/**
+* @brief Get decode result (outputinfo) from VE1
+* @return VE1_DEC_RETURN_VALUE
+*/
+int VE1_DecPicDone(void *pCtx);
+int VE1_DecCheckComplete(void *pCtx);
+int VE1_DecClose(void *pCtx);
+int VE1_DecDeInit(void *pCtx);
+void VE1_GetParsedInfo(void *pCtx, void *pInfo);
+void VE1_GetDisplayFrameInfo(void *pCtx, void *displayFrameInfo);
+int VE1_AllocateBitstreamBuffer(struct device *dev, unsigned long *phys_addr,
+				unsigned long *virt_addr, unsigned long size,
+				unsigned int is_svp);
+int VE1_FreeBitstreamBuffer(struct device *dev, unsigned long virt_addr,
+			    unsigned long phys_addr, unsigned int size);
+void VE1_UpdateFrameQueueInfo(void *pCtx);
+int VE1_DecUpdateBS(void *pCtx, uint8_t *buf, uint32_t size);
+void *rtkve1_find_dpb(void *pCtx, unsigned long dpb_paddr, unsigned int seqNo);
+int rtkve1_add_capbuf_to_dpb(void *pCtx, unsigned long size,
+			     unsigned long phys_addr, void *vb2_v4l2_buf);
+int rtkve1_register_dpbs(void *pCtx);
+int rtkve1_check_new_dpb(void *pCtx);
+void rtkve1_flush_dpbs(void *pCtx);
+int rtkve1_flush_bitstream(void *pCtx);
+int rtkve1_flush(void *pCtx);
+void *rtkve1_find_dpb_undequeue(void *pCtx, unsigned int seqNo);
+int rtkve1_unreg_dpbs(void *pCtx);
+#endif // #define __VE1_WRAPPER_H__
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve2.c
@@ -0,0 +1,1331 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ *
+ * Release Log
+ * v0.1 - Support H265 decode 2022 01 03
+ */
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#ifdef ENABLE_TEE_DRM_FLOW
+#include <linux/tee_drv.h>
+#endif
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-event.h>
+
+#include "drv_if.h"
+#include "vpu.h"
+#include "ve2.h"
+#include "ve2rpc.h"
+#include "debug.h"
+
+#define VENG_ID 2
+#define VIDEO_CC_DATA_LENGTH 128
+#define COUNTRY_CODE_OFFSET 3
+#define CC_DATA_HEADER_LEN 16
+#define CIE1931_TO_SMPTE (50000)
+#define CANDELAS_PER_SQUARE_METER_BASE (10000)
+//2K max resolution : 1920x1088=2088960
+#define MAX_2K_RESOLUTION (2088960)
+#define MAX_DEC_INSTANCE (15)
+
+typedef struct {
+	/* NTSC and PAL */
+	unsigned int PTSHigh;
+	unsigned int PTSLow;
+	unsigned int cc_type;
+	unsigned int repeat_first_field;
+	unsigned int top_field_first;
+	unsigned int size;
+} VIDEO_CC_CALLBACK_HEADER;
+
+struct ve2_ctx {
+	struct ve2rpc *out_hndl;
+	struct ve2rpc *cap_hndl;
+#ifdef REORDER_PTS
+	struct list_head pts_list;
+#endif
+	bool eosEvent;
+	bool eos;
+	bool no_frame;
+	bool streamon_out;
+	bool streamon_cap;
+	bool streamoff_out;
+	bool streamoff_cap;
+	bool is_run;
+	int32_t internal_buf_cnt;
+	bool is_cmprs;
+	bool gpu_cache_en;
+	struct ve2rpc_ion_object *dma_obj;
+};
+
+/* Return dma-buf fd and get offset & size from RPC driver */
+extern int r_program_fd(unsigned long phys_addr, unsigned long *offset,
+			unsigned long *size);
+#ifdef ENABLE_TEE_DRM_FLOW
+extern int ta_TEEapi_init(struct tee_context **teeapi_ctx,
+			  unsigned int *teeapi_tee_session);
+extern int ta_TEEapi_deinit(struct tee_context *teeapi_ctx,
+			    unsigned int teeapi_tee_session);
+#endif
+/*
+ * Return ve2_ctx structure for a given struct v4l2_fh
+ */
+static struct ve2_ctx *fh_to_ve(struct v4l2_fh *fh)
+{
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	return vid_ctx->ve_ctx;
+}
+
+static struct vpu_ctx *fh_to_vpu(struct v4l2_fh *fh)
+{
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	return vid_ctx->vpu_ctx;
+}
+
+/*
+ * Return ve2_ctx structure for a given struct vb2_queue
+ */
+static struct ve2_ctx *vq_to_ve(struct vb2_queue *q)
+{
+	struct videc_ctx *vid_ctx = vb2_get_drv_priv(q);
+	return vid_ctx->ve_ctx;
+}
+
+int ve2_start_streaming(struct vb2_queue *q, uint32_t count, int pixelformat)
+{
+	struct ve2_ctx *ctx = vq_to_ve(q);
+	struct videc_ctx *vid_ctx = vb2_get_drv_priv(q);
+	struct vpu_ctx *v_ctx = (struct vpu_ctx *)vid_ctx->vpu_ctx;
+	int type = q->type;
+	int ret;
+
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	vpu_info("ve2_start_streaming(%s), codec %p4cc\n", v4l2_type_names[type],
+	       &pixelformat);
+
+	if (!(pixelformat == V4L2_PIX_FMT_HEVC ||
+	      pixelformat == V4L2_PIX_FMT_AV1 ||
+	      pixelformat == V4L2_PIX_FMT_VP9)) {
+		vpu_err("Unsupport pixel format %s, %p4cc\n",
+			V4L2_TYPE_TO_STR(type), &pixelformat);
+		return -EINVAL;
+	}
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type) && (ctx->streamon_out == 1)) {
+		vpu_err("%s OUTPUT is already stream on\n", __func__);
+		return -EPERM;
+	} else if (V4L2_TYPE_IS_CAPTURE(q->type) && (ctx->streamon_cap == 1)) {
+		vpu_err("%s CAPTURE is already stream on\n", __func__);
+		return -EPERM;
+	}
+
+	if (V4L2_TYPE_IS_OUTPUT(type)) {
+#ifdef VPU_GET_CC
+		ret = ve2rpc_setDecoderCCBypass(ctx->out_hndl,
+						VIDEODECODER_CC_CALLBACK);
+		if (ret) {
+			vpu_err("ve2rpc_inband_newseg fail\n");
+			return ret;
+		}
+#endif
+		ret = ve2rpc_set_cmprs(ctx->out_hndl, ctx->is_cmprs);
+		if (ret) {
+			vpu_err("ve2rpc fail to set cmprs\n");
+			return ret;
+		}
+
+		ret = ve2rpc_inband_newseg(ctx->out_hndl);
+		if (ret) {
+			vpu_err("ve2rpc_inband_newseg fail\n");
+			return ret;
+		}
+
+		ret = ve2rpc_inband_decode(ctx->out_hndl, NORMAL_DECODE);
+		if (ret) {
+			vpu_err("ve2rpc_inband_decode fail\n");
+			return ret;
+		}
+
+#ifdef VPU_GET_CC
+		ret = ve2rpc_SetRingBuffer(ctx->out_hndl, &ctx->out_hndl->cc_rb,
+					   0x100000 /* 1MB */, RINGBUFFER_DTVCC,
+					   false);
+		if (ret) {
+			vpu_err("ve2rpc fail to initial cc_rb\n");
+			return -EPERM;
+		}
+#endif
+#ifdef SUPPORT_ADAPTIVE_PLAYBACK
+		if (vid_ctx->params.dec_params.en_adaptive_playback)
+			ctx->cap_hndl->main_rb.pRBH->reserve3 =
+				htonl(0 /*width*/ << 16 | 0 /*height*/);
+		else
+			ctx->cap_hndl->main_rb.pRBH->reserve3 = htonl(
+				v_ctx->cap_fmt.misc.ori_width << 16 |
+				v_ctx->cap_fmt.misc.ori_height);
+#endif
+		ctx->out_hndl->main_rb.memory = q->memory;
+
+		ctx->streamon_out = 1;
+		ctx->streamoff_out = 0;
+		ctx->out_hndl->type = type;
+#ifdef VPU_GET_CC
+		cc_data_channel_init();
+#endif
+	} else {
+		ctx->streamon_cap = 1;
+		ctx->streamoff_cap = 0;
+		ctx->cap_hndl->type = type;
+		ctx->cap_hndl->bit_depth = (v_ctx->bit_depth == 10)?10:8;
+
+#ifdef ENABLE_GPU_CACHE
+		if (ctx->gpu_cache_en && !ctx->cap_hndl->gpu_cache_ctrl) {
+			ctx->cap_hndl->gpu_cache_ctrl = rtk_gpu_cache_control_create();
+			if (!ctx->cap_hndl->gpu_cache_ctrl)
+				vpu_err("Create gpu cache controller fail");
+			else
+				ctx->cap_hndl->ddr_height = v_ctx->cap_fmt.spec.fmt.pix_mp.height;
+		}
+#endif
+	}
+
+	if (ctx->streamon_out && ctx->streamon_cap) {
+		ret = ve2rpc_run(ctx->cap_hndl);
+		if (ret) {
+			vpu_err("ve2rpc_run cap_hndl fail\n");
+			return ret;
+		}
+
+		ret = ve2rpc_run(ctx->out_hndl);
+		if (ret) {
+			vpu_err("ve2rpc_run out_hndl fail\n");
+			return ret;
+		}
+		ctx->is_run = true;
+	} else if (ctx->streamon_cap) {
+		ret = ve2rpc_run(ctx->cap_hndl);
+		if (ret) {
+			vpu_err("ve2rpc_run cap_hndl fail\n");
+			return ret;
+		}
+	}
+	return 0;
+}
+
+int ve2_abort(void *ve_ctx, int type)
+{
+	return 0;
+}
+
+static void ve2_make_undq_capbuf_done(struct ve2_ctx *ctx)
+{
+	int i = 0;
+	struct ve2rpc *cap_hndl;
+
+	if (ctx == NULL) {
+		vpu_err("%s invalid parameters\n", __func__);
+		return;
+	}
+
+	cap_hndl = ctx->cap_hndl;
+	mutex_lock(&cap_hndl->dpb_mutex);
+	for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
+		struct vb2_v4l2_buffer *vb2_v4l2_buf =
+			(struct vb2_v4l2_buffer *)cap_hndl->dpb[i].vb2_v4l2_buf;
+
+		if (cap_hndl->dpb[i].status == RTKVE2_DPB_ST_VALID &&
+			vb2_v4l2_buf->vb2_buf.state == VB2_BUF_STATE_ACTIVE) {
+			v4l2_m2m_buf_done(
+				(struct vb2_v4l2_buffer
+					 *)(cap_hndl->dpb[i].vb2_v4l2_buf),
+				VB2_BUF_STATE_ERROR);
+		}
+	}
+
+	mutex_unlock(&cap_hndl->dpb_mutex);
+}
+
+int ve2_stop_streaming(struct vb2_queue *q)
+{
+	struct ve2_ctx *ctx = vq_to_ve(q);
+	int type = q->type;
+	struct ve2rpc *hndl;
+	int ret = 0;
+
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		goto exit;
+	}
+
+	if (V4L2_TYPE_IS_OUTPUT(type)) {
+		if (!ctx->streamon_out) {
+			vpu_err("No out stream on !!!\n");
+			ret = (-EPERM);
+			goto exit;
+		}
+		hndl = ctx->out_hndl;
+	} else {
+		if (!ctx->streamon_cap) {
+			vpu_err("No cap stream on !!!\n");
+			ret = (-EPERM);
+			goto exit;
+		}
+		hndl = ctx->cap_hndl;
+	}
+
+	if (!hndl) {
+		vpu_err("ve2_stop_streaming %s hnd is NULL\n",
+			V4L2_TYPE_TO_STR(q->type));
+		goto exit;
+	}
+
+	if (!ctx->streamon_out && !ctx->streamon_cap) {
+		vpu_err("No streamon can't streamoff !!!\n");
+		ret = (-EPERM);
+		goto exit;
+	}
+
+	if (ctx->streamoff_out && ctx->streamoff_cap) {
+		vpu_err("Streamoff return directly\n");
+		goto exit;
+	}
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		ret = ve2rpc_pause(ctx->out_hndl);
+		if (ret) {
+			vpu_err("out ve2rpc_pause fail\n");
+			goto exit;
+		}
+
+		ret = ve2rpc_flush(ctx->out_hndl);
+		if (ret) {
+			vpu_err("out ve2rpc_fluse fail\n");
+			goto exit;
+		}
+
+		if(ctx->streamoff_cap) {
+			ret = ve2rpc_pause(ctx->cap_hndl);
+			if (ret) {
+				vpu_err("cap ve2rpc_pause fail\n");
+				goto exit;
+			}
+
+			ret = ve2rpc_flush(ctx->cap_hndl);
+			if (ret) {
+				vpu_err("cap ve2rpc_fluse fail\n");
+				goto exit;
+			}
+		}
+
+		ret = ve2rpc_reset_bs_ring_rwptr(ctx->out_hndl);
+		if (ret) {
+			vpu_err("reset bs_ringbuffer_rwptr fail\n");
+			goto exit;
+		}
+
+		ctx->internal_buf_cnt = 0;
+		ctx->streamoff_out = 1;
+		ctx->streamon_out = 0;
+	} else {
+		ret = ve2rpc_pause(ctx->cap_hndl);
+		if (ret) {
+			vpu_err("cap ve2rpc_pause fail\n");
+			goto exit;
+		}
+		ret = ve2rpc_flush(ctx->cap_hndl);
+		if (ret) {
+			vpu_err("cap ve2rpc_fluse fail\n");
+			goto exit;
+		}
+
+		ret = ve2rpc_reset_msg_ring_rwptr(ctx->cap_hndl);
+		if (ret) {
+			vpu_err("reset frm_ringbuffer_rwptr fail\n");
+			goto exit;
+		}
+
+		ret = ve2rpc_reset_buflock(ctx->cap_hndl, false);
+		if (ret) {
+			vpu_err("ve2rpc_reset_buflock fail\n");
+			goto exit;
+		}
+
+		ve2_make_undq_capbuf_done(ctx);
+
+		ctx->internal_buf_cnt = 0;
+#ifdef REORDER_PTS
+		ctx->cap_hndl->pre_pts = 0;
+#endif
+		ctx->streamoff_cap = 1;
+		ctx->streamon_cap = 0;
+	}
+
+#ifdef REORDER_PTS
+	if (ctx->streamoff_out && ctx->streamoff_cap) {
+		if (ctx->out_hndl->is_pts_reorder) {
+			ret = ve2rpc_free_pts(ctx->out_hndl);
+			if (ret) {
+				vpu_err("ve2rpc_free_pts fail\n");
+				goto exit;
+			}
+		}
+	}
+#endif
+exit:
+	return ret;
+}
+
+static int ve2_out_qbuf(void *fh, uint8_t *buf, uint32_t len, uint64_t pts,
+			uint32_t sequence)
+{
+	struct ve2_ctx *ctx = fh_to_ve(fh);
+	struct ve2rpc *out_hdl = NULL;
+	struct ve2rpc *cap_hdl = NULL;
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	struct vpu_ctx *v_ctx = (struct vpu_ctx *)vid_ctx->vpu_ctx;
+	int ret;
+
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		return -EINVAL;
+	}
+	out_hdl = ctx->out_hndl;
+	cap_hdl = ctx->cap_hndl;
+
+	vpu_input_dbg("ve2_out_qbuf seq %d, pts %lld, len %x\n", sequence, pts,
+		      len);
+
+	if (v_ctx->is_decoder_error || out_hdl->is_error) {
+		vpu_err("%s decode error %d, %d", __func__,v_ctx->is_decoder_error, out_hdl->is_error);
+		return -EIO;
+	}
+	if (v_ctx->is_bs_error)
+		vpu_err("%s bitstream error %d", __func__, v_ctx->is_bs_error);
+
+	if (ctx->internal_buf_cnt > 0 && v_ctx->cap_fmt.misc.bufcnt > 0 &&
+		ctx->internal_buf_cnt > (v_ctx->cap_fmt.misc.bufcnt << 1)) {
+		vpu_input_dbg("too many internal buffers %d, %d\n", ctx->internal_buf_cnt,
+		      v_ctx->cap_fmt.misc.bufcnt);
+		return -ENOSPC;
+	}
+
+	ret = ve2rpc_write_bs(out_hdl, buf, len, pts, sequence);
+	if (ret) {
+		vpu_input_dbg("ve2rpc_write_bs fail, ret %d\n", ret);
+		return ret;
+	} else {
+#ifdef REORDER_PTS
+		if (ctx->out_hndl->is_pts_reorder) {
+			struct pts_queue *p = (struct pts_queue *)kmalloc(
+				sizeof(struct pts_queue), GFP_KERNEL | __GFP_ZERO);
+			if (!p) {
+				vpu_err("ve2_out_qbuf malloc fail\n");
+				return -ENOMEM;
+			}
+			p->pts = pts;
+			p->idx = sequence;
+			mutex_lock(&ctx->cap_hndl->pts_mutex);
+			list_add_tail(&p->list, &ctx->pts_list);
+			mutex_unlock(&ctx->cap_hndl->pts_mutex);
+		}
+#endif
+		ctx->internal_buf_cnt++;
+	}
+
+	return 0;
+}
+
+static int ve2_cap_qbuf(void *fh, struct vb2_buffer *vb)
+{
+	struct ve2_ctx *ctx = vq_to_ve(vb->vb2_queue);
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	struct vpu_ctx *v_ctx = (struct vpu_ctx *)vid_ctx->vpu_ctx;
+	struct vb2_v4l2_buffer *vb2_v4l2_buf = NULL;
+	dma_addr_t cap_buf_paddr = 0;
+	struct vb2_v4l2_buffer *rm_vb2_v4l2_buf = NULL;
+	int ret = 0;
+
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (!ctx->cap_hndl) {
+		vpu_err("cap is uninited\n");
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	vb2_v4l2_buf = to_vb2_v4l2_buffer(vb);
+
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+	cap_buf_paddr = vb2_dma_contig_plane_dma_addr(vb, 0) + METADATA_OFFSET;
+#else
+	cap_buf_paddr = vb2_dma_contig_plane_dma_addr(vb, 0);
+#endif
+	if (ctx->cap_hndl->dpb_cnt < vb->vb2_queue->num_buffers) {
+		uint32_t cap_buf_size = 0;
+		struct rtkve2_reg_dpb_t dpb = {0};
+
+		cap_buf_size = vb2_plane_size(vb, 0);
+		if (cap_buf_size == 0) {
+			vpu_err("cap_buf_size is 0\n");
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		dpb.width = v_ctx->cap_fmt.misc.ori_width;
+		dpb.height = v_ctx->cap_fmt.misc.ori_height;
+		dpb.dpb_width = v_ctx->ddr_width;
+		dpb.dpb_height = v_ctx->cap_fmt.spec.fmt.pix_mp.height;
+		dpb.size = cap_buf_size;
+		dpb.y_phy_addr = (uint64_t)cap_buf_paddr;
+		dpb.c_phy_addr = dpb.y_phy_addr + dpb.dpb_width * dpb.dpb_height;
+		dpb.bit_depth = v_ctx->bit_depth;
+		dpb.vb2_v4l2_buf = vb2_v4l2_buf;
+		dpb.idx = vb->index;
+
+		ret = ve2rpc_add_capbuf_to_dpb(
+			ctx->out_hndl, ctx->cap_hndl, dpb, ctx->is_cmprs);
+		if (ret != 0)
+			goto exit;
+	}
+
+	rm_vb2_v4l2_buf =
+		v4l2_m2m_dst_buf_remove(((struct v4l2_fh *)fh)->m2m_ctx);
+	if (rm_vb2_v4l2_buf != vb2_v4l2_buf) {
+		vpu_output_dbg(
+			"the vb2_v4l2_buf:0x%px from v4l2_m2m_dst_buf_remove() not equals to cap_qbuf:0x%px\n",
+			rm_vb2_v4l2_buf, vb2_v4l2_buf);
+	}
+
+	ret = ve2rpc_qframe(ctx->cap_hndl, cap_buf_paddr, vb->index);
+	if (ret) {
+		vpu_err("ve2rpc_qframe fail, ret %d\n", ret);
+		goto exit;
+	}
+
+	ve2rpc_update_dpb_st(ctx->cap_hndl, vb2_v4l2_buf, RTKVE2_DPB_ST_VALID);
+
+exit:
+	return ret;
+}
+
+#ifdef VPU_GET_CC
+int ve2_cc_wrapper_write(void *data, int data_size)
+{
+	// process cc data
+	bool isCcData = false;
+	char *pcSrc = (char *)data;
+
+	short itu_t_t35_provider_code;
+	char *pCCdata = pcSrc + sizeof(VIDEO_CC_CALLBACK_HEADER);
+	itu_t_t35_provider_code = (short)((pCCdata[1] << 8) |
+					  (pCCdata[2])); // ARM is little-endian
+
+	switch (itu_t_t35_provider_code) {
+	case 47: // Direct TV
+		if (pCCdata[3] == 3) {
+			isCcData = true;
+		}
+		break;
+	case 49: // ATSC
+		if (pCCdata[3] == 'G' && pCCdata[4] == 'A' &&
+		    pCCdata[5] == '9' && pCCdata[6] == '4' && pCCdata[7] == 3) {
+			isCcData = true;
+		}
+		break;
+	default:
+		break;
+	}
+
+	if (isCcData) {
+		char ccOutputBuf[VIDEO_CC_DATA_LENGTH];
+		short ccDataLen;
+
+		// Add CC data header
+		// CC MAGIC NUMBER
+		ccOutputBuf[0] = 0x63;
+		ccOutputBuf[1] = 0x4b;
+		ccOutputBuf[2] = 0x74;
+		ccOutputBuf[3] = 0x52;
+		// CC data length
+		ccOutputBuf[4] = pcSrc[23] - COUNTRY_CODE_OFFSET;
+		ccOutputBuf[5] = pcSrc[22];
+		ccOutputBuf[6] = pcSrc[21];
+		ccOutputBuf[7] = pcSrc[20];
+		// PTSHigh
+		ccOutputBuf[8] = pcSrc[0];
+		ccOutputBuf[9] = pcSrc[1];
+		ccOutputBuf[10] = pcSrc[2];
+		ccOutputBuf[11] = pcSrc[3];
+		// PTSLow
+		ccOutputBuf[12] = pcSrc[4];
+		ccOutputBuf[13] = pcSrc[5];
+		ccOutputBuf[14] = pcSrc[6];
+		ccOutputBuf[15] = pcSrc[7];
+
+		ccDataLen = ccOutputBuf[4];
+		memcpy(&ccOutputBuf[CC_DATA_HEADER_LEN],
+		       pCCdata + COUNTRY_CODE_OFFSET, ccDataLen);
+
+		// send to ccReader
+		if (cc_isCCReaderReady()) {
+			cc_data_channel_send(ccOutputBuf,
+					     ccDataLen + CC_DATA_HEADER_LEN,
+					     cc_getCCReaderPid());
+		}
+	}
+
+	return 0;
+}
+#endif
+
+static int ve2_map_colorformat(struct ve2_ctx *ctx,
+			    uint8_t ycbcr_enc, uint8_t xfer_func)
+{
+	switch(ycbcr_enc) {
+	case V4L2_YCBCR_ENC_709:
+	case V4L2_YCBCR_ENC_XV709:
+		ctx->cap_hndl->col_matrix.matrix_coefficients = 1;
+		break;
+	case V4L2_YCBCR_ENC_601:
+	case V4L2_YCBCR_ENC_XV601:
+		ctx->cap_hndl->col_matrix.matrix_coefficients = 6;
+		break;
+	case V4L2_YCBCR_ENC_SMPTE240M:
+		ctx->cap_hndl->col_matrix.matrix_coefficients = 7;
+		break;
+	case V4L2_YCBCR_ENC_BT2020:
+		ctx->cap_hndl->col_matrix.matrix_coefficients = 9;
+		break;
+	case V4L2_YCBCR_ENC_BT2020_CONST_LUM:
+		ctx->cap_hndl->col_matrix.matrix_coefficients = 10;
+		break;
+	case V4L2_YCBCR_ENC_DEFAULT:
+	default: /* unknown */
+		ctx->cap_hndl->col_matrix.matrix_coefficients = 0;
+		break;
+	}
+
+	switch(xfer_func) {
+	case V4L2_XFER_FUNC_SMPTE2084:
+		ctx->cap_hndl->col_matrix.transfer_characteristics = 2;
+		break;
+#if 0  //TODO:HLG?
+		ctx->cap_hndl->col_matrix.transfer_characteristics = 6;
+		break;
+#endif
+	default:
+		ctx->cap_hndl->col_matrix.transfer_characteristics = 0;
+		break;
+	}
+
+	return 0;
+}
+
+static void update_color_matrix(void *fh)
+{
+	struct ve2_ctx *ctx = fh_to_ve(fh);
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	struct vpu_ctx *v_ctx = fh_to_vpu(fh);
+	struct v4l2_ctrl_hdr10_mastering_display *mastering =
+		&vid_ctx->params.mastering;
+
+	if(!ctx || !v_ctx) {
+		vpu_err("%s ctx or v_ctx is NULL\n", __func__);
+		return;
+	}
+
+	if (vid_ctx->params_update) {
+		ve2_map_colorformat(ctx, v_ctx->cap_fmt.spec.fmt.pix_mp.ycbcr_enc,
+			v_ctx->cap_fmt.spec.fmt.pix_mp.xfer_func);
+
+		ctx->cap_hndl->col_matrix.primary_r_chromaticity_x =
+			mastering->display_primaries_x[0] * CIE1931_TO_SMPTE;
+		ctx->cap_hndl->col_matrix.primary_g_chromaticity_x =
+			mastering->display_primaries_x[1] * CIE1931_TO_SMPTE;
+		ctx->cap_hndl->col_matrix.primary_b_chromaticity_x =
+			mastering->display_primaries_x[2] * CIE1931_TO_SMPTE;
+		ctx->cap_hndl->col_matrix.primary_r_chromaticity_y =
+			mastering->display_primaries_y[0] * CIE1931_TO_SMPTE;
+		ctx->cap_hndl->col_matrix.primary_g_chromaticity_y =
+			mastering->display_primaries_y[1] * CIE1931_TO_SMPTE;
+		ctx->cap_hndl->col_matrix.primary_b_chromaticity_y =
+			mastering->display_primaries_y[2] * CIE1931_TO_SMPTE;
+		ctx->cap_hndl->col_matrix.whitepoint_chromaticity_x =
+			mastering->white_point_x * CIE1931_TO_SMPTE;
+		ctx->cap_hndl->col_matrix.whitepoint_chromaticity_y =
+			mastering->white_point_y * CIE1931_TO_SMPTE;
+		ctx->cap_hndl->col_matrix.luminance_min =
+			mastering->min_display_mastering_luminance * CANDELAS_PER_SQUARE_METER_BASE;
+		ctx->cap_hndl->col_matrix.luminance_max =
+			mastering->max_display_mastering_luminance * CANDELAS_PER_SQUARE_METER_BASE;
+		vid_ctx->params_update = false;
+	}
+}
+
+int ve2_cap_dqbuf(void *fh, uint8_t *buf, uint64_t *pts,
+		  struct vb2_v4l2_buffer **disp_buf)
+{
+	struct ve2_ctx *ctx = fh_to_ve(fh);
+	struct vpu_ctx *v_ctx = NULL;
+	uint32_t no_show_frm_cnt = 0;
+	int ret;
+#ifdef VPU_GET_CC
+	char cc_message[VIDEO_CC_DATA_LENGTH];
+	int cc_len;
+#endif
+
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!ctx->cap_hndl) {
+		vpu_err("cap is uninited\n");
+		return -EINVAL;
+	}
+
+	v_ctx = fh_to_vpu(fh);
+	if (v_ctx == NULL) {
+		vpu_err("%s vpu_ctx is NULL\n", __func__);
+		return -EINVAL;
+	}
+	update_color_matrix(fh);
+	ret = ve2rpc_dqframe(ctx->cap_hndl, disp_buf, pts, &ctx->eos,
+			     &ctx->no_frame, &no_show_frm_cnt);
+
+	if (ret == 0) {
+		ctx->internal_buf_cnt -= (no_show_frm_cnt + 1);
+	} else {
+		if (ret == -ENODATA)
+			ctx->internal_buf_cnt -= no_show_frm_cnt;
+
+		//ve2_cap_dqbuf fail is normal
+		return ret;
+	}
+
+	vpu_output_dbg("ve2_cap_dqbuf pts %lld\n", *pts);
+
+	// write CC data
+#ifdef VPU_GET_CC
+	cc_len = ve2rpc_readCcRingBuf(&ctx->out_hndl->cc_rb,
+				      VIDEO_CC_DATA_LENGTH, cc_message);
+
+	if (cc_len > 0)
+		ve2_cc_wrapper_write(cc_message, cc_len);
+#endif
+
+	ve2rpc_update_dpb_st(ctx->cap_hndl,  *disp_buf, RTKVE2_DPB_ST_DQ);
+
+	return 0;
+}
+
+static void *ve2_alloc_context(void *fh)
+{
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	struct vpu_ctx *vpu_ctx = fh_to_vpu(fh);
+	struct ve2_ctx *ctx = NULL;
+	VIDEO_STREAM_TYPE eStreamType = VIDEO_STREAM_H265;
+	int pixelformat = vpu_ctx->out_fmt.spec.fmt.pix_mp.pixelformat;
+	struct device *dev = vid_ctx->dev->dev;
+	int ret = 0;
+
+	if (!fh) {
+		vpu_err("%s, fh is NULL\n", __func__);
+		goto exit;
+	}
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		vpu_err("Failed to allocate video engine\n");
+		goto exit;
+	}
+
+	ctx->dma_obj = ve2rpc_init_shuttle(dev);
+	if (IS_ERR(ctx->dma_obj)) {
+		vpu_err("Failed to allocate shuttle buf\n");
+		goto err_init_shuttle;
+	}
+
+	ret = ve2rpc_init_cap_handle(dev, &ctx->cap_hndl,
+				     vid_ctx->params.is_secure,
+				     fh, ctx->dma_obj);
+	if (ret) {
+		vpu_err("ve2rpc_init_handle cap fail\n");
+		goto err_init_cap;
+	}
+
+	ret = ve2rpc_init_out_handle(dev, &ctx->out_hndl,
+				     vid_ctx->params.is_secure,
+				     fh, ctx->dma_obj);
+	if (ret) {
+		vpu_err("ve2rpc_init_handle out fail\n");
+		goto err_init_out;
+	}
+
+	if (!ctx->out_hndl || !ctx->cap_hndl) {
+		vpu_err("ve2rpc_init_handle fail\n");
+		goto error;
+	}
+
+#ifdef SUPPORT_ADAPTIVE_PLAYBACK
+	ctx->cap_hndl->is_adaptive_playback =
+		ctx->out_hndl->is_adaptive_playback =
+		vid_ctx->params.dec_params.en_adaptive_playback;
+#endif
+
+#ifdef REORDER_PTS
+	ctx->cap_hndl->is_pts_reorder =
+		ctx->out_hndl->is_pts_reorder =
+		vid_ctx->params.dec_params.en_pts_reorder;
+
+	if (vid_ctx->params.dec_params.en_pts_reorder) {
+		ctx->cap_hndl->lastID = 0;
+		mutex_init(&ctx->cap_hndl->pts_mutex);
+		INIT_LIST_HEAD(&ctx->pts_list);
+		ctx->cap_hndl->pts_queue = &ctx->pts_list;
+		ctx->out_hndl->pts_queue = &ctx->pts_list;
+	}
+#endif
+
+	ret = ve2rpc_connect(ctx->out_hndl, ctx->cap_hndl);
+	if (ret) {
+		vpu_err("ve2rpc_connect fail\n");
+		goto error;
+	}
+
+#ifdef ENABLE_TEE_DRM_FLOW
+	ret = ta_TEEapi_init(
+		(struct tee_context **)&ctx->out_hndl->teeapi_ctx,
+		&ctx->out_hndl->teeapi_tee_session);
+	if (ret < 0) {
+		vpu_err("%s ta_TEEapi_init() fail, ret:%d\n", __func__,
+			ret);
+		goto error;
+	}
+
+	ctx->out_hndl->main_rb.teeapi_ctx = ctx->out_hndl->teeapi_ctx;
+	ctx->out_hndl->main_rb.teeapi_tee_session =
+		ctx->out_hndl->teeapi_tee_session;
+#endif
+
+
+	if (pixelformat == V4L2_PIX_FMT_HEVC)
+		eStreamType = VIDEO_STREAM_H265;
+	else if (pixelformat == V4L2_PIX_FMT_VP9)
+		eStreamType = VIDEO_STREAM_VP9;
+	else if (pixelformat == V4L2_PIX_FMT_AV1)
+		eStreamType = VIDEO_STREAM_AV1;
+	else {
+		vpu_err("unsupport codec! %p4cc\n", &pixelformat);
+		goto error;
+	}
+
+	ctx->out_hndl->vType = eStreamType;
+	ret = ve2rpc_setRole(ctx->out_hndl, eStreamType);
+	if (ret) {
+		vpu_err("ve2rpc_setRole fail %p4cc\n", &pixelformat);
+		goto error;
+	}
+
+	ret = ve2rpc_enable_drop_cnt(ctx->out_hndl);
+	if (ret) {
+		vpu_err("ve2rpc fail to report drop cnt\n");
+		goto error;
+	}
+
+	return ctx;
+
+error:
+	if (ctx->out_hndl)
+		ve2rpc_uninit_handle(ctx->out_hndl);
+err_init_out:
+	if (ctx->cap_hndl)
+		ve2rpc_uninit_handle(ctx->cap_hndl);
+err_init_cap:
+	if (ctx->dma_obj)
+		ve2rpc_uninit_shuttle(dev, ctx->dma_obj);
+err_init_shuttle:
+	if (ctx)
+		kfree(ctx);
+exit:
+	return ERR_PTR(-EFAULT);
+}
+
+static void ve2_free_capture(void *ve_ctx)
+{
+	struct ve2_ctx *ctx = (struct ve2_ctx *)ve_ctx;
+	int ret = 0;
+
+	if (!ctx)
+		goto exit;
+
+	if ( !ctx->cap_hndl || !ctx->out_hndl)
+		goto exit;
+
+	if (ctx->is_run) {
+		ret = ve2rpc_pause(ctx->cap_hndl);
+		if (ret) {
+			vpu_err("out ve2rpc_pause fail\n");
+			goto exit;
+		}
+
+		ret = ve2rpc_free_travel_frame(ctx->cap_hndl);
+		if (ret) {
+			vpu_err("ve2rpc_free_travel_frame fail\n");
+			goto exit;
+		}
+
+		ret = ve2rpc_reset_buflock(ctx->cap_hndl, true);
+		if (ret) {
+			vpu_err("ve2rpc_reset_buflock to UNLOCK fail\n");
+			goto exit;
+		}
+	}
+
+	ret = ve2rpc_del_capbuf_from_dpb(ctx->out_hndl, ctx->cap_hndl);
+	if (ret) {
+		vpu_err("out del_capbuf_from_dpb fail\n");
+		goto exit;
+	}
+
+	if (ctx->is_run) {
+		ret = ve2rpc_flush(ctx->cap_hndl);
+		if (ret) {
+			vpu_err("cap ve2rpc_fluse fail\n");
+			goto exit;
+		}
+	}
+exit:
+	return;
+}
+
+static void ve2_free_context(void *ve_ctx)
+{
+	struct ve2_ctx *ctx = (struct ve2_ctx *)ve_ctx;
+	int ret = 0;
+
+	if (!ctx)
+		goto exit;
+
+	if ( !ctx->cap_hndl || !ctx->out_hndl)
+		goto exit;
+
+	if (ctx->is_run) {
+		ret = ve2rpc_stop(ctx->cap_hndl);
+		if (ret) {
+			vpu_err("cap ve2rpc_stop fail\n");
+			goto exit;
+		}
+
+		ret = ve2rpc_stop(ctx->out_hndl);
+		if (ret) {
+			vpu_err("out ve2rpc_stop fail\n");
+			goto exit;
+		}
+
+		ret = ve2rpc_free_travel_frame(ctx->cap_hndl);
+		if (ret) {
+			vpu_err("ve2rpc_free_travel_frame fail\n");
+			goto exit;
+		}
+
+		ctx->is_run = false;
+	}
+	ret = ve2rpc_reset_buflock(ctx->cap_hndl, true);
+	if (ret) {
+		vpu_err("ve2rpc_reset_buflock fail\n");
+		goto exit;
+	}
+
+	ret = ve2rpc_close(ctx->cap_hndl);
+	if (ret) {
+		vpu_err("cap ve2rpc_close fail\n");
+		goto exit;
+	}
+
+	ret = ve2rpc_close(ctx->out_hndl);
+	if (ret) {
+		vpu_err("out ve2rpc_close fail\n");
+		goto exit;
+	}
+
+	if (V4L2_TYPE_IS_CAPTURE(ctx->cap_hndl->type)) {
+		struct task_struct *t;
+
+		t = xchg(&ctx->cap_hndl->buflock_thread, NULL);
+		if(t) {
+			wake_up_interruptible(&ctx->cap_hndl->buflock_waitq);
+			kthread_stop(t);
+		}
+	}
+
+	ret = ve2rpc_del_capbuf_from_dpb(ctx->out_hndl, ctx->cap_hndl);
+	if (ret) {
+		vpu_err("out del_capbuf_from_dpb fail\n");
+		goto exit;
+	}
+
+#ifdef ENABLE_TEE_DRM_FLOW
+	ret = ta_TEEapi_deinit(
+		(struct tee_context *)ctx->out_hndl->teeapi_ctx,
+		ctx->out_hndl->teeapi_tee_session);
+	if (ret < 0) {
+		vpu_err("%s ta_TEEapi_deinit() fail, ret:%d\n",
+			__func__, ret);
+		goto exit;
+	}
+#endif
+
+#ifdef REORDER_PTS
+	if (ctx->cap_hndl->is_pts_reorder)
+		mutex_destroy(&ctx->cap_hndl->pts_mutex);
+#endif
+	if (ctx->dma_obj) {
+		ve2rpc_uninit_shuttle(ctx->out_hndl->dev, ctx->dma_obj);
+		ctx->dma_obj = NULL;
+	}
+
+	ret = ve2rpc_uninit_handle(ctx->out_hndl);
+	if (ret) {
+		vpu_err("ve2rpc_uninit_handle fail out\n");
+		goto exit;
+	}
+	ctx->out_hndl = NULL;
+
+	ret = ve2rpc_uninit_handle(ctx->cap_hndl);
+	if (ret) {
+		vpu_err("ve2rpc_uninit_handle fail out\n");
+		goto exit;
+	}
+	ctx->cap_hndl = NULL;
+
+exit:
+	if (ctx)
+		kfree(ctx);
+}
+
+
+static int ve2_force_eos(void *fh, struct ve2rpc *cap_hndl)
+{
+	const struct v4l2_event eos_event = { .type = V4L2_EVENT_EOS };
+	struct vb2_v4l2_buffer *buf = NULL;
+	int i = 0;
+
+	mutex_lock(&cap_hndl->dpb_mutex);
+	for (i = VE2_MAX_DPB_NUM - 1; i >= 0; i--) {
+		struct vb2_v4l2_buffer *tmp = (struct vb2_v4l2_buffer *)cap_hndl->dpb[i].vb2_v4l2_buf;
+		if (cap_hndl->dpb[i].status == RTKVE2_DPB_ST_VALID &&
+				tmp->vb2_buf.state == VB2_BUF_STATE_ACTIVE) {
+			buf = cap_hndl->dpb[i].vb2_v4l2_buf;
+			break;
+		}
+	}
+
+	if (i == -1) {
+		vpu_err("Can't find valid buffer for EOS\n");
+		mutex_unlock(&cap_hndl->dpb_mutex);
+		return -ENOBUFS;
+	}
+	mutex_unlock(&cap_hndl->dpb_mutex);
+
+	vb2_set_plane_payload(&buf->vb2_buf, 0, 0);
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+	buf->vb2_buf.planes[0].data_offset = 0;
+#endif
+	v4l2_m2m_last_buffer_done(((struct v4l2_fh *)fh)->m2m_ctx, buf);
+	v4l2_event_queue_fh(fh, &eos_event);
+
+	return 0;
+}
+
+static int ve2_stop_cmd(void *fh, int pixelformat)
+{
+	struct ve2_ctx *ctx = NULL;
+	struct ve2rpc *hndl = NULL;
+	struct vpu_ctx *v_ctx = NULL;
+	int ret = 0;
+
+	if (!fh) {
+		vpu_err("%s invalid parameters\n", __func__);
+		goto out;
+	}
+	ctx = fh_to_ve(fh);
+	if (!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		goto out;
+	}
+
+	hndl = ctx->out_hndl;
+	if (!hndl) {
+		vpu_err("%s hndl is NULL\n", __func__);
+		goto out;
+	}
+
+	v_ctx = fh_to_vpu(fh);
+	if (v_ctx == NULL) {
+		vpu_err("%s v_ctx is NULL\n", __func__);
+		goto out;
+	}
+
+	if (ctx->eosEvent == 0) {
+		if (v_ctx->out_fmt.spec.fmt.pix_mp.pixelformat ==
+		    V4L2_PIX_FMT_HEVC)
+			ve2rpc_inband_eos_event(&hndl->sub_rb,
+						hndl->main_rb.pRBH, 2);
+		else
+			ve2rpc_inband_eos_event(&hndl->sub_rb,
+						hndl->main_rb.pRBH, 0);
+
+		if(hndl->is_error || v_ctx->is_bs_error || v_ctx->is_decoder_error)
+			ve2_force_eos(fh, ctx->cap_hndl);
+
+		ctx->eosEvent = 1;
+	}
+
+out:
+	return ret;
+}
+
+static int ve2_start_cmd(void *fh)
+{
+	struct ve2_ctx *ctx = NULL;
+	int ret = 0;
+
+	if (!fh) {
+		vpu_err("%s invalid parameters\n", __func__);
+		goto out;
+	}
+	ctx = fh_to_ve(fh);
+	if (!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		goto out;
+	}
+
+	ctx->eosEvent = 0;
+out:
+	return ret;
+}
+
+static int ve2_get_max_instance(void *fh)
+{
+	return MAX_DEC_INSTANCE;
+}
+
+static int ve2_suspend(void *fh)
+{
+
+	struct ve2_ctx *ctx = fh_to_ve(fh);
+	int ret = 0;
+
+	if (ctx->streamon_out) {
+		ret = ve2rpc_pause(ctx->out_hndl);
+		if (ret) {
+			vpu_err("out ve2rpc_pause fail\n");
+			goto exit;
+		}
+	}
+
+	if (ctx->streamon_cap) {
+		ret = ve2rpc_pause(ctx->cap_hndl);
+		if (ret) {
+			vpu_err("cap ve2rpc_pause fail\n");
+			goto exit;
+		}
+	}
+
+exit:
+
+	return ret;
+}
+
+static int ve2_resume(void *fh)
+{
+	struct ve2_ctx *ctx = fh_to_ve(fh);
+	int ret = 0;
+
+	if (ctx->streamon_cap) {
+		ret = ve2rpc_run(ctx->cap_hndl);
+		if (ret) {
+			vpu_err("cap ve2rpc_pause fail\n");
+			goto exit;
+		}
+	}
+
+	if (ctx->streamon_out) {
+		ret = ve2rpc_run(ctx->out_hndl);
+		if (ret) {
+			vpu_err("out ve2rpc_pause fail\n");
+			goto exit;
+		}
+	}
+
+exit:
+
+	return ret;
+}
+
+static void ve2_get_info(void *fh, bool *eos, bool *no_frame)
+{
+	struct ve2_ctx *ctx = fh_to_ve(fh);
+
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		return;
+	}
+
+	*eos = ctx->eos;
+	*no_frame = ctx->no_frame;
+}
+
+static int ve2_get_undq_dispFrm_cnt(void *fh)
+{
+	struct ve2_ctx *ctx = fh_to_ve(fh);
+
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	return ve2rpc_get_decoded_frm_cnt(ctx->cap_hndl);
+}
+
+static int ve2_pasre_header(void *fh, struct vb2_buffer *vb, uint32_t *width,
+			    uint32_t *height, uint32_t *min_reqbuf,
+			    uint32_t *bit_depth)
+{
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	struct vpu_ctx *v_ctx = (struct vpu_ctx *)vid_ctx->vpu_ctx;
+	struct ve2_ctx *ctx = fh_to_ve(fh);
+	struct vb2_v4l2_buffer *v4l2_buf;
+	uint32_t size = 0;
+	uint32_t ddr_width = 0;
+	uint32_t ddr_height = 0;
+	void *buf = NULL;
+	int ret;
+
+	v4l2_buf = to_vb2_v4l2_buffer(vb);
+	size = v4l2_buf->vb2_buf.planes[0].bytesused;
+	buf = vb2_plane_vaddr(&v4l2_buf->vb2_buf, 0);
+
+	ret = ve2rpc_get_bs_info(vb->vb2_queue->dev, fh,
+				 v_ctx->out_fmt.spec.fmt.pix_mp.pixelformat, size,
+				 buf, width, height, &ddr_width, &ddr_height,
+				 min_reqbuf, bit_depth);
+
+	if (!ret && *bit_depth == 0x80000000 && *min_reqbuf == 0) {
+		v_ctx->is_bs_error = true;
+		vpu_err("ve2_pasre_header: bitstream keyframe error!\n");
+		ret = -EFAULT;
+		goto exit;
+	} else if (!ret && *bit_depth == 0x40000000 && *min_reqbuf == 0) {
+		v_ctx->is_decoder_error = true;
+		vpu_err("ve2_pasre_header: Codec not support!\n");
+		ret = -EFAULT;
+		goto exit;
+	} else if (ret ||
+		(*width == 0 || *height == 0 ||
+		ddr_width == 0 || ddr_height == 0)) {
+		v_ctx->is_decoder_error = true;
+		vpu_err("get_bs_info fail %d, %dx%d, ddr %dx%d\n",
+			ret, *width, *height, ddr_width, ddr_height);
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	if (vid_ctx->params.dec_params.en_enhance == true &&
+		((*width) * (*height) > MAX_2K_RESOLUTION)) {
+		ctx->is_cmprs = true;
+		vpu_info("Enable enhance mode\n");
+	}
+#ifdef ENABLE_GPU_CACHE
+	if (vid_ctx->support_gpu_cache && ctx->is_cmprs) {
+		ctx->gpu_cache_en = true;
+		vpu_info("Enable gpu cache\n");
+	}
+
+	if (ctx->gpu_cache_en && *bit_depth == 1)
+		v_ctx->p010_stride = 2 * ALIGN(*width, 64);
+#endif
+
+	vpu_update_resolution_change(fh, *width, *height, ddr_width, ddr_height,
+		*bit_depth, *min_reqbuf);
+
+	v_ctx->is_bs_error = false;
+	ctx->internal_buf_cnt = 0;
+exit:
+	return ret;
+}
+
+static struct veng_ops ve_ops = {
+	.ve_start_streaming = ve2_start_streaming,
+	.ve_stop_streaming = ve2_stop_streaming,
+	.ve_out_qbuf = ve2_out_qbuf,
+	.ve_cap_qbuf = ve2_cap_qbuf,
+	.ve_cap_dqbuf = ve2_cap_dqbuf,
+	.ve_abort = ve2_abort,
+	.ve_alloc_context = ve2_alloc_context,
+	.ve_free_context = ve2_free_context,
+	.ve_free_capture = ve2_free_capture,
+	.ve_stop_cmd = ve2_stop_cmd,
+	.ve_get_info = ve2_get_info,
+	.ve_get_undq_dispFrm_cnt = ve2_get_undq_dispFrm_cnt,
+	.ve_out_pre_parse = ve2_pasre_header,
+	.ve_start_cmd = ve2_start_cmd,
+	.ve_get_max_instance = ve2_get_max_instance,
+	.ve_suspend = ve2_suspend,
+	.ve_resume = ve2_resume,
+};
+
+static int __init ve2_init(void)
+{
+	int ret;
+
+	ret = vpu_ve_register(VENG_ID, &ve_ops);
+	if (ret) {
+		vpu_err("Failed to register video engine VE%d ops\n", VENG_ID);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit ve2_exit(void)
+{
+	vpu_ve_unregister(VENG_ID);
+}
+
+module_init(ve2_init);
+module_exit(ve2_exit);
+
+#if IS_ENABLED(CONFIG_RTK_V4L2_DECODER)
+#if IS_MODULE(CONFIG_RTK_FW_REMOTEPROC)
+MODULE_SOFTDEP("pre: rtk_fw_remoteproc");
+#endif
+#endif
+
+MODULE_VERSION(CODEC_VERSION);
+MODULE_IMPORT_NS(DMA_BUF);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("William Lee <william.lee@realtek.com>");
+MODULE_DESCRIPTION("V4L2 Realtek Video Engine 2 Codec Driver");
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve2.h
@@ -0,0 +1,31 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#ifndef __VE2_H__
+#define __VE2_H__
+#include <media/videobuf2-v4l2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-dev.h>
+
+struct ve2_ops {
+	int (*ve2_start_streaming)(int type, uint32_t count, uint32_t bufcnt,
+				   int pixelformat);
+	int (*ve2_stop_streaming)(int type);
+	int (*ve2_out_qbuf)(uint8_t *buf, uint32_t len, uint64_t pts,
+			    uint32_t sequence);
+	int (*ve2_cap_qbuf)(void *fh, struct vb2_buffer *vb);
+	int (*ve2_cap_dqbuf)(void *fh, uint8_t *buf, uint64_t *pts,
+			     struct vb2_v4l2_buffer **disp_buf);
+	int (*ve2_abort)(int type);
+};
+
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve2_frame.h
@@ -0,0 +1,216 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#ifndef __VE2_FRAME_H__
+#define __VE2_FRAME_H__
+
+#include <linux/types.h>
+
+#define PIC_SIZE_INVALID ((uint32_t)-1)
+
+#define VE2RPC_FLASH_FRAME_INFO_VERSION 1
+#define VE2RPC_FLASH_FRAME_INFO_SIZE 384
+
+#define VE2RPC_DVO_INFO_DOLBY_VISION_SIGN (0xECECECEC)
+
+/**
+ * Indicate if a frame has a base layer frame dequeued from flash driver
+ */
+#define VE2RPC_DVO_INFO_FLAGS_BL_DEQUEUED (0x00000001)
+
+/**
+ * Indicate if a frame has a enhance layer frame dequeued from flash driver
+ */
+#define VE2RPC_DVO_INFO_FLAGS_EL_DEQUEUED (0x00000002)
+
+/**
+ * Indicate if a frame is the first frame after flushing
+ */
+#define VE2RPC_DVO_INFO_FLAGS_FLUSHED (0x00000004)
+
+#define VRPC_FRAME_INFO_FLAG_EOS 0x00000001
+#define VRPC_FRAME_INFO_FLAG_DATACORRUPT 0x00000002
+#define VRPC_FRAME_INFO_FLAG_DISCARD 0x00000004
+
+typedef struct __attribute__((__packed__)) ve2rpc_hdr_info_t {
+	uint32_t hdr_type;
+	uint8_t nTransferCharacteristics;
+	uint8_t nMatrixCoefficiets;
+	uint8_t nColorPrimaries;
+	uint8_t bVideoFullRangeFlag;
+	// offset = 8
+	uint16_t nDisplayPrimariesX[3];
+	uint16_t nDisplayPrimariesY[3];
+	uint16_t nWhitePointX;
+	uint16_t nWhitePointY;
+	uint16_t reserve2[4];
+	// offset = 8 + 24
+	uint32_t nMaxDisplayMasteringLuminance;
+	uint32_t nMinDisplayMasteringLuminance;
+	uint32_t nMaxCLL;
+	uint32_t nMaxFALL;
+	uint32_t nHdrType;
+	uint32_t reserve3[3];
+	// size = 8 + 24 + 32 = 64
+} ve2rpc_hdr_info_t;
+typedef struct __attribute__((__packed__)) ve2rpc_frame_info_t {
+	void *pixel;
+	uint32_t phyaddr;
+	uint32_t width;
+	uint32_t height;
+	uint32_t ptsLow;
+	uint32_t ptsHigh;
+	uint32_t pts2High;
+	uint32_t pts2Low;
+	uint32_t ptsSeiHigh;
+	uint32_t ptsSeiLow;
+	uint32_t flag;
+	uint32_t keyId;
+	uint32_t framerate;
+	uint32_t progressive;
+	uint32_t pitch;
+	uint32_t cpitch;
+	uint32_t reserve[2];
+	// offset = 72
+	uint8_t checkPicCoding;
+	uint8_t bitDepthLuma;
+	uint8_t bitDepthChroma;
+	uint8_t completeFields;
+	uint32_t phyaddrY;
+	uint32_t phyaddrC;
+	uint32_t offset;
+	uint32_t picCoding;
+	uint32_t interlaceMode;
+	ve2rpc_hdr_info_t hdrInfo;
+	uint32_t reserve2[8];
+	uint32_t blid;
+	uint32_t ext_data_in_use;
+	uint32_t is_ext_video;
+	uint32_t nDecClkTime;
+	uint32_t nDecFrameCount;
+	uint32_t is_frame_decoded;
+	uint32_t hdr_metadata_addr;
+	uint32_t hdr_metadata_size;
+	bool has_pts;
+	uint64_t nTimeStamp;
+	bool bWaitReleaseByBLID;
+	bool bPeekFrame;
+	uint64_t nFilledLen;
+} ve2rpc_frame_info_t;
+/*
+ * VCPU Flash output farme info data structure
+ * Size = 256 bytes
+ * */
+typedef struct {
+	unsigned int nSize;
+	unsigned int nVersion;
+	unsigned int pUserData;
+	unsigned int nRRKey;
+	unsigned int nContext;
+	unsigned int nBufID;
+	unsigned int nPicFlags;
+	unsigned int nPicWidth;
+	unsigned int nPicHeight;
+	unsigned int nDecimatePicWidth;
+	unsigned int nDecimateicHeight;
+	unsigned int nBitDepthLuma;
+	unsigned int nBitDepthChroma;
+
+	unsigned int nPtsHigh;
+	unsigned int nPtsLow;
+	unsigned int nRPtsHigh;
+	unsigned int nRPtsLow;
+	unsigned int nPts2High;
+	unsigned int nPts2Low;
+	unsigned int nPicPhysicalAddr;
+	unsigned int nPicPitch;
+	unsigned int nClkTimeHigh;
+	unsigned int nClkTimeLow;
+	unsigned int nDecClkTime;
+	unsigned int nDecFrameCount;
+	unsigned int nFramerateD;
+	unsigned int nFramerateN;
+	unsigned int eScanType; /* 0: progressive, 1: interlaced */
+	/* nInterlaceMode define  */
+	unsigned int nInterlaceMode;
+	unsigned int nSeiPtsHigh; /* SEI PTS High */
+	unsigned int nSeiPtsSLow; /* SEI PTS Low */
+	unsigned int nPicCPitch;
+	unsigned int nPicCPhysicalAddr;
+	unsigned int nSampleWidth;
+	unsigned int nSampleHeight;
+	unsigned int qlevel_sel_y;
+	unsigned int qlevel_sel_c;
+	/* nHDR_Type define */
+	unsigned int nHDR_Type;
+	unsigned int nDisplayPrimaries_X[3];
+	unsigned int nDisplayPrimaries_Y[3];
+	unsigned int nWhitePoint_X;
+	unsigned int nWhitePoint_Y;
+	unsigned int nMaxDisplayMasteringLuminance;
+	unsigned int nMinDisplayMasteringLuminance;
+	unsigned int nTransferCharacteristics;
+	unsigned int nMatrixCoefficiets;
+	unsigned int nVideoFullRangeFlag;
+	unsigned int nMaxCLL;
+	unsigned int nMaxFALL;
+	unsigned int hdr_metadata_addr;
+	unsigned int hdr_metadata_size;
+	unsigned int tch_metadata_addr;
+	unsigned int tch_metadata_size;
+	unsigned int film_grain_metadata_addr;
+	unsigned int film_grain_metadata_size;
+
+	/* 0: raw, 1: lossless, 2: lossy */
+	unsigned int nCmprsMode;
+	unsigned int nPicYCmprsHdrAddr;
+	unsigned int nPicCCmprsHdrAddr;
+	unsigned int nPicCmprsPitch;
+	unsigned int nPicCPhysicalAddr2;
+
+	unsigned int nBufLockPhysicalAddr;
+	unsigned int max_fb_num;
+	unsigned int max_cmprs_head_size;
+
+	unsigned int nLinearPicPhysicalAddr;
+	unsigned int nLinearPicCPhysicalAddr;
+	unsigned int nLinearPicWidth;
+	unsigned int nLinearPicHeight;
+	unsigned int nLinearPicPitch;
+
+	unsigned int nPixelAR_hor;
+	unsigned int nPixelAR_ver;
+	union {
+		unsigned int data;
+		struct {
+			unsigned int have_timecode:1;     // bit[0]
+			unsigned int seconds:6;           // bit[6:1]
+			unsigned int minutes:6;           // bit[12:7]
+			unsigned int hours:5;             // bit[17:13]
+			unsigned int frames:9;            // bit[26:18]
+		};
+	} nHevc_tc_timestamp;
+	union{
+		unsigned int data;
+		struct{
+			unsigned int colour_primaries:8; // bit[7:0]
+			unsigned int transferCharacteristics:8; // bit[15:8]
+		};
+	}nVUI_information;
+	unsigned int dv_rpu_metadata_addr;
+	unsigned int dv_rpu_metadata_size;
+	unsigned int noShowFrame_count;
+	unsigned int noShowFrame_picId[8];
+	unsigned int reserved[9];
+} ve2rpc_flash_frame_info_t;
+
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve2rpc.c
@@ -0,0 +1,3116 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#include <linux/errno.h>
+#include <linux/v4l2-common.h>
+#include <linux/mm.h>
+#include <linux/kthread.h> // for threads
+#include <linux/time.h> // for using jiffies
+#include <linux/list.h>
+#include <linux/workqueue.h>
+#include <linux/slab.h>
+#ifdef ENABLE_TEE_DRM_FLOW
+#include <linux/tee_drv.h>
+#endif
+#include "debug.h"
+#include "vpu.h"
+#include "ve2rpc.h"
+#include "ve2rpc_cmd.h"
+#include "ve2_frame.h"
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+#include "ve_common.h"
+#endif
+
+#include <soc/realtek/memory.h>
+#include <soc/realtek/rtk_media_heap.h>
+
+#define RES_4K_SIZE (5570560) //2560*2176
+#define SHUTTLE_BUF_SIZE (1024)
+
+struct ve2rpc_qframe_st {
+	struct list_head list;
+	volatile ve2rpc_flash_frame_info_t *frame;
+	volatile uint8_t *buflock_va;
+	uint32_t buflock_pa;
+	struct mutex *buflock_mutex;
+	struct mutex *mainrb_mutex;
+	uint32_t frm_idx;
+	struct ve2rpc *hndl;
+};
+struct traveling_frame_st {
+	struct list_head list;
+	uint32_t phy_addr;
+	uint32_t vb2_q_idx;
+	uint32_t buflock_phy_addr;
+	void *vb2_v4l2_buf;
+	int gpu_cache_idx;
+};
+struct ve2rpc_dqframe {
+	struct list_head list;
+};
+
+#ifdef ENABLE_TEE_DRM_FLOW
+extern int ta_TEEapi_memcpy_a7(struct tee_context *teeapi_ctx,
+			       unsigned int teeapi_tee_session,
+			       unsigned int dstPAddr, unsigned char *buf,
+			       int size);
+extern int ta_TEEapi_memcpy(struct tee_context *teeapi_ctx,
+			    unsigned int teeapi_tee_session,
+			    unsigned int dstPhysAddr, unsigned int srtPhysAddr,
+			    int size);
+#endif
+
+static void memset_volatile(volatile void *dest, char val, size_t len)
+{
+	volatile char *ptr = dest;
+	while (len-- > 0) {
+		*ptr++ = val;
+	}
+}
+
+static void __maybe_unused dump_frame(volatile ve2rpc_flash_frame_info_t *frame)
+{
+	vpu_output_dbg("\n");
+	vpu_output_dbg("frame->nSize = %x\n", htonl(frame->nSize));
+	vpu_output_dbg("frame->nVersion = %x\n", htonl(frame->nVersion));
+	vpu_output_dbg("frame->pUserData = %x\n", htonl(frame->pUserData));
+	vpu_output_dbg("frame->nRRKey = %x\n", htonl(frame->nRRKey));
+	vpu_output_dbg("frame->nContext = %x\n", htonl(frame->nContext));
+	vpu_output_dbg("frame->nBufID = %x\n", htonl(frame->nBufID));
+	vpu_output_dbg("frame->nPicFlags = %x\n", htonl(frame->nPicFlags));
+	vpu_output_dbg("frame->nPicWidth = %x\n", htonl(frame->nPicWidth));
+	vpu_output_dbg("frame->nPicHeight = %x\n", htonl(frame->nPicHeight));
+	vpu_output_dbg("frame->nDecimatePicWidth = %x\n",
+		       htonl(frame->nDecimatePicWidth));
+	vpu_output_dbg("frame->nDecimateicHeight = %x\n",
+		       htonl(frame->nDecimateicHeight));
+	vpu_output_dbg("frame->nBitDepthLuma = %x\n",
+		       htonl(frame->nBitDepthLuma));
+	vpu_output_dbg("frame->nBitDepthChroma = %x\n",
+		       htonl(frame->nBitDepthChroma));
+	vpu_output_dbg("frame->nPtsHigh = %x\n", htonl(frame->nPtsHigh));
+	vpu_output_dbg("frame->nPtsLow = %x\n", htonl(frame->nPtsLow));
+	vpu_output_dbg("frame->nRPtsHigh = %x\n", htonl(frame->nRPtsHigh));
+	vpu_output_dbg("frame->nRPtsLow = %x\n", htonl(frame->nRPtsLow));
+	vpu_output_dbg("frame->nPts2High = %x\n", htonl(frame->nPts2High));
+	vpu_output_dbg("frame->nPts2Low = %x\n", htonl(frame->nPts2Low));
+	vpu_output_dbg("frame->nPicPhysicalAddr = %x\n",
+		       htonl(frame->nPicPhysicalAddr));
+	vpu_output_dbg("frame->nPicPitch = %x\n", htonl(frame->nPicPitch));
+	vpu_output_dbg("frame->nClkTimeHigh = %x\n",
+		       htonl(frame->nClkTimeHigh));
+	vpu_output_dbg("frame->nClkTimeLow = %x\n", htonl(frame->nClkTimeLow));
+	vpu_output_dbg("frame->nDecClkTime = %x\n", htonl(frame->nDecClkTime));
+	vpu_output_dbg("frame->nDecFrameCount = %x\n",
+		       htonl(frame->nDecFrameCount));
+	vpu_output_dbg("frame->nFramerateD = %x\n", htonl(frame->nFramerateD));
+	vpu_output_dbg("frame->nFramerateN = %x\n", htonl(frame->nFramerateN));
+	vpu_output_dbg("frame->eScanType = %x\n", htonl(frame->eScanType));
+	vpu_output_dbg("frame->nInterlaceMode = %x\n",
+		       htonl(frame->nInterlaceMode));
+	vpu_output_dbg("frame->nSeiPtsHigh = %x\n", htonl(frame->nSeiPtsHigh));
+	vpu_output_dbg("frame->nSeiPtsSLow = %x\n", htonl(frame->nSeiPtsSLow));
+	vpu_output_dbg("frame->nPicCPitch = %x\n", htonl(frame->nPicCPitch));
+	vpu_output_dbg("frame->nPicCPhysicalAddr = %x\n",
+		       htonl(frame->nPicCPhysicalAddr));
+	vpu_output_dbg("frame->nSampleWidth = %x\n",
+		       htonl(frame->nSampleWidth));
+	vpu_output_dbg("frame->nSampleHeight = %x\n",
+		       htonl(frame->nSampleHeight));
+	vpu_output_dbg("frame->qlevel_sel_y = %x\n",
+		       htonl(frame->qlevel_sel_y));
+	vpu_output_dbg("frame->qlevel_sel_c = %x\n",
+		       htonl(frame->qlevel_sel_c));
+	vpu_output_dbg("frame->nHDR_Type = %x\n", htonl(frame->nHDR_Type));
+
+	vpu_output_dbg("frame->nDisplayPrimaries_X[0] = %x\n",
+		       htonl(frame->nDisplayPrimaries_X[0]));
+	vpu_output_dbg("frame->nDisplayPrimaries_X[1] = %x\n",
+		       htonl(frame->nDisplayPrimaries_X[1]));
+	vpu_output_dbg("frame->nDisplayPrimaries_X[2] = %x\n",
+		       htonl(frame->nDisplayPrimaries_X[2]));
+
+	vpu_output_dbg("frame->nDisplayPrimaries_Y[0] = %x\n",
+		       htonl(frame->nDisplayPrimaries_Y[0]));
+	vpu_output_dbg("frame->nDisplayPrimaries_Y[1] = %x\n",
+		       htonl(frame->nDisplayPrimaries_Y[1]));
+	vpu_output_dbg("frame->nDisplayPrimaries_Y[2] = %x\n",
+		       htonl(frame->nDisplayPrimaries_Y[2]));
+
+	vpu_output_dbg("frame->nWhitePoint_X = %x\n",
+		       htonl(frame->nWhitePoint_X));
+	vpu_output_dbg("frame->nWhitePoint_Y = %x\n",
+		       htonl(frame->nWhitePoint_Y));
+	vpu_output_dbg("frame->nMaxDisplayMasteringLuminance = %x\n",
+		       htonl(frame->nMaxDisplayMasteringLuminance));
+	vpu_output_dbg("frame->nMinDisplayMasteringLuminance = %x\n",
+		       htonl(frame->nMinDisplayMasteringLuminance));
+	vpu_output_dbg("frame->nTransferCharacteristics = %x\n",
+		       htonl(frame->nTransferCharacteristics));
+	vpu_output_dbg("frame->nMatrixCoefficiets = %x\n",
+		       htonl(frame->nMatrixCoefficiets));
+	vpu_output_dbg("frame->nVideoFullRangeFlag = %x\n",
+		       htonl(frame->nVideoFullRangeFlag));
+	vpu_output_dbg("frame->nMaxCLL = %x\n", htonl(frame->nMaxCLL));
+	vpu_output_dbg("frame->nMaxFALL = %x\n", htonl(frame->nMaxFALL));
+	vpu_output_dbg("frame->hdr_metadata_addr = %x\n",
+		       htonl(frame->hdr_metadata_addr));
+	vpu_output_dbg("frame->hdr_metadata_size = %x\n",
+		       htonl(frame->hdr_metadata_size));
+	vpu_output_dbg("frame->tch_metadata_addr = %x\n",
+		       htonl(frame->tch_metadata_addr));
+	vpu_output_dbg("frame->tch_metadata_size = %x\n",
+		       htonl(frame->tch_metadata_size));
+	vpu_output_dbg("frame->film_grain_metadata_addr = %x\n",
+		       htonl(frame->film_grain_metadata_addr));
+	vpu_output_dbg("frame->film_grain_metadata_size = %x\n",
+		       htonl(frame->film_grain_metadata_size));
+
+	vpu_output_dbg("frame->nCmprsMode = %x\n", htonl(frame->nCmprsMode));
+	vpu_output_dbg("frame->nPicYCmprsHdrAddr = %x\n",
+		       htonl(frame->nPicYCmprsHdrAddr));
+	vpu_output_dbg("frame->nPicCCmprsHdrAddr = %x\n",
+		       htonl(frame->nPicCCmprsHdrAddr));
+	vpu_output_dbg("frame->nPicCmprsPitch = %x\n",
+		       htonl(frame->nPicCmprsPitch));
+	vpu_output_dbg("frame->nPicCPhysicalAddr2 = %x\n",
+		       htonl(frame->nPicCPhysicalAddr2));
+
+	vpu_output_dbg("frame->nBufLockPhysicalAddr = %x\n",
+		       htonl(frame->nBufLockPhysicalAddr));
+	vpu_output_dbg("frame->max_fb_num = %x\n", htonl(frame->max_fb_num));
+	vpu_output_dbg("frame->max_cmprs_head_size = %x\n",
+		       htonl(frame->max_cmprs_head_size));
+
+	vpu_output_dbg("frame->nLinearPicPhysicalAddr = %x\n",
+		       htonl(frame->nLinearPicPhysicalAddr));
+	vpu_output_dbg("frame->nLinearPicCPhysicalAddr = %x\n",
+		       htonl(frame->nLinearPicCPhysicalAddr));
+	vpu_output_dbg("frame->nLinearPicWidth = %x\n",
+		       htonl(frame->nLinearPicWidth));
+	vpu_output_dbg("frame->nLinearPicHeight = %x\n",
+		       htonl(frame->nLinearPicHeight));
+	vpu_output_dbg("frame->nLinearPicPitch = %x\n",
+		       htonl(frame->nLinearPicPitch));
+
+	vpu_output_dbg("frame->nPixelAR_hor = %x\n",
+		       htonl(frame->nPixelAR_hor));
+	vpu_output_dbg("frame->nPixelAR_ver = %x\n",
+		       htonl(frame->nPixelAR_ver));
+}
+
+static void __maybe_unused _dump_ringbuf(struct ve2rpc_ringbuf_t *prb)
+{
+	mutex_lock(&prb->lock);
+	vpu_output_dbg("\n");
+	vpu_output_dbg("prb->pRBH->magic %x\n", htonl(prb->pRBH->magic));
+	vpu_output_dbg("prb->pRBH->beginAddr %x\n",
+		       htonl(prb->pRBH->beginAddr));
+	vpu_output_dbg("prb->pRBH->size %x\n", htonl(prb->pRBH->size));
+	vpu_output_dbg("prb->pRBH->bufferID %x\n", htonl(prb->pRBH->bufferID));
+
+	vpu_output_dbg("prb->pRBH->writePtr %x\n", htonl(prb->pRBH->writePtr));
+	vpu_output_dbg("prb->pRBH->numOfReadPtr %x\n",
+		       htonl(prb->pRBH->numOfReadPtr));
+	vpu_output_dbg("prb->pRBH->reserve2 %x\n", htonl(prb->pRBH->reserve2));
+	vpu_output_dbg("prb->pRBH->reserve3 %x\n", htonl(prb->pRBH->reserve3));
+
+	vpu_output_dbg("prb->pRBH->readPtr[0] %x\n",
+		       htonl(prb->pRBH->readPtr[0]));
+	vpu_output_dbg("prb->pRBH->readPtr[1] %x\n",
+		       htonl(prb->pRBH->readPtr[1]));
+	vpu_output_dbg("prb->pRBH->readPtr[2] %x\n",
+		       htonl(prb->pRBH->readPtr[2]));
+	vpu_output_dbg("prb->pRBH->readPtr[3] %x\n",
+		       htonl(prb->pRBH->readPtr[3]));
+
+	vpu_output_dbg("prb->pRBH->fileOffset %x\n",
+		       htonl(prb->pRBH->fileOffset));
+	vpu_output_dbg("prb->pRBH->requestedFileOffset %x\n",
+		       htonl(prb->pRBH->requestedFileOffset));
+	vpu_output_dbg("prb->pRBH->fileSize %x\n", htonl(prb->pRBH->fileSize));
+	vpu_output_dbg("prb->pRBH->bSeekable %x\n",
+		       htonl(prb->pRBH->bSeekable));
+	mutex_unlock(&prb->lock);
+}
+
+static struct ve2rpc_ion_object *_ve2rpc_ion_create(struct device *dev,
+						    size_t size,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 116)
+						    char *name,
+#else
+						    unsigned int mask,
+#endif
+						    unsigned int flags)
+{
+	struct ve2rpc_ion_object *ion_obj;
+	struct dma_buf_attachment *attachment __maybe_unused;
+	struct sg_table *sgt __maybe_unused;
+	dma_addr_t dma_addr;
+	void *vaddr;
+
+	ion_obj = kzalloc(sizeof(*ion_obj), GFP_KERNEL);
+	if (!ion_obj) {
+		vpu_err("%s allocate ion_obj fail, No Memory\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	mutex_lock(&dev->mutex);
+	rheap_setup_dma_pools(dev, "rtk_media_heap",
+	                      RTK_FLAG_NONCACHED | RTK_FLAG_SCPUACC |
+	                      RTK_FLAG_VO_U_POOL, __func__);
+	vaddr = dma_alloc_coherent(dev, size, &dma_addr, GFP_KERNEL);
+	mutex_unlock(&dev->mutex);
+	if (!vaddr) {
+		vpu_err("%s dma_alloc fail \n", __func__);
+		kfree(ion_obj);
+		return ERR_PTR(-ENOMEM);
+	}
+	ion_obj->vaddr = vaddr;
+	ion_obj->paddr = dma_addr;
+	ion_obj->size = size;
+
+	memset(ion_obj->vaddr, 0, size);
+
+	return ion_obj;
+}
+
+static void _ve2rpc_ion_free(struct device *dev,
+								struct ve2rpc_ion_object *ion_obj)
+{
+	if (!ion_obj) {
+		vpu_err("_ve2rpc_ion_free ion_obj is NULL\n");
+		return;
+	}
+
+	if (ion_obj->dmabuf) {
+		dma_buf_vunmap(ion_obj->dmabuf, &ion_obj->map);
+		dma_buf_end_cpu_access(ion_obj->dmabuf, DMA_BIDIRECTIONAL);
+		dma_buf_unmap_attachment(ion_obj->attach, ion_obj->sgt,
+					 DMA_TO_DEVICE);
+		dma_buf_detach(ion_obj->dmabuf, ion_obj->attach);
+		dma_buf_put(ion_obj->dmabuf);
+	}
+	else
+	{
+		if (ion_obj->vaddr) {
+			dma_free_coherent(dev, ion_obj->size, ion_obj->vaddr, ion_obj->paddr);
+		}
+	}
+
+	kfree(ion_obj);
+}
+
+static struct ve2rpc_ion_object *_ve2rpc_audio_ion_create(struct device *dev,
+							  size_t size)
+{
+	return _ve2rpc_ion_create(dev, size,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 116)
+				  "rtk_audio_heap",
+				  RTK_FLAG_NONCACHED | RTK_FLAG_SCPUACC |
+					  RTK_FLAG_ACPUACC);
+#else
+				  RTK_ION_HEAP_AUDIO_MASK,
+				  ION_FLAG_NONCACHED | ION_FLAG_SCPUACC |
+					  ION_FLAG_ACPUACC);
+#endif
+}
+
+static __maybe_unused struct ve2rpc_ion_object *
+_ve2rpc_secure_media_ion_create(struct device *dev, uint32_t size)
+{
+	return _ve2rpc_ion_create(dev, size,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 116)
+				  "rtk_media_heap",
+				  RTK_FLAG_NONCACHED | RTK_FLAG_HWIPACC |
+					  RTK_FLAG_VCPU_FWACC |
+					  RTK_FLAG_PROTECTED_VIDEO);
+#else
+				  RTK_ION_HEAP_SECURE_MASK |
+					  RTK_ION_HEAP_MEDIA_MASK,
+				  ION_FLAG_NONCACHED | ION_FLAG_HWIPACC |
+					  ION_FLAG_VCPU_FWACC |
+					  ION_FLAG_PROTECTED_VIDEO);
+#endif
+}
+
+static struct ve2rpc_ion_object *_ve2rpc_media_ion_create(struct device *dev,
+							  size_t size)
+{
+	return _ve2rpc_ion_create(dev, size,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 116)
+				  "rtk_media_heap",
+				  RTK_FLAG_NONCACHED | RTK_FLAG_SCPUACC |
+					  RTK_FLAG_ACPUACC |
+					  RTK_FLAG_VCPU_FWACC);
+#else
+				  RTK_ION_HEAP_MEDIA_MASK,
+				  ION_FLAG_NONCACHED | ION_FLAG_SCPUACC |
+					  ION_FLAG_ACPUACC |
+					  ION_FLAG_VCPU_FWACC);
+#endif
+}
+
+static int SendReply(struct rtk_krpc_ept_info *krpc_ept_info,
+		     uint32_t req_taskID, int32_t req_context,
+		     char *ReplyParameter, // parameter's start address
+		     uint32_t ParameterSize) // parameter's size
+{
+	ssize_t ret;
+	struct rpc_struct *rpc;
+	char *mem_ToShm;
+	char *p;
+	int size_ToShm = 0; // total mem size for writing to share memory
+	uint32_t *context;
+	mem_ToShm =
+		kmalloc(sizeof(RPC_STRUCT) + sizeof(uint32_t) + ParameterSize,
+			GFP_KERNEL | __GFP_ZERO);
+	if (!mem_ToShm) {
+		pr_err("SendReply malloc fail\n");
+		return -ENOMEM;
+	}
+	p = mem_ToShm;
+	rpc = (struct rpc_struct *)p;
+	p += sizeof(struct rpc_struct);
+	context = (uint32_t *)p;
+	*context = htonl(req_taskID);
+	size_ToShm += sizeof(uint32_t);
+	p += sizeof(uint32_t);
+	for (context = (uint32_t *)p; (char *)context < p + ParameterSize;
+	     context++) {
+		*context = *ReplyParameter;
+		ReplyParameter += sizeof(uint32_t);
+	}
+	size_ToShm += ParameterSize;
+	rpc->programID = REPLYID;
+	rpc->versionID = REPLYID;
+	rpc->procedureID = 0;
+	rpc->mycontext = req_context; // fill in req's para addr
+	rpc->taskID = 0xffffffff;
+	rpc->sysPID = 0xffffffff;
+	rpc->parameterSize = size_ToShm;
+	size_ToShm += sizeof(struct rpc_struct);
+	ret = rtk_send_rpc(krpc_ept_info, mem_ToShm, size_ToShm);
+	if (ret != size_ToShm) {
+		pr_err("ve2RPC: ERROR in send kernel RPC\n");
+	}
+	kfree(mem_ToShm);
+	if (ret)
+		return 0;
+	else
+		return ret;
+}
+
+static int handle_rpc_command(struct rtk_krpc_ept_info *krpc_ept_info,
+			      char *buf)
+{
+	struct ve2rpc *hndl = (struct ve2rpc *)krpc_ept_info->priv;
+	struct v4l2_fh *fh = hndl->fh;
+	int cmd;
+	struct VIDEO_RPC_VOUT_MESSAGE *event;
+	HRESULT retval = S_OK;
+	ssize_t size = 0;
+	struct rpc_struct *rpc_head = (struct rpc_struct *)buf;
+	uint32_t width = 0;
+	uint32_t height = 0;
+	uint32_t ddr_width = 0;
+	uint32_t ddr_height = 0;
+	uint32_t is_ten_bits = 0;
+	uint32_t dpb_cnt = 0;
+
+	vpu_input_dbg("rpc_kern_ve2_read, cmd %d, count %lu, size %d\n",
+		      rpc_head->procedureID, sizeof(rpc_head),
+		      rpc_head->parameterSize);
+	cmd = rpc_head->procedureID;
+	switch (cmd) {
+	case VIDEO_RPC_DEC_ToSystem_FatalError:
+		event = (struct VIDEO_RPC_VOUT_MESSAGE *)kmalloc(sizeof(struct VIDEO_RPC_DEC_ERROR_INFO),
+				GFP_KERNEL | __GFP_ZERO);
+		if (!event) {
+			vpu_err("VIDEO_RPC_DEC_ERROR_INFO event malloc fail\n");
+			return -ENOMEM;
+		}
+		if (rpc_head->parameterSize !=
+		    sizeof(struct VIDEO_RPC_DEC_ERROR_INFO)) {
+			pr_err("vclient: VIDEO_RPC_DEC_ToSystem_FatalError: rpc data size not match(expect:%lu real:%ld rpc->parameterSize:%d)\n",
+			       sizeof(struct VIDEO_RPC_DEC_ERROR_INFO), size,
+			       rpc_head->parameterSize);
+			return -EINVAL;
+		}
+		memcpy(event, buf + sizeof(struct rpc_struct),
+		       rpc_head->parameterSize);
+		hndl->is_error = true;
+		vpu_err("ve2 decode error!!\n");
+		kfree(event);
+		break;
+	case VIDEO_RPC_DEC_ToSystem_Deliver_MediaInfo:
+		event = (struct VIDEO_RPC_VOUT_MESSAGE *)kmalloc(sizeof(struct VIDEO_RPC_DEC_MEDIA_INFO),
+				GFP_KERNEL | __GFP_ZERO);
+		if (!event) {
+			vpu_err("VIDEO_RPC_DEC_MEDIA_INFO event malloc fail\n");
+			return -ENOMEM;
+		}
+		if (rpc_head->parameterSize !=
+		    sizeof(struct VIDEO_RPC_DEC_MEDIA_INFO)) {
+			pr_err("vclient: VIDEO_RPC_DEC_MEDIA_INFO: rpc data size not match(expect:%lu real:%ld rpc->parameterSize:%d)\n",
+			       sizeof(struct VIDEO_RPC_DEC_MEDIA_INFO), size,
+			       rpc_head->parameterSize);
+		}
+		memcpy(event, buf + sizeof(struct rpc_struct),
+		       rpc_head->parameterSize);
+		kfree(event);
+		break;
+	case VIDEO_RPC_ToSystem_VoutMessage:
+		event = (struct VIDEO_RPC_VOUT_MESSAGE *)kmalloc(sizeof(struct VIDEO_RPC_VOUT_MESSAGE),
+				GFP_KERNEL | __GFP_ZERO);
+		if (!event) {
+			vpu_err("VIDEO_RPC_VOUT_MESSAGE event malloc fail\n");
+			return -ENOMEM;
+		}
+
+		if (rpc_head->parameterSize !=
+		    sizeof(struct VIDEO_RPC_VOUT_MESSAGE)) {
+			pr_err("vclient: VIDEO_RPC_VOUT_MESSAGE: rpc data size not match(expect:%lu real:%ld rpc->parameterSize:%d)\n",
+			       sizeof(struct VIDEO_RPC_VOUT_MESSAGE), size,
+			       rpc_head->parameterSize);
+		}
+		memcpy(event, buf + sizeof(struct rpc_struct),
+		       rpc_head->parameterSize);
+
+		width = event->reserved1;
+		height = event->reserved2;
+		ddr_width = event->reserved3 >> 16;
+		ddr_height = event->reserved3 & 0xffff;
+		is_ten_bits = event->reserved4 >> 16;
+		dpb_cnt = event->reserved4 & 0xffff;
+
+		vpu_info("Resolution change! width %d, height %d, ddr_width %d, ddr_height %d, is_ten_bits %d, dpb_cnt %d",
+			width, height, ddr_width, ddr_height, is_ten_bits, dpb_cnt);
+
+#ifdef SUPPORT_ADAPTIVE_PLAYBACK
+		if (!hndl->is_adaptive_playback)
+			hndl->main_rb.pRBH->reserve3 = htonl(width << 16 | height);
+#endif
+		if (vpu_check_sub_res_chg(fh))
+			vpu_update_resolution_change(fh, width, height, ddr_width, ddr_height,
+				is_ten_bits, dpb_cnt);
+		else
+			hndl->is_error = true;
+
+		kfree(event);
+		break;
+	default:
+		break;
+	}
+	if (rpc_head->taskID != 0)
+		SendReply(hndl->vcpu_ept_info, rpc_head->taskID,
+			  rpc_head->mycontext, (char *)&retval, sizeof(retval));
+
+	return 0;
+}
+
+static char *prepare_rpc_data(struct rtk_krpc_ept_info *krpc_ept_info,
+			      uint32_t command, uint32_t param1,
+			      uint32_t param2, int *len)
+{
+	struct rpc_struct *rpc;
+	uint32_t *tmp;
+	char *buf;
+
+	*len = sizeof(struct rpc_struct) + 3 * sizeof(uint32_t);
+	buf = kmalloc(sizeof(struct rpc_struct) + 3 * sizeof(uint32_t),
+		      GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	rpc = (struct rpc_struct *)buf;
+	rpc->programID = KERNELID;
+	rpc->versionID = KERNELID;
+	rpc->procedureID = 0;
+	rpc->taskID = krpc_ept_info->id;
+	rpc->sysTID = krpc_ept_info->id;
+	rpc->sysPID = krpc_ept_info->id;
+	rpc->parameterSize = 3 * sizeof(uint32_t);
+	rpc->mycontext = 0;
+	tmp = (uint32_t *)(buf + sizeof(struct rpc_struct));
+	*tmp = command;
+	*(tmp + 1) = param1;
+	*(tmp + 2) = param2;
+
+	return buf;
+}
+
+int ve2_send_rpc(struct rtk_krpc_ept_info *krpc_ept_info, char *buf, int len,
+		 uint32_t *retval)
+{
+	int ret = 0;
+
+	mutex_lock(&krpc_ept_info->send_mutex);
+
+	krpc_ept_info->retval = retval;
+	ret = rtk_send_rpc(krpc_ept_info, buf, len);
+	if (!wait_for_completion_timeout(&krpc_ept_info->ack, RPC_TIMEOUT)) {
+		pr_err("[%s]kernel rpc timeout: %s...\n", __func__,
+		       krpc_ept_info->name);
+		rtk_krpc_dump_ringbuf_info(krpc_ept_info);
+		mutex_unlock(&krpc_ept_info->send_mutex);
+		return -EINVAL;
+	}
+	mutex_unlock(&krpc_ept_info->send_mutex);
+
+	return 0;
+}
+
+static int send_rpc(struct ve2rpc *hndl, int opt, uint32_t command,
+		    uint32_t param1, uint32_t param2, uint32_t *retval)
+{
+	int ret = 0;
+	char *buf;
+	int len;
+
+	if (opt == RPC_VIDEO) {
+		buf = prepare_rpc_data(hndl->vcpu_ept_info, command, param1,
+				       param2, &len);
+		if (!IS_ERR(buf)) {
+			ret = ve2_send_rpc(hndl->vcpu_ept_info, buf, len,
+					   retval);
+			kfree(buf);
+		}
+	}
+
+	return ret;
+}
+
+static int krpc_vcpu_cb(struct rtk_krpc_ept_info *krpc_ept_info, char *buf)
+{
+	uint32_t *tmp;
+	struct rpc_struct *rpc = (struct rpc_struct *)buf;
+
+	if (rpc->programID == REPLYID) {
+		tmp = (uint32_t *)(buf + sizeof(struct rpc_struct));
+		*(krpc_ept_info->retval) = *(tmp + 1);
+
+		complete(&krpc_ept_info->ack);
+	} else {
+		handle_rpc_command(krpc_ept_info, buf);
+	}
+
+	return 0;
+}
+
+static struct rtk_krpc_ept_info *get_ve2_krpc_info(void)
+{
+	struct device_node *np;
+	struct rtk_krpc_ept_info *vcpu_ept_info;
+
+	np = of_find_compatible_node(NULL, NULL, "realtek,ve2rpc");
+	if (!np)
+		return ERR_PTR(-ENODEV);
+
+	vcpu_ept_info = of_krpc_ept_info_get(np, 0);
+
+	return vcpu_ept_info;
+}
+
+static int _ve2rpc_shuttle(struct ve2rpc *hndl, int cmd, void *data, int size,
+			   void *rpc_ret, int rpc_ret_size)
+{
+	struct ve2rpc_ion_object *ion_obj = hndl->dma_obj;
+	int offset;
+	uint32_t dat;
+	unsigned int RPC_ret;
+
+	if (!ion_obj) {
+		vpu_err("_ve2rpc_shuttle fail, no shuttle buf\n");
+		return -EPERM;
+	}
+
+	memcpy_toio(ion_obj->vaddr, data, size);
+	dsb(sy);
+	offset = get_rpc_alignment_offset(size);
+	dat = ion_obj->paddr;
+
+	if (send_rpc(hndl, RPC_VIDEO, cmd, dat, dat + offset, &RPC_ret))
+	{
+		vpu_err("ve2rpc fail, cmd %d\n", cmd);
+		return -EPERM;
+	} else {
+		if (RPC_ret == S_OK) {
+			if (rpc_ret)
+				memcpy_toio(rpc_ret, ion_obj->vaddr + offset,
+					    rpc_ret_size);
+			return 0;
+		} else {
+			vpu_err("ve2rpc return fail, cmd %d\n", cmd);
+			return -EPERM;
+		}
+	}
+	return 0;
+}
+
+static int _ve2rpc_ringbuf_release(struct ve2rpc *hndl,
+				   struct ve2rpc_ringbuf_t *ringbuf)
+{
+	if (!ringbuf) {
+		vpu_err("Invaild input\n");
+		return -EPERM;
+	}
+
+	if (ringbuf->rbinfo.hdr_hdl) {
+		mutex_lock(&ringbuf->lock);
+		_ve2rpc_ion_free(hndl->dev, ringbuf->rbinfo.hdr_hdl);
+		ringbuf->rbinfo.hdr_hdl = NULL;
+		mutex_unlock(&ringbuf->lock);
+	}
+
+	if (ringbuf->rbinfo.buf_hdl) {
+		mutex_lock(&ringbuf->lock);
+		_ve2rpc_ion_free(hndl->dev, ringbuf->rbinfo.buf_hdl);
+		ringbuf->rbinfo.buf_hdl = NULL;
+		mutex_unlock(&ringbuf->lock);
+	}
+
+	return 0;
+}
+
+int ve2rpc_SetRingBuffer(struct ve2rpc *hndl, struct ve2rpc_ringbuf_t *prb,
+			 uint32_t bodysize, RINGBUFFER_TYPE type,
+			 uint8_t is_secure)
+{
+	RPC_RINGBUFFER ringbuffer;
+	struct ve2rpc_ringbuf_info_t *pRB_info;
+	struct ve2rpc_ion_object *body, *head;
+	int ret = 0;
+
+	if (!hndl) {
+		vpu_err("Invaild input\n");
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (is_secure)
+		body = _ve2rpc_secure_media_ion_create(hndl->dev, bodysize);
+	else
+		body = _ve2rpc_media_ion_create(hndl->dev, bodysize);
+	if (IS_ERR(body)) {
+		vpu_err("allocate body fail, No Memory\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	head = _ve2rpc_media_ion_create(hndl->dev,
+					sizeof(struct _tagRingBufferHeader));
+	if (IS_ERR(head)) {
+		vpu_err("allocate head fail, No Memory\n");
+		ret = -ENOMEM;
+		goto err_alloc_head;
+	}
+
+	memset(prb, 0, sizeof(struct ve2rpc_ringbuf_t));
+	prb->phyaddr_hdr = head->paddr;
+	prb->phyaddr = body->paddr;
+	prb->size = bodysize;
+	prb->base = (uint8_t *)body->vaddr;
+	prb->limit = (uint8_t *)body->vaddr + bodysize;
+	prb->buf_cached = body->vaddr;
+	prb->buf_uncached = body->vaddr;
+	prb->hdr_cached = head->vaddr;
+	prb->hdr_uncached = head->vaddr;
+	prb->secure = is_secure;
+
+	mutex_init(&prb->lock);
+	pRB_info = &prb->rbinfo;
+	pRB_info->buf_type = VE2RPC_MEMORY_CPB;
+	pRB_info->buf_addr = body->paddr;
+	pRB_info->buf_size = bodysize;
+	pRB_info->buf_cached = body->vaddr;
+	pRB_info->buf_uncached = body->vaddr;
+	pRB_info->buf_limit = (uint32_t)(uintptr_t)body->vaddr + bodysize;
+	pRB_info->buf_hdl = body;
+
+	pRB_info->hdr_type = VE2RPC_MEMORY_CMA;
+	pRB_info->hdr_addr = head->paddr;
+	pRB_info->hdr_size = sizeof(struct _tagRingBufferHeader);
+	pRB_info->hdr_cached = (uintptr_t)head->vaddr;
+	pRB_info->hdr_uncached = (uintptr_t)head->vaddr;
+	pRB_info->hdr_limit =
+		(uintptr_t)head->vaddr + sizeof(struct _tagRingBufferHeader);
+	pRB_info->hdr_hdl = head;
+
+	pRB_info->bufex_type = VE2RPC_MEMORY_NONE;
+	pRB_info->bufex_addr = 0;
+	pRB_info->bufex_size = 0;
+
+	prb->pRBH = (volatile struct _tagRingBufferHeader *)head->vaddr;
+	prb->pRBH->size = htonl(bodysize);
+	prb->pRBH->numOfReadPtr = htonl(1);
+	prb->pRBH->beginAddr = htonl(body->paddr);
+	prb->pRBH->writePtr = htonl(body->paddr);
+	prb->pRBH->readPtr[0] = htonl(body->paddr);
+	prb->pRBH->readPtr[1] = htonl(body->paddr);
+	prb->pRBH->readPtr[2] = htonl(body->paddr);
+	prb->pRBH->readPtr[3] = htonl(body->paddr);
+#define VRB_STRUCT_VERSION 1
+#define VRPC_FLASH_FORMAT_SEND_BUF_ID 5
+	prb->pRBH->reserve2 = 0;
+	prb->pRBH->reserve3 = 0;
+	prb->pRBH->bufferID = htonl(type);
+
+	mutex_lock(&hndl->lock);
+	ringbuffer.instanceID = htonl(hndl->instanceID);
+	ringbuffer.readPtrIndex = 0;
+	ringbuffer.pinID = 0;
+	ringbuffer.pRINGBUFF_HEADER = htonl(head->paddr);
+	ret = _ve2rpc_shuttle(hndl, VIDEO_RPC_COMMON_ToAgent_InitRingBuffer,
+			      &ringbuffer, sizeof(ringbuffer), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	return ret;
+err_alloc_head:
+	if (body)
+		_ve2rpc_ion_free(hndl->dev, body);
+exit:
+	return ret;
+}
+
+static int _ve2rpc_open(struct ve2rpc *hndl, int type, struct v4l2_fh *fh)
+{
+	VIDEO_RPC_INSTANCE instance;
+	unsigned int ret;
+	RPCRES_LONG retval;
+	hndl->fh = fh;
+	hndl->vcpu_ept_info = get_ve2_krpc_info();
+	ret = krpc_info_init(hndl->vcpu_ept_info, "ve2rpc", krpc_vcpu_cb);
+	if (ret) {
+		vpu_err("%s krpc_info_init fail\n", __func__);
+		return (-EPERM);
+	}
+	hndl->vcpu_ept_info->priv = (void *)hndl;
+
+	mutex_lock(&hndl->lock);
+	instance.type = htonl(type);
+	ret = _ve2rpc_shuttle(hndl, VIDEO_RPC_COMMON_ToAgent_Create, &instance,
+			      sizeof(instance), &retval, sizeof(retval));
+	if (ret) {
+		vpu_err("fail to open decoder(%s)\n",
+			V4L2_TYPE_TO_STR(hndl->type));
+		mutex_unlock(&hndl->lock);
+		return (-EPERM);
+	}
+
+	hndl->instanceType = type;
+	if (htonl(retval.result) == S_OK) {
+		hndl->instanceID = htonl(retval.data);
+	} else {
+		vpu_err("fail to get instance(%s)\n",
+			V4L2_TYPE_TO_STR(hndl->type));
+		mutex_unlock(&hndl->lock);
+		return (-EPERM);
+	}
+	mutex_unlock(&hndl->lock);
+	return 0;
+}
+
+int ve2rpc_close(struct ve2rpc *hndl)
+{
+	if (!hndl) {
+		vpu_err("Invaild handle\n");
+		return -EPERM;
+	}
+
+	mutex_lock(&hndl->lock);
+	if (hndl->instanceID) {
+		uint32_t instanceID;
+		int ret;
+
+		instanceID = htonl(hndl->instanceID);
+		ret = _ve2rpc_shuttle(hndl, VIDEO_RPC_COMMON_ToAgent_Destroy,
+				      &instanceID, sizeof(instanceID), NULL, 0);
+		if (ret) {
+			mutex_unlock(&hndl->lock);
+			vpu_err("fail to close decoder(%s)\n",
+				V4L2_TYPE_TO_STR(hndl->type));
+			return (-EPERM);
+		}
+	}
+
+	krpc_info_deinit(hndl->vcpu_ept_info);
+	krpc_ept_info_put(hndl->vcpu_ept_info);
+
+	hndl->instanceType = -1;
+	hndl->instanceID = -1;
+	mutex_unlock(&hndl->lock);
+	return 0;
+}
+
+int ve2rpc_connect(struct ve2rpc *src, struct ve2rpc *dst)
+{
+	RPC_CONNECTION connection;
+	int ret;
+
+	if (!src || !src->instanceID) {
+		pr_err("%s out handler is NULL", __func__);
+		return -EPERM;
+	}
+
+	if (!dst || !dst->instanceID) {
+		pr_err("%s cap handler is NULL", __func__);
+		return -EPERM;
+	}
+
+	mutex_lock(&dst->lock);
+	mutex_lock(&src->lock);
+
+	memset(&connection, 0, sizeof(connection));
+	connection.srcInstanceID = htonl(src->instanceID);
+	connection.desInstanceID = htonl(dst->instanceID);
+
+	ret = _ve2rpc_shuttle(src, VIDEO_RPC_COMMON_ToAgent_Connect,
+			      &connection, sizeof(connection), NULL, 0);
+	mutex_unlock(&src->lock);
+	mutex_unlock(&dst->lock);
+	if (ret) {
+		vpu_err("fail to connect decoder\n");
+		return (-EPERM);
+	}
+	return 0;
+}
+
+int ve2rpc_setRole(struct ve2rpc *hndl, VIDEO_STREAM_TYPE type)
+{
+	VIDEO_RPC_DEC_INIT info;
+	int ret;
+
+	if (!hndl || !hndl->instanceID) {
+		vpu_err("hndl = %p hndl->instanceID=%x ", hndl,
+			(hndl == NULL) ? 0 : hndl->instanceID);
+		return -EPERM;
+	}
+
+	mutex_lock(&hndl->lock);
+
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->instanceID);
+	info.set_speed.instanceID = htonl(hndl->instanceID);
+	info.set_speed.displaySpeed = 0;
+	info.set_speed.decodeSkip = 0;
+	info.type = htonl(type);
+	ret = _ve2rpc_shuttle(hndl, VIDEO_RPC_DEC_ToAgent_Init, &info,
+			      sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		vpu_err("fail to connect decoder\n");
+		return (-EPERM);
+	}
+
+	return 0;
+}
+
+int ve2rpc_set_cmprs(struct ve2rpc *hndl, uint8_t enable)
+{
+	VIDEO_RPC_DEC_CMPRS_CTRL info;
+	int ret;
+
+	if (!hndl || !hndl->instanceID)
+		return -1;
+
+	mutex_lock(&hndl->lock);
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->instanceID);
+	info.mode = 0; //0: lossless, 1: lossy
+	info.ratio = htonl(CMPRS_RATIO_75);
+	info.enable = enable;
+
+	ret = _ve2rpc_shuttle(hndl, VIDEO_RPC_DEC_ToAgent_CmprsCtrl, &info,
+			      sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		vpu_err("fail to do cmd %d \n",
+			VIDEO_RPC_DEC_ToAgent_CmprsCtrl);
+		return (-EPERM);
+	}
+
+	return 0;
+}
+
+int ve2rpc_enable_drop_cnt(struct ve2rpc *hndl)
+{
+	VIDEO_RPC_RESOURCE_INFO info;
+	int ret;
+
+	if (!hndl || !hndl->instanceID)
+		return -1;
+
+	mutex_lock(&hndl->lock);
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->instanceID);
+	info.resource_ctrl_sets = htonl(0x80);
+
+	ret = _ve2rpc_shuttle(hndl, VIDEO_RPC_ToAgent_SetResourceInfo, &info,
+			      sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		vpu_err("fail to do cmd %d \n",
+			VIDEO_RPC_ToAgent_SetResourceInfo);
+		return (-EPERM);
+	}
+
+	return 0;
+}
+
+int ve2rpc_get_bs_info(struct device *dev, void *fh, uint32_t codec,
+		       uint32_t size, void *buf, uint32_t *width,
+		       uint32_t *height, uint32_t *ddr_width,
+		       uint32_t *ddr_height, uint32_t *min_reqbuf,
+		       uint32_t *bit_depth)
+{
+	struct ve2rpc *hndl;
+	struct ve2rpc_ion_object *bs_buf;
+	VIDEO_RPC_DEC_BITSTREAM_BUFFER input = { 0 };
+	VIDEO_RPC_DEC_PV_RESULT output = { 0 };
+	uint32_t paddr = 0;
+	int ret = 0;
+
+	hndl = kzalloc(sizeof(struct ve2rpc), GFP_KERNEL);
+	if (!hndl) {
+		vpu_err("allocate handler fail, No Memory\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+	hndl->dev = dev;
+	hndl->vcpu_ept_info = get_ve2_krpc_info();
+	ret = krpc_info_init(hndl->vcpu_ept_info, "ve2rpc", krpc_vcpu_cb);
+	if (ret) {
+		vpu_err("%s krpc_info_init fail\n", __func__);
+		goto krpc_init_fail;
+	}
+	hndl->vcpu_ept_info->priv = (void *)hndl;
+	hndl->dma_obj = ve2rpc_init_shuttle(dev);
+	if (IS_ERR(hndl->dma_obj)) {
+		vpu_err("allocate shuttle buffer fail, No Memory\n");
+		ret = -ENOMEM;
+		goto init_shuttle_fail;
+	}
+
+	bs_buf = _ve2rpc_media_ion_create(hndl->dev, size);
+	if (IS_ERR(bs_buf)) {
+		vpu_err("allocate bs_buf fail, No Memory\n");
+		ret = -ENOMEM;
+		goto alloc_bs_fail;
+	}
+
+	memcpy_toio(bs_buf->vaddr, buf, size);
+
+	paddr = (uint32_t)bs_buf->paddr; // TODO
+	input.bsBase = htonl(paddr);
+	input.bsSize = htonl(size);
+	if (codec == V4L2_PIX_FMT_HEVC) {
+		input.type = htonl(VF_TYPE_VIDEO_H265_DECODER);
+	} else if (codec == V4L2_PIX_FMT_VP9) {
+		input.type = htonl(VF_TYPE_VIDEO_VP9_DECODER);
+	} else if (codec == V4L2_PIX_FMT_AV1) {
+		input.type = htonl(VF_TYPE_VIDEO_AV1_DECODER);
+	} else {
+		input.type = htonl(VF_TYPE_VIDEO_H265_DECODER);
+		vpu_err("%s, unsupport codec %d", __func__, codec);
+	}
+	ret = _ve2rpc_shuttle(hndl, VIDEO_RPC_DEC_ToAgent_ParseResolution,
+			      &input, sizeof(VIDEO_RPC_DEC_BITSTREAM_BUFFER),
+			      &output, sizeof(VIDEO_RPC_DEC_PV_RESULT));
+	if (ret) {
+		vpu_err("fail to do cmd ParseResolution %d \n",
+			VIDEO_RPC_DEC_ToAgent_BitstreamValidation);
+		goto parse_res_fail;
+	}
+
+	*width = htonl(output.width) >> 16;
+	*height = htonl(output.height) >> 16;
+	*ddr_width = htonl(output.width) & 0xffff;
+	*ddr_height = htonl(output.height) & 0xffff;
+	*bit_depth = htonl(output.bit_depth);
+	*min_reqbuf = htonl(output.DPB_size);
+
+	vpu_input_dbg("ve2rpc_get_bs_info width %d, height %d, ddr_width %d, ddr_height %d, bit_depth %d, min_reqbuf %d",
+		*width, *height, *ddr_width, *ddr_height, *bit_depth, *min_reqbuf);
+
+parse_res_fail:
+	if (bs_buf)
+		_ve2rpc_ion_free(hndl->dev, bs_buf);
+alloc_bs_fail:
+	if (hndl->dma_obj)
+		ve2rpc_uninit_shuttle(dev, hndl->dma_obj);
+init_shuttle_fail:
+	if (hndl->vcpu_ept_info) {
+		krpc_info_deinit(hndl->vcpu_ept_info);
+		krpc_ept_info_put(hndl->vcpu_ept_info);
+	}
+krpc_init_fail:
+	kfree(hndl);
+exit:
+	return ret;
+}
+
+static int _ve2rpc_common(struct ve2rpc *hndl, int cmd)
+{
+	uint32_t instanceID;
+	int ret;
+
+	if (!hndl || !hndl->instanceID) {
+		vpu_err("handle = %px hndl->instanceID=%d ", hndl,
+			(hndl == NULL) ? 0 : hndl->instanceID);
+		return -EPERM;
+	}
+	mutex_lock(&hndl->lock);
+	instanceID = htonl(hndl->instanceID);
+	ret = _ve2rpc_shuttle(hndl, cmd, &instanceID, sizeof(instanceID), NULL,
+			      0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		vpu_err("fail to do cmd %d \n", cmd);
+		return (-EPERM);
+	}
+	return 0;
+}
+
+int ve2rpc_run(struct ve2rpc *hndl)
+{
+	int ret;
+	ret = _ve2rpc_common(hndl, VIDEO_RPC_COMMON_ToAgent_Run);
+
+	return ret;
+}
+
+int ve2rpc_pause(struct ve2rpc *hndl)
+{
+	int ret;
+
+	ret = _ve2rpc_common(hndl, VIDEO_RPC_COMMON_ToAgent_Pause);
+	return ret;
+}
+
+int ve2rpc_flush(struct ve2rpc *hndl)
+{
+	int ret;
+
+	ret = _ve2rpc_common(hndl, VIDEO_RPC_COMMON_ToAgent_Flush);
+	return ret;
+}
+
+int ve2rpc_stop(struct ve2rpc *hndl)
+{
+	int ret;
+
+	ret = _ve2rpc_common(hndl, VIDEO_RPC_COMMON_ToAgent_Stop);
+	return ret;
+}
+
+static void _inband_memcpy(uint8_t *des, uint8_t *src, unsigned int size)
+{
+	unsigned int *src_int32 = (unsigned int *)src;
+	unsigned int *des_int32 = (unsigned int *)des;
+	unsigned int i;
+
+	for (i = 0; i < (size / sizeof(int)); i++)
+		des_int32[i] = htonl(src_int32[i]);
+
+	dsb(sy);
+}
+
+static int _ve2rpc_write(struct ve2rpc_ringbuf_t *ringbuf, int type,
+			 uint8_t *buf, int size)
+{
+	volatile struct ve2rpc_ringbuf_t *rb = ringbuf;
+	uint32_t wp, rp;
+	void *wptr, *next, *addr_end;
+#ifdef ENABLE_TEE_DRM_FLOW
+	uint32_t wptr_s, next_s, addr_end_s;
+	uint8_t secure = rb->secure;
+#endif
+	uint8_t over = 0;
+
+	if (!ringbuf) {
+		vpu_err("invaild input ringbuf %p", ringbuf);
+		return -EPERM;
+	}
+
+	mutex_lock(&ringbuf->lock);
+
+	wp = htonl(rb->pRBH->writePtr);
+	rp = htonl(rb->pRBH->readPtr[0]);
+
+	if (rp > wp && (int)(rp - wp - 1) < size) {
+		mutex_unlock(&ringbuf->lock);
+		return -EPERM;
+	}
+
+	if (wp > rp && (int)(rp + rb->size - wp - 1) < size) {
+		mutex_unlock(&ringbuf->lock);
+		return -EPERM;
+	}
+
+#ifdef ENABLE_TEE_DRM_FLOW
+	if (secure) {
+		wptr_s = wp;
+		addr_end_s = rb->phyaddr + rb->size;
+		next_s = wptr_s + size;
+		if (next_s >= addr_end_s) {
+			over = 1;
+			next_s -= rb->size;
+		}
+	} else
+#endif
+	{
+		wptr = rb->buf_cached + (wp - rb->phyaddr);
+		addr_end = rb->buf_cached + rb->size;
+		next = wptr + size;
+		if (next >= addr_end) {
+			over = 1;
+			next -= rb->size;
+		}
+	}
+
+	if (over) {
+		int size0 = 0;
+		int size1 = 0;
+#ifdef ENABLE_TEE_DRM_FLOW
+		if (secure) {
+			size0 = rb->phyaddr + rb->size - wptr_s;
+			size1 = size - size0;
+		} else
+#endif
+		{
+			size0 = rb->buf_cached + rb->size - (uint8_t *)wptr;
+			size1 = size - size0;
+		}
+
+		if (type == RINGBUFFER_STREAM) {
+#ifdef ENABLE_TEE_DRM_FLOW
+			if (secure && rb->teeapi_ctx &&
+			    rb->teeapi_tee_session) {
+				int ret = 0;
+				if (rb->memory == V4L2_MEMORY_MMAP) {
+					if (size0 != 0) {
+						ret = ta_TEEapi_memcpy_a7(
+							(struct tee_context *)
+								rb->teeapi_ctx,
+							rb->teeapi_tee_session,
+							(uintptr_t)wptr_s, buf,
+							size0);
+						if (ret < 0) {
+							vpu_err("%s %d, ta_TEEapi_memcpy_a7 fail ret:%d\n",
+								__func__,
+								__LINE__, ret);
+						}
+					}
+
+					if (size1 != 0) {
+						ret = ta_TEEapi_memcpy_a7(
+							(struct tee_context *)
+								rb->teeapi_ctx,
+							rb->teeapi_tee_session,
+							rb->phyaddr,
+							buf + size0, size1);
+						if (ret < 0) {
+							vpu_err("%s %d, ta_TEEapi_memcpy_a7 fail ret:%d\n",
+								__func__,
+								__LINE__, ret);
+						}
+					}
+				} else if (rb->memory == V4L2_MEMORY_DMABUF) {
+					if (size0 != 0) {
+						ret = ta_TEEapi_memcpy(
+							(struct tee_context *)
+								rb->teeapi_ctx,
+							rb->teeapi_tee_session,
+							(uintptr_t)wptr_s,
+							(uintptr_t)buf, size0);
+						if (ret < 0)
+							vpu_err("%s %d, ta_TEEapi_memcpy_a7 fail ret:%d\n",
+								__func__,
+								__LINE__, ret);
+					}
+
+					if (size1 != 0) {
+						ret = ta_TEEapi_memcpy(
+							(struct tee_context *)
+								rb->teeapi_ctx,
+							rb->teeapi_tee_session,
+							rb->phyaddr,
+							(uintptr_t)(buf +
+								    size0),
+							size1);
+						if (ret < 0)
+							vpu_err("%s %d, ta_TEEapi_memcpy_a7 fail ret:%d\n",
+								__func__,
+								__LINE__, ret);
+					}
+				} else
+					vpu_err("%s %d, Not support this memory mode %d\n",
+						__func__, __LINE__, rb->memory);
+			} else
+#endif
+			{
+				if (size0 != 0)
+					memcpy_toio(wptr, buf, size0);
+
+				if (size1 != 0)
+					memcpy_toio(rb->buf_cached, buf + size0,
+						    size1);
+			}
+		} else {
+			if (size0 != 0)
+				_inband_memcpy(wptr, buf, (unsigned int)size0);
+
+			if (size1 != 0)
+				_inband_memcpy(rb->buf_cached, buf + size0,
+					       (unsigned int)size1);
+		}
+	} else {
+		if (type == RINGBUFFER_STREAM) {
+#ifdef ENABLE_TEE_DRM_FLOW
+			if (secure && rb->teeapi_ctx &&
+			    rb->teeapi_tee_session) {
+				int ret = 0;
+				if (rb->memory == V4L2_MEMORY_MMAP) {
+					ret = ta_TEEapi_memcpy_a7(
+						(struct tee_context *)
+							rb->teeapi_ctx,
+						rb->teeapi_tee_session,
+						(uintptr_t)wptr_s, buf, size);
+					if (ret < 0)
+						vpu_err("%s ta_TEEapi_memcpy_a7 fail ret:%d\n",
+							__func__, ret);
+				} else if (rb->memory == V4L2_MEMORY_DMABUF) {
+					ret = ta_TEEapi_memcpy(
+						(struct tee_context *)
+							rb->teeapi_ctx,
+						rb->teeapi_tee_session,
+						(uintptr_t)wptr_s,
+						(uintptr_t)buf, size);
+					if (ret < 0)
+						vpu_err("%s ta_TEEapi_memcpy_a7 fail ret:%d\n",
+							__func__, ret);
+				} else
+					vpu_err("%s %d, Not support this memory mode %d\n",
+						__func__, __LINE__, rb->memory);
+			} else
+#endif
+			{
+				memcpy_toio(wptr, buf, size);
+			}
+		} else {
+			_inband_memcpy(wptr, buf, (unsigned int)size);
+		}
+	}
+#ifdef ENABLE_TEE_DRM_FLOW
+	if (secure)
+		rb->pRBH->writePtr = htonl(next_s);
+	else
+#endif
+		rb->pRBH->writePtr =
+			htonl(rb->phyaddr + ((uint8_t *)next - rb->buf_cached));
+
+	dsb(sy);
+	mutex_unlock(&ringbuf->lock);
+
+	return 0;
+}
+
+int ve2rpc_inband_newseg(struct ve2rpc *vout_hndl)
+{
+	int ret;
+	NEW_SEG cmd;
+	struct ve2rpc_ringbuf_t *cmb_ringbuf = &vout_hndl->sub_rb;
+	struct ve2rpc_ringbuf_t *bs_ringbuf = &vout_hndl->main_rb;
+
+	mutex_lock(&bs_ringbuf->lock);
+	cmd.header.type = INBAND_CMD_TYPE_NEW_SEG;
+	cmd.header.size = sizeof(NEW_SEG);
+	cmd.wPtr = htonl(bs_ringbuf->pRBH->writePtr);
+	mutex_unlock(&bs_ringbuf->lock);
+	ret = _ve2rpc_write(cmb_ringbuf, RINGBUFFER_COMMAND, (uint8_t *)&cmd,
+			    sizeof(NEW_SEG));
+
+	return ret;
+}
+
+int ve2rpc_inband_decode(struct ve2rpc *vout_hndl, DECODE_MODE mode)
+{
+	DECODE_NEW cmd;
+	int64_t relativePTS = 0;
+	int64_t duration = -1;
+	int ret;
+
+	cmd.header.type = INBAND_CMD_TYPE_DECODE;
+	cmd.header.size = sizeof(DECODE_NEW);
+	cmd.RelativePTSH = relativePTS >> 32;
+	cmd.RelativePTSL = relativePTS;
+	cmd.PTSDurationH = duration >> 32;
+	cmd.PTSDurationL = duration;
+	cmd.skip_GOP = 0;
+	cmd.mode = mode;
+	cmd.isHM91 = 0;
+	cmd.useAbsolutePTS = 1;
+
+	ret = _ve2rpc_write(&vout_hndl->sub_rb, RINGBUFFER_COMMAND,
+			    (uint8_t *)&cmd, sizeof(DECODE_NEW));
+	return ret;
+}
+
+int ve2rpc_space(struct ve2rpc_ringbuf_t *ringbuf, char bRead, char bAtom)
+{
+	volatile struct ve2rpc_ringbuf_t *rb = ringbuf;
+	unsigned int wp, rp, space;
+
+	if (!ringbuf) {
+		vpu_err("invaild input ringbuf %p", ringbuf);
+		return -EPERM;
+	}
+	mutex_lock(&ringbuf->lock);
+	wp = htonl(rb->pRBH->writePtr);
+	rp = htonl(rb->pRBH->readPtr[0]);
+	if (bRead) {
+		space = (rp > wp) ? (wp + rb->size - rp - rb->dummy) :
+				    (wp - rp);
+	} else {
+		if (bAtom && rp <= wp) {
+			int s1 = rb->phyaddr + rb->size - wp - 1;
+			int s2 = rp - rb->phyaddr - 1;
+			space = (s1 > s2) ? s1 : s2;
+		} else {
+			space = (rp > wp) ? (rp - wp - 1) :
+					    (rp + rb->size - wp - 1);
+		}
+	}
+	dsb(sy);
+	mutex_unlock(&ringbuf->lock);
+
+	return space;
+}
+
+static int ve2rpc_inband_pts2(struct ve2rpc_ringbuf_t *ringbuf, uint32_t wptr,
+			      uint64_t pts, uint64_t pts2, uint32_t length,
+			      uint32_t flag)
+{
+	int ret;
+	PTS_INFO2 cmd;
+	if (!length) {
+		vpu_err("\n wrong length %d\n", length);
+		return 0;
+	}
+
+	cmd.header.type = INBAND_CMD_TYPE_PTS;
+	cmd.header.size = sizeof(PTS_INFO2);
+	cmd.wPtr = wptr;
+	cmd.PTSH = pts >> 32;
+	cmd.PTSL = pts;
+	cmd.PTSH2 = pts2 >> 32;
+	cmd.PTSL2 = pts2;
+	cmd.length = length;
+	cmd.flag = flag;
+
+	ret = _ve2rpc_write(ringbuf, RINGBUFFER_COMMAND, (uint8_t *)&cmd,
+			    sizeof(PTS_INFO2));
+
+	return ret;
+}
+
+static int __maybe_unused
+ve2rpc_inband_eof(struct ve2rpc_ringbuf_t *ringbuf,
+		  volatile struct _tagRingBufferHeader *pRBH, uint64_t pts,
+		  uint64_t pts2, uint32_t length, uint32_t flag)
+{
+	int ret;
+	PTS_INFO2 cmd;
+	uint32_t wptr;
+
+	if (!length) {
+		vpu_err("\n wrong length %d\n", length);
+		return 0;
+	}
+
+	wptr = htonl(pRBH->writePtr);
+	cmd.header.type = VIDEO_INBAND_CMD_TYPE_FRAME_BOUNDARY;
+	cmd.header.size = sizeof(PTS_INFO2);
+	cmd.wPtr = wptr;
+	cmd.PTSH = pts >> 32;
+	cmd.PTSL = pts;
+	cmd.PTSH2 = pts2 >> 32;
+	cmd.PTSL2 = pts2;
+	cmd.length = 0;
+	cmd.flag = 0;
+	ret = _ve2rpc_write(ringbuf, RINGBUFFER_COMMAND, (uint8_t *)&cmd,
+			    sizeof(PTS_INFO2));
+	return ret;
+}
+
+int ve2rpc_inband_eos_event(struct ve2rpc_ringbuf_t *ringbuf,
+			    volatile struct _tagRingBufferHeader *pRBH,
+			    unsigned int event_id)
+{
+	int ret;
+	EOS cmd;
+	uint32_t wptr;
+	wptr = htonl(pRBH->writePtr);
+	cmd.header.type = INBAND_CMD_TYPE_EOS;
+	cmd.header.size = sizeof(EOS);
+	cmd.eventID = event_id;
+	cmd.wPtr = wptr;
+
+	ret = _ve2rpc_write(ringbuf, RINGBUFFER_COMMAND, (uint8_t *)&cmd,
+			    sizeof(EOS));
+
+	vpu_input_dbg("Send EOS event\n");
+
+	return ret;
+}
+
+int ve2rpc_inband_add_buf(struct ve2rpc_ringbuf_t *ringbuf,
+			  struct rtkve2_reg_dpb_t dpb,
+			  uint32_t cmprs_hdr_lu, uint32_t cmprs_hdr_ch,
+			  uint32_t cmprs_hdr_size)
+{
+	int ret = 0;
+	FRAME_INFO_IN cmd = {0};
+
+	if(dpb.bit_depth != 8 && dpb.bit_depth != 10)
+		dpb.bit_depth = 0;
+
+	cmd.header.type = VIDEO_FRAME_INBAND_ADD;
+	cmd.header.size = sizeof(FRAME_INFO_IN);
+	cmd.lu_addr = dpb.y_phy_addr;
+	cmd.ch_addr = dpb.c_phy_addr;;
+	cmd.decimate_lu_addr = 0;
+	cmd.decimate_ch_addr = 0;
+	cmd.width = dpb.width;
+	cmd.height = dpb.height;
+	cmd.decimate_width = 0;
+	cmd.decimate_height = 0;
+	cmd.ddr_width = dpb.dpb_width;
+	cmd.ddr_height = dpb.dpb_height;
+	cmd.bit_depth = dpb.bit_depth;
+	cmd.decimate_en = 0;
+	cmd.decimate_ratio = 0;
+	if (cmprs_hdr_size) {
+		cmd.cmprs_hdr_size = cmprs_hdr_size;
+		cmd.cmprs_hdr_lu = cmprs_hdr_lu;
+		cmd.cmprs_hdr_ch = cmprs_hdr_ch;
+		cmd.cmprs_en = 1;
+		cmd.lossy_en = 0;
+		cmd.lossy_ratio = 1;
+	}
+
+	ret = _ve2rpc_write(ringbuf, RINGBUFFER_FRAME_USER, (uint8_t *)&cmd,
+			    cmd.header.size);
+
+	return ret;
+}
+
+int ve2rpc_inband_del_buf(struct ve2rpc_ringbuf_t *ringbuf, uint32_t y_phy_addr)
+{
+	int ret = 0;
+	FRAME_INFO_OUT cmd;
+
+	cmd.header.type = VIDEO_FRAME_INBAND_DELETE;
+	cmd.header.size = sizeof(FRAME_INFO_OUT);
+	cmd.lu_addr = y_phy_addr;
+
+	ret = _ve2rpc_write(ringbuf, RINGBUFFER_FRAME_USER, (uint8_t *)&cmd,
+			    cmd.header.size);
+
+	return ret;
+}
+
+int ve2rpc_write_bs(struct ve2rpc *hndl, uint8_t *buf, uint32_t len,
+		    uint64_t pts, uint32_t sequence)
+{
+	int space, ret;
+	uint32_t writePtrforPTS;
+	//int i=0;
+
+	space = ve2rpc_space(&hndl->main_rb, 0, 1);
+	if (space < len) {
+		vpu_input_dbg("bitstream buffer is too small %d, %d\n", space,
+			      len);
+		return -ENOSPC;
+	}
+
+	space = ve2rpc_space(&hndl->sub_rb, 0, 1);
+	if (space < 512) {
+		vpu_input_dbg("command buffer is too small %d\n", space);
+		return -ENOSPC;
+	}
+
+	writePtrforPTS = htonl(hndl->main_rb.pRBH->writePtr);
+#ifdef REORDER_PTS
+	if (hndl->is_pts_reorder) {
+		ret = ve2rpc_inband_pts2(&hndl->sub_rb, writePtrforPTS,
+					 (uint64_t)sequence << 32, pts, len, 0);
+	} else
+#endif
+	{
+		ret = ve2rpc_inband_pts2(&hndl->sub_rb, writePtrforPTS,
+					 (uint64_t)pts, sequence, len, 0);
+	}
+	if (ret) {
+		vpu_err("ve2rpc_inband_pts2 fail %d\n", ret);
+		return -EFAULT;
+	}
+
+	{
+		ret = _ve2rpc_write(&hndl->main_rb, RINGBUFFER_STREAM, buf,
+				    len);
+	}
+
+	if (ret) {
+		vpu_err("_ve2rpc_write RINGBUFFER_STREAM fail %d\n", ret);
+		return -EFAULT;
+	}
+	if (hndl->vType == VIDEO_STREAM_H265) {
+		ret = ve2rpc_inband_eof(&hndl->sub_rb, hndl->main_rb.pRBH,
+					(uint64_t)sequence << 32, pts, len, 0);
+		if (ret) {
+			vpu_err("ve2rpc_inband_eof fail %d\n", ret);
+			return -EFAULT;
+		}
+	}
+	return 0;
+}
+
+static uint8_t *_get_buflock_va(struct ve2rpc_ion_object *buflock,
+				uint32_t buflock_pa)
+{
+	if ((buflock_pa >= buflock->paddr) &&
+	    (buflock_pa < (buflock->paddr + buflock->size))) {
+		return buflock->vaddr + buflock_pa - buflock->paddr;
+	}
+	return NULL;
+}
+
+void __maybe_unused dump_buflock(struct ve2rpc *cap_hndl)
+{
+	struct ve2rpc_ion_object *buflock;
+	volatile uint8_t *buflock_va;
+	int i = 0;
+
+	buflock = (struct ve2rpc_ion_object *)cap_hndl->buflock;
+
+	for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
+		buflock_va = cap_hndl->buflock_info[i].buflock_va;
+		if (buflock_va) {
+			pr_err("buflock_va %d) 0x%x, %d, used %d", i, cap_hndl->buflock_info[i].buflock_pa, *buflock_va, cap_hndl->buflock_info[i].is_used);
+		} else
+			vpu_input_dbg("idx %d, state unknow, NULL, 0\n", i);
+	}
+}
+
+int ve2rpc_get_decoded_frm_cnt(struct ve2rpc *hndl)
+{
+	struct ve2rpc_ringbuf_t *prb;
+	int disp_frm_cnt = 0;
+	volatile uint32_t wptr = 0;
+	volatile uint32_t rptr = 0;
+
+	prb = &hndl->main_rb;
+	mutex_lock(&prb->lock);
+	wptr = htonl(prb->pRBH->writePtr);
+	rptr = htonl(prb->pRBH->readPtr[0]);
+	if (prb->pRBH && wptr != rptr) {
+		if (wptr >= rptr)
+			disp_frm_cnt = (wptr - rptr) /
+				       sizeof(ve2rpc_flash_frame_info_t);
+		else
+			disp_frm_cnt = (wptr + prb->size - rptr) /
+				       sizeof(ve2rpc_flash_frame_info_t);
+	}
+	mutex_unlock(&prb->lock);
+
+	return disp_frm_cnt;
+}
+
+static struct rtkve2_dpb_t *ve2rpc_find_dpb(struct ve2rpc *cap_hndl,
+	struct vb2_v4l2_buffer *vb2_v4l2_buffer)
+{
+	int i = 0;
+
+	for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
+		if ((cap_hndl->dpb[i].status != RTKVE2_DPB_ST_EMPTY) &&
+		    (cap_hndl->dpb[i].vb2_v4l2_buf == vb2_v4l2_buffer))
+			return (void *)&(cap_hndl->dpb[i]);
+	}
+
+	return NULL;
+}
+
+
+void ve2rpc_update_dpb_st(struct ve2rpc *cap_hndl,
+	struct vb2_v4l2_buffer *vb2_v4l2_buffer, unsigned int status)
+{
+	struct rtkve2_dpb_t *dpb = NULL;
+
+	if (cap_hndl == NULL) {
+		vpu_err("%s cap_hndl is NULL", __func__);
+		return;
+	}
+
+	mutex_lock(&cap_hndl->dpb_mutex);
+	dpb = ve2rpc_find_dpb(cap_hndl, vb2_v4l2_buffer);
+	if (!dpb) {
+		vpu_err("%s, can't find vb2_v4l2_buffer:%px in dpb[]\n",
+			__func__, vb2_v4l2_buffer);
+		mutex_unlock(&cap_hndl->dpb_mutex);
+		return;
+	}
+
+	dpb->status = status;
+	mutex_unlock(&cap_hndl->dpb_mutex);
+
+}
+
+int ve2rpc_add_travel_entry(struct ve2rpc *cap_hndl,
+	uint32_t y_phy_addr, uint32_t buflock_phy_addr,
+	void *vb2_v4l2_buf, uint32_t idx, int gpu_idx)
+{
+	struct traveling_frame_st *tframe;
+	int ret = 0;
+
+	tframe = kmalloc(sizeof(struct traveling_frame_st),
+			 GFP_KERNEL | __GFP_ZERO);
+	if (!tframe) {
+		vpu_err("kmalloc traveling_frame_st fail\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	tframe->phy_addr = y_phy_addr;
+	tframe->vb2_q_idx = idx;
+	tframe->vb2_v4l2_buf = vb2_v4l2_buf;
+	tframe->buflock_phy_addr = buflock_phy_addr;
+	tframe->gpu_cache_idx = gpu_idx;
+
+	mutex_lock(&cap_hndl->travel_mutex);
+	list_add_tail(&tframe->list, &cap_hndl->qframe.tlist);
+	mutex_unlock(&cap_hndl->travel_mutex);
+exit:
+	return ret;
+}
+
+int ve2rpc_add_capbuf_to_dpb(struct ve2rpc *out_hndl, struct ve2rpc *cap_hndl,
+			     struct rtkve2_reg_dpb_t dpb, bool is_cmprs)
+{
+	int ret = 0;
+	int i = 0;
+	uint32_t cmprs_hdr_lu = 0;
+	uint32_t cmprs_hdr_ch = 0;
+	uint32_t cmprs_hdr_size = 0;
+	struct ve2rpc_ion_object *cmprs_hdr_buf = NULL;
+
+	if ((out_hndl == NULL) || (cap_hndl == NULL) || (dpb.size == 0) ||
+	    (dpb.y_phy_addr == 0) || (dpb.vb2_v4l2_buf == NULL)) {
+		vpu_err("%s invalid parameters out_hndl:%px, cap_hndl:%px, size:%d, phys_addr:0x%llx, vb2_v4l2_buf:%px\n",
+			__func__, out_hndl, cap_hndl, dpb.size, dpb.y_phy_addr,
+			dpb.vb2_v4l2_buf);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (is_cmprs) {
+		uint32_t cmprs_lu_size1 = ALIGN((ALIGN(dpb.width / 8, 64) * dpb.height / 128), 64) * 32;
+		uint32_t cmprs_lu_size2 = ALIGN((ALIGN(dpb.height / 8, 64) * dpb.width / 128), 64) * 32;
+		uint32_t cmprs_hdr_lu_size = max(cmprs_lu_size1, cmprs_lu_size2);
+
+		cmprs_hdr_size = cmprs_hdr_lu_size * 3 / 2;
+		if (cmprs_hdr_size != 0) {
+			cmprs_hdr_buf = _ve2rpc_media_ion_create(cap_hndl->dev, cmprs_hdr_size);
+			if (IS_ERR(cmprs_hdr_buf))
+				vpu_err("allocate cmprs buffer fail, No Memory\n");
+
+			cmprs_hdr_lu = cmprs_hdr_buf->paddr;
+			cmprs_hdr_ch = cmprs_hdr_lu + cmprs_hdr_lu_size;
+		} else {
+			vpu_err("cmprs_hdr_size is incorrect (%dx%d). Back to normal mode.", dpb.width, dpb.height);
+		}
+	}
+
+	mutex_lock(&cap_hndl->dpb_mutex);
+	for (i = 0; i < cap_hndl->dpb_cnt; i++)
+		if (cap_hndl->dpb[i].y_phy_addr == dpb.y_phy_addr)
+			break;
+	if (i != cap_hndl->dpb_cnt) {
+		if (cmprs_hdr_buf)
+			_ve2rpc_ion_free(cap_hndl->dev, cmprs_hdr_buf);
+		mutex_unlock(&cap_hndl->dpb_mutex);
+		goto exit;
+	}
+	for (i = 0; i < VE2_MAX_DPB_NUM; i++)
+		if (cap_hndl->dpb[i].status == RTKVE2_DPB_ST_EMPTY)
+			break;
+
+	if (i == VE2_MAX_DPB_NUM) {
+		if (cmprs_hdr_buf)
+			_ve2rpc_ion_free(cap_hndl->dev, cmprs_hdr_buf);
+		vpu_err("all dpb buffers are used\n");
+		mutex_unlock(&cap_hndl->dpb_mutex);
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	cap_hndl->dpb[i].size = dpb.size;
+	cap_hndl->dpb[i].status = RTKVE2_DPB_ST_VALID;
+	cap_hndl->dpb[i].y_phy_addr = dpb.y_phy_addr;
+	cap_hndl->dpb[i].c_phy_addr = dpb.c_phy_addr;
+	cap_hndl->dpb[i].vb2_v4l2_buf = dpb.vb2_v4l2_buf;
+	cap_hndl->dpb[i].idx = dpb.idx;
+	cap_hndl->dpb[i].cmprs_hdr_buf = cmprs_hdr_buf;
+	cap_hndl->dpb_cnt++;
+	mutex_unlock(&cap_hndl->dpb_mutex);
+
+	ret = ve2rpc_inband_add_buf(&out_hndl->dpb_rb, dpb,
+				    cmprs_hdr_lu, cmprs_hdr_ch, cmprs_hdr_size);
+exit:
+	return ret;
+}
+
+int ve2rpc_del_capbuf_from_dpb(struct ve2rpc *out_hndl, struct ve2rpc *cap_hndl)
+{
+	int ret = 0;
+	int i = 0;
+
+	if ((out_hndl == NULL) || (cap_hndl == NULL)) {
+		vpu_err("%s invalid parameters out_hndl, cap_hndl\n",
+			__func__);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (!out_hndl->dpb_rb.rbinfo.hdr_hdl || !out_hndl->dpb_rb.rbinfo.buf_hdl) {
+		vpu_err("%s dpb_rb is not ready\n", __func__);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	mutex_lock(&cap_hndl->dpb_mutex);
+	for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
+		if (cap_hndl->dpb[i].status != RTKVE2_DPB_ST_EMPTY) {
+			ret = ve2rpc_inband_del_buf(
+				&out_hndl->dpb_rb, cap_hndl->dpb[i].y_phy_addr);
+			if (cap_hndl->dpb[i].cmprs_hdr_buf != 0)
+				_ve2rpc_ion_free(cap_hndl->dev, cap_hndl->dpb[i].cmprs_hdr_buf);
+			cap_hndl->dpb[i].y_phy_addr = 0;
+			cap_hndl->dpb[i].status = RTKVE2_DPB_ST_EMPTY;
+		}
+	}
+	cap_hndl->dpb_cnt = 0;
+
+	mutex_unlock(&cap_hndl->dpb_mutex);
+exit:
+	return ret;
+}
+
+struct rtkve2_buflock_t *ve2rpc_get_unused_buflock(struct ve2rpc *cap_hndl)
+{
+	int i = 0;
+	struct rtkve2_buflock_t *buflock = NULL;
+	volatile uint8_t *buflock_va;
+
+	if (!cap_hndl) {
+		vpu_err("%s cap isn't ready\n", __func__);
+		return 0;
+	}
+	mutex_lock(&cap_hndl->buflock_mutex);
+	for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
+		buflock_va = cap_hndl->buflock_info[i].buflock_va;
+		if (cap_hndl->buflock_info[i].is_used == 0 &&
+			*buflock_va == E_BUFLOCK_ST_NORMAL) {
+			buflock = &cap_hndl->buflock_info[i];
+			cap_hndl->buflock_info[i].is_used = 1;
+			break;
+		}
+	}
+	mutex_unlock(&cap_hndl->buflock_mutex);
+
+	return buflock;
+}
+
+static int ve2rpc_clear_buflock_thread(void *data)
+{
+	struct ve2rpc *hndl = (struct ve2rpc *)data;
+	struct ve2rpc_qframe_st *entry = NULL;
+	struct ve2rpc_qframe_st *tmp_entry = NULL;
+	uint32_t buflock_pa = 0;
+	volatile uint8_t *buflock_va;
+	int i = 0;
+	int wait_cnt = 0;
+
+	while (1) {
+		int ret;
+		ret = wait_event_interruptible_timeout(
+			hndl->buflock_waitq,
+			(kthread_should_stop() && list_empty_careful(&hndl->qframe.list)),
+			msecs_to_jiffies(5));
+
+		if ((kthread_should_stop() || (ret == -ERESTART))) {
+			if (list_empty_careful(&hndl->qframe.list))
+				break;
+			else {
+				wait_cnt++;
+				if (wait_cnt > 1000) {
+					pr_info("Can't wait for RELEASE status");
+					mutex_lock(&hndl->qframe.lock);
+					list_for_each_entry_safe (entry, tmp_entry, &hndl->qframe.list, list) {
+						buflock_va = entry->buflock_va;
+						pr_debug("Force remove buflock %d", *buflock_va);
+						list_del(&entry->list);
+						kfree(entry);
+					}
+					mutex_unlock(&hndl->buflock_mutex);
+					break;
+				}
+			}
+		}
+
+		mutex_lock(&hndl->qframe.lock);
+		list_for_each_entry_safe (entry, tmp_entry, &hndl->qframe.list, list) {
+			buflock_va = entry->buflock_va;
+			buflock_pa = entry->buflock_pa;
+			mutex_lock(&hndl->buflock_mutex);
+			if (*buflock_va == E_BUFLOCK_ST_RELEASE ||
+				*buflock_va == E_BUFLOCK_ST_NORMAL) {
+				*buflock_va = E_BUFLOCK_ST_NORMAL;
+				for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
+					if (buflock_pa == hndl->buflock_info[i].buflock_pa) {
+						hndl->buflock_info[i].is_used = 0;
+					}
+				}
+				list_del(&entry->list);
+				kfree(entry);
+			}
+			mutex_unlock(&hndl->buflock_mutex);
+		}
+		mutex_unlock(&hndl->qframe.lock);
+	}
+
+	return 1;
+}
+
+int ve2rpc_add_to_buflock_clear_q(struct ve2rpc *cap_hndl, uint32_t buflock_pa,
+	volatile uint8_t *buflock_va)
+{
+	struct ve2rpc_qframe_st *re_qframe;
+
+	if (!cap_hndl->buflock_thread) {
+		init_waitqueue_head(&cap_hndl->buflock_waitq);
+		cap_hndl->buflock_thread = kthread_run(
+			ve2rpc_clear_buflock_thread, cap_hndl, "buflockthread");
+		if (IS_ERR(cap_hndl->buflock_thread)) {
+		    vpu_err("failed to start buflock thread\n");
+		    cap_hndl->buflock_thread = NULL;
+		}
+	}
+
+	re_qframe = kmalloc(sizeof(struct ve2rpc_qframe_st),
+			GFP_KERNEL | __GFP_ZERO);
+	if (!re_qframe) {
+		vpu_err("kmalloc ve2rpc_qframe_st fail\n");
+		return -ENOMEM;
+	}
+	INIT_LIST_HEAD(&re_qframe->list);
+	re_qframe->buflock_va = buflock_va;
+	re_qframe->buflock_pa = buflock_pa;
+	re_qframe->hndl = cap_hndl;
+
+	mutex_lock(&cap_hndl->qframe.lock);
+	list_add_tail(&re_qframe->list, &cap_hndl->qframe.list);
+	mutex_unlock(&cap_hndl->qframe.lock);
+
+	wake_up_interruptible(&cap_hndl->buflock_waitq);
+	return 0;
+}
+
+static void ve2rpc_add_to_msgQ(struct ve2rpc *cap_hndl, uint32_t buflock_pa)
+{
+	uint32_t frm_idx = 0;
+	volatile ve2rpc_flash_frame_info_t *frame;
+
+	frm_idx = cap_hndl->outputRingIdx++;
+	if (cap_hndl->outputRingIdx >= VE2_MAX_DPB_NUM)
+		cap_hndl->outputRingIdx = 0;
+
+	frame = (volatile ve2rpc_flash_frame_info_t *)cap_hndl->frame[frm_idx];
+
+	memset_volatile(frame, 0, sizeof(ve2rpc_flash_frame_info_t));
+	frame->nPicFlags = 0;
+	frame->nPicWidth = PIC_SIZE_INVALID;
+	frame->nPicHeight = PIC_SIZE_INVALID;
+	frame->nClkTimeHigh = -1;
+	frame->nClkTimeLow = -1;
+	frame->nBufLockPhysicalAddr = htonl(buflock_pa);
+	frame->pUserData = true;
+	dsb(sy);
+}
+
+int ve2rpc_qframe(struct ve2rpc *cap_hndl, dma_addr_t phy_addr,
+		  uint32_t vb2_q_idx)
+{
+	struct ve2rpc_ion_object *buflock;
+	struct ve2rpc_ringbuf_t *prb;
+	struct rtkve2_buflock_t * buflock_info = NULL;
+	uint32_t buflock_pa = 0;
+	volatile uint8_t *buflock_va;
+	struct traveling_frame_st *tentry;
+	struct traveling_frame_st *tmp_tentry = NULL;
+	int ret = 0;
+#ifdef ENABLE_GPU_CACHE
+	int gpu_cache_idx = -1;
+#endif
+
+	if (!cap_hndl || !cap_hndl->instanceID) {
+		vpu_err("handle = %p hndl->instanceID=%d ", cap_hndl,
+			(cap_hndl == NULL) ? 0 : cap_hndl->instanceID);
+		return -EPERM;
+	}
+
+	prb = &cap_hndl->main_rb;
+
+	if (vb2_q_idx >= cap_hndl->dpb_cnt) {
+		vpu_err("invaild vb2_q_idx %d %d", vb2_q_idx,
+			cap_hndl->dpb_cnt);
+		return -EPERM;
+	}
+
+	mutex_lock(&cap_hndl->travel_mutex);
+
+	list_for_each_entry_safe (tentry, tmp_tentry,
+		&cap_hndl->qframe.tlist, list) {
+		if ((tentry->phy_addr == phy_addr) &&
+			(tentry->vb2_q_idx == vb2_q_idx)) {
+				buflock_pa = tentry->buflock_phy_addr;
+#ifdef ENABLE_GPU_CACHE
+				gpu_cache_idx = tentry->gpu_cache_idx;
+#endif
+				tentry->phy_addr = 0;
+				tentry->vb2_q_idx = -1;
+				tentry->vb2_v4l2_buf = NULL;
+				list_del(&tentry->list);
+				kfree(tentry);
+				break;
+			}
+		}
+
+	mutex_unlock(&cap_hndl->travel_mutex);
+
+#ifdef ENABLE_GPU_CACHE
+	if (cap_hndl->gpu_cache_ctrl &&
+		gpu_cache_idx != -1) {
+		ret = rtk_gpu_cache_control_release_frame(cap_hndl->gpu_cache_ctrl, gpu_cache_idx);
+		if (ret)
+			vpu_err("%s, rtk_gpu_cache_control_release_frame fail", __func__);
+	}
+#endif
+
+	buflock = (struct ve2rpc_ion_object *)cap_hndl->buflock;
+	if (buflock_pa) {
+		buflock_va = _get_buflock_va(buflock, buflock_pa);
+		if (!buflock_va) {
+			vpu_err("can't find buflock_va by buflock_pa %x, buflock %p\n",
+				buflock_pa, buflock);
+			return -EINVAL;
+		}
+
+		mutex_lock(&cap_hndl->buflock_mutex);
+		if (*buflock_va == E_BUFLOCK_ST_LOCK) {
+			*buflock_va = E_BUFLOCK_ST_UNLOCK;
+			dsb(sy);
+		}
+		mutex_unlock(&cap_hndl->buflock_mutex);
+
+		ret = ve2rpc_add_to_buflock_clear_q(cap_hndl, buflock_pa, buflock_va);
+		if (ret)
+			return ret;
+	}
+
+	buflock_info = ve2rpc_get_unused_buflock(cap_hndl);
+	if (!buflock_info) {
+		vpu_err("can't find buflock_pa\n");
+		return -EINVAL;
+	}
+
+	buflock_va = buflock_info->buflock_va;
+
+	mutex_lock(&prb->lock);
+	ve2rpc_add_to_msgQ(cap_hndl, buflock_info->buflock_pa);
+	mutex_unlock(&prb->lock);
+
+	return ret;
+}
+
+static uint64_t _ve2rpc_update_PTS(struct ve2rpc *cap_hndl,
+			     uint32_t ptsHigh, uint32_t ptsLow)
+{
+	uint64_t frmPTS = 0;
+#ifdef REORDER_PTS
+	uint64_t estPTS = ULLONG_MAX;
+	uint32_t estIdx = UINT_MAX;
+	struct pts_queue *entry = NULL;
+	struct pts_queue *match_entry = NULL;
+	struct pts_queue *tmp_entry = NULL;
+
+	if (cap_hndl->is_pts_reorder) {
+		mutex_lock(&cap_hndl->pts_mutex);
+		//find the smallest pts
+		if (cap_hndl->pts_queue) {
+			list_for_each_entry (entry, cap_hndl->pts_queue, list) {
+				if (entry && entry->pts < estPTS) {
+					estPTS = entry->pts;
+					estIdx = entry->idx;
+					match_entry = entry;
+				}
+			}
+		}
+
+		//delete this node
+		if (cap_hndl->pts_queue) {
+			list_for_each_entry_safe (entry, tmp_entry, cap_hndl->pts_queue,
+						  list) {
+				if (entry && entry == match_entry) {
+					list_del(&entry->list);
+					kfree(entry);
+				}
+			}
+		}
+		mutex_unlock(&cap_hndl->pts_mutex);
+
+		frmPTS = estPTS;
+		if (ptsHigh != estIdx)
+			vpu_output_dbg("Refine PTS\n");
+
+		if (cap_hndl->pre_pts > frmPTS)
+			vpu_warn("PTS roll back %lld => %lld\n", cap_hndl->pre_pts,
+				 frmPTS);
+
+		cap_hndl->pre_pts = frmPTS;
+
+		if (!ptsLow) {
+			cap_hndl->lastID = ptsHigh;
+		} else {
+			if (ptsHigh == cap_hndl->lastID || ptsLow < 0) {
+				frmPTS += (ptsLow * 100 / 9);
+			} else {
+				vpu_warn("invalid pts %d %d", ptsHigh, ptsLow);
+			}
+		}
+	}else
+#endif
+	{
+		frmPTS = ptsHigh;
+		frmPTS = (frmPTS << 32) | ptsLow;
+	}
+
+	return frmPTS;
+}
+
+static void _ve2rpc_update_buflock(struct ve2rpc *cap_hndl,
+			     uint32_t buflock_phy_addr)
+{
+	struct ve2rpc_ion_object *buflock;
+	volatile uint8_t *buflock_va;
+
+	mutex_lock(&cap_hndl->buflock_mutex);
+	buflock = (struct ve2rpc_ion_object *)cap_hndl->buflock;
+	buflock_va =
+		_get_buflock_va(buflock, buflock_phy_addr);
+	if (!buflock_va)
+		vpu_err("can't find buflock_va by buflock_pa 0x%x, buflock %p\n",
+			buflock_phy_addr, buflock);
+
+	if (*buflock_va == E_BUFLOCK_ST_TOUCH) {
+		*buflock_va = E_BUFLOCK_ST_LOCK;
+		dsb(sy);
+	}
+	mutex_unlock(&cap_hndl->buflock_mutex);
+
+}
+
+static int _ve2rpc_update_dpb(struct ve2rpc *cap_hndl,
+			     bool no_frame, void **disp_buf, uint32_t y_phy_addr, uint32_t *idx)
+{
+	int ret = 0;
+	int i = 0;
+
+	mutex_lock(&cap_hndl->dpb_mutex);
+	if (no_frame == 0) {
+		for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
+			if (cap_hndl->dpb[i].y_phy_addr == y_phy_addr) {
+				*disp_buf = cap_hndl->dpb[i].vb2_v4l2_buf;
+				*idx = cap_hndl->dpb[i].idx;
+				break;
+			}
+		}
+
+		if (i == VE2_MAX_DPB_NUM) {
+			vpu_err("Can't find vb2_v4l2_buf for 0x%x\n",
+				y_phy_addr);
+			mutex_unlock(&cap_hndl->dpb_mutex);
+			ret = -ENOBUFS;
+			goto exit;
+		}
+	} else {
+		for (i = VE2_MAX_DPB_NUM - 1; i >= 0; i--) {
+			struct vb2_v4l2_buffer *buf = (struct vb2_v4l2_buffer *)cap_hndl->dpb[i].vb2_v4l2_buf;
+			if (cap_hndl->dpb[i].status == RTKVE2_DPB_ST_VALID &&
+					buf->vb2_buf.state == VB2_BUF_STATE_ACTIVE) {
+				*disp_buf = cap_hndl->dpb[i].vb2_v4l2_buf;
+				*idx = cap_hndl->dpb[i].idx;
+				break;
+			}
+		}
+
+		if (i == -1) {
+			vpu_err("Can't find valid buffer for EOS\n");
+			mutex_unlock(&cap_hndl->dpb_mutex);
+			ret = -ENOBUFS;
+			goto exit;
+		}
+	}
+	mutex_unlock(&cap_hndl->dpb_mutex);
+
+exit:
+	return ret;
+}
+
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+static void _ve2rpc_fill_frm_info(struct ve2rpc *cap_hndl,
+			     volatile ve2rpc_flash_frame_info_t *frame,
+			     struct vb2_v4l2_buffer *buf)
+{
+	struct ve_frame_info *ve2frame_info = NULL;
+	unsigned int pic_cmprs_mode = 0;
+
+	ve2frame_info = (struct ve_frame_info *)vb2_plane_vaddr(&buf->vb2_buf, 0);
+	if (!ve2frame_info) {
+		vpu_err("%s Can't get plane virtual address\n", __func__);
+		return ;
+	}
+
+	ve2frame_info->yuvs.lumaOffTblAddr = 0xffffffff;
+	ve2frame_info->yuvs.chromaOffTblAddr = 0xffffffff;
+	ve2frame_info->yuvs.lumaOffTblAddrR = 0xffffffff;
+	ve2frame_info->yuvs.chromaOffTblAddrR = 0xffffffff;
+	ve2frame_info->yuvs.bufBitDepth = 8;
+	ve2frame_info->yuvs.matrix_coefficients = 1;
+	ve2frame_info->yuvs.tch_hdr_metadata[0] = -1;
+
+	ve2frame_info->yuvs.Y_addr_Right = 0xffffffff;
+	ve2frame_info->yuvs.U_addr_Right = 0xffffffff;
+	ve2frame_info->yuvs.pLock_Right = 0xffffffff;
+
+	ve2frame_info->rtk_meta_buf_id = 0x52544B6D; //RTKm
+	ve2frame_info->is_ve1_buf = 0;
+
+	pic_cmprs_mode = htonl(frame->nCmprsMode);
+
+	ve2frame_info->yuvs.width = htonl(frame->nPicWidth);
+	ve2frame_info->yuvs.height = htonl(frame->nPicHeight);
+	ve2frame_info->yuvs.Y_addr = htonl(frame->nPicPhysicalAddr);
+	ve2frame_info->yuvs.U_addr = htonl(frame->nPicCPhysicalAddr);
+	ve2frame_info->yuvs.Y_pitch = pic_cmprs_mode ?
+					      htonl(frame->nPicCmprsPitch) :
+					      htonl(frame->nPicPitch);
+	ve2frame_info->yuvs.C_pitch = pic_cmprs_mode ?
+					      htonl(frame->nPicCmprsPitch) :
+					      htonl(frame->nPicCPitch);
+	ve2frame_info->yuvs.slice_height = htonl(frame->nPicHeight);
+	ve2frame_info->yuvs.mode = htonl(frame->nInterlaceMode);
+
+	ve2frame_info->yuvs.tvve_picture_width = htonl(frame->nSampleWidth);
+	ve2frame_info->yuvs.tvve_lossy_en = (pic_cmprs_mode == 2) ? 1 : 0;
+	ve2frame_info->yuvs.tvve_bypass_en = (pic_cmprs_mode == 0) ? 1 : 0;
+	ve2frame_info->yuvs.tvve_qlevel_sel_y = htonl(frame->qlevel_sel_y);
+	ve2frame_info->yuvs.tvve_qlevel_sel_c = htonl(frame->qlevel_sel_c);
+	ve2frame_info->yuvs.is_ve_tile_mode = 0;
+	ve2frame_info->yuvs.film_grain_metadat_addr =
+		htonl(frame->film_grain_metadata_addr);
+	ve2frame_info->yuvs.film_grain_metadat_size =
+		htonl(frame->film_grain_metadata_size);
+	ve2frame_info->yuvs.hdr_metadata_addr = htonl(frame->hdr_metadata_addr);
+	ve2frame_info->yuvs.hdr_metadata_size = htonl(frame->hdr_metadata_size);
+	ve2frame_info->yuvs.video_full_range_flag =
+		htonl(frame->nVideoFullRangeFlag);
+	ve2frame_info->yuvs.pFrameBufferDbg =
+		0;
+	ve2frame_info->yuvs.pixelAR_hor = htonl(frame->nPixelAR_hor);
+	ve2frame_info->yuvs.pixelAR_ver = htonl(frame->nPixelAR_ver);
+
+	ve2frame_info->yuvs.is_dolby_video = 0;
+	ve2frame_info->yuvs.bufBitDepth = htonl(frame->nBitDepthLuma);
+	ve2frame_info->yuvs.lumaOffTblAddr =
+		pic_cmprs_mode ? htonl(frame->nPicYCmprsHdrAddr) : -1U;
+	ve2frame_info->yuvs.chromaOffTblAddr =
+		pic_cmprs_mode ? htonl(frame->nPicCCmprsHdrAddr) : -1U;
+	ve2frame_info->yuvs.lumaOffTblSize = htonl(frame->max_cmprs_head_size);
+	ve2frame_info->yuvs.chromaOffTblSize =
+		htonl(frame->max_cmprs_head_size);
+
+	ve2frame_info->yuvs.Combine_Y_Addr =
+		htonl(frame->nLinearPicPhysicalAddr);
+	ve2frame_info->yuvs.Combine_U_Addr =
+		htonl(frame->nLinearPicCPhysicalAddr);
+	ve2frame_info->yuvs.Combine_Width = htonl(frame->nLinearPicWidth);
+	ve2frame_info->yuvs.Combine_Height = htonl(frame->nLinearPicHeight);
+	ve2frame_info->yuvs.Combine_Y_Pitch = htonl(frame->nLinearPicPitch);
+
+	if (cap_hndl->col_matrix.matrix_coefficients !=
+	    COLOR_MATRIX_COEF_DEFAULT) {
+		ve2frame_info->yuvs.matrix_coefficients =
+			cap_hndl->col_matrix.matrix_coefficients;
+		ve2frame_info->yuvs.transferCharacteristics =
+			cap_hndl->col_matrix.transfer_characteristics;
+		ve2frame_info->yuvs.display_primaries_x0 =
+			cap_hndl->col_matrix.primary_r_chromaticity_x;
+		ve2frame_info->yuvs.display_primaries_x1 =
+			cap_hndl->col_matrix.primary_g_chromaticity_x;
+		ve2frame_info->yuvs.display_primaries_x2 =
+			cap_hndl->col_matrix.primary_b_chromaticity_x;
+		ve2frame_info->yuvs.display_primaries_y0 =
+			cap_hndl->col_matrix.primary_r_chromaticity_y;
+		ve2frame_info->yuvs.display_primaries_y1 =
+			cap_hndl->col_matrix.primary_g_chromaticity_y;
+		ve2frame_info->yuvs.display_primaries_y2 =
+			cap_hndl->col_matrix.primary_b_chromaticity_y;
+		ve2frame_info->yuvs.white_point_x =
+			cap_hndl->col_matrix.whitepoint_chromaticity_x;
+		ve2frame_info->yuvs.white_point_y =
+			cap_hndl->col_matrix.whitepoint_chromaticity_y;
+		ve2frame_info->yuvs.max_display_mastering_luminance =
+			cap_hndl->col_matrix.luminance_max;
+		ve2frame_info->yuvs.min_display_mastering_luminance =
+			cap_hndl->col_matrix.luminance_min;
+	}
+
+	if ((ve2frame_info->yuvs.transferCharacteristics == 1) ||
+	    (ve2frame_info->yuvs.transferCharacteristics == 2) ||
+	    ((htonl(frame->nHDR_Type) == 5 || htonl(frame->nHDR_Type) == 3) &&
+	     ve2frame_info->yuvs.hdr_metadata_addr)) {
+		/*HDR 10*/
+		ve2frame_info->hdr_type = 2;
+	} else if ((ve2frame_info->yuvs.transferCharacteristics == 6) ||
+		   (htonl(frame->nHDR_Type) == 6 &&
+		    ve2frame_info->yuvs.hdr_metadata_addr)) {
+		/*HLG*/
+		ve2frame_info->hdr_type = 3;
+	} else if (htonl(frame->nHDR_Type) == 0 ||
+		   htonl(frame->nHDR_Type) == 1) {
+		ve2frame_info->hdr_type = 0;
+	}
+
+}
+#endif
+
+#ifdef ENABLE_GPU_CACHE
+static int _ve2rpc_set_gpu_cache(struct ve2rpc *cap_hndl,
+			     volatile ve2rpc_flash_frame_info_t *frame)
+{
+	int index = -1;
+
+	if (cap_hndl->gpu_cache_ctrl) {
+		uint32_t gpu_ip_pitch = (htonl(frame->nBitDepthLuma) == 10) ?
+								(2 *ALIGN(htonl(frame->nSampleWidth), 64)) :
+								ALIGN(htonl(frame->nSampleWidth), 64);
+		uint32_t buf_size = gpu_ip_pitch * cap_hndl->ddr_height;
+		dma_addr_t payload_begin_y = (dma_addr_t)htonl(frame->nPicPhysicalAddr);
+		dma_addr_t payload_begin_c = (dma_addr_t)htonl(frame->nPicCPhysicalAddr);
+		dma_addr_t adr_begin_y = (dma_addr_t)payload_begin_y;
+		dma_addr_t adr_end_y = (dma_addr_t)(adr_begin_y + buf_size);
+		dma_addr_t adr_begin_c = (dma_addr_t)adr_end_y;
+		dma_addr_t adr_end_c = (dma_addr_t)(adr_begin_c + (buf_size / 2));
+		dma_addr_t hdr_y = (dma_addr_t)(htonl(frame->nPicYCmprsHdrAddr));
+		dma_addr_t hdr_c = (dma_addr_t)(htonl(frame->nPicCCmprsHdrAddr));
+		uint32_t decmp_pl_pitch = htonl(frame->nPicCmprsPitch) * 4;
+		uint32_t decmp_hdr_pitch = ALIGN(((htonl(frame->nSampleWidth) + 63) / 64) * 8, 64);
+		int ret = 0;
+
+		index = rtk_gpu_cache_control_request_frame2(cap_hndl->gpu_cache_ctrl,
+			adr_begin_y, adr_end_y,
+			adr_begin_c, adr_end_c);
+		if (index >= 0) {
+			ret = rtk_gpu_cache_control_set_frame(cap_hndl->gpu_cache_ctrl, index, 0,
+				adr_begin_y, adr_end_y, hdr_y, payload_begin_y);
+			if (ret)
+				vpu_err("rtk_gpu_cache_control_set_frame Y fail");
+
+			ret = rtk_gpu_cache_control_set_frame(cap_hndl->gpu_cache_ctrl, index, 1,
+				adr_begin_c, adr_end_c, hdr_c, payload_begin_c);
+			if (ret)
+				vpu_err("rtk_gpu_cache_control_set_frame C fail");
+
+			ret = rtk_gpu_cache_control_set_frame_info(cap_hndl->gpu_cache_ctrl, index,
+					decmp_pl_pitch, decmp_hdr_pitch, gpu_ip_pitch, htonl(frame->nPicHeight));
+			if (ret)
+				vpu_err("rtk_gpu_cache_control_set_frame_info fail");
+
+			ret = rtk_gpu_cache_control_set_param(cap_hndl->gpu_cache_ctrl,
+				GPU_CACHE_PARAM_ID_QLEVEL_QUEUE_SEL_Y, htonl(frame->qlevel_sel_y));
+			if (ret)
+				vpu_err("GPU_CACHE_PARAM_ID_QLEVEL_QUEUE_SEL_Y fail");
+
+			ret = rtk_gpu_cache_control_set_param(cap_hndl->gpu_cache_ctrl,
+				GPU_CACHE_PARAM_ID_QLEVEL_QUEUE_SEL_C, htonl(frame->qlevel_sel_c));
+			if (ret)
+				vpu_err("GPU_CACHE_PARAM_ID_QLEVEL_QUEUE_SEL_C fail");
+
+			ret = rtk_gpu_cache_control_set_param(cap_hndl->gpu_cache_ctrl,
+				GPU_CACHE_PARAM_ID_LOSSY_EN, htonl(frame->nCmprsMode) >= 2);
+			if (ret)
+				vpu_err("GPU_CACHE_PARAM_ID_LOSSY_EN fail");
+
+			ret = rtk_gpu_cache_control_set_param(cap_hndl->gpu_cache_ctrl,
+				GPU_CACHE_PARAM_ID_DECOMP_BPP, htonl(frame->nBitDepthLuma)==8 ? 0 : 3);
+			if (ret)
+				vpu_err("GPU_CACHE_PARAM_ID_DECOMP_BPP fail");
+
+			ret = rtk_gpu_cache_control_set_param(cap_hndl->gpu_cache_ctrl,
+				GPU_CACHE_PARAM_ID_GPU_DECOMP_CBCR_SEL, 1);
+			if (ret)
+				vpu_err("GPU_CACHE_PARAM_ID_GPU_DECOMP_CBCR_SEL fail");
+
+			ret = rtk_gpu_cache_control_set_param(cap_hndl->gpu_cache_ctrl,
+				GPU_CACHE_PARAM_ID_DDR_HEADER_SWAP, 1);
+			if (ret)
+				pr_err("GPU_CACHE_PARAM_ID_DDR_HEADER_SWAP fail");
+
+			ret = rtk_gpu_cache_control_set_param(cap_hndl->gpu_cache_ctrl,
+				GPU_CACHE_PARAM_ID_DDR_PAYLOAD_SWAP, 1);
+			if (ret)
+				vpu_err("GPU_CACHE_PARAM_ID_DDR_PAYLOAD_SWAP fail");
+
+			ret = rtk_gpu_cache_control_set_param(cap_hndl->gpu_cache_ctrl,
+				GPU_CACHE_PARAM_ID_NEW_PACKING, htonl(frame->nCmprsMode) == 3);
+			if (ret)
+				vpu_err("GPU_CACHE_PARAM_ID_NEW_PACKING fail");
+		} else {
+			pr_err("rtk_gpu_cache_control_request_frame2 fail");
+		}
+	}
+
+	return index;
+}
+#endif
+
+static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
+			     uint64_t *pts, int frm_idx, bool *eos,
+			     bool *no_frame, uint32_t *no_show_frm_cnt, uint8_t secure)
+{
+	volatile ve2rpc_flash_frame_info_t *frame;
+	uint32_t flags;
+	uint32_t nVersion = 0;
+	uint32_t ptsHigh = 0;
+	uint32_t ptsLow = 0;
+	uint32_t y_phy_addr = 0;
+	uint32_t c_phy_addr = 0;
+	uint32_t buflock_phy_addr = 0;
+	uint32_t idx = 0xFFFFFFFF;
+	struct traveling_frame_st *tentry;
+	struct traveling_frame_st *tmp_tentry = NULL;
+	int ret = 0;
+	int gpu_idx = -1;
+
+	frame = (volatile ve2rpc_flash_frame_info_t *)cap_hndl->frame[frm_idx];
+
+	frame->pUserData = false;
+	dsb(sy);
+	y_phy_addr = htonl(frame->nPicPhysicalAddr);
+	c_phy_addr = htonl(frame->nPicCPhysicalAddr);
+	buflock_phy_addr =  htonl(frame->nBufLockPhysicalAddr);
+	*no_show_frm_cnt = htonl(frame->noShowFrame_count);
+	ptsLow = htonl(frame->nPtsLow);
+	ptsHigh = htonl(frame->nPtsHigh);
+
+	flags = htonl(frame->nPicFlags);
+	nVersion = htonl(frame->nVersion);
+
+	dsb(sy);
+
+	if (nVersion == 0x8001) {
+		vpu_output_dbg("No decoded frame with no show frame count %d", *no_show_frm_cnt);
+		ret = -ENODATA;
+		*no_frame = true;
+		ve2rpc_add_to_msgQ(cap_hndl, buflock_phy_addr);
+		goto exit;
+	}
+
+	if(*no_show_frm_cnt)
+		vpu_output_dbg("decoded frame with no show frame count %d", *no_show_frm_cnt);
+
+	mutex_lock(&cap_hndl->travel_mutex);
+	list_for_each_entry_safe (tentry, tmp_tentry, &cap_hndl->qframe.tlist,
+		list) {
+		struct vb2_v4l2_buffer *buf = (struct vb2_v4l2_buffer *)tentry->vb2_v4l2_buf;
+		if (y_phy_addr && tentry->phy_addr == y_phy_addr &&
+			buf->vb2_buf.state != VB2_BUF_STATE_ACTIVE ) {
+			vpu_output_dbg("Waiting for show existing frame %d!!!!", buf->vb2_buf.state);
+			ret = -EADDRINUSE;
+			mutex_unlock(&cap_hndl->travel_mutex);
+			return ret;
+		}
+	}
+	mutex_unlock(&cap_hndl->travel_mutex);
+
+	if (pts)
+		*pts = _ve2rpc_update_PTS(cap_hndl, ptsHigh, ptsLow);
+
+	*eos = false;
+	*no_frame = false;
+	if (flags & VRPC_FRAME_INFO_FLAG_EOS) {
+		//The buflock may be E_BUFLOCK_ST_NORMAL when EOS
+		*eos = true;
+		vpu_output_dbg("%s eos %d, no_frame %d\n", __func__, *eos,
+			       *no_frame);
+	}
+
+	if (y_phy_addr == 0 && c_phy_addr == 0) {
+		*no_frame = true;
+		if (flags == 0)
+			vpu_err("Something wrong with the ring buffer logic");
+	}
+
+	_ve2rpc_update_buflock(cap_hndl, buflock_phy_addr);
+
+	ret = _ve2rpc_update_dpb(cap_hndl, *no_frame, disp_buf, y_phy_addr, &idx);
+	if (ret)
+		goto exit;
+
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+	_ve2rpc_fill_frm_info(cap_hndl, frame, *disp_buf);
+#endif
+
+#ifdef ENABLE_GPU_CACHE
+	gpu_idx = _ve2rpc_set_gpu_cache(cap_hndl, frame);
+#endif
+
+	ret = ve2rpc_add_travel_entry(cap_hndl,
+		y_phy_addr, buflock_phy_addr, *disp_buf, idx, gpu_idx);
+exit:
+	return ret;
+}
+
+int ve2rpc_dqframe(struct ve2rpc *cap_hndl, void *disp_buf, uint64_t *pts,
+		   bool *eos, bool *no_frame, uint32_t *no_show_frm_cnt)
+{
+	struct ve2rpc_ringbuf_t *prb;
+
+	int ret = 0;
+
+	if (!cap_hndl || !cap_hndl->instanceID) {
+		vpu_err("handle = %p hndl->instanceID=%d ", cap_hndl,
+			(cap_hndl == NULL) ? 0 : cap_hndl->instanceID);
+		return -EPERM;
+	}
+
+	prb = &cap_hndl->main_rb;
+	mutex_lock(&prb->lock);
+
+	if (prb->pRBH) {
+		if (prb->pRBH->readPtr[0] == prb->pRBH->writePtr) {
+			mutex_unlock(&prb->lock);
+			return -EAGAIN;
+		} else {
+			int rp_idx;
+			uint32_t next_rp;
+
+			rp_idx = (htonl(prb->pRBH->readPtr[0]) -
+				  htonl(prb->pRBH->beginAddr)) /
+				 sizeof(ve2rpc_flash_frame_info_t);
+			next_rp = htonl(prb->pRBH->beginAddr) +
+				  ((rp_idx + 1) % VE2_MAX_DPB_NUM) *
+					  sizeof(ve2rpc_flash_frame_info_t);
+
+			ret = _ve2rpc_get_frame(cap_hndl, disp_buf, pts, rp_idx,
+						eos, no_frame, no_show_frm_cnt, prb->secure);
+			if (ret == -ENODATA) {
+				ret = -ENODATA;
+			} else if (ret != 0) {
+				mutex_unlock(&prb->lock);
+				if (ret != -EADDRINUSE)
+					vpu_err("fail to get a frame, try again ret %d\n",
+						ret);
+				return -EAGAIN;
+			}
+			prb->pRBH->readPtr[0] = htonl(next_rp);
+			dsb(sy);
+		}
+	} else {
+		vpu_err("wrong ringbuffer header\n");
+	}
+	mutex_unlock(&prb->lock);
+
+	return ret;
+}
+#ifdef REORDER_PTS
+int ve2rpc_free_pts(struct ve2rpc *cap_hndl)
+{
+	struct pts_queue *entry;
+	struct pts_queue *tmp_entry;
+
+	if (!cap_hndl) {
+		vpu_err("cap isn't ready\n");
+		return -EPERM;
+	}
+
+	mutex_lock(&cap_hndl->pts_mutex);
+	list_for_each_entry_safe (entry, tmp_entry, cap_hndl->pts_queue, list) {
+		if (entry) {
+			list_del(&entry->list);
+			kfree(entry);
+		}
+	}
+	mutex_unlock(&cap_hndl->pts_mutex);
+	return 0;
+}
+#endif
+
+int ve2rpc_free_travel_frame(struct ve2rpc *cap_hndl)
+{
+	struct traveling_frame_st *tentry;
+	struct traveling_frame_st *tmp_tentry = NULL;
+#ifdef ENABLE_GPU_CACHE
+	int gpu_cache_idx = -1;
+	int ret = 0;
+#endif
+
+	if (!cap_hndl) {
+		vpu_err("cap isn't ready\n");
+		return -EPERM;
+	}
+
+	mutex_lock(&cap_hndl->travel_mutex);
+	list_for_each_entry_safe (tentry, tmp_tentry, &cap_hndl->qframe.tlist,
+				  list) {
+		if (tentry) {
+#ifdef ENABLE_GPU_CACHE
+			gpu_cache_idx = tentry->gpu_cache_idx;
+#endif
+			tentry->phy_addr = 0;
+			tentry->phy_addr = 0;
+			tentry->vb2_q_idx = -1;
+			tentry->vb2_v4l2_buf = NULL;
+			list_del(&tentry->list);
+			kfree(tentry);
+		} else {
+			vpu_err("tentry is NULL\n");
+		}
+#ifdef ENABLE_GPU_CACHE
+		if (cap_hndl->gpu_cache_ctrl &&
+			gpu_cache_idx != -1) {
+			ret = rtk_gpu_cache_control_release_frame
+					(cap_hndl->gpu_cache_ctrl, gpu_cache_idx);
+			if (ret)
+				vpu_err("%s rtk_gpu_cache_control_release_frame fail", __func__);
+			gpu_cache_idx = -1;
+		}
+#endif
+	}
+	mutex_unlock(&cap_hndl->travel_mutex);
+
+	return 0;
+}
+
+int ve2rpc_reset_bs_ring_rwptr(struct ve2rpc *out_hndl)
+{
+	struct ve2rpc_ringbuf_t *prb;
+	int ret = 0;
+
+	if (!out_hndl) {
+		vpu_err("out isn't ready\n");
+		ret = -EPERM;
+		goto exit;
+	}
+
+	prb = &out_hndl->main_rb;
+	if (!prb) {
+		vpu_err("%s ringbuffer isn't ready\n", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&prb->lock);
+
+	if (prb->pRBH)
+		prb->pRBH->readPtr[0] = prb->pRBH->writePtr;
+
+	mutex_unlock(&prb->lock);
+exit:
+	return ret;
+}
+
+int ve2rpc_reset_msg_ring_rwptr(struct ve2rpc *cap_hndl)
+{
+	volatile ve2rpc_flash_frame_info_t *frame;
+	volatile uint32_t rptr = 0;
+	struct ve2rpc_ringbuf_t *prb;
+	int ret = 0;
+
+	if (!cap_hndl) {
+		vpu_err("cap isn't ready\n");
+		ret = -EPERM;
+		goto exit;
+	}
+
+	prb = &cap_hndl->main_rb;
+	if (!prb) {
+		vpu_err("%s ringbuffer isn't ready\n", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&prb->lock);
+
+	while (prb->pRBH->readPtr[0] != prb->pRBH->writePtr) {
+		rptr = (htonl(prb->pRBH->readPtr[0]) -
+					  htonl(prb->pRBH->beginAddr)) /
+					 sizeof(ve2rpc_flash_frame_info_t);
+		frame = (volatile ve2rpc_flash_frame_info_t *)cap_hndl->frame[rptr];
+		frame->pUserData = false;
+		rptr = htonl(prb->pRBH->beginAddr) +
+			  ((rptr + 1) % VE2_MAX_DPB_NUM) *
+				  sizeof(ve2rpc_flash_frame_info_t);
+		prb->pRBH->readPtr[0] = htonl(rptr);
+		dsb(sy);
+	}
+
+	cap_hndl->outputRingIdx = (htonl(prb->pRBH->writePtr) -
+				  htonl(prb->pRBH->beginAddr)) /
+				 sizeof(ve2rpc_flash_frame_info_t);
+
+	mutex_unlock(&prb->lock);
+exit:
+	return ret;
+}
+
+int ve2rpc_reset_buflock(struct ve2rpc *cap_hndl, bool force_unlock)
+{
+	volatile uint8_t *buflock_va;
+	int i = 0;
+
+	if (!cap_hndl->buflock)
+		goto exit;
+
+	for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
+		int add_to_wait_q = 0;
+
+		buflock_va = cap_hndl->buflock_info[i].buflock_va;
+		mutex_lock(&cap_hndl->buflock_mutex);
+		if (force_unlock) {
+			if (*buflock_va != E_BUFLOCK_ST_NORMAL &&
+				cap_hndl->buflock_info[i].is_used != 0) {
+				*buflock_va = E_BUFLOCK_ST_UNLOCK;
+				add_to_wait_q = 1;
+			}
+		} else {
+			if (*buflock_va == E_BUFLOCK_ST_NORMAL) {
+				cap_hndl->buflock_info[i].is_used = 0;
+			} else if (*buflock_va == E_BUFLOCK_ST_TOUCH) {
+				*buflock_va = E_BUFLOCK_ST_UNLOCK;
+				add_to_wait_q = 1;
+				cap_hndl->buflock_info[i].is_used = 0;
+			} if (*buflock_va == E_BUFLOCK_ST_RELEASE) {
+				*buflock_va = E_BUFLOCK_ST_NORMAL;
+				cap_hndl->buflock_info[i].is_used = 0;
+			}
+		}
+		dsb(sy);
+		mutex_unlock(&cap_hndl->buflock_mutex);
+
+		if (add_to_wait_q) {
+			int ret = 0;
+			ret = ve2rpc_add_to_buflock_clear_q(cap_hndl,
+				cap_hndl->buflock_info[i].buflock_pa,
+				cap_hndl->buflock_info[i].buflock_va);
+			if (ret)
+				vpu_err("%s add to buflock wq fail, ret %d", __func__, ret);
+		}
+	}
+exit:
+	return 0;
+}
+
+struct ve2rpc_ion_object * ve2rpc_init_shuttle(struct device *dev)
+{
+	return _ve2rpc_audio_ion_create(dev, SHUTTLE_BUF_SIZE);
+}
+
+void ve2rpc_uninit_shuttle(struct device *dev, struct ve2rpc_ion_object *obj)
+{
+	_ve2rpc_ion_free(dev, obj);
+}
+
+int ve2rpc_init_out_handle(struct device *dev, struct ve2rpc **handle,
+			   uint8_t is_secure, struct v4l2_fh *fh, struct ve2rpc_ion_object * dma)
+{
+	struct ve2rpc *hndl;
+	int ret = 0;
+
+	if (!handle) {
+		vpu_info("capture ve2 rpc is inited\n");
+		goto exit;
+	}
+
+	*handle = kzalloc(sizeof(struct ve2rpc), GFP_KERNEL);
+	if (!*handle) {
+		vpu_err("capture allocate ve2rpc handle fail\n");
+		ret =  -ENOMEM;
+		goto exit;
+	}
+
+	hndl = *handle;
+	hndl->dev = dev;
+	hndl->is_secure = is_secure;
+	hndl->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	hndl->dma_obj = dma;
+
+	mutex_init(&hndl->lock);
+
+	ret = _ve2rpc_open(hndl, VF_TYPE_VIDEO_MPEG2_DECODER, fh);
+	if (ret) {
+		vpu_err("ve2rpc_out fail to open vpu decoder\n");
+		ret = -EPERM;
+		goto open_fail;
+	}
+
+	ret = ve2rpc_SetRingBuffer(hndl, &hndl->main_rb, 0x1000000,
+				   RINGBUFFER_STREAM, is_secure);
+	if (ret) {
+		vpu_err("ve2rpc_out fail to initial bs rb\n");
+		goto create_bs_fail;
+	}
+
+	ret = ve2rpc_SetRingBuffer(hndl, &hndl->sub_rb, 0x40000,
+				   RINGBUFFER_COMMAND, false);
+	if (ret) {
+		vpu_err("ve2rpc_out fail to initial inband rb\n");
+		goto create_cmd_fail;
+	}
+
+	ret = ve2rpc_SetRingBuffer(hndl, &hndl->dpb_rb, 0x40000,
+				   RINGBUFFER_FRAME_USER, false);
+	if (ret) {
+		vpu_err("ve2rpc_out fail to initial dpb rb\n");
+		goto create_dpb_fail;
+	}
+
+	hndl->buflock = NULL;
+	hndl->frame = NULL;
+
+	return 0;
+create_dpb_fail:
+	_ve2rpc_ringbuf_release(hndl, &hndl->sub_rb);
+create_cmd_fail:
+	_ve2rpc_ringbuf_release(hndl, &hndl->main_rb);
+create_bs_fail:
+	ve2rpc_close(hndl);
+open_fail:
+	if (hndl)
+		kfree(hndl);
+exit:
+	return ret;
+}
+
+int ve2rpc_init_cap_handle(struct device *dev, struct ve2rpc **handle,
+			   uint8_t is_secure, struct v4l2_fh *fh, struct ve2rpc_ion_object * dma)
+{
+	struct ve2rpc *hndl;
+	volatile uint8_t *buflock_va;
+	uint32_t buflock_pa;
+	volatile ve2rpc_flash_frame_info_t *frame;
+	struct ve2rpc_ion_object *buflock;
+	int ret = 0;
+	int i;
+
+	if (!handle) {
+		vpu_info("capture ve2 rpc is inited\n");
+		goto exit;
+	}
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+	if (METADATA_OFFSET < sizeof(struct ve_frame_info)) {
+		vpu_err("sizeof ve_frame_info %ld is over offset\n", sizeof(struct ve_frame_info));
+		return -EPERM;
+	}
+#endif
+	*handle = kzalloc(sizeof(struct ve2rpc), GFP_KERNEL);
+	if (!*handle) {
+		vpu_err("capture allocate ve2rpc handle fail\n");
+		return -ENOMEM;
+	}
+
+	hndl = *handle;
+	hndl->dev = dev;
+	hndl->is_secure = is_secure;
+	hndl->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	hndl->dma_obj = dma;
+
+	mutex_init(&hndl->lock);
+
+	ret = _ve2rpc_open(hndl, VF_TYPE_FLASH, fh);
+	if (ret) {
+		vpu_err("ve2rpc_cap fail to open vpu flash\n");
+		goto open_fail;
+	}
+
+	ret = ve2rpc_SetRingBuffer(hndl, &hndl->main_rb,
+				   (sizeof(ve2rpc_flash_frame_info_t)) *
+					   VE2_MAX_DPB_NUM,
+				   RINGBUFFER_MESSAGE, false);
+	if (ret) {
+		vpu_err("ve2rpc_cap fail to initial rb\n");
+		goto create_main_fail;
+	}
+
+	{
+#define VRB_STRUCT_VERSION 1
+#define VRPC_FLASH_FORMAT_SEND_BUF_ID 5
+		hndl->main_rb.pRBH->reserve2 =
+			htonl((VE2_MAX_DPB_NUM << 24 & 0xff000000) |
+			      (is_secure << 16 & 0x00ff0000) |
+			      (VRB_STRUCT_VERSION << 8 & 0xff00) |
+			      VRPC_FLASH_FORMAT_SEND_BUF_ID);
+#ifdef SUPPORT_ADAPTIVE_PLAYBACK
+		hndl->main_rb.pRBH->reserve3 =
+			htonl(1 /*width*/ << 16 | 1 /*height*/);
+#endif
+	}
+
+	mutex_init(&hndl->buflock_mutex);
+	mutex_lock(&hndl->buflock_mutex);
+	buflock = (void *)_ve2rpc_media_ion_create(hndl->dev, 4096);
+	if (IS_ERR(buflock)) {
+		vpu_err("allocate buflock fail, No Memory\n");
+		mutex_unlock(&hndl->buflock_mutex);
+		ret = -ENOMEM;
+		goto create_buflock_fail;
+	}
+
+	hndl->buflock = (void *)buflock;
+	buflock_va = (uint8_t *)buflock->vaddr;
+	buflock_pa = (uint32_t)buflock->paddr;
+	memset_volatile(buflock_va, E_BUFLOCK_ST_ERROR, buflock->size);
+	mutex_unlock(&hndl->buflock_mutex);
+
+	hndl->frame = kzalloc(sizeof(uintptr_t) * VE2_MAX_DPB_NUM, GFP_KERNEL);
+	if (!hndl->frame) {
+		vpu_err("allocate msg queue frame fail\n");
+		ret = -ENOMEM;
+		goto alloc_frame_fail;
+	}
+
+	hndl->buflock_info =
+		kzalloc(sizeof(struct rtkve2_buflock_t) * VE2_MAX_DPB_NUM, GFP_KERNEL);
+	if (!hndl->buflock_info) {
+		vpu_err("allocate buflock_info frame fail\n");
+		ret = -ENOMEM;
+		goto alloc_bfl_info_fail;
+	}
+	frame = (volatile ve2rpc_flash_frame_info_t *)
+			hndl->main_rb.rbinfo.buf_uncached;
+
+	hndl->outputRingIdx = 0;
+	hndl->col_matrix.matrix_coefficients = COLOR_MATRIX_COEF_DEFAULT;
+	for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
+		hndl->frame[i] = (uintptr_t)&frame[i];
+		hndl->buflock_info[i].buflock_pa = buflock_pa + i * sizeof(uintptr_t);
+		hndl->buflock_info[i].buflock_va = buflock_va + i * sizeof(uintptr_t);
+		hndl->buflock_info[i].idx = i;
+		/* DO NOT CHANGE THE ORDER BEGIN*/
+		mutex_lock(&hndl->buflock_mutex);
+		buflock_va[i * sizeof(uintptr_t)] = E_BUFLOCK_ST_NORMAL;
+		dsb(sy);
+		mutex_unlock(&hndl->buflock_mutex);
+		frame[i].nBufLockPhysicalAddr = htonl(hndl->buflock_info[i].buflock_pa);
+		dsb(sy);
+		frame[i].nClkTimeHigh = -1;
+		frame[i].nClkTimeLow = -1;
+		frame[i].nPicPhysicalAddr =
+			htonl((uint32_t)(uintptr_t)&frame[i]);
+		frame[i].nPicCPhysicalAddr = 0;
+		frame[i].nPicWidth = PIC_SIZE_INVALID;
+		frame[i].nPicHeight = PIC_SIZE_INVALID;
+		frame[i].pUserData = false;
+		dsb(sy);
+		/* DO NOT CHANGE THE ORDER END*/
+	}
+	INIT_LIST_HEAD(&hndl->qframe.list);
+	INIT_LIST_HEAD(&hndl->qframe.tlist);
+	mutex_init(&hndl->qframe.lock);
+	mutex_init(&hndl->travel_mutex);
+	mutex_init(&hndl->dpb_mutex);
+
+	return 0;
+alloc_bfl_info_fail:
+	if (hndl->frame)
+		kfree(hndl->frame);
+alloc_frame_fail:
+	if (hndl->buflock)
+		_ve2rpc_ion_free(hndl->dev, hndl->buflock);
+create_buflock_fail:
+	_ve2rpc_ringbuf_release(hndl, &hndl->main_rb);
+create_main_fail:
+	ve2rpc_close(hndl);
+open_fail:
+	if (hndl)
+		kfree(hndl);
+exit:
+	return ret;
+}
+
+int ve2rpc_uninit_handle(struct ve2rpc *hndl)
+{
+	if (!hndl) {
+		vpu_err("invaild handler");
+		return -EINVAL;
+	}
+
+	if (V4L2_TYPE_IS_CAPTURE(hndl->type)) {
+		mutex_destroy(&hndl->qframe.lock);
+		mutex_destroy(&hndl->travel_mutex);
+		mutex_destroy(&hndl->dpb_mutex);
+#ifdef ENABLE_GPU_CACHE
+		if (hndl->gpu_cache_ctrl)
+			rtk_gpu_cache_control_destroy(hndl->gpu_cache_ctrl);
+#endif
+	}
+
+	mutex_destroy(&hndl->lock);
+
+	_ve2rpc_ringbuf_release(hndl, &hndl->main_rb);
+	if (V4L2_TYPE_IS_OUTPUT(hndl->type)) {
+		_ve2rpc_ringbuf_release(hndl, &hndl->sub_rb);
+		_ve2rpc_ringbuf_release(hndl, &hndl->cc_rb);
+		_ve2rpc_ringbuf_release(hndl, &hndl->dpb_rb);
+	}
+
+	hndl->type = -1;
+
+	if (hndl->buflock_info) {
+		kfree(hndl->buflock_info);
+		hndl->buflock_info = NULL;
+	}
+
+	if (hndl->buflock) {
+		_ve2rpc_ion_free(hndl->dev, hndl->buflock);
+		hndl->buflock = NULL;
+		mutex_destroy(&hndl->buflock_mutex);
+	}
+
+	if (hndl->frame) {
+		kfree(hndl->frame);
+		hndl->frame = NULL;
+	}
+
+	if (hndl)
+		kfree(hndl);
+
+	return 0;
+}
+
+#ifdef VPU_GET_CC
+int ve2rpc_setDecoderCCBypass(struct ve2rpc *hndl, int mode)
+{
+	VIDEO_RPC_DEC_CC_BYPASS_MODE info;
+	int ret;
+
+	if (!hndl || !hndl->instanceID)
+		return -1;
+
+	mutex_lock(&hndl->lock);
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->instanceID);
+	info.cc_mode = htonl(mode);
+
+	ret = _ve2rpc_shuttle(hndl, VIDEO_RPC_DEC_ToAgent_SetDecoderCCBypass,
+			      &info, sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		vpu_err("fail to do cmd %d \n",
+			VIDEO_RPC_DEC_ToAgent_SetDecoderCCBypass);
+		return (-EPERM);
+	}
+
+	return 0;
+}
+
+int ve2rpc_readCcRingBuf(struct ve2rpc_ringbuf_t *prb, uint32_t length,
+			 char *pcDst)
+{
+	int ret = -1;
+	uint32_t read_len = 0, remind_len = 0, rp_offset = 0;
+	uint32_t wp, rp, base, size, space;
+	char *pcSrc = NULL;
+	do {
+		if (!prb) {
+			vpu_err("%s : ERROR! (prb=%p)", __func__, prb);
+			break;
+		}
+		mutex_lock(&prb->lock);
+		wp = ntohl(prb->pRBH->writePtr);
+		rp = ntohl(prb->pRBH->readPtr[0]);
+		base = ntohl(prb->pRBH->beginAddr);
+		size = ntohl(prb->pRBH->size);
+		space = (rp > wp) ? rp - wp : size - (wp - rp);
+		pcSrc = (char *)prb->buf_uncached;
+		if (!pcSrc || !pcDst) {
+			mutex_unlock(&prb->lock);
+			vpu_err("%s : pcSrc=%p pcDst=%p", __func__, pcSrc,
+				pcDst);
+			break;
+		}
+
+		rp_offset = rp - base;
+		if (wp >= rp) {
+			if (wp >= rp + length)
+				read_len = length;
+			else
+				read_len = wp - rp;
+			memcpy(pcDst, pcSrc + rp_offset, read_len);
+		} else {
+			uint32_t top = base + size;
+			uint32_t top_space = top - rp;
+			if (top_space >= length) {
+				read_len = length;
+				memcpy(pcDst, pcSrc + rp_offset, read_len);
+			} else {
+				uint32_t data_bytes_in_buff =
+					top_space + (wp - base);
+				read_len = top_space;
+				memcpy(pcDst, pcSrc + rp_offset, top_space);
+				data_bytes_in_buff -= read_len;
+				rp_offset += read_len;
+				if (data_bytes_in_buff >= length - read_len) {
+					remind_len = length - read_len;
+				} else {
+					remind_len = data_bytes_in_buff;
+				}
+				read_len += remind_len;
+				memcpy(pcDst + top_space, pcSrc + rp_offset,
+				       remind_len);
+			}
+		}
+		rp += read_len;
+		if (rp >= base + size)
+			rp -= size;
+		prb->pRBH->readPtr[0] = htonl(rp);
+		ret = read_len;
+		mutex_unlock(&prb->lock);
+	} while (0);
+	return ret;
+}
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve2rpc.h
@@ -0,0 +1,304 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#ifndef __VE2RPC_H__
+#define __VE2RPC_H__
+#include <linux/videodev2.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/version.h>
+#include <soc/realtek/rtk-krpc-agent.h>
+#include "ve2rpc_cmd.h"
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 10, 116)
+struct dma_buf *ext_rtk_ion_alloc(size_t len, unsigned int heap_type_mask,
+				  unsigned int flags);
+int ext_rtk_ion_close_fd(struct files_struct *files, unsigned fd);
+
+#define ion_alloc ext_rtk_ion_alloc
+#endif
+
+#define COLOR_MATRIX_COEF_DEFAULT (-1)
+#define MAX_VE2_FRAME_BUFFERS 20
+#define VE2_MAX_DPB_NUM 64
+
+typedef enum {
+	VE2RPC_MEMORY_NONE = 0,
+	VE2RPC_MEMORY_CMA,
+	VE2RPC_MEMORY_CMA_DECRYPT_BUF,
+	VE2RPC_MEMORY_CPB,
+	VE2RPC_MEMORY_CPB_DECRYPT_BUF,
+	VE2RPC_MEMORY_INBAND
+} VE2RPC_MEMORY_TYPE;
+
+struct _tagRingBufferHeader {
+	volatile uint32_t magic; //Magic number
+	volatile uint32_t beginAddr;
+	volatile uint32_t size;
+	volatile uint32_t
+		bufferID; // RINGBUFFER_TYPE, choose a type from RINGBUFFER_TYPE
+	volatile uint32_t writePtr;
+	volatile uint32_t numOfReadPtr;
+	volatile uint32_t reserve2; //Reserve for Red Zone
+	volatile uint32_t reserve3; //Reserve for Red Zone
+	volatile uint32_t readPtr[4];
+	volatile int32_t fileOffset;
+	volatile int32_t requestedFileOffset;
+	volatile int32_t fileSize;
+	volatile int32_t
+		bSeekable; /* Can't be sought if data is streamed by HTTP */
+};
+
+struct ve2rpc_ion_object {
+	struct dma_buf *dmabuf;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,6,0)
+	struct dma_buf_map map;
+#else
+	struct iosys_map map;
+#endif
+	dma_addr_t paddr;
+	void *vaddr;
+	size_t size;
+};
+
+struct ve2rpc_ringbuf_info_t {
+	void *hdr_hdl;
+	VE2RPC_MEMORY_TYPE buf_type;
+	uint32_t buf_addr;
+	uint32_t buf_size;
+	void *buf_cached;
+	void *buf_uncached;
+	uint32_t buf_limit;
+
+	void *buf_hdl;
+	VE2RPC_MEMORY_TYPE hdr_type;
+	uint32_t hdr_addr;
+	uint32_t hdr_size;
+	uint32_t hdr_cached;
+	uint32_t hdr_uncached;
+	uint32_t hdr_limit;
+
+	VE2RPC_MEMORY_TYPE bufex_type;
+	uint32_t bufex_addr;
+	uint32_t bufex_size;
+};
+
+struct ve2rpc_ringbuf_t {
+	struct mutex lock;
+
+	struct ve2rpc_ringbuf_info_t rbinfo;
+	volatile struct _tagRingBufferHeader *pRBH;
+	uint8_t *buf_cached;
+	uint8_t *buf_uncached;
+	uint8_t *hdr_cached;
+	uint8_t *hdr_uncached;
+	uint8_t *base;
+	uint8_t *limit;
+	uint32_t size;
+	uint32_t phyaddr;
+	uint32_t phyaddr_hdr;
+	uint32_t read_start;
+	int dummy; /* used for atom access */
+	uint8_t secure;
+	uint32_t memory;
+#ifdef ENABLE_TEE_DRM_FLOW
+	void *teeapi_ctx;
+	unsigned int teeapi_tee_session;
+#endif
+};
+
+struct color_metrix {
+	uint32_t matrix_coefficients;
+	uint32_t range;
+	uint32_t transfer_characteristics;
+	uint32_t primaries;
+	uint32_t max_cll;
+	uint32_t max_fall;
+	uint32_t primary_r_chromaticity_x;
+	uint32_t primary_r_chromaticity_y;
+	uint32_t primary_g_chromaticity_x;
+	uint32_t primary_g_chromaticity_y;
+	uint32_t primary_b_chromaticity_x;
+	uint32_t primary_b_chromaticity_y;
+	uint32_t whitepoint_chromaticity_x;
+	uint32_t whitepoint_chromaticity_y;
+	uint32_t luminance_max;
+	uint32_t luminance_min;
+};
+
+struct ve2rpc_qframe_wq {
+	struct list_head list;
+	struct list_head tlist; //for traveling frame
+	struct mutex lock;
+	struct task_struct *vclient;
+};
+
+enum dpb_st {
+	RTKVE2_DPB_ST_EMPTY,
+	RTKVE2_DPB_ST_VALID,
+	RTKVE2_DPB_ST_DQ
+};
+
+struct rtkve2_reg_dpb_t {
+	uint32_t width;
+	uint32_t height;
+	uint32_t dpb_width;
+	uint32_t dpb_height;
+	uint32_t size;
+	uint64_t y_phy_addr;
+	uint64_t c_phy_addr;
+	uint32_t bit_depth;
+	void *vb2_v4l2_buf;
+	uint32_t idx;
+};
+
+struct rtkve2_dpb_t {
+	unsigned int size;
+	unsigned int width;
+	unsigned int height;
+	uint32_t y_phy_addr;
+	uint32_t c_phy_addr;
+	struct ve2rpc_ion_object *cmprs_hdr_buf;
+	void *vb2_v4l2_buf;
+	uint8_t idx;
+	enum dpb_st status;
+};
+
+struct rtkve2_buflock_t {
+	volatile uint8_t *buflock_va;
+	uint32_t buflock_pa;
+	uint32_t idx;
+	bool is_used;
+};
+
+struct ve2rpc {
+	int type;
+	struct ve2rpc_ringbuf_t main_rb;
+	struct ve2rpc_ringbuf_t sub_rb;
+	struct ve2rpc_ringbuf_t cc_rb;
+	struct ve2rpc_ringbuf_t dpb_rb;
+	uint32_t instanceType;
+	uint32_t instanceID;
+	struct task_struct *buflock_thread;
+	wait_queue_head_t buflock_waitq;
+	struct mutex buflock_mutex;
+	void *buflock;
+	struct rtkve2_buflock_t *buflock_info;
+	uintptr_t *frame;
+	struct ve2rpc_qframe_wq qframe;
+	struct mutex lock;
+#ifdef REORDER_PTS
+	struct mutex pts_mutex;
+	struct list_head *pts_queue;
+	uint64_t pre_pts;
+	int lastID;
+#endif
+	uint32_t rpc_id;
+	struct rtk_krpc_ept_info *vcpu_ept_info;
+	struct v4l2_fh *fh;
+	struct mutex travel_mutex;
+	uint32_t outputRingIdx;
+	struct device *dev;
+#ifdef ENABLE_TEE_DRM_FLOW
+	void *teeapi_ctx;
+	unsigned int teeapi_tee_session;
+#endif
+	struct color_metrix col_matrix;
+	VIDEO_STREAM_TYPE vType;
+	struct rtkve2_dpb_t dpb[VE2_MAX_DPB_NUM];
+	struct mutex dpb_mutex;
+	uint32_t dpb_cnt;
+	uint8_t is_secure;
+	uint8_t is_adaptive_playback;
+	uint8_t is_error;
+	uint8_t is_pts_reorder;
+	uint32_t bit_depth;
+#ifdef ENABLE_GPU_CACHE
+	struct rtk_gpu_cache_control *gpu_cache_ctrl;
+	uint32_t ddr_height;
+#endif
+	struct ve2rpc_ion_object *dma_obj;
+};
+
+struct pts_queue {
+	struct list_head list;
+	uint64_t pts;
+	uint32_t idx;
+};
+
+int ve2rpc_dqframe(struct ve2rpc *cap_hndl, void *disp_buf, uint64_t *pts,
+		   bool *eos, bool *no_frame, uint32_t *no_show_frm_cnt);
+int ve2rpc_qframe(struct ve2rpc *cap_hndl, dma_addr_t phy_addr,
+		  uint32_t work_idx);
+int ve2rpc_write_bs(struct ve2rpc *hndl, uint8_t *buf, uint32_t len,
+		    uint64_t pts, uint32_t sequence);
+int ve2rpc_inband_decode(struct ve2rpc *vout_hndl, DECODE_MODE mode);
+int ve2rpc_inband_newseg(struct ve2rpc *vout_hndl);
+int ve2rpc_pause(struct ve2rpc *hndl);
+int ve2rpc_flush(struct ve2rpc *hndl);
+int ve2rpc_stop(struct ve2rpc *hndl);
+int ve2rpc_close(struct ve2rpc *hndl);
+int ve2rpc_setRole(struct ve2rpc *hndl, VIDEO_STREAM_TYPE type);
+int ve2rpc_connect(struct ve2rpc *src, struct ve2rpc *dst);
+struct ve2rpc_ion_object * ve2rpc_init_shuttle(struct device *dev);
+void ve2rpc_uninit_shuttle(struct device *dev, struct ve2rpc_ion_object *obj);
+int ve2rpc_init_out_handle(struct device *dev, struct ve2rpc **handle,
+			   uint8_t is_secure, struct v4l2_fh *fh, struct ve2rpc_ion_object * dma);
+int ve2rpc_init_cap_handle(struct device *dev, struct ve2rpc **handle,
+			   uint8_t is_secure, struct v4l2_fh *fh, struct ve2rpc_ion_object * dma);
+int ve2rpc_uninit_handle(struct ve2rpc *hndl);
+#ifdef REORDER_PTS
+int ve2rpc_free_pts(struct ve2rpc *cap_hndl);
+#endif
+int ve2rpc_free_travel_frame(struct ve2rpc *cap_hndl);
+int ve2rpc_add_travel_entry(struct ve2rpc *cap_hndl,
+	uint32_t y_phy_addr, uint32_t buflock_phy_addr,
+	void *vb2_v4l2_buf, uint32_t idx, int gpu_id);
+int ve2rpc_reset_buflock(struct ve2rpc *cap_hndl, bool force_unlock);
+int ve2rpc_run(struct ve2rpc *hndl);
+int ve2rpc_get_info(struct ve2rpc *cap_hndl, uint32_t *info);
+int ve2rpc_inband_eos_event(struct ve2rpc_ringbuf_t *ringbuf,
+			   volatile struct _tagRingBufferHeader *pRBH,
+			   unsigned int event_id);
+int ve2rpc_readCcRingBuf(struct ve2rpc_ringbuf_t *prb, uint32_t length,
+			   char *pcDst);
+int ve2rpc_setDecoderCCBypass(struct ve2rpc *hndl, int mode);
+int ve2rpc_SetRingBuffer(struct ve2rpc *hndl, struct ve2rpc_ringbuf_t *prb,
+			   uint32_t bodysize, RINGBUFFER_TYPE type,
+			   uint8_t is_secure);
+int ve2rpc_get_decoded_frm_cnt(struct ve2rpc *hndl);
+int ve2rpc_add_capbuf_to_dpb(struct ve2rpc *out_hndl, struct ve2rpc *cap_hndl,
+			     struct rtkve2_reg_dpb_t dpb, bool is_cmprs);
+int ve2rpc_del_capbuf_from_dpb(struct ve2rpc *out_hndl,
+			   struct ve2rpc *cap_hndl);
+void ve2rpc_update_dpb_st(struct ve2rpc *cap_hndl,
+			   struct vb2_v4l2_buffer *vb2_v4l2_buffer, unsigned int status);
+int ve2rpc_inband_add_buf(struct ve2rpc_ringbuf_t *ringbuf,
+			  struct rtkve2_reg_dpb_t dpb,
+			  uint32_t cmprs_hdr_lu, uint32_t cmprs_hdr_ch,
+			  uint32_t cmprs_hdr_size);
+int ve2rpc_inband_del_buf(struct ve2rpc_ringbuf_t *ringbuf,
+			   uint32_t y_phy_addr);
+int ve2rpc_set_cmprs(struct ve2rpc *hndl, uint8_t enable);
+int ve2rpc_get_bs_info(struct device *dev, void *fh, uint32_t codec,
+		       uint32_t size, void *buf, uint32_t *width,
+		       uint32_t *height, uint32_t *ddr_width,
+		       uint32_t *ddr_height, uint32_t *min_reqbuf,
+		       uint32_t *bit_depth);
+int ve2rpc_enable_drop_cnt(struct ve2rpc *hndl);
+int ve2rpc_reset_msg_ring_rwptr(struct ve2rpc *cap_hndl);
+int ve2rpc_reset_bs_ring_rwptr(struct ve2rpc *out_hndl);
+void __maybe_unused dump_buflock(struct ve2rpc *cap_hndl);
+
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve2rpc_cmd.h
@@ -0,0 +1,581 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#ifndef __VE2RPC_CMD_H__
+#define __VE2RPC_CMD_H__
+
+#define RPC_VIDEO 0x1
+#define S_OK 0x10000000
+
+enum buflock_status {
+	E_BUFLOCK_ST_ERROR,
+	E_BUFLOCK_ST_NORMAL, /* initial state, set by ARM, allow VFW to access ve2rpc_flash_frame_info_t */
+	E_BUFLOCK_ST_TOUCH, /* VFW has completed filling ve2rpc_flash_frame_info_t, the status is set by VFW */
+	E_BUFLOCK_ST_LOCK, /* ARM start to access ve2rpc_flash_frame_info_t, the status is set by ARM */
+	E_BUFLOCK_ST_UNLOCK,
+	E_BUFLOCK_ST_RELEASE,
+};
+
+enum VIDEO_STREAM_TYPE {
+	VIDEO_STREAM_MPEG1 = 0,
+	VIDEO_STREAM_MPEG2 = 1,
+	VIDEO_STREAM_MPEG4 = 2,
+	VIDEO_STREAM_DV3 = 3,
+	VIDEO_STREAM_H263 = 4,
+	VIDEO_STREAM_H264 = 5,
+	VIDEO_STREAM_VC1 = 6,
+	VIDEO_STREAM_REALVIDEO = 7,
+	VIDEO_STREAM_MJPEG = 8,
+	VIDEO_STREAM_VP6 = 9,
+	VIDEO_STREAM_AVS = 10,
+	VIDEO_STREAM_YUV = 11,
+	VIDEO_STREAM_VP8 = 12,
+	VIDEO_STREAM_WMV7 = 13,
+	VIDEO_STREAM_WMV8 = 14,
+	VIDEO_STREAM_RAW = 15,
+	VIDEO_STREAM_THEORA = 16,
+	VIDEO_STREAM_UNKNOWN = 17,
+	VIDEO_STREAM_FJPEG = 18,
+	VIDEO_STREAM_H265 = 19,
+	VIDEO_STREAM_VP9 = 20,
+	VIDEO_STREAM_H264lv51 = 21,
+	VIDEO_STREAM_AVS2 = 22,
+	VIDEO_STREAM_AV1 = 23,
+};
+typedef enum VIDEO_STREAM_TYPE VIDEO_STREAM_TYPE;
+
+#define VIDEO_RPC_COMMON_ToAgent_Create 10
+#define VIDEO_RPC_COMMON_ToAgent_Connect 20
+#define VIDEO_RPC_COMMON_ToAgent_InitRingBuffer 30
+#define VIDEO_RPC_COMMON_ToAgent_Run 40
+#define VIDEO_RPC_COMMON_ToAgent_Pause 50
+#define VIDEO_RPC_COMMON_ToAgent_Stop 60
+#define VIDEO_RPC_COMMON_ToAgent_Destroy 70
+#define VIDEO_RPC_COMMON_ToAgent_Flush 80
+#define VIDEO_RPC_COMMON_ToAgent_SetRefClock 90
+#define VIDEO_RPC_COMMON_ToAgent_VideoCreate 100
+#define VIDEO_RPC_COMMON_ToAgent_VideoConfig 105
+#define VIDEO_RPC_COMMON_ToAgent_VideoMemoryConfig 108
+#define VIDEO_RPC_COMMON_ToAgent_VideoChunkConfig 109
+#define VIDEO_RPC_COMMON_ToAgent_VideoDestroy 110
+#define VIDEO_RPC_COMMON_ToAgent_RequestBuffer 120
+#define VIDEO_RPC_COMMON_ToAgent_ReleaseBuffer 130
+#define VIDEO_RPC_COMMON_ToAgent_ConfigLowDelay 133
+#define VIDEO_RPC_COMMON_ToAgent_SetDebugMemory 140
+#define VIDEO_RPC_COMMON_ToAgent_VCPU_DEBUG_COMMAND 141
+#define VIDEO_RPC_COMMON_ToAgent_VideoHalt 150
+#define VIDEO_RPC_COMMON_ToAgent_YUYV2RGB 160
+#define VIDEO_RPC_COMMON_ToAgent_Self_Destroy 170
+#define VIDEO_RPC_ToAgent_SetResourceInfo 550
+#define VIDEO_RPC_DEC_ToAgent_CmprsCtrl 1005
+#define VIDEO_RPC_DEC_ToAgent_DecimateCtrl 1006
+#define VIDEO_RPC_DEC_ToAgent_SetSpeed 1010
+#define VIDEO_RPC_DEC_ToAgent_SetErrorConcealmentLevel 1015
+#define VIDEO_RPC_DEC_ToAgent_Init 1020
+#define VIDEO_RPC_DEC_ToAgent_SetDeblock 1030
+#define VIDEO_RPC_DEC_ToAgent_GetVideoSequenceInfo 1035
+#define VIDEO_RPC_DEC_ToAgent_GetVideoSequenceInfo_New 1036
+#define VIDEO_RPC_DEC_ToAgent_BitstreamValidation 1040
+#define VIDEO_RPC_DEC_ToAgent_ParseResolution 1041
+#define VIDEO_RPC_DEC_ToAgent_Capability 1045
+#define VIDEO_RPC_DEC_ToAgent_SetDecoderCCBypass 1050
+#define VIDEO_RPC_DEC_ToAgent_SetDNR 1060
+#define VIDEO_RPC_DEC_ToAgent_SetRefSyncLimit 1065
+#define VIDEO_RPC_FLASH_ToAgent_SetOutput 1085
+#define VIDEO_RPC_THUMBNAIL_ToAgent_SetVscalerOutputFormat 1070
+#define VIDEO_RPC_THUMBNAIL_ToAgent_SetThreshold 1080
+#define VIDEO_RPC_VOUT_ToAgent_SetV2alpha 3090
+#define VIDEO_RPC_THUMBNAIL_ToAgent_SetStartPictureNumber 1090
+#define VIDEO_RPC_DEC_ToAgent_PrivateInfo 1095
+#define VIDEO_RPC_SUBPIC_DEC_ToAgent_Configure 5040
+#define VIDEO_RPC_SUBPIC_DEC_ToAgent_Page 5050
+#define VIDEO_RPC_JPEG_ToAgent_DEC 6010
+#define VIDEO_RPC_JPEG_ToAgent_DEC_BATCH 6011
+#define VIDEO_RPC_TRANSITION_ToAgent_Start 6020
+#define VIDEO_RPC_MIXER_FILTER_ToAgent_Configure 8010
+#define VIDEO_RPC_MIXER_FILTER_ToAgent_ConfigureWindow 8020
+#define VIDEO_RPC_MIXER_FILTER_ToAgent_SetMasterWindow 8030
+#define VIDEO_RPC_MIXER_ToAgent_PlayOneMotionJpegFrame 8040
+
+typedef enum _tagRingBufferType {
+	RINGBUFFER_STREAM,
+	RINGBUFFER_COMMAND,
+	RINGBUFFER_MESSAGE,
+	RINGBUFFER_VBI,
+	RINGBUFFER_PTS,
+	RINGBUFFER_DTVCC,
+	RINGBUFFER_STREAM1,
+	RINGBUFFER_COMMAND1,
+	RINGBUFFER_MESSAGE1,
+	RINGBUFFER_STREAM_BL,
+	RINGBUFFER_COMMAND_BL,
+	RINGBUFFER_STREAM_EL,
+	RINGBUFFER_COMMAND_EL,
+	RINGBUFFER_STREAM_MD,
+	RINGBUFFER_COMMAND_MD,
+	RINGBUFFER_STREAM_SUBES,
+	RINGBUFFER_COMMAND_SUBIB,
+	RINGBUFFER_FRAME_USER,
+	RINGBUFFER_FAKE
+} RINGBUFFER_TYPE;
+
+/** inband cmd type. I use prefix "VIDEO_DEC_" to label the cmd used in video decoder. */
+typedef enum {
+	INBAND_CMD_TYPE_PTS = 0,
+	INBAND_CMD_TYPE_PTS_SKIP,
+	INBAND_CMD_TYPE_NEW_SEG,
+	INBAND_CMD_TYPE_SEQ_END,
+	INBAND_CMD_TYPE_EOS,
+	INBAND_CMD_TYPE_CONTEXT,
+	INBAND_CMD_TYPE_DECODE,
+
+	/* Video Decoder In-band Command */
+	VIDEO_DEC_INBAND_CMD_TYPE_VOBU,
+	VIDEO_DEC_INBAND_CMD_TYPE_DVDVR_DCI_CCI,
+	VIDEO_DEC_INBAND_CMD_TYPE_DVDV_VATR,
+
+	/* MSG Type for parse mode */
+	VIDEO_DEC_INBAND_CMD_TYPE_SEG_INFO,
+	VIDEO_DEC_INBAND_CMD_TYPE_PIC_INFO,
+
+	/* Sub-picture Decoder In-band Command */
+	VIDEO_SUBP_INBAND_CMD_TYPE_SET_PALETTE,
+	VIDEO_SUBP_INBAND_CMD_TYPE_SET_HIGHLIGHT,
+
+	/* Video Mixer In-band Command */
+	VIDEO_MIXER_INBAND_CMD_TYPE_SET_BG_COLOR,
+	VIDEO_MIXER_INBAND_CMD_TYPE_SET_MIXER_RPTS,
+	VIDEO_MIXER_INBAND_CMD_TYPE_BLEND,
+
+	/* Video Scaler In-band Command */
+	VIDEO_SCALER_INBAND_CMD_TYPE_OUTPUT_FMT,
+
+	/*Dv3 resolution In-band Command*/
+	VIDEO_DV3_INBAND_CMD_TYPE_RESOLUTION,
+
+	/*MPEG4 detected In-band command*/
+	VIDEO_MPEG4_INBAND_CMD_TYPE_MP4,
+	/* Audio In-band Commands Start Here */
+
+	/* DV In-band Commands */
+	VIDEO_DV_INBAND_CMD_TYPE_VAUX,
+	VIDEO_DV_INBAND_CMD_TYPE_FF, //fast forward
+
+	/* Transport Demux In-band command */
+	VIDEO_TRANSPORT_DEMUX_INBAND_CMD_TYPE_PID,
+	VIDEO_TRANSPORT_DEMUX_INBAND_CMD_TYPE_PTS_OFFSET,
+	VIDEO_TRANSPORT_DEMUX_INBAND_CMD_TYPE_PACKET_SIZE,
+
+	/* Real Video In-band command */
+	VIDEO_RV_INBAND_CMD_TYPE_FRAME_INFO,
+	VIDEO_RV_INBAND_CMD_TYPE_FORMAT_INFO,
+	VIDEO_RV_INBAND_CMD_TYPE_SEGMENT_INFO,
+
+	/*VC1 video In-band command*/
+	VIDEO_VC1_INBAND_CMD_TYPE_SEQ_INFO,
+
+	/* general video properties */
+	VIDEO_INBAND_CMD_TYPE_VIDEO_USABILITY_INFO,
+	VIDEO_INBAND_CMD_TYPE_VIDEO_MPEG4_USABILITY_INFO,
+
+	/*MJPEG resolution In-band Command*/
+	VIDEO_MJPEG_INBAND_CMD_TYPE_RESOLUTION,
+
+	/* picture object for graphic */
+	VIDEO_GRAPHIC_INBAND_CMD_TYPE_PICTURE_OBJECT,
+	VIDEO_GRAPHIC_INBAND_CMD_TYPE_DISPLAY_INFO,
+
+	/* subtitle offset sequence id for 3D video */
+	VIDEO_DEC_INBAND_CMD_TYPE_SUBP_OFFSET_SEQUENCE_ID,
+
+	VIDEO_H264_INBAND_CMD_TYPE_DPBBYPASS,
+
+	/* Clear back frame to black color and send it to VO */
+	VIDEO_FJPEG_INBAND_CMD_TYPE_CLEAR_SCREEN,
+
+	/* each picture info of MJPEG */
+	VIDEO_FJPEG_INBAND_CMD_TYPE_PIC_INFO,
+
+	/*FJPEG resolution In-band Command*/
+	VIDEO_FJPEG_INBAND_CMD_TYPE_RESOLUTION,
+
+	/*VO receive VP_OBJ_PICTURE_TYPE In-band Command*/
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_PIC,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_DVD_SP,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_DVB_SP,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_BD_SP,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_SP_FLUSH,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_SP_RESOLUTION,
+
+	/* VO receive writeback buffers In-band Command */
+	VIDEO_VO_INBAND_CMD_TYPE_WRITEBACK_BUFFER,
+
+	/* for VO debug, VO can dump picture */
+	VIDEO_VO_INBAND_CMD_TYPE_DUMP_PIC,
+	VIDEO_CURSOR_INBAND_CMD_TYPE_PICTURE_OBJECT,
+	VIDEO_CURSOR_INBAND_CMD_TYPE_COORDINATE_OBJECT,
+	VIDEO_TRANSCODE_INBAND_CMD_TYPE_PICTURE_OBJECT,
+	VIDEO_WRITEBACK_INBAND_CMD_TYPE_PICTURE_OBJECT,
+
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_BD_SCALE_RGB_SP,
+
+	// TV code
+	VIDEO_INBAND_CMD_TYPE_DV_CERTIFY,
+
+	/*M_DOMAIN resolution In-band Command*/
+	VIDEO_INBAND_CMD_TYPE_M_DOMAIN_RESOLUTION,
+
+	/* DTV source In-band Command */
+	VIDEO_INBAND_CMD_TYPE_SOURCE_DTV,
+
+	/* Din source copy mode In-band Command */
+	VIDEO_DIN_INBAND_CMD_TYPE_COPY_MODE,
+
+	/* Video Decoder AU In-band command */
+	VIDEO_DEC_INBAND_CMD_TYPE_AU,
+
+	/* Video Decoder parse frame In-band command */
+	VIDEO_DEC_INBAND_CMD_TYPE_PARSE_FRAME_IN,
+	VIDEO_DEC_INBAND_CMD_TYPE_PARSE_FRAME_OUT,
+
+	/* Set video decode mode In-band command */
+	VIDEO_DEC_INBAND_CMD_TYPE_NEW_DECODE_MODE,
+
+	/* Secure buffer protection */
+	VIDEO_INBAND_CMD_TYPE_SECURE_PROTECTION,
+
+	/* Dolby HDR inband command */
+	VIDEO_DEC_INBAND_CMD_TYPE_DV_PROFILE,
+
+	/* VP9 HDR10 In-band command */
+	VIDEO_VP9_INBAND_CMD_TYPE_HDR10_METADATA,
+
+	/* AV1 HDR10 In-band command */
+	VIDEO_AV1_INBAND_CMD_TYPE_HDR10_METADATA,
+
+	/* DvdPlayer tell RVSD video BS ring buffer is full */
+	VIDEO_DEC_INBAND_CMD_TYPE_BS_RINGBUF_FULL,
+
+	/* Frame Boundary In-band command */
+	VIDEO_INBAND_CMD_TYPE_FRAME_BOUNDARY = 100,
+
+	/* VO receive npp writeback buffers In-band Command */
+	VIDEO_NPP_INBAND_CMD_TYPE_WRITEBACK_BUFFER,
+	VIDEO_NPP_OUT_INBAND_CMD_TYPE_OBJ_PIC,
+
+	/* hevc encoder raw yuv data In-band Commnad */
+	VENC_INBAND_CMD_TYPE_RAWYUV,
+
+	/* hevc encoder ref yuv addr In-band Commnad */
+	VENC_INBAND_CMD_TYPE_REFYUV,
+
+	/* add frame info for user allocate */
+	VIDEO_FRAME_INBAND_ADD,
+
+	/* delete frame info for user allocate */
+	VIDEO_FRAME_INBAND_DELETE,
+} INBAND_CMD_TYPE;
+
+enum VIDEO_VF_TYPE {
+	VF_TYPE_VIDEO_MPEG2_DECODER = 0,
+	VF_TYPE_VIDEO_MPEG4_DECODER = 1,
+	VF_TYPE_VIDEO_DV_DECODER = 2,
+	VF_TYPE_VIDEO_H263_DECODER = 3,
+	VF_TYPE_VIDEO_H264_DECODER = 4,
+	VF_TYPE_VIDEO_VC1_DECODER = 5,
+	VF_TYPE_VIDEO_REAL_DECODER = 6,
+	VF_TYPE_VIDEO_JPEG_DECODER = 7,
+	VF_TYPE_VIDEO_MJPEG_DECODER = 8,
+	VF_TYPE_SPU_DECODER = 9,
+	VF_TYPE_VIDEO_OUT = 10,
+	VF_TYPE_TRANSITION = 11,
+	VF_TYPE_THUMBNAIL = 12,
+	VF_TYPE_VIDEO_VP6_DECODER = 13,
+	VF_TYPE_VIDEO_IMAGE_DECODER = 14,
+	VF_TYPE_FLASH = 15,
+	VF_TYPE_VIDEO_AVS_DECODER = 16,
+	VF_TYPE_MIXER = 17,
+	VF_TYPE_VIDEO_VP8_DECODER = 18,
+	VF_TYPE_VIDEO_WMV7_DECODER = 19,
+	VF_TYPE_VIDEO_WMV8_DECODER = 20,
+	VF_TYPE_VIDEO_RAW_DECODER = 21,
+	VF_TYPE_VIDEO_THEORA_DECODER = 22,
+	VF_TYPE_VIDEO_FJPEG_DECODER = 23,
+	VF_TYPE_VIDEO_H265_DECODER = 24,
+	VF_TYPE_VIDEO_VP9_DECODER = 25,
+	VF_TYPE_VIDEO_H264lv51_DECODER = 26,
+	VF_TYPE_VIDEO_CAPTURER = 27,
+	VF_TYPE_RAWCONV = 28,
+	VF_TYPE_TVD = 29,
+	VF_TYPE_VIDEO_ENCODER = 30,
+	VF_TYPE_VIDEO_SPLITTER = 31,
+	VF_TYPE_VIDEO_AVS2_DECODER = 32,
+	VF_TYPE_VIDEO_AV1_DECODER = 33,
+};
+typedef enum VIDEO_VF_TYPE VIDEO_VF_TYPE;
+
+typedef enum {
+	NORMAL_DECODE = 0,
+	I_ONLY_DECODE,
+	FASTFR_DECODE,
+	RESERVED1,
+	TS_NORMAL_DECODE,
+	TS_I_ONLY_DECODE,
+	TS_FASTFR_DECODE,
+	RESERVED2,
+	BITSTREAM_PARSING,
+	TRANSCODE_PARSING,
+	NORMAL_DECODE_MVC,
+	//TV code
+	NORMAL_I_ONLY_DECODE,
+	IP_ONLY_DECODE,
+	VDEC_DIRECT_DECODE = 16,
+	DRIP_I_ONLY_DECODE = 17,
+	NORMAL_DECODE_LOWDELAY = 18,
+	NO_REF_SYNC_DECODE = 32
+} DECODE_MODE;
+
+typedef struct {
+	INBAND_CMD_TYPE type;
+	unsigned int size;
+} INBAND_CMD_PKT_HEADER;
+
+typedef struct {
+	INBAND_CMD_PKT_HEADER header;
+	unsigned int wPtr;
+} NEW_SEG;
+
+typedef struct {
+	INBAND_CMD_PKT_HEADER header;
+	unsigned int RelativePTSH;
+	unsigned int RelativePTSL;
+	unsigned int PTSDurationH;
+	unsigned int PTSDurationL;
+	unsigned int skip_GOP;
+	DECODE_MODE mode;
+	unsigned int isHM91; /* for HEVC codec version 1: HM91 0: HM10+*/
+	unsigned int useAbsolutePTS; /* 0: relative PTS, 1: absolute PTS */
+} DECODE_NEW;
+
+typedef struct {
+	INBAND_CMD_PKT_HEADER header;
+	unsigned int wPtr;
+	unsigned int PTSH;
+	unsigned int PTSL;
+	unsigned int PTSH2;
+	unsigned int PTSL2;
+	unsigned int length;
+	unsigned int flag;
+} PTS_INFO2;
+
+typedef struct {
+	INBAND_CMD_PKT_HEADER header;
+	unsigned int lu_addr;
+	unsigned int ch_addr;
+	unsigned int decimate_lu_addr;
+	unsigned int decimate_ch_addr;
+	unsigned int cmprs_hdr_lu;
+	unsigned int cmprs_hdr_ch;
+	unsigned int width;
+	unsigned int height;
+	unsigned int decimate_width;
+	unsigned int decimate_height;
+	unsigned int ddr_width;
+	unsigned int ddr_height;
+	unsigned int cmprs_hdr_size;
+	unsigned int cmprs_en;
+	unsigned int lossy_en;
+	unsigned int lossy_ratio;
+	unsigned int bit_depth;
+	unsigned int decimate_en;
+	unsigned int decimate_ratio;
+} FRAME_INFO_IN;
+
+typedef struct {
+	INBAND_CMD_PKT_HEADER header;
+	unsigned int lu_addr;
+} FRAME_INFO_OUT;
+
+/**
+	\brief Mark a EOS on an address.
+		This is the last inband command of a segment and is mandatary.
+	\param wPtr
+*/
+typedef struct {
+	INBAND_CMD_PKT_HEADER header;
+	unsigned int wPtr;
+	unsigned int eventID;
+} EOS;
+
+typedef struct RPCRES_LONG {
+	uint32_t result;
+	uint32_t data;
+} RPCRES_LONG;
+
+struct RPC_RINGBUFFER {
+	unsigned int instanceID;
+	unsigned int pinID;
+	unsigned int readPtrIndex;
+	unsigned int pRINGBUFF_HEADER;
+};
+typedef struct RPC_RINGBUFFER RPC_RINGBUFFER;
+
+struct VIDEO_RPC_INSTANCE {
+	enum VIDEO_VF_TYPE type;
+};
+typedef struct VIDEO_RPC_INSTANCE VIDEO_RPC_INSTANCE;
+
+struct RPC_CONNECTION {
+	unsigned int srcInstanceID;
+	unsigned int srcPinID;
+	unsigned int desInstanceID;
+	unsigned int desPinID;
+	unsigned int mediaType;
+};
+typedef struct RPC_CONNECTION RPC_CONNECTION;
+
+struct VIDEO_RPC_DEC_SET_SPEED {
+	uint32_t instanceID;
+	uint32_t displaySpeed;
+	uint32_t decodeSkip;
+};
+typedef struct VIDEO_RPC_DEC_SET_SPEED VIDEO_RPC_DEC_SET_SPEED;
+
+struct VIDEO_RPC_DEC_INIT {
+	uint32_t instanceID;
+	VIDEO_STREAM_TYPE type;
+	struct VIDEO_RPC_DEC_SET_SPEED set_speed;
+};
+typedef struct VIDEO_RPC_DEC_INIT VIDEO_RPC_DEC_INIT;
+typedef struct RPC_STRUCT RPC_STRUCT;
+struct RPC_STRUCT {
+	uint32_t programID; // program ID defined in IDL file
+	uint32_t versionID; // version ID defined in IDL file
+	uint32_t procedureID; // function ID defined in IDL file
+	uint32_t taskID; // the caller's task ID, assign 0 if NONBLOCK_MODE
+	uint32_t sysTID;
+	uint32_t sysPID; // the callee's task ID
+	uint32_t parameterSize; // packet's body size
+	uint32_t context; // return address of reply value
+};
+;
+struct VIDEO_RPC_VOUT_MESSAGE {
+	uint32_t instanceID;
+	uint32_t message;
+	uint32_t PTShigh;
+	uint32_t PTSlow;
+	uint32_t reserved1;
+	uint32_t reserved2;
+	uint32_t reserved3;
+	uint32_t reserved4;
+};
+typedef struct VIDEO_RPC_VOUT_MESSAGE VIDEO_RPC_VOUT_MESSAGE;
+struct VIDEO_RPC_DEC_MEDIA_INFO {
+	uint32_t instanceID;
+	uint32_t width;
+	uint32_t height;
+	uint32_t frame_rate;
+	uint32_t aspect_ratio_n;
+	uint32_t aspect_ratio_d;
+	uint32_t level;
+	uint32_t profile;
+	uint32_t type_3D;
+	uint32_t par_width;
+	uint32_t par_height;
+	uint32_t type_LR;
+	uint32_t type_Scan;
+	uint32_t afd;
+};
+typedef struct VIDEO_RPC_DEC_MEDIA_INFO VIDEO_RPC_DEC_MEDIA_INFO;
+struct VIDEO_RPC_DEC_ERROR_INFO {
+	uint32_t instanceID;
+	uint32_t errCode;
+};
+typedef struct VIDEO_RPC_DEC_ERROR_INFO VIDEO_RPC_DEC_ERROR_INFO;
+
+enum VIDEO_DECODER_CC_BYPASS_MODE {
+	VIDEODECODER_CC_DROP = 0,
+	VIDEODECODER_CC_BYPASS = 1,
+	VIDEODECODER_CC_DECODE = 2,
+	VIDEODECODER_CC_CALLBACK = 3,
+};
+
+struct VIDEO_RPC_DEC_CC_BYPASS_MODE {
+	uint32_t instanceID;
+	enum VIDEO_DECODER_CC_BYPASS_MODE cc_mode;
+};
+typedef struct VIDEO_RPC_DEC_CC_BYPASS_MODE VIDEO_RPC_DEC_CC_BYPASS_MODE;
+
+enum CMPRS_RATIO {
+	CMPRS_RATIO_50 = 0,
+	CMPRS_RATIO_75 = 1,
+};
+typedef enum CMPRS_RATIO CMPRS_RATIO;
+
+struct VIDEO_RPC_DEC_CMPRS_CTRL {
+	uint32_t instanceID;
+	uint8_t mode;
+	enum CMPRS_RATIO ratio;
+	uint8_t enable;
+};
+typedef struct VIDEO_RPC_DEC_CMPRS_CTRL VIDEO_RPC_DEC_CMPRS_CTRL;
+
+struct VIDEO_RPC_DEC_BITSTREAM_BUFFER {
+	uint32_t bsBase;
+	uint32_t bsSize;
+	enum VIDEO_VF_TYPE type;
+};
+typedef struct VIDEO_RPC_DEC_BITSTREAM_BUFFER VIDEO_RPC_DEC_BITSTREAM_BUFFER;
+
+struct VIDEO_RPC_DEC_BV_RESULT {
+	uint32_t bitRate;
+	uint32_t type;
+};
+typedef struct VIDEO_RPC_DEC_BV_RESULT VIDEO_RPC_DEC_BV_RESULT;
+
+struct VIDEO_RPC_DEC_PV_RESULT {
+	uint32_t width;
+	uint32_t height;
+	uint32_t bit_depth;
+	uint32_t DPB_size;
+};
+typedef struct VIDEO_RPC_DEC_PV_RESULT VIDEO_RPC_DEC_PV_RESULT;
+
+enum VIDEO_RESOURCE_CORE_TYPE {
+        VIDEO_RESOURCE_CORE_REALTEK = 0,
+        VIDEO_RESOURCE_CORE_GOOGLE = 0 + 1,
+        VIDEO_RESOURCE_CORE_IP1 = 0 + 2,
+        VIDEO_RESOURCE_CORE_IP2 = 0 + 3,
+        VIDEO_RESOURCE_CORE_DUAL = 0 + 4,
+};
+typedef enum VIDEO_RESOURCE_CORE_TYPE VIDEO_RESOURCE_CORE_TYPE;
+
+struct VIDEO_RPC_RESOURCE_INFO {
+	int32_t resource_ctrl_sets;
+	enum VIDEO_RESOURCE_CORE_TYPE core_type;
+	int32_t video_port;
+	int32_t max_width;
+	int32_t max_height;
+	uint32_t instanceID;
+	int32_t width;
+	int32_t height;
+	int32_t framerate;
+	int32_t second_resource_ctrl_sets;
+};
+typedef struct VIDEO_RPC_RESOURCE_INFO VIDEO_RPC_RESOURCE_INFO;
+
+typedef int HRESULT;
+#define VIDEO_RPC_DEC_ToSystem_FatalError 63
+#define VIDEO_RPC_DEC_ToSystem_Deliver_MediaInfo 1020
+#define VIDEO_RPC_ToSystem_VoutMessage 1021
+#define REPLYID 99 // for registering the Reply_Handler
+#endif
\ No newline at end of file
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/ve_common.h
@@ -0,0 +1,189 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ */
+#ifndef __VE_COMMON_H__
+#define __VE_COMMON_H__
+
+enum PICTURE_MODE {
+	INTERLEAVED_TOP_FIELD = 0,  /* top	field data stored in even lines of a frame buffer */
+	INTERLEAVED_BOT_FIELD,	  /* bottom field data stored in odd  lines of a frame buffer */
+	CONSECUTIVE_TOP_FIELD,	  /* top	field data stored consecutlively in all lines of a field buffer */
+	CONSECUTIVE_BOT_FIELD,	  /* bottom field data stored consecutlively in all lines of a field buffer */
+	CONSECUTIVE_FRAME,		   /* progressive frame data stored consecutlively in all lines of a frame buffer */
+	INTERLEAVED_TOP_FIELD_422,  /* top	field data stored in even lines of a frame buffer */
+	INTERLEAVED_BOT_FIELD_422,	  /* bottom field data stored in odd  lines of a frame buffer */
+	CONSECUTIVE_TOP_FIELD_422,	  /* top	field data stored consecutlively in all lines of a field buffer */
+	CONSECUTIVE_BOT_FIELD_422,	  /* bottom field data stored consecutlively in all lines of a field buffer */
+	CONSECUTIVE_FRAME_422,		/* progressive frame with 4:2:2 chroma */
+	TOP_BOTTOM_FRAME,			/* top field in the 0~height/2-1, bottom field in the height/2~height-1 in the frame */
+	INTERLEAVED_TOP_BOT_FIELD,   /* one frame buffer contains one top and one bot field, top field first */
+	INTERLEAVED_BOT_TOP_FIELD,   /* one frame buffer contains one bot and one top field, bot field first */
+
+	MPEG2_PIC_MODE_NOT_PROG	  /*yllin: for MPEG2 check pic mode usage */
+};
+
+struct yuv_state {
+	unsigned int version;
+	unsigned int mode;
+	unsigned int Y_addr;
+	unsigned int U_addr;
+	unsigned int pLock;
+	unsigned int width;
+	unsigned int height;
+	unsigned int Y_pitch;
+	unsigned int C_pitch;
+	unsigned int RPTSH;
+	unsigned int RPTSL;
+	unsigned int PTSH;
+	unsigned int PTSL;
+
+	/* for send two interlaced fields in the same packet,
+    valid only when mode is INTERLEAVED_TOP_BOT_FIELD or INTERLEAVED_BOT_TOP_FIELD*/
+	unsigned int RPTSH2;
+	unsigned int RPTSL2;
+	unsigned int PTSH2;
+	unsigned int PTSL2;
+
+	unsigned int context;
+	unsigned int pRefClock; /* not used now */
+
+	unsigned int pixelAR_hor; /* pixel aspect ratio hor, not used now */
+	unsigned int pixelAR_ver; /* pixel aspect ratio ver, not used now */
+
+	unsigned int Y_addr_Right; /* for mvc */
+	unsigned int U_addr_Right; /* for mvc */
+	unsigned int pLock_Right; /* for mvc */
+	unsigned int mvc; /* 1: mvc */
+	unsigned int
+		subPicOffset; /* 3D Blu-ray dependent-view sub-picture plane offset metadata as defined in BD spec sec. 9.3.3.6.
+    				Valid only when Y_BufId_Right and C_BufId_Right are both valid */
+	unsigned int pReceived; // fix bug 44329 by version 0x72746B30 'rtk0'
+	unsigned int
+		pReceived_Right; // fix bug 44329 by version 0x72746B30 'rtk0'
+
+	unsigned int fps; // 'rtk1'
+
+	unsigned int
+		IsForceDIBobMode; // force vo use bob mode to do deinterlace, 'rtk2'.
+	unsigned int lumaOffTblAddr; // 'rtk3'
+	unsigned int chromaOffTblAddr; // 'rtk3'
+	unsigned int lumaOffTblAddrR; // for mvc, 'rtk3'
+	unsigned int chromaOffTblAddrR; // for mvc, 'rtk3'
+
+	unsigned int bufBitDepth; // 'rtk3'
+	unsigned int
+		bufFormat; // 'rtk3', according to VO spec: 10bits Pixel Packing mode selection,
+		// "0": use 2 bytes to store 1 components. MSB justified.
+		// "1": use 4 bytes to store 3 components. LSB justified.
+
+	// VUI (Video Usability Information)
+	unsigned int transferCharacteristics; // 0:SDR, 1:HDR, 2:ST2084, 'rtk3'
+	// Mastering display colour volume SEI, 'rtk3'
+	unsigned int display_primaries_x0;
+	unsigned int display_primaries_y0;
+	unsigned int display_primaries_x1;
+	unsigned int display_primaries_y1;
+	unsigned int display_primaries_x2;
+	unsigned int display_primaries_y2;
+	unsigned int white_point_x;
+	unsigned int white_point_y;
+	unsigned int max_display_mastering_luminance;
+	unsigned int min_display_mastering_luminance;
+
+	// for transcode interlaced feild use.	//'rtk4'
+	unsigned int Y_addr_prev; //'rtk4'
+	unsigned int U_addr_prev; //'rtk4'
+	unsigned int Y_addr_next; //'rtk4'
+	unsigned int U_addr_next; //'rtk4'
+	unsigned int video_full_range_flag; //'rtk4' default= 1
+	unsigned int matrix_coefficients; //'rtk4' default= 1
+
+	// for transcode interlaced feild use.	//'rtk5'
+	unsigned int pLock_prev;
+	unsigned int pReceived_prev;
+	unsigned int pLock_next;
+	unsigned int pReceived_next;
+
+	unsigned int is_tch_video; //'rtk6'
+	unsigned int tch_hdr_metadata[144]; //'rtk6'
+
+	unsigned int pFrameBufferDbg; //'rtk7'
+	unsigned int pFrameBufferDbg_Right;
+	unsigned int Y_addr_EL; //'rtk8' for dolby vision
+	unsigned int U_addr_EL;
+	unsigned int width_EL;
+	unsigned int height_EL;
+	unsigned int Y_pitch_EL;
+	unsigned int C_pitch_EL;
+	unsigned int lumaOffTblAddr_EL;
+	unsigned int chromaOffTblAddr_EL;
+
+	unsigned int dm_reg1_addr;
+	unsigned int dm_reg1_size;
+	unsigned int dm_reg2_addr;
+	unsigned int dm_reg2_size;
+	unsigned int dm_reg3_addr;
+	unsigned int dm_reg3_size;
+	unsigned int dv_lut1_addr;
+	unsigned int dv_lut1_size;
+	unsigned int dv_lut2_addr;
+	unsigned int dv_lut2_size;
+
+	unsigned int slice_height; //'rtk8'
+
+	unsigned int hdr_metadata_addr; //'rtk9'
+	unsigned int hdr_metadata_size; //'rtk9'
+	unsigned int tch_metadata_addr; //'rtk9'
+	unsigned int tch_metadata_size; //'rtk9'
+	unsigned int is_dolby_video; //'rtk10'
+
+	unsigned int lumaOffTblSize; //'rtk11'
+	unsigned int chromaOffTblSize; //'rtk11'
+	// 'rtk12'
+	unsigned int Combine_Y_Addr;
+	unsigned int Combine_U_Addr;
+	unsigned int Combine_Width;
+	unsigned int Combine_Height;
+	unsigned int Combine_Y_Pitch;
+	unsigned int secure_flag;
+
+	// 'rtk13'
+	unsigned int tvve_picture_width;
+	unsigned int tvve_lossy_en;
+	unsigned int tvve_bypass_en;
+	unsigned int tvve_qlevel_sel_y;
+	unsigned int tvve_qlevel_sel_c;
+	unsigned int is_ve_tile_mode;
+	unsigned int film_grain_metadat_addr;
+	unsigned int film_grain_metadat_size;
+
+	// 'rtk14'
+	unsigned int partialSrcWin_x; //rtk14 0x72746B3E
+	unsigned int partialSrcWin_y;
+	unsigned int partialSrcWin_w;
+	unsigned int partialSrcWin_h;
+
+	// 'rtk15'
+	unsigned int dolby_out_hdr_metadata_addr; //rtk 15 0x72746B3F
+	unsigned int dolby_out_hdr_metadata_size;
+};
+
+/* simplified structure for capture buffer */
+struct ve_frame_info {
+	unsigned int rtk_meta_buf_id;
+	unsigned int is_ve1_buf;
+
+	struct yuv_state yuvs;
+
+	// priviate data
+	unsigned int hdr_type;
+};
+
+#endif
+
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/video_engine.h
@@ -0,0 +1,17 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ */
+#ifndef __VIDEO_ENGINE_H__
+#define __VIDEO_ENGINE_H__
+
+#define VIDEO_ENGINE_1 1
+#define VIDEO_ENGINE_2 2
+#define VIDEO_ENGINE_3 3
+#define VIDEO_OUTPUT_1 4
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/vpu.c
@@ -0,0 +1,1841 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h> // for threads
+#include <linux/time.h> // for using jiffies
+#include <media/v4l2-mem2mem.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
+#include <media/videobuf2-vmalloc.h>
+#include <media/videobuf2-dma-contig.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include "drv_if.h"
+#include "debug.h"
+#include "vpu.h"
+
+struct veng_ops *vpu_ve1_ops = NULL;
+struct veng_ops *vpu_ve2_ops = NULL;
+
+//#define RTKVPU_DUMP_OUTBUF_EN
+#if defined(RTKVPU_DUMP_OUTBUF_EN)
+static int gOutbufDumpSerial = 0;
+#endif
+
+//#define RTKVPU_DUMP_CAPBUF_EN
+#if defined(RTKVPU_DUMP_CAPBUF_EN)
+static int gCapbufDumpSerial = 0;
+static int gCapbufDumpMaxNum = 0;
+#endif
+
+#define RTK_DPB_WIDTH_ALIGN 32
+#define RTK_DPB_HEIGHT_ALIGN 32
+#define RTK_VE2_WIDTH_ALIGN 128
+#define RTK_VE2_HEIGHT_ALIGN 128
+
+#define RTK_VPU_DEC_4K_CODED_MAX_WIDTH 4096
+#define RTK_VPU_DEC_4K_CODED_MAX_HEIGHT 4096
+//4K max resolution : 4096x2304=9437184
+#define RTK_VPU_DEC_4K_CODED_MAX_RESOLUTION 9437184
+#define RTK_VPU_DEC_2K_CODED_MAX_WIDTH 1920
+#define RTK_VPU_DEC_2K_CODED_MAX_HEIGHT 1920
+//2K max resolution : 1920x1088=2088960
+#define RTK_VPU_DEC_2K_CODED_MAX_RESOLUTION 2088960
+
+#define RTK_VE1_DEC_4K_CODED_MAX_WIDTH 4096
+#define RTK_VE1_DEC_4K_CODED_MAX_HEIGHT 3024
+//4K max resolution : 4096x3024=12386304
+#define RTK_VE1_DEC_4K_CODED_MAX_RESOLUTION 12386304
+
+void vpu_cap_buf_done(struct v4l2_fh *fh, struct vb2_v4l2_buffer *buf, bool eos,
+		      enum vb2_buffer_state state);
+
+const static struct vpu_fmt out_fmt[] = {
+	/* video engine VE1 output format */
+	{
+		/* struct v4l2_pix_format */
+		.spec.fmt.pix_mp.width = 1920,
+		.spec.fmt.pix_mp.height = 1088,
+		.spec.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H264,
+		.spec.fmt.pix_mp.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix_mp.plane_fmt[0].bytesperline = 0,
+		.spec.fmt.pix_mp.plane_fmt[0].sizeimage = 4 * 1024 * 1024, // FIXME: 1024*1024
+		.spec.fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix_mp.num_planes = 1,
+		.spec.fmt.pix_mp.flags = 0,
+		.spec.fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		/* enum v4l2_buf_type */
+		.spec.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VE1_DEC_4K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VE1_DEC_4K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 4,
+		.misc.max_resolution = RTK_VE1_DEC_4K_CODED_MAX_RESOLUTION,
+		.misc.VideoEngine = VIDEO_ENGINE_1,
+	},
+	{
+		.spec.fmt.pix_mp.width = 1920,
+		.spec.fmt.pix_mp.height = 1088,
+		.spec.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H263,
+		.spec.fmt.pix_mp.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix_mp.plane_fmt[0].bytesperline = 0,
+		.spec.fmt.pix_mp.plane_fmt[0].sizeimage = 3 * 1024 * 1024, // FIXME: 1024*1024
+		.spec.fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix_mp.num_planes = 1,
+		.spec.fmt.pix_mp.flags = 0,
+		.spec.fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		.spec.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VPU_DEC_2K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VPU_DEC_2K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 4,
+		.misc.max_resolution = RTK_VPU_DEC_2K_CODED_MAX_RESOLUTION,
+		.misc.VideoEngine = VIDEO_ENGINE_1,
+	},
+	{
+		.spec.fmt.pix_mp.width = 1920,
+		.spec.fmt.pix_mp.height = 1088,
+		.spec.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG1,
+		.spec.fmt.pix_mp.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix_mp.plane_fmt[0].bytesperline = 0,
+		.spec.fmt.pix_mp.plane_fmt[0].sizeimage = 3 * 1024 * 1024, // FIXME: 1024*1024
+		.spec.fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix_mp.num_planes = 1,
+		.spec.fmt.pix_mp.flags = 0,
+		.spec.fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		.spec.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VPU_DEC_2K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VPU_DEC_2K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 4,
+		.misc.max_resolution = RTK_VPU_DEC_2K_CODED_MAX_RESOLUTION,
+		.misc.VideoEngine = VIDEO_ENGINE_1,
+	},
+	{
+		.spec.fmt.pix_mp.width = 1920,
+		.spec.fmt.pix_mp.height = 1088,
+		.spec.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG2,
+		.spec.fmt.pix_mp.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix_mp.plane_fmt[0].bytesperline = 0,
+		.spec.fmt.pix_mp.plane_fmt[0].sizeimage = 3 * 1024 * 1024, // FIXME: 1024*1024
+		.spec.fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix_mp.num_planes = 1,
+		.spec.fmt.pix_mp.flags = 0,
+		.spec.fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		.spec.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VPU_DEC_2K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VPU_DEC_2K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 4,
+		.misc.max_resolution = RTK_VPU_DEC_2K_CODED_MAX_RESOLUTION,
+		.misc.VideoEngine = VIDEO_ENGINE_1,
+	},
+	{
+		.spec.fmt.pix_mp.width = 1920,
+		.spec.fmt.pix_mp.height = 1088,
+		.spec.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG4,
+		.spec.fmt.pix_mp.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix_mp.plane_fmt[0].bytesperline = 0,
+		.spec.fmt.pix_mp.plane_fmt[0].sizeimage = 3 * 1024 * 1024, // FIXME: 1024*1024
+		.spec.fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix_mp.num_planes = 1,
+		.spec.fmt.pix_mp.flags = 0,
+		.spec.fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		.spec.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VPU_DEC_2K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VPU_DEC_2K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 4,
+		.misc.max_resolution = RTK_VPU_DEC_2K_CODED_MAX_RESOLUTION,
+		.misc.VideoEngine = VIDEO_ENGINE_1,
+	},
+	{
+		.spec.fmt.pix_mp.width = 1920,
+		.spec.fmt.pix_mp.height = 1088,
+		.spec.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_VP8,
+		.spec.fmt.pix_mp.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix_mp.plane_fmt[0].bytesperline = 0,
+		.spec.fmt.pix_mp.plane_fmt[0].sizeimage = 3 * 1024 * 1024, // FIXME: 1024*1024
+		.spec.fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix_mp.num_planes = 1,
+		.spec.fmt.pix_mp.flags = 0,
+		.spec.fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		.spec.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VPU_DEC_2K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VPU_DEC_2K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 4,
+		.misc.max_resolution = RTK_VPU_DEC_2K_CODED_MAX_RESOLUTION,
+		.misc.VideoEngine = VIDEO_ENGINE_1,
+	},
+	{
+		.spec.fmt.pix_mp.width = 1920,
+		.spec.fmt.pix_mp.height = 1088,
+		.spec.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_VC1_ANNEX_G,
+		.spec.fmt.pix_mp.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix_mp.plane_fmt[0].bytesperline = 0,
+		.spec.fmt.pix_mp.plane_fmt[0].sizeimage = 3 * 1024 * 1024, // FIXME: 1024*1024
+		.spec.fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix_mp.num_planes = 1,
+		.spec.fmt.pix_mp.flags = 0,
+		.spec.fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		.spec.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VPU_DEC_2K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VPU_DEC_2K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 4,
+		.misc.max_resolution = RTK_VPU_DEC_2K_CODED_MAX_RESOLUTION,
+		.misc.VideoEngine = VIDEO_ENGINE_1,
+	},
+	{
+		.spec.fmt.pix_mp.width = 1920,
+		.spec.fmt.pix_mp.height = 1088,
+		.spec.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_VC1_ANNEX_L,
+		.spec.fmt.pix_mp.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix_mp.plane_fmt[0].bytesperline = 0,
+		.spec.fmt.pix_mp.plane_fmt[0].sizeimage = 3 * 1024 * 1024, // FIXME: 1024*1024
+		.spec.fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix_mp.num_planes = 1,
+		.spec.fmt.pix_mp.flags = 0,
+		.spec.fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		.spec.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VPU_DEC_2K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VPU_DEC_2K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 4,
+		.misc.max_resolution = RTK_VPU_DEC_2K_CODED_MAX_RESOLUTION,
+		.misc.VideoEngine = VIDEO_ENGINE_1,
+	},
+	/* video engine VE2 output format */
+	{
+		/* struct v4l2_pix_format */
+		.spec.fmt.pix_mp.width = 1920,
+		.spec.fmt.pix_mp.height = 1088,
+		.spec.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_HEVC,
+		.spec.fmt.pix_mp.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix_mp.plane_fmt[0].bytesperline = 0,
+		.spec.fmt.pix_mp.plane_fmt[0].sizeimage = 4 * 1024 * 1024,
+		.spec.fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix_mp.num_planes = 1,
+		.spec.fmt.pix_mp.flags = 0,
+		.spec.fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		/* enum v4l2_buf_type */
+		.spec.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VPU_DEC_4K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VPU_DEC_4K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 15,
+		.misc.max_resolution = RTK_VPU_DEC_4K_CODED_MAX_RESOLUTION,
+		.misc.VideoEngine = VIDEO_ENGINE_2,
+	},
+	{
+		.spec.fmt.pix_mp.width = 1920,
+		.spec.fmt.pix_mp.height = 1088,
+		.spec.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_VP9,
+		.spec.fmt.pix_mp.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix_mp.plane_fmt[0].bytesperline = 0,
+		.spec.fmt.pix_mp.plane_fmt[0].sizeimage = 4 * 1024 * 1024,
+		.spec.fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix_mp.num_planes = 1,
+		.spec.fmt.pix_mp.flags = 0,
+		.spec.fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		.spec.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VPU_DEC_4K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VPU_DEC_4K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 10,
+		.misc.max_resolution = RTK_VPU_DEC_4K_CODED_MAX_RESOLUTION,
+		.misc.VideoEngine = VIDEO_ENGINE_2,
+	},
+	{
+		.spec.fmt.pix_mp.width = 1920,
+		.spec.fmt.pix_mp.height = 1088,
+		.spec.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_AV1,
+		.spec.fmt.pix_mp.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix_mp.plane_fmt[0].bytesperline = 0,
+		.spec.fmt.pix_mp.plane_fmt[0].sizeimage = 4 * 1024 * 1024,
+		.spec.fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix_mp.num_planes = 1,
+		.spec.fmt.pix_mp.flags = 0,
+		.spec.fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		.spec.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VPU_DEC_4K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VPU_DEC_4K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 10,
+		.misc.max_resolution = RTK_VPU_DEC_4K_CODED_MAX_RESOLUTION,
+		.misc.VideoEngine = VIDEO_ENGINE_2,
+	},
+};
+
+static const struct vpu_fmt cap_fmt[] = {
+	{
+		.spec.fmt.pix_mp.width = 1920,
+		.spec.fmt.pix_mp.height = 1088,
+		.spec.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12,
+		.spec.fmt.pix_mp.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix_mp.plane_fmt[0].bytesperline = 1920,
+		.spec.fmt.pix_mp.plane_fmt[0].sizeimage = 3133440, // 1920*1088*3/2
+		.spec.fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix_mp.num_planes = 1,
+		.spec.fmt.pix_mp.flags = 0,
+		.spec.fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		.spec.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VPU_DEC_4K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VPU_DEC_4K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 10,
+		.misc.max_resolution = RTK_VPU_DEC_4K_CODED_MAX_RESOLUTION,
+		.misc.VideoEngine = VIDEO_OUTPUT_1,
+	},
+#ifdef ENABLE_GPU_CACHE
+	{
+		.spec.fmt.pix_mp.width = 1920,
+		.spec.fmt.pix_mp.height = 1088,
+		.spec.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_P010,
+		.spec.fmt.pix_mp.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix_mp.plane_fmt[0].bytesperline = 3840,
+		.spec.fmt.pix_mp.plane_fmt[0].sizeimage = 6166880, // 1920*1088*3/2
+		.spec.fmt.pix_mp.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix_mp.num_planes = 1,
+		.spec.fmt.pix_mp.flags = 0,
+		.spec.fmt.pix_mp.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix_mp.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix_mp.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		.spec.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VPU_DEC_4K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VPU_DEC_4K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 10,
+		.misc.max_resolution = RTK_VPU_DEC_4K_CODED_MAX_RESOLUTION,
+		.misc.VideoEngine = VIDEO_OUTPUT_1,
+	},
+#endif
+};
+
+#define OUT_NUM ARRAY_SIZE(out_fmt)
+#define CAP_NUM ARRAY_SIZE(cap_fmt)
+
+/*
+ * Return vpu_ctx structure for a given struct v4l2_fh
+ */
+static struct vpu_ctx *fh_to_vpu(struct v4l2_fh *fh)
+{
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	return vid_ctx->vpu_ctx;
+}
+
+/*
+ * Return vpu_ctx structure for a given struct vb2_queue
+ */
+static struct vpu_ctx *vq_to_vpu(struct vb2_queue *q)
+{
+	struct videc_ctx *vid_ctx = vb2_get_drv_priv(q);
+	return vid_ctx->vpu_ctx;
+}
+
+static int vpu_buf_done(struct v4l2_fh *fh, struct vb2_v4l2_buffer *v4l2_buf,
+			uint64_t timestamp, uint32_t sizeimage, uint32_t sequence,
+			bool eos, bool no_frame)
+{
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+	unsigned long flags;
+	struct vb2_buffer *vb = NULL;
+	dma_addr_t cap_buf_paddr;
+	const struct v4l2_event eos_event = { .type = V4L2_EVENT_EOS };
+
+	v4l2_buf->field = V4L2_FIELD_NONE;
+	v4l2_buf->flags = V4L2_BUF_FLAG_KEYFRAME;
+	v4l2_buf->vb2_buf.timestamp = timestamp;
+	v4l2_buf->sequence = sequence++;
+	mutex_lock(&ctx->vpu_mutex);
+	ctx->seq_cap = sequence;
+	mutex_unlock(&ctx->vpu_mutex);
+
+	spin_lock_irqsave(&ctx->vpu_spin_lock, flags);
+
+	if (eos) {
+		vpu_info("%d.%s.ctx->last_buf_done = true\n", __LINE__,
+			 __func__);
+		if (no_frame) {
+			vb2_set_plane_payload(&v4l2_buf->vb2_buf, 0, 0);
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+			v4l2_buf->vb2_buf.planes[0].data_offset = 0;
+#endif
+		}
+		v4l2_m2m_last_buffer_done(fh->m2m_ctx, v4l2_buf);
+		v4l2_event_queue_fh(fh, &eos_event);
+		ctx->last_buf_done = true;
+	} else {
+		if (ctx->wait_disp_I) {
+			vb = &(v4l2_buf->vb2_buf);
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+			cap_buf_paddr = vb2_dma_contig_plane_dma_addr(vb, 0) + METADATA_OFFSET;
+#else
+			cap_buf_paddr = vb2_dma_contig_plane_dma_addr(vb, 0);
+#endif
+			vpu_info("%d.%s.wait_disp_I.cap_buf_paddr:0x%lx.VB2_BUF_STATE_ERROR\n",
+				__LINE__, __func__,
+				(unsigned long)cap_buf_paddr);
+			v4l2_m2m_buf_done(v4l2_buf, VB2_BUF_STATE_ERROR);
+		}
+		else {
+			v4l2_m2m_buf_done(v4l2_buf, VB2_BUF_STATE_DONE);
+		}
+	}
+
+	spin_unlock_irqrestore(&ctx->vpu_spin_lock, flags);
+	return 0;
+}
+
+static int rtkvpu_dump_capbuf(struct vpu_ctx *ctx, struct vb2_v4l2_buffer *v4l2_buf, uint32_t size)
+{
+#if defined(RTKVPU_DUMP_CAPBUF_EN)
+	struct vb2_buffer *vb2_buf = NULL;
+	void *vb2_virt_addr = NULL;
+	int filp_open_flags;
+	ssize_t bytes = 0;
+	loff_t pos = 0;
+
+	if ((v4l2_buf == NULL) || (size == 0)) {
+		return -1;
+	}
+
+	vb2_buf = &(v4l2_buf->vb2_buf);
+	vb2_virt_addr = vb2_plane_vaddr(vb2_buf, 0);
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+	vpu_info("%d.%s.v4l2_buf:0x%px.METADATA_OFFSET:%d.vb2_virt_addr:0x%px(new_v_addr:0x%px).size:%d\n",__LINE__,__func__,
+			(void *)v4l2_buf,METADATA_OFFSET,vb2_virt_addr,(vb2_virt_addr+METADATA_OFFSET),size);
+	vb2_virt_addr += METADATA_OFFSET;
+#else
+	vpu_info("%d.%s.v4l2_buf:0x%px.vb2_virt_addr:0x%px.size:%d\n",__LINE__,__func__,
+			(void *)v4l2_buf,vb2_virt_addr,size);
+#endif
+
+	if (ctx->bNewCapbufDumpFile == 1) {
+		ctx->bNewCapbufDumpFile = 0;
+		gCapbufDumpMaxNum = 0;
+		filp_open_flags = O_CREAT | O_WRONLY;
+		memset(ctx->capbufDumpFileName, 0, sizeof(unsigned char)*256);
+		snprintf(ctx->capbufDumpFileName, 256,
+				"/mnt/capbuf_%d.yuv",
+				gCapbufDumpSerial);
+		gCapbufDumpSerial++;
+		vpu_info("%d.%s.create new capbuf dump:%s\n",__LINE__,__func__,
+				ctx->capbufDumpFileName);
+	} else {
+		filp_open_flags = O_APPEND | O_WRONLY;
+	}
+	ctx->capbufDumpFile =
+		(void *)filp_open(ctx->capbufDumpFileName, filp_open_flags, 0);
+	if (IS_ERR((struct file *)ctx->capbufDumpFile)) {
+		vpu_err("%d.%s.filp_open %s fail\n",__LINE__,__func__,
+				ctx->capbufDumpFileName);
+	} else {
+		//if (gCapbufDumpMaxNum >= 30) {
+		//	return -1;
+		//}
+		//vpu_info("%d.%s.filp_open %s ok\n",__LINE__,__func__,
+		//		ctx->capbufDumpFileName);
+		bytes =
+			kernel_write((struct file *)(ctx->capbufDumpFile),
+						(void *)vb2_virt_addr, (size_t)size, &pos);
+		//vpu_info("%d.%s.kernel_write bytes:%ld.pos:%lld\n",__LINE__,__func__,
+		//		bytes, pos);
+		filp_close((struct file *)(ctx->capbufDumpFile), NULL);
+		//vpu_info("%d.%s.filp_close %s\n",__LINE__,__func__,
+		//		ctx->capbufDumpFileName);
+		ctx->capbufDumpFile = NULL;
+		gCapbufDumpMaxNum++;
+	}
+	return 0;
+#else
+	return -1;
+#endif
+}
+
+static int threadcap(void *data)
+{
+	struct v4l2_fh *fh = (struct v4l2_fh *)data;
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+	uint32_t sizeimage, sequence;
+	struct vb2_v4l2_buffer *disp_buf = NULL;
+
+	while (1) {
+		int ret;
+		ret = wait_event_interruptible_timeout(
+			ctx->vpu_cap_waitq,
+			kthread_should_stop() ||
+				(ctx->veng_ops->ve_get_undq_dispFrm_cnt(fh)),
+			msecs_to_jiffies(ctx->thread_cap_interval));
+
+		if (kthread_should_stop() || (ret == -ERESTART)) {
+			if (!ctx->veng_ops->ve_get_undq_dispFrm_cnt(fh)) {
+				vpu_info("%d.%s.return 1\n", __LINE__,
+					 __func__);
+				return 1;
+			}
+		}
+
+		if (!ctx->veng_ops->ve_get_undq_dispFrm_cnt(fh) &&
+		    !ctx->stop_cmd) {
+			// SW-7622, sometimes ve1_ctx->last_frame is set after all 30 frames are dequeued, threadcap won't flow to ve_cap_dqbuf() + ve_get_info() + vpu_buf_done(), vpu_ctx->last_buf_done won't be set.
+			// Add "!ctx->stop_cmd" to flow to ve_cap_dqbuf() + ve_get_info() + vpu_buf_done(), ve1_cap_dqbuf() will set vpu_ctx->last_frame if ve1_ctx->last_frame is set
+			continue;
+		}
+
+		ret = 0;
+		for (; !ret;) {
+			uint64_t timestamp = 0;
+			bool eos = 0;
+			bool no_frame = 0;
+
+			mutex_lock(&ctx->vpu_mutex);
+			sizeimage = ctx->cap_fmt.spec.fmt.pix_mp.plane_fmt[0].sizeimage;
+			sequence = ctx->seq_cap;
+			mutex_unlock(&ctx->vpu_mutex);
+
+			ret = ctx->veng_ops->ve_cap_dqbuf(fh, NULL, &timestamp,
+							  &disp_buf);
+			if (!ret) {
+				rtkvpu_dump_capbuf(ctx, disp_buf, sizeimage);
+
+				if (ctx->veng_ops->ve_get_info)
+					ctx->veng_ops->ve_get_info(fh, &eos,
+								   &no_frame);
+
+				if (vpu_buf_done(fh, disp_buf, timestamp, sizeimage,
+						 sequence, eos, no_frame))
+					break;
+
+				ctx->cap_retry_cnt = 0;
+			} else {
+				if (ret == -EAGAIN) {
+					ctx->cap_retry_cnt++;
+
+					if (ctx->cap_retry_cnt > 200) {
+						ctx->cap_retry_cnt = 0;
+
+						if (kthread_should_stop()) {
+							vpu_err("%s force quit\n", __func__);
+							return 1;
+						}
+					}
+				}
+				usleep_range(1000, 1000);
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static void rtkvpu_dump_outbuf(struct vpu_ctx *ctx, uint8_t* buf,
+					uint32_t offset, uint32_t len)
+{
+#if defined(RTKVPU_DUMP_OUTBUF_EN)
+	int filp_open_flags;
+	ssize_t bytes = 0;
+	loff_t pos = 0;
+
+	if (ctx == NULL) {
+		return;
+	}
+
+	if ((buf != NULL) && (len != 0)) {
+		if (ctx->bNewOutbufDumpFile == 1) {
+			ctx->bNewOutbufDumpFile = 0;
+			filp_open_flags = O_CREAT | O_WRONLY;
+			memset(ctx->outbufDumpFileName, 0, sizeof(unsigned char)*256);
+			snprintf(ctx->outbufDumpFileName, 256,
+					"/mnt/outbuf_%d.es",
+					gOutbufDumpSerial);
+			gOutbufDumpSerial++;
+			vpu_info("%d.%s.create new outbuf dump:%s\n",__LINE__,__func__,
+					ctx->outbufDumpFileName);
+		} else {
+			filp_open_flags = O_APPEND | O_WRONLY;
+		}
+		ctx->outbufDumpFile =
+			(void *)filp_open(ctx->outbufDumpFileName, filp_open_flags, 0);
+		if (IS_ERR((struct file *)ctx->outbufDumpFile)) {
+			vpu_err("%d.%s.filp_open %s fail\n",__LINE__,__func__,
+					ctx->outbufDumpFileName);
+		} else {
+			//vpu_info("%d.%s.filp_open %s ok\n",__LINE__,__func__,
+			//		ctx->outbufDumpFileName);
+			bytes =
+				kernel_write((struct file *)(ctx->outbufDumpFile),
+							(void *)(buf + offset), (size_t)len, &pos);
+			//vpu_info("%d.%s.kernel_write bytes:%ld.pos:%lld\n",__LINE__,__func__,
+			//		bytes, pos);
+			filp_close((struct file *)(ctx->outbufDumpFile), NULL);
+			//vpu_info("%d.%s.filp_close %s\n",__LINE__,__func__,
+			//		ctx->outbufDumpFileName);
+			ctx->outbufDumpFile = NULL;
+		}
+	}
+#endif
+}
+
+static int threadout(void *data)
+{
+	struct v4l2_fh *fh = (struct v4l2_fh *)data;
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+	uint32_t sizeimage, sequence;
+	struct vb2_v4l2_buffer *v4l2_buf;
+	unsigned long flags;
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	int ret = 0, qbuf_ret = 0;
+	const struct v4l2_event eos_event = { .type = V4L2_EVENT_EOS };
+	struct vb2_queue *dst_vq = NULL;
+	bool bForceEscapeDone = false;
+
+	while (1) {
+		ret = wait_event_interruptible_timeout(
+			ctx->vpu_out_waitq,
+			(kthread_should_stop() ||
+			(v4l2_m2m_num_src_bufs_ready(fh->m2m_ctx)
+			&& (qbuf_ret != -ENOSPC))),
+			msecs_to_jiffies(ctx->thread_out_interval));
+
+		if (kthread_should_stop() || (ret == -ERESTART)) {
+			for (;;) {
+				v4l2_buf = v4l2_m2m_src_buf_remove(fh->m2m_ctx);
+				if (v4l2_buf == NULL)
+					return 1;
+
+				spin_lock_irqsave(&ctx->vpu_spin_lock, flags);
+				v4l2_m2m_buf_done(v4l2_buf,
+						  VB2_BUF_STATE_ERROR);
+				spin_unlock_irqrestore(&ctx->vpu_spin_lock,
+						       flags);
+			}
+		}
+
+		if (ctx->stop_cmd &&
+		    !v4l2_m2m_num_src_bufs_ready(fh->m2m_ctx) &&
+		    !ctx->last_buf_done) {
+			ret = op->vpu_stop_cmd(fh);
+			if ((ret < 0) && (!bForceEscapeDone)) {
+				dst_vq = v4l2_m2m_get_vq(
+					fh->m2m_ctx,
+					V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+
+				if (list_empty(&dst_vq->done_list)) {
+					vpu_info("%d.%s.force last_buffer_dequeued\n",
+						 __LINE__, __func__);
+					dst_vq->last_buffer_dequeued = true;
+					wake_up(&dst_vq->done_wq);
+					v4l2_event_queue_fh(fh, &eos_event);
+					bForceEscapeDone = true;
+				}
+			}
+		}
+
+		if (v4l2_m2m_num_src_bufs_ready(fh->m2m_ctx)) {
+			uint8_t *p;
+			uint32_t offset, len;
+			for (;;) {
+				v4l2_buf = v4l2_m2m_next_src_buf(fh->m2m_ctx);
+				if (!v4l2_buf)
+					break;
+
+				mutex_lock(&ctx->vpu_mutex);
+				sizeimage = ctx->out_fmt.spec.fmt.pix_mp.plane_fmt[0].sizeimage;
+				sequence = ctx->seq_out;
+				mutex_unlock(&ctx->vpu_mutex);
+
+				if (vid_ctx->params.is_secure &&
+					ctx->memory_out == V4L2_MEMORY_DMABUF) {
+					p = ((uint8_t *)
+						     vb2_dma_contig_plane_dma_addr(
+							     &v4l2_buf->vb2_buf, 0));
+				} else {
+					if (vid_ctx->params.is_secure) {
+						vpu_err("svp needs V4L2_MEMORY_DMABUF for OUTPUT");
+						break;
+					} else {
+						p = vb2_plane_vaddr(&v4l2_buf->vb2_buf, 0);
+					}
+				}
+
+				len = v4l2_buf->vb2_buf.planes[0].bytesused;
+				offset =
+					v4l2_buf->vb2_buf.planes[0].data_offset;
+
+				qbuf_ret = ctx->veng_ops->ve_out_qbuf(fh, p + offset,
+						len, v4l2_buf->vb2_buf.timestamp,
+						sequence);
+				if (!qbuf_ret) {
+					rtkvpu_dump_outbuf(ctx, p, offset, len);
+
+					v4l2_buf = v4l2_m2m_src_buf_remove(
+						fh->m2m_ctx);
+					if (!v4l2_buf) {
+						vpu_warn(
+							"No src buffer to remove\n");
+						break;
+					}
+
+					/* Complete first bitstream parsing only first */
+					if (!sequence) {
+						complete(&ctx->bs_parsing_comp);
+						vpu_info(
+							"%d.%s.complete bs_parsing_comp for bitstream parsing\n",
+							__LINE__, __func__);
+					}
+					v4l2_buf->sequence = sequence++;
+
+					mutex_lock(&ctx->vpu_mutex);
+					ctx->seq_out = sequence;
+					mutex_unlock(&ctx->vpu_mutex);
+
+					vb2_set_plane_payload(
+						&v4l2_buf->vb2_buf, 0,
+						sizeimage);
+
+					spin_lock_irqsave(&ctx->vpu_spin_lock,
+							  flags);
+					v4l2_m2m_buf_done(v4l2_buf,
+							  VB2_BUF_STATE_DONE);
+					spin_unlock_irqrestore(
+						&ctx->vpu_spin_lock, flags);
+					continue;
+				} else if (qbuf_ret == -EINVAL || qbuf_ret == -EIO) {
+					vpu_info("%s ve_out_qbuf error, buf done VB2_BUF_STATE_ERROR\n", __func__);
+					v4l2_buf = v4l2_m2m_src_buf_remove(fh->m2m_ctx);
+					if (v4l2_buf)
+						v4l2_m2m_buf_done(v4l2_buf, VB2_BUF_STATE_ERROR);
+					continue;
+				}
+
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int vpu_enum_fmt_cap(struct v4l2_fmtdesc *f)
+{
+	if (f->index < ARRAY_SIZE(cap_fmt)) {
+		/* Format found */
+		f->pixelformat = cap_fmt[f->index].spec.fmt.pix_mp.pixelformat;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int vpu_enum_fmt_out(struct v4l2_fmtdesc *f)
+{
+	if (f->index < ARRAY_SIZE(out_fmt)) {
+		/* Format found */
+		f->pixelformat = out_fmt[f->index].spec.fmt.pix_mp.pixelformat;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int vpu_g_fmt(struct v4l2_fh *fh, struct v4l2_format *f)
+{
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+
+	mutex_lock(&ctx->vpu_mutex);
+	if (V4L2_TYPE_IS_OUTPUT(f->type))
+		memcpy(&f->fmt.pix_mp, &ctx->out_fmt.spec.fmt.pix_mp,
+		       sizeof(struct v4l2_pix_format_mplane));
+	else
+		memcpy(&f->fmt.pix_mp, &ctx->cap_fmt.spec.fmt.pix_mp,
+		       sizeof(struct v4l2_pix_format_mplane));
+	mutex_unlock(&ctx->vpu_mutex);
+	return 0;
+}
+
+static const struct vpu_fmt *find_format(struct v4l2_format *f)
+{
+	const struct vpu_fmt *fmt;
+	unsigned int size = 0;
+	unsigned int i;
+
+	if (V4L2_TYPE_IS_OUTPUT(f->type)) {
+		fmt = &out_fmt[0];
+		size = OUT_NUM;
+	} else {
+		fmt = &cap_fmt[0];
+		size = CAP_NUM;
+	}
+
+	for (i = 0; i < size; i++) {
+		if (fmt[i].spec.fmt.pix_mp.pixelformat == f->fmt.pix_mp.pixelformat)
+			break;
+	}
+
+	if (i == size) {
+		vpu_warn("unknow type %d format %p4cc, use default\n",
+			 f->type, &f->fmt.pix_mp.pixelformat);
+		return NULL;
+	}
+
+	return &fmt[i];
+}
+
+static int vpu_try_fmt(struct v4l2_fh *fh, struct v4l2_format *f)
+{
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+	const struct vpu_fmt *fmt;
+	enum v4l2_field field;
+	unsigned int width = 0;
+	unsigned int height = 0;
+	unsigned int bytesperline = 0;
+	unsigned int sizeimage = 0;
+
+	fmt = find_format(f);
+	if (!fmt) {
+		if (V4L2_TYPE_IS_OUTPUT(f->type))
+			fmt = &out_fmt[0];
+		else
+			fmt = &cap_fmt[0];
+
+		f->fmt.pix_mp.pixelformat = fmt->spec.fmt.pix_mp.pixelformat;
+	}
+
+	field = V4L2_FIELD_NONE;
+	if (f->fmt.pix_mp.pixelformat == V4L2_PIX_FMT_MPEG1 || f->fmt.pix_mp.pixelformat == V4L2_PIX_FMT_MPEG2 ||
+		f->fmt.pix_mp.pixelformat == V4L2_PIX_FMT_MPEG4 || f->fmt.pix_mp.pixelformat == V4L2_PIX_FMT_H264 ||
+		f->fmt.pix_mp.pixelformat == V4L2_PIX_FMT_NV12) {
+		if ((f->fmt.pix_mp.field == V4L2_FIELD_NONE) || (f->fmt.pix_mp.field == V4L2_FIELD_INTERLACED)) {
+			field = f->fmt.pix_mp.field;
+		}
+	}
+
+	width = clamp(f->fmt.pix_mp.width, fmt->frmsize.min_width,
+		fmt->frmsize.max_width);
+	height = clamp(f->fmt.pix_mp.height, fmt->frmsize.min_height,
+		fmt->frmsize.max_height);
+
+	if (V4L2_TYPE_IS_CAPTURE(f->type)) {
+		if (ctx->out_fmt.misc.VideoEngine == VIDEO_ENGINE_2) {
+			if(ctx->ddr_width && ctx->ddr_height) {
+				width = ctx->ddr_width;
+				height = ctx->ddr_height;
+			} else {
+				width = ALIGN(width, RTK_VE2_WIDTH_ALIGN);
+				height = ALIGN(height, RTK_VE2_HEIGHT_ALIGN);
+			}
+#ifdef ENABLE_GPU_CACHE
+			if (ctx->p010_stride) {
+				width = ctx->p010_stride;
+				f->fmt.pix_mp.pixelformat = V4L2_PIX_FMT_P010;
+			}
+#endif
+		} else {
+			width = ALIGN(width, RTK_DPB_WIDTH_ALIGN);
+			height = ALIGN(height, RTK_DPB_HEIGHT_ALIGN);
+		}
+
+		bytesperline = width;
+		sizeimage = bytesperline * height * 3 / 2;
+		if(ctx->is_bs_error) sizeimage = sizeimage * 10 / 8;
+	} else {
+		width = ALIGN(width, RTK_DPB_WIDTH_ALIGN);
+		height = ALIGN(height, RTK_DPB_HEIGHT_ALIGN);
+
+		bytesperline = 0;
+		sizeimage = fmt->spec.fmt.pix_mp.plane_fmt[0].sizeimage;
+	}
+
+	f->fmt.pix_mp.width = width;
+	f->fmt.pix_mp.height = height;
+	f->fmt.pix_mp.field = field;
+	f->fmt.pix_mp.plane_fmt[0].bytesperline = bytesperline;
+	f->fmt.pix_mp.plane_fmt[0].sizeimage = sizeimage;
+	f->fmt.pix_mp.num_planes = 1;
+
+	return 0;
+}
+
+static int vpu_s_fmt_cap(struct v4l2_fh *fh, struct v4l2_format *f)
+{
+	const struct vpu_fmt *fmt;
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+	unsigned int width = 0;
+	unsigned int height = 0;
+
+	fmt = find_format(f);
+	if (!fmt)
+		memcpy(f, &cap_fmt[0], sizeof(struct v4l2_format));
+
+	width = f->fmt.pix_mp.width;
+	height = f->fmt.pix_mp.height;
+
+	vpu_try_fmt(fh, f);
+
+	mutex_lock(&ctx->vpu_mutex);
+	memcpy(&ctx->cap_fmt.spec, f, sizeof(struct v4l2_format));
+	ctx->cap_fmt.misc.ori_width = (width > 0) ? width : f->fmt.pix_mp.width;
+	ctx->cap_fmt.misc.ori_height = (height > 0) ? height : f->fmt.pix_mp.height;
+	ctx->out_fmt.spec.fmt.pix_mp.colorspace = f->fmt.pix_mp.colorspace;
+	ctx->out_fmt.spec.fmt.pix_mp.ycbcr_enc = f->fmt.pix_mp.ycbcr_enc;
+	ctx->out_fmt.spec.fmt.pix_mp.quantization = f->fmt.pix_mp.quantization;
+	ctx->out_fmt.spec.fmt.pix_mp.xfer_func = f->fmt.pix_mp.xfer_func;
+
+	mutex_unlock(&ctx->vpu_mutex);
+
+	return 0;
+}
+
+static int vpu_s_fmt_out(struct v4l2_fh *fh, struct v4l2_format *f)
+{
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+	const struct vpu_fmt *fmt = NULL;
+	int pixelformat = 0;
+	int ret = 0;
+
+	fmt = find_format(f);
+	if (!fmt) {
+		fmt = &out_fmt[0];
+		memcpy(f, &fmt->spec, sizeof(struct v4l2_format));
+	}
+
+	mutex_lock(&ctx->vpu_mutex);
+	if (f->fmt.pix_mp.width * f->fmt.pix_mp.height > fmt->misc.max_resolution) {
+		vpu_err("%s, %d x %d over spec ", __func__, f->fmt.pix_mp.width, f->fmt.pix_mp.height);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	ctx->rect.width = f->fmt.pix_mp.width;
+	ctx->rect.height = f->fmt.pix_mp.height;
+	mutex_unlock(&ctx->vpu_mutex);
+
+	vpu_try_fmt(fh, f);
+
+	pixelformat = f->fmt.pix_mp.pixelformat;
+	mutex_lock(&ctx->vpu_mutex);
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_H263:
+	case V4L2_PIX_FMT_H264:
+	case V4L2_PIX_FMT_MPEG1:
+	case V4L2_PIX_FMT_MPEG2:
+	case V4L2_PIX_FMT_MPEG4:
+	case V4L2_PIX_FMT_VP8:
+	case V4L2_PIX_FMT_VC1_ANNEX_G:
+	case V4L2_PIX_FMT_VC1_ANNEX_L:
+		/* Set VE1 ops */
+		if (!ctx->ve1_ops) {
+			ret = -EINVAL;
+			goto exit;
+		}
+		ctx->veng_ops = ctx->ve1_ops;
+		ctx->out_fmt.misc.VideoEngine = VIDEO_ENGINE_1;
+		break;
+	case V4L2_PIX_FMT_HEVC:
+	case V4L2_PIX_FMT_VP9:
+	case V4L2_PIX_FMT_AV1:
+		/* Set VE2 ops */
+		if (!ctx->ve2_ops) {
+			ret =  -EINVAL;
+			goto exit;
+		}
+		ctx->veng_ops = ctx->ve2_ops;
+		ctx->out_fmt.misc.VideoEngine = VIDEO_ENGINE_2;
+		break;
+	default:
+		vpu_err("Unsupported format=%p4cc\n", &pixelformat);
+		break;
+	}
+
+	memcpy(&ctx->out_fmt.spec, f, sizeof(struct v4l2_format));
+	memcpy(&ctx->out_fmt.frmsize, &fmt->frmsize, sizeof(struct v4l2_frmsize_stepwise));
+	memcpy(&ctx->out_fmt.misc, &fmt->misc, sizeof(struct vpu_misc));
+	ctx->cap_fmt.spec.fmt.pix_mp.field = f->fmt.pix_mp.field;
+	ctx->cap_fmt.spec.fmt.pix_mp.colorspace = f->fmt.pix_mp.colorspace;
+	ctx->cap_fmt.spec.fmt.pix_mp.ycbcr_enc = f->fmt.pix_mp.ycbcr_enc;
+	ctx->cap_fmt.spec.fmt.pix_mp.quantization = f->fmt.pix_mp.quantization;
+	ctx->cap_fmt.spec.fmt.pix_mp.xfer_func = f->fmt.pix_mp.xfer_func;
+	ctx->cap_fmt.spec.fmt.pix_mp.width = f->fmt.pix_mp.width;
+	ctx->cap_fmt.spec.fmt.pix_mp.height = f->fmt.pix_mp.height;
+	ctx->cap_fmt.spec.fmt.pix_mp.plane_fmt[0].bytesperline = f->fmt.pix_mp.width;
+	ctx->cap_fmt.spec.fmt.pix_mp.plane_fmt[0].sizeimage =
+		f->fmt.pix_mp.width * f->fmt.pix_mp.height * 3 / 2;
+
+	/* Allocate video engine context */
+	if (!vid_ctx->ve_ctx) {
+		int num_inst;
+		if (ctx->out_fmt.misc.VideoEngine == VIDEO_ENGINE_1) {
+			num_inst = atomic_inc_return(&vid_ctx->dev->ve1_num_inst);
+			vpu_dbg("%s add ve1 inst cnt %d", __func__, num_inst);
+		} else {
+			num_inst = atomic_inc_return(&vid_ctx->dev->ve2_num_inst);
+			vpu_dbg("%s add ve2 inst cnt %d", __func__, num_inst);
+		}
+
+		if (num_inst > ctx->veng_ops->ve_get_max_instance(fh)) {
+			if (ctx->out_fmt.misc.VideoEngine == VIDEO_ENGINE_1) {
+				atomic_dec(&vid_ctx->dev->ve1_num_inst);
+				vpu_dbg("%s ve1 inst cnt %d", __func__,
+					atomic_read(&vid_ctx->dev->ve1_num_inst));
+			} else {
+				atomic_dec(&vid_ctx->dev->ve2_num_inst);
+				vpu_dbg("%s ve2 inst cnt %d", __func__,
+					atomic_read(&vid_ctx->dev->ve2_num_inst));
+			}
+
+			vpu_warn("Warning!!%s instance limit exceeded (max = %d)\n",
+				(ctx->out_fmt.misc.VideoEngine == VIDEO_ENGINE_1)?"ve1":"ve2",
+				ctx->veng_ops->ve_get_max_instance(fh));
+			ret = -EBUSY;
+			goto exit;
+		}
+
+		vid_ctx->ve_ctx =
+			ctx->veng_ops->ve_alloc_context(fh);
+		if (IS_ERR(vid_ctx->ve_ctx)) {
+			vid_ctx->ve_ctx = NULL;
+			ret = -EBUSY;
+			goto exit;
+		}
+	}
+
+exit:
+	mutex_unlock(&ctx->vpu_mutex);
+
+	return ret;
+}
+
+static int vpu_queue_info(struct vb2_queue *vq, int *bufcnt,
+			  unsigned int *nplanes, int *sizeimage)
+{
+	struct vpu_ctx *ctx = vq_to_vpu(vq);
+	const struct vpu_fmt *fmt;
+	int type = vq->type;
+
+	mutex_lock(&ctx->vpu_mutex);
+	if (V4L2_TYPE_IS_OUTPUT(type)) {
+		if (ctx->out_fmt.spec.type == -1) {
+			mutex_unlock(&ctx->vpu_mutex);
+			return -EPERM;
+		}
+
+		fmt = &ctx->out_fmt;
+		if (bufcnt)
+			*bufcnt = fmt->misc.bufcnt;
+	} else {
+		if (ctx->cap_fmt.spec.type == -1) {
+			mutex_unlock(&ctx->vpu_mutex);
+			return -EPERM;
+		}
+
+		fmt = &ctx->cap_fmt;
+	}
+
+	if (nplanes) {
+		if (*nplanes) {
+			if (*sizeimage < fmt->spec.fmt.pix_mp.plane_fmt[0].sizeimage) {
+				mutex_unlock(&ctx->vpu_mutex);
+				return -EINVAL;
+			}
+		} else {
+			*nplanes = 1;
+		}
+	}
+
+	if (sizeimage) {
+		*sizeimage = fmt->spec.fmt.pix_mp.plane_fmt[0].sizeimage;
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+		if (V4L2_TYPE_IS_CAPTURE(type))
+			*sizeimage += METADATA_OFFSET;
+#endif
+	}
+
+	mutex_unlock(&ctx->vpu_mutex);
+	return 0;
+}
+
+int vpu_start_streaming(struct vb2_queue *q, uint32_t count)
+{
+	struct videc_ctx *vid_ctx = vb2_get_drv_priv(q);
+	struct vpu_ctx *ctx = vid_ctx->vpu_ctx;
+	struct v4l2_fh *fh = &vid_ctx->fh;
+	int ret,i;
+	int pixelformat = ctx->out_fmt.spec.fmt.pix_mp.pixelformat;
+
+	if (!ctx->veng_ops){
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	mutex_lock(&ctx->vpu_mutex);
+	ret = ctx->veng_ops->ve_start_streaming(q, count, pixelformat);
+	if (ret) {
+		vpu_err("Failed to start streaming %d\n", ret);
+		if (vid_ctx->ve_ctx) {
+			ctx->veng_ops->ve_free_context(vid_ctx->ve_ctx);
+			if (ctx->out_fmt.misc.VideoEngine == VIDEO_ENGINE_1) {
+				atomic_dec(&vid_ctx->dev->ve1_num_inst);
+				vpu_dbg("%s ve1 inst cnt %d", __func__,
+					atomic_read(&vid_ctx->dev->ve1_num_inst));
+			} else {
+				atomic_dec(&vid_ctx->dev->ve2_num_inst);
+				vpu_dbg("%s ve2 inst cnt %d", __func__,
+					atomic_read(&vid_ctx->dev->ve1_num_inst));
+			}
+			vid_ctx->ve_ctx = NULL;
+		}
+		mutex_unlock(&ctx->vpu_mutex);
+		goto exit;
+	}
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		ctx->seq_out = 0;
+		ctx->memory_out = q->memory;
+		ctx->thread_out = kthread_run(
+			threadout, fh, "outthread %p4cc", &pixelformat);
+		if (IS_ERR(ctx->thread_out)) {
+		    vpu_err("failed to start out thread\n");
+		    ctx->thread_out = NULL;
+		}
+		ctx->is_out_started = 1;
+#if defined(RTKVPU_DUMP_OUTBUF_EN)
+		ctx->bNewOutbufDumpFile = 1;
+#endif
+	} else {
+		ctx->seq_cap = 0;
+		ctx->memory_cap = q->memory;
+		ctx->thread_cap = kthread_run(
+			threadcap, fh, "capthread %p4cc", &pixelformat);
+		if (IS_ERR(ctx->thread_cap)) {
+		    vpu_err("failed to start cap thread\n");
+		    ctx->thread_cap = NULL;
+		}
+		ctx->is_cap_started = 1;
+		ctx->last_buf_done = false;
+#if defined(RTKVPU_DUMP_CAPBUF_EN)
+		ctx->bNewCapbufDumpFile = 1;
+#endif
+	}
+	mutex_unlock(&ctx->vpu_mutex);
+
+	if (ctx->out_fmt.misc.VideoEngine == VIDEO_ENGINE_1 &&
+	    v4l2_m2m_num_src_bufs_ready(fh->m2m_ctx) &&
+	    V4L2_TYPE_IS_OUTPUT(q->type)) {
+		vpu_info(
+			"%d.%s.waiting most 1s for bitstream parsing to be done\n",
+			__LINE__, __func__);
+		wait_for_completion_timeout(&ctx->bs_parsing_comp,
+					    msecs_to_jiffies(1000));
+	}
+
+	return ret;
+
+exit:
+	for (i = 0; i < q->num_buffers; ++i) {
+		struct vb2_buffer *buf = vb2_get_buffer(q, i);
+		if (buf->state == VB2_BUF_STATE_ACTIVE) {
+			vpu_err("id=%d, type=%d, %d -> VB2_BUF_STATE_QUEUED",
+					i, q->type,(int)buf->state);
+			v4l2_m2m_buf_done(to_vb2_v4l2_buffer(buf),
+					  VB2_BUF_STATE_QUEUED);
+		}
+	}
+
+	return ret;
+}
+
+int vpu_stop_streaming(struct vb2_queue *q)
+{
+	struct videc_ctx *vid_ctx = vb2_get_drv_priv(q);
+	struct vpu_ctx *ctx = vid_ctx->vpu_ctx;
+	int ret = 0;
+	int num_src_bufs_ready = 0;
+	struct vb2_v4l2_buffer *v4l2_buf = NULL;
+	struct task_struct *t;
+	//int i = 0;
+	//struct vb2_buffer *vb2 = NULL;
+
+	if (!ctx || !ctx->veng_ops)
+		return -EINVAL;
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		t = xchg(&ctx->thread_out, NULL);
+		if (t) {
+			wake_up_interruptible(&ctx->vpu_out_waitq);
+			kthread_stop(t);
+		}
+	} else {
+		t = xchg(&ctx->thread_cap, NULL);
+		if (t) {
+			wake_up_interruptible(&ctx->vpu_cap_waitq);
+			kthread_stop(t);
+		}
+	}
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		num_src_bufs_ready = v4l2_m2m_num_src_bufs_ready(vid_ctx->fh.m2m_ctx);
+		vpu_info("%d.%s.num_src_bufs_ready:%d\n",
+					__LINE__, __func__, num_src_bufs_ready);
+		if (num_src_bufs_ready) {
+			do {
+				v4l2_buf = v4l2_m2m_next_src_buf(vid_ctx->fh.m2m_ctx);
+				if (!v4l2_buf) {
+					break;
+				}
+				v4l2_buf = v4l2_m2m_src_buf_remove(vid_ctx->fh.m2m_ctx);
+				v4l2_m2m_buf_done(v4l2_buf, VB2_BUF_STATE_ERROR);
+			} while (1);
+		}
+		/*for (i=0;i<q->num_buffers;i++) {
+			vb2 = q->bufs[i];
+			vpu_info("%d.%s.out_vb2[%d].index:%d.state:%d.vb2:0x%px\n",
+				__LINE__, __func__, i,
+				vb2->index,
+				vb2->state,
+				vb2);
+		}*/
+	}
+
+	mutex_lock(&ctx->vpu_mutex);
+	if (ctx && ctx->veng_ops) {
+		ret = ctx->veng_ops->ve_stop_streaming(q);
+		if (ret)
+			vpu_err("fail to stop streaming %d\n", ret);
+	}
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type))
+		ctx->is_out_started = 0;
+	else
+		ctx->is_cap_started = 0;
+	if (!ctx->is_cap_started && !ctx->is_out_started) {
+		reinit_completion(&ctx->bs_parsing_comp);
+	}
+
+	mutex_unlock(&ctx->vpu_mutex);
+	return ret;
+}
+
+static int vpu_qbuf(struct v4l2_fh *fh, struct vb2_buffer *vb)
+{
+	struct vpu_ctx *ctx = vq_to_vpu(vb->vb2_queue);
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	int ret;
+
+	if (!ctx->veng_ops)
+		return -EINVAL;
+
+	if (V4L2_TYPE_IS_OUTPUT(vb->type)) {
+		uint32_t width = 0;
+		uint32_t height = 0;
+		uint32_t min_reqbuf = 0;
+		uint32_t bit_depth = 0;
+		ctx->out_q_cnt++;
+		if (!ctx->parse_header_done && !ctx->is_decoder_error &&
+		    ctx->veng_ops->ve_out_pre_parse) {
+			ret = ctx->veng_ops->ve_out_pre_parse(
+				fh, vb, &width, &height, &min_reqbuf, &bit_depth);
+			if (ret == 0 && (width && height && min_reqbuf))
+				ctx->parse_header_done = true;
+		}
+
+		wake_up_interruptible(&ctx->vpu_out_waitq);
+		return 0;
+	} else {
+		if (ctx->stop_cmd && !v4l2_m2m_num_src_bufs_ready(fh->m2m_ctx))
+			op->vpu_stop_cmd(fh);
+
+		ret = ctx->veng_ops->ve_cap_qbuf(fh, vb);
+		if (!ret) {
+			wake_up_interruptible(&ctx->vpu_cap_waitq);
+		}
+		return ret;
+	}
+	return -EINVAL;
+}
+
+static int vpu_abort(void *priv, int type)
+{
+	struct videc_ctx *vid_ctx = priv;
+	struct vpu_ctx *ctx = vid_ctx->vpu_ctx;
+	int ret;
+
+	if (!ctx->veng_ops)
+		return -EINVAL;
+
+	ret = ctx->veng_ops->ve_abort(vid_ctx->ve_ctx, type);
+	if (ret) {
+		vpu_err("fail to abort streaming(ve2_abort %d)\n", ret);
+	}
+
+	return 0;
+}
+
+static int vpu_g_crop(void *fh, struct v4l2_rect *rect)
+{
+	/* G_SELECTION */
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+
+	mutex_lock(&ctx->vpu_mutex);
+	memcpy(rect, &ctx->rect, sizeof(ctx->rect));
+	mutex_unlock(&ctx->vpu_mutex);
+	return 0;
+}
+
+static int vpu_stop_cmd(void *fh)
+{
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+	int ret = 0;
+
+	if (!ctx->veng_ops)
+		return -EINVAL;
+
+	if (ctx->veng_ops->ve_stop_cmd)
+		ret = ctx->veng_ops->ve_stop_cmd(
+			fh, ctx->out_fmt.spec.fmt.pix_mp.pixelformat);
+
+	return ret;
+}
+
+static int vpu_start_cmd(void *fh)
+{
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+	int ret = 0;
+
+	if (!ctx->veng_ops)
+		return -EINVAL;
+
+	if (ctx->veng_ops->ve_start_cmd)
+		ret = ctx->veng_ops->ve_start_cmd(fh);
+
+	return ret;
+}
+
+static int vpu_reset_resource(void *fh)
+{
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+
+	if(vid_ctx && vid_ctx->ve_ctx &&
+		ctx && ctx->veng_ops) {
+		struct task_struct *t;
+
+		t = xchg(&ctx->thread_out, NULL);
+		if (t) {
+			wake_up_interruptible(&ctx->vpu_out_waitq);
+			kthread_stop(t);
+		}
+
+		t = xchg(&ctx->thread_cap, NULL);
+		if (t) {
+			wake_up_interruptible(&ctx->vpu_cap_waitq);
+			kthread_stop(t);
+		}
+
+		mutex_lock(&ctx->vpu_mutex);
+		ctx->veng_ops->ve_free_context(vid_ctx->ve_ctx);
+		if (ctx->out_fmt.misc.VideoEngine == VIDEO_ENGINE_1) {
+			atomic_dec(&vid_ctx->dev->ve1_num_inst);
+			vpu_dbg("%s ve1 inst cnt %d", __func__,
+				atomic_read(&vid_ctx->dev->ve1_num_inst));
+		} else {
+			atomic_dec(&vid_ctx->dev->ve2_num_inst);
+			vpu_dbg("%s ve2 inst cnt %d", __func__,
+				atomic_read(&vid_ctx->dev->ve1_num_inst));
+		}
+		ctx->veng_ops = NULL;
+
+		// reset other variables of struct videc_ctx
+		// init ctx->out with default value
+		memcpy(&ctx->out_fmt, &out_fmt[0], sizeof(struct vpu_fmt));
+		// init ctx->cap with default value
+		memcpy(&ctx->cap_fmt, &cap_fmt[0], sizeof(struct vpu_fmt));
+		memset(&ctx->rect, 0, sizeof(struct v4l2_rect));
+
+		ctx->seq_out = 1;
+		ctx->seq_cap = 1;
+		ctx->memory_out = 0;
+		ctx->memory_cap = 0;
+		ctx->stop_cmd = false;
+		ctx->last_buf_done = false;
+		ctx->cap_retry_cnt = 0;
+		ctx->out_q_cnt = 0;
+		ctx->parse_header_done = false;
+		mutex_unlock(&ctx->vpu_mutex);
+	}
+
+	return 0;
+}
+
+static int vpu_free_capture(void *fh)
+{
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+	struct task_struct *t;
+
+	t = xchg(&ctx->thread_cap, NULL);
+	if (t) {
+		wake_up_interruptible(&ctx->vpu_cap_waitq);
+		kthread_stop(t);
+	}
+
+	mutex_lock(&ctx->vpu_mutex);
+	if(vid_ctx && vid_ctx->ve_ctx &&
+		ctx && ctx->veng_ops && ctx->veng_ops->ve_free_capture) {
+		ctx->veng_ops->ve_free_capture(vid_ctx->ve_ctx);
+		ctx->seq_cap = 1;
+		ctx->memory_cap = 0;
+		ctx->cap_retry_cnt = 0;
+	}
+	mutex_unlock(&ctx->vpu_mutex);
+
+	return 0;
+}
+
+void *vpu_get_frmsize(uint32_t pixel_format)
+{
+	int i = 0;
+
+	for (i = 0; i < OUT_NUM; i++) {
+		if (pixel_format == out_fmt[i].spec.fmt.pix_mp.pixelformat)
+			return (void *)&out_fmt[i].frmsize;
+	}
+
+	for (i = 0; i < CAP_NUM; i++) {
+		if (pixel_format == cap_fmt[i].spec.fmt.pix_mp.pixelformat)
+			return (void *)&cap_fmt[i].frmsize;
+	}
+
+	return NULL;
+}
+
+int vpu_update_rect(void *fh, struct v4l2_rect *rect)
+{
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+	if (ctx && rect) {
+		mutex_lock(&ctx->vpu_mutex);
+		memcpy(&ctx->rect, rect, sizeof(struct v4l2_rect));
+		vpu_info("%d.%s.rect(%d,%d,%d,%d)\n",
+			__LINE__, __func__,
+			ctx->rect.top, ctx->rect.left,
+			ctx->rect.width, ctx->rect.height);
+		mutex_unlock(&ctx->vpu_mutex);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(vpu_update_rect);
+
+int vpu_get_cap_fmt(void *fh, void *cap_fmt)
+{
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+
+	if (ctx && cap_fmt) {
+		mutex_lock(&ctx->vpu_mutex);
+		memcpy(cap_fmt, &ctx->cap_fmt, sizeof(struct vpu_fmt));
+		mutex_unlock(&ctx->vpu_mutex);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(vpu_get_cap_fmt);
+
+int vpu_update_cap_fmt(void *fh, void *cap_fmt)
+{
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+	struct vpu_fmt *v_fmt = (struct vpu_fmt *)cap_fmt;
+
+	if (ctx && cap_fmt) {
+		mutex_lock(&ctx->vpu_mutex);
+		v_fmt->misc.ori_width = v_fmt->spec.fmt.pix_mp.width;
+		v_fmt->misc.ori_height = v_fmt->spec.fmt.pix_mp.height;
+		ctx->rect.width = v_fmt->misc.ori_width;
+		ctx->rect.height = v_fmt->misc.ori_height;
+
+		vpu_try_fmt(fh, &v_fmt->spec);
+		memcpy(&ctx->cap_fmt, v_fmt, sizeof(struct vpu_fmt));
+		mutex_unlock(&ctx->vpu_mutex);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(vpu_update_cap_fmt);
+
+void vpu_notify_event_resolution_change(void *fh)
+{
+	static const struct v4l2_event event_source_change = {
+		.type = V4L2_EVENT_SOURCE_CHANGE,
+		.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION
+	};
+
+	v4l2_event_queue_fh(fh, &event_source_change);
+}
+EXPORT_SYMBOL(vpu_notify_event_resolution_change);
+
+void vpu_update_resolution_change(void *fh, uint32_t width, uint32_t height,
+			      uint32_t ddr_width, uint32_t ddr_height, uint32_t bit_depth,
+			      uint32_t min_reqbuf)
+{
+	struct vpu_ctx *v_ctx =  fh_to_vpu(fh);
+	struct vpu_fmt vpu_fmt;
+
+	vpu_get_cap_fmt(fh, (void *)&vpu_fmt);
+	if (vpu_fmt.misc.ori_width != width ||
+			vpu_fmt.misc.ori_height != height ||
+			vpu_fmt.misc.bufcnt != min_reqbuf ||
+			v_ctx->bit_depth != ((bit_depth == 0)?8:10) ||
+			v_ctx->ddr_width != ddr_width ||
+			v_ctx->ddr_height != ddr_height) {
+		vpu_fmt.spec.fmt.pix_mp.width = width;
+		vpu_fmt.spec.fmt.pix_mp.height = height;
+		vpu_fmt.spec.fmt.pix_mp.plane_fmt[0].bytesperline = width;
+		vpu_fmt.misc.bufcnt = min_reqbuf;
+		v_ctx->bit_depth = (bit_depth == 0)?8:10;
+		v_ctx->ddr_width = ddr_width;
+		v_ctx->ddr_height = ddr_height;
+
+		vpu_update_cap_fmt(fh, (void *)&vpu_fmt);
+		vpu_notify_event_resolution_change(fh);
+	}
+}
+EXPORT_SYMBOL(vpu_update_resolution_change);
+
+int vpu_check_sub_res_chg(void *fh)
+{
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+
+	if(!fh) {
+		vpu_err("%s fh is NULL", __func__);
+		return 0;
+	}
+
+	if(!vid_ctx) {
+		vpu_err("%s vid_ctx is NULL", __func__);
+		return 0;
+	}
+
+	return vid_ctx->is_sub_res_chg;
+}
+EXPORT_SYMBOL(vpu_check_sub_res_chg);
+
+
+const static struct vpu_fmt_ops ops = {
+	.vpu_enum_fmt_cap = vpu_enum_fmt_cap,
+	.vpu_enum_fmt_out = vpu_enum_fmt_out,
+	.vpu_g_fmt = vpu_g_fmt,
+	.vpu_try_fmt_cap = vpu_try_fmt,
+	.vpu_try_fmt_out = vpu_try_fmt,
+	.vpu_s_fmt_cap = vpu_s_fmt_cap,
+	.vpu_s_fmt_out = vpu_s_fmt_out,
+	.vpu_queue_info = vpu_queue_info,
+	.vpu_start_streaming = vpu_start_streaming,
+	.vpu_stop_streaming = vpu_stop_streaming,
+	.vpu_qbuf = vpu_qbuf,
+	.vpu_abort = vpu_abort,
+	.vpu_g_crop = vpu_g_crop,
+	.vpu_stop_cmd = vpu_stop_cmd,
+	.vpu_free_capture = vpu_free_capture,
+	.vpu_reset_resource = vpu_reset_resource,
+	.vpu_start_cmd = vpu_start_cmd,
+};
+
+const struct vpu_fmt_ops *get_vpu_fmt_ops(void)
+{
+	return &ops;
+}
+
+void *vpu_alloc_context(void)
+{
+	struct vpu_ctx *ctx = NULL;
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		vpu_err("Failed to allocate vpu\n");
+		return ctx;
+	}
+
+	ctx->out_fmt.spec.type = -1;
+	ctx->cap_fmt.spec.type = -1;
+	ctx->thread_out = NULL;
+	ctx->thread_cap = NULL;
+	ctx->seq_out = 1;
+	ctx->seq_cap = 1;
+	ctx->thread_out_interval = 10;
+	ctx->thread_cap_interval = 10;
+	ctx->rect.left = 0;
+	ctx->rect.top = 0;
+	ctx->rect.width = 1920;
+	ctx->rect.height = 1080;
+	ctx->veng_ops = NULL;
+	ctx->ve1_ops = NULL;
+	ctx->ve2_ops = NULL;
+	ctx->is_cap_started = 0;
+	ctx->is_out_started = 0;
+	ctx->ve1_ops = vpu_ve1_ops;
+	ctx->ve2_ops = vpu_ve2_ops;
+	ctx->cap_retry_cnt = 0;
+	ctx->stop_cmd = false;
+	ctx->last_buf_done = false;
+	ctx->out_q_cnt = 0;
+	ctx->bit_depth = 8;
+
+	mutex_init(&ctx->vpu_mutex);
+	spin_lock_init(&ctx->vpu_spin_lock);
+	init_waitqueue_head(&ctx->vpu_out_waitq);
+	init_waitqueue_head(&ctx->vpu_cap_waitq);
+	init_completion(&ctx->bs_parsing_comp);
+
+	// init ctx->out with default value
+	memcpy(&ctx->out_fmt, &out_fmt[0], sizeof(struct vpu_fmt));
+	// init ctx->cap with default value
+	memcpy(&ctx->cap_fmt, &cap_fmt[0], sizeof(struct vpu_fmt));
+
+	return ctx;
+}
+
+void vpu_free_context(void *ctx)
+{
+	struct vpu_ctx *vpu_ctx = ctx;
+	struct task_struct *t;
+
+	// reset other variables of struct videc_ctx
+	// init ctx->out with default value
+	memcpy(&vpu_ctx->out_fmt, &out_fmt[0], sizeof(struct vpu_fmt));
+	// init ctx->cap with default value
+	memcpy(&vpu_ctx->cap_fmt, &cap_fmt[0], sizeof(struct vpu_fmt));
+	memset(&vpu_ctx->rect, 0, sizeof(struct v4l2_rect));
+
+	t = xchg(&vpu_ctx->thread_out, NULL);
+	if (t) {
+		wake_up_interruptible(&vpu_ctx->vpu_out_waitq);
+		kthread_stop(t);
+	}
+
+	t = xchg(&vpu_ctx->thread_cap, NULL);
+	if (t) {
+		wake_up_interruptible(&vpu_ctx->vpu_cap_waitq);
+		kthread_stop(t);
+	}
+	vpu_ctx->seq_out = 1;
+	vpu_ctx->seq_cap = 1;
+	vpu_ctx->memory_out = 0;
+	vpu_ctx->memory_cap = 0;
+	vpu_ctx->stop_cmd = false;
+	vpu_ctx->last_buf_done = false;
+	vpu_ctx->cap_retry_cnt = 0;
+	vpu_ctx->out_q_cnt = 0;
+
+	kfree(vpu_ctx);
+}
+
+int vpu_ve_suspend(void *ctx, void *fh)
+{
+	struct vpu_ctx *vpu_ctx = ctx;
+	int ret = 0;
+
+	if (vpu_ctx && vpu_ctx->veng_ops && vpu_ctx->veng_ops->ve_suspend)
+		ret = vpu_ctx->veng_ops->ve_suspend(fh);
+
+	return ret;
+}
+
+int vpu_ve_resume(void *ctx, void *fh)
+{
+	struct vpu_ctx *vpu_ctx = ctx;
+	int ret = 0;
+
+	if (vpu_ctx && vpu_ctx->veng_ops && vpu_ctx->veng_ops->ve_resume)
+		ret = vpu_ctx->veng_ops->ve_resume(fh);
+
+	return ret;
+}
+
+static char *fourcc_to_string(u32 fourcc)
+{
+    static char str[5];
+
+    str[0] = fourcc & 0xFF;
+    str[1] = (fourcc >> 8) & 0xFF;
+    str[2] = (fourcc >> 16) & 0xFF;
+    str[3] = (fourcc >> 24) & 0xFF;
+    str[4] = '\0';
+
+    return str;
+}
+
+const char* vpu_ve_status(void *ctx, void *fh)
+{
+	struct vpu_ctx *vpu_ctx = fh_to_vpu(fh);
+	static char state[128];
+
+	snprintf(state, sizeof(state), "Codec %s, Resolution %dx%d\n",
+		fourcc_to_string(vpu_ctx->out_fmt.spec.fmt.pix_mp.pixelformat),
+		vpu_ctx->rect.width, vpu_ctx->rect.height);
+
+	return state;
+}
+
+/*
+ * Register video engine operations.
+ */
+int vpu_ve_register(int id, struct veng_ops *ops)
+{
+	if (id == 1)
+		vpu_ve1_ops = ops;
+	else if (id == 2)
+		vpu_ve2_ops = ops;
+	else {
+		vpu_err("Register invalid video engine VE%d ops\n", id);
+		return -EINVAL;
+		;
+	}
+
+	vpu_info("Registered video engine VE%d ops\n", id);
+
+	return 0;
+}
+EXPORT_SYMBOL(vpu_ve_register);
+
+/*
+ * Unregister video engine operations.
+ */
+void vpu_ve_unregister(int id)
+{
+	if (id == 1)
+		vpu_ve1_ops = NULL;
+	else if (id == 2)
+		vpu_ve2_ops = NULL;
+
+	vpu_info("Unregistered video engine VE%d ops\n", id);
+}
+EXPORT_SYMBOL(vpu_ve_unregister);
--- /dev/null
+++ b/drivers/media/platform/realtek/legacy/vpu.h
@@ -0,0 +1,176 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ */
+
+#ifndef __VPU_H__
+#define __VPU_H__
+#include <media/v4l2-device.h>
+#include <media/v4l2-dev.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-v4l2.h>
+#include "video_engine.h"
+
+#if IS_ENABLED(CONFIG_RTK_V4L2_DEC_PREPEND_METADATA)
+#define METADATA_OFFSET (2048)
+#endif
+
+//#define ENABLE_GPU_CACHE
+#ifdef ENABLE_GPU_CACHE
+#include <soc/realtek/rtk_gpu_cache_control.h>
+#endif
+
+struct vpu_misc {
+	uint32_t VideoEngine;
+	uint32_t bufcnt;
+	uint32_t ori_width;
+	uint32_t ori_height;
+	uint32_t max_resolution;
+};
+
+struct vpu_fmt {
+	struct v4l2_format spec;
+	struct v4l2_frmsize_stepwise frmsize;
+	struct vpu_misc misc;
+};
+
+struct vpu_ctx {
+	struct vpu_fmt out_fmt, cap_fmt;
+	struct v4l2_rect rect;
+	struct task_struct *thread_out, *thread_cap;
+	int thread_out_interval, thread_cap_interval; // set in vpu_alloc_context(), no need to reset when vpu_stop_streaming
+	uint32_t seq_out, seq_cap;
+	struct mutex vpu_mutex; // init in vpu_alloc_context(), can't set to NULL when vpu_stop_streaming
+	spinlock_t vpu_spin_lock; // init in vpu_alloc_context(), can't set to NULL when vpu_stop_streaming
+	wait_queue_head_t vpu_out_waitq; // init in vpu_alloc_context(), can't set to NULL when vpu_stop_streaming
+	wait_queue_head_t vpu_cap_waitq; // init in vpu_alloc_context(), can't set to NULL when vpu_stop_streaming
+
+	/* video engine operations */
+	struct veng_ops *veng_ops; // set in vpu_s_fmt_out()
+	struct veng_ops *ve1_ops; // set in module_init() of ve1, can't set to NULL when vpu_stop_streaming
+	struct veng_ops *ve2_ops; // set in module_init() of ve2, can't set to NULL when vpu_stop_streaming
+
+	int is_cap_started, is_out_started;
+	uint32_t memory_out, memory_cap;
+
+	bool stop_cmd;
+	bool last_buf_done;
+	int cap_retry_cnt;
+	uint64_t out_q_cnt;
+	struct completion bs_parsing_comp; // init in vpu_alloc_context(), it should reinit_completion() when vpu_stop_streaming
+	bool parse_header_done;
+	uint32_t bit_depth;
+	uint32_t ddr_width;
+	uint32_t ddr_height;
+	bool is_bs_error;
+	bool is_decoder_error;
+	bool wait_disp_I;
+
+	int bNewOutbufDumpFile;		// #if defined(RTKVPU_DUMP_BS_EN) in vpu.c
+	void *outbufDumpFile;		// #if defined(RTKVPU_DUMP_BS_EN) in vpu.c
+	unsigned char outbufDumpFileName[256]; // #if defined(RTKVPU_DUMP_BS_EN) in vpu.c
+	int bNewCapbufDumpFile;		// #if defined(RTKVPU_DUMP_BS_EN) in vpu.c
+	void *capbufDumpFile;		// #if defined(RTKVPU_DUMP_BS_EN) in vpu.c
+	unsigned char capbufDumpFileName[256]; // #if defined(RTKVPU_DUMP_BS_EN) in vpu.c
+
+#ifdef ENABLE_GPU_CACHE
+	uint32_t p010_stride;
+#endif
+};
+
+struct vpu_fmt_ops {
+	int (*vpu_enum_fmt_cap)(struct v4l2_fmtdesc *f);
+	int (*vpu_enum_fmt_out)(struct v4l2_fmtdesc *f);
+	int (*vpu_g_fmt)(struct v4l2_fh *fh, struct v4l2_format *f);
+	int (*vpu_try_fmt_cap)(struct v4l2_fh *fh, struct v4l2_format *f);
+	int (*vpu_try_fmt_out)(struct v4l2_fh *fh, struct v4l2_format *f);
+	int (*vpu_s_fmt_cap)(struct v4l2_fh *fh, struct v4l2_format *f);
+	int (*vpu_s_fmt_out)(struct v4l2_fh *fh, struct v4l2_format *f);
+	int (*vpu_queue_info)(struct vb2_queue *vq, int *bufcnt,
+			      unsigned int *nplanes, int *sizeimage);
+	int (*vpu_start_streaming)(struct vb2_queue *q, unsigned count);
+	int (*vpu_stop_streaming)(struct vb2_queue *q);
+	int (*vpu_qbuf)(struct v4l2_fh *fh, struct vb2_buffer *vb);
+	void (*vpu_buf_finish)(struct vb2_buffer *vb);
+	int (*vpu_abort)(void *priv, int type);
+	int (*vpu_g_crop)(void *fh, struct v4l2_rect *rect);
+	int (*vpu_stop_cmd)(void *fh);
+	int (*vpu_free_capture)(void *fh);
+	int (*vpu_reset_resource)(void *fh);
+	int (*vpu_start_cmd)(void *fh);
+};
+
+const struct vpu_fmt_ops *get_vpu_fmt_ops(void);
+
+/*
+ * struct veng_ops - video engine operations
+ */
+struct veng_ops {
+	int (*ve_start_streaming)(struct vb2_queue *q, uint32_t count,
+				  int pixelformat);
+	int (*ve_stop_streaming)(struct vb2_queue *q);
+	int (*ve_out_qbuf)(void *fh, uint8_t *buf, uint32_t len, uint64_t timestamp,
+			   uint32_t sequence);
+	int (*ve_cap_qbuf)(void *fh, struct vb2_buffer *vb);
+	int (*ve_cap_dqbuf)(void *fh, uint8_t *buf, uint64_t *timestamp,
+			    struct vb2_v4l2_buffer **disp_buf);
+	int (*ve_abort)(void *ctx, int type);
+	void *(*ve_alloc_context)(void *fh);
+	void (*ve_free_context)(void *ctx);
+	void (*ve_free_capture)(void *ctx);
+	int (*ve_stop_cmd)(void *fh, int pixelformat);
+	void (*ve_get_info)(void *fh, bool *eos, bool *no_frame);
+	int (*ve_get_undq_dispFrm_cnt)(void *fh);
+	int (*ve_out_pre_parse)(void *fh, struct vb2_buffer *vb,
+				uint32_t *width, uint32_t *height,
+				uint32_t *minBufCnt, uint32_t *bitrate);
+	int (*ve_get_request_buf_info)(void *fh,
+				uint32_t *ddr_width, uint32_t *ddr_height);
+	int (*ve_start_cmd)(void *fh);
+	int (*ve_suspend)(void *fh);
+	int (*ve_resume)(void *fh);
+	int (*ve_get_max_instance)(void *fh);
+};
+
+/**
+* @brief  Update the rect resolution
+* @param fh [input] struct v4l2_fh
+* @param rect [input] struct v4l2_rect
+*/
+int vpu_update_rect(void *fh, struct v4l2_rect *rect);
+
+/**
+* @brief Get the original v4l2_pix_format of cap in vpu_ctx
+* @param fh [input] struct v4l2_fh
+* @param cap_fmt [output] struct v4l2_pix_format, copied from the original v4l2_pix_format of cap in vpu_ctx
+*/
+int vpu_get_cap_fmt(void *fh, void *cap_fmt);
+/**
+* @brief Update the v4l2_pix_format of cap in vpu_ctx
+* @param fh [input] struct v4l2_fh
+* @param cap_fmt [input] struct v4l2_pix_format, it will be copied to the v4l2_pix_format of cap in vpu_ctx
+*/
+int vpu_update_cap_fmt(void *fh, void *cap_fmt);
+/**
+ * @brief Notify source resolution change event
+ * @param fh [input] struct v4l2_fh
+ */
+void vpu_notify_event_resolution_change(void *fh);
+void vpu_update_resolution_change(void *fh, uint32_t width, uint32_t height,
+			      uint32_t ddr_width, uint32_t ddr_height, uint32_t bit_depth,
+			      uint32_t min_reqbuf);
+int vpu_check_sub_res_chg(void *fh);
+void *vpu_alloc_context(void);
+void vpu_free_context(void *ctx);
+void *vpu_get_frmsize(uint32_t pixel_format);
+int vpu_ve_suspend(void *ctx, void *fh);
+int vpu_ve_resume(void *ctx, void *fh);
+const char* vpu_ve_status(void *ctx, void *fh);
+int vpu_ve_register(int index, struct veng_ops *ops);
+void vpu_ve_unregister(int index);
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/rtkve/enc/rtkve-common.c
@@ -0,0 +1,110 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+
+#include <linux/v4l2-common.h>
+#include <linux/dma-map-ops.h>
+#include <soc/realtek/memory.h>
+#include <soc/realtek/rtk_media_heap.h>
+#include "rtkve-common.h"
+
+struct vpu_buf *rtkve_allocate_dma_memory(struct device *dev,
+				 size_t size, bool limit)
+{
+	struct vpu_buf *buf_hdl = NULL;
+	void *vaddr;
+	dma_addr_t dma_addr;
+	unsigned int flags = 0;
+
+	if (!size) {
+		dev_err(dev, "%s(): requested size==0\n", __func__);
+		goto exit;
+	}
+#if 0
+	if (size < SZ_8K)
+		size = SZ_8K;
+#endif
+	buf_hdl = kzalloc(sizeof(*buf_hdl), GFP_KERNEL);
+	if (!buf_hdl) {
+		dev_err(dev, "%s allocate vpu_buf fail, No Memory\n", __func__);
+		goto exit;
+	}
+
+	if (limit)
+		flags = RTK_FLAG_NONCACHED | RTK_FLAG_SCPUACC | RTK_FLAG_VO_U_POOL;
+	else
+		flags = RTK_FLAG_NONCACHED | RTK_FLAG_SCPUACC | RTK_FLAG_VO_POOL;
+
+	mutex_lock(&dev->mutex);
+	rheap_setup_dma_pools(dev, "rtk_media_heap", flags, __func__);
+	vaddr = dma_alloc_coherent(dev, size, &dma_addr, GFP_KERNEL);
+	mutex_unlock(&dev->mutex);
+	if (!vaddr) {
+		dev_err(dev, "%s dma_alloc fail \n", __func__);
+		kfree(buf_hdl);
+		buf_hdl = NULL;
+		goto exit;
+	}
+
+	buf_hdl->vaddr = vaddr;
+	buf_hdl->daddr = dma_addr;
+	buf_hdl->size = size;
+	memset(buf_hdl->vaddr, 0, size);
+exit:
+	return buf_hdl;
+}
+
+void rtkve_free_dma_memory(struct device *dev, struct vpu_buf *vb)
+{
+	if (vb->size == 0)
+		goto exit;
+
+	if (!vb->vaddr)
+		dev_err(dev, "%s(): requested free of unmapped buffer\n",
+			__func__);
+	else
+		dma_free_coherent(dev, vb->size, vb->vaddr, vb->daddr);
+
+	kfree(vb);
+exit:
+	return;
+}
+
+void word_endian_convert(uint8_t *dst, uint8_t *src, int len)
+{
+	int i;
+	uint16_t *s_ptr = (uint16_t *)src;
+	uint16_t *d_ptr = (uint16_t *)dst;
+	int size = len / sizeof(uint16_t);
+
+	for (i = 0; i < size; i++) {
+		d_ptr[i] = htons(s_ptr[i]);
+	}
+}
+
+void dword_endian_convert(uint8_t *dst, uint8_t *src, int len)
+{
+	int i;
+	uint32_t *s_ptr = (uint32_t *)src;
+	uint32_t *d_ptr = (uint32_t *)dst;
+	int size = len / sizeof(uint32_t);
+
+	for (i = 0; i < size; i++) {
+		d_ptr[i] = htonl(s_ptr[i]);
+	}
+}
+
+uint64_t htonll(long long val)
+{
+	return (((long long)htonl(val)) << 32) + htonl(val >> 32);
+}
+
+void qword_endian_convert(uint8_t *dst, uint8_t *src, int len)
+{
+	int i;
+	uint64_t *s_ptr = (uint64_t *)src;
+	uint64_t *d_ptr = (uint64_t *)dst;
+	int size = len / sizeof(uint64_t);
+
+	for (i = 0; i < size; i++) {
+		d_ptr[i] = htonll(s_ptr[i]);
+	}
+}
--- /dev/null
+++ b/drivers/media/platform/realtek/rtkve/enc/rtkve-common.h
@@ -0,0 +1,211 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+#ifndef RTKVE_COMMON_H
+#define RTKVE_COMMON_H
+
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/v4l2-ctrls.h>
+
+#include "rtkve-rpc-def.h"
+
+#define VPU_ENC_DRV_NAME "rtkve-enc"
+#define VPU_ENC_DEV_NAME "RTK Video Engine encoder"
+
+#define RTKVE_MAX_FBS 32
+
+enum cod_std { STD_HEVC, STD_VP9, STD_AV1, STD_MAX };
+
+enum vpu_fmt_type { VPU_FMT_TYPE_CODEC = 0, VPU_FMT_TYPE_RAW = 1 };
+
+enum vpu_instance_state {
+	VPU_INST_STATE_NONE = 0,
+	VPU_INST_STATE_INIT = 1,
+	VPU_INST_STATE_PREPARE = 2,
+	VPU_INST_STATE_PIC_RUN = 3,
+	VPU_INST_STATE_RESET = 4,
+	VPU_INST_STATE_STOP = 5
+};
+
+enum vpu_instance_type { VPU_INST_TYPE_DEC = 0, VPU_INST_TYPE_ENC = 1 };
+
+struct vpu_buf {
+	size_t size;
+	dma_addr_t daddr;
+	void *vaddr;
+};
+
+struct stateless_hevc_info {
+	const struct v4l2_ctrl_hevc_sps *sps;
+	const struct v4l2_ctrl_hevc_pps *pps;
+	const struct v4l2_ctrl_hevc_scaling_matrix *sm;
+	const struct v4l2_ctrl_hevc_slice_params *spram;
+	const struct v4l2_ctrl_hevc_decode_params *dpram;
+	uint32_t spram_cnt;
+};
+
+struct stateless_vp9_info {
+	const struct v4l2_ctrl_vp9_frame *frame;
+	const struct v4l2_ctrl_vp9_compressed_hdr *cmprs_hdr;
+};
+
+struct stateless_av1_info {
+	const struct v4l2_ctrl_av1_sequence *seq;
+	const struct v4l2_ctrl_av1_frame *frm;
+	const struct v4l2_ctrl_av1_film_grain *film_grain;
+	const struct v4l2_ctrl_av1_tile_group_entry *tge;
+	uint32_t tge_cnt;
+};
+
+struct vpu_rect {
+	u32 left; /* A horizontal pixel offset of top-left corner of rectangle from (0, 0) */
+	u32 top; /* A vertical pixel offset of top-left corner of rectangle from (0, 0) */
+	u32 right; /* A horizontal pixel offset of bottom-right corner of rectangle from (0, 0) */
+	u32 bottom; /* A vertical pixel offset of bottom-right corner of rectangle from (0, 0) */
+};
+
+struct frame_buffer {
+	dma_addr_t buf_y;
+	dma_addr_t buf_cb;
+	dma_addr_t buf_cr;
+	dma_addr_t buf_y_bot;
+	dma_addr_t buf_cb_bot;
+	dma_addr_t buf_cr_bot;
+	unsigned int stride; /* A horizontal stride for given frame buffer */
+	unsigned int width; /* A width for given frame buffer */
+	unsigned int height; /* A height for given frame buffer */
+	unsigned int sequence_no;
+	int index;
+	u32 luma_bitdepth : 4;
+	u32 chroma_bitdepth : 4;
+	u32 chroma_format_idc : 2;
+};
+
+struct enc_output_info {
+	int frm_size;
+	uint64_t timestamp;
+	unsigned char keyfrm;
+	uint32_t picture_num;
+};
+
+struct enc_param {
+	uint32_t framerate_num;
+	uint32_t framerate_denom;
+	uint32_t framerate;
+	uint32_t bitrate;
+	uint32_t bitrate_mode;
+	uint32_t gop_size;
+	uint32_t header_with_frm;
+	bool force_key_frm;
+};
+
+struct dec_param {
+	dma_addr_t
+		buf_addr_y; /**< It specifies the Y buffer address of stateless decoding. */
+	dma_addr_t
+		buf_addr_c; /**< It specifies the Cb buffer address of stateless decoding. */
+	unsigned int wPtr; //PTS_INFO
+	unsigned int PTSH; //PTS_INFO
+	unsigned int PTSL;
+	unsigned int pre_PTSH; //PTS_INFO
+	unsigned int pre_PTSL;
+	u32 bs_len;
+#if 0
+	struct stateless_hevc_info	hevc;
+	struct stateless_vp9_info	vp9;
+	struct stateless_av1_info	av1;
+#endif
+	//struct AV1_V4L2_CTRL_INFO av1;
+};
+
+struct vpu_instance {
+	struct list_head list;
+	struct v4l2_fh v4l2_fh;
+	struct v4l2_ctrl_handler v4l2_ctrl_hdl;
+	struct vpu_device *dev;
+
+	struct v4l2_pix_format_mplane src_fmt;
+	struct v4l2_pix_format_mplane dst_fmt;
+	struct v4l2_rect crop;
+	enum v4l2_colorspace colorspace;
+	enum v4l2_xfer_func xfer_func;
+	enum v4l2_ycbcr_encoding ycbcr_enc;
+	enum v4l2_quantization quantization;
+
+	enum vpu_instance_state state;
+	enum vpu_instance_type type;
+
+	struct enc_param enc_params;
+
+	uint32_t id;
+	uint32_t queued_src_buf_num;
+	uint32_t queued_dst_buf_num;
+	int reqbuf_out;
+	int reqbuf_cap;
+	bool nv21;
+	bool eos;
+	bool is_10bit_bitstream;
+	bool force_key_frm_mode;
+	uint32_t feed_cnt;
+
+	struct vpu_handler *enc_hdl;
+
+	u8 frame_addr[RTKVE_MAX_FBS][3][4];
+	struct task_struct *input_thread;
+	wait_queue_head_t input_waitq;
+	wait_queue_head_t output_waitq;
+	struct work_struct encode_work;
+
+	struct list_head srcbuf_list;
+	struct list_head dstbuf_list;
+	spinlock_t srcbuf_lock;
+	spinlock_t dstbuf_lock;
+
+	//stateful
+	bool initialized;
+	bool is_bs_error;
+	bool is_decoder_error;
+};
+
+struct rtkve_match_data {
+	const struct vpu_format *(*find_vpu_fmt)(unsigned int v4l2_pix_fmt,
+						 enum vpu_fmt_type type);
+	const struct vpu_format *(*find_vpu_fmt_by_idx)(unsigned int idx,
+							enum vpu_fmt_type type);
+	int (*ctrls_setup)(struct vpu_instance *inst);
+	int (*queue_init)(void *priv, struct vb2_queue *src_vq,
+			  struct vb2_queue *dst_vq);
+	//void (*dev_run_work)(struct vpu_instance *inst);
+	void (*dev_run_work)(struct work_struct *work);
+	void (*stop_decode)(struct vpu_instance *inst);
+	int (*create_instance)(struct vpu_instance *inst);
+	void (*destroy_instance)(struct vpu_instance *inst);
+
+	bool is_stateless;
+};
+
+struct vpu_device {
+	struct device *dev;
+	struct v4l2_device v4l2_dev;
+	struct media_device mdev;
+	struct v4l2_m2m_dev *m2m_dev;
+	struct list_head instances;
+	const struct rtkve_match_data *rtkve_mdata;
+	struct video_device *video_dev_enc;
+	struct mutex dev_lock; /* lock for the src, dst v4l2 queues */
+	struct mutex hw_lock; /* lock hw configurations */
+	struct workqueue_struct *encode_workqueue;
+	atomic_t num_inst;
+};
+
+struct vpu_buf *rtkve_allocate_dma_memory(struct device *dev,
+	size_t size, bool limit);
+void rtkve_free_dma_memory(struct device *dev, struct vpu_buf *vb);
+uint64_t htonll(long long val);
+void word_endian_convert(uint8_t *dst, uint8_t *src, int len);
+void dword_endian_convert(uint8_t *dst, uint8_t *src, int len);
+void qword_endian_convert(uint8_t *dst, uint8_t *src, int len);
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/rtkve/enc/rtkve-enc-drv.c
@@ -0,0 +1,308 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video encoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/of_address.h>
+#include <linux/genalloc.h>
+#include <linux/firmware.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/dma-map-ops.h>
+#include <soc/realtek/memory.h>
+#include <soc/realtek/rtk_media_heap.h>
+#include "rtkve-vpu.h"
+
+#define VPU_PLATFORM_DEVICE_NAME "rtkve-enc"
+
+static ssize_t rtkve_get_instance_info(struct device *dev, struct device_attribute *attr,
+			 char *buf);
+
+static DEVICE_ATTR(instance_info, S_IRUSR, rtkve_get_instance_info, NULL);
+
+static const struct media_device_ops rtkve_m2m_media_ops = {
+	.req_validate = vb2_request_validate,
+	.req_queue = v4l2_m2m_request_queue,
+};
+
+static int rtkve_enc_open(struct file *filp)
+{
+	struct video_device *vdev = video_devdata(filp);
+	struct vpu_device *dev = video_drvdata(filp);
+	const struct rtkve_match_data *enc_pdata = dev->rtkve_mdata;
+	struct vpu_instance *inst = NULL;
+	int ret;
+
+	inst = kzalloc(sizeof(*inst), GFP_KERNEL);
+	if (!inst)
+		return -ENOMEM;
+
+	inst->dev = dev;
+	inst->type = VPU_INST_TYPE_DEC;
+
+	v4l2_fh_init(&inst->v4l2_fh, vdev);
+	filp->private_data = &inst->v4l2_fh;
+	v4l2_fh_add(&inst->v4l2_fh);
+
+	inst->v4l2_fh.m2m_ctx =
+		v4l2_m2m_ctx_init(dev->m2m_dev, inst, enc_pdata->queue_init);
+	if (IS_ERR(inst->v4l2_fh.m2m_ctx)) {
+		ret = PTR_ERR(inst->v4l2_fh.m2m_ctx);
+		goto free_inst;
+	}
+
+	if (enc_pdata->ctrls_setup(inst)) {
+		ret = -ENODEV;
+		goto err_m2m_release;
+	}
+
+	rtkve_set_default_format(inst, &inst->src_fmt, &inst->dst_fmt);
+	inst->colorspace = V4L2_COLORSPACE_DEFAULT;
+	inst->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	inst->quantization = V4L2_QUANTIZATION_DEFAULT;
+	inst->xfer_func = V4L2_XFER_FUNC_DEFAULT;
+	inst->enc_params.framerate_num = DEFAULT_FRAMERATE_DENOM;
+	inst->enc_params.framerate_denom = DEFAULT_FRAMERATE_NUM;
+	inst->enc_params.gop_size = DEFAULT_GOP;
+
+	INIT_WORK(&inst->encode_work, enc_pdata->dev_run_work);
+	init_waitqueue_head(&inst->input_waitq);
+	init_waitqueue_head(&inst->output_waitq);
+
+	ret = mutex_lock_interruptible(&dev->dev_lock);
+	if (ret)
+		goto cleanup_inst;
+
+	list_add_tail(&inst->list, &dev->instances);
+
+	mutex_unlock(&dev->dev_lock);
+	return 0;
+
+cleanup_inst:
+	v4l2_ctrl_handler_free(&inst->v4l2_ctrl_hdl);
+err_m2m_release:
+	v4l2_m2m_ctx_release(inst->v4l2_fh.m2m_ctx);
+free_inst:
+	kfree(inst);
+
+	return ret;
+}
+
+static int rtkve_enc_release(struct file *file)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(file->private_data);
+	struct vpu_device *dev = inst->dev;
+	const struct rtkve_match_data *enc_pdata = dev->rtkve_mdata;
+
+	mutex_lock(&inst->dev->dev_lock);
+	list_del(&inst->list);
+	v4l2_m2m_ctx_release(inst->v4l2_fh.m2m_ctx);
+
+	if (inst->state != VPU_INST_STATE_NONE) {
+		v4l2_m2m_suspend(inst->dev->m2m_dev);
+		enc_pdata->destroy_instance(inst);
+		v4l2_m2m_resume(inst->dev->m2m_dev);
+	}
+	mutex_unlock(&inst->dev->dev_lock);
+
+	v4l2_ctrl_handler_free(&inst->v4l2_ctrl_hdl);
+	v4l2_fh_del(&inst->v4l2_fh);
+	v4l2_fh_exit(&inst->v4l2_fh);
+	kfree(inst);
+	inst = NULL;
+
+	return 0;
+}
+
+static const struct v4l2_file_operations rtkve_enc_fops = {
+	.owner = THIS_MODULE,
+	.open = rtkve_enc_open,
+	.release = rtkve_enc_release,
+	.unlocked_ioctl = video_ioctl2,
+	.poll = v4l2_m2m_fop_poll,
+	.mmap = v4l2_m2m_fop_mmap,
+};
+
+static int rtkve_enc_register_device(struct vpu_device *dev)
+{
+	struct video_device *vdev_enc;
+	int ret = 0;
+
+	vdev_enc =
+		devm_kzalloc(dev->v4l2_dev.dev, sizeof(*vdev_enc), GFP_KERNEL);
+	if (!vdev_enc) {
+		ret = -ENOMEM;
+		dev_err(dev->dev, "alloc devm failed\n");
+		goto exit;
+	}
+
+	dev->video_dev_enc = vdev_enc;
+
+	strscpy(vdev_enc->name, VPU_ENC_DEV_NAME, sizeof(vdev_enc->name));
+	vdev_enc->fops = &rtkve_enc_fops;
+	vdev_enc->ioctl_ops = &rtkve_enc_ioctl_ops;
+	vdev_enc->release = video_device_release_empty;
+	vdev_enc->v4l2_dev = &dev->v4l2_dev;
+	vdev_enc->vfl_dir = VFL_DIR_M2M;
+	vdev_enc->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;
+	vdev_enc->lock = &dev->dev_lock;
+
+	video_set_drvdata(vdev_enc, dev);
+
+	ret = video_register_device(vdev_enc, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		dev_err(dev->dev, "video_register_device failed, ret %d\n",
+			ret);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+static void rtkve_enc_unregister_device(struct vpu_device *dev)
+{
+	video_unregister_device(dev->video_dev_enc);
+}
+
+static int rtkve_enc_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct vpu_device *dev;
+
+	dev_info(&pdev->dev, "%d.%s.enter\n", __LINE__, __func__);
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&pdev->dev, "alloc devm failed\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	dev->rtkve_mdata = device_get_match_data(&pdev->dev);
+	if (!dev->rtkve_mdata) {
+		dev_err(&pdev->dev, "missing match_data\n");
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	set_dma_ops(&pdev->dev, &rheap_dma_ops);
+	rheap_setup_dma_pools(&pdev->dev, "rtk_media_heap",
+	                      RTK_FLAG_NONCACHED | RTK_FLAG_SCPUACC |
+	                      RTK_FLAG_VO_U_POOL, __func__);
+
+	mutex_init(&dev->dev_lock);
+	mutex_init(&dev->hw_lock);
+	dev_set_drvdata(&pdev->dev, dev);
+	dev->dev = &pdev->dev;
+	strscpy(dev->mdev.model, VPU_ENC_DRV_NAME, sizeof(dev->mdev.model));
+
+	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "v4l2_device_register fail: %d\n", ret);
+		goto exit;
+	}
+
+	ret = rtkve_enc_init_m2m_dev(dev);
+	if (ret)
+		goto err_enc_unreg;
+
+	dev->encode_workqueue = alloc_ordered_workqueue(
+		VPU_ENC_DRV_NAME, WQ_MEM_RECLAIM | WQ_FREEZABLE);
+	if (!dev->encode_workqueue) {
+		dev_err(&pdev->dev, "Failed to create encode workqueue");
+		ret = -EINVAL;
+		goto err_enc_workq;
+	}
+
+	INIT_LIST_HEAD(&dev->instances);
+	atomic_set(&dev->num_inst, 0);
+
+	ret = device_create_file(&pdev->dev, &dev_attr_instance_info);
+	if (ret < 0)
+		dev_err(&pdev->dev, "failed to create v4l2 encode instance_info attribute\n");
+
+	ret = rtkve_enc_register_device(dev);
+	if (ret) {
+		dev_err(&pdev->dev, "coda_vpu_enc_register_device fail: %d\n",
+			ret);
+		goto err_v4l2_unregister;
+	}
+
+	dev_info(&pdev->dev, "%d.%s.leave\n", __LINE__, __func__);
+	return 0;
+
+err_enc_workq:
+	v4l2_m2m_release(dev->m2m_dev);
+err_enc_unreg:
+	rtkve_enc_unregister_device(dev);
+err_v4l2_unregister:
+	v4l2_device_unregister(&dev->v4l2_dev);
+exit:
+	dev_err(&pdev->dev, "%d.%s.leave.ret:%d\n", __LINE__, __func__, ret);
+	return ret;
+}
+
+static int rtkve_enc_remove(struct platform_device *pdev)
+{
+	struct vpu_device *dev = dev_get_drvdata(&pdev->dev);
+
+	if (dev->encode_workqueue)
+		destroy_workqueue(dev->encode_workqueue);
+
+	device_remove_file(&pdev->dev, &dev_attr_instance_info);
+	v4l2_m2m_release(dev->m2m_dev);
+	rtkve_enc_unregister_device(dev);
+	v4l2_device_unregister(&dev->v4l2_dev);
+
+	return 0;
+}
+
+static ssize_t rtkve_get_instance_info(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct vpu_device *vdev = dev_get_drvdata(dev);
+	struct vpu_instance *inst = NULL;
+	int len = 0;
+	int enc_cnt = 0;
+
+	list_for_each_entry(inst, &vdev->instances, list) {
+		if (inst) {
+			enc_cnt++;
+		}
+	}
+
+	len += scnprintf(buf + len, PAGE_SIZE - len,
+		"Enc total instance(Hevc) %d\n", enc_cnt);
+	return len;
+}
+
+static const struct of_device_id rtkve_dt_ids[] = {
+	{ .compatible = "realtek,rtd16xxb-ve3", .data = &rtkve3_data_stateful },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, rtkve_dt_ids);
+
+static struct platform_driver rtkve_enc_driver = {
+	.driver = {
+		.name = VPU_PLATFORM_DEVICE_NAME,
+		.of_match_table = of_match_ptr(rtkve_dt_ids),
+		},
+	.probe = rtkve_enc_probe,
+	.remove = rtkve_enc_remove,
+};
+
+module_platform_driver(rtkve_enc_driver);
+MODULE_DESCRIPTION("RTK Video Engine V4L2 encode driver");
+MODULE_LICENSE("Dual BSD/GPL");
--- /dev/null
+++ b/drivers/media/platform/realtek/rtkve/enc/rtkve-enc-v4l2.c
@@ -0,0 +1,609 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video encoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#include <linux/dma-map-ops.h>
+#include <soc/realtek/memory.h>
+#include <soc/realtek/rtk_media_heap.h>
+#include "rtkve-vpu.h"
+
+#define MAX_INSTANCE (2)
+
+void rtkve_update_pix_fmt(struct vpu_instance *inst,
+			  struct v4l2_pix_format_mplane *pix_mp,
+			  unsigned int width, unsigned int height)
+{
+	pix_mp->flags = 0;
+	pix_mp->field = V4L2_FIELD_NONE;
+	memset(pix_mp->reserved, 0, sizeof(pix_mp->reserved));
+
+	switch (pix_mp->pixelformat) {
+	case V4L2_PIX_FMT_NV12:
+		pix_mp->width = width;
+		pix_mp->height = height;
+
+		pix_mp->plane_fmt[0].bytesperline = pix_mp->width;
+		pix_mp->plane_fmt[0].sizeimage =
+			pix_mp->width * pix_mp->height * 3 / 2;
+		break;
+	default:
+		pix_mp->width = width;
+		pix_mp->height = height;
+		pix_mp->plane_fmt[0].bytesperline = 0;
+		if (!pix_mp->plane_fmt[0].sizeimage)
+			pix_mp->plane_fmt[0].sizeimage = width * height;
+		break;
+	}
+}
+
+void rtkve_set_default_format(struct vpu_instance *inst,
+			      struct v4l2_pix_format_mplane *src_fmt,
+			      struct v4l2_pix_format_mplane *dst_fmt)
+{
+	const struct rtkve_match_data *enc_pdata = inst->dev->rtkve_mdata;
+	const struct vpu_format *vpu_fmt;
+
+	vpu_fmt = enc_pdata->find_vpu_fmt_by_idx(0, VPU_FMT_TYPE_RAW);
+
+	src_fmt->pixelformat = vpu_fmt->v4l2_pix_fmt;
+	src_fmt->num_planes = vpu_fmt->num_planes;
+	rtkve_update_pix_fmt(inst, src_fmt, 1920, 1080);
+
+	vpu_fmt = enc_pdata->find_vpu_fmt_by_idx(0, VPU_FMT_TYPE_CODEC);
+
+	dst_fmt->pixelformat = vpu_fmt->v4l2_pix_fmt;
+	dst_fmt->num_planes = vpu_fmt->num_planes;
+	rtkve_update_pix_fmt(inst, dst_fmt, 1920, 1080);
+}
+
+static int rtkve_enc_querycap(struct file *file, void *fh,
+			      struct v4l2_capability *cap)
+{
+	strscpy(cap->driver, VPU_ENC_DRV_NAME, sizeof(cap->driver));
+	strscpy(cap->card, VPU_ENC_DRV_NAME, sizeof(cap->card));
+	strscpy(cap->bus_info, "platform:" VPU_ENC_DRV_NAME,
+		sizeof(cap->bus_info));
+
+	return 0;
+}
+
+static int rtkve_enc_enum_framesizes(struct file *f, void *fh,
+				     struct v4l2_frmsizeenum *fsize)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	const struct rtkve_match_data *dec_pdata = inst->dev->rtkve_mdata;
+	const struct vpu_format *vpu_fmt;
+	int ret = 0;
+
+	if (fsize->index) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	vpu_fmt = dec_pdata->find_vpu_fmt(fsize->pixel_format,
+					  VPU_FMT_TYPE_CODEC);
+	if (!vpu_fmt) {
+		vpu_fmt = dec_pdata->find_vpu_fmt(fsize->pixel_format,
+						  VPU_FMT_TYPE_RAW);
+		if (!vpu_fmt) {
+			ret = -EINVAL;
+			goto exit;
+		}
+	}
+
+	fsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;
+	fsize->stepwise.min_width = vpu_fmt->min_width;
+	fsize->stepwise.max_width = vpu_fmt->max_width;
+	fsize->stepwise.step_width = ENC_PIC_SIZE_STEP;
+	fsize->stepwise.min_height = vpu_fmt->min_height;
+	fsize->stepwise.max_height = vpu_fmt->max_height;
+	fsize->stepwise.step_height = ENC_PIC_SIZE_STEP;
+
+exit:
+	return ret;
+}
+
+static int rtkve_enc_s_parm(struct file *file, void *fh,
+			    struct v4l2_streamparm *a)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	struct v4l2_fract *timeperframe = &a->parm.output.timeperframe;
+	int ret = 0;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (timeperframe->numerator == 0 || timeperframe->denominator == 0) {
+		timeperframe->numerator = DEFAULT_FRAMERATE_DENOM;
+		timeperframe->denominator = DEFAULT_FRAMERATE_NUM;
+	}
+
+	inst->enc_params.framerate_denom = timeperframe->numerator;
+	inst->enc_params.framerate_num = timeperframe->denominator;
+	inst->enc_params.framerate = inst->enc_params.framerate_num /
+				     inst->enc_params.framerate_denom;
+	inst->enc_params.gop_size = inst->enc_params.framerate;
+	a->parm.output.capability = V4L2_CAP_TIMEPERFRAME;
+
+exit:
+	return ret;
+}
+
+static int rtkve_enc_g_parm(struct file *file, void *fh,
+			    struct v4l2_streamparm *a)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	int ret = 0;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	a->parm.output.capability = V4L2_CAP_TIMEPERFRAME;
+	a->parm.output.timeperframe.denominator =
+		inst->enc_params.framerate_num;
+	a->parm.output.timeperframe.numerator =
+		inst->enc_params.framerate_denom;
+
+exit:
+	return ret;
+}
+
+static int rtkve_enc_enum_fmt_cap(struct file *file, void *fh,
+				  struct v4l2_fmtdesc *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	const struct rtkve_match_data *dec_pdata = inst->dev->rtkve_mdata;
+	const struct vpu_format *vpu_fmt;
+	int ret = 0;
+
+	vpu_fmt = dec_pdata->find_vpu_fmt_by_idx(f->index, VPU_FMT_TYPE_CODEC);
+	if (!vpu_fmt) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	f->pixelformat = vpu_fmt->v4l2_pix_fmt;
+	f->flags = 0;
+
+exit:
+	return ret;
+}
+
+static int rtkve_enc_try_fmt_cap(struct file *file, void *fh,
+				 struct v4l2_format *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	const struct rtkve_match_data *dec_pdata = inst->dev->rtkve_mdata;
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	const struct vpu_format *vpu_fmt;
+	int width, height;
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: %p4cc w %d h %d plane %d colorspace %d\n",
+		__func__, &pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	if (!V4L2_TYPE_IS_CAPTURE(f->type)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	vpu_fmt = dec_pdata->find_vpu_fmt(pix_mp->pixelformat,
+					  VPU_FMT_TYPE_CODEC);
+	if (!vpu_fmt) {
+		width = inst->dst_fmt.width;
+		height = inst->dst_fmt.height;
+		pix_mp->pixelformat = inst->dst_fmt.pixelformat;
+		pix_mp->num_planes = inst->dst_fmt.num_planes;
+	} else {
+		width = clamp(pix_mp->width, vpu_fmt->min_width,
+			      inst->src_fmt.width);
+		height = clamp(pix_mp->height, vpu_fmt->min_height,
+			       inst->src_fmt.height);
+		pix_mp->pixelformat = vpu_fmt->v4l2_pix_fmt;
+		pix_mp->num_planes = vpu_fmt->num_planes;
+	}
+
+	rtkve_update_pix_fmt(inst, pix_mp, width, height);
+	pix_mp->colorspace = inst->colorspace;
+	pix_mp->ycbcr_enc = inst->ycbcr_enc;
+	pix_mp->quantization = inst->quantization;
+	pix_mp->xfer_func = inst->xfer_func;
+
+exit:
+	return ret;
+}
+
+static int rtkve_enc_s_fmt_cap(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i, ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: %p4cc w %d h %d plane %d colorspace %d\n",
+		__func__, &pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	ret = rtkve_enc_try_fmt_cap(file, fh, f);
+	if (ret) {
+		dev_err(inst->dev->dev, "rtkve_enc_try_fmt_cap fail");
+		goto exit;
+	}
+
+	inst->dst_fmt.width = pix_mp->width;
+	inst->dst_fmt.height = pix_mp->height;
+	inst->dst_fmt.pixelformat = pix_mp->pixelformat;
+	inst->dst_fmt.field = pix_mp->field;
+	inst->dst_fmt.flags = pix_mp->flags;
+	inst->dst_fmt.num_planes = pix_mp->num_planes;
+	for (i = 0; i < inst->dst_fmt.num_planes; i++) {
+		inst->dst_fmt.plane_fmt[i].bytesperline =
+			pix_mp->plane_fmt[i].bytesperline;
+		inst->dst_fmt.plane_fmt[i].sizeimage =
+			pix_mp->plane_fmt[i].sizeimage;
+	}
+
+	rtkve_update_pix_fmt(inst, &inst->src_fmt, pix_mp->width,
+			     pix_mp->height);
+
+exit:
+	return ret;
+}
+
+static int rtkve_enc_g_fmt_cap(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i;
+
+	pix_mp->width = inst->dst_fmt.width;
+	pix_mp->height = inst->dst_fmt.height;
+	pix_mp->pixelformat = inst->dst_fmt.pixelformat;
+	pix_mp->field = inst->dst_fmt.field;
+	pix_mp->flags = inst->dst_fmt.flags;
+	pix_mp->num_planes = inst->dst_fmt.num_planes;
+	for (i = 0; i < pix_mp->num_planes; i++) {
+		pix_mp->plane_fmt[i].bytesperline =
+			inst->dst_fmt.plane_fmt[i].bytesperline;
+		pix_mp->plane_fmt[i].sizeimage =
+			inst->dst_fmt.plane_fmt[i].sizeimage;
+	}
+
+	pix_mp->colorspace = inst->colorspace;
+	pix_mp->ycbcr_enc = inst->ycbcr_enc;
+	pix_mp->quantization = inst->quantization;
+	pix_mp->xfer_func = inst->xfer_func;
+
+	return 0;
+}
+
+static int rtkve_enc_enum_fmt_out(struct file *file, void *fh,
+				  struct v4l2_fmtdesc *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	const struct rtkve_match_data *dec_pdata = inst->dev->rtkve_mdata;
+	const struct vpu_format *vpu_fmt;
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: index %d\n", __func__, f->index);
+
+	vpu_fmt = dec_pdata->find_vpu_fmt_by_idx(f->index, VPU_FMT_TYPE_RAW);
+	if (!vpu_fmt) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	f->pixelformat = vpu_fmt->v4l2_pix_fmt;
+
+exit:
+	return ret;
+}
+
+static int rtkve_enc_try_fmt_out(struct file *file, void *fh,
+				 struct v4l2_format *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	const struct rtkve_match_data *dec_pdata = inst->dev->rtkve_mdata;
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	const struct vpu_format *vpu_fmt;
+	int width, height;
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s %p4cc w %d h %d plane %d colorspace %d\n",
+		__func__, &pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	if (!V4L2_TYPE_IS_OUTPUT(f->type)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	vpu_fmt =
+		dec_pdata->find_vpu_fmt(pix_mp->pixelformat, VPU_FMT_TYPE_RAW);
+	if (!vpu_fmt) {
+		width = inst->src_fmt.width;
+		height = inst->src_fmt.height;
+		pix_mp->pixelformat = inst->src_fmt.pixelformat;
+		pix_mp->num_planes = inst->src_fmt.num_planes;
+	} else {
+		width = pix_mp->width;
+		height = pix_mp->height;
+		pix_mp->pixelformat = vpu_fmt->v4l2_pix_fmt;
+		pix_mp->num_planes = vpu_fmt->num_planes;
+	}
+
+	rtkve_update_pix_fmt(inst, pix_mp, width, height);
+exit:
+	return ret;
+}
+
+static int rtkve_enc_s_fmt_out(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i, ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: %p4cc w %d h %d plane %d colorspace %d\n",
+		__func__, &pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	ret = rtkve_enc_try_fmt_out(file, fh, f);
+	if (ret) {
+		dev_err(inst->dev->dev, "rtkve_dec_try_fmt_out fail");
+		goto exit;
+	}
+
+	inst->src_fmt.width = pix_mp->width;
+	inst->src_fmt.height = pix_mp->height;
+	inst->src_fmt.pixelformat = pix_mp->pixelformat;
+	inst->src_fmt.field = pix_mp->field;
+	inst->src_fmt.flags = pix_mp->flags;
+	inst->src_fmt.num_planes = pix_mp->num_planes;
+	for (i = 0; i < inst->src_fmt.num_planes; i++) {
+		inst->src_fmt.plane_fmt[i].bytesperline =
+			pix_mp->plane_fmt[i].bytesperline;
+		inst->src_fmt.plane_fmt[i].sizeimage =
+			pix_mp->plane_fmt[i].sizeimage;
+	}
+
+	inst->colorspace = pix_mp->colorspace;
+	inst->ycbcr_enc = pix_mp->ycbcr_enc;
+	inst->quantization = pix_mp->quantization;
+	inst->xfer_func = pix_mp->xfer_func;
+
+	rtkve_update_pix_fmt(inst, &inst->dst_fmt,
+		pix_mp->width, pix_mp->height);
+exit:
+	return ret;
+}
+
+static int rtkve_enc_g_fmt_out(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i;
+
+	pix_mp->width = inst->src_fmt.width;
+	pix_mp->height = inst->src_fmt.height;
+	pix_mp->pixelformat = inst->src_fmt.pixelformat;
+	pix_mp->field = inst->src_fmt.field;
+	pix_mp->flags = inst->src_fmt.flags;
+	pix_mp->num_planes = inst->src_fmt.num_planes;
+	for (i = 0; i < pix_mp->num_planes; i++) {
+		pix_mp->plane_fmt[i].bytesperline =
+			inst->src_fmt.plane_fmt[i].bytesperline;
+		pix_mp->plane_fmt[i].sizeimage =
+			inst->src_fmt.plane_fmt[i].sizeimage;
+	}
+
+	pix_mp->colorspace = inst->colorspace;
+	pix_mp->ycbcr_enc = inst->ycbcr_enc;
+	pix_mp->quantization = inst->quantization;
+	pix_mp->xfer_func = inst->xfer_func;
+
+	return 0;
+}
+
+static int rtkve_enc_reqbufs(struct file *file, void *priv,
+			     struct v4l2_requestbuffers *rb)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(priv);
+	struct vpu_device *dev = inst->dev;
+	const struct rtkve_match_data *enc_pdata = dev->rtkve_mdata;
+	int ret = 0;
+
+	mutex_lock(&dev->dev->mutex);
+	rheap_setup_dma_pools(dev->dev, "rtk_media_heap",
+	                      RTK_FLAG_NONCACHED | RTK_FLAG_SCPUACC |
+	                      RTK_FLAG_VO_POOL, __func__);
+	ret = v4l2_m2m_ioctl_reqbufs(file, priv, rb);
+	mutex_unlock(&dev->dev->mutex);
+	if (ret)
+		goto exit;
+
+	if (V4L2_TYPE_IS_OUTPUT(rb->type)) {
+		inst->reqbuf_out = rb->count;
+	} else {
+		inst->reqbuf_cap = rb->count;
+	}
+
+	if (rb->count != 0 && !inst->enc_hdl) {
+		if (atomic_inc_return(&dev->num_inst) > MAX_INSTANCE) {
+			atomic_dec(&dev->num_inst);
+			dev_err(inst->dev->dev, "Error!!instance limit exceeded (max = %d)\n",
+				MAX_INSTANCE);
+			ret = -EBUSY;
+			goto exit;
+		}
+
+		if (enc_pdata->create_instance)
+			ret = enc_pdata->create_instance(inst);
+	} else if (inst->state != VPU_INST_STATE_NONE &&
+			inst->enc_hdl &&
+			inst->reqbuf_out == 0 && inst->reqbuf_cap == 0) {
+		if (enc_pdata->destroy_instance)
+			enc_pdata->destroy_instance(inst);
+
+		atomic_dec(&dev->num_inst);
+		inst->enc_hdl = NULL;
+	}
+
+exit:
+	return ret;
+}
+
+static int rtkve_enc_subscribe_event(struct v4l2_fh *fh,
+				     const struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_EOS:
+		return v4l2_event_subscribe(fh, sub, 0, NULL);
+	default:
+		return v4l2_ctrl_subscribe_event(fh, sub);
+	}
+}
+
+static int rtkve_enc_cmd(struct file *file, void *priv,
+			 struct v4l2_encoder_cmd *cmd)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(priv);
+	struct v4l2_m2m_ctx *ctx = inst->v4l2_fh.m2m_ctx;
+	struct vb2_v4l2_buffer *buf;
+	int ret;
+
+	ret = v4l2_m2m_ioctl_try_encoder_cmd(file, priv, cmd);
+	if (ret)
+		return ret;
+
+	if (!vb2_is_streaming(v4l2_m2m_get_src_vq(ctx)) ||
+	    !vb2_is_streaming(v4l2_m2m_get_dst_vq(ctx)))
+		return 0;
+
+	switch (cmd->cmd) {
+	case V4L2_ENC_CMD_STOP:
+		buf = v4l2_m2m_last_src_buf(ctx);
+		if (buf) {
+			buf->flags |= V4L2_BUF_FLAG_LAST;
+			inst->eos = true;
+		} else {
+			struct vb2_queue *dst_vq;
+
+			dst_vq = v4l2_m2m_get_vq(ctx,
+						 V4L2_BUF_TYPE_VIDEO_CAPTURE);
+			dst_vq->last_buffer_dequeued = true;
+			wake_up(&dst_vq->done_wq);
+		}
+		break;
+	case V4L2_ENC_CMD_START:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+struct v4l2_ioctl_ops rtkve_enc_ioctl_ops = {
+	.vidioc_querycap = rtkve_enc_querycap,
+	.vidioc_enum_framesizes = rtkve_enc_enum_framesizes,
+
+	.vidioc_s_parm = rtkve_enc_s_parm,
+	.vidioc_g_parm = rtkve_enc_g_parm,
+
+	.vidioc_enum_fmt_vid_cap = rtkve_enc_enum_fmt_cap,
+	.vidioc_s_fmt_vid_cap_mplane = rtkve_enc_s_fmt_cap,
+	.vidioc_g_fmt_vid_cap_mplane = rtkve_enc_g_fmt_cap,
+	.vidioc_try_fmt_vid_cap_mplane = rtkve_enc_try_fmt_cap,
+
+	.vidioc_enum_fmt_vid_out = rtkve_enc_enum_fmt_out,
+	.vidioc_s_fmt_vid_out_mplane = rtkve_enc_s_fmt_out,
+	.vidioc_g_fmt_vid_out_mplane = rtkve_enc_g_fmt_out,
+	.vidioc_try_fmt_vid_out_mplane = rtkve_enc_try_fmt_out,
+
+	.vidioc_reqbufs = rtkve_enc_reqbufs,
+	.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,
+	.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,
+	.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,
+	.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,
+	.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,
+	.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,
+
+	.vidioc_streamon = v4l2_m2m_ioctl_streamon,
+	.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,
+
+	.vidioc_subscribe_event = rtkve_enc_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+
+	.vidioc_encoder_cmd = rtkve_enc_cmd,
+	.vidioc_try_encoder_cmd = v4l2_m2m_ioctl_try_encoder_cmd,
+};
+
+static void rtkve_enc_device_run(void *priv)
+{
+	struct vpu_instance *inst = priv;
+
+	queue_work(inst->dev->encode_workqueue, &inst->encode_work);
+}
+
+static int rtkve_enc_job_ready(void *priv)
+{
+	struct vpu_instance *inst = priv;
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "[%d]%s: state %d\n", inst->id, __func__,
+		inst->state);
+
+	if (inst->state == VPU_INST_STATE_STOP && inst->eos)
+		ret = 0;
+	else
+		ret = 1;
+
+	return ret;
+}
+
+static void rtkve_enc_job_abort(void *priv)
+{
+	struct vpu_instance *inst = priv;
+	struct vpu_device *dev = inst->dev;
+	const struct rtkve_match_data *dec_pdata = dev->rtkve_mdata;
+
+	dev_dbg(inst->dev->dev, "[%d]%s: state %d\n", inst->id, __func__,
+		inst->state);
+
+	dec_pdata->stop_decode(inst);
+}
+
+static const struct v4l2_m2m_ops rtkve_enc_m2m_ops = {
+	.device_run = rtkve_enc_device_run,
+	.job_ready = rtkve_enc_job_ready,
+	.job_abort = rtkve_enc_job_abort,
+};
+
+int rtkve_enc_init_m2m_dev(struct vpu_device *dev)
+{
+	dev->m2m_dev = v4l2_m2m_init(&rtkve_enc_m2m_ops);
+	if (IS_ERR(dev->m2m_dev)) {
+		dev_err(dev->dev, "v4l2_m2m_init fail: %ld\n",
+			PTR_ERR(dev->m2m_dev));
+		return PTR_ERR(dev->m2m_dev);
+	}
+
+	return 0;
+}
--- /dev/null
+++ b/drivers/media/platform/realtek/rtkve/enc/rtkve-rpc-def.h
@@ -0,0 +1,498 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#ifndef RTKVE_RPC_DEF_H
+#define RTKVE_RPC_DEF_H
+
+#include <linux/types.h>
+
+#define RTKVE_MAX_MSG_NUM (32)
+
+#define VIDEO_RPC_VENC_ToAgent_Create 2010
+#define VIDEO_RPC_VENC_ToAgent_InitRingBuffer 2030
+#define VIDEO_RPC_VENC_ToAgent_Run 2040
+#define VIDEO_RPC_VENC_ToAgent_Pause 2050
+#define VIDEO_RPC_VENC_ToAgent_Stop 2060
+#define VIDEO_RPC_VENC_ToAgent_Destroy 2070
+#define VIDEO_RPC_VENC_ToAgent_VideoCreate 2100
+#define VIDEO_RPC_VENC_ToAgent_VideoDestroy 2110
+#define VIDEO_RPC_VENC_ToAgent_VCPU_DEBUG_COMMAND 2141
+#define VIDEO_RPC_VENC_ToAgent_Self_Destroy 2170
+#define VIDEO_RPC_VENC_ToAgent_Init 2510
+#define VIDEO_RPC_VENC_ToAgent_SetNewResolution 2535
+#define VIDEO_RPC_VENC_ToAgent_SetBitRate 2540
+#define VIDEO_RPC_VENC_ToAgent_SetGOPStructure 2550
+#define VIDEO_RPC_VENC_ToAgent_SetEncodeFormat 2610
+#define VIDEO_RPC_VENC_ToAgent_StartRecord 2640
+#define VIDEO_RPC_VENC_ToAgent_PauseRecord 2650
+#define VIDEO_RPC_VENC_ToAgent_StopRecord 2660
+#define VIDEO_RPC_VENC_ToAgent_SetFrameRate 2740
+#define VIDEO_RPC_VENC_ToAgent_ReqKeyFrame 2750
+#define VIDEO_RPC_VENC_ToAgent_SetProfile 2760
+
+typedef int HRESULT;
+#define VIDEO_RPC_DEC_ToSystem_FatalError 63
+#define VIDEO_RPC_DEC_ToSystem_Deliver_MediaInfo 1020
+#define VIDEO_RPC_ToSystem_VoutMessage 1021
+#define REPLYID 99 // for registering the Reply_Handler
+
+enum RINGBUFFER_TYPE {
+	RINGBUFFER_STREAM,
+	RINGBUFFER_COMMAND,
+	RINGBUFFER_MESSAGE,
+	RINGBUFFER_VBI,
+	RINGBUFFER_PTS,
+	RINGBUFFER_DTVCC,
+	RINGBUFFER_STREAM1,
+	RINGBUFFER_COMMAND1,
+	RINGBUFFER_MESSAGE1,
+	RINGBUFFER_STREAM_BL,
+	RINGBUFFER_COMMAND_BL,
+	RINGBUFFER_STREAM_EL,
+	RINGBUFFER_COMMAND_EL,
+	RINGBUFFER_STREAM_MD,
+	RINGBUFFER_COMMAND_MD,
+	RINGBUFFER_STREAM_SUBES,
+	RINGBUFFER_COMMAND_SUBIB,
+	RINGBUFFER_FRAME_USER,
+	RINGBUFFER_V4L2_CONTROL,
+	RINGBUFFER_FAKE
+};
+
+enum VIDEO_VF_TYPE {
+	VF_TYPE_VIDEO_MPEG2_DECODER = 0,
+	VF_TYPE_VIDEO_MPEG4_DECODER = 1,
+	VF_TYPE_VIDEO_DV_DECODER = 2,
+	VF_TYPE_VIDEO_H263_DECODER = 3,
+	VF_TYPE_VIDEO_H264_DECODER = 4,
+	VF_TYPE_VIDEO_VC1_DECODER = 5,
+	VF_TYPE_VIDEO_REAL_DECODER = 6,
+	VF_TYPE_VIDEO_JPEG_DECODER = 7,
+	VF_TYPE_VIDEO_MJPEG_DECODER = 8,
+	VF_TYPE_SPU_DECODER = 9,
+	VF_TYPE_VIDEO_OUT = 10,
+	VF_TYPE_TRANSITION = 11,
+	VF_TYPE_THUMBNAIL = 12,
+	VF_TYPE_VIDEO_VP6_DECODER = 13,
+	VF_TYPE_VIDEO_IMAGE_DECODER = 14,
+	VF_TYPE_FLASH = 15,
+	VF_TYPE_VIDEO_AVS_DECODER = 16,
+	VF_TYPE_MIXER = 17,
+	VF_TYPE_VIDEO_VP8_DECODER = 18,
+	VF_TYPE_VIDEO_WMV7_DECODER = 19,
+	VF_TYPE_VIDEO_WMV8_DECODER = 20,
+	VF_TYPE_VIDEO_RAW_DECODER = 21,
+	VF_TYPE_VIDEO_THEORA_DECODER = 22,
+	VF_TYPE_VIDEO_FJPEG_DECODER = 23,
+	VF_TYPE_VIDEO_H265_DECODER = 24,
+	VF_TYPE_VIDEO_VP9_DECODER = 25,
+	VF_TYPE_VIDEO_H264lv51_DECODER = 26,
+	VF_TYPE_VIDEO_CAPTURER = 27,
+	VF_TYPE_RAWCONV = 28,
+	VF_TYPE_TVD = 29,
+	VF_TYPE_VIDEO_ENCODER = 30,
+	VF_TYPE_VIDEO_SPLITTER = 31,
+	VF_TYPE_VIDEO_AVS2_DECODER = 32,
+	VF_TYPE_VIDEO_AV1_DECODER = 33,
+};
+
+enum VIDEO_STREAM_TYPE {
+	VIDEO_STREAM_MPEG1 = 0,
+	VIDEO_STREAM_MPEG2 = 1,
+	VIDEO_STREAM_MPEG4 = 2,
+	VIDEO_STREAM_DV3 = 3,
+	VIDEO_STREAM_H263 = 4,
+	VIDEO_STREAM_H264 = 5,
+	VIDEO_STREAM_VC1 = 6,
+	VIDEO_STREAM_REALVIDEO = 7,
+	VIDEO_STREAM_MJPEG = 8,
+	VIDEO_STREAM_VP6 = 9,
+	VIDEO_STREAM_AVS = 10,
+	VIDEO_STREAM_YUV = 11,
+	VIDEO_STREAM_VP8 = 12,
+	VIDEO_STREAM_WMV7 = 13,
+	VIDEO_STREAM_WMV8 = 14,
+	VIDEO_STREAM_RAW = 15,
+	VIDEO_STREAM_THEORA = 16,
+	VIDEO_STREAM_UNKNOWN = 17,
+	VIDEO_STREAM_FJPEG = 18,
+	VIDEO_STREAM_H265 = 19,
+	VIDEO_STREAM_VP9 = 20,
+	VIDEO_STREAM_H264lv51 = 21,
+	VIDEO_STREAM_AVS2 = 22,
+	VIDEO_STREAM_AV1 = 23,
+};
+
+/** inband cmd type. I use prefix "VIDEO_DEC_" to label the cmd used in video decoder. */
+enum INBAND_CMD_TYPE {
+	INBAND_CMD_TYPE_PTS = 0,
+	INBAND_CMD_TYPE_PTS_SKIP,
+	INBAND_CMD_TYPE_NEW_SEG,
+	INBAND_CMD_TYPE_SEQ_END,
+	INBAND_CMD_TYPE_EOS,
+	INBAND_CMD_TYPE_CONTEXT,
+	INBAND_CMD_TYPE_DECODE,
+
+	/* Video Decoder In-band Command */
+	VIDEO_DEC_INBAND_CMD_TYPE_VOBU,
+	VIDEO_DEC_INBAND_CMD_TYPE_DVDVR_DCI_CCI,
+	VIDEO_DEC_INBAND_CMD_TYPE_DVDV_VATR,
+
+	/* MSG Type for parse mode */
+	VIDEO_DEC_INBAND_CMD_TYPE_SEG_INFO,
+	VIDEO_DEC_INBAND_CMD_TYPE_PIC_INFO,
+
+	/* Sub-picture Decoder In-band Command */
+	VIDEO_SUBP_INBAND_CMD_TYPE_SET_PALETTE,
+	VIDEO_SUBP_INBAND_CMD_TYPE_SET_HIGHLIGHT,
+
+	/* Video Mixer In-band Command */
+	VIDEO_MIXER_INBAND_CMD_TYPE_SET_BG_COLOR,
+	VIDEO_MIXER_INBAND_CMD_TYPE_SET_MIXER_RPTS,
+	VIDEO_MIXER_INBAND_CMD_TYPE_BLEND,
+
+	/* Video Scaler In-band Command */
+	VIDEO_SCALER_INBAND_CMD_TYPE_OUTPUT_FMT,
+
+	/*Dv3 resolution In-band Command*/
+	VIDEO_DV3_INBAND_CMD_TYPE_RESOLUTION,
+
+	/*MPEG4 detected In-band command*/
+	VIDEO_MPEG4_INBAND_CMD_TYPE_MP4,
+	/* Audio In-band Commands Start Here */
+
+	/* DV In-band Commands */
+	VIDEO_DV_INBAND_CMD_TYPE_VAUX,
+	VIDEO_DV_INBAND_CMD_TYPE_FF, //fast forward
+
+	/* Transport Demux In-band command */
+	VIDEO_TRANSPORT_DEMUX_INBAND_CMD_TYPE_PID,
+	VIDEO_TRANSPORT_DEMUX_INBAND_CMD_TYPE_PTS_OFFSET,
+	VIDEO_TRANSPORT_DEMUX_INBAND_CMD_TYPE_PACKET_SIZE,
+
+	/* Real Video In-band command */
+	VIDEO_RV_INBAND_CMD_TYPE_FRAME_INFO,
+	VIDEO_RV_INBAND_CMD_TYPE_FORMAT_INFO,
+	VIDEO_RV_INBAND_CMD_TYPE_SEGMENT_INFO,
+
+	/*VC1 video In-band command*/
+	VIDEO_VC1_INBAND_CMD_TYPE_SEQ_INFO,
+
+	/* general video properties */
+	VIDEO_INBAND_CMD_TYPE_VIDEO_USABILITY_INFO,
+	VIDEO_INBAND_CMD_TYPE_VIDEO_MPEG4_USABILITY_INFO,
+
+	/*MJPEG resolution In-band Command*/
+	VIDEO_MJPEG_INBAND_CMD_TYPE_RESOLUTION,
+
+	/* picture object for graphic */
+	VIDEO_GRAPHIC_INBAND_CMD_TYPE_PICTURE_OBJECT,
+	VIDEO_GRAPHIC_INBAND_CMD_TYPE_DISPLAY_INFO,
+
+	/* subtitle offset sequence id for 3D video */
+	VIDEO_DEC_INBAND_CMD_TYPE_SUBP_OFFSET_SEQUENCE_ID,
+
+	VIDEO_H264_INBAND_CMD_TYPE_DPBBYPASS,
+
+	/* Clear back frame to black color and send it to VO */
+	VIDEO_FJPEG_INBAND_CMD_TYPE_CLEAR_SCREEN,
+
+	/* each picture info of MJPEG */
+	VIDEO_FJPEG_INBAND_CMD_TYPE_PIC_INFO,
+
+	/*FJPEG resolution In-band Command*/
+	VIDEO_FJPEG_INBAND_CMD_TYPE_RESOLUTION,
+
+	/*VO receive VP_OBJ_PICTURE_TYPE In-band Command*/
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_PIC,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_DVD_SP,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_DVB_SP,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_BD_SP,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_SP_FLUSH,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_SP_RESOLUTION,
+
+	/* VO receive writeback buffers In-band Command */
+	VIDEO_VO_INBAND_CMD_TYPE_WRITEBACK_BUFFER,
+
+	/* for VO debug, VO can dump picture */
+	VIDEO_VO_INBAND_CMD_TYPE_DUMP_PIC,
+	VIDEO_CURSOR_INBAND_CMD_TYPE_PICTURE_OBJECT,
+	VIDEO_CURSOR_INBAND_CMD_TYPE_COORDINATE_OBJECT,
+	VIDEO_TRANSCODE_INBAND_CMD_TYPE_PICTURE_OBJECT,
+	VIDEO_WRITEBACK_INBAND_CMD_TYPE_PICTURE_OBJECT,
+
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_BD_SCALE_RGB_SP,
+
+	// TV code
+	VIDEO_INBAND_CMD_TYPE_DV_CERTIFY,
+
+	/*M_DOMAIN resolution In-band Command*/
+	VIDEO_INBAND_CMD_TYPE_M_DOMAIN_RESOLUTION,
+
+	/* DTV source In-band Command */
+	VIDEO_INBAND_CMD_TYPE_SOURCE_DTV,
+
+	/* Din source copy mode In-band Command */
+	VIDEO_DIN_INBAND_CMD_TYPE_COPY_MODE,
+
+	/* Video Decoder AU In-band command */
+	VIDEO_DEC_INBAND_CMD_TYPE_AU,
+
+	/* Video Decoder parse frame In-band command */
+	VIDEO_DEC_INBAND_CMD_TYPE_PARSE_FRAME_IN,
+	VIDEO_DEC_INBAND_CMD_TYPE_PARSE_FRAME_OUT,
+
+	/* Set video decode mode In-band command */
+	VIDEO_DEC_INBAND_CMD_TYPE_NEW_DECODE_MODE,
+
+	/* Secure buffer protection */
+	VIDEO_INBAND_CMD_TYPE_SECURE_PROTECTION,
+
+	/* Dolby HDR inband command */
+	VIDEO_DEC_INBAND_CMD_TYPE_DV_PROFILE,
+
+	/* VP9 HDR10 In-band command */
+	VIDEO_VP9_INBAND_CMD_TYPE_HDR10_METADATA,
+
+	/* AV1 HDR10 In-band command */
+	VIDEO_AV1_INBAND_CMD_TYPE_HDR10_METADATA,
+
+	/* DvdPlayer tell RVSD video BS ring buffer is full */
+	VIDEO_DEC_INBAND_CMD_TYPE_BS_RINGBUF_FULL,
+
+	/* Frame Boundary In-band command */
+	VIDEO_INBAND_CMD_TYPE_FRAME_BOUNDARY = 100,
+
+	/* VO receive npp writeback buffers In-band Command */
+	VIDEO_NPP_INBAND_CMD_TYPE_WRITEBACK_BUFFER,
+	VIDEO_NPP_OUT_INBAND_CMD_TYPE_OBJ_PIC,
+
+	/* hevc encoder raw yuv data In-band Commnad */
+	VENC_INBAND_CMD_TYPE_RAWYUV,
+
+	/* hevc encoder ref yuv addr In-band Commnad */
+	VENC_INBAND_CMD_TYPE_REFYUV,
+
+	/* add frame info for user allocate */
+	VIDEO_FRAME_INBAND_ADD,
+
+	/* delete frame info for user allocate */
+	VIDEO_FRAME_INBAND_DELETE,
+
+	VIDEO_AV1_INBAND_CMD_TYPE_V4L2_CTRL = 108,
+	VIDEO_HEVC_INBAND_CMD_TYPE_V4L2_CTRL = 109,
+	VIDEO_VP9_INBAND_CMD_TYPE_V4L2_CTRL = 110,
+};
+
+enum ENUM_DVD_VIDEO_ENCODER_OUTPUT_INFO_TYPE {
+	VIDEOENCODER_VideoGEN,
+	VIDEOENCODER_VideoFrameInfo,
+	VIDEOENCODER_VideoVBID_WSS_Info,
+	VIDEOENCODER_VideoEndOfStream_Info,
+	VIDEOENCODER_Input_EndOfStream_Info,
+	VIDEOENCODER_VideoPauseInfo,
+	VIDEOENCODER_AutoPauseInfo,
+	VIDEOENCODER_TotalInfo
+};
+
+enum YUV_FMT {
+	F_YUV420_Semi = 0,
+	F_YUV420P = 1,
+	F_YUV422 = 2,
+	F_YUYV422 = 3,
+	F_ARGB = 4,
+	F_MMCOMP = 5,
+};
+
+enum VIDEO_ENC_PROFILE {
+	VIDEO_PROFILE_MAIN = 0,
+	VIDEO_PROFILE_MAIN10 = 1,
+};
+
+enum VIDEO_RATE_CONTROL_MODE {
+	VIDEO_RATE_CBR = 0,
+	VIDEO_RATE_VBR = 1,
+	VIDEO_RATE_CVBR = 2,
+};
+
+struct _tagRingBufferHeader {
+	volatile uint32_t magic; //Magic number
+	volatile uint32_t beginAddr;
+	volatile uint32_t size;
+	volatile uint32_t
+		bufferID; // RINGBUFFER_TYPE, choose a type from RINGBUFFER_TYPE
+	volatile uint32_t writePtr;
+	volatile uint32_t numOfReadPtr;
+	volatile uint32_t reserve2; //Reserve for Red Zone
+	volatile uint32_t reserve3; //Reserve for Red Zone
+	volatile uint32_t readPtr[4];
+	volatile int32_t fileOffset;
+	volatile int32_t requestedFileOffset;
+	volatile int32_t fileSize;
+	volatile int32_t bSeekable; //Can't be sought if data is streamed by HTTP
+};
+
+struct RPC_RINGBUFFER {
+	uint32_t instanceID;
+	uint32_t pinID;
+	uint32_t readPtrIndex;
+	uint32_t pRINGBUFF_HEADER;
+};
+
+struct VIDEO_RPC_ENC_ELEM_FRAME_INFO {
+	enum ENUM_DVD_VIDEO_ENCODER_OUTPUT_INFO_TYPE infoType;
+	unsigned int pictureNumber;
+	unsigned char pictureType;
+	unsigned char topFieldFirst;
+	unsigned char numOfField;
+	unsigned char newScene;
+	unsigned int PTShigh;
+	unsigned int PTSlow;
+	unsigned int DTShigh;
+	unsigned int DTSlow;
+	unsigned int VBIData;
+	unsigned int VBVfullness;
+	unsigned char resumedVideoFrame;
+	unsigned char newVOBUStart;
+	unsigned char KeyFrame;
+	unsigned char AGCDetection;
+	unsigned int CCData;
+	unsigned int CCStatus;
+	int frameSize;
+	unsigned int buf_idx;
+};
+
+struct VIDEO_RPC_ENC_INIT {
+	uint32_t instanceID;
+	uint32_t type;
+	enum YUV_FMT yuvFormat;
+};
+
+struct VIDEO_RPC_ENC_SET_ENCFORMAT {
+	uint32_t instanceID;
+	enum VIDEO_STREAM_TYPE streamType;
+};
+
+struct VIDEO_RPC_ENC_SET_NEW_RESOLUTION {
+	uint32_t instanceID;
+	uint32_t in_width;
+	uint32_t in_height;
+	uint32_t out_width;
+	uint32_t out_height;
+	uint32_t bit_depth;
+};
+
+struct VIDEO_RPC_ENC_SET_GOPSTRUCTURE {
+	uint32_t instanceID;
+	uint32_t M;
+	uint32_t N;
+};
+
+struct VIDEO_RPC_ENC_SET_PROFILE {
+	uint32_t instanceID;
+	enum VIDEO_ENC_PROFILE profile;
+};
+
+struct VIDEO_RPC_ENC_SET_BITRATE {
+	uint32_t instanceID;
+	enum VIDEO_RATE_CONTROL_MODE rateControlMode;
+	uint32_t peakBitRate;
+	uint32_t aveBitRate;
+	uint32_t bitBufferSize;
+	uint32_t initBufferFullness;
+	uint32_t time;
+};
+
+struct VIDEO_RPC_ENC_SET_FRAME_RATE {
+	uint32_t instanceID;
+	uint32_t frame_rate;
+};
+
+struct VIDEO_RPC_ENC_REQ_KEY_FRAME {
+	uint32_t instanceID;
+};
+
+struct VIDEO_RPC_ENC_START_ENC {
+	uint32_t instanceID;
+	uint32_t startMode;
+};
+
+struct VIDEO_RPC_ENC_STOP_ENC {
+	uint32_t instanceID;
+};
+
+struct RPC_STRUCT {
+	uint32_t programID; // program ID defined in IDL file
+	uint32_t versionID; // version ID defined in IDL file
+	uint32_t procedureID; // function ID defined in IDL file
+	uint32_t taskID; // the caller's task ID, assign 0 if NONBLOCK_MODE
+	uint32_t sysTID;
+	uint32_t sysPID; // the callee's task ID
+	uint32_t parameterSize; // packet's body size
+	uint32_t context; // return address of reply value
+};
+
+struct RPC_CONNECTION {
+	uint32_t srcInstanceID;
+	uint32_t srcPinID;
+	uint32_t desInstanceID;
+	uint32_t desPinID;
+	uint32_t mediaType;
+};
+
+struct RPCRES_LONG {
+	uint32_t result;
+	uint32_t data;
+};
+
+//inband
+struct INBAND_CMD_PKT_HEADER {
+	enum INBAND_CMD_TYPE type;
+	uint32_t size;
+};
+
+struct VIDEO_RPC_INSTANCE {
+	enum VIDEO_VF_TYPE type;
+};
+
+struct PTS_INFO {
+	struct INBAND_CMD_PKT_HEADER header;
+	unsigned int wPtr;
+	unsigned int PTSH;
+	unsigned int PTSL;
+};
+
+struct RAWYUV_INFO {
+	struct INBAND_CMD_PKT_HEADER header;
+	unsigned int luma_addr;
+	unsigned int luma_size;
+	unsigned int chroma_addr;
+	unsigned int chroma_size;
+	unsigned int PTSH;
+	unsigned int PTSL;
+	unsigned int buf_index;
+};
+
+struct REFYUV_INFO {
+	struct INBAND_CMD_PKT_HEADER header;
+	unsigned int start_addr;
+	unsigned int size;
+};
+
+struct EOS {
+	struct INBAND_CMD_PKT_HEADER header;
+	unsigned int wPtr;
+	unsigned int eventID;
+};
+
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/rtkve/enc/rtkve-rpc.c
@@ -0,0 +1,1090 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video encoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+
+#include <media/v4l2-ioctl.h>
+
+#include <soc/realtek/rtk-krpc-agent.h>
+
+#include "rtkve-rpc.h"
+#include "rtkve-common.h"
+
+#define RPC_BUF_SIZE (1024)
+#define STREAM_RBSIZE (0x600000)
+#define COMMAND_RBSIZE (0x40000)
+#define SIZE_4MB (4194304) //1024 * 1024 * 4
+#define SIZE_2MB (2097152) //1024 * 1024 * 2
+//Ref frame buffer size (1920 * 1152) * 6 + 18656 * 2 + 8160 * 2 = 13324672
+#define REF_FRM_BUF_SIZE (13324672)
+
+static struct rtk_krpc_ept_info *get_ve3_krpc_info(void)
+{
+	struct device_node *np;
+	struct rtk_krpc_ept_info *vcpu_ept_info = NULL;
+
+	np = of_find_compatible_node(NULL, NULL, "realtek,ve3rpc");
+	if (!np) {
+		pr_err("Get ve3 rpc node from device tree fail");
+		goto exit;
+	}
+
+	vcpu_ept_info = of_krpc_ept_info_get(np, 0);
+exit:
+	return vcpu_ept_info;
+}
+
+static int SendReply(struct rtk_krpc_ept_info *krpc_ept_info,
+		     uint32_t req_taskID, int32_t req_context,
+		     char *ReplyParameter, // parameter's start address
+		     uint32_t ParameterSize) // parameter's size
+{
+	ssize_t val;
+	struct rpc_struct *rpc;
+	char *mem_ToShm;
+	char *p;
+	int size_ToShm = 0; // total mem size for writing to share memory
+	uint32_t *context;
+	int ret = 0;
+
+	mem_ToShm = kmalloc(sizeof(struct RPC_STRUCT) + sizeof(uint32_t) +
+				    ParameterSize,
+			    GFP_KERNEL | __GFP_ZERO);
+	if (!mem_ToShm) {
+		pr_err("SendReply malloc fail\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+	p = mem_ToShm;
+	rpc = (struct rpc_struct *)p;
+	p += sizeof(struct rpc_struct);
+	context = (uint32_t *)p;
+	*context = htonl(req_taskID);
+	size_ToShm += sizeof(uint32_t);
+	p += sizeof(uint32_t);
+	for (context = (uint32_t *)p; (char *)context < p + ParameterSize;
+	     context++) {
+		*context = *ReplyParameter;
+		ReplyParameter += sizeof(uint32_t);
+	}
+	size_ToShm += ParameterSize;
+	rpc->programID = REPLYID;
+	rpc->versionID = REPLYID;
+	rpc->procedureID = 0;
+	rpc->mycontext = req_context; // fill in req's para addr
+	rpc->taskID = 0xffffffff;
+	rpc->sysPID = 0xffffffff;
+	rpc->parameterSize = size_ToShm;
+	size_ToShm += sizeof(struct rpc_struct);
+	val = rtk_send_rpc(krpc_ept_info, mem_ToShm, size_ToShm);
+	if (val != size_ToShm) {
+		pr_err("ve2RPC: ERROR in send kernel RPC\n");
+		ret = -EINVAL;
+	}
+	kfree(mem_ToShm);
+
+exit:
+	return ret;
+}
+
+static int handle_rpc_command(struct rtk_krpc_ept_info *krpc_ept_info,
+			      char *buf)
+{
+	struct vpu_handler *hndl = (struct vpu_handler *)krpc_ept_info->priv;
+	int cmd;
+	HRESULT retval = S_OK;
+	struct rpc_struct *rpc_head = (struct rpc_struct *)buf;
+	int ret = 0;
+
+	dev_dbg(hndl->dev, "rpc_kern_ve3_read, cmd %d, count %lu, size %d\n",
+		rpc_head->procedureID, sizeof(rpc_head),
+		rpc_head->parameterSize);
+	cmd = rpc_head->procedureID;
+	switch (cmd) {
+	default:
+		break;
+	}
+	if (rpc_head->taskID != 0)
+		SendReply(hndl->vcpu_ept_info, rpc_head->taskID,
+			  rpc_head->mycontext, (char *)&retval, sizeof(retval));
+
+	return ret;
+}
+
+static int krpc_vcpu_cb(struct rtk_krpc_ept_info *krpc_ept_info, char *buf)
+{
+	uint32_t *tmp;
+	struct rpc_struct *rpc = (struct rpc_struct *)buf;
+
+	if (rpc->programID == REPLYID) {
+		tmp = (uint32_t *)(buf + sizeof(struct rpc_struct));
+		*(krpc_ept_info->retval) = *(tmp + 1);
+
+		complete(&krpc_ept_info->ack);
+	} else {
+		handle_rpc_command(krpc_ept_info, buf);
+	}
+
+	return 0;
+}
+
+static char *prepare_rpc_data(struct rtk_krpc_ept_info *krpc_ept_info,
+			      uint32_t command, uint32_t param1,
+			      uint32_t param2, int *len)
+{
+	struct rpc_struct *rpc;
+	uint32_t *tmp;
+	char *buf;
+
+	*len = sizeof(struct rpc_struct) + 3 * sizeof(uint32_t);
+	buf = kmalloc(sizeof(struct rpc_struct) + 3 * sizeof(uint32_t),
+		      GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	rpc = (struct rpc_struct *)buf;
+	rpc->programID = KERNELID;
+	rpc->versionID = KERNELID;
+	rpc->procedureID = 0;
+	rpc->taskID = krpc_ept_info->id;
+	rpc->sysTID = krpc_ept_info->id;
+	rpc->sysPID = krpc_ept_info->id;
+	rpc->parameterSize = 3 * sizeof(uint32_t);
+	rpc->mycontext = 0;
+	tmp = (uint32_t *)(buf + sizeof(struct rpc_struct));
+	*tmp = command;
+	*(tmp + 1) = param1;
+	*(tmp + 2) = param2;
+
+	return buf;
+}
+
+int rtkve_send_rpc(struct rtk_krpc_ept_info *krpc_ept_info, char *buf, int len,
+		   uint32_t *retval)
+{
+	int ret = 0;
+
+	mutex_lock(&krpc_ept_info->send_mutex);
+
+	krpc_ept_info->retval = retval;
+	rtk_send_rpc(krpc_ept_info, buf, len);
+	if (!wait_for_completion_timeout(&krpc_ept_info->ack, RPC_TIMEOUT)) {
+		pr_err("[%s]kernel rpc timeout: %s...\n", __func__,
+		       krpc_ept_info->name);
+		rtk_krpc_dump_ringbuf_info(krpc_ept_info);
+		mutex_unlock(&krpc_ept_info->send_mutex);
+		ret = -EINVAL;
+		goto exit;
+	}
+	mutex_unlock(&krpc_ept_info->send_mutex);
+
+exit:
+	return ret;
+}
+
+static int send_rpc(struct vpu_handler *hndl, int opt, uint32_t command,
+		    uint32_t param1, uint32_t param2, uint32_t *retval)
+{
+	int ret = 0;
+	char *buf;
+	int len;
+
+	if (opt == RPC_VIDEO) {
+		buf = prepare_rpc_data(hndl->vcpu_ept_info, command, param1,
+				       param2, &len);
+		if (!IS_ERR(buf)) {
+			ret = rtkve_send_rpc(hndl->vcpu_ept_info, buf, len,
+					     retval);
+			kfree(buf);
+		}
+	}
+
+	return ret;
+}
+
+static int rtkve_rpc_shuttle(struct vpu_handler *hndl, int cmd, void *data,
+			     int size, void *rpc_ret, int rpc_ret_size)
+{
+	struct vpu_buf *rpc_buf;
+	int offset;
+	uint32_t dat;
+	unsigned int RPC_ret;
+	int ret = 0;
+
+	rpc_buf = rtkve_allocate_dma_memory(hndl->dev, RPC_BUF_SIZE, true);
+	if (!rpc_buf) {
+		dev_err(hndl->dev,
+			"%s: Allocating shuttle buf of size %d, fail: %d\n",
+			__func__, RPC_BUF_SIZE, ret);
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	memcpy_toio(rpc_buf->vaddr, data, size);
+	dsb(sy);
+	offset = get_rpc_alignment_offset(size);
+	dat = rpc_buf->daddr;
+
+	if (send_rpc(hndl, RPC_VIDEO, cmd, dat, dat + offset, &RPC_ret)) {
+		dev_err(hndl->dev, "rtkve rpc shuttle fail, cmd %d\n", cmd);
+		ret = -EPERM;
+	} else {
+		if (RPC_ret == S_OK) {
+			if (rpc_ret)
+				memcpy_toio(rpc_ret, rpc_buf->vaddr + offset,
+					    rpc_ret_size);
+			ret = 0;
+		} else {
+			dev_err(hndl->dev, "rtkve rpc return fail, cmd %d\n",
+				cmd);
+			ret = -EPERM;
+		}
+	}
+
+	if (rpc_buf)
+		rtkve_free_dma_memory(hndl->dev, rpc_buf);
+exit:
+	return ret;
+}
+
+int rtkve_rpc_open(struct vpu_handler *hndl, int type)
+{
+	struct VIDEO_RPC_INSTANCE instance;
+	struct RPCRES_LONG retval;
+	unsigned int ret = 0;
+
+	if (!hndl) {
+		pr_err("%s, handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	hndl->vcpu_ept_info = get_ve3_krpc_info();
+	ret = krpc_info_init(hndl->vcpu_ept_info, "ve3rpc", krpc_vcpu_cb);
+	if (ret) {
+		dev_err(hndl->dev, "%s krpc_info_init fail\n",
+			v4l2_type_names[hndl->type]);
+		goto exit;
+	}
+	hndl->vcpu_ept_info->priv = (void *)hndl;
+
+	instance.type = htonl(type);
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_VENC_ToAgent_Create, &instance,
+				sizeof(instance), &retval, sizeof(retval));
+	if (ret) {
+		dev_err(hndl->dev, "fail to open encoder(%s)\n",
+			v4l2_type_names[hndl->type]);
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+	hndl->inst_type = type;
+	if (htonl(retval.result) == S_OK) {
+		hndl->inst_id = htonl(retval.data);
+	} else {
+		dev_err(hndl->dev, "fail to get instance(%s)\n",
+			v4l2_type_names[hndl->type]);
+		mutex_unlock(&hndl->lock);
+		ret = (-EPERM);
+	}
+	mutex_unlock(&hndl->lock);
+exit:
+	return ret;
+}
+
+int rtkve_rpc_close(struct vpu_handler *hndl)
+{
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+	if (hndl->inst_id) {
+		uint32_t inst_id;
+		int ret;
+
+		inst_id = htonl(hndl->inst_id);
+		ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_VENC_ToAgent_Destroy,
+					&inst_id, sizeof(inst_id), NULL, 0);
+		if (ret) {
+			mutex_unlock(&hndl->lock);
+			dev_err(hndl->dev, "fail to close encoder\n");
+			ret = -EPERM;
+			goto exit;
+		}
+	}
+
+	krpc_info_deinit(hndl->vcpu_ept_info);
+	krpc_ept_info_put(hndl->vcpu_ept_info);
+
+	hndl->inst_type = -1;
+	hndl->inst_id = -1;
+	mutex_unlock(&hndl->lock);
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_set_srcfmt(struct vpu_handler *hndl, enum YUV_FMT fmt)
+{
+	struct VIDEO_RPC_ENC_INIT info;
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, encoder handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->inst_id);
+	info.type = htonl(VF_TYPE_VIDEO_ENCODER);
+	info.yuvFormat = htonl(fmt);
+	dev_dbg(hndl->dev, "%s : fmt %d", __func__, htonl(fmt));
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_VENC_ToAgent_Init, &info,
+				sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do Init cmd\n");
+		ret = (-EPERM);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_set_encfmt(struct vpu_handler *hndl, enum VIDEO_STREAM_TYPE fmt)
+{
+	struct VIDEO_RPC_ENC_SET_ENCFORMAT info;
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, encoder handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->inst_id);
+	info.streamType = htonl(fmt);
+	dev_dbg(hndl->dev, "%s : fmt %d", __func__, htonl(fmt));
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_VENC_ToAgent_SetEncodeFormat,
+				&info, sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do SetEncodeFormat cmd\n");
+		ret = (-EPERM);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_set_resolution(struct vpu_handler *hndl, uint32_t in_width,
+			     uint32_t in_height, uint32_t out_width, uint32_t out_height)
+{
+	struct VIDEO_RPC_ENC_SET_NEW_RESOLUTION info;
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, encoder handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->inst_id);
+	info.in_height = htonl(in_height);
+	info.in_width = htonl(in_width);
+	info.out_height = htonl(out_height);
+	info.out_width = htonl(out_width);
+	info.bit_depth = htonl(8);
+	dev_dbg(hndl->dev, "%s : in %dx%d, out %dx%d", __func__,
+		htonl(info.in_width), htonl(info.in_height),
+		htonl(info.out_width), htonl(info.out_height));
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_VENC_ToAgent_SetNewResolution,
+				&info, sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do SetNewResolution cmd\n");
+		ret = (-EPERM);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_set_GOPStruct(struct vpu_handler *hndl, uint32_t M, uint32_t N)
+{
+	struct VIDEO_RPC_ENC_SET_GOPSTRUCTURE info;
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, encoder handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->inst_id);
+	info.M = htonl(M);
+	info.N = htonl(N);
+	dev_dbg(hndl->dev, "%s : M %d, N %d", __func__, M, N);
+
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_VENC_ToAgent_SetGOPStructure,
+				&info, sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do SetGOPStructure cmd\n");
+		ret = (-EPERM);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_set_profile(struct vpu_handler *hndl,
+			  enum VIDEO_ENC_PROFILE profile)
+{
+	struct VIDEO_RPC_ENC_SET_PROFILE info;
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, encoder handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->inst_id);
+	info.profile = htonl(profile);
+	dev_dbg(hndl->dev, "%s : profile %d", __func__, profile);
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_VENC_ToAgent_SetProfile, &info,
+				sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do SetBitRate cmd\n");
+		ret = (-EPERM);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_set_bitrate(struct vpu_handler *hndl, uint32_t mode,
+			  uint32_t bitrate)
+{
+	struct VIDEO_RPC_ENC_SET_BITRATE info;
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, encoder handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->inst_id);
+	info.rateControlMode = htonl(mode);
+	info.peakBitRate = htonl(bitrate);
+	info.aveBitRate = htonl(bitrate);
+	info.bitBufferSize = htonl(SIZE_4MB);
+	info.initBufferFullness = htonl(SIZE_2MB);
+	dev_dbg(hndl->dev, "%s : mode %d, bitrate %d", __func__, mode, bitrate);
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_VENC_ToAgent_SetBitRate, &info,
+				sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do SetBitRate cmd\n");
+		ret = (-EPERM);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_set_frmrate(struct vpu_handler *hndl, uint32_t frmrate)
+{
+	struct VIDEO_RPC_ENC_SET_FRAME_RATE info;
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, encoder handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+
+	memset(&info, 0, sizeof(info));
+	dev_dbg(hndl->dev, "%s : frmrate %d", __func__, frmrate);
+	info.instanceID = htonl(hndl->inst_id);
+	info.frame_rate = htonl(frmrate);
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_VENC_ToAgent_SetFrameRate,
+				&info, sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do SetFrameRate cmd\n");
+		ret = (-EPERM);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_req_keyfrm(struct vpu_handler *hndl)
+{
+	struct VIDEO_RPC_ENC_REQ_KEY_FRAME info;
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, encoder handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->inst_id);
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_VENC_ToAgent_ReqKeyFrame, &info,
+				sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do ReqKeyFrame cmd\n");
+		ret = (-EPERM);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_start_record(struct vpu_handler *hndl)
+{
+	struct VIDEO_RPC_ENC_START_ENC info;
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, encoder handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->inst_id);
+	info.startMode = 0;
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_VENC_ToAgent_StartRecord, &info,
+				sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do StartRecord cmd\n");
+		ret = (-EPERM);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_stop_record(struct vpu_handler *hndl)
+{
+	struct VIDEO_RPC_ENC_STOP_ENC info;
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, encoder handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->inst_id);
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_VENC_ToAgent_StopRecord, &info,
+				sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do StopRecord cmd\n");
+		ret = (-EPERM);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+static int rtkve_rpc_common(struct vpu_handler *hndl, int cmd)
+{
+	uint32_t instanceID;
+	int ret = 0;
+
+	mutex_lock(&hndl->lock);
+	if (!hndl || !hndl->inst_id || hndl->inst_id == -1) {
+		pr_err("%s, handler is NULL", __func__);
+		ret = -EPERM;
+		mutex_unlock(&hndl->lock);
+		goto exit;
+	}
+
+	instanceID = htonl(hndl->inst_id);
+	ret = rtkve_rpc_shuttle(hndl, cmd, &instanceID, sizeof(instanceID),
+				NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do cmd %d \n", cmd);
+		ret = -EPERM;
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_run(struct vpu_handler *hndl)
+{
+	int ret = 0;
+
+	ret = rtkve_rpc_common(hndl, VIDEO_RPC_VENC_ToAgent_Run);
+	return ret;
+}
+
+int rtkve_rpc_pause(struct vpu_handler *hndl)
+{
+	int ret = 0;
+
+	ret = rtkve_rpc_common(hndl, VIDEO_RPC_VENC_ToAgent_Pause);
+	return ret;
+}
+
+int rtkve_rpc_stop(struct vpu_handler *hndl)
+{
+	int ret = 0;
+
+	ret = rtkve_rpc_common(hndl, VIDEO_RPC_VENC_ToAgent_Stop);
+	return ret;
+}
+
+static int rtkve_rpc_set_ringbuf(struct vpu_handler *hndl,
+				 struct rtkve_ringbuf_t *prb, uint32_t bodysize,
+				 enum RINGBUFFER_TYPE type)
+{
+	struct RPC_RINGBUFFER ringbuffer;
+	struct vpu_buf *body;
+	struct vpu_buf *head;
+	int ret = 0;
+
+	if (!hndl) {
+		pr_err("%s, handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	body = rtkve_allocate_dma_memory(hndl->dev, bodysize, true);
+	if (!body) {
+		dev_err(hndl->dev,
+			"%s: Allocating body buf of size %d, fail: %d\n",
+			__func__, bodysize, ret);
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	head = rtkve_allocate_dma_memory(hndl->dev,
+					 sizeof(struct _tagRingBufferHeader), true);
+	if (!head) {
+		dev_err(hndl->dev,
+			"%s: Allocating head buf of size %ld, fail: %d\n",
+			__func__, sizeof(struct _tagRingBufferHeader), ret);
+		ret = -ENOMEM;
+		goto err_head_exit;
+	}
+
+	mutex_init(&prb->lock);
+	prb->buf_hdl = body;
+	prb->phyaddr = body->daddr;
+	prb->virtaddr = (uint8_t *)body->vaddr;
+	prb->hdr_hdl = head;
+	prb->phyaddr_hdr = head->daddr;
+	prb->virtaddr_hdr = (uint8_t *)head->vaddr;
+	prb->size = bodysize;
+	prb->limit = prb->phyaddr + bodysize;
+
+	prb->pRBH = (volatile struct _tagRingBufferHeader *)head->vaddr;
+	prb->pRBH->size = htonl(bodysize);
+	prb->pRBH->numOfReadPtr = htonl(1);
+	prb->pRBH->beginAddr = htonl(body->daddr);
+	prb->pRBH->writePtr = htonl(body->daddr);
+	prb->pRBH->readPtr[0] = htonl(body->daddr);
+	prb->pRBH->readPtr[1] = htonl(body->daddr);
+	prb->pRBH->readPtr[2] = htonl(body->daddr);
+	prb->pRBH->readPtr[3] = htonl(body->daddr);
+	prb->pRBH->reserve2 = 0;
+	prb->pRBH->reserve3 = 0;
+	prb->pRBH->bufferID = htonl(type);
+
+	mutex_lock(&hndl->lock);
+	ringbuffer.instanceID = htonl(hndl->inst_id);
+	ringbuffer.readPtrIndex = 0;
+	ringbuffer.pinID = 0;
+	ringbuffer.pRINGBUFF_HEADER = htonl(head->daddr);
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_VENC_ToAgent_InitRingBuffer,
+				&ringbuffer, sizeof(ringbuffer), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev,
+			"%s: init ring buf, fail: %d\n", __func__, ret);
+		goto err_init_ring;
+	}
+
+	return 0;
+err_init_ring:
+	rtkve_free_dma_memory(hndl->dev, head);
+err_head_exit:
+	rtkve_free_dma_memory(hndl->dev, body);
+exit:
+	return ret;
+}
+
+static int rtkve_rpc_release_ringbuf(struct vpu_handler *hndl,
+				     struct rtkve_ringbuf_t *ringbuf)
+{
+	int ret = 0;
+
+	if (!hndl) {
+		pr_err("%s, handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (!ringbuf) {
+		dev_err(hndl->dev, "Invaild input in %s\n", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (ringbuf->hdr_hdl) {
+		mutex_lock(&ringbuf->lock);
+		rtkve_free_dma_memory(hndl->dev, ringbuf->hdr_hdl);
+		ringbuf->hdr_hdl = NULL;
+		mutex_unlock(&ringbuf->lock);
+	}
+
+	if (ringbuf->buf_hdl) {
+		mutex_lock(&ringbuf->lock);
+		rtkve_free_dma_memory(hndl->dev, ringbuf->buf_hdl);
+		ringbuf->buf_hdl = NULL;
+		mutex_unlock(&ringbuf->lock);
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_create_encoder(struct vpu_instance *inst)
+{
+	struct vpu_handler *enc_hdl;
+	int ret = 0;
+
+	enc_hdl = kzalloc(sizeof(struct vpu_handler), GFP_KERNEL);
+	if (!enc_hdl) {
+		dev_err(inst->dev->dev, "allocate flash handle fail\n");
+		ret = (-ENOMEM);
+		goto err_exit;
+	}
+
+	enc_hdl->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	enc_hdl->dev = inst->dev->dev;
+	enc_hdl->inst_id = -1;
+
+	ret = rtkve_rpc_open(enc_hdl, VF_TYPE_VIDEO_ENCODER);
+	if (ret) {
+		dev_err(enc_hdl->dev, "fail to open vpu encoder\n");
+		ret = (-EPERM);
+		goto err_open_exit;
+	}
+
+	ret = rtkve_rpc_set_ringbuf(enc_hdl, &enc_hdl->stream_rb, STREAM_RBSIZE,
+				    RINGBUFFER_STREAM);
+	if (ret) {
+		dev_err(enc_hdl->dev, "fail to initial stream rb\n");
+		goto err_stream_exit;
+	}
+
+	ret = rtkve_rpc_set_ringbuf(enc_hdl, &enc_hdl->inband_rb,
+				    COMMAND_RBSIZE, RINGBUFFER_COMMAND);
+	if (ret) {
+		dev_err(enc_hdl->dev, "fail to initial inband rb\n");
+		goto err_com_exit;
+	}
+
+	ret = rtkve_rpc_set_ringbuf(
+		enc_hdl, &enc_hdl->mesg_rb,
+		RTKVE_MAX_MSG_NUM *
+			sizeof(struct VIDEO_RPC_ENC_ELEM_FRAME_INFO),
+		RINGBUFFER_MESSAGE);
+	if (ret) {
+		dev_err(enc_hdl->dev, "fail to initial message rb\n");
+		goto err_mesg_exit;
+	}
+
+	ret = rtkve_inband_set_ref_buffer(enc_hdl);
+	if (ret) {
+		dev_err(inst->dev->dev, "set reference buffer fail\n");
+		goto err_set_ref;
+	}
+
+	inst->enc_hdl = enc_hdl;
+
+	return 0;
+err_set_ref:
+	rtkve_rpc_release_ringbuf(enc_hdl, &enc_hdl->mesg_rb);
+err_mesg_exit:
+	rtkve_rpc_release_ringbuf(enc_hdl, &enc_hdl->inband_rb);
+err_com_exit:
+	rtkve_rpc_release_ringbuf(enc_hdl, &enc_hdl->stream_rb);
+err_stream_exit:
+	rtkve_rpc_close(enc_hdl);
+err_open_exit:
+	kfree(enc_hdl);
+err_exit:
+	return ret;
+}
+
+int rtkve_rpc_destroy_encoder(struct vpu_instance *inst)
+{
+	struct vpu_handler *enc_hdl = inst->enc_hdl;
+	int ret = 0;
+
+	if (!enc_hdl)
+		goto exit;
+
+	rtkve_rpc_release_ringbuf(enc_hdl, &enc_hdl->inband_rb);
+	rtkve_rpc_release_ringbuf(enc_hdl, &enc_hdl->stream_rb);
+	rtkve_rpc_release_ringbuf(enc_hdl, &enc_hdl->mesg_rb);
+	rtkve_rpc_close(enc_hdl);
+
+	if (enc_hdl)
+		kfree(enc_hdl);
+
+	enc_hdl = NULL;
+exit:
+	return ret;
+}
+
+static void rtkve_inband_memcpy(uint8_t *des, uint8_t *src, unsigned int size)
+{
+	unsigned int *src_int32 = (unsigned int *)src;
+	unsigned int *des_int32 = (unsigned int *)des;
+	unsigned int i;
+
+	for (i = 0; i < (size / sizeof(int)); i++)
+		des_int32[i] = htonl(src_int32[i]);
+
+	dsb(sy);
+}
+
+int rtkve_write_rb(struct rtkve_ringbuf_t *ringbuf, int type, uint8_t *buf,
+		   int size)
+{
+	volatile struct rtkve_ringbuf_t *rb = ringbuf;
+	uint32_t wp, rp;
+	void *wptr, *next, *addr_end;
+	uint8_t over = 0;
+	int ret = 0;
+
+	if (!ringbuf) {
+		pr_err("invaild input ringbuf %p", ringbuf);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&ringbuf->lock);
+
+	wp = htonl(rb->pRBH->writePtr);
+	rp = htonl(rb->pRBH->readPtr[0]);
+
+	if (rp > wp && (int)(rp - wp - 1) < size) {
+		mutex_unlock(&ringbuf->lock);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (wp > rp && (int)(rp + rb->size - wp - 1) < size) {
+		mutex_unlock(&ringbuf->lock);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	wptr = rb->virtaddr + (wp - rb->phyaddr);
+	addr_end = rb->virtaddr + rb->size;
+	next = wptr + size;
+	if (next >= addr_end) {
+		over = 1;
+		next -= rb->size;
+	}
+
+	if (over) {
+		int size0 = 0;
+		int size1 = 0;
+
+		size0 = rb->virtaddr + rb->size - (uint8_t *)wptr;
+		size1 = size - size0;
+
+		if (size0 != 0)
+			rtkve_inband_memcpy(wptr, buf, (unsigned int)size0);
+
+		if (size1 != 0)
+			rtkve_inband_memcpy(rb->virtaddr, buf + size0,
+					    (unsigned int)size1);
+	} else {
+		rtkve_inband_memcpy(wptr, buf, (unsigned int)size);
+	}
+
+	rb->pRBH->writePtr =
+		htonl(rb->phyaddr + ((uint8_t *)next - rb->virtaddr));
+	dsb(sy);
+
+	mutex_unlock(&ringbuf->lock);
+exit:
+	return ret;
+}
+
+int rtkve_inband_pts(struct vpu_handler *hndl, uint32_t wptr, uint64_t pts)
+{
+	struct PTS_INFO cmd;
+	int ret = 0;
+
+	cmd.header.type = INBAND_CMD_TYPE_PTS;
+	cmd.header.size = sizeof(struct PTS_INFO);
+	cmd.wPtr = wptr;
+	cmd.PTSH = pts >> 32;
+	cmd.PTSL = pts;
+
+	ret = rtkve_write_rb(&hndl->inband_rb, RINGBUFFER_COMMAND,
+			     (uint8_t *)&cmd, sizeof(cmd));
+
+	return ret;
+}
+
+int rtkve_inband_raw_input(struct vpu_handler *hndl, uint32_t luma_addr,
+			   uint32_t luma_size, uint32_t chroma_addr,
+			   uint32_t chroma_size, int64_t pts, enum frm_type type)
+{
+	struct RAWYUV_INFO cmd;
+	int ret = 0;
+
+	cmd.header.type = VENC_INBAND_CMD_TYPE_RAWYUV;
+	cmd.header.size = sizeof(struct RAWYUV_INFO);
+	cmd.luma_addr = luma_addr;
+	cmd.luma_size = luma_size;
+	cmd.chroma_addr = chroma_addr;
+	cmd.chroma_size = chroma_size;
+	cmd.PTSH = pts >> 32;
+	cmd.PTSL = pts & 0xFFFFFFFF;
+	cmd.buf_index = type;
+
+	ret = rtkve_write_rb(&hndl->inband_rb, RINGBUFFER_COMMAND,
+			     (uint8_t *)&cmd, sizeof(cmd));
+	return ret;
+}
+
+int rtkve_inband_set_ref_buffer(struct vpu_handler *hndl)
+{
+	struct REFYUV_INFO cmd;
+	int refbuf_size = REF_FRM_BUF_SIZE;
+	int ret = 0;
+
+	hndl->refbuf = rtkve_allocate_dma_memory(hndl->dev, refbuf_size, false);
+	if (!hndl->refbuf) {
+		dev_err(hndl->dev,
+			"%s: Allocating ref buf of size %d, fail: %d\n",
+			__func__, refbuf_size, ret);
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	cmd.header.type = VENC_INBAND_CMD_TYPE_REFYUV;
+	cmd.header.size = sizeof(struct REFYUV_INFO);
+	cmd.start_addr = (unsigned int)hndl->refbuf->daddr;
+	cmd.size = refbuf_size;
+	ret = rtkve_write_rb(&hndl->inband_rb, RINGBUFFER_COMMAND,
+			     (uint8_t *)&cmd, sizeof(cmd));
+	if (ret) {
+		rtkve_free_dma_memory(hndl->dev, hndl->refbuf);
+		hndl->refbuf = NULL;
+	}
+exit:
+	return ret;
+}
+
+int rtkve_inband_release_ref_buffer(struct vpu_handler *hndl)
+{
+	int ret = 0;
+	if (hndl->refbuf) {
+		rtkve_free_dma_memory(hndl->dev, hndl->refbuf);
+		hndl->refbuf = NULL;
+	}
+
+	return ret;
+}
+
+int rtkve_inband_set_eos(struct vpu_handler *hndl)
+{
+	struct EOS cmd;
+	int ret = 0;
+
+	dev_dbg(hndl->dev, "%s", __func__);
+
+	cmd.header.type = INBAND_CMD_TYPE_EOS;
+	cmd.header.size = sizeof(struct EOS);
+	cmd.eventID = 0;
+	cmd.wPtr = 0;
+	ret = rtkve_write_rb(&hndl->inband_rb, RINGBUFFER_COMMAND,
+			     (uint8_t *)&cmd, sizeof(cmd));
+
+	return ret;
+}
--- /dev/null
+++ b/drivers/media/platform/realtek/rtkve/enc/rtkve-rpc.h
@@ -0,0 +1,105 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#ifndef RTKVE_RPC_H
+#define RTKVE_RPC_H
+
+#include "rtkve-rpc-def.h"
+#include "rtkve-common.h"
+
+enum frm_type {
+	FRM_TYPE_P = 1,
+	FRM_TYPE_I = 2,
+};
+
+struct rtkve_ringbuf_t {
+	struct mutex lock;
+	volatile struct _tagRingBufferHeader *pRBH;
+	uint32_t phyaddr;
+	uint32_t phyaddr_hdr;
+	uint32_t limit;
+	uint32_t size;
+	uint8_t *virtaddr;
+	uint8_t *virtaddr_hdr;
+	void *hdr_hdl;
+	void *buf_hdl;
+};
+
+struct rtkve_buflock_t {
+	volatile uint8_t *buflock_va;
+	uint32_t buflock_pa;
+	uint32_t idx;
+	bool is_used;
+};
+
+struct rtkve_pre_parsing_info {
+	uint32_t width;
+	uint32_t height;
+	uint32_t min_reqbuf;
+	uint32_t bit_depth;
+	uint32_t ddr_width;
+	uint32_t ddr_height;
+};
+
+struct vpu_flash_info {
+	struct rtkve_ringbuf_t mesg_rb;
+	uint32_t outputRingIdx;
+	uintptr_t *frame;
+};
+
+struct vpu_handler {
+	struct rtk_krpc_ept_info *vcpu_ept_info;
+	struct mutex lock;
+	uint32_t inst_type;
+	uint32_t inst_id;
+	struct device *dev;
+	int type;
+	struct rtkve_ringbuf_t stream_rb;
+	struct rtkve_ringbuf_t inband_rb;
+	struct rtkve_ringbuf_t mesg_rb;
+	struct vpu_buf *refbuf;
+};
+
+int rtkve_rpc_open(struct vpu_handler *hndl, int type);
+int rtkve_rpc_close(struct vpu_handler *hndl);
+int rtkve_rpc_set_srcfmt(struct vpu_handler *hndl, enum YUV_FMT fmt);
+int rtkve_rpc_set_encfmt(struct vpu_handler *hndl, enum VIDEO_STREAM_TYPE fmt);
+int rtkve_rpc_set_resolution(struct vpu_handler *hndl, uint32_t in_width,
+			   uint32_t in_height, uint32_t out_width, uint32_t out_height);
+int rtkve_rpc_set_GOPStruct(struct vpu_handler *hndl, uint32_t M, uint32_t N);
+int rtkve_rpc_set_profile(struct vpu_handler *hndl,
+			  enum VIDEO_ENC_PROFILE profile);
+int rtkve_rpc_set_bitrate(struct vpu_handler *hndl, uint32_t mode,
+			  uint32_t bitrate);
+int rtkve_rpc_set_frmrate(struct vpu_handler *hndl, uint32_t frmrate);
+int rtkve_rpc_req_keyfrm(struct vpu_handler *hndl);
+int rtkve_rpc_start_record(struct vpu_handler *hndl);
+int rtkve_rpc_stop_record(struct vpu_handler *hndl);
+int rtkve_rpc_run(struct vpu_handler *hndl);
+int rtkve_rpc_pause(struct vpu_handler *hndl);
+int rtkve_rpc_stop(struct vpu_handler *hndl);
+int rtkve_rpc_create_encoder(struct vpu_instance *inst);
+int rtkve_rpc_destroy_encoder(struct vpu_instance *inst);
+
+int rtkve_inband_pts(struct vpu_handler *hndl, uint32_t wptr, uint64_t pts);
+int rtkve_inband_raw_input(struct vpu_handler *hndl, uint32_t luma_addr,
+			   uint32_t luma_size, uint32_t chroma_addr,
+			   uint32_t chroma_size, int64_t pts, enum frm_type type);
+int rtkve_inband_set_ref_buffer(struct vpu_handler *hndl);
+int rtkve_inband_release_ref_buffer(struct vpu_handler *hndl);
+int rtkve_inband_set_eos(struct vpu_handler *hndl);
+
+int rtkve_write_rb(struct rtkve_ringbuf_t *ringbuf, int type, uint8_t *buf,
+		   int size);
+
+#endif
--- /dev/null
+++ b/drivers/media/platform/realtek/rtkve/enc/rtkve-stateful-vpu-enc.c
@@ -0,0 +1,1179 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video encoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#include "rtkve-rpc.h"
+#include "rtkve-vpu.h"
+
+#define MAX_CTRL_LIST (3)
+#define CTRL_RINGBUF_NUM (32)
+#define MEANINGLESS (~0)
+#define MIN_BITRATE (64)
+#define MAX_BITRATE (40 * 1024 * 1024)
+#define DEF_BITRATE (5 * 1024 * 1024)
+#define DEF_OUTPUT_BUF (4)
+#define DEF_CAPTURE_BUF (4)
+
+static void rtkve_enc_return_dstbuf(struct vpu_instance *inst);
+extern void rtkve_update_pix_fmt(struct vpu_instance *inst,
+				 struct v4l2_pix_format_mplane *pix_mp,
+				 unsigned int width, unsigned int height);
+
+static const struct vpu_format rtkve_stateful_enc_fmt_list[2][2] = {
+	[VPU_FMT_TYPE_CODEC] = {
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_HEVC,
+			.max_width = HEVC_MAX_ENC_PIC_WIDTH,
+			.min_width = HEVC_MIN_ENC_PIC_WIDTH,
+			.max_height = HEVC_MAX_ENC_PIC_HEIGHT,
+			.min_height = HEVC_MIN_ENC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+	},
+	[VPU_FMT_TYPE_RAW] = {
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_NV12,
+			.max_width = RAW_MAX_ENC_PIC_WIDTH,
+			.min_width = RAW_MIN_ENC_PIC_WIDTH,
+			.max_height = RAW_MAX_ENC_PIC_HEIGHT,
+			.min_height = RAW_MIN_ENC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+	}
+};
+
+static inline struct vpu_instance *ctrl_to_dec_inst(struct v4l2_ctrl *ctrl)
+{
+	return container_of(ctrl->handler, struct vpu_instance, v4l2_ctrl_hdl);
+}
+
+static int rtkve_enc_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct vpu_instance *inst = ctrl_to_dec_inst(ctrl);
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_MPEG_VIDEO_BITRATE_MODE:
+		dev_dbg(inst->dev->dev, "CTRL set bitrate mode = %d",
+			ctrl->val);
+		if (ctrl->val == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR) {
+			inst->enc_params.bitrate_mode = VIDEO_RATE_VBR;
+		} else if (ctrl->val == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR) {
+			inst->enc_params.bitrate_mode = VIDEO_RATE_CBR;
+		} else {
+			inst->enc_params.bitrate_mode = VIDEO_RATE_CVBR;
+		}
+		break;
+	case V4L2_CID_MPEG_VIDEO_BITRATE:
+		dev_dbg(inst->dev->dev, "CTRL set bitrate = %d", ctrl->val);
+		inst->enc_params.bitrate = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEADER_MODE:
+		dev_dbg(inst->dev->dev, "CTRL set header mode = %d", ctrl->val);
+		inst->enc_params.header_with_frm = ctrl->val; //TODO
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_PROFILE:
+		dev_dbg(inst->dev->dev, "CTRL set profile = %d", ctrl->val);
+		if (ctrl->val != V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN) {
+			dev_err(inst->dev->dev, "Unsupported profile = %d",
+				ctrl->val);
+		}
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_LEVEL:
+		dev_dbg(inst->dev->dev, "CTRL set level = %d", ctrl->val);
+		if (ctrl->val > V4L2_MPEG_VIDEO_HEVC_LEVEL_4_1) {
+			dev_err(inst->dev->dev, "Unsupported level = %d",
+				ctrl->val);
+		}
+		break;
+	case V4L2_CID_MPEG_VIDEO_GOP_SIZE:
+		dev_dbg(inst->dev->dev, "CTRL set GOP size = %d", ctrl->val);
+		inst->enc_params.gop_size = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME:
+		dev_dbg(inst->dev->dev, "CTRL force key frame");
+		inst->force_key_frm_mode = true;
+		inst->enc_params.force_key_frm = true;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops rtkve_enc_ctrl_ops = {
+	.s_ctrl = rtkve_enc_s_ctrl,
+};
+
+static const struct vpu_format *rtkve_enc_find_fmt(unsigned int v4l2_pix_fmt,
+						   enum vpu_fmt_type type)
+{
+	unsigned int index;
+	const struct vpu_format *fmt = NULL;
+
+	for (index = 0; index < ARRAY_SIZE(rtkve_stateful_enc_fmt_list[type]);
+	     index++) {
+		if (rtkve_stateful_enc_fmt_list[type][index].v4l2_pix_fmt ==
+		    v4l2_pix_fmt)
+			fmt = &rtkve_stateful_enc_fmt_list[type][index];
+	}
+
+	return fmt;
+}
+
+static const struct vpu_format *
+rtkve_enc_find_fmt_by_idx(unsigned int idx, enum vpu_fmt_type type)
+{
+	const struct vpu_format *fmt = NULL;
+
+	if (idx >= ARRAY_SIZE(rtkve_stateful_enc_fmt_list[type]))
+		goto exit;
+
+	if (!rtkve_stateful_enc_fmt_list[type][idx].v4l2_pix_fmt)
+		goto exit;
+
+	fmt = &rtkve_stateful_enc_fmt_list[type][idx];
+
+exit:
+	return fmt;
+}
+
+static struct vpu_instance *fh_to_inst(struct v4l2_fh *fh)
+{
+	struct vpu_instance *inst =
+		container_of(fh, struct vpu_instance, v4l2_fh);
+	return inst;
+}
+
+static int rtkve_enc_create_instance(struct vpu_instance *inst)
+{
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: enter\n", __func__);
+
+	ret = rtkve_rpc_create_encoder(inst);
+	if (ret) {
+		dev_err(inst->dev->dev, "create encoder fail\n");
+		goto exit;
+	}
+
+	INIT_LIST_HEAD(&inst->srcbuf_list);
+	INIT_LIST_HEAD(&inst->dstbuf_list);
+	spin_lock_init(&inst->srcbuf_lock);
+	spin_lock_init(&inst->dstbuf_lock);
+
+	inst->state = VPU_INST_STATE_INIT;
+exit:
+	return ret;
+}
+
+static void rtkve_enc_destroy_instance(struct vpu_instance *inst)
+{
+	struct vpu_handler *enc_hndl = inst->enc_hdl;
+	struct task_struct *t;
+	int ret = 0;
+
+	if (!inst || !enc_hndl) {
+		goto exit;
+	}
+
+	ret = rtkve_rpc_pause(enc_hndl);
+	if (ret) {
+		dev_err(inst->dev->dev,
+			"rtkve_rpc_pause fail\n");
+		ret = -EPERM;
+		goto exit;
+	}
+
+	ret = rtkve_rpc_stop(enc_hndl);
+	if (ret) {
+		dev_err(inst->dev->dev, "failed destroy encode instance: %d\n",
+			ret);
+	}
+
+	t = xchg(&inst->input_thread, NULL);
+	if (t) {
+		wake_up_interruptible(&inst->input_waitq);
+		kthread_stop(t);
+	}
+
+	ret = rtkve_inband_release_ref_buffer(enc_hndl);
+	if (ret) {
+		dev_err(inst->dev->dev, "failed free reference buf: %d\n", ret);
+	}
+
+	ret = rtkve_rpc_destroy_encoder(inst);
+	if (ret) {
+		dev_err(inst->dev->dev, "failed destroy encoder instance: %d\n",
+			ret);
+	}
+
+exit:
+	return;
+}
+
+static void rtkve_enc_buf_queue_src(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct vpu_instance *inst = vb2_get_drv_priv(vb->vb2_queue);
+	struct vpu_buffer *src_buf = rtkve_to_vpu_buf(vbuf);
+	unsigned long flags;
+
+	dev_dbg(inst->dev->dev,
+		"type %4d index %4d size[0] %4ld size[1] : %4ld | size[2] : %4ld\n",
+		vb->type, vb->index, vb2_plane_size(&vbuf->vb2_buf, 0),
+		vb2_plane_size(&vbuf->vb2_buf, 1),
+		vb2_plane_size(&vbuf->vb2_buf, 2));
+
+	vbuf->sequence = inst->queued_src_buf_num++;
+
+	if (inst->enc_params.force_key_frm) {
+		src_buf->force_key_frm = true;
+		inst->enc_params.force_key_frm = false;
+	} else {
+		src_buf->force_key_frm = false;
+	}
+	v4l2_m2m_buf_queue(inst->v4l2_fh.m2m_ctx, vbuf);
+	spin_lock_irqsave(&inst->srcbuf_lock, flags);
+	list_add_tail(&src_buf->list, &inst->srcbuf_list);
+	spin_unlock_irqrestore(&inst->srcbuf_lock, flags);
+
+	wake_up_interruptible(&inst->input_waitq);
+	if (inst->state == VPU_INST_STATE_PIC_RUN)
+		wake_up_interruptible(&inst->output_waitq);
+}
+
+static struct vpu_buffer *rtkve_enc_next_srcbuf(struct vpu_instance *inst,
+						bool check_consume)
+{
+	struct vpu_buffer *b = NULL;
+	unsigned long flags;
+	bool is_found = 0;
+
+	spin_lock_irqsave(&inst->srcbuf_lock, flags);
+	if (list_empty(&inst->srcbuf_list)) {
+		spin_unlock_irqrestore(&inst->srcbuf_lock, flags);
+		goto exit;
+	}
+
+	list_for_each_entry (b, &inst->srcbuf_list, list) {
+		if (b && ((check_consume && b->consumed == false) ||
+			  (!check_consume))) {
+			is_found = 1;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&inst->srcbuf_lock, flags);
+exit:
+	return (is_found ? b : NULL);
+}
+
+static struct vb2_v4l2_buffer *
+rtkve_enc_remove_srcbuf(struct vpu_instance *inst, struct vpu_buffer *buf)
+{
+	struct vpu_buffer *b = NULL;
+	struct vpu_buffer *b_tmp = NULL;
+	unsigned long flags;
+	bool is_found = 0;
+
+	spin_lock_irqsave(&inst->srcbuf_lock, flags);
+	list_for_each_entry_safe (b, b_tmp, &inst->srcbuf_list, list) {
+		if (buf == b) {
+			b->consumed = false;
+			list_del(&b->list);
+			is_found = 1;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&inst->srcbuf_lock, flags);
+
+	return (is_found ? &b->v4l2_m2m_buf.vb : NULL);
+}
+
+static void rtkve_enc_return_srcbuf(struct vpu_instance *inst)
+{
+	struct vpu_buffer *vpu_src = rtkve_enc_next_srcbuf(inst, false);
+
+	while (vpu_src) {
+		rtkve_enc_remove_srcbuf(inst, vpu_src);
+		vpu_src = rtkve_enc_next_srcbuf(inst, false);
+	}
+}
+
+static void rtkve_enc_buf_queue_dst(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct vpu_buffer *dst_buf = rtkve_to_vpu_buf(vbuf);
+	struct vpu_instance *inst = vb2_get_drv_priv(vb->vb2_queue);
+	unsigned long flags;
+
+	dev_dbg(inst->dev->dev,
+		"type %4d index %4d size[0] %4ld size[1] : %4ld | size[2] : %4ld\n",
+		vb->type, vb->index, vb2_plane_size(&vbuf->vb2_buf, 0),
+		vb2_plane_size(&vbuf->vb2_buf, 1),
+		vb2_plane_size(&vbuf->vb2_buf, 2));
+
+	vbuf->sequence = inst->queued_dst_buf_num++;
+	v4l2_m2m_buf_queue(inst->v4l2_fh.m2m_ctx, vbuf);
+	spin_lock_irqsave(&inst->dstbuf_lock, flags);
+	list_add_tail(&dst_buf->list, &inst->dstbuf_list);
+	spin_unlock_irqrestore(&inst->dstbuf_lock, flags);
+}
+
+static void rtkve_enc_return_buffer(struct vb2_queue *vq, u32 state)
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(vq);
+	struct vb2_v4l2_buffer *vbuf;
+
+	for (;;) {
+		if (V4L2_TYPE_IS_OUTPUT(vq->type))
+			vbuf = v4l2_m2m_src_buf_remove(inst->v4l2_fh.m2m_ctx);
+		else
+			vbuf = v4l2_m2m_dst_buf_remove(inst->v4l2_fh.m2m_ctx);
+
+		if (!vbuf)
+			break;
+
+		if (vbuf->vb2_buf.req_obj.req)
+			v4l2_ctrl_request_complete(vbuf->vb2_buf.req_obj.req,
+						   &inst->v4l2_ctrl_hdl);
+
+		v4l2_m2m_buf_done(vbuf, state);
+		dev_dbg(inst->dev->dev, "Marked request %px as complete\n",
+			vbuf->vb2_buf.req_obj.req);
+	}
+}
+
+static int rtkve_enc_queue_setup(struct vb2_queue *q, unsigned int *num_buffers,
+				 unsigned int *num_planes, unsigned int sizes[],
+				 struct device *alloc_devs[])
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(q);
+	struct v4l2_pix_format_mplane inst_format =
+		(V4L2_TYPE_IS_OUTPUT(q->type)) ? inst->src_fmt : inst->dst_fmt;
+	unsigned int i;
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: num_buffers %d num_planes %d type %d\n",
+		__func__, *num_buffers, *num_planes, q->type);
+
+	if (*num_planes) {
+		if (inst_format.num_planes != *num_planes) {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		for (i = 0; i < *num_planes; i++) {
+			if (sizes[i] < inst_format.plane_fmt[i].sizeimage) {
+				ret = -EINVAL;
+				goto exit;
+			}
+		}
+	} else {
+		*num_planes = inst_format.num_planes;
+		for (i = 0; i < *num_planes; i++) {
+			sizes[i] = inst_format.plane_fmt[i].sizeimage;
+			dev_dbg(inst->dev->dev, "size[%d] : %d\n", i, sizes[i]);
+		}
+	}
+exit:
+	return ret;
+}
+
+static int rtkve_enc_buf_out_validate(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+
+	vbuf->field = V4L2_FIELD_NONE;
+	return 0;
+}
+
+static int rtkve_enc_buf_prepare(struct vb2_buffer *vb)
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(vb->vb2_queue);
+	struct v4l2_pix_format_mplane *fmt;
+	int i;
+
+	if (V4L2_TYPE_IS_OUTPUT(vb->type))
+		fmt = &inst->src_fmt;
+	else
+		fmt = &inst->dst_fmt;
+
+	for (i = 0; i < fmt->num_planes; i++) {
+		if (vb2_plane_size(vb, i) < fmt->plane_fmt[i].sizeimage) {
+			dev_err(inst->dev->dev,
+				"data will not fit into plane %d (%lu < %d)", i,
+				vb2_plane_size(vb, i),
+				fmt->plane_fmt[i].sizeimage);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static void rtkve_enc_buf_queue(struct vb2_buffer *vb)
+{
+	if (V4L2_TYPE_IS_OUTPUT(vb->type))
+		rtkve_enc_buf_queue_src(vb);
+	else
+		rtkve_enc_buf_queue_dst(vb);
+}
+
+static int rtkve_enc_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(q);
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: type %s\n", __func__,
+		v4l2_type_names[q->type]);
+
+	if ((V4L2_TYPE_IS_OUTPUT(q->type) &&
+		(inst->state == VPU_INST_STATE_STOP)) ||
+		(V4L2_TYPE_IS_CAPTURE(q->type) &&
+		(inst->state == VPU_INST_STATE_RESET)))
+		inst->state = VPU_INST_STATE_PREPARE;
+
+	return ret;
+}
+
+static void rtkve_enc_stop_streaming(struct vb2_queue *q)
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(q);
+	struct v4l2_m2m_ctx *m2m_ctx = inst->v4l2_fh.m2m_ctx;
+
+	dev_dbg(inst->dev->dev, "%s: type %s\n", __func__,
+		v4l2_type_names[q->type]);
+
+	v4l2_m2m_suspend(inst->dev->m2m_dev);
+
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		struct task_struct *t;
+		t = xchg(&inst->input_thread, NULL);
+		if (t) {
+			wake_up_interruptible(&inst->input_waitq);
+			kthread_stop(t);
+		}
+		rtkve_enc_return_srcbuf(inst);
+	} else {
+		rtkve_enc_return_dstbuf(inst);
+	}
+
+	rtkve_enc_return_buffer(q, VB2_BUF_STATE_ERROR);
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		inst->queued_src_buf_num = 0;
+		inst->state = VPU_INST_STATE_STOP;
+	} else {
+		if (v4l2_m2m_has_stopped(m2m_ctx))
+			v4l2_m2m_clear_state(m2m_ctx);
+		inst->state = VPU_INST_STATE_RESET;
+
+		inst->queued_dst_buf_num = 0;
+	}
+	v4l2_m2m_resume(inst->dev->m2m_dev);
+}
+
+static const struct vb2_ops rtkve_enc_vb2_ops = {
+	.queue_setup = rtkve_enc_queue_setup,
+	.buf_out_validate = rtkve_enc_buf_out_validate,
+	.buf_prepare = rtkve_enc_buf_prepare,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+	.buf_queue = rtkve_enc_buf_queue,
+	.start_streaming = rtkve_enc_start_streaming,
+	.stop_streaming = rtkve_enc_stop_streaming,
+};
+
+static int rtkve_enc_queue_init(void *priv, struct vb2_queue *src_vq,
+				struct vb2_queue *dst_vq)
+{
+	struct vpu_instance *inst = priv;
+	int ret;
+
+	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	src_vq->io_modes = VB2_MMAP | VB2_DMABUF;
+	src_vq->mem_ops = &vb2_dma_contig_memops;
+	src_vq->ops = &rtkve_enc_vb2_ops;
+	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	src_vq->buf_struct_size = sizeof(struct vpu_buffer);
+	src_vq->drv_priv = inst;
+	src_vq->lock = &inst->dev->dev_lock;
+	src_vq->dev = inst->dev->v4l2_dev.dev;
+	src_vq->supports_requests = true;
+	ret = vb2_queue_init(src_vq);
+	if (ret)
+		goto exit;
+
+	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	dst_vq->io_modes = VB2_MMAP | VB2_DMABUF;
+	dst_vq->mem_ops = &vb2_dma_contig_memops;
+	dst_vq->ops = &rtkve_enc_vb2_ops;
+	dst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	dst_vq->buf_struct_size = sizeof(struct vpu_buffer);
+	dst_vq->min_buffers_needed = 1;
+	dst_vq->drv_priv = inst;
+	dst_vq->lock = &inst->dev->dev_lock;
+	dst_vq->dev = inst->dev->v4l2_dev.dev;
+	ret = vb2_queue_init(dst_vq);
+	if (ret)
+		goto exit;
+
+exit:
+	return ret;
+}
+
+static void rtkve_enc_handle_src_buf(struct vpu_instance *inst)
+{
+	struct vb2_v4l2_buffer *src_buf;
+	struct vpu_buffer *vpu_buf;
+
+	src_buf = v4l2_m2m_next_src_buf(inst->v4l2_fh.m2m_ctx);
+	if (!src_buf) {
+		dev_info(inst->dev->dev, "not found src buffer \n");
+		goto exit;
+	}
+
+	vpu_buf = rtkve_to_vpu_buf(src_buf);
+	if (!vpu_buf)
+		goto exit;
+
+	rtkve_enc_remove_srcbuf(inst, vpu_buf);
+	src_buf = v4l2_m2m_src_buf_remove(inst->v4l2_fh.m2m_ctx);
+	v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);
+
+exit:
+	return;
+}
+
+static struct vpu_buffer *rtkve_enc_next_dstbuf(struct vpu_instance *inst,
+						bool check_consume)
+{
+	struct vpu_buffer *b = NULL;
+	unsigned long flags;
+	bool is_found = 0;
+
+	spin_lock_irqsave(&inst->dstbuf_lock, flags);
+	if (list_empty(&inst->dstbuf_list)) {
+		spin_unlock_irqrestore(&inst->dstbuf_lock, flags);
+		goto exit;
+	}
+
+	list_for_each_entry (b, &inst->dstbuf_list, list) {
+		if (b && ((check_consume && b->consumed == false) ||
+			  (!check_consume))) {
+			is_found = 1;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&inst->dstbuf_lock, flags);
+exit:
+	return (is_found ? b : NULL);
+}
+
+static struct vb2_v4l2_buffer *
+rtkve_enc_remove_dstbuf(struct vpu_instance *inst, struct vpu_buffer *buf)
+{
+	struct vpu_buffer *b = NULL;
+	struct vpu_buffer *b_tmp = NULL;
+	unsigned long flags;
+	bool is_found = 0;
+
+	spin_lock_irqsave(&inst->dstbuf_lock, flags);
+	list_for_each_entry_safe (b, b_tmp, &inst->dstbuf_list, list) {
+		if (buf == b) {
+			b->consumed = false;
+			list_del(&b->list);
+			is_found = 1;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&inst->dstbuf_lock, flags);
+
+	return (is_found ? &b->v4l2_m2m_buf.vb : NULL);
+}
+
+static void rtkve_enc_return_dstbuf(struct vpu_instance *inst)
+{
+	struct vpu_buffer *vpu_dst = rtkve_enc_next_dstbuf(inst, false);
+
+	while (vpu_dst) {
+		rtkve_enc_remove_dstbuf(inst, vpu_dst);
+		vpu_dst = rtkve_enc_next_dstbuf(inst, false);
+	}
+}
+
+static int rtkve_enc_fill_dst(struct vpu_handler *hndl,
+			      struct vb2_v4l2_buffer *dst, int size)
+{
+	struct rtkve_ringbuf_t *prb;
+	uint32_t wp, rp;
+	uint8_t *rptr, *next, *addr_end;
+	void *dst_buf;
+	int ret = 0;
+
+	prb = &hndl->stream_rb;
+	dst_buf = vb2_plane_vaddr(&dst->vb2_buf, 0);
+	if (!dst_buf)
+		pr_err("%s dst_buf is NULL", __func__);
+
+	mutex_lock(&prb->lock);
+	wp = htonl(prb->pRBH->writePtr);
+	rp = htonl(prb->pRBH->readPtr[0]);
+
+	if (rp > wp && (int)(rp - wp - 1) < size) {
+		mutex_unlock(&prb->lock);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (wp > rp && (int)(rp + prb->size - wp - 1) < size) {
+		mutex_unlock(&prb->lock);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	rptr = prb->virtaddr + (rp - prb->phyaddr);
+	addr_end = prb->virtaddr + prb->size;
+
+	next = rptr + size;
+
+	if (next >= addr_end) {
+		int size0 = addr_end - rptr;
+		int size1 = size - size0;
+
+		memcpy(dst_buf, rptr, size0);
+		memcpy(dst_buf + size0, prb->virtaddr, size1);
+
+		next -= prb->size;
+	} else {
+		memcpy(dst_buf, rptr, size);
+	}
+	prb->pRBH->readPtr[0] = htonl(prb->phyaddr + (next - prb->virtaddr));
+	mutex_unlock(&prb->lock);
+exit:
+	return ret;
+}
+
+static int rtkve_enc_check_wrptr(struct rtkve_ringbuf_t *prb)
+{
+	int ret = 0;
+
+	mutex_lock(&prb->lock);
+	if (prb->pRBH->readPtr[0] != prb->pRBH->writePtr)
+		ret = 1;
+	mutex_unlock(&prb->lock);
+
+	return ret;
+}
+
+static int rtkve_enc_get_frm(struct vpu_instance *inst,
+			     struct vpu_handler *hndl,
+			     struct vb2_v4l2_buffer *dst_buf,
+			     struct enc_output_info *enc_info)
+{
+	struct rtkve_ringbuf_t *prb;
+	struct VIDEO_RPC_ENC_ELEM_FRAME_INFO *frm_info;
+	int ret = 0;
+
+	prb = &hndl->mesg_rb;
+
+	if (prb->pRBH) {
+		int val = 0;
+		val = wait_event_interruptible_timeout(
+			inst->output_waitq,
+			kthread_should_stop() || rtkve_enc_check_wrptr(prb),
+			msecs_to_jiffies(10));
+		if (!val) {
+			ret = -EAGAIN;
+			goto exit;
+		} else {
+			uint32_t next_rp;
+
+			mutex_lock(&prb->lock);
+			frm_info = (struct VIDEO_RPC_ENC_ELEM_FRAME_INFO
+					    *)(prb->virtaddr +
+					       (htonl(prb->pRBH->readPtr[0]) -
+						htonl(prb->pRBH->beginAddr)));
+			if (htonl(frm_info->infoType) !=
+				    VIDEOENCODER_VideoFrameInfo ||
+			    frm_info->frameSize == 0) {
+				pr_err("incorrect info type %d, size %d\n",
+				       htonl(frm_info->infoType),
+				       htonl(frm_info->frameSize));
+			}
+
+			enc_info->frm_size = htonl(frm_info->frameSize);
+			enc_info->timestamp =
+				(((uint64_t)htonl(frm_info->PTShigh)) << 32) |
+				htonl(frm_info->PTSlow);
+			enc_info->keyfrm = frm_info->KeyFrame;
+			enc_info->picture_num = htonl(frm_info->pictureNumber);
+
+			rtkve_enc_fill_dst(hndl, dst_buf, enc_info->frm_size);
+
+			next_rp = htonl(prb->pRBH->readPtr[0]) +
+				  sizeof(struct VIDEO_RPC_ENC_ELEM_FRAME_INFO);
+			if (next_rp < prb->limit)
+				prb->pRBH->readPtr[0] = htonl(next_rp);
+			else
+				prb->pRBH->readPtr[0] = prb->pRBH->beginAddr;
+			dsb(sy);
+			mutex_unlock(&prb->lock);
+		}
+	} else {
+		pr_err("wrong ringbuffer header\n");
+	}
+exit:
+	return ret;
+}
+
+static void rtkve_enc_handle_dst_buf(struct vpu_instance *inst,
+				     struct vb2_v4l2_buffer *dst_buf,
+				     struct enc_output_info enc_info)
+{
+	struct vpu_buffer *vpu_dst;
+
+	vb2_set_plane_payload(&dst_buf->vb2_buf, 0, enc_info.frm_size);
+
+	vpu_dst = rtkve_to_vpu_buf(dst_buf);
+	rtkve_enc_remove_dstbuf(inst, vpu_dst);
+
+	v4l2_m2m_dst_buf_remove_by_buf(inst->v4l2_fh.m2m_ctx, dst_buf);
+	v4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);
+
+	return;
+}
+
+static int rtkve_enc_prepare_raw(struct vpu_instance *inst,
+				 struct vb2_v4l2_buffer *src_buf,
+				 struct enc_param *pic_param,
+				 bool force_key_frm)
+{
+	u64 timestamp = 0;
+	dma_addr_t luma_addr = 0, chroma_addr = 0;
+	uint32_t luma_size = 0, chroma_size = 0;
+	enum frm_type type = FRM_TYPE_P;
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%d.%s.enter\n", __LINE__, __func__);
+
+	if (!src_buf) {
+		ret = -EINVAL;
+		dev_err(inst->dev->dev, "%s, src_buf is NULL !!", __func__);
+		goto exit;
+	}
+
+	if (inst->src_fmt.num_planes == 1) {
+		luma_addr =
+			vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0) +
+			src_buf->planes[0].data_offset;
+		luma_size = vb2_get_plane_payload(&src_buf->vb2_buf, 0) * 2 / 3;
+		chroma_addr = luma_addr + luma_size;
+		chroma_size = vb2_get_plane_payload(&src_buf->vb2_buf, 0) / 3;
+	} else if (inst->src_fmt.num_planes == 2) {
+		luma_addr =
+			vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0) +
+			src_buf->planes[0].data_offset;
+		luma_size = vb2_get_plane_payload(&src_buf->vb2_buf, 0);
+		chroma_addr =
+			vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 1) +
+			src_buf->planes[1].data_offset;
+		;
+		chroma_size = vb2_get_plane_payload(&src_buf->vb2_buf, 1);
+	} else {
+		dev_err(inst->dev->dev,
+			"%s, don't support more than 2 planes !!", __func__);
+	}
+
+	timestamp = src_buf->vb2_buf.timestamp / 100000;
+
+	if (force_key_frm)
+		type = FRM_TYPE_I;
+
+	ret = rtkve_inband_raw_input(inst->enc_hdl, (uint32_t)luma_addr,
+				     luma_size, (uint32_t)chroma_addr,
+				     chroma_size, timestamp, type);
+	if (ret) {
+		dev_err(inst->dev->dev, "%s, inband_raw_input fail", __func__);
+	}
+
+exit:
+	return ret;
+}
+
+static int rtkve_enc_prepare_input(struct vpu_instance *inst)
+{
+	struct vpu_buffer *vpu_src, *vpu_dst;
+	struct vb2_v4l2_buffer *src_buf, *dst_buf;
+	struct enc_param pic_param;
+	unsigned long flags;
+	int ret = 0;
+
+	vpu_src = rtkve_enc_next_srcbuf(inst, true);
+	if (!vpu_src) {
+		ret = -EAGAIN;
+		goto exit;
+	}
+
+	vpu_dst = rtkve_enc_next_dstbuf(inst, true);
+	if (!vpu_dst) {
+		ret = -EAGAIN;
+		goto exit;
+	}
+
+	dst_buf = &vpu_dst->v4l2_m2m_buf.vb;
+	src_buf = &vpu_src->v4l2_m2m_buf.vb;
+
+	ret = rtkve_enc_prepare_raw(inst, src_buf, &pic_param,
+				     vpu_src->force_key_frm);
+	if (ret < 0)
+		goto exit;
+
+	inst->feed_cnt++;
+
+	if (inst->eos && inst->feed_cnt == inst->queued_src_buf_num)
+		rtkve_inband_set_eos(inst->enc_hdl);
+
+	spin_lock_irqsave(&inst->srcbuf_lock, flags);
+	vpu_src->consumed = true;
+	spin_unlock_irqrestore(&inst->srcbuf_lock, flags);
+
+	spin_lock_irqsave(&inst->dstbuf_lock, flags);
+	vpu_dst->consumed = true;
+	spin_unlock_irqrestore(&inst->dstbuf_lock, flags);
+	wake_up_interruptible(&inst->output_waitq);
+exit:
+	return ret;
+}
+
+static int rtkve_enc_has_resource(struct vpu_instance *inst)
+{
+	struct vpu_buffer *vpu_src = NULL;
+	struct vpu_buffer *vpu_dst = NULL;
+	int ret = 0;
+
+	vpu_src = rtkve_enc_next_srcbuf(inst, true);
+	if (!vpu_src)
+		goto exit;
+
+	vpu_dst = rtkve_enc_next_dstbuf(inst, true);
+	if (!vpu_dst)
+		goto exit;
+
+	ret = 1;
+exit:
+	return ret;
+}
+
+static int input_thread(void *data)
+{
+	struct v4l2_fh *fh = (struct v4l2_fh *)data;
+	struct vpu_instance *inst = fh_to_inst(fh);
+	int ret = 0;
+
+	while (1) {
+		ret = wait_event_interruptible_timeout(
+			inst->input_waitq,
+			kthread_should_stop() || rtkve_enc_has_resource(inst),
+			msecs_to_jiffies(10));
+
+		if (kthread_should_stop() || (ret == -ERESTART)) {
+			ret = 1;
+			break;
+		} else if (ret == 0) {
+			continue;
+		}
+
+		ret = rtkve_enc_prepare_input(inst);
+		if (ret != 0)
+			continue;
+	}
+	return ret;
+}
+
+static void rtkve_rpc_calc_res(struct vb2_v4l2_buffer *src_buf,
+				uint32_t width, uint32_t hieght,
+				uint32_t *align_width, uint32_t *align_height)
+{
+	unsigned long size = vb2_get_plane_payload(&src_buf->vb2_buf, 0);
+	int align[3] = {32, 64, 128};
+	int i = 0;
+
+	for(i = 0; i < 3; i++) {
+		*align_width = ALIGN(width, align[i]);
+		*align_height = ALIGN(hieght, align[i]);
+
+		if((*align_width) * (*align_height) * 3 /2 == size)
+			return;
+	}
+
+	*align_width = width;
+	*align_height = hieght;
+}
+
+static int rtkve_enc_init(struct vpu_instance *inst,
+				struct vb2_v4l2_buffer *src_buf)
+{
+	int ret = 0;
+	enum YUV_FMT src_fmt;
+	enum VIDEO_STREAM_TYPE dst_fmt;
+	uint32_t width = 0;
+	uint32_t height = 0;
+
+	switch (inst->src_fmt.pixelformat) {
+	case V4L2_PIX_FMT_NV12:
+	default:
+		src_fmt = F_YUV420_Semi;
+		break;
+	}
+
+	ret = rtkve_rpc_set_srcfmt(inst->enc_hdl, src_fmt);
+	if (ret) {
+		dev_err(inst->dev->dev, "set src fmt fail\n");
+		goto exit;
+	}
+
+	switch (inst->dst_fmt.pixelformat) {
+	case V4L2_PIX_FMT_HEVC:
+	default:
+		dst_fmt = VIDEO_STREAM_H265;
+		break;
+	}
+
+	ret = rtkve_rpc_set_encfmt(inst->enc_hdl, dst_fmt);
+	if (ret) {
+		dev_err(inst->dev->dev, "set encode fmt fail\n");
+		goto exit;
+	}
+
+	rtkve_rpc_calc_res(src_buf,
+				    inst->dst_fmt.width, inst->dst_fmt.height,
+				    &width, &height);
+
+	ret = rtkve_rpc_set_resolution(inst->enc_hdl, width, height,
+				    inst->dst_fmt.width, inst->dst_fmt.height);
+	if (ret) {
+		dev_err(inst->dev->dev, "set resolution fail\n");
+		goto exit;
+	}
+
+	ret = rtkve_rpc_set_frmrate(inst->enc_hdl, inst->enc_params.framerate);
+	if (ret) {
+		dev_err(inst->dev->dev, "set frame rate fail\n");
+		goto exit;
+	}
+
+	ret = rtkve_rpc_set_bitrate(inst->enc_hdl,
+				    inst->enc_params.bitrate_mode,
+				    inst->enc_params.bitrate);
+	if (ret) {
+		dev_err(inst->dev->dev, "set bit rate fail\n");
+		goto exit;
+	}
+
+	if (inst->force_key_frm_mode)
+		inst->enc_params.gop_size = 0xFFFFFFFF;
+
+	ret = rtkve_rpc_set_GOPStruct(inst->enc_hdl, inst->enc_params.gop_size,
+				      inst->enc_params.gop_size);
+	if (ret) {
+		dev_err(inst->dev->dev, "set GOP fail\n");
+		goto exit;
+	}
+
+	ret = rtkve_rpc_start_record(inst->enc_hdl);
+	if (ret) {
+		dev_err(inst->dev->dev, "start record fail\n");
+		goto exit;
+	}
+
+	ret = rtkve_rpc_pause(inst->enc_hdl);
+	if (ret) {
+		dev_err(inst->dev->dev, "%s pause fail\n", __func__);
+		goto exit;
+	}
+
+	ret = rtkve_rpc_run(inst->enc_hdl);
+	if (ret) {
+		dev_err(inst->dev->dev, "%s pause fail\n", __func__);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+static int rtkve_enc_start(struct vpu_instance *inst,
+				struct vb2_v4l2_buffer *src_buf)
+{
+	int ret = 0;
+
+	inst->input_thread =
+		kthread_run(input_thread, &inst->v4l2_fh, "inputhread");
+	if (IS_ERR(inst->input_thread)) {
+	    pr_err("failed to enc input thread: %ld\n", PTR_ERR(inst->input_thread));
+	    inst->input_thread = NULL;
+	}
+
+	return ret;
+}
+
+static void rtkve_enc_start_encode(struct work_struct *work)
+{
+	struct vpu_instance *inst =
+		container_of(work, struct vpu_instance, encode_work);
+	struct vpu_handler *hndl = inst->enc_hdl;
+	struct vb2_v4l2_buffer *src_buf, *dst_buf;
+	struct enc_output_info enc_info = { 0 };
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%d.%s.enter\n", __LINE__, __func__);
+
+	if (inst->eos && inst->feed_cnt == inst->queued_src_buf_num) {
+		rtkve_inband_set_eos(inst->enc_hdl);
+		inst->eos = false;
+	}
+
+	src_buf = v4l2_m2m_next_src_buf(inst->v4l2_fh.m2m_ctx);
+	if (!src_buf)
+		goto exit;
+
+	dst_buf = v4l2_m2m_next_dst_buf(inst->v4l2_fh.m2m_ctx);
+	if (!dst_buf)
+		goto exit;
+
+	switch (inst->state) {
+	case VPU_INST_STATE_INIT:
+		rtkve_enc_init(inst, src_buf);
+		inst->state = VPU_INST_STATE_PREPARE;
+		fallthrough;
+	case VPU_INST_STATE_PREPARE:
+		rtkve_enc_start(inst, src_buf);
+		inst->state = VPU_INST_STATE_PIC_RUN;
+		fallthrough;
+	case VPU_INST_STATE_PIC_RUN:
+		ret = rtkve_enc_get_frm(inst, hndl, dst_buf, &enc_info);
+		if (ret)
+			break;
+
+		dev_dbg(inst->dev->dev, "get frame %d !!!!", enc_info.frm_size);
+		v4l2_m2m_buf_copy_metadata(src_buf, dst_buf, false);
+		if (enc_info.keyfrm)
+			dst_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;
+		else
+			dst_buf->flags |= V4L2_BUF_FLAG_PFRAME;
+		dst_buf->flags |= src_buf->flags & V4L2_BUF_FLAG_LAST;
+
+		rtkve_enc_handle_dst_buf(inst, dst_buf, enc_info);
+
+		rtkve_enc_handle_src_buf(inst);
+		break;
+	default:
+		dev_err(inst->dev->dev, "%s invalid state %d\n", __func__, inst->state);
+		break;
+	}
+exit:
+	v4l2_m2m_job_finish(inst->dev->m2m_dev, inst->v4l2_fh.m2m_ctx);
+
+	dev_dbg(inst->dev->dev, "%d.%s.leave.ret:%d\n", __LINE__, __func__,
+		ret);
+	return;
+}
+
+static void rtkve_enc_stop_decode(struct vpu_instance *inst)
+{
+	dev_dbg(inst->dev->dev, "%s: state %d\n", __func__, inst->state);
+}
+
+static int rtkve_enc_init_ctrls(struct vpu_instance *inst)
+{
+	struct v4l2_ctrl_handler *hdl = &inst->v4l2_ctrl_hdl;
+	int ret = 0;
+
+	v4l2_ctrl_handler_init(hdl, 7);
+
+	v4l2_ctrl_new_std(hdl, &rtkve_enc_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_OUTPUT, 1, 32, 1,
+			  DEF_OUTPUT_BUF);
+
+	v4l2_ctrl_new_std(hdl, &rtkve_enc_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1,
+			  DEF_CAPTURE_BUF);
+
+	v4l2_ctrl_new_std(hdl, &rtkve_enc_ctrl_ops, V4L2_CID_MPEG_VIDEO_BITRATE,
+			  MIN_BITRATE, MAX_BITRATE, 1, DEF_BITRATE);
+
+	v4l2_ctrl_new_std(hdl, &rtkve_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_GOP_SIZE, 0, 65535, 1, 0);
+
+	v4l2_ctrl_new_std(hdl, &rtkve_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME, 0, 0, 0, 0);
+
+	v4l2_ctrl_new_std_menu(hdl, &rtkve_enc_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_BITRATE_MODE,
+			       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR,
+			       ~((1 << V4L2_MPEG_VIDEO_BITRATE_MODE_VBR) |
+				 (1 << V4L2_MPEG_VIDEO_BITRATE_MODE_CBR)),
+			       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR);
+
+	v4l2_ctrl_new_std_menu(
+		hdl, &rtkve_enc_ctrl_ops, V4L2_CID_MPEG_VIDEO_HEADER_MODE,
+		V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME, 0,
+		V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME);
+
+	v4l2_ctrl_new_std_menu(hdl, &rtkve_enc_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_HEVC_PROFILE,
+			       V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10,
+			       ~(1 << V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN),
+			       V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN);
+
+	v4l2_ctrl_new_std_menu(hdl, &rtkve_enc_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_HEVC_LEVEL,
+			       V4L2_MPEG_VIDEO_HEVC_LEVEL_6_2,
+			       ~((1 << V4L2_MPEG_VIDEO_HEVC_LEVEL_1) |
+				 (1 << V4L2_MPEG_VIDEO_HEVC_LEVEL_2) |
+				 (1 << V4L2_MPEG_VIDEO_HEVC_LEVEL_2_1) |
+				 (1 << V4L2_MPEG_VIDEO_HEVC_LEVEL_3) |
+				 (1 << V4L2_MPEG_VIDEO_HEVC_LEVEL_3_1) |
+				 (1 << V4L2_MPEG_VIDEO_HEVC_LEVEL_4) |
+				 (1 << V4L2_MPEG_VIDEO_HEVC_LEVEL_4_1)),
+			       V4L2_MPEG_VIDEO_HEVC_LEVEL_4_1);
+
+	if (hdl->error) {
+		dev_err(inst->dev->dev,
+			"Failed to initialize control handler\n");
+		v4l2_ctrl_handler_free(hdl);
+		ret = hdl->error;
+		goto exit;
+	}
+
+	inst->v4l2_fh.ctrl_handler = hdl;
+	v4l2_ctrl_handler_setup(hdl);
+exit:
+	return ret;
+}
+
+const struct rtkve_match_data rtkve3_data_stateful = {
+	.ctrls_setup = rtkve_enc_init_ctrls,
+	.dev_run_work = rtkve_enc_start_encode,
+	.find_vpu_fmt = rtkve_enc_find_fmt,
+	.find_vpu_fmt_by_idx = rtkve_enc_find_fmt_by_idx,
+	.queue_init = rtkve_enc_queue_init,
+	.create_instance = rtkve_enc_create_instance,
+	.stop_decode = rtkve_enc_stop_decode,
+	.destroy_instance = rtkve_enc_destroy_instance,
+	.is_stateless = false,
+};
--- /dev/null
+++ b/drivers/media/platform/realtek/rtkve/enc/rtkve-vpu.h
@@ -0,0 +1,87 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#ifndef RTKVE_VPU_H
+#define RTKVE_VPU_H
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fh.h>
+#include <media/videobuf2-v4l2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/videobuf2-vmalloc.h>
+
+#include "rtkve-common.h"
+
+#define HEVC_MIN_ENC_PIC_WIDTH 224U
+#define HEVC_MIN_ENC_PIC_HEIGHT 96U
+#define HEVC_MAX_ENC_PIC_WIDTH 1920U
+#define HEVC_MAX_ENC_PIC_HEIGHT 1920U
+
+#define RAW_MIN_ENC_PIC_WIDTH 224U
+#define RAW_MIN_ENC_PIC_HEIGHT 96U
+#define RAW_MAX_ENC_PIC_WIDTH 1920U
+#define RAW_MAX_ENC_PIC_HEIGHT 1920U
+
+#define ENC_PIC_SIZE_STEP 1
+
+#define DEFAULT_FRAMERATE_NUM 30000
+#define DEFAULT_FRAMERATE_DENOM 1000
+#define DEFAULT_GOP 29
+
+struct vpu_format {
+	unsigned int v4l2_pix_fmt;
+	unsigned int max_width;
+	unsigned int min_width;
+	unsigned int max_height;
+	unsigned int min_height;
+	unsigned int num_planes;
+};
+
+struct vpu_buffer {
+	struct v4l2_m2m_buffer v4l2_m2m_buf;
+	bool consumed;
+	bool referenced;
+	bool force_key_frm;
+	struct list_head list;
+};
+
+struct stateless_info {
+	struct vb2_v4l2_buffer *src;
+	struct vb2_v4l2_buffer *dst;
+	union {
+		struct stateless_hevc_info hevc;
+		struct stateless_vp9_info vp9;
+		struct stateless_av1_info av1;
+	};
+};
+
+extern struct v4l2_ioctl_ops rtkve_enc_ioctl_ops;
+extern const struct rtkve_match_data rtkve3_data_stateful;
+
+static inline struct vpu_instance *rtkve_to_vpu_inst(struct v4l2_fh *vfh)
+{
+	return container_of(vfh, struct vpu_instance, v4l2_fh);
+}
+
+static inline struct vpu_buffer *rtkve_to_vpu_buf(struct vb2_v4l2_buffer *vbuf)
+{
+	return container_of(vbuf, struct vpu_buffer, v4l2_m2m_buf.vb);
+}
+
+void rtkve_set_default_format(struct vpu_instance *inst,
+			      struct v4l2_pix_format_mplane *src_fmt,
+			      struct v4l2_pix_format_mplane *dst_fmt);
+int rtkve_enc_init_m2m_dev(struct vpu_device *dev);
+#endif
--- a/drivers/media/platform/Makefile
+++ b/drivers/media/platform/Makefile
@@ -21,6 +21,7 @@
 obj-y += nxp/
 obj-y += qcom/
 obj-y += renesas/
+obj-y += realtek/
 obj-y += rtk_dsi/
 obj-y += rtk_tpdemux/
 obj-y += rtk-mipi-csi/
