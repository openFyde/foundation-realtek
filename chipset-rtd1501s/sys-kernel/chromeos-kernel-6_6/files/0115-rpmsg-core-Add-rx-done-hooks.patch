In order to reduce the amount of copies in the rpmsg framework, it is
necessary for clients to take brief ownership of the receive buffer.

Add the capability for clients to notify the rpmsg framework and the
underlying transports when it is going to hold onto a buffer and also
notify when the client is done with the buffer.

In the .rx_cb of the rpmsg drivers, if they wish to use the received
buffer at a later point, they should return RPMSG_DEFER. Otherwise
returning RPMSG_HANDLED (0) will signal the framework that the client
is done with the resources and can continue with cleanup.

The clients should check if their rpmsg endpoint supports the rx_done
operation with the new state variable in the rpmsg_endpoint since not
all endpoints will have the ability to support this operation.

Signed-off-by: Chris Lew <quic_clew@quicinc.com>
---
 drivers/rpmsg/rpmsg_core.c     | 20 ++++++++++++++++++++
 drivers/rpmsg/rpmsg_internal.h |  1 +
 include/linux/rpmsg.h          | 24 ++++++++++++++++++++++++
 3 files changed, 45 insertions(+)

--- a/drivers/rpmsg/rpmsg_core.c
+++ b/drivers/rpmsg/rpmsg_core.c
@@ -370,6 +370,26 @@
 }
 EXPORT_SYMBOL(rpmsg_get_mtu);
 
+/**
+ * rpmsg_rx_done() - release resources related to @data from a @rx_cb
+ * @ept:	the rpmsg endpoint
+ * @data:	payload from a message
+ *
+ * Returns 0 on success and an appropriate error value on failure.
+ */
+int rpmsg_rx_done(struct rpmsg_endpoint *ept, void *data)
+{
+	if (WARN_ON(!ept))
+		return -EINVAL;
+	if (!ept->ops->rx_done)
+		return -ENXIO;
+	if (!ept->rx_done)
+		return -EINVAL;
+
+	return ept->ops->rx_done(ept, data);
+}
+EXPORT_SYMBOL(rpmsg_rx_done);
+
 /*
  * match a rpmsg channel with a channel info struct.
  * this is used to make sure we're not creating rpmsg devices for channels
--- a/drivers/rpmsg/rpmsg_internal.h
+++ b/drivers/rpmsg/rpmsg_internal.h
@@ -78,6 +78,7 @@
 			     poll_table *wait);
 	int (*set_flow_control)(struct rpmsg_endpoint *ept, bool pause, u32 dst);
 	ssize_t (*get_mtu)(struct rpmsg_endpoint *ept);
+	int (*rx_done)(struct rpmsg_endpoint *ept, void *data);
 };
 
 struct device *rpmsg_find_device(struct device *parent,
--- a/include/linux/rpmsg.h
+++ b/include/linux/rpmsg.h
@@ -63,6 +63,18 @@
 	const struct rpmsg_device_ops *ops;
 };
 
+/**
+ * rpmsg rx callback return definitions
+ * @RPMSG_HANDLED: rpmsg user is done processing data, framework can free the
+ *                 resources related to the buffer
+ * @RPMSG_DEFER:   rpmsg user is not done processing data, framework will hold
+ *                 onto resources related to the buffer until rpmsg_rx_done is
+ *                 called. User should check their endpoint to see if rx_done
+ *                 is a supported operation.
+ */
+#define RPMSG_HANDLED	0
+#define RPMSG_DEFER	1
+
 typedef int (*rpmsg_rx_cb_t)(struct rpmsg_device *, void *, int, void *, u32);
 typedef int (*rpmsg_flowcontrol_cb_t)(struct rpmsg_device *, void *, bool);
 
@@ -73,6 +85,7 @@
  * @cb: rx callback handler
  * @flow_cb: remote flow control callback handler
  * @cb_lock: must be taken before accessing/changing @cb
+ * @rx_done: if set, rpmsg endpoint supports rpmsg_rx_done
  * @addr: local rpmsg address
  * @priv: private data for the driver's use
  *
@@ -96,6 +109,7 @@
 	rpmsg_rx_cb_t cb;
 	rpmsg_flowcontrol_cb_t flow_cb;
 	struct mutex cb_lock;
+	bool rx_done;
 	u32 addr;
 	void *priv;
 
@@ -199,6 +213,8 @@
 
 int rpmsg_set_flow_control(struct rpmsg_endpoint *ept, bool pause, u32 dst);
 
+int rpmsg_rx_done(struct rpmsg_endpoint *ept, void *data);
+
 #else
 
 static inline int rpmsg_register_device_override(struct rpmsg_device *rpdev,
@@ -327,6 +343,14 @@
 {
 	/* This shouldn't be possible */
 	WARN_ON(1);
+
+	return -ENXIO;
+}
+
+static inline int rpmsg_rx_done(struct rpmsg_endpoint *ept, void *data)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
 
 	return -ENXIO;
 }
