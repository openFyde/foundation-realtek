From 5f70683bb092e118c030abec0feee9b535a37c85 Mon Sep 17 00:00:00 2001
From: Edward Wu <edwardwu@realtek.com>
Date: Wed, 10 Jul 2024 07:31:33 +0800
Subject: [PATCH] media: rtk_vdec_rtd16xxb: update v4l2 driver

internal v4l2 commit:
95a9eef6a830472e1bf18ae7f1de435e3f9c22b6

Change-Id: I95e26e2bca8cbd0178f98914f489775840bc430d
---
 .../media/platform/rtk_vdec_rtd16xxb/drv_if.c |  16 +-
 .../media/platform/rtk_vdec_rtd16xxb/ve2.c    |  67 +++--
 .../platform/rtk_vdec_rtd16xxb/ve2_frame.h    |  23 +-
 .../media/platform/rtk_vdec_rtd16xxb/ve2rpc.c | 269 ++++++++++++------
 .../media/platform/rtk_vdec_rtd16xxb/ve2rpc.h |  30 +-
 .../platform/rtk_vdec_rtd16xxb/ve2rpc_cmd.h   |  26 +-
 .../media/platform/rtk_vdec_rtd16xxb/vpu.c    |  31 +-
 .../media/platform/rtk_vdec_rtd16xxb/vpu.h    |   3 +-
 8 files changed, 324 insertions(+), 141 deletions(-)

diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c b/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c
index e5e3e2c7e6ea..754108aebcf9 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c
@@ -488,6 +488,20 @@ static int videc_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)
 	return v4l2_m2m_qbuf(file, fh->m2m_ctx, buf);
 }
 
+static int videc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)
+{
+	struct v4l2_fh *fh = file->private_data;
+
+	struct videc_ctx *vid_ctx = file2ctx(file);
+	struct vpu_ctx *vpu_ctx = vid_ctx->vpu_ctx;
+	if(vpu_ctx->is_decoder_error){
+		vpu_err("Call on DQBUF after decoder error");
+		return -EIO;
+	}
+
+	return v4l2_m2m_dqbuf(file, fh->m2m_ctx, buf);
+}
+
 static int videc_create_bufs(struct file *file, void *priv,
 			     struct v4l2_create_buffers *create)
 {
@@ -635,7 +649,7 @@ static const struct v4l2_ioctl_ops vpu_ioctl_ops = {
 	.vidioc_reqbufs = videc_reqbufs,
 	.vidioc_querybuf = videc_querybuf,
 	.vidioc_qbuf = videc_qbuf,
-	.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,
+	.vidioc_dqbuf = videc_dqbuf,
 	.vidioc_prepare_buf = videc_prepare_buf,
 	.vidioc_create_bufs = videc_create_bufs,
 	.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c
index 770915a16ba1..85b325029201 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c
@@ -56,6 +56,7 @@ struct ve2_ctx {
 	bool streamon_cap;
 	bool streamoff_out;
 	bool streamoff_cap;
+	int32_t internal_buf_cnt;
 };
 
 /* Return dma-buf fd and get offset & size from RPC driver */
@@ -106,14 +107,8 @@ int ve2_start_streaming(struct vb2_queue *q, uint32_t count, int pixelformat)
 		return -EINVAL;
 	}
 
-	pr_err("ve2_start_streaming(%d), codec %s\n", V4L2_TYPE_IS_OUTPUT(type),
-	       (pixelformat == V4L2_PIX_FMT_HEVC) ?
-		       "HEVC" :
-		       ((pixelformat == V4L2_PIX_FMT_AV1) ?
-				"AV1" :
-				((pixelformat == V4L2_PIX_FMT_VP9) ?
-					 "VP9" :
-					 "Unknow")));
+	pr_err("ve2_start_streaming(%s), codec %p4cc\n", v4l2_type_names[type],
+	       &pixelformat);
 
 	if (!(pixelformat == V4L2_PIX_FMT_HEVC ||
 	      pixelformat == V4L2_PIX_FMT_AV1 ||
@@ -227,6 +222,12 @@ int ve2_start_streaming(struct vb2_queue *q, uint32_t count, int pixelformat)
 			vpu_err("ve2rpc fail to set cmprs\n");
 			return -EPERM;
 		}
+
+		ret = ve2rpc_set_res_info(ctx->out_hndl);
+		if (ret) {
+			vpu_err("ve2rpc fail to set res info\n");
+			return -EPERM;
+		}
 	} else { /*Second time stream on */
 		ret = ve2rpc_run(ctx->cap_hndl);
 		if (ret) {
@@ -481,11 +482,23 @@ static int ve2_out_qbuf(void *fh, uint8_t *buf, uint32_t len, uint64_t pts,
 	vpu_input_dbg("ve2_out_qbuf seq %d, pts %lld, len %x\n", sequence, pts,
 		      len);
 
-	if (v_ctx->is_error || cap_hdl->is_error) {
-		vpu_err("%s decode error %d, %d", __func__, v_ctx->is_error, cap_hdl->is_error);
+	if (v_ctx->is_decoder_error || out_hdl->is_error) {
+		vpu_err("%s decode error %d, %d", __func__,v_ctx->is_decoder_error, cap_hdl->is_error);
+		v_ctx->is_decoder_error = true;
+		return -EIO;
+	}
+	if (v_ctx->is_bs_error) {
+		vpu_err("%s bitstream error %d", __func__, v_ctx->is_bs_error);
 		return -EINVAL;
 	}
 
+	if (v_ctx->cap_fmt.misc.bufcnt > 0 &&
+		ctx->internal_buf_cnt > (v_ctx->cap_fmt.misc.bufcnt << 1)) {
+		vpu_input_dbg("too many internal buffers %d, %d\n", ctx->internal_buf_cnt,
+		      v_ctx->cap_fmt.misc.bufcnt);
+		return -ENOSPC;
+	}
+
 	ret = ve2rpc_write_bs(out_hdl, buf, len, pts, sequence);
 	if (ret) {
 		vpu_input_dbg("ve2rpc_write_bs fail, ret %d\n", ret);
@@ -503,7 +516,7 @@ static int ve2_out_qbuf(void *fh, uint8_t *buf, uint32_t len, uint64_t pts,
 		list_add_tail(&p->list, &ctx->pts_list);
 		mutex_unlock(&ctx->cap_hndl->pts_mutex);
 
-		out_hdl->out_q_fill_cnt++;
+		ctx->internal_buf_cnt++;
 	}
 
 	return 0;
@@ -536,6 +549,7 @@ static int ve2_cap_qbuf(void *fh, struct vb2_buffer *vb)
 	cap_buf_paddr = vb2_dma_contig_plane_dma_addr(vb, 0);
 	if (ctx->cap_hndl->dpb_cnt < vb->vb2_queue->num_buffers) {
 		uint32_t cap_buf_size = 0;
+		struct rtkve2_reg_dpb_t dpb;
 
 		cap_buf_size = vb2_plane_size(vb, 0);
 		if (cap_buf_size == 0) {
@@ -544,14 +558,19 @@ static int ve2_cap_qbuf(void *fh, struct vb2_buffer *vb)
 			goto exit;
 		}
 
+		dpb.width = v_ctx->cap_fmt.misc.ori_width;
+		dpb.height = v_ctx->cap_fmt.misc.ori_height;
+		dpb.dpb_width = v_ctx->cap_fmt.spec.fmt.pix_mp.width;
+		dpb.dpb_height = v_ctx->cap_fmt.spec.fmt.pix_mp.height;
+		dpb.size = cap_buf_size;
+		dpb.y_phy_addr = (uint64_t)cap_buf_paddr;
+		dpb.c_phy_addr = dpb.y_phy_addr + dpb.dpb_width * dpb.dpb_height;
+		dpb.bit_depth = v_ctx->bit_depth;
+		dpb.vb2_v4l2_buf = vb2_v4l2_buf;
+		dpb.idx = vb->index;
+
 		ret = ve2rpc_add_capbuf_to_dpb(
-			ctx->out_hndl, ctx->cap_hndl,
-			v_ctx->cap_fmt.misc.ori_width,
-			v_ctx->cap_fmt.misc.ori_height,
-			v_ctx->cap_fmt.spec.fmt.pix_mp.width,
-			v_ctx->cap_fmt.spec.fmt.pix_mp.height, cap_buf_size,
-			(uint64_t)cap_buf_paddr, vb2_v4l2_buf,
-			vb->index, v_ctx->bit_depth);
+			ctx->out_hndl, ctx->cap_hndl, dpb);
 		if (ret != 0)
 			goto exit;
 	}
@@ -691,6 +710,7 @@ int ve2_cap_dqbuf(void *fh, uint8_t *buf, uint64_t *pts,
 {
 	struct ve2_ctx *ctx = fh_to_ve(fh);
 	struct vpu_ctx *v_ctx = NULL;
+	uint32_t no_show_frm_cnt = 0;
 	int ret;
 #ifdef VPU_GET_CC
 	char cc_message[VIDEO_CC_DATA_LENGTH];
@@ -714,7 +734,7 @@ int ve2_cap_dqbuf(void *fh, uint8_t *buf, uint64_t *pts,
 	}
 	update_color_matrix(fh);
 	ret = ve2rpc_dqframe(ctx->cap_hndl, disp_buf, pts, &ctx->eos,
-			     &ctx->no_frame);
+			     &ctx->no_frame, &no_show_frm_cnt);
 	if (ret) {
 		//ve2_cap_dqbuf fail is normal
 		return ret;
@@ -733,6 +753,7 @@ int ve2_cap_dqbuf(void *fh, uint8_t *buf, uint64_t *pts,
 
 	ve2rpc_update_dpb_st(ctx->cap_hndl,  *disp_buf, RTKVE2_DPB_ST_DQ);
 
+	ctx->internal_buf_cnt -= (no_show_frm_cnt + 1);
 	return 0;
 }
 
@@ -846,7 +867,12 @@ static int ve2_pasre_header(void *fh, struct vb2_buffer *vb, uint32_t *width,
 				 min_reqbuf, bit_depth);
 
 	if (!ret && *bit_depth == 0x80000000 && *min_reqbuf == 0) {
-		v_ctx->is_error = true;
+		v_ctx->is_bs_error = true;
+		vpu_err("ve2_pasre_header: bitstream keyframe error!\n");
+		ret = -EFAULT;
+		goto exit;
+	} else if (!ret && *bit_depth == 0x40000000 && *min_reqbuf == 0) {
+		v_ctx->is_decoder_error = true;
 		vpu_err("ve2_pasre_header: Codec not support!\n");
 		ret = -EFAULT;
 		goto exit;
@@ -867,6 +893,7 @@ static int ve2_pasre_header(void *fh, struct vb2_buffer *vb, uint32_t *width,
 	v_ctx->bit_depth = (*bit_depth == 0)?8:10;
 	v_ctx->ddr_width = ddr_width;
 	v_ctx->ddr_height = ddr_height;
+	v_ctx->is_bs_error = false;
 
 	vpu_update_cap_fmt(fh, (void *)&vpu_fmt);
 	vpu_notify_event_resolution_change(fh);
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2_frame.h b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2_frame.h
index fc7af1a0e72a..e242f496ced5 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2_frame.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2_frame.h
@@ -189,7 +189,28 @@ typedef struct {
 
 	unsigned int nPixelAR_hor;
 	unsigned int nPixelAR_ver;
-	unsigned int reserved[22];
+	union {
+		unsigned int data;
+		struct {
+			unsigned int have_timecode:1;     // bit[0]
+			unsigned int seconds:6;           // bit[6:1]
+			unsigned int minutes:6;           // bit[12:7]
+			unsigned int hours:5;             // bit[17:13]
+			unsigned int frames:9;            // bit[26:18]
+		};
+	} nHevc_tc_timestamp;
+	union{
+		unsigned int data;
+		struct{
+			unsigned int colour_primaries:8; // bit[7:0]
+			unsigned int transferCharacteristics:8; // bit[15:8]
+		};
+	}nVUI_information;
+	unsigned int dv_rpu_metadata_addr;
+	unsigned int dv_rpu_metadata_size;
+	unsigned int noShowFrame_count;
+	unsigned int noShowFrame_picId[8];
+	unsigned int reserved[9];
 } ve2rpc_flash_frame_info_t;
 
 #endif
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.c
index eaae8f06029a..9ce1d87262c7 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.c
@@ -49,6 +49,8 @@ struct traveling_frame_st {
 	struct list_head list;
 	uint32_t phy_addr;
 	uint32_t vb2_q_idx;
+	uint32_t buflock_phy_addr;
+	void *vb2_v4l2_buf;
 };
 struct ve2rpc_dqframe {
 	struct list_head list;
@@ -951,6 +953,37 @@ int ve2rpc_set_cmprs(struct ve2rpc *hndl, uint8_t enable)
 	return 0;
 }
 
+int ve2rpc_set_res_info(struct ve2rpc *hndl)
+{
+	VIDEO_RPC_RESOURCE_INFO info;
+	int ret;
+
+	if (!hndl || !hndl->instanceID)
+		return -1;
+
+	mutex_lock(&hndl->lock);
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->instanceID);
+	info.max_width = htonl(4096);
+	info.max_height = htonl(2304);
+	info.width = htonl(3840);
+	info.height = htonl(2160);
+	info.framerate = htonl(60);
+	info.resource_ctrl_sets = htonl(0x80);
+
+	ret = _ve2rpc_shuttle(hndl, VIDEO_RPC_ToAgent_SetResourceInfo, &info,
+			      sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		vpu_err("fail to do cmd %d \n",
+			VIDEO_RPC_ToAgent_SetResourceInfo);
+		return (-EPERM);
+	}
+
+	return 0;
+}
+
 int ve2rpc_get_bs_info(struct device *dev, void *fh, uint32_t codec,
 		       uint32_t size, void *buf, uint32_t *width,
 		       uint32_t *height, uint32_t *ddr_width,
@@ -1427,37 +1460,34 @@ int ve2rpc_inband_eos_event(struct ve2rpc_ringbuf_t *ringbuf,
 }
 
 int ve2rpc_inband_add_buf(struct ve2rpc_ringbuf_t *ringbuf,
-			  uint32_t width, uint32_t height,
-			  uint32_t dpb_width, uint32_t dpb_height,
-			  uint32_t y_phy_addr, uint32_t c_phy_addr,
-			  uint32_t cmprs_hdr_lu, uint32_t cmprs_hdr_ch,
-			  uint32_t bit_depth)
+			  struct rtkve2_reg_dpb_t dpb,
+			  uint32_t cmprs_hdr_lu, uint32_t cmprs_hdr_ch)
 {
 	int ret = 0;
 	FRAME_INFO_IN cmd;
 
-	if(bit_depth != 8 && bit_depth != 10)
-		bit_depth = 0;
+	if(dpb.bit_depth != 8 && dpb.bit_depth != 10)
+		dpb.bit_depth = 0;
 
 	cmd.header.type = VIDEO_FRAME_INBAND_ADD;
 	cmd.header.size = sizeof(FRAME_INFO_IN);
-	cmd.lu_addr = y_phy_addr;
-	cmd.ch_addr = c_phy_addr;
+	cmd.lu_addr = dpb.y_phy_addr;
+	cmd.ch_addr = dpb.c_phy_addr;;
 	cmd.decimate_lu_addr = 0;
 	cmd.decimate_ch_addr = 0;
 	cmd.cmprs_hdr_lu = cmprs_hdr_lu;
 	cmd.cmprs_hdr_ch = cmprs_hdr_ch;
-	cmd.width = width;
-	cmd.height = height;
+	cmd.width = dpb.width;
+	cmd.height = dpb.height;
 	cmd.decimate_width = 0;
 	cmd.decimate_height = 0;
-	cmd.ddr_width = dpb_width;
-	cmd.ddr_height = dpb_height;
+	cmd.ddr_width = dpb.dpb_width;
+	cmd.ddr_height = dpb.dpb_height;
 	cmd.cmprs_hdr_size = 0;
 	cmd.cmprs_en = 0;
 	cmd.lossy_en = 0;
 	cmd.lossy_ratio = 0;
-	cmd.bit_depth = bit_depth;
+	cmd.bit_depth = dpb.bit_depth;
 	cmd.decimate_en = 0;
 	cmd.decimate_ratio = 0;
 
@@ -1578,7 +1608,7 @@ int ve2rpc_get_decoded_frm_cnt(struct ve2rpc *hndl)
 			disp_frm_cnt = (wptr - rptr) /
 				       sizeof(ve2rpc_flash_frame_info_t);
 		else
-			disp_frm_cnt = (wptr + prb->pRBH->size - rptr) /
+			disp_frm_cnt = (wptr + prb->size - rptr) /
 				       sizeof(ve2rpc_flash_frame_info_t);
 	}
 	mutex_unlock(&prb->lock);
@@ -1625,11 +1655,69 @@ void ve2rpc_update_dpb_st(struct ve2rpc *cap_hndl,
 
 }
 
+int ve2rpc_add_travel_entry(struct ve2rpc *cap_hndl,
+	uint32_t y_phy_addr, uint32_t buflock_phy_addr,
+	void *vb2_v4l2_buf, uint32_t idx)
+{
+	struct traveling_frame_st *tframe;
+	int ret = 0;
+
+	tframe = kmalloc(sizeof(struct traveling_frame_st),
+			 GFP_KERNEL | __GFP_ZERO);
+	if (!tframe) {
+		vpu_err("kmalloc traveling_frame_st fail\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	tframe->phy_addr = y_phy_addr;
+	tframe->vb2_q_idx = idx;
+	tframe->vb2_v4l2_buf = vb2_v4l2_buf;
+	tframe->buflock_phy_addr = buflock_phy_addr;
+
+	mutex_lock(&cap_hndl->travel_mutex);
+	list_add_tail(&tframe->list, &cap_hndl->qframe.tlist);
+	mutex_unlock(&cap_hndl->travel_mutex);
+exit:
+	return ret;
+}
+
+int ve2rpc_free_travel_entry(struct ve2rpc *cap_hndl,
+	uint32_t buflock_pa, uint32_t vb2_q_idx, uint8_t no_lock)
+{
+	struct traveling_frame_st *tentry;
+	struct traveling_frame_st *tmp_tentry = NULL;
+
+	if (!cap_hndl) {
+		vpu_err("cap isn't ready\n");
+		return -EPERM;
+	}
+
+	if(!no_lock)
+		mutex_lock(&cap_hndl->travel_mutex);
+
+	list_for_each_entry_safe (tentry, tmp_tentry,
+				  &cap_hndl->qframe.tlist, list) {
+		if (tentry->buflock_phy_addr == buflock_pa &&
+			tentry->vb2_q_idx == vb2_q_idx) {
+			tentry->phy_addr = 0;
+			tentry->vb2_q_idx = -1;
+			tentry->vb2_v4l2_buf = NULL;
+			list_del(&tentry->list);
+			kfree(tentry);
+
+			break;
+		}
+	}
+
+	if(!no_lock)
+		mutex_unlock(&cap_hndl->travel_mutex);
+
+	return 0;
+}
+
 int ve2rpc_add_capbuf_to_dpb(struct ve2rpc *out_hndl, struct ve2rpc *cap_hndl,
-			     uint32_t width, uint32_t height,
-			     uint32_t dpb_width, uint32_t dpb_height, uint32_t size,
-			     uint64_t phys_addr, void *vb2_v4l2_buf,
-			     uint32_t idx, uint32_t bit_depth)
+			     struct rtkve2_reg_dpb_t dpb)
 {
 	int ret = 0;
 	int i = 0;
@@ -1637,11 +1725,11 @@ int ve2rpc_add_capbuf_to_dpb(struct ve2rpc *out_hndl, struct ve2rpc *cap_hndl,
 	uint32_t cmprs_hdr_ch = 0;
 	struct ve2rpc_ion_object *cmprs = NULL;
 
-	if ((out_hndl == NULL) || (cap_hndl == NULL) || (size == 0) ||
-	    (phys_addr == 0) || (vb2_v4l2_buf == NULL)) {
+	if ((out_hndl == NULL) || (cap_hndl == NULL) || (dpb.size == 0) ||
+	    (dpb.y_phy_addr == 0) || (dpb.vb2_v4l2_buf == NULL)) {
 		vpu_err("%s invalid parameters out_hndl:%px, cap_hndl:%px, size:%d, phys_addr:0x%llx, vb2_v4l2_buf:%px\n",
-			__func__, out_hndl, cap_hndl, size, phys_addr,
-			vb2_v4l2_buf);
+			__func__, out_hndl, cap_hndl, dpb.size, dpb.y_phy_addr,
+			dpb.vb2_v4l2_buf);
 		ret = -EINVAL;
 		goto exit;
 	}
@@ -1659,22 +1747,23 @@ int ve2rpc_add_capbuf_to_dpb(struct ve2rpc *out_hndl, struct ve2rpc *cap_hndl,
 		goto exit;
 	}
 
-	cap_hndl->dpb[i].size = size;
+	cap_hndl->dpb[i].size = dpb.size;
 	cap_hndl->dpb[i].status = RTKVE2_DPB_ST_VALID;
-	cap_hndl->dpb[i].y_phy_addr = phys_addr;
-	cap_hndl->dpb[i].c_phy_addr = phys_addr + dpb_width * dpb_height;
+	cap_hndl->dpb[i].y_phy_addr = dpb.y_phy_addr;
+	cap_hndl->dpb[i].c_phy_addr = dpb.c_phy_addr;;
 	cap_hndl->dpb[i].cmprs = cmprs;
-	cap_hndl->dpb[i].vb2_v4l2_buf = vb2_v4l2_buf;
-	cap_hndl->dpb[i].buflock_phy_addr = cap_hndl->buflockPhy[i];
-	cap_hndl->dpb[i].idx = idx;
+	cap_hndl->dpb[i].vb2_v4l2_buf = dpb.vb2_v4l2_buf;
+	cap_hndl->dpb[i].idx = dpb.idx;
 	cap_hndl->dpb_cnt++;
 	mutex_unlock(&cap_hndl->dpb_mutex);
 
-	ret = ve2rpc_inband_add_buf(&out_hndl->dpb_rb, width, height,
-				    dpb_width, dpb_height,
-				    cap_hndl->dpb[i].y_phy_addr, cap_hndl->dpb[i].c_phy_addr,
-				    cmprs_hdr_lu, cmprs_hdr_ch,
-				    bit_depth);
+	ret = ve2rpc_inband_add_buf(&out_hndl->dpb_rb, dpb,
+				    cmprs_hdr_lu, cmprs_hdr_ch);
+	if (!ret) {
+		ret = ve2rpc_add_travel_entry(cap_hndl,
+			 cap_hndl->dpb[i].y_phy_addr, cap_hndl->buflockPhy[i],
+			 cap_hndl->dpb[i].vb2_v4l2_buf, cap_hndl->dpb[i].idx);
+	}
 exit:
 	return ret;
 }
@@ -1715,11 +1804,13 @@ int ve2rpc_qframe(struct ve2rpc *cap_hndl, dma_addr_t phy_addr,
 	volatile ve2rpc_flash_frame_info_t *frame;
 	struct ve2rpc_ion_object *buflock;
 	struct ve2rpc_ringbuf_t *prb;
-	uint32_t buflock_pa;
+	uint32_t buflock_pa = 0;
 	volatile uint8_t *buflock_va;
 	uint8_t isInitial = 0;
 	uint32_t frm_idx = 0;
-	int i = 0;
+	struct traveling_frame_st *tentry;
+	struct traveling_frame_st *tmp_tentry = NULL;
+	int ret = 0;
 
 	if (!cap_hndl || !cap_hndl->instanceID) {
 		vpu_err("handle = %p hndl->instanceID=%d ", cap_hndl,
@@ -1735,11 +1826,23 @@ int ve2rpc_qframe(struct ve2rpc *cap_hndl, dma_addr_t phy_addr,
 		return -EPERM;
 	}
 
+	if(!free_travel_frame)
+		mutex_lock(&cap_hndl->travel_mutex);
+
+	list_for_each_entry_safe (tentry, tmp_tentry,
+		&cap_hndl->qframe.tlist, list) {
+		if ((tentry->phy_addr == phy_addr) &&
+			(tentry->vb2_q_idx == vb2_q_idx)) {
+				tentry->phy_addr = 0;
+				buflock_pa = tentry->buflock_phy_addr;
+				break;
+			}
+		}
+
+	if(!free_travel_frame)
+		mutex_unlock(&cap_hndl->travel_mutex);
 
 	buflock = (struct ve2rpc_ion_object *)cap_hndl->buflock;
-	mutex_lock(&cap_hndl->dpb_mutex);
-	buflock_pa = cap_hndl->dpb[vb2_q_idx].buflock_phy_addr;
-	mutex_unlock(&cap_hndl->dpb_mutex);
 	buflock_va = _get_buflock_va(buflock, buflock_pa);
 	if (!buflock_va) {
 		vpu_err("can't find buflock_va by buflock_pa %x, buflock %p\n",
@@ -1766,20 +1869,6 @@ int ve2rpc_qframe(struct ve2rpc *cap_hndl, dma_addr_t phy_addr,
 		return -EINVAL;
 	}
 
-	mutex_lock(&cap_hndl->dpb_mutex);
-	for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
-		if (cap_hndl->dpb[i].y_phy_addr == phy_addr) {
-			cap_hndl->dpb[i].buflock_phy_addr = 0;
-			break;
-		}
-	}
-
-	if (i == VE2_MAX_DPB_NUM) {
-		vpu_err("%s, Can't find vb2_v4l2_buf for 0x%llx\n",
-			__func__, phy_addr);
-	}
-	mutex_unlock(&cap_hndl->dpb_mutex);
-
 	mutex_unlock(&cap_hndl->buflock_mutex);
 
 	frm_idx = cap_hndl->outputRingIdx++;
@@ -1801,6 +1890,9 @@ int ve2rpc_qframe(struct ve2rpc *cap_hndl, dma_addr_t phy_addr,
 		frame->pUserData = htonl((uint32_t)phy_addr);
 		dsb(sy);
 		mutex_unlock(&prb->lock);
+
+		ret = ve2rpc_free_travel_entry(cap_hndl, buflock_pa, vb2_q_idx,
+			free_travel_frame);
 	} else {
 		struct ve2rpc_qframe_st *re_qframe =
 			kmalloc(sizeof(struct ve2rpc_qframe_st),
@@ -1833,7 +1925,7 @@ int ve2rpc_qframe(struct ve2rpc *cap_hndl, dma_addr_t phy_addr,
 				   delay);
 	}
 
-	return 0;
+	return ret;
 }
 
 void ve2rpc_re_qframe(struct work_struct *work)
@@ -1842,12 +1934,12 @@ void ve2rpc_re_qframe(struct work_struct *work)
 		to_delayed_work(work), struct ve2rpc_qframe_wq, work);
 	struct ve2rpc_qframe_st *entry = NULL;
 	struct ve2rpc_qframe_st *tmp_entry = NULL;
-	struct traveling_frame_st *tentry;
-	struct traveling_frame_st *tmp_tentry = NULL;
 	uint32_t vb2_q_idx;
 	uint32_t frm_idx;
 	uint32_t UserData;
+	uint32_t buflock_pa;
 	struct mutex *travel_mutex;
+	struct ve2rpc *hndl;
 	uint8_t bNeedFree = 0;
 
 	list_for_each_entry_safe (entry, tmp_entry, &wq->list, list) {
@@ -1856,7 +1948,9 @@ void ve2rpc_re_qframe(struct work_struct *work)
 			vb2_q_idx = entry->vb2_q_idx;
 			frm_idx = entry->frm_idx;
 			UserData = entry->UserData;
+			buflock_pa = entry->buflock_pa;
 			travel_mutex = entry->travel_mutex;
+			hndl = entry->hndl;
 			mutex_lock(entry->buflock_mutex);
 			if (!entry->free_travel_frame &&
 			    ((*entry->buflock_va) != E_BUFLOCK_ST_RELEASE)) {
@@ -1904,18 +1998,7 @@ void ve2rpc_re_qframe(struct work_struct *work)
 		mutex_unlock(&wq->lock);
 
 		if (bNeedFree) {
-			mutex_lock(travel_mutex);
-			list_for_each_entry_safe (tentry, tmp_tentry,
-						  &wq->tlist, list) {
-				if ((tentry->phy_addr == UserData) &&
-				    (tentry->vb2_q_idx == vb2_q_idx)) {
-					tentry->phy_addr = 0;
-					tentry->vb2_q_idx = -1;
-					list_del(&tentry->list);
-					kfree(tentry);
-				}
-			}
-			mutex_unlock(travel_mutex);
+			ve2rpc_free_travel_entry(hndl, buflock_pa, vb2_q_idx, 0);
 			bNeedFree = 0;
 		}
 	}
@@ -1923,13 +2006,13 @@ void ve2rpc_re_qframe(struct work_struct *work)
 
 static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 			     uint64_t *pts, int frm_idx, bool *eos,
-			     bool *no_frame, uint8_t secure)
+			     bool *no_frame, uint32_t *no_show_frm_cnt, uint8_t secure)
 {
 	volatile ve2rpc_flash_frame_info_t *frame;
 	struct ve2rpc_ion_object *buflock;
 	volatile uint8_t *buflock_va;
 	uint32_t flags;
-	struct traveling_frame_st *tframe;
+	uint32_t nVersion = 0;
 
 	unsigned int ptsHigh = 0;
 	int ptsLow = 0;
@@ -1957,11 +2040,12 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 	y_phy_addr = htonl(frame->nPicPhysicalAddr);
 	c_phy_addr = htonl(frame->nPicCPhysicalAddr);
 	buflock_phy_addr =  htonl(frame->nBufLockPhysicalAddr);
-
+	*no_show_frm_cnt = htonl(frame->noShowFrame_count);
 	ptsLow = htonl(frame->nPtsLow);
 	ptsHigh = htonl(frame->nPtsHigh);
 
 	flags = htonl(frame->nPicFlags);
+	nVersion = htonl(frame->nVersion);
 
 #ifdef ENABLE_SHOW_VIDEO_INFO
 	vpu_keep_fm_info(htonl(frame->nPicWidth), htonl(frame->nPicHeight));
@@ -1969,11 +2053,20 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 
 	dsb(sy);
 
+	if (nVersion == 0x8001) {
+		pr_err("No decoded frame with no show frame count %d", *no_show_frm_cnt);
+		ret = -ENODATA;
+		*no_frame = true;
+		goto exit;
+	}
+
 	mutex_lock(&cap_hndl->travel_mutex);
 	list_for_each_entry_safe (tentry, tmp_tentry, &cap_hndl->qframe.tlist,
 		list) {
-		if (tentry->phy_addr == y_phy_addr) {
-			vpu_output_dbg("Show existing frame!!!!");
+		struct vb2_v4l2_buffer *buf = (struct vb2_v4l2_buffer *)tentry->vb2_v4l2_buf;
+		if (y_phy_addr && tentry->phy_addr == y_phy_addr &&
+			buf->vb2_buf.state != VB2_BUF_STATE_ACTIVE ) {
+			vpu_output_dbg("Waiting for show existing frame %d!!!!", buf->vb2_buf.state);
 			ret = -EBUSY;
 			mutex_unlock(&cap_hndl->travel_mutex);
 			return ret;
@@ -2063,7 +2156,6 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 		for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
 			if (cap_hndl->dpb[i].y_phy_addr == y_phy_addr) {
 				*disp_buf = cap_hndl->dpb[i].vb2_v4l2_buf;
-				cap_hndl->dpb[i].buflock_phy_addr = buflock_phy_addr;
 				idx = cap_hndl->dpb[i].idx;
 				break;
 			}
@@ -2077,40 +2169,29 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 		}
 	} else {
 		for (i = VE2_MAX_DPB_NUM - 1; i >= 0; i--) {
-			if (cap_hndl->dpb[i].status != RTKVE2_DPB_ST_EMPTY &&
-				cap_hndl->dpb[i].buflock_phy_addr == 0) {
+			if (cap_hndl->dpb[i].status == RTKVE2_DPB_ST_VALID) {
 				*disp_buf = cap_hndl->dpb[i].vb2_v4l2_buf;
-				cap_hndl->dpb[i].buflock_phy_addr = buflock_phy_addr;
 				idx = cap_hndl->dpb[i].idx;
 				break;
 			}
 		}
 
 		if (i == -1) {
-			vpu_err("Can't find for buflock_phy_addr is 0\n");
+			vpu_err("Can't find valid buffer for EOS\n");
 			mutex_unlock(&cap_hndl->dpb_mutex);
 			return -ENODATA;
 		}
 	}
 	mutex_unlock(&cap_hndl->dpb_mutex);
 
-	tframe = kmalloc(sizeof(struct traveling_frame_st),
-			 GFP_KERNEL | __GFP_ZERO);
-	if (!tframe) {
-		vpu_err("kmalloc traveling_frame_st fail\n");
-		return -ENOMEM;
-	}
-	tframe->phy_addr = y_phy_addr;
-	tframe->vb2_q_idx = idx;
-
-	mutex_lock(&cap_hndl->travel_mutex);
-	list_add_tail(&tframe->list, &cap_hndl->qframe.tlist);
-	mutex_unlock(&cap_hndl->travel_mutex);
+	ret = ve2rpc_add_travel_entry(cap_hndl,
+		y_phy_addr, buflock_phy_addr, *disp_buf, idx);
+exit:
 	return ret;
 }
 
 int ve2rpc_dqframe(struct ve2rpc *cap_hndl, void *disp_buf, uint64_t *pts,
-		   bool *eos, bool *no_frame)
+		   bool *eos, bool *no_frame, uint32_t *no_show_frm_cnt)
 {
 	struct ve2rpc_ringbuf_t *prb;
 
@@ -2141,8 +2222,10 @@ int ve2rpc_dqframe(struct ve2rpc *cap_hndl, void *disp_buf, uint64_t *pts,
 					  sizeof(ve2rpc_flash_frame_info_t);
 
 			ret = _ve2rpc_get_frame(cap_hndl, disp_buf, pts, rp_idx,
-						eos, no_frame, prb->secure);
-			if (ret) {
+						eos, no_frame, no_show_frm_cnt, prb->secure);
+			if (ret == -ENODATA) {
+				ret = -ENODATA;
+			} else if (ret != 0) {
 				mutex_unlock(&prb->lock);
 				if (ret != -EBUSY)
 					vpu_err("fail to get a frame, try again ret %d\n",
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.h b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.h
index 41e8a46a3461..9e6b6b26e929 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.h
@@ -148,13 +148,25 @@ enum dpb_st {
 	RTKVE2_DPB_ST_DQ
 };
 
+struct rtkve2_reg_dpb_t {
+	uint32_t width;
+	uint32_t height;
+	uint32_t dpb_width;
+	uint32_t dpb_height;
+	uint32_t size;
+	uint64_t y_phy_addr;
+	uint64_t c_phy_addr;
+	uint32_t bit_depth;
+	void *vb2_v4l2_buf;
+	uint32_t idx;
+};
+
 struct rtkve2_dpb_t {
 	unsigned int size;
 	unsigned int width;
 	unsigned int height;
 	uint32_t y_phy_addr;
 	uint32_t c_phy_addr;
-	uint32_t buflock_phy_addr;
 	struct ve2rpc_ion_object *cmprs;
 	void *vb2_v4l2_buf;
 	uint8_t idx;
@@ -190,7 +202,6 @@ struct ve2rpc {
 	unsigned int teeapi_tee_session;
 #endif
 	struct color_metrix col_matrix;
-	uint64_t out_q_fill_cnt;
 	VIDEO_STREAM_TYPE vType;
 	struct rtkve2_dpb_t dpb[VE2_MAX_DPB_NUM];
 	struct mutex dpb_mutex;
@@ -207,7 +218,7 @@ struct pts_queue {
 };
 
 int ve2rpc_dqframe(struct ve2rpc *cap_hndl, void *disp_buf, uint64_t *pts,
-		   bool *eos, bool *no_frame);
+		   bool *eos, bool *no_frame, uint32_t *no_show_frm_cnt);
 int ve2rpc_qframe(struct ve2rpc *cap_hndl, dma_addr_t phy_addr,
 		  uint32_t work_idx, uint8_t free_travel_frame);
 int ve2rpc_write_bs(struct ve2rpc *hndl, uint8_t *buf, uint32_t len,
@@ -241,20 +252,14 @@ int ve2rpc_SetRingBuffer(struct ve2rpc *hndl, struct ve2rpc_ringbuf_t *prb,
 			   uint8_t is_secure);
 int ve2rpc_get_decoded_frm_cnt(struct ve2rpc *hndl);
 int ve2rpc_add_capbuf_to_dpb(struct ve2rpc *out_hndl, struct ve2rpc *cap_hndl,
-			   uint32_t width, uint32_t height,
-			   uint32_t dpb_width, uint32_t dpb_height, uint32_t size,
-			   uint64_t phys_addr, void *vb2_v4l2_buf,
-			   uint32_t idx, uint32_t bit_depth);
+			     struct rtkve2_reg_dpb_t dpb);
 int ve2rpc_del_capbuf_from_dpb(struct ve2rpc *out_hndl,
 			   struct ve2rpc *cap_hndl);
 void ve2rpc_update_dpb_st(struct ve2rpc *cap_hndl,
 			   struct vb2_v4l2_buffer *vb2_v4l2_buffer, unsigned int status);
 int ve2rpc_inband_add_buf(struct ve2rpc_ringbuf_t *ringbuf,
-			   uint32_t width, uint32_t height,
-			   uint32_t dpb_width, uint32_t dpb_height,
-			   uint32_t y_phy_addr, uint32_t c_phy_addr,
-			   uint32_t cmprs_hdr_lu, uint32_t cmprs_hdr_ch,
-			   uint32_t bit_depth);
+			  struct rtkve2_reg_dpb_t dpb,
+			  uint32_t cmprs_hdr_lu, uint32_t cmprs_hdr_ch);
 int ve2rpc_inband_del_buf(struct ve2rpc_ringbuf_t *ringbuf,
 			   uint32_t y_phy_addr);
 int ve2rpc_set_cmprs(struct ve2rpc *hndl, uint8_t enable);
@@ -263,4 +268,5 @@ int ve2rpc_get_bs_info(struct device *dev, void *fh, uint32_t codec,
 		       uint32_t *height, uint32_t *ddr_width,
 		       uint32_t *ddr_height, uint32_t *min_reqbuf,
 		       uint32_t *bit_depth);
+int ve2rpc_set_res_info(struct ve2rpc *hndl);
 #endif
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc_cmd.h b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc_cmd.h
index 07a184d93a2a..2cc0e66dd947 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc_cmd.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc_cmd.h
@@ -547,7 +547,31 @@ struct VIDEO_RPC_DEC_PV_RESULT {
 	uint32_t height;
 	uint32_t bit_depth;
 	uint32_t DPB_size;
-};typedef struct VIDEO_RPC_DEC_PV_RESULT VIDEO_RPC_DEC_PV_RESULT;
+};
+typedef struct VIDEO_RPC_DEC_PV_RESULT VIDEO_RPC_DEC_PV_RESULT;
+
+enum VIDEO_RESOURCE_CORE_TYPE {
+        VIDEO_RESOURCE_CORE_REALTEK = 0,
+        VIDEO_RESOURCE_CORE_GOOGLE = 0 + 1,
+        VIDEO_RESOURCE_CORE_IP1 = 0 + 2,
+        VIDEO_RESOURCE_CORE_IP2 = 0 + 3,
+        VIDEO_RESOURCE_CORE_DUAL = 0 + 4,
+};
+typedef enum VIDEO_RESOURCE_CORE_TYPE VIDEO_RESOURCE_CORE_TYPE;
+
+struct VIDEO_RPC_RESOURCE_INFO {
+	int32_t resource_ctrl_sets;
+	enum VIDEO_RESOURCE_CORE_TYPE core_type;
+	int32_t video_port;
+	int32_t max_width;
+	int32_t max_height;
+	uint32_t instanceID;
+	int32_t width;
+	int32_t height;
+	int32_t framerate;
+	int32_t second_resource_ctrl_sets;
+};
+typedef struct VIDEO_RPC_RESOURCE_INFO VIDEO_RPC_RESOURCE_INFO;
 
 typedef int HRESULT;
 #define VIDEO_RPC_DEC_ToSystem_FatalError 63
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c b/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c
index 5a42d98e4f23..53f1d1a313e4 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c
@@ -40,6 +40,8 @@ static uint32_t pixfmt = 0;
 
 #define RTK_DPB_WIDTH_ALIGN 32
 #define RTK_DPB_HEIGHT_ALIGN 32
+#define RTK_VE2_WIDTH_ALIGN 128
+#define RTK_VE2_HEIGHT_ALIGN 128
 
 #define RTK_VPU_DEC_4K_CODED_MAX_WIDTH 4096
 #define RTK_VPU_DEC_4K_CODED_MAX_HEIGHT 2304
@@ -244,7 +246,7 @@ const static struct vpu_fmt out_fmt[] = {
 		.frmsize.step_height = 1,
 
 		/* struct vpu_misc */
-		.misc.bufcnt = 8,
+		.misc.bufcnt = 15,
 		.misc.VideoEngine = VIDEO_ENGINE_2,
 	},
 	{
@@ -271,7 +273,7 @@ const static struct vpu_fmt out_fmt[] = {
 		.frmsize.step_height = 1,
 
 		/* struct vpu_misc */
-		.misc.bufcnt = 8,
+		.misc.bufcnt = 10,
 		.misc.VideoEngine = VIDEO_ENGINE_2,
 	},
 	{
@@ -298,7 +300,7 @@ const static struct vpu_fmt out_fmt[] = {
 		.frmsize.step_height = 1,
 
 		/* struct vpu_misc */
-		.misc.bufcnt = 8,
+		.misc.bufcnt = 10,
 		.misc.VideoEngine = VIDEO_ENGINE_2,
 	},
 };
@@ -583,7 +585,7 @@ static int threadout(void *data)
 					spin_unlock_irqrestore(
 						&ctx->vpu_spin_lock, flags);
 					continue;
-				} else if (qbuf_ret == -EINVAL) {
+				} else if (qbuf_ret == -EINVAL || qbuf_ret == -EIO) {
 					vpu_info("%s ve_out_qbuf error, buf done VB2_BUF_STATE_ERROR\n", __func__);
 					v4l2_buf = v4l2_m2m_src_buf_remove(fh->m2m_ctx);
 					v4l2_m2m_buf_done(v4l2_buf, VB2_BUF_STATE_ERROR);
@@ -670,6 +672,7 @@ static int vpu_try_fmt(struct v4l2_fh *fh, struct v4l2_format *f)
 	unsigned int height = 0;
 	unsigned int bytesperline = 0;
 	unsigned int sizeimage = 0;
+	unsigned int pre_parse_error = 0;
 
 	fmt = find_format(f);
 	if (!fmt) {
@@ -689,11 +692,16 @@ static int vpu_try_fmt(struct v4l2_fh *fh, struct v4l2_format *f)
 		fmt->frmsize.max_height);
 
 	if (V4L2_TYPE_IS_CAPTURE(f->type)) {
-		if (ctx->out_fmt.misc.VideoEngine == VIDEO_ENGINE_2 &&
-			ctx->ddr_width && ctx->ddr_height) {
-			width = ctx->ddr_width;
-			height = ctx->ddr_height;
-			bytesperline = width;
+		if (ctx->out_fmt.misc.VideoEngine == VIDEO_ENGINE_2) {
+			if(ctx->ddr_width && ctx->ddr_height) {
+				width = ctx->ddr_width;
+				height = ctx->ddr_height;
+			}
+			else {
+				width = ALIGN(width, RTK_VE2_WIDTH_ALIGN);
+				height = ALIGN(height, RTK_VE2_HEIGHT_ALIGN);
+				pre_parse_error = 1;
+			}
 		} else {
 			width = ALIGN(width, RTK_DPB_WIDTH_ALIGN);
 			height = ALIGN(height, RTK_DPB_HEIGHT_ALIGN);
@@ -701,6 +709,7 @@ static int vpu_try_fmt(struct v4l2_fh *fh, struct v4l2_format *f)
 
 		bytesperline = width;
 		sizeimage = bytesperline * height * 3 / 2;
+		if(pre_parse_error) sizeimage = sizeimage * 10 / 8;
 	} else {
 		width = ALIGN(width, RTK_DPB_WIDTH_ALIGN);
 		height = ALIGN(height, RTK_DPB_HEIGHT_ALIGN);
@@ -994,7 +1003,7 @@ static int vpu_qbuf(struct v4l2_fh *fh, struct vb2_buffer *vb)
 		uint32_t min_reqbuf = 0;
 		uint32_t bit_depth = 0;
 		ctx->out_q_cnt++;
-		if (!ctx->parse_header_done && !ctx->is_out_started &&
+		if (!ctx->parse_header_done && !ctx->is_decoder_error &&
 		    ctx->veng_ops->ve_out_pre_parse) {
 			ret = ctx->veng_ops->ve_out_pre_parse(
 				fh, vb, &width, &height, &min_reqbuf, &bit_depth);
@@ -1105,8 +1114,6 @@ static int vpu_reset_resource(void *fh)
 		ctx->miss_last_buf_done = false;
 		ctx->cap_retry_cnt = 0;
 		ctx->out_q_cnt = 0;
-	}else {
-		vpu_err("Reset nothing");
 	}
 
 	return 0;
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.h b/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.h
index 7ba9cf992271..0e0da610733d 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.h
@@ -58,7 +58,8 @@ struct vpu_ctx {
 	uint32_t bit_depth;
 	unsigned int ddr_width;
 	unsigned int ddr_height;
-	bool is_error;
+	bool is_bs_error;
+	bool is_decoder_error;
 };
 
 struct vpu_fmt_ops {
-- 
2.45.2

