From ceab35280c80629831756f93d65adca84297da80 Mon Sep 17 00:00:00 2001
From: Edward Wu <edwardwu@realtek.com>
Date: Fri, 4 Jul 2025 18:24:50 +0800
Subject: [PATCH] media: add Realtek vpu decoder

Change-Id: I3f2f4589b0f7650f0e82df886d864605e8a021cd
---
 .../arm64/chromiumos-realtek.flavour.config   |   133 +
 drivers/media/platform/Makefile               |     2 +-
 drivers/media/platform/realtek/vpu/Kconfig    |    32 +
 drivers/media/platform/realtek/vpu/Makefile   |     3 +
 .../platform/realtek/vpu/stateful/Makefile    |    30 +
 .../platform/realtek/vpu/stateful/debug.h     |    64 +
 .../platform/realtek/vpu/stateful/drv_if.c    |  1270 ++
 .../platform/realtek/vpu/stateful/drv_if.h    |    79 +
 .../realtek/vpu/stateful/ve1_config.h         |    61 +
 .../realtek/vpu/stateful/ve1_decode.c         |   648 +
 .../platform/realtek/vpu/stateful/ve1_fw.h    | 12978 ++++++++++++++++
 .../platform/realtek/vpu/stateful/ve1_mem.c   |   324 +
 .../platform/realtek/vpu/stateful/ve1_mem.h   |    26 +
 .../realtek/vpu/stateful/ve1_mem_compat.c     |    69 +
 .../realtek/vpu/stateful/ve1_mem_compat.h     |    14 +
 .../realtek/vpu/stateful/ve1_mem_uapi.h       |    17 +
 .../platform/realtek/vpu/stateful/ve1_mm.c    |   580 +
 .../platform/realtek/vpu/stateful/ve1_mm.h    |    70 +
 .../realtek/vpu/stateful/ve1_product.c        |  1138 ++
 .../realtek/vpu/stateful/ve1_product.h        |   220 +
 .../realtek/vpu/stateful/ve1_regdefine.h      |   595 +
 .../platform/realtek/vpu/stateful/ve1_v4l2.c  |  1174 ++
 .../platform/realtek/vpu/stateful/ve1_v4l2.h  |   481 +
 .../platform/realtek/vpu/stateful/ve1_vdi.c   |  3054 ++++
 .../platform/realtek/vpu/stateful/ve1_vdi.h   |   209 +
 .../realtek/vpu/stateful/ve1_vdi_osal.c       |   310 +
 .../realtek/vpu/stateful/ve1_vdi_osal.h       |   130 +
 .../platform/realtek/vpu/stateful/ve1_vpu.c   |  4511 ++++++
 .../platform/realtek/vpu/stateful/ve1_vpu.h   |    97 +
 .../realtek/vpu/stateful/ve1_vpu_md5.h        |    15 +
 .../realtek/vpu/stateful/ve1_vpuapi.c         |  5093 ++++++
 .../realtek/vpu/stateful/ve1_vpuapi.h         |  6538 ++++++++
 .../realtek/vpu/stateful/ve1_vpuapifunc.c     |  5174 ++++++
 .../realtek/vpu/stateful/ve1_vpuapifunc.h     |   751 +
 .../realtek/vpu/stateful/ve1_vpuconfig.h      |   147 +
 .../realtek/vpu/stateful/ve1_vpuerror.h       |   229 +
 .../realtek/vpu/stateful/ve1_vputypes.h       |   104 +
 .../realtek/vpu/stateful/ve1_wrapper.c        |  3926 +++++
 .../realtek/vpu/stateful/ve1_wrapper.h        |    81 +
 .../media/platform/realtek/vpu/stateful/ve2.c |  1146 ++
 .../media/platform/realtek/vpu/stateful/ve2.h |    31 +
 .../platform/realtek/vpu/stateful/ve2_frame.h |   216 +
 .../platform/realtek/vpu/stateful/ve2rpc.c    |  2702 ++++
 .../platform/realtek/vpu/stateful/ve2rpc.h    |   292 +
 .../realtek/vpu/stateful/ve2rpc_cmd.h         |   581 +
 .../realtek/vpu/stateful/video_engine.h       |    17 +
 .../media/platform/realtek/vpu/stateful/vpu.c |  1582 ++
 .../media/platform/realtek/vpu/stateful/vpu.h |   153 +
 .../platform/realtek/vpu/stateless/Makefile   |    22 +
 .../realtek/vpu/stateless/coda/coda-hw.c      |  2741 ++++
 .../vpu/stateless/coda/coda-regdefine.h       |   443 +
 .../stateless/coda/coda-stateless-vpu-dec.c   |  2135 +++
 .../realtek/vpu/stateless/coda/coda-vdi.c     |   209 +
 .../realtek/vpu/stateless/coda/coda-vdi.h     |    51 +
 .../vpu/stateless/coda/coda-vpu-v4l2.c        |   146 +
 .../realtek/vpu/stateless/coda/coda-vpu.h     |    51 +
 .../realtek/vpu/stateless/coda/coda-vpuapi.h  |  1060 ++
 .../vpu/stateless/coda/coda-vpuconfig.h       |    83 +
 .../realtek/vpu/stateless/coda/coda.h         |    34 +
 .../platform/realtek/vpu/stateless/coda/vpu.c |   460 +
 .../vpu/stateless/rtkve/rtkve-common.c        |    97 +
 .../vpu/stateless/rtkve/rtkve-common.h        |   213 +
 .../vpu/stateless/rtkve/rtkve-dec-drv.c       |   378 +
 .../vpu/stateless/rtkve/rtkve-dec-v4l2.c      |   510 +
 .../vpu/stateless/rtkve/rtkve-rpc-def.h       |   591 +
 .../realtek/vpu/stateless/rtkve/rtkve-rpc.c   |  1364 ++
 .../realtek/vpu/stateless/rtkve/rtkve-rpc.h   |   109 +
 .../vpu/stateless/rtkve/rtkve-sl-av1.c        |   315 +
 .../vpu/stateless/rtkve/rtkve-sl-av1.h        |    24 +
 .../vpu/stateless/rtkve/rtkve-sl-ctrl.h       |  1258 ++
 .../vpu/stateless/rtkve/rtkve-sl-hevc.c       |   161 +
 .../vpu/stateless/rtkve/rtkve-sl-hevc.h       |    19 +
 .../vpu/stateless/rtkve/rtkve-sl-vp9.c        |   149 +
 .../vpu/stateless/rtkve/rtkve-sl-vp9.h        |    21 +
 .../stateless/rtkve/rtkve-stateless-vpu-dec.c |  1911 +++
 .../realtek/vpu/stateless/rtkve/rtkve-vpu.h   |    99 +
 .../realtek/vpu/stateless/rtkve/rtkve_frame.h |   216 +
 77 files changed, 71966 insertions(+), 1 deletion(-)
 create mode 100644 chromeos/config/chromeos/arm64/chromiumos-realtek.flavour.config
 create mode 100644 drivers/media/platform/realtek/vpu/Kconfig
 create mode 100644 drivers/media/platform/realtek/vpu/Makefile
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/Makefile
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/debug.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/drv_if.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/drv_if.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_config.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_decode.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_fw.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_mem.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_mem.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_mem_compat.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_mem_compat.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_mem_uapi.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_mm.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_mm.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_product.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_product.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_regdefine.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_v4l2.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_v4l2.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_vdi.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_vdi.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_vdi_osal.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_vdi_osal.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_vpu.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_vpu.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_vpu_md5.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_vpuapi.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_vpuapi.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_vpuapifunc.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_vpuapifunc.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_vpuconfig.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_vpuerror.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_vputypes.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_wrapper.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve1_wrapper.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve2.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve2.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve2_frame.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve2rpc.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve2rpc.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/ve2rpc_cmd.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/video_engine.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/vpu.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateful/vpu.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/Makefile
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/coda/coda-hw.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/coda/coda-regdefine.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/coda/coda-stateless-vpu-dec.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/coda/coda-vdi.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/coda/coda-vdi.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/coda/coda-vpu-v4l2.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/coda/coda-vpu.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/coda/coda-vpuapi.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/coda/coda-vpuconfig.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/coda/coda.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/coda/vpu.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-common.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-common.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-dec-drv.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-dec-v4l2.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-rpc-def.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-rpc.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-rpc.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-av1.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-av1.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-ctrl.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-hevc.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-hevc.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-vp9.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-vp9.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-stateless-vpu-dec.c
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-vpu.h
 create mode 100644 drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve_frame.h

Index: kernel-5_15/chromeos/config/chromeos/arm64/chromiumos-realtek.flavour.config
===================================================================
--- kernel-5_15.orig/chromeos/config/chromeos/arm64/chromiumos-realtek.flavour.config
+++ kernel-5_15/chromeos/config/chromeos/arm64/chromiumos-realtek.flavour.config
@@ -109,8 +109,25 @@ CONFIG_REGULATOR_APW888X_CORE=y
 CONFIG_REGULATOR_APW8886=y
 CONFIG_RTK_GIC_EXT=y
 CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
-CONFIG_RTD16XXB_RTK_CODEC=y
-CONFIG_RTD16XXB_VE1_CODEC=y
 CONFIG_VIDEO_REALTEK=m
-CONFIG_VIDEO_RTK_VCODEC=m
+CONFIG_VIDEO_RTK_VCODEC_SL=m
+CONFIG_MMC_SDHCI_OF_RTK=y
+CONFIG_RTW88=m
+CONFIG_RTW88_CORE=m
+CONFIG_RTW88_SDIO=m
+CONFIG_RTW88_8822C=m
+CONFIG_RTW88_8822CS=m
+CONFIG_RTW88_DEBUG=y
+CONFIG_RTW88_DEBUGFS=y
+CONFIG_REGULATOR_PWM=y
+CONFIG_SPI_RTK_SFC=n
+CONFIG_BT_RTL=m
+CONFIG_BT_RTK_GPIO=y
+CONFIG_BT_HCIBTSDIO=m
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_SERDEV=y
+CONFIG_BT_HCIUART_3WIRE=y
+CONFIG_BT_HCIUART_RTL=y
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_SERIAL_DEV_CTRL_TTYPORT=y
 CONFIG_USB_KBD_DOCKER_EMULATOR=y
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateful/debug.h
===================================================================
--- kernel-5_15.orig/drivers/media/platform/realtek/vpu/stateful/debug.h
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateful/debug.h
@@ -61,4 +61,4 @@ extern __printf(3, 4) void vpu_printk(co
 
 #define V4L2_TYPE_TO_STR(type) (V4L2_TYPE_IS_OUTPUT(type) ? "out" : "cap")
 
-#endif
\ No newline at end of file
+#endif
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateful/drv_if.c
===================================================================
--- kernel-5_15.orig/drivers/media/platform/realtek/vpu/stateful/drv_if.c
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateful/drv_if.c
@@ -13,6 +13,7 @@
 #include <linux/fs.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
+#include <linux/version.h>
 #ifdef VPU_GET_CC
 #include <linux/module.h>
 #include <linux/netlink.h>
@@ -306,6 +307,7 @@ static int vpu_s_ctrl(struct v4l2_ctrl *
 	return 0;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,6,0)
 static bool vpu_ctrl_type_equal(const struct v4l2_ctrl *ctrl, u32 idx,
 				union v4l2_ctrl_ptr ptr1,
 				union v4l2_ctrl_ptr ptr2)
@@ -313,6 +315,14 @@ static bool vpu_ctrl_type_equal(const st
 	idx *= ctrl->elem_size;
 	return !memcmp(ptr1.p_const + idx, ptr2.p_const + idx, ctrl->elem_size);
 }
+#else
+static bool vpu_ctrl_type_equal(const struct v4l2_ctrl *ctrl,
+				union v4l2_ctrl_ptr ptr1,
+				union v4l2_ctrl_ptr ptr2)
+{
+	return !memcmp(ptr1.p_const, ptr2.p_const, ctrl->elems * ctrl->elem_size);
+}
+#endif
 
 static void vpu_ctrl_type_init(const struct v4l2_ctrl *ctrl, u32 idx,
 			       union v4l2_ctrl_ptr ptr)
@@ -338,7 +348,11 @@ static void vpu_ctrl_type_log(const stru
 	pr_cont("RTK DEC PARAMS");
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,6,0)
 static int vpu_ctrl_type_validate(const struct v4l2_ctrl *ctrl, u32 idx,
+#else
+static int vpu_ctrl_type_validate(const struct v4l2_ctrl *ctrl,
+#endif
 				  union v4l2_ctrl_ptr ptr)
 {
 	return 0;
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateful/ve1_v4l2.c
===================================================================
--- kernel-5_15.orig/drivers/media/platform/realtek/vpu/stateful/ve1_v4l2.c
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateful/ve1_v4l2.c
@@ -1168,6 +1168,7 @@ module_init(ve1_init);
 module_exit(ve1_exit);
 
 MODULE_VERSION(xstr(GIT_VERSION));
+MODULE_IMPORT_NS(DMA_BUF);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Scarly.Cheng <scarly.cheng@realtek.com>");
 MODULE_DESCRIPTION("V4L2 Realtek Video Engine 1 Codec Driver");
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateful/ve1_vpuapi.c
===================================================================
--- kernel-5_15.orig/drivers/media/platform/realtek/vpu/stateful/ve1_vpuapi.c
+++ /dev/null
@@ -1,5093 +0,0 @@
-//--=========================================================================--
-//  This file is a part of VPU Reference API project
-//-----------------------------------------------------------------------------
-//
-//       This confidential and proprietary software may be used only
-//     as authorized by a licensing agreement from Chips&Media Inc.
-//     In the event of publication, the following notice is applicable:
-//
-//            (C) COPYRIGHT 2006 - 2013  CHIPS&MEDIA INC.
-//                      ALL RIGHTS RESERVED
-//
-//       The entire notice above must be reproduced on all authorized
-//       copies.
-//
-//--=========================================================================--
-
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/string.h>
-#include <linux/tee_drv.h>
-#include "ve1_vpuapifunc.h"
-#include "ve1_product.h"
-
-#ifdef DAH_222_PREALLOC_MV_SLICE_BUFFER
-/*
- * Fixed DAH-222 , Stark NTS DRS AL1 video freeze
- * Sometime during video resultion change, ion realloc need cost long time.
- * In NonTunnel playback, we prealloc max buffer can reduce realloc time for these items.
- */
-#include "ve1_fw.h"
-#include "ve1_vpuconfig.h"
-#endif
-
-#ifdef VE1_CHECKSUM
-#include <mcp_api.h>
-#define HASH_SIZE 32
-#endif
-
-#include "ve1_fw.h"
-#ifdef BIT_CODE_FILE_PATH
-#include BIT_CODE_FILE_PATH
-#endif
-
-#define INVALID_CORE_INDEX_RETURN_ERROR(_coreIdx)                              \
-	if (_coreIdx >= MAX_NUM_VPU_CORE)                                      \
-		return -1;
-
-Uint32 __VPU_BUSY_TIMEOUT = VPU_BUSY_CHECK_TIMEOUT;
-
-unsigned long vpu_ring_valid_data(unsigned long ring_base,
-				  unsigned long ring_limit,
-				  unsigned long ring_rp, unsigned long ring_wp)
-{
-	if (ring_wp >= ring_rp) {
-		return (ring_wp - ring_rp);
-	} else {
-		return (ring_limit - ring_base) - (ring_rp - ring_wp);
-	}
-}
-
-#ifdef ENABLE_TEE_DRM_FLOW
-extern int ta_TEEapi_init(struct tee_context **teeapi_ctx,
-			  unsigned int *teeapi_tee_session);
-extern int ta_TEEapi_deinit(struct tee_context *teeapi_ctx,
-			    unsigned int teeapi_tee_session);
-extern int ta_TEEapi_bitstreamprint(struct tee_context *teeapi_ctx,
-				    unsigned int teeapi_tee_session,
-				    unsigned int phy_addr, int size);
-extern int ta_TEEapi_bitstreamout(struct tee_context *teeapi_ctx,
-				  unsigned int teeapi_tee_session,
-				  unsigned int srcPAddr, unsigned char *buf,
-				  int size);
-extern int ta_TEEapi_memcpy(struct tee_context *teeapi_ctx,
-			    unsigned int teeapi_tee_session,
-			    unsigned int dstPhysAddr, unsigned int srtPhysAddr,
-			    int size);
-
-RetCode VPU_InitWithBitcodeProtect(Uint32 coreIdx, const Uint16 *code,
-				   Uint32 size, void *sess, void *rtk_sess,
-				   void *filp)
-{
-	RetCode ret;
-
-	if (coreIdx >= MAX_NUM_VPU_CORE)
-		return RETCODE_INVALID_PARAM;
-	if (code == NULL || size == 0)
-		return RETCODE_INVALID_PARAM;
-
-	if (vdi_init(coreIdx) < 0)
-		return RETCODE_FAILURE;
-
-	if (ProductVpuScan(coreIdx) == 0) {
-		return RETCODE_NOT_FOUND_VPU_DEVICE;
-	}
-
-	InitCodecInstancePool(coreIdx);
-
-	ret = ProductVpuReset(coreIdx, SW_RESET_ON_BOOT);
-	if (ret != RETCODE_SUCCESS) {
-		return ret;
-	}
-
-	ret = ProductVpuInitProtect(coreIdx, (void *)code, size, sess, rtk_sess,
-				    filp);
-	if (ret != RETCODE_SUCCESS) {
-		return ret;
-	}
-	return RETCODE_SUCCESS;
-}
-#endif
-
-static RetCode CheckInstanceValidity(CodecInst *pCodecInst)
-{
-	int i;
-	vpu_instance_pool_t *vip;
-
-	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(pCodecInst->coreIdx);
-	if (!vip)
-		return RETCODE_INSUFFICIENT_RESOURCE;
-
-	for (i = 0; i < MAX_NUM_INSTANCE; i++) {
-		if ((CodecInst *)vip->codecInstPool[i] == pCodecInst)
-			return RETCODE_SUCCESS;
-	}
-
-	return RETCODE_INVALID_HANDLE;
-}
-
-static RetCode CheckDecInstanceValidity(CodecInst *pCodecInst)
-{
-	RetCode ret;
-
-	if (pCodecInst == NULL)
-		return RETCODE_INVALID_HANDLE;
-
-	ret = CheckInstanceValidity(pCodecInst);
-	if (ret != RETCODE_SUCCESS) {
-		return RETCODE_INVALID_HANDLE;
-	}
-	if (!pCodecInst->inUse) {
-		return RETCODE_INVALID_HANDLE;
-	}
-
-	return ProductVpuDecCheckCapability(pCodecInst);
-}
-
-Int32 VPU_IsBusy(Uint32 coreIdx)
-{
-	Uint32 ret = 0;
-
-	INVALID_CORE_INDEX_RETURN_ERROR(coreIdx);
-
-	SetClockGate(coreIdx, 1);
-	ret = ProductVpuIsBusy(coreIdx);
-	SetClockGate(coreIdx, 0);
-
-	return ret != 0;
-}
-
-Int32 VPU_IsInit(Uint32 coreIdx)
-{
-	Int32 pc;
-	VLOG(TRACE, "[+] [%d]%s\n", __LINE__, __func__);
-
-	INVALID_CORE_INDEX_RETURN_ERROR(coreIdx);
-
-	SetClockGate(coreIdx, 1);
-	pc = ProductVpuIsInit(coreIdx);
-	SetClockGate(coreIdx, 0);
-
-	VLOG(TRACE, "[-] [%d]%s.pc:0x%x\n", __LINE__, __func__, pc);
-	return pc;
-}
-
-Int32 VPU_WaitInterrupt(Uint32 coreIdx, int timeout)
-{
-	Int32 ret;
-	CodecInst *instance;
-
-	INVALID_CORE_INDEX_RETURN_ERROR(coreIdx);
-
-	if ((instance = GetPendingInst(coreIdx)) != NULL) {
-		ret = ProductVpuWaitInterrupt(instance, timeout);
-		VLOG(TRACE, "[%d]%s.coreIdx:%d.timeout:%d.ret:%d\n", __LINE__,
-		     __func__, coreIdx, timeout, ret);
-	} else {
-		ret = -1;
-		VLOG(TRACE, "[%d]%s.coreIdx:%d.timeout:%d.ret:-1\n", __LINE__,
-		     __func__, coreIdx, timeout);
-	}
-
-	return ret;
-}
-
-Int32 VPU_WaitInterruptEx(VpuHandle handle, int timeout)
-{
-	Int32 ret;
-	CodecInst *pCodecInst;
-
-	pCodecInst = handle;
-
-	INVALID_CORE_INDEX_RETURN_ERROR(pCodecInst->coreIdx);
-
-	ret = ProductVpuWaitInterrupt(pCodecInst, timeout);
-
-	return ret;
-}
-
-void VPU_ClearInterrupt(Uint32 coreIdx)
-{
-	/* clear all interrupt flags */
-	ProductVpuClearInterrupt(coreIdx, 0xffff);
-	VLOG(TRACE, "[%d]%s.coreIdx:%d\n", __LINE__, __func__, coreIdx);
-}
-
-void VPU_ClearInterruptEx(VpuHandle handle, Int32 intrFlag)
-{
-	CodecInst *pCodecInst;
-
-	pCodecInst = handle;
-
-	ProductVpuClearInterrupt(pCodecInst->coreIdx, intrFlag);
-}
-
-int VPU_GetMvColBufSize(CodStd codStd, int width, int height, int num)
-{
-	int size_mvcolbuf = ProductCalculateAuxBufferSize(
-		AUX_BUF_TYPE_MVCOL, codStd, width, height);
-
-	if (codStd == STD_AVC || codStd == STD_HEVC || codStd == STD_VP9)
-		size_mvcolbuf *= num;
-
-	return size_mvcolbuf;
-}
-
-RetCode VPU_GetFBCOffsetTableSize(CodStd codStd, int width, int height,
-				  int *ysize, int *csize)
-{
-	if (ysize == NULL || csize == NULL)
-		return RETCODE_INVALID_PARAM;
-
-	*ysize = ProductCalculateAuxBufferSize(AUX_BUF_TYPE_FBC_Y_OFFSET,
-					       codStd, width, height);
-	*csize = ProductCalculateAuxBufferSize(AUX_BUF_TYPE_FBC_C_OFFSET,
-					       codStd, width, height);
-
-	return RETCODE_SUCCESS;
-}
-
-int VPU_GetFrameBufSize(int coreIdx, int stride, int height, int mapType,
-			int format, int interleave, DRAMConfig *pDramCfg)
-{
-	int productId;
-	UNREFERENCED_PARAMETER(interleave); /*!<< for backward compatiblity */
-
-	if (coreIdx < 0 || coreIdx >= MAX_NUM_VPU_CORE)
-		return -1;
-
-	productId = ProductVpuGetId(coreIdx);
-
-	return ProductCalculateFrameBufSize(productId, stride, height,
-					    (TiledMapType)mapType,
-					    (FrameBufferFormat)format,
-					    (BOOL)interleave, pDramCfg);
-}
-
-int VPU_GetProductId(int coreIdx)
-{
-	Int32 productId = -1;
-
-	VLOG(TRACE, "[+] [%d]%s\n", __LINE__, __func__);
-
-	INVALID_CORE_INDEX_RETURN_ERROR(coreIdx);
-
-	if (ProductVpuScan(coreIdx) == FALSE) {
-		VLOG(ERR, "[-] [%d]%s.ProductVpuScan() fail.coreIdx:%d\n",
-		     __LINE__, __func__, coreIdx);
-		return -1;
-	}
-	productId = ProductVpuGetId(coreIdx);
-	VLOG(TRACE, "[-] [%d]%s.productId:%d\n", __LINE__, __func__, productId);
-	return productId;
-}
-
-int VPU_GetOpenInstanceNum(Uint32 coreIdx)
-{
-	INVALID_CORE_INDEX_RETURN_ERROR(coreIdx);
-
-	return vdi_get_instance_num(coreIdx);
-}
-
-static RetCode InitializeVPU(Uint32 coreIdx, const Uint16 *code, Uint32 size)
-{
-	RetCode ret;
-	VLOG(TRACE, "[+] [%d]%s.code:0x%px.size:%d\n", __LINE__, __func__, code,
-	     size);
-
-	if (vdi_init(coreIdx) < 0) {
-		VLOG(ERR, "[%d]vdi_init() fail.coreIdx:%d", __LINE__, coreIdx);
-		return RETCODE_FAILURE;
-	}
-
-	EnterLock(coreIdx);
-
-	if (ProductVpuScan(coreIdx) == 0) {
-		LeaveLock(coreIdx);
-		VLOG(ERR, "[-] [%d]%s.RETCODE_NOT_FOUND_VPU_DEVICE\n", __LINE__,
-		     __func__);
-		return RETCODE_NOT_FOUND_VPU_DEVICE;
-	}
-
-	if (VPU_IsInit(coreIdx) != 0) {
-		SetClockGate(coreIdx, 1);
-		ProductVpuGetProductId(coreIdx);
-		LeaveLock(coreIdx);
-		VLOG(INFO, "[-] [%d]%s.RETCODE_CALLED_BEFORE\n", __LINE__,
-		     __func__);
-		return RETCODE_CALLED_BEFORE;
-	} else if (size == 0) //RTK
-	{
-		VLOG(WARN,
-		     "[%d]VPU didn't initial, we should re-load fw again\n",
-		     __LINE__);
-		LeaveLock(coreIdx);
-		vdi_release(coreIdx);
-		VLOG(TRACE, "[-] [%d]%s.RETCODE_NOT_FOUND_BITCODE_PATH\n",
-		     __LINE__, __func__);
-		return RETCODE_NOT_FOUND_BITCODE_PATH;
-	}
-
-	InitCodecInstancePool(coreIdx);
-
-	SetClockGate(coreIdx, 1);
-	ret = ProductVpuReset(coreIdx, SW_RESET_ON_BOOT);
-	if (ret != RETCODE_SUCCESS) {
-		LeaveLock(coreIdx);
-		VLOG(ERR, "[-] [%d]%s.ProductVpuReset() fail.ret:%d\n",
-		     __LINE__, __func__, ret);
-		return ret;
-	}
-
-	ret = ProductVpuInit(coreIdx, (void *)code, size);
-	if (ret != RETCODE_SUCCESS) {
-		LeaveLock(coreIdx);
-		VLOG(ERR, "[-] [%d]%s.ProductVpuInit() fail.ret:%d\n", __LINE__,
-		     __func__, ret);
-		return ret;
-	}
-	LeaveLock(coreIdx);
-	VLOG(TRACE, "[-] [%d]%s\n", __LINE__, __func__);
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_Init(Uint32 coreIdx)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	VLOG(TRACE, "[+] [%d]%s.coreIdx:%d\n", __LINE__, __func__, coreIdx);
-	if (coreIdx >= MAX_NUM_VPU_CORE) {
-		VLOG(ERR, "[-] [%d]%s.coreIdx:%d.ret:RETCODE_INVALID_PARAM\n",
-		     __LINE__, __func__, coreIdx);
-		return RETCODE_INVALID_PARAM;
-	}
-
-	ret = InitializeVPU(coreIdx, NULL, 0);
-	VLOG(TRACE, "[-] [%d]%s.coreIdx:%d.ret:%d\n", __LINE__, __func__,
-	     coreIdx, ret);
-	return ret;
-}
-
-RetCode VPU_InitWithBitcode(Uint32 coreIdx, const Uint16 *code, Uint32 size)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	VLOG(TRACE, "[+] [%d]%s.code:%px.size:%d\n", __LINE__, __func__, code,
-	     size);
-	if (coreIdx >= MAX_NUM_VPU_CORE) {
-		VLOG(ERR, "[-] [%d]%s.RETCODE_INVALID_PARAM\n", __LINE__,
-		     __func__);
-		return RETCODE_INVALID_PARAM;
-	}
-	if (code == NULL || size == 0) {
-		VLOG(ERR, "[-] [%d]%s.RETCODE_INVALID_PARAM\n", __LINE__,
-		     __func__);
-		return RETCODE_INVALID_PARAM;
-	}
-
-	ret = InitializeVPU(coreIdx, code, size);
-	VLOG(TRACE, "[-] [%d]%s.ret:%d\n", __LINE__, __func__, ret);
-	return ret;
-}
-
-RetCode VPU_DeInit(Uint32 coreIdx)
-{
-	int ret;
-
-	if (coreIdx >= MAX_NUM_VPU_CORE)
-		return RETCODE_INVALID_PARAM;
-
-	ret = vdi_release(coreIdx);
-	if (ret != 0) {
-		VLOG(TRACE, "[%d]%s.coreIdx:%d.ret:0x%x\n", __LINE__, __func__,
-		     coreIdx, ret);
-		return RETCODE_FAILURE;
-	}
-
-	VLOG(TRACE, "[%d]%s.coreIdx:%d.ret:RETCODE_SUCCESS\n", __LINE__,
-	     __func__, coreIdx);
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_GetVersionInfo(Uint32 coreIdx, Uint32 *versionInfo,
-			   Uint32 *revision, Uint32 *productId)
-{
-	RetCode ret;
-
-	if (coreIdx >= MAX_NUM_VPU_CORE)
-		return RETCODE_INVALID_PARAM;
-
-	EnterLock(coreIdx);
-
-	if (ProductVpuIsInit(coreIdx) == 0) {
-		LeaveLock(coreIdx);
-		return RETCODE_NOT_INITIALIZED;
-	}
-
-	if (GetPendingInst(coreIdx)) {
-		LeaveLock(coreIdx);
-		return RETCODE_FRAME_NOT_COMPLETE;
-	}
-
-	if (productId != NULL) {
-		*productId = ProductVpuGetId(coreIdx);
-	}
-	ret = ProductVpuGetVersion(coreIdx, versionInfo, revision);
-
-	LeaveLock(coreIdx);
-
-	return ret;
-}
-RetCode VPU_DecOpen(DecHandle *pHandle, DecOpenParam *pop)
-{
-	CodecInst *pCodecInst = 0;
-	DecInfo *pDecInfo;
-	RetCode ret;
-#if defined(ENABLE_TEE_DRM_FLOW)
-	int ret_teeapi;
-#endif
-
-	VLOG(TRACE, "[+] [%d]%s\n", __LINE__, __func__);
-	ret = ProductCheckDecOpenParam(pop);
-	if (ret != RETCODE_SUCCESS) {
-		VLOG(ERR, "[-] [%d]%s.ProductCheckDecOpenParam fail.ret:%d\n",
-		     __LINE__, __func__, ret);
-		return ret;
-	}
-
-	VLOG(TRACE, "[bitstreamFormat    ]: %d\n", pop->bitstreamFormat);
-	VLOG(TRACE, "[bitstreamBuffer    ]: 0x%08x\n", pop->bitstreamBuffer);
-	VLOG(TRACE, "[bitstreamBufferSize]: %d\n", pop->bitstreamBufferSize);
-	VLOG(TRACE, "[mp4DeblkEnable     ]: %d\n", pop->mp4DeblkEnable);
-	VLOG(TRACE, "[avcExtension       ]: %d\n", pop->avcExtension);
-	VLOG(TRACE, "[mp4Class           ]: %d\n", pop->mp4Class);
-	VLOG(TRACE, "[tiled2LinearEnable ]: %d\n", pop->tiled2LinearEnable);
-	VLOG(TRACE, "[tiled2LinearMode   ]: %d\n", pop->tiled2LinearMode);
-	VLOG(TRACE, "[wtlEnable          ]: %d\n", pop->wtlEnable);
-	VLOG(TRACE, "[wtlMode            ]: %d\n", pop->wtlMode);
-	VLOG(TRACE, "[cbcrInterleave     ]: %d\n", pop->cbcrInterleave);
-	VLOG(TRACE, "[nv21               ]: %d\n", pop->nv21);
-	VLOG(TRACE, "[cbcrOrder          ]: %d\n", pop->cbcrOrder);
-	VLOG(TRACE, "[BWB                ]: %d\n", pop->bwbEnable);
-	VLOG(TRACE, "[frameEndian        ]: %d\n", pop->frameEndian);
-	VLOG(TRACE, "[streamEndian       ]: %d\n", pop->streamEndian);
-	VLOG(TRACE, "[bitstreamMode      ]: %d\n", pop->bitstreamMode);
-	VLOG(TRACE, "[coreIdx            ]: %d\n", pop->coreIdx);
-	VLOG(TRACE, "[vbWork.size        ]: %d\n", pop->vbWork.size);
-	VLOG(TRACE, "[vbWork.phys_addr   ]: 0x%08lx\n", pop->vbWork.phys_addr);
-	VLOG(TRACE, "[vbWork.base        ]: 0x%08lx\n", pop->vbWork.base);
-	VLOG(TRACE, "[vbWork.virt_addr   ]: 0x%08lx\n", pop->vbWork.virt_addr);
-	VLOG(TRACE, "[vbWork.region      ]: %d\n", pop->vbWork.req_spec_region);
-	VLOG(TRACE, "[fbc_mode           ]: %d\n", pop->fbc_mode);
-	VLOG(TRACE, "[virtAxiID          ]: %d\n", pop->virtAxiID);
-	VLOG(TRACE, "[bwOptimization     ]: %d\n", pop->bwOptimization);
-	VLOG(TRACE, "[afbceEnable        ]: %d\n", pop->afbceEnable);
-	VLOG(TRACE, "[afbceFormat        ]: %d\n", pop->afbceFormat);
-	VLOG(TRACE, "[isUseProtectBuffer ]: %d\n", pop->isUseProtectBuffer);
-	VLOG(TRACE, "[sess               ]: %p\n", pop->sess);
-	VLOG(TRACE, "[rtk_sess           ]: %p\n", pop->rtk_sess);
-
-	EnterLock(pop->coreIdx);
-
-	if (VPU_IsInit(pop->coreIdx) == 0) {
-		LeaveLock(pop->coreIdx);
-		VLOG(TRACE, "[-] [%d]%s.ret:RETCODE_NOT_INITIALIZED\n",
-		     __LINE__, __func__);
-		return RETCODE_NOT_INITIALIZED;
-	}
-
-	ret = GetCodecInstance(pop->coreIdx, &pCodecInst, pop->filp);
-	if (ret != RETCODE_SUCCESS) {
-		*pHandle = 0;
-		LeaveLock(pop->coreIdx);
-		VLOG(ERR, "[-] [%d]%s.GetCodecInstance fail.ret:%d\n", __LINE__,
-		     __func__, ret);
-		return ret;
-	}
-
-#if defined(ENABLE_TEE_DRM_FLOW)
-	ret_teeapi =
-		ta_TEEapi_init((struct tee_context **)&pCodecInst->teeapi_ctx,
-			       &pCodecInst->teeapi_tee_session);
-	if (ret_teeapi < 0) {
-		*pHandle = 0;
-		LeaveLock(pop->coreIdx);
-		VLOG(ERR, "[-] [%d]%s.ta_TEEapi_init() fail.ret:%d\n", __LINE__,
-		     __func__, ret_teeapi);
-		return RETCODE_FAILURE;
-	}
-#endif
-
-	pCodecInst->isDecoder = TRUE;
-	*pHandle = pCodecInst;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-	osal_memset(pDecInfo, 0x00, sizeof(DecInfo));
-	osal_memcpy((void *)&pDecInfo->openParam, pop, sizeof(DecOpenParam));
-
-	if (pop->bitstreamFormat == STD_MPEG4) {
-		pCodecInst->codecMode = MP4_DEC;
-		pCodecInst->codecModeAux = MP4_AUX_MPEG4;
-	} else if (pop->bitstreamFormat == STD_AVC) {
-		pCodecInst->codecMode = AVC_DEC;
-		pCodecInst->codecModeAux = pop->avcExtension;
-	} else if (pop->bitstreamFormat == STD_VC1) {
-		pCodecInst->codecMode = VC1_DEC;
-	} else if (pop->bitstreamFormat == STD_MPEG2) {
-		pCodecInst->codecMode = MP2_DEC;
-	} else if (pop->bitstreamFormat == STD_H263) {
-		pCodecInst->codecMode = MP4_DEC;
-		pCodecInst->codecModeAux = MP4_AUX_MPEG4;
-	} else if (pop->bitstreamFormat == STD_UNKNOWN3) {
-		pCodecInst->codecMode = DV3_DEC;
-		pCodecInst->codecModeAux = MP4_AUX_UNKNOWN3;
-	} else if (pop->bitstreamFormat == STD_RV) {
-		pCodecInst->codecMode = RV_DEC;
-	} else if (pop->bitstreamFormat == STD_AVS) {
-		pCodecInst->codecMode = AVS_DEC;
-	} else if (pop->bitstreamFormat == STD_THO) {
-		pCodecInst->codecMode = VPX_DEC;
-		pCodecInst->codecModeAux = VPX_AUX_THO;
-	} else if (pop->bitstreamFormat == STD_VP3) {
-		pCodecInst->codecMode = VPX_DEC;
-		pCodecInst->codecModeAux = VPX_AUX_THO;
-	} else if (pop->bitstreamFormat == STD_VP8) {
-		pCodecInst->codecMode = VPX_DEC;
-		pCodecInst->codecModeAux = VPX_AUX_VP8;
-	} else if (pop->bitstreamFormat == STD_HEVC) {
-		pCodecInst->codecMode = HEVC_DEC;
-	} else if (pop->bitstreamFormat == STD_VP9) {
-		pCodecInst->codecMode = W_VP9_DEC;
-	} else if (pop->bitstreamFormat == STD_AVS2) {
-		pCodecInst->codecMode = W_AVS2_DEC;
-	} else {
-		LeaveLock(pop->coreIdx);
-		VLOG(ERR,
-		     "[-] [%d]%s.ret:RETCODE_INVALID_PARAM.unknown bitstreamFormat:%d\n",
-		     __LINE__, __func__, pop->bitstreamFormat);
-		return RETCODE_INVALID_PARAM;
-	}
-
-	pDecInfo->enableAfbce = pop->afbceEnable;
-	pDecInfo->afbceFormat = pop->afbceFormat;
-	pDecInfo->wtlEnable = pop->wtlEnable;
-	pDecInfo->wtlMode = pop->wtlMode;
-	if (!pDecInfo->wtlEnable)
-		pDecInfo->wtlMode = 0;
-
-	pDecInfo->streamWrPtr = pop->bitstreamBuffer;
-	pDecInfo->streamRdPtr = pop->bitstreamBuffer;
-	pDecInfo->frameDelay = -1;
-	pDecInfo->streamBufStartAddr = pop->bitstreamBuffer;
-	pDecInfo->streamBufSize = pop->bitstreamBufferSize;
-	pDecInfo->streamBufEndAddr =
-		pop->bitstreamBuffer + pop->bitstreamBufferSize;
-	pDecInfo->reorderEnable = VPU_REORDER_ENABLE;
-	pDecInfo->mirrorDirection = MIRDIR_NONE;
-#ifdef FIX_SET_GET_RD_PTR_BUG
-#else
-	pDecInfo->prevFrameEndPos = pop->bitstreamBuffer;
-#endif
-
-	//ENABLE_TEE_DRM_FLOW //For RTK DRM flow
-	pCodecInst->isUseProtectBuffer = pop->isUseProtectBuffer;
-	pCodecInst->sess = pop->sess;
-	pCodecInst->rtk_sess = pop->rtk_sess;
-	pCodecInst->enableDcsysDebug = pop->enableDcsysDebug;
-
-	SetClockGate(pop->coreIdx, TRUE);
-	if ((ret = ProductVpuDecBuildUpOpenParam(pCodecInst, pop)) !=
-	    RETCODE_SUCCESS) {
-		SetClockGate(pop->coreIdx, FALSE);
-		*pHandle = 0;
-		LeaveLock(pCodecInst->coreIdx);
-		VLOG(ERR,
-		     "[-] [%d]%s.ProductVpuDecBuildUpOpenParam fail.ret:%d\n",
-		     __LINE__, __func__, ret);
-		return ret;
-	}
-	SetClockGate(pop->coreIdx, FALSE);
-
-	pDecInfo->tiled2LinearEnable = pop->tiled2LinearEnable;
-	pDecInfo->tiled2LinearMode = pop->tiled2LinearMode;
-	if (!pDecInfo->tiled2LinearEnable)
-		pDecInfo->tiled2LinearMode = 0; //coda980 only
-
-	if (!pDecInfo->wtlEnable) //coda980, wave320, wave410 only
-		pDecInfo->wtlMode = 0;
-
-	osal_memset((void *)&pDecInfo->cacheConfig, 0x00,
-		    sizeof(MaverickCacheConfig));
-#ifdef VE1_CHECKSUM
-	memset(&pDecInfo->hashTable, 0, sizeof(vpu_buffer_t));
-	pDecInfo->hashTable.size = HASH_SIZE;
-	if (vdi_allocate_dma_memory(pCodecInst->coreIdx, &pDecInfo->hashTable,
-				    pCodecInst->filp) < 0) {
-		pDecInfo->hashTable.size = 0;
-		VLOG(ERR, "fail to allocate checksum buffer");
-		return RETCODE_FAILURE;
-	}
-	VLOG(TRACE,
-	     "[%d]%s.vdi_allocate_dma_memory hashTable(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-	     __LINE__, __func__, pDecInfo->hashTable.phys_addr,
-	     pDecInfo->hashTable.base, pDecInfo->hashTable.virt_addr,
-	     pDecInfo->hashTable.size, pDecInfo->hashTable.req_spec_region);
-#endif
-
-#ifdef DAH_222_PREALLOC_MV_SLICE_BUFFER
-	int size_mvcolbuf = 0;
-	vpu_buffer_t vbBuffer;
-	size_mvcolbuf = ((PREALLOC_MV_WIDTH + 31) & ~31) *
-			((PREALLOC_MV_HEIGHT + 31) & ~31);
-	size_mvcolbuf = (size_mvcolbuf * 3) / 2;
-	size_mvcolbuf = (size_mvcolbuf + 4) / 5;
-	size_mvcolbuf = ((size_mvcolbuf + 7) / 8) * 8;
-	vbBuffer.size = size_mvcolbuf;
-	vbBuffer.phys_addr = 0;
-	for (int i = 0; i < PREALLOC_MV_BUFFER_COUNT; i++) {
-		//ENABLE_TEE_DRM_FLOW
-		if (pCodecInst->isUseProtectBuffer)
-			vbBuffer.req_spec_region = VE_SECURE_PROTECTION;
-		else
-			vbBuffer.req_spec_region = 0;
-
-		if (pDecInfo->vbMV[i].size == 0) {
-			if (vdi_allocate_dma_memory(pCodecInst->coreIdx,
-						    &vbBuffer) < 0) {
-				return RETCODE_FAILURE;
-			}
-			pDecInfo->vbMV[i] = vbBuffer;
-			VLOG(TRACE,
-			     "[%d]%s.vdi_allocate_dma_memory vbMV[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, i, pDecInfo->vbMV[i].phys_addr,
-			     pDecInfo->vbMV[i].base,
-			     pDecInfo->vbMV[i].virt_addr,
-			     pDecInfo->vbMV[i].size,
-			     pDecInfo->vbMV[i].req_spec_region);
-		}
-	}
-
-	if (pCodecInst->codecMode == VPX_DEC) {
-		vpu_buffer_t *pvbSlice = &pDecInfo->vbSlice;
-		if (pvbSlice->size == 0) {
-			pvbSlice->size = VP8_MB_SAVE_SIZE;
-			//ENABLE_TEE_DRM_FLOW
-			if (pCodecInst->isUseProtectBuffer)
-				pvbSlice->req_spec_region =
-					VE_SECURE_PROTECTION;
-			else
-				pvbSlice->req_spec_region = 0;
-
-			if (vdi_allocate_dma_memory(pCodecInst->coreIdx,
-						    pvbSlice) < 0) {
-				return RETCODE_INSUFFICIENT_RESOURCE;
-			}
-			VLOG(TRACE,
-			     "[%d]%s.vdi_allocate_dma_memory vbSlice(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, pvbSlice->phys_addr,
-			     pvbSlice->base, pvbSlice->virt_addr,
-			     pvbSlice->size, pvbSlice->req_spec_region);
-		}
-	}
-
-	if (pCodecInst->codecMode == AVC_DEC) {
-		vpu_buffer_t *pvbSlice = &pDecInfo->vbSlice;
-		if (pvbSlice->size == 0) {
-			pvbSlice->size = SLICE_SAVE_SIZE;
-			//ENABLE_TEE_DRM_FLOW
-			if (pCodecInst->isUseProtectBuffer)
-				pvbSlice->req_spec_region =
-					VE_SECURE_PROTECTION;
-			else
-				pvbSlice->req_spec_region = 0;
-
-			if (vdi_allocate_dma_memory(pCodecInst->coreIdx,
-						    pvbSlice) < 0) {
-				return RETCODE_INSUFFICIENT_RESOURCE;
-			}
-			VLOG(TRACE,
-			     "[%d]%s.vdi_allocate_dma_memory vbSlice(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, pvbSlice->phys_addr,
-			     pvbSlice->base, pvbSlice->virt_addr,
-			     pvbSlice->size, pvbSlice->req_spec_region);
-		}
-	}
-#endif // #ifdef DAH_222_PREALLOC_MV_SLICE_BUFFER
-
-	// for debug, enable logging by vpuapi self
-	//pCodecInst->loggingEnable = 1;
-
-	LeaveLock(pCodecInst->coreIdx);
-
-	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:RETCODE_SUCCESS\n", __LINE__,
-	     __func__, *pHandle);
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_DecClose(DecHandle handle)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	RetCode ret;
-	int i;
-#if defined(ENABLE_TEE_DRM_FLOW)
-	int ret_teeapi;
-#endif
-
-	VLOG(TRACE, "[+] [%d]%s.h:0x%x\n", __LINE__, __func__, handle);
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS) {
-		VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
-		     handle, ret);
-		return ret;
-	}
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-
-	EnterLock(pCodecInst->coreIdx);
-
-	if ((ret = ProductVpuDecFiniSeq(pCodecInst)) != RETCODE_SUCCESS) {
-		if (pCodecInst->loggingEnable)
-			vdi_log(pCodecInst->coreIdx, DEC_SEQ_END, 0);
-
-		if (ret == RETCODE_VPU_STILL_RUNNING) {
-			LeaveLock(pCodecInst->coreIdx);
-			VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__,
-			     __func__, handle, ret);
-			return ret;
-		}
-	}
-
-#if defined(ENABLE_TEE_DRM_FLOW)
-	ret_teeapi =
-		ta_TEEapi_deinit((struct tee_context *)pCodecInst->teeapi_ctx,
-				 pCodecInst->teeapi_tee_session);
-	if (ret_teeapi < 0) {
-		LeaveLock(pCodecInst->coreIdx);
-		VLOG(ERR, "[%d]%s.ta_TEEapi_deinit() fail.ret:%d\n", __LINE__,
-		     __func__, ret_teeapi);
-		return RETCODE_FAILURE;
-	}
-#endif
-
-	if (pDecInfo->vbSlice.size) {
-		VLOG(TRACE,
-		     "[%d]%s.vdi_free_dma_memory_no_mmap vbSlice(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-		     __LINE__, __func__, pDecInfo->vbSlice.phys_addr,
-		     pDecInfo->vbSlice.base, pDecInfo->vbSlice.virt_addr,
-		     pDecInfo->vbSlice.size, pDecInfo->vbSlice.req_spec_region);
-		vdi_free_dma_memory_no_mmap(pCodecInst->coreIdx,
-					    &pDecInfo->vbSlice);
-	}
-
-	if (pDecInfo->vbWork.size) {
-		if (pDecInfo->workBufferAllocExt == 0) {
-			VLOG(TRACE,
-			     "[%d]%s.vdi_free_dma_memory_no_mmap vbWork(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, pDecInfo->vbWork.phys_addr,
-			     pDecInfo->vbWork.base, pDecInfo->vbWork.virt_addr,
-			     pDecInfo->vbWork.size,
-			     pDecInfo->vbWork.req_spec_region);
-			vdi_free_dma_memory_no_mmap(pCodecInst->coreIdx,
-						    &pDecInfo->vbWork);
-		} else {
-			vdi_dettach_dma_memory(pCodecInst->coreIdx,
-					       &pDecInfo->vbWork);
-		}
-	}
-
-	if (pDecInfo->vbFrame.size) {
-		if (pDecInfo->frameAllocExt == 0) {
-			VLOG(TRACE,
-			     "[%d]%s.vdi_free_dma_memory vbFrame(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, pDecInfo->vbFrame.phys_addr,
-			     pDecInfo->vbFrame.base,
-			     pDecInfo->vbFrame.virt_addr,
-			     pDecInfo->vbFrame.size,
-			     pDecInfo->vbFrame.req_spec_region);
-			vdi_free_dma_memory(pCodecInst->coreIdx,
-					    &pDecInfo->vbFrame);
-		}
-	}
-	for (i = 0; i < MAX_REG_FRAME; i++) {
-		if (pDecInfo->vbMV[i].size) {
-			VLOG(TRACE,
-			     "[%d]%s.vdi_free_dma_memory_no_mmap vbMV[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, i, pDecInfo->vbMV[i].phys_addr,
-			     pDecInfo->vbMV[i].base,
-			     pDecInfo->vbMV[i].virt_addr,
-			     pDecInfo->vbMV[i].size,
-			     pDecInfo->vbMV[i].req_spec_region);
-			vdi_free_dma_memory_no_mmap(pCodecInst->coreIdx,
-						    &pDecInfo->vbMV[i]);
-		}
-		if (pDecInfo->vbFbcYTbl[i].size) {
-			if (pDecInfo->fbcTblAllocExt == 0) {
-				VLOG(TRACE,
-				     "[%d]%s.vdi_free_dma_memory vbFbcYTbl[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-				     __LINE__, __func__, i,
-				     pDecInfo->vbFbcYTbl[i].phys_addr,
-				     pDecInfo->vbFbcYTbl[i].base,
-				     pDecInfo->vbFbcYTbl[i].virt_addr,
-				     pDecInfo->vbFbcYTbl[i].size,
-				     pDecInfo->vbFbcYTbl[i].req_spec_region);
-				vdi_free_dma_memory(pCodecInst->coreIdx,
-						    &pDecInfo->vbFbcYTbl[i]);
-			}
-		}
-		if (pDecInfo->vbFbcCTbl[i].size) {
-			if (pDecInfo->fbcTblAllocExt == 0) {
-				VLOG(TRACE,
-				     "[%d]%s.vdi_free_dma_memory vbFbcCTbl[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-				     __LINE__, __func__, i,
-				     pDecInfo->vbFbcCTbl[i].phys_addr,
-				     pDecInfo->vbFbcCTbl[i].base,
-				     pDecInfo->vbFbcCTbl[i].virt_addr,
-				     pDecInfo->vbFbcCTbl[i].size,
-				     pDecInfo->vbFbcCTbl[i].req_spec_region);
-				vdi_free_dma_memory(pCodecInst->coreIdx,
-						    &pDecInfo->vbFbcCTbl[i]);
-			}
-		}
-	}
-
-	if (pDecInfo->vbTemp.size)
-		vdi_dettach_dma_memory(pCodecInst->coreIdx, &pDecInfo->vbTemp);
-
-	if (pDecInfo->vbPPU.size) {
-		if (pDecInfo->ppuAllocExt == 0) {
-			VLOG(TRACE,
-			     "[%d]%s.vdi_free_dma_memory vbPPU(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, pDecInfo->vbPPU.phys_addr,
-			     pDecInfo->vbPPU.base, pDecInfo->vbPPU.virt_addr,
-			     pDecInfo->vbPPU.size,
-			     pDecInfo->vbPPU.req_spec_region);
-			vdi_free_dma_memory(pCodecInst->coreIdx,
-					    &pDecInfo->vbPPU);
-		}
-	}
-
-	if (pDecInfo->vbWTL.size) {
-		VLOG(TRACE,
-		     "[%d]%s.vdi_free_dma_memory vbWTL(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-		     __LINE__, __func__, pDecInfo->vbWTL.phys_addr,
-		     pDecInfo->vbWTL.base, pDecInfo->vbWTL.virt_addr,
-		     pDecInfo->vbWTL.size, pDecInfo->vbWTL.req_spec_region);
-		vdi_free_dma_memory(pCodecInst->coreIdx, &pDecInfo->vbWTL);
-	}
-
-	if (pDecInfo->vbUserData.size)
-		vdi_dettach_dma_memory(pCodecInst->coreIdx,
-				       &pDecInfo->vbUserData);
-
-	if (pDecInfo->vbReport.size) {
-		VLOG(TRACE,
-		     "[%d]%s.vdi_free_dma_memory vbReport(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-		     __LINE__, __func__, pDecInfo->vbReport.phys_addr,
-		     pDecInfo->vbReport.base, pDecInfo->vbReport.virt_addr,
-		     pDecInfo->vbReport.size,
-		     pDecInfo->vbReport.req_spec_region);
-		vdi_free_dma_memory(pCodecInst->coreIdx, &pDecInfo->vbReport);
-	}
-
-	if (GetPendingInst(pCodecInst->coreIdx) == pCodecInst)
-		ClearPendingInst(pCodecInst->coreIdx);
-
-#ifdef VE1_CHECKSUM
-	if (pDecInfo->hashTable.size) {
-		Uint8 *result = (Uint8 *)pDecInfo->hashTable.virt_addr;
-		Uint32 sum = 0;
-		int i;
-		for (i = 0; i < HASH_SIZE; i++)
-			sum += result[i];
-		if (sum > 0)
-			VLOG(TRACE,
-			     "[RTKCKS]= Fianl Hash = %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x",
-			     result[0], result[1], result[2], result[3],
-			     result[4], result[5], result[6], result[7],
-			     result[8], result[9], result[10], result[11],
-			     result[12], result[13], result[14], result[15],
-			     result[16], result[17], result[18], result[19],
-			     result[20], result[21], result[22], result[23],
-			     result[24], result[25], result[26], result[27],
-			     result[28], result[29], result[30], result[31]);
-		VLOG(TRACE,
-		     "[%d]%s.vdi_free_dma_memory hashTable(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-		     __LINE__, __func__, pDecInfo->hashTable.phys_addr,
-		     pDecInfo->hashTable.base, pDecInfo->hashTable.virt_addr,
-		     pDecInfo->hashTable.size,
-		     pDecInfo->hashTable.req_spec_region);
-		vdi_free_dma_memory(pCodecInst->coreIdx, &pDecInfo->hashTable);
-	}
-#endif
-
-	LeaveLock(pCodecInst->coreIdx);
-
-	FreeCodecInstance(pCodecInst);
-
-	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__, handle,
-	     ret);
-	return ret;
-}
-
-RetCode VPU_DecSetEscSeqInit(DecHandle handle, int escape)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	RetCode ret;
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-
-	if (pDecInfo->openParam.bitstreamMode != BS_MODE_INTERRUPT)
-		return RETCODE_INVALID_PARAM;
-
-	pDecInfo->seqInitEscape = escape;
-
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_DecGetInitialInfo(DecHandle handle, DecInitialInfo *info)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	RetCode ret;
-	Int32 flags;
-	Uint32 interruptBit;
-	VpuAttr *pAttr;
-
-	/* CODA9xx */
-	interruptBit = INT_BIT_SEQ_INIT;
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	if (info == NULL)
-		return RETCODE_INVALID_PARAM;
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-	ret = ProductVpuDecCheckCapability(pCodecInst);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	EnterLock(pCodecInst->coreIdx);
-
-	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
-
-	if (GetPendingInst(pCodecInst->coreIdx)) {
-		/* The other instance is running */
-		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
-		{
-			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
-			     __func__, __LINE__);
-			msleep(50);
-			if (GetPendingInst(pCodecInst->coreIdx)) {
-				LeaveLock(pCodecInst->coreIdx);
-				return RETCODE_FRAME_NOT_COMPLETE;
-			}
-		} else {
-			LeaveLock(pCodecInst->coreIdx);
-			return RETCODE_FRAME_NOT_COMPLETE;
-		}
-	}
-
-	if (DecBitstreamBufEmpty(pDecInfo)) {
-		LeaveLock(pCodecInst->coreIdx);
-		return RETCODE_WRONG_CALL_SEQUENCE;
-	}
-
-	ret = ProductVpuDecInitSeq(handle);
-	if (ret != RETCODE_SUCCESS) {
-		LeaveLock(pCodecInst->coreIdx);
-		return ret;
-	}
-
-	if (pAttr->supportCommandQueue == TRUE) {
-		LeaveLock(pCodecInst->coreIdx);
-	}
-
-	flags = ProductVpuWaitInterrupt(pCodecInst, __VPU_BUSY_TIMEOUT);
-
-	if (pAttr->supportCommandQueue == TRUE) {
-		EnterLock(pCodecInst->coreIdx);
-	}
-
-	if (flags == -1) {
-		info->rdPtr = VpuReadReg(pCodecInst->coreIdx,
-					 pDecInfo->streamRdPtrRegAddr);
-		info->wrPtr = VpuReadReg(pCodecInst->coreIdx,
-					 pDecInfo->streamWrPtrRegAddr);
-		ret = RETCODE_VPU_RESPONSE_TIMEOUT;
-	} else {
-		if (flags & (1 << interruptBit))
-			ProductVpuClearInterrupt(pCodecInst->coreIdx,
-						 (1 << interruptBit));
-
-		if (flags != (1 << interruptBit))
-			ret = RETCODE_FAILURE;
-		else
-			ret = ProductVpuDecGetSeqInfo(handle, info);
-	}
-
-	info->rdPtr =
-		VpuReadReg(pCodecInst->coreIdx, pDecInfo->streamRdPtrRegAddr);
-	info->wrPtr =
-		VpuReadReg(pCodecInst->coreIdx, pDecInfo->streamWrPtrRegAddr);
-
-	pDecInfo->initialInfo = *info;
-	if (ret == RETCODE_SUCCESS) {
-		pDecInfo->initialInfoObtained = 1;
-	}
-
-	SetPendingInst(pCodecInst->coreIdx, 0);
-
-	LeaveLock(pCodecInst->coreIdx);
-
-	return ret;
-}
-
-RetCode VPU_DecIssueSeqInit(DecHandle handle)
-{
-	CodecInst *pCodecInst;
-	RetCode ret;
-	VpuAttr *pAttr;
-
-	VLOG(TRACE, "[+] [%d]%s.h:0x%x\n", __LINE__, __func__, handle);
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS) {
-		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
-		     handle, ret);
-		return ret;
-	}
-
-	pCodecInst = handle;
-
-	EnterLock(pCodecInst->coreIdx);
-
-	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
-
-	if (GetPendingInst(pCodecInst->coreIdx)) {
-		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
-		{
-			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
-			     __func__, __LINE__);
-			msleep(50);
-			if (GetPendingInst(pCodecInst->coreIdx)) {
-				LeaveLock(pCodecInst->coreIdx);
-				VLOG(ERR,
-				     "[-] [%d]%s.h:0x%x.ret:RETCODE_FRAME_NOT_COMPLETE\n",
-				     __LINE__, __func__, handle);
-				return RETCODE_FRAME_NOT_COMPLETE;
-			}
-		} else {
-			LeaveLock(pCodecInst->coreIdx);
-			VLOG(ERR,
-			     "[-] [%d]%s.h:0x%x.ret:RETCODE_FRAME_NOT_COMPLETE\n",
-			     __LINE__, __func__, handle);
-			return RETCODE_FRAME_NOT_COMPLETE;
-		}
-	}
-
-	ret = ProductVpuDecInitSeq(handle);
-	if (ret == RETCODE_SUCCESS) {
-		SetPendingInst(pCodecInst->coreIdx, pCodecInst);
-	}
-
-	if (pAttr->supportCommandQueue == TRUE) {
-		SetPendingInst(pCodecInst->coreIdx, NULL);
-		LeaveLock(pCodecInst->coreIdx);
-	}
-
-	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__, handle,
-	     ret);
-	return ret;
-}
-
-RetCode VPU_DecCompleteSeqInit(DecHandle handle, DecInitialInfo *info)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	RetCode ret;
-	VpuAttr *pAttr;
-
-	VLOG(TRACE, "[+] [%d]%s.h:0x%x\n", __LINE__, __func__, handle);
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS) {
-		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
-		     handle, ret);
-		return ret;
-	}
-
-	if (info == 0) {
-		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:RETCODE_INVALID_PARAM\n",
-		     __LINE__, __func__, handle);
-		return RETCODE_INVALID_PARAM;
-	}
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-
-	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
-
-	if (pAttr->supportCommandQueue == TRUE) {
-		EnterLock(pCodecInst->coreIdx);
-	} else {
-		if (pCodecInst != GetPendingInst(pCodecInst->coreIdx)) {
-			SetPendingInst(pCodecInst->coreIdx, 0);
-			LeaveLock(pCodecInst->coreIdx);
-			VLOG(ERR,
-			     "[-] [%d]%s.h:0x%x.ret:RETCODE_WRONG_CALL_SEQUENCE\n",
-			     __LINE__, __func__, handle);
-			return RETCODE_WRONG_CALL_SEQUENCE;
-		}
-	}
-
-	ret = ProductVpuDecGetSeqInfo(handle, info);
-	if (ret == RETCODE_SUCCESS) {
-		pDecInfo->initialInfoObtained = 1;
-	}
-
-	info->rdPtr = ProductVpuDecGetRdPtr(pCodecInst);
-	info->wrPtr =
-		VpuReadReg(pCodecInst->coreIdx, pDecInfo->streamWrPtrRegAddr);
-#ifdef FIX_SET_GET_RD_PTR_BUG
-#else
-	pDecInfo->prevFrameEndPos = info->rdPtr;
-#endif
-	pDecInfo->initialInfo = *info;
-
-	VLOG(TRACE, "[picWidth                ]: %d\n", info->picWidth);
-	VLOG(TRACE, "[picHeight               ]: %d\n", info->picHeight);
-	VLOG(TRACE, "[fRateNumerator          ]: %d\n", info->fRateNumerator);
-	VLOG(TRACE, "[fRateDenominator        ]: %d\n", info->fRateDenominator);
-	VLOG(TRACE, "[picCropRect.left        ]: %d\n", info->picCropRect.left);
-	VLOG(TRACE, "[picCropRect.top         ]: %d\n", info->picCropRect.top);
-	VLOG(TRACE, "[picCropRect.right       ]: %d\n",
-	     info->picCropRect.right);
-	VLOG(TRACE, "[picCropRect.bottom      ]: %d\n",
-	     info->picCropRect.bottom);
-	VLOG(TRACE, "[mp4DataPartitionEnable  ]: %d\n",
-	     info->mp4DataPartitionEnable);
-	VLOG(TRACE, "[mp4ReversibleVlcEnable  ]: %d\n",
-	     info->mp4ReversibleVlcEnable);
-	VLOG(TRACE, "[mp4ShortVideoHeader     ]: %d\n",
-	     info->mp4ShortVideoHeader);
-	VLOG(TRACE, "[h263AnnexJEnable        ]: %d\n", info->h263AnnexJEnable);
-	VLOG(TRACE, "[minFrameBufferCount     ]: %d\n",
-	     info->minFrameBufferCount);
-	VLOG(TRACE, "[frameBufDelay           ]: %d\n", info->frameBufDelay);
-	VLOG(TRACE, "[normalSliceSize         ]: %d\n", info->normalSliceSize);
-	VLOG(TRACE, "[worstSliceSize          ]: %d\n", info->worstSliceSize);
-	VLOG(TRACE, "[maxSubLayers            ]: %d\n", info->maxSubLayers);
-	VLOG(TRACE, "[profile                 ]: %d\n", info->profile);
-	VLOG(TRACE, "[level                   ]: %d\n", info->level);
-	VLOG(TRACE, "[tier                    ]: %d\n", info->tier);
-	VLOG(TRACE, "[interlace               ]: %d\n", info->interlace);
-	VLOG(TRACE, "[constraint_set_flag     ]: 0x%08x 0x%08x 0x%08x 0x%08x\n",
-	     info->constraint_set_flag[0], info->constraint_set_flag[1],
-	     info->constraint_set_flag[2], info->constraint_set_flag[3]);
-	VLOG(TRACE, "[direct8x8Flag           ]: %d\n", info->direct8x8Flag);
-	VLOG(TRACE, "[vc1Psf                  ]: %d\n", info->vc1Psf);
-	VLOG(TRACE, "[isExtSAR                ]: %d\n", info->isExtSAR);
-	VLOG(TRACE, "[maxNumRefFrmFlag        ]: %d\n", info->maxNumRefFrmFlag);
-	VLOG(TRACE, "[maxNumRefFrm            ]: %d\n", info->maxNumRefFrm);
-	VLOG(TRACE, "[aspectRateInfo          ]: %d\n", info->aspectRateInfo);
-	VLOG(TRACE, "[bitRate                 ]: %d\n", info->bitRate);
-	VLOG(TRACE, "[mp2LowDelay             ]: %d\n", info->mp2LowDelay);
-	VLOG(TRACE, "[mp2DispVerSize          ]: %d\n", info->mp2DispVerSize);
-	VLOG(TRACE, "[mp2DispHorSize          ]: %d\n", info->mp2DispHorSize);
-	VLOG(TRACE, "[userDataNum             ]: %d\n", info->userDataNum);
-	VLOG(TRACE, "[userDataSize            ]: %d\n", info->userDataSize);
-	VLOG(TRACE, "[chromaFormatIDC         ]: %d\n", info->chromaFormatIDC);
-	VLOG(TRACE, "[lumaBitdepth            ]: %d\n", info->lumaBitdepth);
-	VLOG(TRACE, "[chromaBitdepth          ]: %d\n", info->chromaBitdepth);
-	VLOG(TRACE, "[seqInitErrReason        ]: 0x%08x\n",
-	     info->seqInitErrReason);
-	VLOG(TRACE, "[warnInfo                ]: %d\n", info->warnInfo);
-	VLOG(TRACE, "[rdPtr                   ]: 0x%08x\n", info->rdPtr);
-	VLOG(TRACE, "[wrPtr                   ]: 0x%08x\n", info->wrPtr);
-	VLOG(TRACE, "[sequenceNo              ]: %d\n", info->sequenceNo);
-
-	SetPendingInst(pCodecInst->coreIdx, NULL);
-
-	LeaveLock(pCodecInst->coreIdx);
-
-	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__, handle,
-	     ret);
-	return ret;
-}
-
-static RetCode DecRegisterFrameBuffer(DecHandle handle, FrameBuffer *bufArray,
-				      int numFbsForDecoding, int numFbsForWTL,
-				      int stride, int height, int mapType)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	Int32 i;
-	Uint32 size, totalAllocSize;
-	RetCode ret;
-	FrameBuffer *fb, nullFb;
-	vpu_buffer_t *vb;
-	FrameBufferFormat format = FORMAT_420;
-	Int32 totalNumOfFbs;
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	if (numFbsForDecoding > MAX_FRAMEBUFFER_COUNT ||
-	    numFbsForWTL > MAX_FRAMEBUFFER_COUNT) {
-		return RETCODE_INVALID_PARAM;
-	}
-
-	osal_memset(&nullFb, 0x00, sizeof(FrameBuffer));
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-	pDecInfo->numFbsForDecoding = numFbsForDecoding;
-	pDecInfo->numFbsForWTL = numFbsForWTL;
-	pDecInfo->numFrameBuffers = numFbsForDecoding + numFbsForWTL;
-	pDecInfo->stride = stride;
-	if (pCodecInst->codecMode == VPX_DEC ||
-	    pCodecInst->codecMode == W_VP8_DEC)
-		pDecInfo->frameBufferHeight = VPU_ALIGN64(height);
-	else if (pCodecInst->codecMode == W_VP9_DEC)
-		pDecInfo->frameBufferHeight = VPU_ALIGN64(height);
-	else
-		pDecInfo->frameBufferHeight = height;
-	pDecInfo->mapType = mapType;
-	pDecInfo->mapCfg.productId = pCodecInst->productId;
-
-	ret = ProductVpuDecCheckCapability(pCodecInst);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	if (!pDecInfo->initialInfoObtained)
-		return RETCODE_WRONG_CALL_SEQUENCE;
-
-	if ((stride < pDecInfo->initialInfo.picWidth) || (stride % 8 != 0) ||
-	    (height < pDecInfo->initialInfo.picHeight)) {
-		return RETCODE_INVALID_STRIDE;
-	}
-
-	EnterLock(pCodecInst->coreIdx);
-	if (GetPendingInst(pCodecInst->coreIdx)) {
-		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
-		{
-			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
-			     __func__, __LINE__);
-			msleep(50);
-			if (GetPendingInst(pCodecInst->coreIdx)) {
-				LeaveLock(pCodecInst->coreIdx);
-				return RETCODE_FRAME_NOT_COMPLETE;
-			}
-		} else {
-			LeaveLock(pCodecInst->coreIdx);
-			return RETCODE_FRAME_NOT_COMPLETE;
-		}
-	}
-
-	/* clear frameBufPool */
-	for (i = 0;
-	     i < (int)(sizeof(pDecInfo->frameBufPool) / sizeof(FrameBuffer));
-	     i++) {
-		pDecInfo->frameBufPool[i] = nullFb;
-	}
-
-	/* LinearMap or TiledMap, compressed framebuffer inclusive. */
-	if (pDecInfo->initialInfo.lumaBitdepth > 8 ||
-	    pDecInfo->initialInfo.chromaBitdepth > 8)
-		format = FORMAT_420_P10_16BIT_LSB;
-
-	totalNumOfFbs = numFbsForDecoding + numFbsForWTL;
-	VLOG(TRACE,
-	     "[%d]%s.numFbsForDecoding:%d.numFbsForWTL:%d.totalNumOfFbs:%d(%d).\n",
-	     __LINE__, __func__, pDecInfo->numFbsForDecoding,
-	     pDecInfo->numFbsForWTL, totalNumOfFbs, pDecInfo->numFrameBuffers);
-	if (bufArray) {
-		for (i = 0; i < totalNumOfFbs; i++)
-			pDecInfo->frameBufPool[i] = bufArray[i];
-	} else {
-		vb = &pDecInfo->vbFrame;
-		fb = &pDecInfo->frameBufPool[0];
-		ret = ProductVpuAllocateFramebuffer(
-			(CodecInst *)handle, fb, (TiledMapType)mapType,
-			numFbsForDecoding, stride, height, format,
-			pDecInfo->openParam.cbcrInterleave,
-			pDecInfo->openParam.nv21,
-			pDecInfo->openParam.frameEndian, vb, 0, FB_TYPE_CODEC);
-		if (ret != RETCODE_SUCCESS) {
-			LeaveLock(pCodecInst->coreIdx);
-			return ret;
-		}
-	}
-	totalAllocSize = 0;
-	if (pCodecInst->productId != PRODUCT_ID_960) {
-		pDecInfo->mapCfg.tiledBaseAddr = pDecInfo->frameBufPool[0].bufY;
-	}
-
-	if (numFbsForDecoding == 1) {
-		size = ProductCalculateFrameBufSize(
-			handle->productId, stride, height,
-			(TiledMapType)mapType, format,
-			pDecInfo->openParam.cbcrInterleave, &pDecInfo->dramCfg);
-	} else {
-		size = pDecInfo->frameBufPool[1].bufY -
-		       pDecInfo->frameBufPool[0].bufY;
-	}
-	size *= numFbsForDecoding;
-	totalAllocSize += size;
-
-	/* LinearMap */
-	if (pDecInfo->wtlEnable == TRUE || pDecInfo->enableAfbce == TRUE ||
-	    numFbsForWTL != 0) {
-		pDecInfo->stride = stride;
-		if (bufArray) {
-			format = pDecInfo->frameBufPool[0].format;
-		} else {
-			TiledMapType map;
-			map = pDecInfo->enableAfbce == TRUE ?
-				      ARM_COMPRESSED_FRAME_MAP :
-				      ((pDecInfo->wtlMode == FF_FRAME ?
-						LINEAR_FRAME_MAP :
-						LINEAR_FIELD_MAP));
-			format = pDecInfo->wtlFormat;
-			vb = &pDecInfo->vbWTL;
-			fb = &pDecInfo->frameBufPool[numFbsForDecoding];
-
-			ret = ProductVpuAllocateFramebuffer(
-				(CodecInst *)handle, fb, map, numFbsForWTL,
-				stride, height, pDecInfo->wtlFormat,
-				pDecInfo->openParam.cbcrInterleave,
-				pDecInfo->openParam.nv21,
-				pDecInfo->openParam.frameEndian, vb, 0,
-				FB_TYPE_PPU);
-
-			if (ret != RETCODE_SUCCESS) {
-				LeaveLock(pCodecInst->coreIdx);
-				return ret;
-			}
-		}
-		if (numFbsForWTL == 1) {
-			size = ProductCalculateFrameBufSize(
-				handle->productId, stride, height,
-				(TiledMapType)mapType, format,
-				pDecInfo->openParam.cbcrInterleave,
-				&pDecInfo->dramCfg);
-		} else {
-			size = pDecInfo->frameBufPool[numFbsForDecoding + 1]
-				       .bufY -
-			       pDecInfo->frameBufPool[numFbsForDecoding].bufY;
-		}
-		size *= numFbsForWTL;
-		totalAllocSize += size;
-	}
-
-	ret = ProductVpuRegisterFramebuffer(pCodecInst);
-
-	LeaveLock(pCodecInst->coreIdx);
-
-#ifdef ENABLE_CODA9_WRITE_PROTECT
-	{
-		PhysicalAddress startAddr = 0xffffffff;
-		PhysicalAddress endAddr = 0;
-		Int32 maxSize = 0;
-
-		startAddr = 0xffffffff;
-		endAddr = 0;
-		for (i = 0; i < totalNumOfFbs; i++) {
-			startAddr =
-				(startAddr > pDecInfo->frameBufPool[i].bufY) ?
-					pDecInfo->frameBufPool[i].bufY :
-					startAddr;
-			endAddr = (endAddr < pDecInfo->frameBufPool[i].bufY) ?
-					  pDecInfo->frameBufPool[i].bufY :
-					  endAddr;
-			maxSize = (maxSize < pDecInfo->frameBufPool[i].size) ?
-					  pDecInfo->frameBufPool[i].size :
-					  maxSize;
-		}
-		endAddr += maxSize;
-		VLOG(INFO,
-		     "[%d]%s.registered frameBuf startAddr:0x%08x.endAddr:0x%08x.size:%d\n",
-		     __LINE__, __func__, startAddr, endAddr, maxSize);
-
-		if (pDecInfo->vbMV[0].phys_addr > 0) {
-			for (i = 0; i < numFbsForDecoding; i++) {
-				PhysicalAddress mvColEndAddr =
-					pDecInfo->vbMV[i].phys_addr +
-					pDecInfo->vbMV[i].size;
-				VLOG(INFO,
-				     "[%d]%s.vbMV[%d](0x%08x,0x%08x).startAddr:0x%08x.endAddr:0x%08x\n",
-				     __LINE__, __func__, i,
-				     pDecInfo->vbMV[i].phys_addr, mvColEndAddr,
-				     startAddr, endAddr);
-				startAddr = (startAddr <
-					     pDecInfo->vbMV[i].phys_addr) ?
-						    startAddr :
-						    pDecInfo->vbMV[i].phys_addr;
-				endAddr = (endAddr < mvColEndAddr) ?
-						  mvColEndAddr :
-						  endAddr;
-				VLOG(INFO,
-				     "[%d]%s.new startAddr:0x%08x.endAddr:0x%08x\n",
-				     __LINE__, __func__, startAddr, endAddr);
-			}
-		}
-
-		if (pDecInfo->secAxiInfo.bufSize) {
-			pDecInfo->writeMemProtectCfg
-				.decRegion[WPROT_DEC_SEC_AXI]
-				.enable = TRUE;
-			pDecInfo->writeMemProtectCfg
-				.decRegion[WPROT_DEC_SEC_AXI]
-				.isSecondary = TRUE;
-			pDecInfo->writeMemProtectCfg
-				.decRegion[WPROT_DEC_SEC_AXI]
-				.startAddress = pDecInfo->secAxiInfo.bufBase;
-			pDecInfo->writeMemProtectCfg
-				.decRegion[WPROT_DEC_SEC_AXI]
-				.endAddress = pDecInfo->secAxiInfo.bufBase +
-					      pDecInfo->secAxiInfo.bufSize;
-			VLOG(INFO,
-			     "[%d]%s.set decRegion[WPROT_DEC_SEC_AXI](%d,%d,0x%08x,0x%08x)\n",
-			     __LINE__, __func__,
-			     pDecInfo->writeMemProtectCfg
-				     .decRegion[WPROT_DEC_SEC_AXI]
-				     .enable,
-			     pDecInfo->writeMemProtectCfg
-				     .decRegion[WPROT_DEC_SEC_AXI]
-				     .isSecondary,
-			     pDecInfo->writeMemProtectCfg
-				     .decRegion[WPROT_DEC_SEC_AXI]
-				     .startAddress,
-			     pDecInfo->writeMemProtectCfg
-				     .decRegion[WPROT_DEC_SEC_AXI]
-				     .endAddress);
-		}
-		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME].enable =
-			TRUE;
-		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-			.isSecondary = FALSE;
-		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-			.startAddress = startAddr;
-		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-			.endAddress = endAddr;
-		VLOG(INFO,
-		     "[%d]%s.set decRegion[WPROT_DEC_FRAME](%d,%d,0x%08x,0x%08x)\n",
-		     __LINE__, __func__,
-		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-			     .enable,
-		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-			     .isSecondary,
-		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-			     .startAddress,
-		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-			     .endAddress);
-	}
-#endif
-
-	return ret;
-}
-
-RetCode VPU_DecRegisterFrameBuffer(DecHandle handle, FrameBuffer *bufArray,
-				   int num, int stride, int height, int mapType)
-{
-	DecInfo *pDecInfo = &handle->CodecInfo->decInfo;
-	Uint32 numWTL = 0;
-	RetCode ret;
-	int i;
-
-	VLOG(TRACE, "[+] [%d]%s.h:0x%x.num:%d.stride:%d.height:%d.mapType:%d\n",
-	     __LINE__, __func__, handle, num, stride, height, mapType);
-	if (num) {
-		for (i = 0; i < num; i++) {
-			VLOG(TRACE,
-			     "[%d]%s.h:0x%x.size:%d.bufY:0x%x.0x%x.0x%x.updateFbInfo:%d\n",
-			     __LINE__, __func__, handle, bufArray[i].size,
-			     bufArray[i].bufY, bufArray[i].bufCb,
-			     bufArray[i].bufCr, bufArray[i].updateFbInfo);
-		}
-	}
-	if (pDecInfo->wtlEnable == TRUE)
-		numWTL = num;
-	ret = DecRegisterFrameBuffer(handle, bufArray, num, numWTL, stride,
-				     height, mapType);
-	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__, handle,
-	     ret);
-	return ret;
-}
-
-RetCode VPU_DecRegisterFrameBufferEx(DecHandle handle, FrameBuffer *bufArray,
-				     int numOfDecFbs, int numOfDisplayFbs,
-				     int stride, int height, int mapType)
-{
-	return DecRegisterFrameBuffer(handle, bufArray, numOfDecFbs,
-				      numOfDisplayFbs, stride, height, mapType);
-}
-
-RetCode VPU_DecGetFrameBuffer(DecHandle handle, int frameIdx,
-			      FrameBuffer *frameBuf)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	RetCode ret;
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	if (frameBuf == 0)
-		return RETCODE_INVALID_PARAM;
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-
-	if (frameIdx < 0 || frameIdx >= pDecInfo->numFrameBuffers)
-		return RETCODE_INVALID_PARAM;
-
-	*frameBuf = pDecInfo->frameBufPool[frameIdx];
-
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_DecUpdateFrameBuffer(DecHandle handle, FrameBuffer *fbcFb,
-				 FrameBuffer *linearFb, Int32 mvColIndex,
-				 Int32 picWidth, Int32 picHeight)
-{
-	if (handle == NULL) {
-		return RETCODE_INVALID_HANDLE;
-	}
-
-	return ProductVpuDecUpdateFrameBuffer((CodecInst *)handle, fbcFb,
-					      linearFb, mvColIndex, picWidth,
-					      picHeight);
-}
-
-RetCode VPU_DecSetBitstreamBuffer(DecHandle handle, PhysicalAddress rdPtr,
-				  PhysicalAddress wrPtr)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	RetCode ret;
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-
-	SetClockGate(pCodecInst->coreIdx, 1);
-
-	if (GetPendingInst(pCodecInst->coreIdx) == pCodecInst)
-		VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamRdPtrRegAddr,
-			    rdPtr);
-	else
-		pDecInfo->streamRdPtr = rdPtr;
-
-	SetClockGate(pCodecInst->coreIdx, 0);
-
-	pDecInfo->streamWrPtr = wrPtr;
-
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_DecSetDispFlag(DecHandle handle, int dispFlag) // [r] unused
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	RetCode ret;
-	VpuAttr *pAttr;
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-
-	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
-	if (pAttr->supportCommandQueue == FALSE) {
-		EnterDispFlagLock(pCodecInst->coreIdx);
-		pDecInfo->frameDisplayFlag = dispFlag;
-		pDecInfo->clearDisplayIndexes = 0;
-		LeaveDispFlagLock(pCodecInst->coreIdx);
-	} else {
-		EnterLock(pCodecInst->coreIdx);
-		LeaveLock(pCodecInst->coreIdx);
-	}
-
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_DecGetBitstreamBuffer(DecHandle handle, PhysicalAddress *prdPtr,
-				  PhysicalAddress *pwrPtr, Uint32 *size)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	PhysicalAddress rdPtr;
-	PhysicalAddress wrPtr;
-	PhysicalAddress tempPtr;
-	int room;
-	Int32 coreIdx;
-	VpuAttr *pAttr;
-
-	coreIdx = handle->coreIdx;
-	pAttr = &g_VpuCoreAttributes[coreIdx];
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-
-	SetClockGate(coreIdx, TRUE);
-
-	if (pAttr->supportCommandQueue == TRUE) {
-#ifdef FIX_SET_GET_RD_PTR_BUG
-		EnterLock(pCodecInst->coreIdx);
-		rdPtr = ProductVpuDecGetRdPtr(pCodecInst);
-		LeaveLock(pCodecInst->coreIdx);
-#else
-		if (pDecInfo->rdPtrValidFlag ==
-		    TRUE) { // when RdPtr has been updated by calling SetRdPtr.
-			rdPtr = pDecInfo->streamRdPtr;
-		} else {
-			EnterLock(pCodecInst->coreIdx);
-			rdPtr = ProductVpuDecGetRdPtr(pCodecInst);
-			LeaveLock(pCodecInst->coreIdx);
-		}
-#endif
-	} else {
-		if (GetPendingInst(coreIdx) == pCodecInst) {
-			if (pCodecInst->codecMode == AVC_DEC &&
-			    pCodecInst->codecModeAux == AVC_AUX_MVC) {
-				rdPtr = pDecInfo->streamRdPtr;
-			} else {
-				rdPtr = VpuReadReg(
-					coreIdx, pDecInfo->streamRdPtrRegAddr);
-			}
-		} else {
-			rdPtr = pDecInfo->streamRdPtr;
-		}
-	}
-
-	SetClockGate(coreIdx, FALSE);
-
-	wrPtr = pDecInfo->streamWrPtr;
-
-	pAttr = &g_VpuCoreAttributes[coreIdx];
-
-	tempPtr = rdPtr;
-
-	if (pDecInfo->openParam.bitstreamMode != BS_MODE_PIC_END) {
-		if (wrPtr < tempPtr) {
-			room = tempPtr - wrPtr -
-			       pAttr->bitstreamBufferMargin * 2;
-		} else {
-			room = (pDecInfo->streamBufEndAddr - wrPtr) +
-			       (tempPtr - pDecInfo->streamBufStartAddr) -
-			       pAttr->bitstreamBufferMargin * 2;
-		}
-		room--;
-	} else {
-		room = (pDecInfo->streamBufEndAddr - wrPtr);
-	}
-
-	if (prdPtr)
-		*prdPtr = tempPtr;
-	if (pwrPtr)
-		*pwrPtr = wrPtr;
-	if (size)
-		*size = room;
-
-	VLOG(TRACE, "[%d]%s.h:0x%x.rdPtr:0x%x.wrPtr:0x%x.room:%d\n", __LINE__,
-	     __func__, handle, tempPtr, wrPtr, room);
-	return RETCODE_SUCCESS;
-}
-
-// RTHA-133, for PIC_END + ring buffer
-RetCode VPU_DecGetBitstreamBufferEx(DecHandle handle, PhysicalAddress *prdPtr,
-				    PhysicalAddress *pwrPtr, Uint32 *size)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	PhysicalAddress rdPtr;
-	PhysicalAddress wrPtr;
-	PhysicalAddress tempPtr;
-	int room;
-	Int32 coreIdx;
-	VpuAttr *pAttr;
-
-	coreIdx = handle->coreIdx;
-	pAttr = &g_VpuCoreAttributes[coreIdx];
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-
-	SetClockGate(coreIdx, TRUE);
-
-	if (pAttr->supportCommandQueue == TRUE) {
-#ifdef FIX_SET_GET_RD_PTR_BUG
-		EnterLock(pCodecInst->coreIdx);
-		rdPtr = ProductVpuDecGetRdPtr(pCodecInst);
-		LeaveLock(pCodecInst->coreIdx);
-#else
-		if (pDecInfo->rdPtrValidFlag ==
-		    TRUE) { // when RdPtr has been updated by calling SetRdPtr.
-			rdPtr = pDecInfo->streamRdPtr;
-		} else {
-			EnterLock(pCodecInst->coreIdx);
-			rdPtr = ProductVpuDecGetRdPtr(pCodecInst);
-			LeaveLock(pCodecInst->coreIdx);
-		}
-#endif
-	} else {
-		if (GetPendingInst(coreIdx) == pCodecInst) {
-			if (pCodecInst->codecMode == AVC_DEC &&
-			    pCodecInst->codecModeAux == AVC_AUX_MVC) {
-				rdPtr = pDecInfo->streamRdPtr;
-			} else {
-				rdPtr = VpuReadReg(
-					coreIdx, pDecInfo->streamRdPtrRegAddr);
-			}
-		} else {
-			rdPtr = pDecInfo->streamRdPtr;
-		}
-	}
-
-	SetClockGate(coreIdx, FALSE);
-
-	wrPtr = pDecInfo->streamWrPtr;
-
-	pAttr = &g_VpuCoreAttributes[coreIdx];
-
-	tempPtr = rdPtr;
-
-	if (wrPtr < tempPtr) {
-		room = tempPtr - wrPtr - pAttr->bitstreamBufferMargin * 2;
-	} else {
-		room = (pDecInfo->streamBufEndAddr - wrPtr) +
-		       (tempPtr - pDecInfo->streamBufStartAddr) -
-		       pAttr->bitstreamBufferMargin * 2;
-	}
-	room--;
-
-	if (prdPtr)
-		*prdPtr = tempPtr;
-	if (pwrPtr)
-		*pwrPtr = wrPtr;
-	if (size)
-		*size = room;
-
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_DecUpdateBitstreamBuffer(DecHandle handle, int size)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	PhysicalAddress wrPtr;
-	PhysicalAddress rdPtr;
-	RetCode ret;
-	BOOL running;
-	VpuAttr *pAttr;
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS) {
-		VLOG(ERR, "[-] [%d]%s.h:0x%x.size:%d.ret:%d\n", __LINE__,
-		     __func__, handle, size, ret);
-		return ret;
-	}
-
-	pCodecInst = handle;
-	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-	wrPtr = pDecInfo->streamWrPtr;
-
-	SetClockGate(pCodecInst->coreIdx, 1);
-
-	if (pAttr->supportCommandQueue == TRUE) {
-		running = FALSE;
-	} else {
-		running = (BOOL)(GetPendingInst(pCodecInst->coreIdx) ==
-				 pCodecInst);
-	}
-
-	if (size > 0) {
-		Uint32 room = 0;
-
-		if (running == TRUE)
-			rdPtr = VpuReadReg(pCodecInst->coreIdx,
-					   pDecInfo->streamRdPtrRegAddr);
-		else
-			rdPtr = pDecInfo->streamRdPtr;
-
-		if (wrPtr < rdPtr) {
-			if (rdPtr <= wrPtr + size) {
-				SetClockGate(pCodecInst->coreIdx, 0);
-				VLOG(ERR,
-				     "[-] [%d]%s.h:0x%x.size:%d.ret:RETCODE_INVALID_PARAM\n",
-				     __LINE__, __func__, handle, size);
-				return RETCODE_INVALID_PARAM;
-			}
-		}
-
-		wrPtr += size;
-
-		// Discuss with FuChun, vpuapi can't know BS buffer is ring buffer or line buffer.
-		// Gregory use "bitstreamMode != BS_MODE_PIC_END" to determine BS buffer is ring buffer is not correct due to we have PIC_END + ring buffer case.
-		// If line buffer, wrPts won't be bigger than pDecInfo->streamBufEndAddr, so mark this condition is also ok for line buffer.
-		if (wrPtr > pDecInfo->streamBufEndAddr) {
-			room = wrPtr - pDecInfo->streamBufEndAddr;
-			wrPtr = pDecInfo->streamBufStartAddr;
-			wrPtr += room;
-		} else if (wrPtr == pDecInfo->streamBufEndAddr) {
-			wrPtr = pDecInfo->streamBufStartAddr;
-		}
-
-		pDecInfo->streamWrPtr = wrPtr;
-		pDecInfo->streamRdPtr = rdPtr;
-
-		if (running == TRUE) {
-			VpuWriteReg(pCodecInst->coreIdx,
-				    pDecInfo->streamWrPtrRegAddr, wrPtr);
-		}
-	}
-
-	ret = ProductVpuDecSetBitstreamFlag(pCodecInst, running, size);
-
-	SetClockGate(pCodecInst->coreIdx, 0);
-	VLOG(TRACE, "[%d]%s.h:0x%x.size:%d.ret:%d\n", __LINE__, __func__,
-	     handle, size, ret);
-	return ret;
-}
-
-RetCode VPU_HWReset(Uint32 coreIdx)
-{
-	if (vdi_hw_reset(coreIdx) < 0)
-		return RETCODE_FAILURE;
-
-	if (GetPendingInst(coreIdx)) {
-		SetPendingInst(coreIdx, 0);
-		LeaveLock(
-			coreIdx); //if vpu is in a lock state. release the state;
-	}
-	return RETCODE_SUCCESS;
-}
-
-/**
-* VPU_SWReset
-* IN
-*    forcedReset : 1 if there is no need to waiting for BUS transaction,
-*                  0 for otherwise
-* OUT
-*    RetCode : RETCODE_FAILURE if failed to reset,
-*              RETCODE_SUCCESS for otherwise
-*/
-RetCode VPU_SWReset(Uint32 coreIdx, SWResetMode resetMode, void *pendingInst)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	CodecInst *pCodecInst = (CodecInst *)pendingInst;
-
-	VLOG(TRACE, "[+] [%d]%s.coreIdx:%d.resetMode:%d.pendingInst:%p\n",
-	     __LINE__, __func__, coreIdx, resetMode, pendingInst);
-	SetClockGate(coreIdx, 1);
-	ret = ProductVpuReset(coreIdx, resetMode);
-
-	if (ret != RETCODE_SUCCESS) //RTK
-	{
-		ret = VPU_HWReset(coreIdx);
-	} else {
-		if (pCodecInst) {
-			SetPendingInst(pCodecInst->coreIdx, 0);
-			LeaveLock(coreIdx);
-			SetClockGate(coreIdx, 1);
-			if (pCodecInst->loggingEnable) {
-				vdi_log(pCodecInst->coreIdx,
-					(pCodecInst->productId ==
-						 PRODUCT_ID_960 ||
-					 pCodecInst->productId ==
-						 PRODUCT_ID_980) ?
-						0x10 :
-						0x10000,
-					1);
-			}
-		}
-
-		if (pCodecInst) {
-			if (pCodecInst->loggingEnable) {
-				vdi_log(pCodecInst->coreIdx,
-					(pCodecInst->productId ==
-						 PRODUCT_ID_960 ||
-					 pCodecInst->productId ==
-						 PRODUCT_ID_980) ?
-						0x10 :
-						0x10000,
-					0);
-			}
-		}
-	}
-
-	SetClockGate(coreIdx, 0);
-
-	VLOG(TRACE, "[-] [%d]%s.coreIdx:%d.ret:%d\n", __LINE__, __func__,
-	     coreIdx, ret);
-	return ret;
-}
-
-//---- VPU_SLEEP/WAKE
-RetCode VPU_SleepWake(Uint32 coreIdx, int iSleepWake)
-{
-	SetClockGate(coreIdx, TRUE);
-	SetClockGate(coreIdx, FALSE);
-
-	return 0;
-}
-
-RetCode VPU_DecStartOneFrame(DecHandle handle, DecParam *param)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	Uint32 val = 0;
-	RetCode ret = RETCODE_SUCCESS;
-	VpuAttr *pAttr = NULL;
-
-	VLOG(TRACE, "[+] [%d]%s.h:0x%x.DecParam(%d,%d,%d)\n", __LINE__,
-	     __func__, handle, param->iframeSearchEnable, param->skipframeMode,
-	     param->craAsBlaFlag);
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS) {
-		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
-		     handle, ret);
-		return ret;
-	}
-
-	pCodecInst = (CodecInst *)handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-
-	if (pDecInfo->stride ==
-	    0) { // This means frame buffers have not been registered.
-		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:RETCODE_WRONG_CALL_SEQUENCE\n",
-		     __LINE__, __func__, handle);
-		return RETCODE_WRONG_CALL_SEQUENCE;
-	}
-
-	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
-
-	EnterLock(pCodecInst->coreIdx);
-	if (GetPendingInst(pCodecInst->coreIdx)) {
-		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
-		{
-			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
-			     __func__, __LINE__);
-			msleep(50);
-			if (GetPendingInst(pCodecInst->coreIdx)) {
-				LeaveLock(pCodecInst->coreIdx);
-				VLOG(ERR,
-				     "[-] [%d]%s.h:0x%x.ret:RETCODE_FRAME_NOT_COMPLETE\n",
-				     __LINE__, __func__, handle);
-				return RETCODE_FRAME_NOT_COMPLETE;
-			}
-		} else {
-			LeaveLock(pCodecInst->coreIdx);
-			VLOG(ERR,
-			     "[-] [%d]%s.h:0x%x.ret:RETCODE_FRAME_NOT_COMPLETE\n",
-			     __LINE__, __func__, handle);
-			return RETCODE_FRAME_NOT_COMPLETE;
-		}
-	}
-
-	if (pAttr->supportCommandQueue == FALSE) {
-		EnterDispFlagLock(pCodecInst->coreIdx);
-		val = pDecInfo->frameDisplayFlag;
-		val |= pDecInfo->setDisplayIndexes;
-		val &= ~(Uint32)(pDecInfo->clearDisplayIndexes);
-		VpuWriteReg(pCodecInst->coreIdx,
-			    pDecInfo->frameDisplayFlagRegAddr, val);
-		pDecInfo->clearDisplayIndexes = 0;
-		pDecInfo->setDisplayIndexes = 0;
-		LeaveDispFlagLock(pCodecInst->coreIdx);
-	}
-
-	pDecInfo->frameStartPos = pDecInfo->streamRdPtr;
-
-	ret = ProductVpuDecode(pCodecInst, param);
-
-	if (pAttr->supportCommandQueue == TRUE) {
-		SetPendingInst(pCodecInst->coreIdx, NULL);
-		LeaveLock(pCodecInst->coreIdx);
-	} else {
-		SetPendingInst(pCodecInst->coreIdx, pCodecInst);
-	}
-
-	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__, handle,
-	     ret);
-	return ret;
-}
-
-RetCode VPU_DecGetOutputInfo(DecHandle handle, DecOutputInfo *info)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	RetCode ret;
-	VpuRect rectInfo;
-	Uint32 val;
-	Int32 decodedIndex;
-	Int32 displayIndex;
-	Uint32 maxDecIndex;
-	VpuAttr *pAttr;
-#ifdef VE1_CHECKSUM_LOG_TO_TMP
-	char hash[128];
-	FILE *hash_out_file;
-#endif
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS) {
-		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
-		     handle, ret);
-		return ret;
-	}
-
-	if (info == 0) {
-		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:RETCODE_INVALID_PARAM\n",
-		     __LINE__, __func__, handle);
-		return RETCODE_INVALID_PARAM;
-	}
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
-
-	if (pAttr->supportCommandQueue == TRUE) {
-		EnterLock(pCodecInst->coreIdx);
-	} else {
-		if (pCodecInst != GetPendingInst(pCodecInst->coreIdx)) {
-			SetPendingInst(pCodecInst->coreIdx, 0);
-			LeaveLock(pCodecInst->coreIdx);
-			VLOG(ERR,
-			     "[-] [%d]%s.h:0x%x.ret:RETCODE_WRONG_CALL_SEQUENCE\n",
-			     __LINE__, __func__, handle);
-			return RETCODE_WRONG_CALL_SEQUENCE;
-		}
-	}
-
-	osal_memset((void *)info, 0x00, sizeof(DecOutputInfo));
-
-	ret = ProductVpuDecGetResult(pCodecInst, info);
-	if (ret != RETCODE_SUCCESS) {
-		info->rdPtr = pDecInfo->streamRdPtr;
-		info->wrPtr = pDecInfo->streamWrPtr;
-		SetPendingInst(pCodecInst->coreIdx, 0);
-		LeaveLock(pCodecInst->coreIdx);
-		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
-		     handle, ret);
-		return ret;
-	}
-
-	decodedIndex = info->indexFrameDecoded;
-
-	if (pDecInfo->openParam.afbceEnable) {
-		maxDecIndex =
-			(pDecInfo->numFbsForDecoding > pDecInfo->numFbsForWTL) ?
-				pDecInfo->numFbsForDecoding :
-				pDecInfo->numFbsForWTL;
-		if (0 <= decodedIndex && decodedIndex < (int)maxDecIndex) {
-			val = pDecInfo->numFbsForDecoding; //fbOffset
-			pDecInfo->frameBufPool[val + decodedIndex].lfEnable =
-				info->lfEnable;
-		}
-	}
-
-	// Calculate display frame region
-	val = 0;
-	if (decodedIndex >= 0 && decodedIndex < MAX_GDI_IDX) {
-		//default value
-		rectInfo.left = 0;
-		rectInfo.right = info->decPicWidth;
-		rectInfo.top = 0;
-		rectInfo.bottom = info->decPicHeight;
-
-		if (pCodecInst->codecMode == HEVC_DEC ||
-		    pCodecInst->codecMode == AVC_DEC ||
-		    pCodecInst->codecMode == W_AVC_DEC ||
-		    pCodecInst->codecMode == AVS_DEC)
-			rectInfo = pDecInfo->initialInfo.picCropRect;
-
-		info->rcDecoded.left =
-			pDecInfo->decOutInfo[decodedIndex].rcDecoded.left =
-				rectInfo.left;
-		info->rcDecoded.right =
-			pDecInfo->decOutInfo[decodedIndex].rcDecoded.right =
-				rectInfo.right;
-		info->rcDecoded.top =
-			pDecInfo->decOutInfo[decodedIndex].rcDecoded.top =
-				rectInfo.top;
-		info->rcDecoded.bottom =
-			pDecInfo->decOutInfo[decodedIndex].rcDecoded.bottom =
-				rectInfo.bottom;
-	} else {
-		info->rcDecoded.left = 0;
-		info->rcDecoded.right = info->decPicWidth;
-		info->rcDecoded.top = 0;
-		info->rcDecoded.bottom = info->decPicHeight;
-	}
-
-	displayIndex = info->indexFrameDisplay;
-	if (info->indexFrameDisplay >= 0 &&
-	    info->indexFrameDisplay < MAX_GDI_IDX) {
-		if (pCodecInst->codecMode == VC1_DEC ||
-		    pCodecInst->codecMode ==
-			    W_VC1_DEC) // vc1 rotates decoded frame buffer region. the other std rotated whole frame buffer region.
-		{
-			if (pDecInfo->rotationEnable &&
-			    (pDecInfo->rotationAngle == 90 ||
-			     pDecInfo->rotationAngle == 270)) {
-				info->rcDisplay.left =
-					pDecInfo->decOutInfo[displayIndex]
-						.rcDecoded.top;
-				info->rcDisplay.right =
-					pDecInfo->decOutInfo[displayIndex]
-						.rcDecoded.bottom;
-				info->rcDisplay.top =
-					pDecInfo->decOutInfo[displayIndex]
-						.rcDecoded.left;
-				info->rcDisplay.bottom =
-					pDecInfo->decOutInfo[displayIndex]
-						.rcDecoded.right;
-			} else {
-				info->rcDisplay.left =
-					pDecInfo->decOutInfo[displayIndex]
-						.rcDecoded.left;
-				info->rcDisplay.right =
-					pDecInfo->decOutInfo[displayIndex]
-						.rcDecoded.right;
-				info->rcDisplay.top =
-					pDecInfo->decOutInfo[displayIndex]
-						.rcDecoded.top;
-				info->rcDisplay.bottom =
-					pDecInfo->decOutInfo[displayIndex]
-						.rcDecoded.bottom;
-			}
-		} else {
-			if (pDecInfo->rotationEnable) {
-				switch (pDecInfo->rotationAngle) {
-				case 90:
-					info->rcDisplay.left =
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.top;
-					info->rcDisplay.right =
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.bottom;
-					info->rcDisplay.top =
-						info->decPicWidth -
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.right;
-					info->rcDisplay.bottom =
-						info->decPicWidth -
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.left;
-					break;
-				case 270:
-					info->rcDisplay.left =
-						info->decPicHeight -
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.bottom;
-					info->rcDisplay.right =
-						info->decPicHeight -
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.top;
-					info->rcDisplay.top =
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.left;
-					info->rcDisplay.bottom =
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.right;
-					break;
-				case 180:
-					info->rcDisplay.left =
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.left;
-					info->rcDisplay.right =
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.right;
-					info->rcDisplay.top =
-						info->decPicHeight -
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.bottom;
-					info->rcDisplay.bottom =
-						info->decPicHeight -
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.top;
-					break;
-				default:
-					info->rcDisplay.left =
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.left;
-					info->rcDisplay.right =
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.right;
-					info->rcDisplay.top =
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.top;
-					info->rcDisplay.bottom =
-						pDecInfo->decOutInfo[displayIndex]
-							.rcDecoded.bottom;
-					break;
-				}
-
-			} else {
-				info->rcDisplay.left =
-					pDecInfo->decOutInfo[displayIndex]
-						.rcDecoded.left;
-				info->rcDisplay.right =
-					pDecInfo->decOutInfo[displayIndex]
-						.rcDecoded.right;
-				info->rcDisplay.top =
-					pDecInfo->decOutInfo[displayIndex]
-						.rcDecoded.top;
-				info->rcDisplay.bottom =
-					pDecInfo->decOutInfo[displayIndex]
-						.rcDecoded.bottom;
-			}
-
-			if (pDecInfo->mirrorEnable) {
-				Uint32 temp;
-				if (pDecInfo->mirrorDirection & MIRDIR_VER) {
-					temp = info->rcDisplay.top;
-					info->rcDisplay.top =
-						info->decPicHeight -
-						info->rcDisplay.bottom;
-					info->rcDisplay.bottom =
-						info->decPicHeight - temp;
-				}
-				if (pDecInfo->mirrorDirection & MIRDIR_HOR) {
-					temp = info->rcDisplay.left;
-					info->rcDisplay.left =
-						info->decPicWidth -
-						info->rcDisplay.right;
-					info->rcDisplay.right =
-						info->decPicWidth - temp;
-				}
-			}
-
-			switch (pCodecInst->codecMode) {
-			default:
-				break;
-			}
-		}
-
-		if (info->indexFrameDisplay == info->indexFrameDecoded) {
-			info->dispPicWidth = info->decPicWidth;
-			info->dispPicHeight = info->decPicHeight;
-		} else {
-			info->dispPicWidth =
-				pDecInfo->decOutInfo[displayIndex].decPicWidth;
-			info->dispPicHeight =
-				pDecInfo->decOutInfo[displayIndex].decPicHeight;
-		}
-
-		if (pDecInfo->scalerEnable == TRUE) {
-			if ((pDecInfo->scaleWidth != 0) &&
-			    (pDecInfo->scaleHeight != 0)) {
-				info->dispPicWidth = pDecInfo->scaleWidth;
-				info->dispPicHeight = pDecInfo->scaleHeight;
-				info->rcDisplay.right = pDecInfo->scaleWidth;
-				info->rcDisplay.bottom = pDecInfo->scaleHeight;
-			}
-		}
-	} else {
-		info->rcDisplay.left = 0;
-		info->rcDisplay.right = 0;
-		info->rcDisplay.top = 0;
-		info->rcDisplay.bottom = 0;
-
-		if (pDecInfo->rotationEnable || pDecInfo->mirrorEnable ||
-		    pDecInfo->tiled2LinearEnable || pDecInfo->deringEnable) {
-			info->dispPicWidth = info->decPicWidth;
-			info->dispPicHeight = info->decPicHeight;
-		} else {
-			info->dispPicWidth = 0;
-			info->dispPicHeight = 0;
-		}
-	}
-
-	if ((pCodecInst->codecMode == VC1_DEC ||
-	     pCodecInst->codecMode == W_VC1_DEC) &&
-	    info->indexFrameDisplay != -3) {
-		if (pDecInfo->vc1BframeDisplayValid == 0) {
-			if (info->picType == 2)
-				info->indexFrameDisplay = -3;
-			else
-				pDecInfo->vc1BframeDisplayValid = 1;
-		}
-	}
-
-	pDecInfo->streamRdPtr = ProductVpuDecGetRdPtr(pCodecInst);
-	pDecInfo->frameDisplayFlag = VpuReadReg(
-		pCodecInst->coreIdx, pDecInfo->frameDisplayFlagRegAddr);
-	if (pCodecInst->codecMode == W_VP9_DEC) {
-		pDecInfo->frameDisplayFlag &= 0xFFFF;
-	}
-	pDecInfo->frameEndPos = pDecInfo->streamRdPtr;
-
-	if (pDecInfo->frameEndPos < pDecInfo->frameStartPos)
-		info->consumedByte = pDecInfo->frameEndPos +
-				     pDecInfo->streamBufSize -
-				     pDecInfo->frameStartPos;
-	else
-		info->consumedByte =
-			pDecInfo->frameEndPos - pDecInfo->frameStartPos;
-
-	if (pDecInfo->deringEnable || pDecInfo->mirrorEnable ||
-	    pDecInfo->rotationEnable || pDecInfo->tiled2LinearEnable) {
-		info->dispFrame = pDecInfo->rotatorOutput;
-		info->dispFrame.stride = pDecInfo->rotatorStride;
-	} else {
-		val = ((pDecInfo->openParam.wtlEnable == TRUE ||
-			pDecInfo->openParam.afbceEnable) ?
-			       pDecInfo->numFbsForDecoding :
-			       0); //fbOffset
-		maxDecIndex =
-			(pDecInfo->numFbsForDecoding > pDecInfo->numFbsForWTL) ?
-				pDecInfo->numFbsForDecoding :
-				pDecInfo->numFbsForWTL;
-
-		if (0 <= info->indexFrameDisplay &&
-		    info->indexFrameDisplay < (int)maxDecIndex)
-			info->dispFrame =
-				pDecInfo->frameBufPool[val +
-						       info->indexFrameDisplay];
-	}
-
-	info->rdPtr = pDecInfo->streamRdPtr;
-	info->wrPtr = pDecInfo->streamWrPtr;
-	info->frameDisplayFlag = pDecInfo->frameDisplayFlag;
-
-	info->sequenceNo = pDecInfo->initialInfo.sequenceNo;
-	if (decodedIndex >= 0 && decodedIndex < MAX_GDI_IDX) {
-		pDecInfo->decOutInfo[decodedIndex] = *info;
-	}
-
-	if (displayIndex >= 0 && displayIndex < MAX_GDI_IDX) {
-		info->numOfTotMBs = info->numOfTotMBs;
-		info->numOfErrMBs = info->numOfErrMBs;
-		info->numOfTotMBsInDisplay =
-			pDecInfo->decOutInfo[displayIndex].numOfTotMBs;
-		info->numOfErrMBsInDisplay =
-			pDecInfo->decOutInfo[displayIndex].numOfErrMBs;
-		info->dispFrame.sequenceNo = info->sequenceNo;
-	} else {
-		info->numOfTotMBsInDisplay = 0;
-		info->numOfErrMBsInDisplay = 0;
-	}
-
-	if (info->sequenceChanged != 0) {
-		if (!(pCodecInst->productId == PRODUCT_ID_960 ||
-		      pCodecInst->productId == PRODUCT_ID_980)) {
-			/* Update new sequence information */
-			osal_memcpy((void *)&pDecInfo->initialInfo,
-				    (void *)&pDecInfo->newSeqInfo,
-				    sizeof(DecInitialInfo));
-		}
-		if ((info->sequenceChanged & SEQ_CHANGE_INTER_RES_CHANGE) !=
-		    SEQ_CHANGE_INTER_RES_CHANGE) {
-			pDecInfo->initialInfo.sequenceNo++;
-		}
-	}
-
-	SetPendingInst(pCodecInst->coreIdx, 0);
-#ifdef VE1_CHECKSUM
-	if (info->indexFrameDisplay >= 0) {
-		FrameBuffer fbTmp =
-			pDecInfo->frameBufPool[info->indexFrameDisplay];
-		int fbSize =
-			VPU_GetFrameBufSize(pCodecInst->coreIdx, fbTmp.stride,
-					    fbTmp.height, fbTmp.mapType,
-					    fbTmp.format, fbTmp.cbcrInterleave,
-					    &pDecInfo->dramCfg);
-		MCP_SHA256_Hash(info->dispFrame.bufY, fbSize,
-				pDecInfo->hashTable.phys_addr);
-		Uint8 *result = (Uint8 *)pDecInfo->hashTable.virt_addr;
-		VLOG(TRACE,
-		     "addr 0x%x size %zu Cur Hash= %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x",
-		     info->dispFrame.bufY, fbSize, result[0], result[1],
-		     result[2], result[3], result[4], result[5], result[6],
-		     result[7], result[8], result[9], result[10], result[11],
-		     result[12], result[13], result[14], result[15], result[16],
-		     result[17], result[18], result[19], result[20], result[21],
-		     result[22], result[23], result[24], result[25], result[26],
-		     result[27], result[28], result[29], result[30],
-		     result[31]);
-#ifdef VE1_CHECKSUM_LOG_TO_TMP
-		memset(hash, 0, sizeof(hash));
-		sprintf(hash,
-			"%.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x "
-			"%.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x "
-			"%.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x "
-			"%.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x\n",
-			result[0], result[1], result[2], result[3], result[4],
-			result[5], result[6], result[7], result[8], result[9],
-			result[10], result[11], result[12], result[13],
-			result[14], result[15], result[16], result[17],
-			result[18], result[19], result[20], result[21],
-			result[22], result[23], result[24], result[25],
-			result[26], result[27], result[28], result[29],
-			result[30], result[31]);
-		VLOG(TRACE, "%s", hash);
-		//open
-		hash_out_file = fopen("/tmp/hash.log", "a+");
-		if (hash_out_file) {
-			//write
-			fputs(hash, hash_out_file);
-			//close
-			fclose(hash_out_file);
-		} else {
-			VLOG(TRACE, "open /tmp/hash.log failed");
-		}
-#endif
-	}
-#endif
-
-	LeaveLock(pCodecInst->coreIdx);
-
-	if (pCodecInst->coreIdx == 0) {
-		pDecInfo->outputinfoSN++;
-		if ((pDecInfo->openParam.bitstreamMode == BS_MODE_ROLLBACK) &&
-		    !(info->decodingSuccess & 0x10) &&
-		    (info->indexFrameDecoded >= 0 ||
-		     info->indexFrameDecoded == -2)) {
-			pDecInfo->decodedFrmNum++;
-		} else if (info->indexFrameDecoded >= 0 ||
-			   info->indexFrameDecoded == -2) {
-			pDecInfo->decodedFrmNum++;
-		}
-	}
-	VLOG(TRACE,
-	     "[%d]%s.h:0x%x.%d.%d.dec:%d.dis:%d.POC:%d(%d,%d).type:%d(%d).pos(0x%x 0x%x 0x%x).size:%d.suc:0x%x.err:%d.frmDisFlg:0x%x.warn:%d.nalRefIdc:%d.decFrameInfo:%d.sc:0x%x.sef:%d\n",
-	     __LINE__, __func__, handle, pDecInfo->outputinfoSN,
-	     pDecInfo->decodedFrmNum, info->indexFrameDecoded,
-	     info->indexFrameDisplay, info->avcPocPic, info->avcPocTop,
-	     info->avcPocBot, info->picType, info->picTypeFirst,
-	     info->bytePosFrameStart, info->bytePosFrameEnd, info->rdPtr,
-	     vpu_ring_valid_data(
-		     pDecInfo->streamBufStartAddr,
-		     pDecInfo->streamBufStartAddr + pDecInfo->streamBufSize,
-		     info->bytePosFrameStart, info->bytePosFrameEnd),
-	     info->decodingSuccess, info->numOfErrMBs, info->frameDisplayFlag,
-	     info->warnInfo, info->nalRefIdc, info->decFrameInfo,
-	     info->sequenceChanged, info->streamEndFlag);
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_DecFrameBufferFlush(DecHandle handle, DecOutputInfo *pRemainings,
-				Uint32 *retNum)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	DecOutputInfo *pOut;
-	RetCode ret;
-	FramebufferIndex retIndex[MAX_GDI_IDX];
-	Uint32 retRemainings = 0;
-	Int32 i, index, val;
-	VpuAttr *pAttr = NULL;
-
-	VLOG(TRACE, "[+] [%d]%s.h:0x%x\n", __LINE__, __func__, handle);
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS) {
-		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
-		     handle, ret);
-		return ret;
-	}
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-
-	EnterLock(pCodecInst->coreIdx);
-
-	if (GetPendingInst(pCodecInst->coreIdx)) {
-		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
-		{
-			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
-			     __func__, __LINE__);
-			msleep(50);
-			if (GetPendingInst(pCodecInst->coreIdx)) {
-				LeaveLock(pCodecInst->coreIdx);
-				VLOG(ERR,
-				     "[-] [%d]%s.h:0x%x.ret:RETCODE_FRAME_NOT_COMPLETE\n",
-				     __LINE__, __func__, handle);
-				return RETCODE_FRAME_NOT_COMPLETE;
-			}
-		} else {
-			LeaveLock(pCodecInst->coreIdx);
-			VLOG(ERR,
-			     "[-] [%d]%s.h:0x%x.ret:RETCODE_FRAME_NOT_COMPLETE\n",
-			     __LINE__, __func__, handle);
-			return RETCODE_FRAME_NOT_COMPLETE;
-		}
-	}
-
-	osal_memset((void *)retIndex, 0xff, sizeof(retIndex));
-
-	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
-	if (pAttr->supportCommandQueue == FALSE) {
-		EnterDispFlagLock(pCodecInst->coreIdx);
-		val = pDecInfo->frameDisplayFlag;
-		val |= pDecInfo->setDisplayIndexes;
-		val &= ~(Uint32)(pDecInfo->clearDisplayIndexes);
-		VpuWriteReg(pCodecInst->coreIdx,
-			    pDecInfo->frameDisplayFlagRegAddr, val);
-		pDecInfo->clearDisplayIndexes = 0;
-		pDecInfo->setDisplayIndexes = 0;
-		LeaveDispFlagLock(pCodecInst->coreIdx);
-	}
-
-	if ((ret = ProductVpuDecFlush(pCodecInst, retIndex, MAX_GDI_IDX)) !=
-	    RETCODE_SUCCESS) {
-		LeaveLock(pCodecInst->coreIdx);
-		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
-		     handle, ret);
-		return ret;
-	}
-
-	if (pRemainings != NULL) {
-		for (i = 0; i < MAX_GDI_IDX; i++) {
-			index = (pDecInfo->wtlEnable == TRUE) ?
-					retIndex[i].tiledIndex :
-					retIndex[i].linearIndex;
-			if (index < 0)
-				continue;
-			pRemainings[i] = pDecInfo->decOutInfo[index];
-			pOut = &pRemainings[i];
-			pOut->indexFrameDisplay = pOut->indexFrameDecoded;
-			pOut->indexFrameDisplayForTiled =
-				pOut->indexFrameDecodedForTiled;
-			if (pDecInfo->wtlEnable == TRUE)
-				pOut->dispFrame =
-					pDecInfo->frameBufPool
-						[pDecInfo->numFbsForDecoding +
-						 retIndex[i].linearIndex];
-			else
-				pOut->dispFrame = pDecInfo->frameBufPool[index];
-
-			pOut->dispFrame.sequenceNo = pOut->sequenceNo;
-			pOut->dispPicWidth = pOut->decPicWidth;
-			pOut->dispPicHeight = pOut->decPicHeight;
-
-			if (pDecInfo->rotationEnable) {
-				switch (pDecInfo->rotationAngle) {
-				case 90:
-					pOut->rcDisplay.left =
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.top;
-					pOut->rcDisplay.right =
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.bottom;
-					pOut->rcDisplay.top =
-						pOut->decPicWidth -
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.right;
-					pOut->rcDisplay.bottom =
-						pOut->decPicWidth -
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.left;
-					break;
-				case 270:
-					pOut->rcDisplay.left =
-						pOut->decPicHeight -
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.bottom;
-					pOut->rcDisplay.right =
-						pOut->decPicHeight -
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.top;
-					pOut->rcDisplay.top =
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.left;
-					pOut->rcDisplay.bottom =
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.right;
-					break;
-				case 180:
-					pOut->rcDisplay.left =
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.left;
-					pOut->rcDisplay.right =
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.right;
-					pOut->rcDisplay.top =
-						pOut->decPicHeight -
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.bottom;
-					pOut->rcDisplay.bottom =
-						pOut->decPicHeight -
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.top;
-					break;
-				default:
-					pOut->rcDisplay.left =
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.left;
-					pOut->rcDisplay.right =
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.right;
-					pOut->rcDisplay.top =
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.top;
-					pOut->rcDisplay.bottom =
-						pDecInfo->decOutInfo[index]
-							.rcDecoded.bottom;
-					break;
-				}
-			} else {
-				pOut->rcDisplay.left =
-					pDecInfo->decOutInfo[index]
-						.rcDecoded.left;
-				pOut->rcDisplay.right =
-					pDecInfo->decOutInfo[index]
-						.rcDecoded.right;
-				pOut->rcDisplay.top =
-					pDecInfo->decOutInfo[index]
-						.rcDecoded.top;
-				pOut->rcDisplay.bottom =
-					pDecInfo->decOutInfo[index]
-						.rcDecoded.bottom;
-			}
-			retRemainings++;
-		}
-	}
-
-	if (retNum)
-		*retNum = retRemainings;
-
-	if (pCodecInst->loggingEnable)
-		vdi_log(pCodecInst->coreIdx, DEC_BUF_FLUSH, 0);
-
-	LeaveLock(pCodecInst->coreIdx);
-
-	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__, handle,
-	     ret);
-	return ret;
-}
-
-RetCode VPU_DecSetRdPtr(DecHandle handle, PhysicalAddress addr, int updateWrPtr)
-{
-	CodecInst *pCodecInst;
-	CodecInst *pPendingInst;
-	DecInfo *pDecInfo;
-	RetCode ret;
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS) {
-		return ret;
-	}
-	pCodecInst = (CodecInst *)handle;
-	ret = ProductVpuDecCheckCapability(pCodecInst);
-	if (ret != RETCODE_SUCCESS) {
-		return ret;
-	}
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-	pPendingInst = GetPendingInst(pCodecInst->coreIdx);
-	if (pCodecInst == pPendingInst) {
-		VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamRdPtrRegAddr,
-			    addr);
-	} else {
-		EnterLock(pCodecInst->coreIdx);
-		VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamRdPtrRegAddr,
-			    addr);
-		LeaveLock(pCodecInst->coreIdx);
-	}
-
-	pDecInfo->streamRdPtr = addr;
-	pDecInfo->prevFrameEndPos = addr;
-	if (updateWrPtr == TRUE) {
-		pDecInfo->streamWrPtr = addr;
-	}
-	pDecInfo->rdPtrValidFlag = 1;
-	VLOG(TRACE, "[%d]%s.h:0x%x.addr:0x%x.updateWrPtr:%d\n", __LINE__,
-	     __func__, handle, addr, updateWrPtr);
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_EncSetWrPtr(EncHandle handle, PhysicalAddress addr, int updateRdPtr)
-{
-	CodecInst *pCodecInst;
-	CodecInst *pPendingInst;
-	EncInfo *pEncInfo;
-	RetCode ret;
-
-	ret = CheckEncInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-	pCodecInst = (CodecInst *)handle;
-
-	if (pCodecInst->productId == PRODUCT_ID_960 ||
-	    pCodecInst->productId == PRODUCT_ID_980) {
-		return RETCODE_NOT_SUPPORTED_FEATURE;
-	}
-
-	pEncInfo = &handle->CodecInfo->encInfo;
-	pPendingInst = GetPendingInst(pCodecInst->coreIdx);
-	if (pCodecInst == pPendingInst) {
-		VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamWrPtrRegAddr,
-			    addr);
-	} else {
-		EnterLock(pCodecInst->coreIdx);
-		VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamWrPtrRegAddr,
-			    addr);
-		LeaveLock(pCodecInst->coreIdx);
-	}
-	pEncInfo->streamWrPtr = addr;
-	if (updateRdPtr)
-		pEncInfo->streamRdPtr = addr;
-
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_DecClrDispFlag(DecHandle handle, int index)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	RetCode ret = RETCODE_SUCCESS;
-	Int32 endIndex;
-	VpuAttr *pAttr = NULL;
-	BOOL supportCommandQueue;
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
-
-	endIndex = (pDecInfo->openParam.wtlEnable == TRUE) ?
-			   pDecInfo->numFbsForWTL :
-			   pDecInfo->numFbsForDecoding;
-
-	if ((index < 0) || (index > (endIndex - 1))) {
-		return RETCODE_INVALID_PARAM;
-	}
-
-	supportCommandQueue = (pAttr->supportCommandQueue == TRUE);
-	if (supportCommandQueue == TRUE) {
-		EnterLock(pCodecInst->coreIdx);
-		LeaveLock(pCodecInst->coreIdx);
-	} else {
-		EnterDispFlagLock(pCodecInst->coreIdx);
-		pDecInfo->clearDisplayIndexes |= (1 << index);
-		LeaveDispFlagLock(pCodecInst->coreIdx);
-	}
-
-	VLOG(TRACE, "[%d]%s.h:0x%x.index:%d\n", __LINE__, __func__, handle,
-	     index);
-	return ret;
-}
-
-RetCode VPU_DecGiveCommand(DecHandle handle, CodecCommand cmd, void *param)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	RetCode ret;
-	DecOpenParam *pop = NULL;
-
-	VLOG(TRACE, "[%d]%s.h:0x%x.cmd:%d\n", __LINE__, __func__, handle, cmd);
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-	switch (cmd) {
-	case ENABLE_ROTATION: {
-		if (pDecInfo->rotatorStride == 0) {
-			return RETCODE_ROTATOR_STRIDE_NOT_SET;
-		}
-		pDecInfo->rotationEnable = 1;
-		break;
-	}
-
-	case DISABLE_ROTATION: {
-		pDecInfo->rotationEnable = 0;
-		break;
-	}
-
-	case ENABLE_MIRRORING: {
-		if (pDecInfo->rotatorStride == 0) {
-			return RETCODE_ROTATOR_STRIDE_NOT_SET;
-		}
-		pDecInfo->mirrorEnable = 1;
-		break;
-	}
-	case DISABLE_MIRRORING: {
-		pDecInfo->mirrorEnable = 0;
-		break;
-	}
-	case SET_MIRROR_DIRECTION: {
-		MirrorDirection mirDir;
-
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		mirDir = *(MirrorDirection *)param;
-		if (!(mirDir == MIRDIR_NONE) && !(mirDir == MIRDIR_HOR) &&
-		    !(mirDir == MIRDIR_VER) && !(mirDir == MIRDIR_HOR_VER)) {
-			return RETCODE_INVALID_PARAM;
-		}
-		pDecInfo->mirrorDirection = mirDir;
-
-		break;
-	}
-	case SET_ROTATION_ANGLE: {
-		int angle;
-
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		angle = *(int *)param;
-		if (angle != 0 && angle != 90 && angle != 180 && angle != 270) {
-			return RETCODE_INVALID_PARAM;
-		}
-		if (pDecInfo->rotatorStride != 0) {
-			if (angle == 90 || angle == 270) {
-				if (pDecInfo->initialInfo.picHeight >
-				    pDecInfo->rotatorStride) {
-					return RETCODE_INVALID_PARAM;
-				}
-			} else {
-				if (pDecInfo->initialInfo.picWidth >
-				    pDecInfo->rotatorStride) {
-					return RETCODE_INVALID_PARAM;
-				}
-			}
-		}
-
-		pDecInfo->rotationAngle = angle;
-		break;
-	}
-	case SET_ROTATOR_OUTPUT: {
-#ifdef ENABLE_CODA9_WRITE_PROTECT
-		PhysicalAddress start, end, ppuAddr;
-#endif
-		FrameBuffer *frame;
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		frame = (FrameBuffer *)param;
-
-		pDecInfo->rotatorOutput = *frame;
-		pDecInfo->rotatorOutputValid = 1;
-#ifdef ENABLE_CODA9_WRITE_PROTECT
-		start = pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-				.startAddress;
-		end = pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-			      .endAddress;
-		ppuAddr = GetXY2AXIAddr(&pDecInfo->mapCfg, 0, 0, 0,
-					pDecInfo->rotatorStride,
-					&pDecInfo->rotatorOutput);
-		start = (start < ppuAddr) ? start : ppuAddr;
-		ppuAddr += VPU_GetFrameBufSize(
-			pCodecInst->coreIdx, pDecInfo->rotatorStride,
-			pDecInfo->rotatorOutput.height,
-			pDecInfo->rotatorOutput.mapType, FORMAT_420,
-			pDecInfo->openParam.cbcrInterleave, &pDecInfo->dramCfg);
-		end = (end > ppuAddr) ? end : ppuAddr;
-
-		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-			.startAddress = start;
-		pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-			.endAddress = end;
-		VLOG(INFO,
-		     "[%d]%s.set decRegion[WPROT_DEC_FRAME](%d,%d,0x%08x,0x%08x)\n",
-		     __LINE__, __func__,
-		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-			     .enable,
-		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-			     .isSecondary,
-		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-			     .startAddress,
-		     pDecInfo->writeMemProtectCfg.decRegion[WPROT_DEC_FRAME]
-			     .endAddress);
-#endif
-		break;
-	}
-
-	case SET_ROTATOR_STRIDE: {
-		int stride;
-
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		stride = *(int *)param;
-		if (stride % 8 != 0 || stride == 0) {
-			return RETCODE_INVALID_STRIDE;
-		}
-
-		if (pDecInfo->rotationAngle == 90 ||
-		    pDecInfo->rotationAngle == 270) {
-			if (pDecInfo->initialInfo.picHeight > stride) {
-				return RETCODE_INVALID_STRIDE;
-			}
-		} else {
-			if (pDecInfo->initialInfo.picWidth > stride) {
-				return RETCODE_INVALID_STRIDE;
-			}
-		}
-
-		pDecInfo->rotatorStride = stride;
-		break;
-	}
-	case DEC_SET_SPS_RBSP: {
-		if (pCodecInst->codecMode != AVC_DEC &&
-		    pCodecInst->codecMode != W_AVC_DEC) {
-			return RETCODE_INVALID_COMMAND;
-		}
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		return SetParaSet(handle, 0, (DecParamSet *)param);
-	}
-
-	case DEC_SET_PPS_RBSP: {
-		if (pCodecInst->codecMode != AVC_DEC &&
-		    pCodecInst->codecMode != W_AVC_DEC) {
-			return RETCODE_INVALID_COMMAND;
-		}
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		return SetParaSet(handle, 1, (DecParamSet *)param);
-	}
-	case ENABLE_DERING: {
-		if (pDecInfo->rotatorStride == 0) {
-			return RETCODE_ROTATOR_STRIDE_NOT_SET;
-		}
-		pDecInfo->deringEnable = 1;
-		break;
-	}
-
-	case DISABLE_DERING: {
-		pDecInfo->deringEnable = 0;
-		break;
-	}
-	case SET_SEC_AXI: {
-		SecAxiUse secAxiUse;
-
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		secAxiUse = *(SecAxiUse *)param;
-
-		pDecInfo->secAxiInfo.u.coda9.useBitEnable =
-			secAxiUse.u.coda9.useBitEnable;
-		pDecInfo->secAxiInfo.u.coda9.useIpEnable =
-			secAxiUse.u.coda9.useIpEnable;
-		pDecInfo->secAxiInfo.u.coda9.useDbkYEnable =
-			secAxiUse.u.coda9.useDbkYEnable;
-		pDecInfo->secAxiInfo.u.coda9.useDbkCEnable =
-			secAxiUse.u.coda9.useDbkCEnable;
-		pDecInfo->secAxiInfo.u.coda9.useOvlEnable =
-			secAxiUse.u.coda9.useOvlEnable;
-		pDecInfo->secAxiInfo.u.coda9.useBtpEnable =
-			secAxiUse.u.coda9.useBtpEnable;
-
-		break;
-	}
-	case ENABLE_AFBCE: {
-		pDecInfo->enableAfbce = 1;
-		break;
-	}
-	case DISABLE_AFBCE: {
-		pDecInfo->enableAfbce = 0;
-		break;
-	}
-	case ENABLE_REP_USERDATA: {
-#ifdef ENABLE_CODA9_WRITE_PROTECT
-		WriteMemProtectCfg *pCgf = &pDecInfo->writeMemProtectCfg;
-#endif
-		if (!pDecInfo->userDataBufAddr) {
-			return RETCODE_USERDATA_BUF_NOT_SET;
-		}
-		if (pDecInfo->userDataBufSize == 0) {
-			return RETCODE_USERDATA_BUF_NOT_SET;
-		}
-		switch (pCodecInst->productId) {
-		case PRODUCT_ID_420L:
-			pDecInfo->userDataEnable = *(Uint32 *)param;
-			break;
-		case PRODUCT_ID_960:
-		case PRODUCT_ID_980:
-			pDecInfo->userDataEnable = TRUE;
-			break;
-		default:
-			VLOG(INFO,
-			     "%s(ENABLE_REP_DATA) invalid productId(%d)\n",
-			     __FUNCTION__, pCodecInst->productId);
-			return RETCODE_INVALID_PARAM;
-		}
-#ifdef ENABLE_CODA9_WRITE_PROTECT
-		pCgf->decRegion[WPROT_DEC_REPORT].enable = 1;
-		pCgf->decRegion[WPROT_DEC_REPORT].isSecondary = 0;
-		pCgf->decRegion[WPROT_DEC_REPORT].startAddress =
-			pDecInfo->userDataBufAddr;
-		pCgf->decRegion[WPROT_DEC_REPORT].endAddress =
-			pDecInfo->userDataBufAddr + pDecInfo->userDataBufSize;
-		VLOG(INFO,
-		     "[%d]%s.set decRegion[WPROT_DEC_REPORT](%d,%d,0x%08x,0x%08x)\n",
-		     __LINE__, __func__,
-		     pCgf->decRegion[WPROT_DEC_REPORT].enable,
-		     pCgf->decRegion[WPROT_DEC_REPORT].isSecondary,
-		     pCgf->decRegion[WPROT_DEC_REPORT].startAddress,
-		     pCgf->decRegion[WPROT_DEC_REPORT].endAddress);
-#endif
-		break;
-	}
-	case DISABLE_REP_USERDATA: {
-		pDecInfo->userDataEnable = 0;
-		break;
-	}
-	case SET_ADDR_REP_USERDATA: {
-		PhysicalAddress userDataBufAddr;
-
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		userDataBufAddr = *(PhysicalAddress *)param;
-		if (userDataBufAddr % 8 != 0 || userDataBufAddr == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		pDecInfo->userDataBufAddr = userDataBufAddr;
-		break;
-	}
-	case SET_VIRT_ADDR_REP_USERDATA: {
-		unsigned long userDataVirtAddr;
-
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		if (!pDecInfo->userDataBufAddr) {
-			return RETCODE_USERDATA_BUF_NOT_SET;
-		}
-		if (pDecInfo->userDataBufSize == 0) {
-			return RETCODE_USERDATA_BUF_NOT_SET;
-		}
-
-		userDataVirtAddr = *(unsigned long *)param;
-		if (!userDataVirtAddr) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		pDecInfo->vbUserData.phys_addr = pDecInfo->userDataBufAddr;
-		pDecInfo->vbUserData.size = pDecInfo->userDataBufSize;
-		pDecInfo->vbUserData.virt_addr =
-			(unsigned long)userDataVirtAddr;
-		if (vdi_attach_dma_memory(pCodecInst->coreIdx,
-					  &pDecInfo->vbUserData) != 0) {
-			return RETCODE_INSUFFICIENT_RESOURCE;
-		}
-		break;
-	}
-	case SET_SIZE_REP_USERDATA: {
-		PhysicalAddress userDataBufSize;
-
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		userDataBufSize = *(PhysicalAddress *)param;
-
-		pDecInfo->userDataBufSize = userDataBufSize;
-		break;
-	}
-
-	case SET_USERDATA_REPORT_MODE: {
-		int userDataMode;
-
-		userDataMode = *(int *)param;
-		if (userDataMode != 1 && userDataMode != 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		pDecInfo->userDataReportMode = userDataMode;
-		break;
-	}
-	case SET_CACHE_CONFIG: {
-		MaverickCacheConfig *mcCacheConfig;
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		mcCacheConfig = (MaverickCacheConfig *)param;
-		pDecInfo->cacheConfig = *mcCacheConfig;
-	} break;
-	case SET_LOW_DELAY_CONFIG: {
-		LowDelayInfo *lowDelayInfo;
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		if (pCodecInst->productId != PRODUCT_ID_980) {
-			return RETCODE_NOT_SUPPORTED_FEATURE;
-		}
-		lowDelayInfo = (LowDelayInfo *)param;
-
-		if (lowDelayInfo->lowDelayEn) {
-			if ((pCodecInst->codecMode != AVC_DEC &&
-			     pCodecInst->codecMode != W_AVC_DEC) ||
-			    pDecInfo->rotationEnable ||
-			    pDecInfo->mirrorEnable ||
-			    pDecInfo->tiled2LinearEnable ||
-			    pDecInfo->deringEnable) {
-				return RETCODE_INVALID_PARAM;
-			}
-		}
-
-		pDecInfo->lowDelayInfo.lowDelayEn = lowDelayInfo->lowDelayEn;
-		pDecInfo->lowDelayInfo.numRows = lowDelayInfo->numRows;
-	} break;
-
-	case SET_DECODE_FLUSH: // interrupt mode to pic_end
-		ret = ProductCpbFlush((CodecInst *)handle);
-		break;
-
-	case DEC_SET_FRAME_DELAY: {
-		pDecInfo->frameDelay = *(int *)param;
-		break;
-	}
-	case DEC_ENABLE_REORDER: {
-		if ((handle->productId == PRODUCT_ID_980) ||
-		    (handle->productId == PRODUCT_ID_960) ||
-		    (handle->productId == PRODUCT_ID_950)) {
-			if (pDecInfo->initialInfoObtained) {
-				return RETCODE_WRONG_CALL_SEQUENCE;
-			}
-		}
-
-		pDecInfo->reorderEnable = 1;
-		break;
-	}
-	case DEC_DISABLE_REORDER: {
-		if ((handle->productId == PRODUCT_ID_980) ||
-		    (handle->productId == PRODUCT_ID_960) ||
-		    (handle->productId == PRODUCT_ID_950)) {
-			if (pDecInfo->initialInfoObtained) {
-				return RETCODE_WRONG_CALL_SEQUENCE;
-			}
-
-			if (pCodecInst->codecMode != AVC_DEC &&
-			    pCodecInst->codecMode != VC1_DEC &&
-			    pCodecInst->codecMode != AVS_DEC &&
-			    pCodecInst->codecMode != W_AVC_DEC &&
-			    pCodecInst->codecMode != W_VC1_DEC &&
-			    pCodecInst->codecMode != W_AVS_DEC) {
-				return RETCODE_INVALID_COMMAND;
-			}
-		}
-
-		pDecInfo->reorderEnable = 0;
-		break;
-	}
-	case DEC_SET_AVC_ERROR_CONCEAL_MODE: {
-		if (pCodecInst->codecMode != AVC_DEC &&
-		    pCodecInst->codecMode != W_AVC_DEC) {
-			return RETCODE_INVALID_COMMAND;
-		}
-
-		pDecInfo->avcErrorConcealMode = *(int *)param;
-		break;
-	}
-	case DEC_FREE_FRAME_BUFFER: {
-		int i;
-		if (pDecInfo->vbSlice.size) {
-			VLOG(TRACE,
-			     "[%d]%s.vdi_free_dma_memory_no_mmap vbSlice(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, pDecInfo->vbSlice.phys_addr,
-			     pDecInfo->vbSlice.base,
-			     pDecInfo->vbSlice.virt_addr,
-			     pDecInfo->vbSlice.size,
-			     pDecInfo->vbSlice.req_spec_region);
-			vdi_free_dma_memory_no_mmap(pCodecInst->coreIdx,
-						    &pDecInfo->vbSlice);
-		}
-
-		if (pDecInfo->vbFrame.size) {
-			if (pDecInfo->frameAllocExt == 0) {
-				VLOG(TRACE,
-				     "[%d]%s.vdi_free_dma_memory vbFrame(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-				     __LINE__, __func__,
-				     pDecInfo->vbFrame.phys_addr,
-				     pDecInfo->vbFrame.base,
-				     pDecInfo->vbFrame.virt_addr,
-				     pDecInfo->vbFrame.size,
-				     pDecInfo->vbFrame.req_spec_region);
-				vdi_free_dma_memory(pCodecInst->coreIdx,
-						    &pDecInfo->vbFrame);
-			}
-		}
-		for (i = 0; i < MAX_REG_FRAME; i++) {
-			if (pDecInfo->vbFbcYTbl[i].size) {
-				if (pDecInfo->fbcTblAllocExt == 0) {
-					VLOG(TRACE,
-					     "[%d]%s.vdi_free_dma_memory vbFbcYTbl[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-					     __LINE__, __func__, i,
-					     pDecInfo->vbFbcYTbl[i].phys_addr,
-					     pDecInfo->vbFbcYTbl[i].base,
-					     pDecInfo->vbFbcYTbl[i].virt_addr,
-					     pDecInfo->vbFbcYTbl[i].size,
-					     pDecInfo->vbFbcYTbl[i]
-						     .req_spec_region);
-					vdi_free_dma_memory(
-						pCodecInst->coreIdx,
-						&pDecInfo->vbFbcYTbl[i]);
-				}
-			}
-
-			if (pDecInfo->vbFbcCTbl[i].size) {
-				if (pDecInfo->fbcTblAllocExt == 0) {
-					VLOG(TRACE,
-					     "[%d]%s.vdi_free_dma_memory vbFbcCTbl[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-					     __LINE__, __func__, i,
-					     pDecInfo->vbFbcCTbl[i].phys_addr,
-					     pDecInfo->vbFbcCTbl[i].base,
-					     pDecInfo->vbFbcCTbl[i].virt_addr,
-					     pDecInfo->vbFbcCTbl[i].size,
-					     pDecInfo->vbFbcCTbl[i]
-						     .req_spec_region);
-					vdi_free_dma_memory(
-						pCodecInst->coreIdx,
-						&pDecInfo->vbFbcCTbl[i]);
-				}
-			}
-
-#if !defined(DAH_222_PREALLOC_MV_SLICE_BUFFER)
-			if (pDecInfo->vbMV[i].size)
-				vdi_free_dma_memory_no_mmap(pCodecInst->coreIdx,
-							    &pDecInfo->vbMV[i]);
-#endif
-		}
-
-		if (pDecInfo->vbPPU.size) {
-			if (pDecInfo->ppuAllocExt == 0) {
-				VLOG(TRACE,
-				     "[%d]%s.vdi_free_dma_memory vbPPU(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-				     __LINE__, __func__,
-				     pDecInfo->vbPPU.phys_addr,
-				     pDecInfo->vbPPU.base,
-				     pDecInfo->vbPPU.virt_addr,
-				     pDecInfo->vbPPU.size,
-				     pDecInfo->vbPPU.req_spec_region);
-				vdi_free_dma_memory(pCodecInst->coreIdx,
-						    &pDecInfo->vbPPU);
-			}
-		}
-
-		if (pDecInfo->wtlEnable) {
-			if (pDecInfo->vbWTL.size) {
-				VLOG(TRACE,
-				     "[%d]%s.vdi_free_dma_memory vbWTL(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-				     __LINE__, __func__,
-				     pDecInfo->vbWTL.phys_addr,
-				     pDecInfo->vbWTL.base,
-				     pDecInfo->vbWTL.virt_addr,
-				     pDecInfo->vbWTL.size,
-				     pDecInfo->vbWTL.req_spec_region);
-				vdi_free_dma_memory(pCodecInst->coreIdx,
-						    &pDecInfo->vbWTL);
-			}
-		}
-		break;
-	}
-	case DEC_GET_FRAMEBUF_INFO: {
-		DecGetFramebufInfo *fbInfo = (DecGetFramebufInfo *)param;
-		Uint32 i;
-		fbInfo->vbFrame = pDecInfo->vbFrame;
-		fbInfo->vbWTL = pDecInfo->vbWTL;
-		for (i = 0; i < MAX_REG_FRAME; i++) {
-			fbInfo->vbFbcYTbl[i] = pDecInfo->vbFbcYTbl[i];
-			fbInfo->vbFbcCTbl[i] = pDecInfo->vbFbcCTbl[i];
-			fbInfo->vbMvCol[i] = pDecInfo->vbMV[i];
-		}
-
-		for (i = 0; i < MAX_GDI_IDX * 2; i++) {
-			fbInfo->framebufPool[i] = pDecInfo->frameBufPool[i];
-		}
-	} break;
-	case DEC_RESET_FRAMEBUF_INFO: {
-		int i;
-
-		pDecInfo->vbFrame.base = 0;
-		pDecInfo->vbFrame.phys_addr = 0;
-		pDecInfo->vbFrame.virt_addr = 0;
-		pDecInfo->vbFrame.size = 0;
-		pDecInfo->vbWTL.base = 0;
-		pDecInfo->vbWTL.phys_addr = 0;
-		pDecInfo->vbWTL.virt_addr = 0;
-		pDecInfo->vbWTL.size = 0;
-		for (i = 0; i < MAX_REG_FRAME; i++) {
-			pDecInfo->vbFbcYTbl[i].base = 0;
-			pDecInfo->vbFbcYTbl[i].phys_addr = 0;
-			pDecInfo->vbFbcYTbl[i].virt_addr = 0;
-			pDecInfo->vbFbcYTbl[i].size = 0;
-			pDecInfo->vbFbcCTbl[i].base = 0;
-			pDecInfo->vbFbcCTbl[i].phys_addr = 0;
-			pDecInfo->vbFbcCTbl[i].virt_addr = 0;
-			pDecInfo->vbFbcCTbl[i].size = 0;
-			pDecInfo->vbMV[i].base = 0;
-			pDecInfo->vbMV[i].phys_addr = 0;
-			pDecInfo->vbMV[i].virt_addr = 0;
-			pDecInfo->vbMV[i].size = 0;
-		}
-
-		pDecInfo->frameDisplayFlag = 0;
-		pDecInfo->setDisplayIndexes = 0;
-		pDecInfo->clearDisplayIndexes = 0;
-		break;
-	}
-	case DEC_GET_QUEUE_STATUS: {
-		DecQueueStatusInfo *queueInfo = (DecQueueStatusInfo *)param;
-		queueInfo->instanceQueueCount = pDecInfo->instanceQueueCount;
-		queueInfo->totalQueueCount = pDecInfo->totalQueueCount;
-		break;
-	}
-
-	case ENABLE_DEC_THUMBNAIL_MODE: {
-		pDecInfo->thumbnailMode = 1;
-		break;
-	}
-	case DEC_GET_SEQ_INFO: {
-		DecInitialInfo *seqInfo = (DecInitialInfo *)param;
-		*seqInfo = pDecInfo->initialInfo;
-		break;
-	}
-	case DEC_SET_SEQ_INFO: {
-		DecInitialInfo *seqInfo = (DecInitialInfo *)param;
-		pDecInfo->initialInfo = *seqInfo;
-		break;
-	}
-	case DEC_GET_FIELD_PIC_TYPE: {
-		return RETCODE_FAILURE;
-	}
-	case DEC_GET_DISPLAY_OUTPUT_INFO: {
-		DecOutputInfo *pDecOutInfo = (DecOutputInfo *)param;
-		*pDecOutInfo =
-			pDecInfo->decOutInfo[pDecOutInfo->indexFrameDisplay];
-		break;
-	}
-	case GET_TILEDMAP_CONFIG: {
-		TiledMapConfig *pMapCfg = (TiledMapConfig *)param;
-		if (!pMapCfg) {
-			return RETCODE_INVALID_PARAM;
-		}
-		if (!pDecInfo->stride) {
-			return RETCODE_WRONG_CALL_SEQUENCE;
-		}
-		*pMapCfg = pDecInfo->mapCfg;
-		break;
-	}
-	case SET_DRAM_CONFIG: {
-		DRAMConfig *cfg = (DRAMConfig *)param;
-
-		if (!cfg) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		pDecInfo->dramCfg = *cfg;
-		break;
-	}
-	case GET_DRAM_CONFIG: {
-		DRAMConfig *cfg = (DRAMConfig *)param;
-
-		if (!cfg) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		*cfg = pDecInfo->dramCfg;
-
-		break;
-	}
-	case GET_LOW_DELAY_OUTPUT: {
-		DecOutputInfo *lowDelayOutput;
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		if (!pDecInfo->lowDelayInfo.lowDelayEn ||
-		    pCodecInst->codecMode != AVC_DEC) {
-			return RETCODE_INVALID_COMMAND;
-		}
-
-		if (pCodecInst != GetPendingInst(pCodecInst->coreIdx)) {
-			return RETCODE_WRONG_CALL_SEQUENCE;
-		}
-
-		lowDelayOutput = (DecOutputInfo *)param;
-
-		GetLowDelayOutput(pCodecInst, lowDelayOutput);
-	} break;
-	case ENABLE_LOGGING: {
-		pCodecInst->loggingEnable = 1;
-	} break;
-	case DISABLE_LOGGING: {
-		pCodecInst->loggingEnable = 0;
-	} break;
-	case DEC_SET_SEQ_CHANGE_MASK:
-		if (PRODUCT_ID_NOT_W_SERIES(pCodecInst->productId))
-			return RETCODE_INVALID_PARAM;
-		pDecInfo->seqChangeMask = *(int *)param;
-		break;
-	case DEC_SET_WTL_FRAME_FORMAT:
-		pDecInfo->wtlFormat = *(FrameBufferFormat *)param;
-		break;
-	case DEC_SET_DISPLAY_FLAG: {
-		Int32 index;
-		VpuAttr *pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
-		BOOL supportCommandQueue = FALSE;
-
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		index = *(Int32 *)param;
-
-		supportCommandQueue = (pAttr->supportCommandQueue == TRUE);
-		if (supportCommandQueue == TRUE) {
-			EnterLock(pCodecInst->coreIdx);
-			LeaveLock(pCodecInst->coreIdx);
-		} else {
-			EnterDispFlagLock(pCodecInst->coreIdx);
-			pDecInfo->setDisplayIndexes |= (1 << index);
-			LeaveDispFlagLock(pCodecInst->coreIdx);
-		}
-
-	} break;
-	case DEC_GET_SCALER_INFO: {
-		ScalerInfo *scalerInfo = (ScalerInfo *)param;
-		if (scalerInfo == NULL) {
-			return RETCODE_INVALID_PARAM;
-		}
-		scalerInfo->enScaler = pDecInfo->scalerEnable;
-		scalerInfo->scaleWidth = pDecInfo->scaleWidth;
-		scalerInfo->scaleHeight = pDecInfo->scaleHeight;
-	} break;
-	case DEC_SET_SCALER_INFO: {
-		ScalerInfo *scalerInfo = (ScalerInfo *)param;
-
-		if (!pDecInfo->initialInfoObtained) {
-			return RETCODE_WRONG_CALL_SEQUENCE;
-		}
-
-		if (scalerInfo == NULL) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		pDecInfo->scalerEnable = scalerInfo->enScaler;
-		if (scalerInfo->enScaler == TRUE) {
-			// minW = Ceil8(picWidth/8), minH = Ceil8(picHeight/8)
-			Uint32 minScaleWidth =
-				VPU_ALIGN8(pDecInfo->initialInfo.picWidth >> 3);
-			Uint32 minScaleHeight = VPU_ALIGN8(
-				pDecInfo->initialInfo.picHeight >> 3);
-
-			if (minScaleWidth == 0)
-				minScaleWidth = 8;
-			if (minScaleHeight == 0)
-				minScaleHeight = 8;
-
-			if (scalerInfo->scaleWidth < minScaleWidth ||
-			    scalerInfo->scaleHeight < minScaleHeight) {
-				return RETCODE_INVALID_PARAM;
-			}
-
-			if (scalerInfo->scaleWidth > 0 ||
-			    scalerInfo->scaleHeight > 0) {
-				if ((scalerInfo->scaleWidth % 8) ||
-				    scalerInfo->scaleWidth >
-					    (Uint32)(VPU_ALIGN8(
-						    pDecInfo->initialInfo
-							    .picWidth))) {
-					return RETCODE_INVALID_PARAM;
-				}
-
-				if ((scalerInfo->scaleHeight % 8) ||
-				    scalerInfo->scaleHeight >
-					    (Uint32)(VPU_ALIGN8(
-						    pDecInfo->initialInfo
-							    .picHeight))) {
-					return RETCODE_INVALID_PARAM;
-				}
-				pDecInfo->scaleWidth = scalerInfo->scaleWidth;
-				pDecInfo->scaleHeight = scalerInfo->scaleHeight;
-				pDecInfo->scalerEnable = scalerInfo->enScaler;
-			}
-		}
-		break;
-	}
-	case DEC_SET_TARGET_TEMPORAL_ID:
-		if (param == NULL) {
-			return RETCODE_INVALID_PARAM;
-		}
-		if (pCodecInst->codecMode != HEVC_DEC) {
-			return RETCODE_NOT_SUPPORTED_FEATURE;
-		}
-		break;
-	case DEC_SET_BWB_CUR_FRAME_IDX:
-		pDecInfo->chBwbFrameIdx = *(Uint32 *)param;
-		break;
-	case DEC_SET_FBC_CUR_FRAME_IDX:
-		pDecInfo->chFbcFrameIdx = *(Uint32 *)param;
-		break;
-	case DEC_SET_INTER_RES_INFO_ON:
-		pDecInfo->interResChange = 1;
-		break;
-	case DEC_SET_INTER_RES_INFO_OFF:
-		pDecInfo->interResChange = 0;
-		break;
-	case DEC_FREE_FBC_TABLE_BUFFER: {
-		Uint32 fbcCurFrameIdx = *(Uint32 *)param;
-		if (pDecInfo->vbFbcYTbl[fbcCurFrameIdx].size > 0) {
-			VLOG(TRACE,
-			     "[%d]%s.vdi_free_dma_memory vbFbcYTbl[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, fbcCurFrameIdx,
-			     pDecInfo->vbFbcYTbl[fbcCurFrameIdx].phys_addr,
-			     pDecInfo->vbFbcYTbl[fbcCurFrameIdx].base,
-			     pDecInfo->vbFbcYTbl[fbcCurFrameIdx].virt_addr,
-			     pDecInfo->vbFbcYTbl[fbcCurFrameIdx].size,
-			     pDecInfo->vbFbcYTbl[fbcCurFrameIdx]
-				     .req_spec_region);
-			vdi_free_dma_memory(
-				pCodecInst->coreIdx,
-				&pDecInfo->vbFbcYTbl[fbcCurFrameIdx]);
-			pDecInfo->vbFbcYTbl[fbcCurFrameIdx].size = 0;
-		}
-		if (pDecInfo->vbFbcCTbl[fbcCurFrameIdx].size > 0) {
-			VLOG(TRACE,
-			     "[%d]%s.vdi_free_dma_memory vbFbcCTbl[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, fbcCurFrameIdx,
-			     pDecInfo->vbFbcCTbl[fbcCurFrameIdx].phys_addr,
-			     pDecInfo->vbFbcCTbl[fbcCurFrameIdx].base,
-			     pDecInfo->vbFbcCTbl[fbcCurFrameIdx].virt_addr,
-			     pDecInfo->vbFbcCTbl[fbcCurFrameIdx].size,
-			     pDecInfo->vbFbcCTbl[fbcCurFrameIdx]
-				     .req_spec_region);
-			vdi_free_dma_memory(
-				pCodecInst->coreIdx,
-				&pDecInfo->vbFbcCTbl[fbcCurFrameIdx]);
-			pDecInfo->vbFbcCTbl[fbcCurFrameIdx].size = 0;
-		}
-	} break;
-	case DEC_FREE_MV_BUFFER: {
-		Uint32 fbcCurFrameIdx = *(Uint32 *)param;
-		if (pDecInfo->vbMV[fbcCurFrameIdx].size > 0) {
-			VLOG(TRACE,
-			     "[%d]%s.vdi_free_dma_memory_no_mmap vbMV[%d](0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, fbcCurFrameIdx,
-			     pDecInfo->vbMV[fbcCurFrameIdx].phys_addr,
-			     pDecInfo->vbMV[fbcCurFrameIdx].base,
-			     pDecInfo->vbMV[fbcCurFrameIdx].virt_addr,
-			     pDecInfo->vbMV[fbcCurFrameIdx].size,
-			     pDecInfo->vbMV[fbcCurFrameIdx].req_spec_region);
-			vdi_free_dma_memory_no_mmap(
-				pCodecInst->coreIdx,
-				&pDecInfo->vbMV[fbcCurFrameIdx]);
-			pDecInfo->vbMV[fbcCurFrameIdx].size = 0;
-		}
-	} break;
-	case DEC_SET_YTBL_ADDR:
-	case DEC_SET_CTBL_ADDR:
-		if (param == NULL) {
-			return RETCODE_INVALID_PARAM;
-		}
-		if (pCodecInst->codecMode != HEVC_DEC &&
-		    pCodecInst->codecMode != W_VP9_DEC) {
-			return RETCODE_NOT_SUPPORTED_FEATURE;
-		} else {
-			int i = 0;
-			vpu_buffer_t *vb = (vpu_buffer_t *)param;
-			pDecInfo->fbcTblAllocExt = 1;
-			for (i = 0; i < MAX_GDI_IDX; i++) {
-				if (cmd == DEC_SET_YTBL_ADDR)
-					osal_memcpy((void *)&pDecInfo
-							    ->extVbFbcYTbls[i],
-						    &vb[i],
-						    sizeof(vpu_buffer_t));
-				else
-					osal_memcpy((void *)&pDecInfo
-							    ->extVbFbcCTbls[i],
-						    &vb[i],
-						    sizeof(vpu_buffer_t));
-			}
-		}
-		break;
-	case DEC_SET_WTL_MODE: {
-		if (param == NULL) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		pop = (DecOpenParam *)param;
-
-		pDecInfo->openParam.wtlEnable = pop->wtlEnable;
-		pDecInfo->openParam.wtlMode = pop->wtlMode;
-		pDecInfo->wtlEnable = pop->wtlEnable;
-		pDecInfo->wtlMode = pop->wtlMode;
-		if (!pDecInfo->wtlEnable)
-			pDecInfo->wtlMode = 0;
-	} break;
-	case DEC_SET_T2L_MODE: {
-		if (param == NULL) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		pop = (DecOpenParam *)param;
-
-		pDecInfo->openParam.tiled2LinearEnable =
-			pop->tiled2LinearEnable;
-		pDecInfo->openParam.tiled2LinearMode = pop->tiled2LinearMode;
-		pDecInfo->tiled2LinearEnable = pop->tiled2LinearEnable;
-		pDecInfo->tiled2LinearMode = pop->tiled2LinearMode;
-	} break;
-#ifdef SUPPORT_GET_NAL_START_POS
-	case DEC_GET_NAL_START_POS: {
-		PhysicalAddress *pos = (PhysicalAddress *)param;
-
-		*pos = pDecInfo->nalStartPtr;
-	} break;
-#endif
-
-	default:
-		return RETCODE_INVALID_COMMAND;
-	}
-
-	return ret;
-}
-
-RetCode VPU_DecAllocateFrameBuffer(DecHandle handle, FrameBufferAllocInfo info,
-				   FrameBuffer *frameBuffer)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	RetCode ret;
-	Uint32 gdiIndex;
-	int i;
-
-	VLOG(TRACE, "[+] [%d]%s.h:0x%x.mapType:%d.%d.%d.%d\n", __LINE__,
-	     __func__, handle, info.mapType, info.cbcrInterleave, info.nv21,
-	     info.format);
-	VLOG(TRACE, "[+] [%d]%s.h:0x%x.stride:%d.%d.%d.%d.%d\n", __LINE__,
-	     __func__, handle, info.stride, info.height, info.size,
-	     info.lumaBitDepth, info.chromaBitDepth);
-	VLOG(TRACE, "[+] [%d]%s.h:0x%x.endian:%d.%d.%d\n", __LINE__, __func__,
-	     handle, info.endian, info.num, info.type);
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS) {
-		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__,
-		     handle, ret);
-		return ret;
-	}
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-
-	if (!frameBuffer) {
-		VLOG(ERR, "[-] [%d]%s.h:0x%x.ret:RETCODE_INVALID_PARAM\n",
-		     __LINE__, __func__, handle);
-		return RETCODE_INVALID_PARAM;
-	}
-
-	if (info.num) {
-		for (i = 0; i < info.num; i++) {
-			VLOG(TRACE,
-			     "[%d]%s.h:0x%x.size:%d.bufY:0x%x.0x%x.0x%x.updateFbInfo:%d\n",
-			     __LINE__, __func__, handle, frameBuffer[i].size,
-			     frameBuffer[i].bufY, frameBuffer[i].bufCb,
-			     frameBuffer[i].bufCr, frameBuffer[i].updateFbInfo);
-		}
-	}
-
-	if (info.type == FB_TYPE_PPU) {
-		if (pDecInfo->numFrameBuffers == 0)
-			return RETCODE_WRONG_CALL_SEQUENCE;
-		if (frameBuffer[0].updateFbInfo == TRUE) {
-			pDecInfo->ppuAllocExt = TRUE;
-		}
-		pDecInfo->ppuAllocExt = frameBuffer[0].updateFbInfo;
-		gdiIndex = pDecInfo->numFbsForDecoding;
-		ret = ProductVpuAllocateFramebuffer(
-			pCodecInst, frameBuffer, (TiledMapType)info.mapType,
-			(Int32)info.num, info.stride, info.height, info.format,
-			info.cbcrInterleave, info.nv21, info.endian,
-			&pDecInfo->vbPPU, gdiIndex, FB_TYPE_PPU);
-	} else if (info.type == FB_TYPE_CODEC) {
-		gdiIndex = 0;
-		if (frameBuffer[0].updateFbInfo == TRUE) {
-			pDecInfo->frameAllocExt = TRUE;
-		}
-		ret = ProductVpuAllocateFramebuffer(
-			pCodecInst, frameBuffer, (TiledMapType)info.mapType,
-			(Int32)info.num, info.stride, info.height, info.format,
-			info.cbcrInterleave, info.nv21, info.endian,
-			&pDecInfo->vbFrame, gdiIndex,
-			(FramebufferAllocType)info.type);
-
-		pDecInfo->mapCfg.tiledBaseAddr = pDecInfo->vbFrame.phys_addr;
-	}
-
-	VLOG(TRACE, "[-] [%d]%s.h:0x%x.ret:%d\n", __LINE__, __func__, handle,
-	     ret);
-	return ret;
-}
-
-RetCode VPU_EncOpen(EncHandle *pHandle, EncOpenParam *pop)
-{
-	CodecInst *pCodecInst;
-	EncInfo *pEncInfo;
-	RetCode ret;
-
-	if ((ret = ProductCheckEncOpenParam(pop)) != RETCODE_SUCCESS)
-		return ret;
-
-	EnterLock(pop->coreIdx);
-
-	if (VPU_IsInit(pop->coreIdx) == 0) {
-		LeaveLock(pop->coreIdx);
-		return RETCODE_NOT_INITIALIZED;
-	}
-	ret = GetCodecInstance(pop->coreIdx, &pCodecInst, pop->filp);
-	if (ret == RETCODE_FAILURE) {
-		*pHandle = 0;
-		LeaveLock(pop->coreIdx);
-		return RETCODE_FAILURE;
-	}
-
-	pCodecInst->isDecoder = FALSE;
-	*pHandle = pCodecInst;
-	pEncInfo = &pCodecInst->CodecInfo->encInfo;
-
-	osal_memset(pEncInfo, 0x00, sizeof(EncInfo));
-	pEncInfo->openParam = *pop;
-
-	SetClockGate(pop->coreIdx, TRUE);
-	if ((ret = ProductVpuEncBuildUpOpenParam(pCodecInst, pop)) !=
-	    RETCODE_SUCCESS) {
-		*pHandle = 0;
-	}
-	SetClockGate(pop->coreIdx, FALSE);
-
-	LeaveLock(pCodecInst->coreIdx);
-
-	return ret;
-}
-
-RetCode VPU_EncClose(EncHandle handle)
-{
-	CodecInst *pCodecInst;
-	EncInfo *pEncInfo;
-	RetCode ret;
-
-	ret = CheckEncInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	pCodecInst = handle;
-	pEncInfo = &pCodecInst->CodecInfo->encInfo;
-
-	EnterLock(pCodecInst->coreIdx);
-
-	if (pEncInfo->initialInfoObtained) {
-		VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamWrPtrRegAddr,
-			    pEncInfo->streamWrPtr);
-		VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamRdPtrRegAddr,
-			    pEncInfo->streamRdPtr);
-
-		if ((ret = ProductVpuEncFiniSeq(pCodecInst)) !=
-		    RETCODE_SUCCESS) {
-			if (pCodecInst->loggingEnable)
-				vdi_log(pCodecInst->coreIdx, ENC_SEQ_END, 0);
-
-			if (ret == RETCODE_VPU_STILL_RUNNING) {
-				LeaveLock(pCodecInst->coreIdx);
-				return ret;
-			}
-		}
-		if (pCodecInst->loggingEnable)
-			vdi_log(pCodecInst->coreIdx, ENC_SEQ_END, 0);
-		pEncInfo->streamWrPtr = VpuReadReg(
-			pCodecInst->coreIdx, pEncInfo->streamWrPtrRegAddr);
-	}
-
-	if (pEncInfo->vbScratch.size) {
-		VLOG(TRACE,
-		     "[%d]%s.vdi_free_dma_memory vbScratch(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-		     __LINE__, __func__, pEncInfo->vbScratch.phys_addr,
-		     pEncInfo->vbScratch.base, pEncInfo->vbScratch.virt_addr,
-		     pEncInfo->vbScratch.size,
-		     pEncInfo->vbScratch.req_spec_region);
-		vdi_free_dma_memory(pCodecInst->coreIdx, &pEncInfo->vbScratch);
-	}
-
-	if (pEncInfo->vbWork.size) {
-		VLOG(TRACE,
-		     "[%d]%s.vdi_free_dma_memory vbWork(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-		     __LINE__, __func__, pEncInfo->vbWork.phys_addr,
-		     pEncInfo->vbWork.base, pEncInfo->vbWork.virt_addr,
-		     pEncInfo->vbWork.size, pEncInfo->vbWork.req_spec_region);
-		vdi_free_dma_memory(pCodecInst->coreIdx, &pEncInfo->vbWork);
-	}
-
-	if (pEncInfo->vbFrame.size) {
-		if (pEncInfo->frameAllocExt == 0) {
-			VLOG(TRACE,
-			     "[%d]%s.vdi_free_dma_memory vbFrame(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, pEncInfo->vbFrame.phys_addr,
-			     pEncInfo->vbFrame.base,
-			     pEncInfo->vbFrame.virt_addr,
-			     pEncInfo->vbFrame.size,
-			     pEncInfo->vbFrame.req_spec_region);
-			vdi_free_dma_memory(pCodecInst->coreIdx,
-					    &pEncInfo->vbFrame);
-		}
-	}
-
-	if (pCodecInst->codecMode == W_AVC_ENC) {
-		if (pEncInfo->vbFbcYTbl.size) {
-			VLOG(TRACE,
-			     "[%d]%s.vdi_free_dma_memory vbFbcYTbl(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, pEncInfo->vbFbcYTbl.phys_addr,
-			     pEncInfo->vbFbcYTbl.base,
-			     pEncInfo->vbFbcYTbl.virt_addr,
-			     pEncInfo->vbFbcYTbl.size,
-			     pEncInfo->vbFbcYTbl.req_spec_region);
-			vdi_free_dma_memory(pCodecInst->coreIdx,
-					    &pEncInfo->vbFbcYTbl);
-		}
-
-		if (pEncInfo->vbFbcCTbl.size) {
-			VLOG(TRACE,
-			     "[%d]%s.vdi_free_dma_memory vbFbcCTbl(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, pEncInfo->vbFbcCTbl.phys_addr,
-			     pEncInfo->vbFbcCTbl.base,
-			     pEncInfo->vbFbcCTbl.virt_addr,
-			     pEncInfo->vbFbcCTbl.size,
-			     pEncInfo->vbFbcCTbl.req_spec_region);
-			vdi_free_dma_memory(pCodecInst->coreIdx,
-					    &pEncInfo->vbFbcCTbl);
-		}
-	}
-
-	if (pEncInfo->vbPPU.size) {
-		if (pEncInfo->ppuAllocExt == 0) {
-			VLOG(TRACE,
-			     "[%d]%s.vdi_free_dma_memory vbPPU(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-			     __LINE__, __func__, pEncInfo->vbPPU.phys_addr,
-			     pEncInfo->vbPPU.base, pEncInfo->vbPPU.virt_addr,
-			     pEncInfo->vbPPU.size,
-			     pEncInfo->vbPPU.req_spec_region);
-			vdi_free_dma_memory(pCodecInst->coreIdx,
-					    &pEncInfo->vbPPU);
-		}
-	}
-	if (pEncInfo->vbSubSampFrame.size) {
-		VLOG(TRACE,
-		     "[%d]%s.vdi_free_dma_memory vbSubSampFrame(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-		     __LINE__, __func__, pEncInfo->vbSubSampFrame.phys_addr,
-		     pEncInfo->vbSubSampFrame.base,
-		     pEncInfo->vbSubSampFrame.virt_addr,
-		     pEncInfo->vbSubSampFrame.size,
-		     pEncInfo->vbSubSampFrame.req_spec_region);
-		vdi_free_dma_memory(pCodecInst->coreIdx,
-				    &pEncInfo->vbSubSampFrame);
-	}
-	if (pEncInfo->vbMvcSubSampFrame.size) {
-		VLOG(TRACE,
-		     "[%d]%s.vdi_free_dma_memory vbMvcSubSampFrame(0x%08lx,0x%08lx,0x%08lx,%d,%d)\n",
-		     __LINE__, __func__, pEncInfo->vbMvcSubSampFrame.phys_addr,
-		     pEncInfo->vbMvcSubSampFrame.base,
-		     pEncInfo->vbMvcSubSampFrame.virt_addr,
-		     pEncInfo->vbMvcSubSampFrame.size,
-		     pEncInfo->vbMvcSubSampFrame.req_spec_region);
-		vdi_free_dma_memory(pCodecInst->coreIdx,
-				    &pEncInfo->vbMvcSubSampFrame);
-	}
-
-	LeaveLock(pCodecInst->coreIdx);
-
-	FreeCodecInstance(pCodecInst);
-
-	return ret;
-}
-
-RetCode VPU_EncGetInitialInfo(EncHandle handle, EncInitialInfo *info)
-{
-	CodecInst *pCodecInst;
-	EncInfo *pEncInfo;
-	RetCode ret;
-
-	ret = CheckEncInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	if (info == 0) {
-		return RETCODE_INVALID_PARAM;
-	}
-
-	pCodecInst = handle;
-	pEncInfo = &pCodecInst->CodecInfo->encInfo;
-
-	EnterLock(pCodecInst->coreIdx);
-
-	if (GetPendingInst(pCodecInst->coreIdx)) {
-		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
-		{
-			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
-			     __func__, __LINE__);
-			msleep(50);
-			if (GetPendingInst(pCodecInst->coreIdx)) {
-				LeaveLock(pCodecInst->coreIdx);
-				return RETCODE_FRAME_NOT_COMPLETE;
-			}
-		} else {
-			LeaveLock(pCodecInst->coreIdx);
-			return RETCODE_FRAME_NOT_COMPLETE;
-		}
-	}
-
-	if ((ret = ProductVpuEncSetup(pCodecInst)) != RETCODE_SUCCESS) {
-		LeaveLock(pCodecInst->coreIdx);
-		return ret;
-	}
-
-	if (pCodecInst->codecMode == AVC_ENC &&
-	    pCodecInst->codecModeAux == AVC_AUX_MVC)
-		info->minFrameBufferCount =
-			3; // reconstructed frame + 2 reference frame
-	else if (pCodecInst->codecMode == W_AVC_ENC &&
-		 pCodecInst->codecModeAux == AVC_AUX_MVC)
-		info->minFrameBufferCount =
-			3; // reconstructed frame + 2 reference frame
-	else
-		info->minFrameBufferCount =
-			2; // reconstructed frame + reference frame
-
-	pEncInfo->initialInfo = *info;
-	pEncInfo->initialInfoObtained = TRUE;
-
-	LeaveLock(pCodecInst->coreIdx);
-
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_EncRegisterFrameBuffer(EncHandle handle, FrameBuffer *bufArray,
-				   int num, int stride, int height, int mapType)
-{
-	CodecInst *pCodecInst;
-	EncInfo *pEncInfo;
-	Int32 i;
-	RetCode ret;
-	EncOpenParam *openParam;
-	FrameBuffer *fb;
-
-	ret = CheckEncInstanceValidity(handle);
-	// FIXME temp
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	pCodecInst = handle;
-	pEncInfo = &pCodecInst->CodecInfo->encInfo;
-	openParam = &pEncInfo->openParam;
-
-	if (pEncInfo->stride)
-		return RETCODE_CALLED_BEFORE;
-
-	if (!pEncInfo->initialInfoObtained)
-		return RETCODE_WRONG_CALL_SEQUENCE;
-
-	if (num < pEncInfo->initialInfo.minFrameBufferCount)
-		return RETCODE_INSUFFICIENT_FRAME_BUFFERS;
-
-	if (stride == 0 || (stride % 8 != 0) || stride < 0)
-		return RETCODE_INVALID_STRIDE;
-
-	if (height == 0 || height < 0)
-		return RETCODE_INVALID_PARAM;
-
-	EnterLock(pCodecInst->coreIdx);
-
-	if (GetPendingInst(pCodecInst->coreIdx)) {
-		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
-		{
-			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
-			     __func__, __LINE__);
-			msleep(50);
-			if (GetPendingInst(pCodecInst->coreIdx)) {
-				LeaveLock(pCodecInst->coreIdx);
-				return RETCODE_FRAME_NOT_COMPLETE;
-			}
-		} else {
-			LeaveLock(pCodecInst->coreIdx);
-			return RETCODE_FRAME_NOT_COMPLETE;
-		}
-	}
-
-	pEncInfo->numFrameBuffers = num;
-	pEncInfo->stride = stride;
-	pEncInfo->frameBufferHeight = height;
-	pEncInfo->mapType = mapType;
-	pEncInfo->mapCfg.productId = pCodecInst->productId;
-
-	if (bufArray) {
-		for (i = 0; i < num; i++)
-			pEncInfo->frameBufPool[i] = bufArray[i];
-	}
-
-	if (pEncInfo->frameAllocExt == FALSE) {
-		fb = pEncInfo->frameBufPool;
-		if (bufArray) {
-			if (bufArray[0].bufCb == (Uint32)-1 &&
-			    bufArray[0].bufCr == (Uint32)-1) {
-				Uint32 size;
-				pEncInfo->frameAllocExt = TRUE;
-				size = ProductCalculateFrameBufSize(
-					pCodecInst->productId, stride, height,
-					(TiledMapType)mapType,
-					(FrameBufferFormat)openParam->srcFormat,
-					(BOOL)openParam->cbcrInterleave, NULL);
-				if (mapType == LINEAR_FRAME_MAP) {
-					pEncInfo->vbFrame.phys_addr =
-						bufArray[0].bufY;
-					pEncInfo->vbFrame.size = size * num;
-				}
-			}
-		}
-		ret = ProductVpuAllocateFramebuffer(
-			pCodecInst, fb, (TiledMapType)mapType, num, stride,
-			height, (FrameBufferFormat)openParam->srcFormat,
-			openParam->cbcrInterleave, FALSE,
-			openParam->frameEndian, &pEncInfo->vbFrame, 0,
-			FB_TYPE_CODEC);
-		if (ret != RETCODE_SUCCESS) {
-			LeaveLock(pCodecInst->coreIdx);
-			return ret;
-		}
-	}
-	ret = ProductVpuRegisterFramebuffer(pCodecInst);
-
-	LeaveLock(pCodecInst->coreIdx);
-
-	return ret;
-}
-
-RetCode VPU_EncGetFrameBuffer(EncHandle handle, int frameIdx,
-			      FrameBuffer *frameBuf)
-{
-	CodecInst *pCodecInst;
-	EncInfo *pEncInfo;
-	RetCode ret;
-
-	ret = CheckEncInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	pCodecInst = handle;
-	pEncInfo = &pCodecInst->CodecInfo->encInfo;
-
-	if (frameIdx < 0 || frameIdx > pEncInfo->numFrameBuffers)
-		return RETCODE_INVALID_PARAM;
-
-	if (frameBuf == 0)
-		return RETCODE_INVALID_PARAM;
-
-	*frameBuf = pEncInfo->frameBufPool[frameIdx];
-
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_EncGetBitstreamBuffer(EncHandle handle, PhysicalAddress *prdPrt,
-				  PhysicalAddress *pwrPtr, int *size)
-{
-	CodecInst *pCodecInst;
-	EncInfo *pEncInfo;
-	PhysicalAddress rdPtr;
-	PhysicalAddress wrPtr;
-	Uint32 room;
-	RetCode ret;
-
-	ret = CheckEncInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	if (prdPrt == 0 || pwrPtr == 0 || size == 0) {
-		return RETCODE_INVALID_PARAM;
-	}
-
-	pCodecInst = handle;
-	pEncInfo = &pCodecInst->CodecInfo->encInfo;
-
-	rdPtr = pEncInfo->streamRdPtr;
-
-	SetClockGate(pCodecInst->coreIdx, 1);
-
-	if (GetPendingInst(pCodecInst->coreIdx) == pCodecInst)
-		wrPtr = VpuReadReg(pCodecInst->coreIdx,
-				   pEncInfo->streamWrPtrRegAddr);
-	else
-		wrPtr = pEncInfo->streamWrPtr;
-
-	SetClockGate(pCodecInst->coreIdx, 0);
-	if (pEncInfo->ringBufferEnable == 1 || pEncInfo->lineBufIntEn == 1) {
-		if (wrPtr >= rdPtr) {
-			room = wrPtr - rdPtr;
-		} else {
-			room = (pEncInfo->streamBufEndAddr - rdPtr) +
-			       (wrPtr - pEncInfo->streamBufStartAddr);
-		}
-	} else {
-		if (wrPtr >= rdPtr)
-			room = wrPtr - rdPtr;
-		else
-			return RETCODE_INVALID_PARAM;
-	}
-
-	*prdPrt = rdPtr;
-	*pwrPtr = wrPtr;
-	*size = room;
-
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_EncUpdateBitstreamBuffer(EncHandle handle, int size)
-{
-	CodecInst *pCodecInst;
-	EncInfo *pEncInfo;
-	PhysicalAddress wrPtr;
-	PhysicalAddress rdPtr;
-	RetCode ret;
-	int room = 0;
-	ret = CheckEncInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	pCodecInst = handle;
-	pEncInfo = &pCodecInst->CodecInfo->encInfo;
-
-	rdPtr = pEncInfo->streamRdPtr;
-
-	SetClockGate(pCodecInst->coreIdx, 1);
-
-	if (GetPendingInst(pCodecInst->coreIdx) == pCodecInst)
-		wrPtr = VpuReadReg(pCodecInst->coreIdx,
-				   pEncInfo->streamWrPtrRegAddr);
-	else
-		wrPtr = pEncInfo->streamWrPtr;
-
-	if (rdPtr < wrPtr) {
-		if (rdPtr + size > wrPtr) {
-			SetClockGate(pCodecInst->coreIdx, 0);
-			return RETCODE_INVALID_PARAM;
-		}
-	}
-
-	if (pEncInfo->ringBufferEnable == TRUE ||
-	    pEncInfo->lineBufIntEn == TRUE) {
-		rdPtr += size;
-		if (rdPtr > pEncInfo->streamBufEndAddr) {
-			if (pEncInfo->lineBufIntEn == TRUE) {
-				return RETCODE_INVALID_PARAM;
-			}
-			room = rdPtr - pEncInfo->streamBufEndAddr;
-			rdPtr = pEncInfo->streamBufStartAddr;
-			rdPtr += room;
-		}
-
-		if (rdPtr == pEncInfo->streamBufEndAddr) {
-			rdPtr = pEncInfo->streamBufStartAddr;
-		}
-	} else {
-		rdPtr = pEncInfo->streamBufStartAddr;
-	}
-
-	pEncInfo->streamRdPtr = rdPtr;
-	pEncInfo->streamWrPtr = wrPtr;
-	if (GetPendingInst(pCodecInst->coreIdx) == pCodecInst)
-		VpuWriteReg(pCodecInst->coreIdx, pEncInfo->streamRdPtrRegAddr,
-			    rdPtr);
-
-	if (pEncInfo->lineBufIntEn == TRUE) {
-		pEncInfo->streamRdPtr = pEncInfo->streamBufStartAddr;
-	}
-
-	SetClockGate(pCodecInst->coreIdx, 0);
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_EncStartOneFrame(EncHandle handle, EncParam *param)
-{
-	CodecInst *pCodecInst;
-	EncInfo *pEncInfo;
-	RetCode ret;
-	VpuAttr *pAttr = NULL;
-	vpu_instance_pool_t *vip;
-
-	ret = CheckEncInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	pCodecInst = handle;
-	pEncInfo = &pCodecInst->CodecInfo->encInfo;
-	vip = (vpu_instance_pool_t *)vdi_get_instance_pool(pCodecInst->coreIdx);
-	if (!vip) {
-		return RETCODE_INVALID_HANDLE;
-	}
-
-	if (pEncInfo->stride ==
-	    0) { // This means frame buffers have not been registered.
-		return RETCODE_WRONG_CALL_SEQUENCE;
-	}
-
-	ret = CheckEncParam(handle, param);
-	if (ret != RETCODE_SUCCESS) {
-		return ret;
-	}
-
-	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
-
-	EnterLock(pCodecInst->coreIdx);
-
-	pEncInfo->ptsMap[param->srcIdx] =
-		(pEncInfo->openParam.enablePTS == TRUE) ? GetTimestamp(handle) :
-							  param->pts;
-
-	if (GetPendingInst(pCodecInst->coreIdx)) {
-		if (VPU_GetOpenInstanceNum(pCodecInst->coreIdx) > 1) //RTK
-		{
-			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
-			     __func__, __LINE__);
-			msleep(50);
-			if (GetPendingInst(pCodecInst->coreIdx)) {
-				LeaveLock(pCodecInst->coreIdx);
-				return RETCODE_FRAME_NOT_COMPLETE;
-			}
-		} else {
-			LeaveLock(pCodecInst->coreIdx);
-			return RETCODE_FRAME_NOT_COMPLETE;
-		}
-	}
-
-	ret = ProductVpuEncode(pCodecInst, param);
-
-	if (pAttr->supportCommandQueue == TRUE) {
-		SetPendingInst(pCodecInst->coreIdx, NULL);
-		LeaveLock(pCodecInst->coreIdx);
-	} else {
-		SetPendingInst(pCodecInst->coreIdx, pCodecInst);
-	}
-
-	return ret;
-}
-
-RetCode VPU_EncGetOutputInfo(EncHandle handle, EncOutputInfo *info)
-{
-	CodecInst *pCodecInst;
-	EncInfo *pEncInfo;
-	RetCode ret;
-	VpuAttr *pAttr;
-
-	ret = CheckEncInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS) {
-		return ret;
-	}
-
-	if (info == 0) {
-		return RETCODE_INVALID_PARAM;
-	}
-
-	pCodecInst = handle;
-	pEncInfo = &pCodecInst->CodecInfo->encInfo;
-	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
-
-	if (pAttr->supportCommandQueue == TRUE) {
-		EnterLock(pCodecInst->coreIdx);
-	} else {
-		if (pCodecInst != GetPendingInst(pCodecInst->coreIdx)) {
-			SetPendingInst(pCodecInst->coreIdx, 0);
-			LeaveLock(pCodecInst->coreIdx);
-			return RETCODE_WRONG_CALL_SEQUENCE;
-		}
-	}
-
-	ret = ProductVpuEncGetResult(pCodecInst, info);
-
-	if (ret == RETCODE_SUCCESS) {
-		info->pts = pEncInfo->ptsMap[info->encSrcIdx];
-	} else {
-		info->pts = 0LL;
-	}
-
-	SetPendingInst(pCodecInst->coreIdx, 0);
-	LeaveLock(pCodecInst->coreIdx);
-
-	return ret;
-}
-
-RetCode VPU_EncGiveCommand(EncHandle handle, CodecCommand cmd, void *param)
-{
-	CodecInst *pCodecInst;
-	EncInfo *pEncInfo;
-	RetCode ret;
-
-	ret = CheckEncInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS) {
-		return ret;
-	}
-
-	pCodecInst = handle;
-	pEncInfo = &pCodecInst->CodecInfo->encInfo;
-	switch (cmd) {
-	case ENABLE_ROTATION: {
-		pEncInfo->rotationEnable = 1;
-	} break;
-	case DISABLE_ROTATION: {
-		pEncInfo->rotationEnable = 0;
-	} break;
-	case ENABLE_MIRRORING: {
-		pEncInfo->mirrorEnable = 1;
-	} break;
-	case DISABLE_MIRRORING: {
-		pEncInfo->mirrorEnable = 0;
-	} break;
-	case SET_MIRROR_DIRECTION: {
-		MirrorDirection mirDir;
-
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		mirDir = *(MirrorDirection *)param;
-		if (!(mirDir == MIRDIR_NONE) && !(mirDir == MIRDIR_HOR) &&
-		    !(mirDir == MIRDIR_VER) && !(mirDir == MIRDIR_HOR_VER)) {
-			return RETCODE_INVALID_PARAM;
-		}
-		pEncInfo->mirrorDirection = mirDir;
-	} break;
-	case SET_ROTATION_ANGLE: {
-		int angle;
-
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		angle = *(int *)param;
-		if (angle != 0 && angle != 90 && angle != 180 && angle != 270) {
-			return RETCODE_INVALID_PARAM;
-		}
-		if (pEncInfo->initialInfoObtained &&
-		    (angle == 90 || angle == 270)) {
-			return RETCODE_INVALID_PARAM;
-		}
-		pEncInfo->rotationAngle = angle;
-	} break;
-	case SET_CACHE_CONFIG: {
-		MaverickCacheConfig *mcCacheConfig;
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		mcCacheConfig = (MaverickCacheConfig *)param;
-		pEncInfo->cacheConfig = *mcCacheConfig;
-	} break;
-	case ENC_PUT_MP4_HEADER:
-	case ENC_PUT_AVC_HEADER:
-	case ENC_PUT_VIDEO_HEADER: {
-		EncHeaderParam *encHeaderParam;
-
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		encHeaderParam = (EncHeaderParam *)param;
-		if (pCodecInst->codecMode == MP4_ENC ||
-		    pCodecInst->codecMode == W_MP4_ENC) {
-			if (!(VOL_HEADER <= encHeaderParam->headerType &&
-			      encHeaderParam->headerType <= VIS_HEADER)) {
-				return RETCODE_INVALID_PARAM;
-			}
-		} else if (pCodecInst->codecMode == AVC_ENC ||
-			   pCodecInst->codecMode == W_AVC_ENC) {
-			if (!(SPS_RBSP <= encHeaderParam->headerType &&
-			      encHeaderParam->headerType <= PPS_RBSP_MVC)) {
-				return RETCODE_INVALID_PARAM;
-			}
-		} else
-			return RETCODE_INVALID_PARAM;
-
-		if (pEncInfo->ringBufferEnable == 0) {
-			if (encHeaderParam->buf % 8 ||
-			    encHeaderParam->size == 0) {
-				return RETCODE_INVALID_PARAM;
-			}
-		}
-
-		return GetEncHeader(handle, encHeaderParam);
-	}
-	case ENC_SET_ACTIVE_PPS: {
-		int ActivePPSIdx = (int)(*(int *)param);
-		if (pCodecInst->codecMode != AVC_ENC &&
-		    pCodecInst->codecMode != W_AVC_ENC)
-			return RETCODE_INVALID_COMMAND;
-		if (ActivePPSIdx < 0 ||
-		    ActivePPSIdx >
-			    pEncInfo->openParam.EncStdParam.avcParam.ppsNum)
-			return RETCODE_INVALID_COMMAND;
-
-		pEncInfo->ActivePPSIdx = ActivePPSIdx;
-		return EncParaSet(handle, PPS_RBSP);
-	} break;
-	case ENC_GET_ACTIVE_PPS:
-		if (pCodecInst->codecMode != AVC_ENC &&
-		    pCodecInst->codecMode != W_AVC_ENC)
-			return RETCODE_INVALID_COMMAND;
-		*((int *)param) = pEncInfo->ActivePPSIdx;
-		break;
-	case ENC_SET_GOP_NUMBER: {
-		int *pGopNumber = (int *)param;
-		if (pCodecInst->codecMode != MP4_ENC &&
-		    pCodecInst->codecMode != AVC_ENC &&
-		    pCodecInst->codecMode != W_MP4_ENC &&
-		    pCodecInst->codecMode != W_AVC_ENC) {
-			return RETCODE_INVALID_COMMAND;
-		}
-		if (*pGopNumber < 0)
-			return RETCODE_INVALID_PARAM;
-		pEncInfo->openParam.gopSize = *pGopNumber;
-		SetGopNumber(handle, (Uint32 *)pGopNumber);
-	} break;
-	case ENC_SET_INTRA_QP: {
-		int *pIntraQp = (int *)param;
-		if (pCodecInst->codecMode != MP4_ENC &&
-		    pCodecInst->codecMode != AVC_ENC &&
-		    pCodecInst->codecMode != W_MP4_ENC &&
-		    pCodecInst->codecMode != W_AVC_ENC) {
-			return RETCODE_INVALID_COMMAND;
-		}
-		if (pCodecInst->codecMode == MP4_ENC ||
-		    pCodecInst->codecMode == W_MP4_ENC) {
-			if (*pIntraQp < 1 || *pIntraQp > 31)
-				return RETCODE_INVALID_PARAM;
-		}
-		if (pCodecInst->codecMode == AVC_ENC ||
-		    pCodecInst->codecMode == W_AVC_ENC) {
-			if (*pIntraQp < 0 || *pIntraQp > 51)
-				return RETCODE_INVALID_PARAM;
-		}
-		SetIntraQp(handle, (Uint32 *)pIntraQp);
-	} break;
-	case ENC_SET_BITRATE: {
-		int *pBitrate = (int *)param;
-		if (pCodecInst->codecMode != MP4_ENC &&
-		    pCodecInst->codecMode != AVC_ENC &&
-		    pCodecInst->codecMode != W_MP4_ENC &&
-		    pCodecInst->codecMode != W_AVC_ENC) {
-			return RETCODE_INVALID_COMMAND;
-		}
-		if (pCodecInst->codecMode == AVC_ENC ||
-		    pCodecInst->codecMode == W_AVC_ENC) {
-			if (*pBitrate < 0 || *pBitrate > 524288) {
-				return RETCODE_INVALID_PARAM;
-			}
-
-		} else // MP4_ENC
-		{
-			if (*pBitrate < 0 || *pBitrate > 32767) {
-				return RETCODE_INVALID_PARAM;
-			}
-		}
-		SetBitrate(handle, (Uint32 *)pBitrate);
-	} break;
-	case ENC_SET_FRAME_RATE: {
-		int *pFramerate = (int *)param;
-
-		if (pCodecInst->codecMode != MP4_ENC &&
-		    pCodecInst->codecMode != AVC_ENC &&
-		    pCodecInst->codecMode != W_MP4_ENC &&
-		    pCodecInst->codecMode != W_AVC_ENC) {
-			return RETCODE_INVALID_COMMAND;
-		}
-		if (*pFramerate <= 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		SetFramerate(handle, (Uint32 *)pFramerate);
-	} break;
-	case ENC_SET_INTRA_MB_REFRESH_NUMBER: {
-		int *pIntraRefreshNum = (int *)param;
-		SetIntraRefreshNum(handle, (Uint32 *)pIntraRefreshNum);
-	} break;
-	case ENC_SET_SLICE_INFO: {
-		EncSliceMode *pSliceMode = (EncSliceMode *)param;
-		if (pSliceMode->sliceMode < 0 || pSliceMode->sliceMode > 1) {
-			return RETCODE_INVALID_PARAM;
-		}
-		if (pSliceMode->sliceSizeMode < 0 ||
-		    pSliceMode->sliceSizeMode > 1) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		SetSliceMode(handle, (EncSliceMode *)pSliceMode);
-	} break;
-	case ENC_ENABLE_HEC: {
-		if (pCodecInst->codecMode != MP4_ENC &&
-		    pCodecInst->codecMode != W_MP4_ENC) {
-			return RETCODE_INVALID_COMMAND;
-		}
-		SetHecMode(handle, 1);
-	} break;
-	case ENC_DISABLE_HEC: {
-		if (pCodecInst->codecMode != MP4_ENC &&
-		    pCodecInst->codecMode != W_MP4_ENC) {
-			return RETCODE_INVALID_COMMAND;
-		}
-		SetHecMode(handle, 0);
-	} break;
-	case SET_SEC_AXI: {
-		SecAxiUse secAxiUse;
-
-		if (param == 0) {
-			return RETCODE_INVALID_PARAM;
-		}
-		secAxiUse = *(SecAxiUse *)param;
-
-		// coda9 or coda7q or ...
-		pEncInfo->secAxiInfo.u.coda9.useBitEnable =
-			secAxiUse.u.coda9.useBitEnable;
-		pEncInfo->secAxiInfo.u.coda9.useIpEnable =
-			secAxiUse.u.coda9.useIpEnable;
-		pEncInfo->secAxiInfo.u.coda9.useDbkYEnable =
-			secAxiUse.u.coda9.useDbkYEnable;
-		pEncInfo->secAxiInfo.u.coda9.useDbkCEnable =
-			secAxiUse.u.coda9.useDbkCEnable;
-		pEncInfo->secAxiInfo.u.coda9.useOvlEnable =
-			secAxiUse.u.coda9.useOvlEnable;
-		pEncInfo->secAxiInfo.u.coda9.useBtpEnable =
-			secAxiUse.u.coda9.useBtpEnable;
-	} break;
-	case GET_TILEDMAP_CONFIG: {
-		TiledMapConfig *pMapCfg = (TiledMapConfig *)param;
-		if (!pMapCfg) {
-			return RETCODE_INVALID_PARAM;
-		}
-		*pMapCfg = pEncInfo->mapCfg;
-		break;
-	}
-	case SET_DRAM_CONFIG: {
-		DRAMConfig *cfg = (DRAMConfig *)param;
-
-		if (!cfg) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		pEncInfo->dramCfg = *cfg;
-		break;
-	}
-	case GET_DRAM_CONFIG: {
-		DRAMConfig *cfg = (DRAMConfig *)param;
-
-		if (!cfg) {
-			return RETCODE_INVALID_PARAM;
-		}
-
-		*cfg = pEncInfo->dramCfg;
-
-		break;
-	}
-	case ENABLE_LOGGING: {
-		pCodecInst->loggingEnable = 1;
-	} break;
-	case DISABLE_LOGGING: {
-		pCodecInst->loggingEnable = 0;
-	} break;
-	case ENC_SET_PARA_CHANGE: {
-		return RETCODE_INVALID_PARAM;
-	} break;
-	default:
-		return RETCODE_INVALID_COMMAND;
-	}
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_EncAllocateFrameBuffer(EncHandle handle, FrameBufferAllocInfo info,
-				   FrameBuffer *frameBuffer)
-{
-	CodecInst *pCodecInst;
-	EncInfo *pEncInfo;
-	RetCode ret;
-	int gdiIndex;
-
-	ret = CheckEncInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	pCodecInst = handle;
-	pEncInfo = &pCodecInst->CodecInfo->encInfo;
-
-	if (!frameBuffer) {
-		return RETCODE_INVALID_PARAM;
-	}
-	if (info.num == 0 || info.num < 0) {
-		return RETCODE_INVALID_PARAM;
-	}
-	if (info.stride == 0 || info.stride < 0) {
-		return RETCODE_INVALID_PARAM;
-	}
-	if (info.height == 0 || info.height < 0) {
-		return RETCODE_INVALID_PARAM;
-	}
-
-	if (info.type == FB_TYPE_PPU) {
-		if (pEncInfo->numFrameBuffers == 0) {
-			return RETCODE_WRONG_CALL_SEQUENCE;
-		}
-		pEncInfo->ppuAllocExt = frameBuffer[0].updateFbInfo;
-		gdiIndex = pEncInfo->numFrameBuffers;
-		ret = ProductVpuAllocateFramebuffer(
-			pCodecInst, frameBuffer, (TiledMapType)info.mapType,
-			(Int32)info.num, info.stride, info.height, info.format,
-			info.cbcrInterleave, info.nv21, info.endian,
-			&pEncInfo->vbPPU, gdiIndex,
-			(FramebufferAllocType)info.type);
-	} else if (info.type == FB_TYPE_CODEC) {
-		gdiIndex = 0;
-		pEncInfo->frameAllocExt = frameBuffer[0].updateFbInfo;
-		ret = ProductVpuAllocateFramebuffer(
-			pCodecInst, frameBuffer, (TiledMapType)info.mapType,
-			(Int32)info.num, info.stride, info.height, info.format,
-			info.cbcrInterleave, FALSE, info.endian,
-			&pEncInfo->vbFrame, gdiIndex,
-			(FramebufferAllocType)info.type);
-	} else {
-		ret = RETCODE_INVALID_PARAM;
-	}
-
-	return ret;
-}
-
-RetCode VPU_EncIssueSeqInit(EncHandle handle)
-{
-	CodecInst *pCodecInst;
-	RetCode ret;
-	VpuAttr *pAttr;
-
-	ret = CheckEncInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	pCodecInst = handle;
-
-	EnterLock(pCodecInst->coreIdx);
-
-	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
-
-	if (GetPendingInst(pCodecInst->coreIdx)) {
-		LeaveLock(pCodecInst->coreIdx);
-		return RETCODE_FRAME_NOT_COMPLETE;
-	}
-
-	ret = ProductVpuEncInitSeq(handle);
-	if (ret == RETCODE_SUCCESS) {
-		SetPendingInst(pCodecInst->coreIdx, pCodecInst);
-	}
-
-	if (pAttr->supportCommandQueue == TRUE) {
-		SetPendingInst(pCodecInst->coreIdx, NULL);
-		LeaveLock(pCodecInst->coreIdx);
-	}
-
-	return ret;
-}
-
-RetCode VPU_EncCompleteSeqInit(EncHandle handle, EncInitialInfo *info)
-{
-	CodecInst *pCodecInst;
-	EncInfo *pEncInfo;
-	RetCode ret;
-	VpuAttr *pAttr;
-
-	ret = CheckEncInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS) {
-		return ret;
-	}
-
-	if (info == 0) {
-		return RETCODE_INVALID_PARAM;
-	}
-
-	pCodecInst = handle;
-	pEncInfo = &pCodecInst->CodecInfo->encInfo;
-
-	pAttr = &g_VpuCoreAttributes[pCodecInst->coreIdx];
-
-	if (pAttr->supportCommandQueue == TRUE) {
-		EnterLock(pCodecInst->coreIdx);
-	} else {
-		if (pCodecInst != GetPendingInst(pCodecInst->coreIdx)) {
-			SetPendingInst(pCodecInst->coreIdx, 0);
-			LeaveLock(pCodecInst->coreIdx);
-			return RETCODE_WRONG_CALL_SEQUENCE;
-		}
-	}
-
-	ret = ProductVpuEncGetSeqInfo(handle, info);
-	if (ret == RETCODE_SUCCESS) {
-		pEncInfo->initialInfoObtained = 1;
-	}
-
-	pEncInfo->initialInfo = *info;
-
-	SetPendingInst(pCodecInst->coreIdx, NULL);
-
-	LeaveLock(pCodecInst->coreIdx);
-
-	return ret;
-}
-
-RetCode VPU_DecGetRdPtr(DecHandle handle, PhysicalAddress *prdPtr)
-{
-	CodecInst *pCodecInst;
-	CodecInst *pPendingInst;
-	DecInfo *pDecInfo;
-	RetCode ret;
-
-	PhysicalAddress rdPtr;
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS) {
-		return ret;
-	}
-	pCodecInst = (CodecInst *)handle;
-	ret = ProductVpuDecCheckCapability(pCodecInst);
-	if (ret != RETCODE_SUCCESS) {
-		return ret;
-	}
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-	pPendingInst = GetPendingInst(pCodecInst->coreIdx);
-	if (pCodecInst == pPendingInst) {
-		rdPtr = VpuReadReg(pCodecInst->coreIdx,
-				   pDecInfo->streamRdPtrRegAddr);
-	} else {
-		EnterLock(pCodecInst->coreIdx);
-		rdPtr = VpuReadReg(pCodecInst->coreIdx,
-				   pDecInfo->streamRdPtrRegAddr);
-		LeaveLock(pCodecInst->coreIdx);
-	}
-
-	if (prdPtr)
-		*prdPtr = rdPtr;
-
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_DecSetWrPtr(DecHandle handle, PhysicalAddress addr, int updateRdPtr)
-{
-	CodecInst *pCodecInst;
-	CodecInst *pPendingInst;
-	DecInfo *pDecInfo;
-	RetCode ret;
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-	pCodecInst = (CodecInst *)handle;
-	pDecInfo = &handle->CodecInfo->decInfo;
-	pPendingInst = GetPendingInst(pCodecInst->coreIdx);
-	if (pCodecInst == pPendingInst) {
-		VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamWrPtrRegAddr,
-			    addr);
-	} else {
-		EnterLock(pCodecInst->coreIdx);
-		VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamWrPtrRegAddr,
-			    addr);
-		LeaveLock(pCodecInst->coreIdx);
-	}
-	pDecInfo->streamWrPtr = addr;
-	if (updateRdPtr)
-		pDecInfo->streamRdPtr = addr;
-
-	VLOG(TRACE, "[%d]%s.h:0x%x.addr:0x%x.updateRdPtr:%d\n", __LINE__,
-	     __func__, handle, addr, updateRdPtr);
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_DecGetBitstreamBufferNoHW(DecHandle handle, PhysicalAddress *prdPtr,
-				      PhysicalAddress *pwrPtr, Uint32 *size)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	PhysicalAddress rdPtr;
-	PhysicalAddress wrPtr;
-	PhysicalAddress tempPtr;
-	int room;
-	Int32 coreIdx;
-	VpuAttr *pAttr;
-
-	coreIdx = handle->coreIdx;
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-
-	rdPtr = pDecInfo->streamRdPtr;
-	wrPtr = pDecInfo->streamWrPtr;
-
-	pAttr = &g_VpuCoreAttributes[coreIdx];
-
-	tempPtr = rdPtr;
-
-	if (pDecInfo->openParam.bitstreamMode != BS_MODE_PIC_END) {
-		if (wrPtr < tempPtr) {
-			room = tempPtr - wrPtr -
-			       pAttr->bitstreamBufferMargin * 2;
-		} else {
-			room = (pDecInfo->streamBufEndAddr - wrPtr) +
-			       (tempPtr - pDecInfo->streamBufStartAddr) -
-			       pAttr->bitstreamBufferMargin * 2;
-		}
-		room--;
-	} else {
-		room = (pDecInfo->streamBufEndAddr - wrPtr);
-	}
-
-	if (prdPtr)
-		*prdPtr = tempPtr;
-	if (pwrPtr)
-		*pwrPtr = wrPtr;
-	if (size)
-		*size = room;
-
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_DecUpdateBitstreamBufferNoHW(DecHandle handle, int size)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	PhysicalAddress wrPtr;
-	PhysicalAddress rdPtr;
-	RetCode ret;
-	BOOL running;
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-	wrPtr = pDecInfo->streamWrPtr;
-
-	running = FALSE;
-
-	if (size > 0) {
-		Uint32 room = 0;
-
-		rdPtr = pDecInfo->streamRdPtr;
-
-		if (wrPtr < rdPtr) {
-			if (rdPtr <= wrPtr + size) {
-				return RETCODE_INVALID_PARAM;
-			}
-		}
-
-		wrPtr += size;
-
-		if (wrPtr > pDecInfo->streamBufEndAddr) {
-			room = wrPtr - pDecInfo->streamBufEndAddr;
-			wrPtr = pDecInfo->streamBufStartAddr;
-			wrPtr += room;
-		} else if (wrPtr == pDecInfo->streamBufEndAddr) {
-			wrPtr = pDecInfo->streamBufStartAddr;
-		}
-
-		pDecInfo->streamWrPtr = wrPtr;
-		pDecInfo->streamRdPtr = rdPtr;
-
-		if (running == TRUE) {
-			VpuAttr *pAttr =
-				&g_VpuCoreAttributes[pCodecInst->coreIdx];
-			if (pAttr->supportCommandQueue == FALSE) {
-				VpuWriteReg(pCodecInst->coreIdx,
-					    pDecInfo->streamWrPtrRegAddr,
-					    wrPtr);
-			}
-		}
-	}
-
-	ret = ProductVpuDecSetBitstreamFlag(pCodecInst, running, size);
-
-	return ret;
-}
-
-RetCode RTK_VPU_InitWithBitcode(Uint32 coreIdx, BOOL protect)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	Uint8 *firmware = NULL;
-	Uint32 totalRead = 0;
-	(void)protect; //unused
-
-	VLOG(TRACE, "[+] [%d]%s.coreIdx:%d.protect:%d\n", __LINE__, __func__,
-	     coreIdx, protect);
-	if (coreIdx >= MAX_NUM_VPU_CORE) {
-		VLOG(ERR, "[-] [%d]%s.coreIdx:%d.ret:RETCODE_FAILURE\n",
-		     __LINE__, __func__, coreIdx);
-		return RETCODE_FAILURE;
-	}
-
-	if (coreIdx == 0) {
-		firmware = (Uint8 *)osal_malloc(VPU_FIRMWARE_SIZE);
-		VLOG(TRACE, "[%d]firmware:0x%px\n", __LINE__, firmware);
-		VLOG(TRACE, "[%d]size:%d\n", __LINE__, VPU_FIRMWARE_SIZE);
-		VLOG(TRACE, "[%d]bit_code:0x%lx.sizeof(bit_code):%d\n",
-		     __LINE__, bit_code, sizeof(bit_code));
-		if (firmware != NULL) {
-			osal_memcpy((void *)firmware, bit_code,
-				    sizeof(bit_code));
-			totalRead = sizeof(bit_code) / 2;
-			VLOG(TRACE, "[%d]totalRead:%d\n", __LINE__, totalRead);
-		}
-	}
-
-	if (firmware != NULL) {
-		ret = VPU_InitWithBitcode(coreIdx, (const Uint16 *)firmware,
-					  totalRead);
-		osal_free(firmware);
-	}
-
-	VLOG(TRACE, "[-] [%d]%s.coreIdx:%d.ret:%d\n", __LINE__, __func__,
-	     coreIdx, ret);
-	return ret;
-}
-
-RetCode RTK_VPU_InitWithBitcodeExt(Uint32 coreIdx, BOOL protect, void *sess,
-				   void *rtk_sess, void *filp)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	Uint8 *firmware = NULL;
-	Uint32 totalRead = 0;
-
-	VLOG(TRACE, "[+] [%d]%s.coreIdx:%d.protect:%d.sess:%p.rtk_sess:%p\n",
-	     __LINE__, __func__, coreIdx, protect, sess, rtk_sess);
-	if (coreIdx >= MAX_NUM_VPU_CORE) {
-		VLOG(TRACE, "[-] [%d]%s.coreIdx:%d.ret:RETCODE_FAILURE\n",
-		     __LINE__, __func__, coreIdx);
-		return RETCODE_FAILURE;
-	}
-
-	if (coreIdx == 0) {
-		firmware = (Uint8 *)osal_malloc(VPU_FIRMWARE_SIZE);
-		if (firmware != NULL) {
-			osal_memcpy((void *)firmware, bit_code,
-				    sizeof(bit_code));
-			totalRead = sizeof(bit_code) / 2;
-		}
-	}
-
-	if (firmware != NULL) {
-#ifdef ENABLE_TEE_DRM_FLOW
-		if (protect == TRUE)
-			ret = VPU_InitWithBitcodeProtect(
-				coreIdx, (const Uint16 *)firmware, totalRead,
-				sess, rtk_sess, filp);
-		else
-			ret = VPU_InitWithBitcode(
-				coreIdx, (const Uint16 *)firmware, totalRead);
-#else
-		ret = VPU_InitWithBitcode(coreIdx, (const Uint16 *)firmware,
-					  totalRead);
-#endif
-		osal_free(firmware);
-	}
-
-	VLOG(TRACE, "[-] [%d]%s.coreIdx:%d.ret:%d\n", __LINE__, __func__,
-	     coreIdx, ret);
-	return ret;
-}
-
-RetCode VPU_DBG_DUMP_SDATA(DecHandle handle, unsigned int phy_addr,
-			   unsigned char *dst_buf, int dst_buf_size)
-{
-	RetCode ret = RETCODE_SUCCESS;
-#ifdef ENABLE_TEE_DRM_FLOW
-	int taRet;
-	CodecInst *pCodecInst;
-	vpu_buffer_t *vb = NULL;
-
-	VLOG(TRACE,
-	     "[+] [%d]%s.handle:0x%px.phy_addr:0x%x.dst_buf:0x%px.dst_buf_size:%d\n",
-	     __LINE__, __func__, handle, phy_addr, dst_buf, dst_buf_size);
-
-	if (handle == NULL || phy_addr == 0 || dst_buf == NULL ||
-	    dst_buf_size <= 0) {
-		VLOG(ERR,
-		     "[-] [%d]%s.invalid parameters.handle:0x%px.phy_addr:0x%x.dst_buf:0x%px.dst_buf_size:%d\n",
-		     __LINE__, __func__, handle, phy_addr, dst_buf,
-		     dst_buf_size);
-		return RETCODE_INVALID_PARAM;
-	}
-	pCodecInst = handle;
-
-	vb = kzalloc(sizeof(DecOpenParam), GFP_KERNEL);
-	if (!vb) {
-		VLOG(ERR, "[%d]%s.handle:0x%px.kzalloc vb fail\n", __LINE__,
-		     __func__, handle);
-		goto exit;
-	}
-
-	vb->size = dst_buf_size;
-	vb->req_spec_region = VE_SECURE_PROTECTION;
-	if (vdi_allocate_dma_memory_no_mmap(pCodecInst->coreIdx, (void *)vb,
-					    pCodecInst->filp) < 0) {
-		VLOG(ERR,
-		     "[%d]%s.handle:0x%px.vdi_allocate_dma_memory_no_mmap() fail\n",
-		     __LINE__, __func__, handle);
-		ret = RETCODE_INSUFFICIENT_RESOURCE;
-		goto free_vb;
-	}
-
-	taRet = ta_TEEapi_memcpy((struct tee_context *)pCodecInst->teeapi_ctx,
-				 pCodecInst->teeapi_tee_session, vb->phys_addr,
-				 phy_addr, dst_buf_size);
-	if (taRet < 0) {
-		VLOG(ERR, "[%d]%s.ta_TEEapi_memcpy() fail.ret:%d\n", __LINE__,
-		     __func__, taRet);
-		ret = RETCODE_FAILURE;
-		goto free_vb_ion;
-	}
-
-	taRet = ta_TEEapi_bitstreamprint(
-		(struct tee_context *)pCodecInst->teeapi_ctx,
-		pCodecInst->teeapi_tee_session, vb->phys_addr, dst_buf_size);
-	if (taRet < 0) {
-		VLOG(ERR, "[%d]%s.ta_TEEapi_bitstreamprint() fail.ret:%d\n",
-		     __LINE__, __func__, taRet);
-		ret = RETCODE_FAILURE;
-		goto free_vb_ion;
-	}
-
-	taRet = ta_TEEapi_bitstreamout(
-		(struct tee_context *)pCodecInst->teeapi_ctx,
-		pCodecInst->teeapi_tee_session, vb->phys_addr, dst_buf,
-		dst_buf_size);
-	if (taRet < 0) {
-		VLOG(ERR, "[%d]%s.ta_TEEapi_bitstreamout() fail.ret:%d\n",
-		     __LINE__, __func__, taRet);
-		ret = RETCODE_FAILURE;
-		goto free_vb_ion;
-	}
-
-free_vb_ion:
-	vdi_free_dma_memory_no_mmap(pCodecInst->coreIdx, vb);
-free_vb:
-	kfree(vb);
-exit:
-	VLOG(TRACE, "[-] [%d]%s.ret:%d\n", __LINE__, __func__, ret);
-#else
-	VLOG(ERR, "[%d]%s.unsupport ifndef ENABLE_TEE_DRM_FLOW\n", __LINE__,
-	     __func__);
-	ret = RETCODE_FAILURE;
-#endif // #ifdef ENABLE_TEE_DRM_FLOW
-	return ret;
-}
\ No newline at end of file
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateful/ve1_wrapper.c
===================================================================
--- kernel-5_15.orig/drivers/media/platform/realtek/vpu/stateful/ve1_wrapper.c
+++ /dev/null
@@ -1,3926 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/delay.h>
-#include <linux/videodev2.h>
-#include <linux/tee_drv.h>
-#include <linux/dma-buf.h>
-#include <media/v4l2-mem2mem.h>
-#include "ve1_vpuapifunc.h"
-#include "ve1_wrapper.h"
-#include "ve1_v4l2.h"
-#include "ve1_mem.h"
-#include "drv_if.h"
-#include "vpu.h"
-#define VE1_WRAPPER_TAG "[VE1_WRAPPER]"
-
-// if #define VE1_ALLOC_FRAME_BUFFER_BY_VDI, ve1_wrapper allocate frame buffer by vdi_allocate_dma_memory_no_mmap()
-// or ve1_wrapper allocate frame buffer by ve1_alloc_frame_buffer()
-//#define VE1_ALLOC_FRAME_BUFFER_BY_VDI
-
-//#define VE1_CHECK_DFB_MD5_EN
-//#if defined(VE1_CHECK_DFB_MD5_EN)
-#if defined(VE1_CHECK_DFB_MD5_EN) || defined(VE1_CHECK_USERDATA_MD5_EN)
-#include <crypto/hash.h>
-#define VE1_MD5_DIGEST_SIZE 16
-static unsigned char ve1_md5_digest[VE1_MD5_DIGEST_SIZE];
-#endif
-
-//#define RTKVE1_DUMP_BS_EN
-#if defined(RTKVE1_DUMP_BS_EN)
-static int gBsDumpSerial = 0;
-#endif
-
-//#define RTKVE1_DUMP_YUV_EN
-#if defined(RTKVE1_DUMP_YUV_EN)
-//#define VE1_TEST_DUMP_YUV_FRAME_NUM 30
-static int gYuvDumpSerial = 0;
-#endif
-
-#include <linux/dma-map-ops.h>
-#include <soc/realtek/memory.h>
-
-#define IS_4K(w, h) (((w) * (h)) > (3200 * 1800))
-#define MAX_CHUNK_HEADER_SIZE                                                  \
-	256 * 1024 //DEFAULT_STREAMBUFFER_SIZE //Fuchun 20131225 don't need big size
-#define MAKE_FOURCC(a, b, c, d)                                                \
-	(((unsigned char)a) | ((unsigned char)b << 8) |                        \
-	 ((unsigned char)c << 16) | ((unsigned char)d << 24))
-
-#define EXTRA_DEC_PIC_BUF 2
-
-extern void rtkve1_add_displayble_frame_to_list(struct ve1_ctx *ctx);
-extern void ve1_show_displayable_frame_list(struct ve1_ctx *ctx);
-#if defined(ENABLE_TEE_DRM_FLOW)
-extern int ta_TEEapi_memcpy_a7(struct tee_context *teeapi_ctx,
-			       unsigned int teeapi_tee_session,
-			       unsigned int dstPAddr, unsigned char *buf,
-			       int size);
-extern int ta_TEEapi_memcpy(struct tee_context *teeapi_ctx,
-			    unsigned int teeapi_tee_session,
-			    unsigned int dstPhysAddr, unsigned int srtPhysAddr,
-			    int size);
-#endif
-extern int ta_TEEapi_OMX_CC_API(struct tee_context *teeapi_ctx,
-				unsigned int teeapi_tee_session,
-				unsigned int src_addr, unsigned char *dst_addr,
-				unsigned int size, unsigned int codec_type,
-				unsigned int mode);
-
-extern unsigned int vpu_debug;
-
-enum { H264_PIC_STRUCT_FRAME,
-       H264_PIC_STRUCT_TOP_FIELD,
-       H264_PIC_STRUCT_BOTTOM_FIELD,
-       H264_PIC_STRUCT_TOP_BOTTOM,
-       H264_PIC_STRUCT_BOTTOM_TOP,
-       H264_PIC_STRUCT_TOP_BOTTOM_TOP,
-       H264_PIC_STRUCT_BOTTOM_TOP_BOTTOM,
-       H264_PIC_STRUCT_FRAME_DOUBLING,
-       H264_PIC_STRUCT_FRAME_TRIPLING } VE1_H264_PIC_STRUCT;
-
-char *GetGitVersion(void)
-{
-#if defined(VPUAPIGITVER)
-	return (char *)VPUAPIGITVER;
-#else
-	return NULL;
-#endif
-}
-
-#ifdef VPU_GET_CC
-int ParseUserDataInfo(USER_DATA_INFO *pUserDataInfo, char *pUserDataBuf)
-{
-	char *pTmpBuf = NULL;
-	int ret = 0, i, offset;
-
-	pTmpBuf = pUserDataBuf;
-	pUserDataInfo->nUserDataNum =
-		(short)((pTmpBuf[0] << 8) | (pTmpBuf[1] << 0));
-	pUserDataInfo->nTotalUserDataSize =
-		(short)((pTmpBuf[2] << 8) | (pTmpBuf[3] << 0));
-	pTmpBuf = pUserDataBuf + 8;
-	for (i = 0, offset = USER_DATA_INFO_OFFSET;
-	     i < pUserDataInfo->nUserDataNum; ++i, pTmpBuf += 8) {
-		pUserDataInfo->nUserDataType[i] =
-			(short)((pTmpBuf[0] << 8) | (pTmpBuf[1] << 0));
-		pUserDataInfo->nUserDataSize[i] =
-			(short)((pTmpBuf[2] << 8) | (pTmpBuf[3] << 0));
-		pUserDataInfo->nUserDataOffset[i] = offset;
-
-		offset += (pUserDataInfo->nUserDataSize[i] + 7) / 8 * 8;
-		ret++;
-	}
-	return ret;
-}
-
-#define CC_MAGIC_NUMBER 0x01020304
-#define SEI_USER_DATA_REGISTERED_ITU_T_T35 4 //temp define
-#define itu_t_t35_country_code 181
-
-void FindH264CCInUserData(USER_DATA_INFO *pUserDataInfo, char *pUserDataBuf,
-			  long long PTS, char *dst)
-{
-	int i;
-	char *pCCdata = NULL;
-	short itu_t_t35_provider_code;
-	unsigned int nUserDataSize = 0;
-	int offset = 0;
-	int dst_offset = 72;
-	int magic = CC_MAGIC_NUMBER;
-	int packet_num = 0;
-	int *header = (int *)dst;
-
-	for (i = 0; i < pUserDataInfo->nUserDataNum; ++i) {
-		if (pUserDataInfo->nUserDataType[i] ==
-		    SEI_USER_DATA_REGISTERED_ITU_T_T35) {
-			pCCdata = (pUserDataBuf +
-				   pUserDataInfo->nUserDataOffset[i]);
-			if (pCCdata[0] != itu_t_t35_country_code) {
-				ve1_err(VE1_WRAPPER_TAG,
-					"[H264 CC] ERR @ %s %d\n", __func__,
-					__LINE__);
-				continue;
-			}
-			itu_t_t35_provider_code =
-				(short)((pCCdata[1] << 8) |
-					(pCCdata[2])); // ARM is little-endian
-
-			switch (itu_t_t35_provider_code) {
-			case 47: // Direct TV
-				if (pCCdata[3] == 3) {
-					int *packet_start = (int *)dst;
-					unsigned int *pCCValue =
-						(unsigned int *)(dst +
-								 dst_offset);
-
-					offset = pUserDataInfo
-							 ->nUserDataOffset[i] +
-						 2;
-					nUserDataSize =
-						pUserDataInfo->nUserDataSize[i] -
-						2;
-					packet_start[3 + packet_num] =
-						dst_offset;
-					pCCValue[0] = RTK_CC_SYNC;
-					pCCValue[1] = nUserDataSize;
-					dst_offset += 16;
-					memcpy(dst + dst_offset,
-					       pUserDataBuf + offset,
-					       nUserDataSize);
-					dst_offset += nUserDataSize;
-					packet_num++;
-				}
-				break;
-			case 49: // ATSC
-				if (pCCdata[3] == 'G' && pCCdata[4] == 'A' &&
-				    pCCdata[5] == '9' && pCCdata[6] == '4' &&
-				    pCCdata[7] == 3) {
-					int *packet_start = (int *)dst;
-					unsigned int *pCCValue =
-						(unsigned int *)(dst +
-								 dst_offset);
-
-					offset = pUserDataInfo
-							 ->nUserDataOffset[i] +
-						 3;
-					nUserDataSize =
-						pUserDataInfo->nUserDataSize[i] -
-						3;
-					packet_start[3 + packet_num] =
-						dst_offset;
-					pCCValue[0] = RTK_CC_SYNC;
-					pCCValue[1] = nUserDataSize;
-					dst_offset += 16;
-					memcpy(dst + dst_offset,
-					       pUserDataBuf + offset,
-					       nUserDataSize);
-					dst_offset += nUserDataSize;
-					packet_num++;
-				}
-				break;
-			default:
-				break;
-			}
-		}
-	}
-
-	header = (int *)dst;
-	header[0] = magic;
-	header[1] = dst_offset;
-	header[2] = packet_num;
-}
-
-void FindMpeg2CCInUserData(USER_DATA_INFO *pUserDataInfo, char *pUserDataBuf,
-			   long long PTS, char *dst)
-{
-	int i;
-	char *p = NULL;
-	unsigned int nUserDataSize = 0;
-	int offset = 0;
-	int dst_offset = 72;
-	int magic = CC_MAGIC_NUMBER;
-	int packet_num = 0;
-	bool have_ga94 = false;
-	int *header = (int *)dst;
-
-	for (i = 0; i < pUserDataInfo->nUserDataNum; ++i) {
-		p = pUserDataBuf + pUserDataInfo->nUserDataOffset[i];
-		if (p[0] == 'G' && p[1] == 'A' && p[2] == '9' && p[3] == '4') {
-			have_ga94 = true;
-		}
-	}
-
-	for (i = 0; i < pUserDataInfo->nUserDataNum; ++i) {
-		p = pUserDataBuf + pUserDataInfo->nUserDataOffset[i];
-
-		if (p[0] == 'G' && p[1] == 'A' && p[2] == '9' && p[3] == '4') {
-			int *packet_start = (int *)dst;
-			unsigned int *pCCValue =
-				(unsigned int *)(dst + dst_offset);
-
-			offset = pUserDataInfo->nUserDataOffset[i];
-			nUserDataSize = pUserDataInfo->nUserDataSize[i];
-			packet_start[3 + packet_num] = dst_offset;
-			pCCValue[0] = RTK_CC_SYNC;
-			pCCValue[1] = nUserDataSize;
-			dst_offset += 16;
-			memcpy(dst + dst_offset, pUserDataBuf + offset,
-			       nUserDataSize);
-			dst_offset += nUserDataSize;
-			packet_num++;
-
-		} else if (p[0] == 0x03 && (p[1] & 0x7f) == 0x01) {
-			if (have_ga94 == false) {
-				int *packet_start = (int *)dst;
-				unsigned int *pCCValue =
-					(unsigned int *)(dst + dst_offset);
-
-				offset = pUserDataInfo->nUserDataOffset[i];
-				nUserDataSize = pUserDataInfo->nUserDataSize[i];
-				packet_start[3 + packet_num] = dst_offset;
-				pCCValue[0] = RTK_CC_SYNC;
-				pCCValue[1] = nUserDataSize;
-				dst_offset += 16;
-				memcpy(dst + dst_offset, pUserDataBuf + offset,
-				       nUserDataSize);
-				dst_offset += nUserDataSize;
-				packet_num++;
-			}
-		}
-	}
-
-	header = (int *)dst;
-	header[0] = magic;
-	header[1] = dst_offset;
-	header[2] = packet_num;
-}
-
-int ProcessCC(struct ve1_ctx *ctx, unsigned char *cc_buf, unsigned int cc_size,
-	      long long PTS, int decode_index, int display_index,
-	      int codec_type)
-{
-	if (display_index >= MPEG2_CC_REG_FRAME_MAX) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"display_index is overflow!!! display_index %d > %d\n",
-			display_index, MPEG2_CC_REG_FRAME_MAX);
-		return -1;
-	}
-
-	if (!cc_size)
-		return 0;
-
-	if (ctx->is_svp) {
-		DecHandle decHandle = NULL;
-
-		if (ctx->decHandle == NULL) {
-			ve1_err(VE1_WRAPPER_TAG, "decHandle == NULL\n");
-			return -1;
-		}
-		decHandle = (DecHandle)ctx->decHandle;
-
-		if (decode_index >= 0 &&
-		    ctx->m_CCDecodeOrderWp[decode_index] != NULL) {
-			if (ta_TEEapi_OMX_CC_API(
-				    (struct tee_context *)decHandle->teeapi_ctx,
-				    decHandle->teeapi_tee_session,
-				    ctx->userDataBufPhysAddr,
-				    ctx->m_CCDecodeOrderWp[decode_index],
-				    USER_DATA_SRC_BUF_SIZE, codec_type,
-				    ENUM_CC_P) < 0) {
-				ve1_err(VE1_WRAPPER_TAG,
-					"In[%s][%d] ta_TEEapi_OMX_CC_API fail!!",
-					__func__, __LINE__);
-			}
-		}
-	} else {
-		USER_DATA_INFO nUserDataInfo;
-		ParseUserDataInfo(&nUserDataInfo, (char *)cc_buf);
-		switch (codec_type) {
-		case ENUM_CC_MPGE2:
-			FindMpeg2CCInUserData(
-				&nUserDataInfo, (char *)cc_buf, PTS,
-				ctx->m_CCDecodeOrderWp[decode_index]);
-			break;
-		case ENUM_CC_H264:
-			FindH264CCInUserData(
-				&nUserDataInfo, (char *)cc_buf, PTS,
-				ctx->m_CCDecodeOrderWp[decode_index]);
-			break;
-		default:
-			break;
-		}
-	}
-
-	return 0;
-}
-
-void ProcessCC_Display(void *pCtx, long long PTS,
-		       int display_index) //send CC to AP
-{
-	struct ve1_ctx *ctx;
-	int i;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (display_index >= 0 &&
-	    ctx->m_CCDecodeOrderWp[display_index] != NULL) {
-		int *header = (int *)ctx->m_CCDecodeOrderWp[display_index];
-
-		if (cc_isCCInit()) {
-			ve1_err(VE1_WRAPPER_TAG, " cc_isCCInit = false/n");
-			cc_data_channel_init();
-		}
-		// send data back to AP via fifo
-		if (cc_isCCReaderReady()) {
-			int total_size;
-			long long *pRTKHeader;
-			char *check;
-
-			if (header[0] != CC_MAGIC_NUMBER) {
-				return;
-			}
-
-			total_size = header[1] - 72;
-			if (total_size <= 0) {
-				ve1_err(VE1_WRAPPER_TAG,
-					"get wrong cc header - magic:%x size:%d packet_num:%d\n",
-					header[0], header[1], header[2]);
-				return;
-			}
-
-			for (i = 0; i < header[2]; i++) {
-				int offset = header[3 + i];
-
-				if (offset >
-				    USER_DATA_SRC_BUF_SIZE -
-					    RTK_CC_HEADER_SIZE) { //USER_DATA_SRC_BUF_SIZE
-					if ((ctx->cc_error_count % 100) == 0) {
-						ve1_err(VE1_WRAPPER_TAG,
-							"MPEG2 cc get wrong offset:%d index:%d\n",
-							offset, i);
-					}
-					ctx->cc_error_count++;
-					return;
-				}
-
-				pRTKHeader =
-					(long long *)(ctx->m_CCDecodeOrderWp
-							      [display_index] +
-						      offset);
-				pRTKHeader[1] = PTS;
-			}
-
-			check = ctx->m_CCDecodeOrderWp[display_index] + 72;
-			if (check[0] == 0x63 && check[1] == 0x4b &&
-			    check[2] == 0x74 && check[3] == 0x52) {
-				cc_data_channel_send(
-					ctx->m_CCDecodeOrderWp[display_index] +
-						72,
-					total_size, cc_getCCReaderPid());
-			}
-		}
-		// reset rtk header
-		for (i = 0; i < RTK_CC_HEADER_SIZE + 72; i++)
-			ctx->m_CCDecodeOrderWp[display_index][i] = 0;
-	}
-}
-#endif //defined(VPU_GET_CC)
-
-#if defined(VE1_CHECK_DFB_MD5_EN) || defined(VE1_CHECK_USERDATA_MD5_EN)
-int ve1_md5_hash(unsigned char *result, int resultLen, char *data, int dataLen)
-{
-	int ret = 0;
-	struct crypto_shash *tfm = NULL;
-	struct shash_desc *desc = NULL;
-
-	if ((result == NULL) || (resultLen <= 0) || (data == NULL) ||
-	    (dataLen <= 0)) {
-		return -1;
-	}
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "data:0x%px.dataLen:%d\n", data,
-		dataLen);
-	memset(result, 0, resultLen);
-
-	tfm = crypto_alloc_shash("md5", 0, 0);
-	if (IS_ERR(tfm)) {
-		tfm = NULL;
-		ve1_err(VE1_WRAPPER_TAG, "IS_ERR(tfm)\n");
-		ret = -1;
-		goto out;
-	}
-
-	desc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
-	if (desc == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "kmalloc desc fail\n");
-		ret = -1;
-		goto out;
-	}
-
-	desc->tfm = tfm;
-
-	if (crypto_shash_init(desc) < 0) {
-		ve1_err(VE1_WRAPPER_TAG, "crypto_shash_init() fail\n");
-		ret = -1;
-		goto out;
-	}
-	//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "crypto_shash_init() ok\n");
-
-	if (crypto_shash_update(desc, data, dataLen) < 0) {
-		ve1_err(VE1_WRAPPER_TAG, "crypto_shash_update() fail\n");
-		ret = -1;
-		goto out;
-	}
-	//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "crypto_shash_update() ok\n");
-
-	if (crypto_shash_final(desc, result) < 0) {
-		ve1_err(VE1_WRAPPER_TAG, "crypto_shash_final() fail\n");
-		ret = -1;
-		goto out;
-	}
-	//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "crypto_shash_final() ok\n");
-
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-		result[0], result[1], result[2], result[3], result[4],
-		result[5], result[6], result[7], result[8], result[9],
-		result[10], result[11], result[12], result[13], result[14],
-		result[15]);
-out:
-	if (desc) {
-		kfree(desc);
-	}
-	if (tfm) {
-		crypto_free_shash(tfm);
-	}
-
-	return ret;
-}
-#endif // #if defined(VE1_CHECK_DFB_MD5_EN)
-
-void rtkve1_recycle_dpb(struct ve1_ctx *ctx)
-{
-	int i = 0;
-	struct rtkve1_dpb_t *dpb = NULL;
-
-	if (ctx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx == NULL\n");
-		return;
-	}
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
-		return;
-	}
-
-	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
-		dpb = &(ctx->dpb[i]);
-		if (IS_RTKVE1_DPB_VALID(dpb->status) && IS_RTKVE1_DPB_WAIT_RECYCLE(dpb->status)) {
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"i:%d.status:0x%x\n",
-				i,dpb->status);
-			dpb->status &= ~RTKVE1_DPB_ST_WAIT_RECYCLE;
-			if (dpb->regIndex < ctx->regFbCount) {
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"VPU_DecClrDispFlag(%d).phys_addr:0x%lx\n",
-					dpb->regIndex, dpb->phys_addr);
-				VPU_DecClrDispFlag((DecHandle)ctx->decHandle, dpb->regIndex);
-			}
-			else {
-				ve1_err(VE1_WRAPPER_TAG,
-					"invalid dpb regIndex:%d, not recycle.phys_addr:0x%lx\n",
-					dpb->regIndex, dpb->phys_addr);
-			}
-		}
-	}
-}
-
-int rtkve1_add_capbuf_to_dpb(void *pCtx, unsigned long size,
-			     unsigned long phys_addr, void *vb2_v4l2_buf)
-{
-	int ret = -1;
-
-	struct ve1_ctx *ctx;
-	int i = 0;
-
-	if ((pCtx == NULL) || (size == 0) || (phys_addr == 0) ||
-	    (vb2_v4l2_buf == NULL)) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"invalid parameters.pCtx:0x%px.size:%ld.phys_addr:0x%lx.vb2_v4l2_buf:0x%px\n",
-			pCtx, size, phys_addr, vb2_v4l2_buf);
-		return ret;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	mutex_lock(&ctx->ve1_dma_mutex);
-	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
-		if (IS_RTKVE1_DPB_EMPTY(ctx->dpb[i].status)) {
-			break;
-		}
-	}
-	if (i == VE1_ION_STRUCT_NUM) {
-		ve1_err(VE1_WRAPPER_TAG, "all ctx->dpb[] are used\n");
-		mutex_unlock(&ctx->ve1_dma_mutex);
-		return ret;
-	}
-	ctx->dpb[i].size = size;
-	ctx->dpb[i].status |= RTKVE1_DPB_ST_VALID;
-	ctx->dpb[i].phys_addr = phys_addr;
-	ctx->dpb[i].vb2_v4l2_buf = vb2_v4l2_buf;
-	ctx->cntCap2Dpb++;
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"add capbuf to dpb[%d].phys_addr:0x%lx.size:%u.vb2_v4l2_buf:0x%px.cntCap2Dpb:%d\n",
-		i, ctx->dpb[i].phys_addr, ctx->dpb[i].size,
-		ctx->dpb[i].vb2_v4l2_buf, ctx->cntCap2Dpb);
-	ret = i;
-	mutex_unlock(&ctx->ve1_dma_mutex);
-
-	return ret;
-}
-
-void *rtkve1_find_dpb_unreg(void *pCtx)
-{
-	int i = 0;
-	struct ve1_ctx *ctx;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return NULL;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
-		if (IS_RTKVE1_DPB_VALID(ctx->dpb[i].status) &&
-			!IS_RTKVE1_DPB_REG(ctx->dpb[i].status)) {
-				return (void *)&(ctx->dpb[i]);
-		}
-	}
-
-	return NULL;
-}
-
-void *rtkve1_find_dpb_undequeue(void *pCtx)
-{
-	int i = 0;
-	struct ve1_ctx *ctx;
-	struct rtkve1_dpb_t *dpb = NULL;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return NULL;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
-		if (IS_RTKVE1_DPB_VALID(ctx->dpb[i].status) &&
-			IS_RTKVE1_DPB_REG(ctx->dpb[i].status) &&
-			!IS_RTKVE1_DPB_DQ(ctx->dpb[i].status)) {
-				dpb = &(ctx->dpb[i]);
-		}
-	}
-
-	return (void *)dpb;
-}
-
-void rtkve1_show_dpbs(struct ve1_ctx *ctx)
-{
-	int i = 0;
-
-	if (ctx == NULL) {
-		return;
-	}
-
-	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
-		if (ctx->dpb[i].size == 0) {
-			continue;
-		}
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			"dpb[%d].status:0x%x.size:%d.phys_addr:0x%lx.vb2_v4l2_buf:0x%px.regIndex:%d\n",i,
-			ctx->dpb[i].status, ctx->dpb[i].size,
-			ctx->dpb[i].phys_addr,
-			ctx->dpb[i].vb2_v4l2_buf,
-			ctx->dpb[i].regIndex);
-	}
-}
-
-int rtkve1_register_dpbs(void *pCtx)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	struct ve1_ctx *ctx;
-	int i = 0;
-	DecOpenParam *decOP;
-	DecInitialInfo *initialInfo;
-	int mapType = LINEAR_FRAME_MAP;
-	int fbHeight;
-	int fbStride;
-	FrameBufferFormat fbFormat;
-	FrameBufferFormat wtlFormat;
-	FrameBufferAllocInfo *fbAllocInfo;
-	FrameBuffer *fbUser;
-	struct rtkve1_dpb_t *dpb_unreg = NULL;
-	unsigned int dispFlag = 0;
-	unsigned int clearDispIndex = 0;
-	SecAxiUse *secAxiUse;
-	MaverickCacheConfig *decCacheConfig;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"invalid parameters.pCtx:0x%px\n",
-			pCtx);
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
-		return -1;
-	}
-
-	if (ctx->fbAllocInfo == NULL) {
-		ctx->fbAllocInfo =
-			kzalloc(sizeof(FrameBufferAllocInfo), GFP_KERNEL);
-		if (ctx->fbAllocInfo == NULL) {
-			ve1_err(VE1_WRAPPER_TAG, "kzalloc fbAllocInfo fail\n");
-			return -1;
-		}
-	}
-
-	if (ctx->fbUser == NULL) {
-		ctx->fbUser = kzalloc(sizeof(FrameBuffer) * MAX_REG_FRAME,
-				      GFP_KERNEL);
-		if (ctx->fbUser == NULL) {
-			ve1_err(VE1_WRAPPER_TAG, "kzalloc fbUser fail\n");
-			return -1;
-		}
-	}
-
-	decOP = (DecOpenParam *)ctx->decOP;
-	initialInfo = (DecInitialInfo *)ctx->initialInfo;
-	fbAllocInfo = (FrameBufferAllocInfo *)ctx->fbAllocInfo;
-
-	fbFormat = FORMAT_420;
-	wtlFormat = FORMAT_420;
-
-	if ((mapType == TILED_FRAME_V_MAP) && (decOP->wtlEnable == 0) &&
-	    (decOP->tiled2LinearEnable == 0)) {
-		// trace VPU_GetFrameBufSize -> ProductCalculateFrameBufSize -> CalcLumaSize
-		// if TILED_FRAME_V_MAP and CODA980, VPU force use 64 align to calculate the frame buffer height (unit_size_ver_lum),
-		// it will influence the U_addr of YUV_STATE
-		fbHeight = VPU_ALIGN64(initialInfo->picHeight);
-	} else {
-		fbHeight = VPU_ALIGN32(initialInfo->picHeight);
-	}
-	fbStride = CalcStride(initialInfo->picWidth, initialInfo->picHeight,
-			      fbFormat, decOP->cbcrInterleave,
-			      (TiledMapType)mapType, 0);
-	ctx->framebufSize =
-		VPU_GetFrameBufSize(VE1_COREIDX, fbStride, fbHeight, mapType,
-				    fbFormat, decOP->cbcrInterleave, NULL);
-	ve1_info(
-		VE1_WRAPPER_TAG,
-		"af VPU_GetFrameBufSize().framebufSize:%d.fbStride:%d.fbHeight:%d.mapType:%d\n",
-		ctx->framebufSize, fbStride, fbHeight, mapType);
-
-	if (fbHeight == 0 || fbStride == 0 || ctx->framebufSize == 0) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"incorrect fbHeight:%d.fbStride:%d.framebufSize:%d\n",
-			fbHeight, fbStride, ctx->framebufSize);
-		return -1;
-	}
-
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"cntCap2Dpb:%d.capReqBufsCnt:%d.regFbCount:%d\n",
-			ctx->cntCap2Dpb, ctx->capReqBufsCnt, ctx->regFbCount);
-
-	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
-		if ((ctx->dpb[i].size > 0) &&
-			(!IS_RTKVE1_DPB_REG(ctx->dpb[i].status)) &&
-			(ctx->dpb[i].size < ctx->framebufSize)) {
-			ve1_err(VE1_WRAPPER_TAG,
-				"dpb[%d].size:%u < expected framebufSize:%d\n",
-				i,ctx->dpb[i].size,
-				ctx->framebufSize);
-			WARN_ON(1);
-			return -1;
-		}
-	}
-
-	fbAllocInfo->format = fbFormat;
-	fbAllocInfo->cbcrInterleave = decOP->cbcrInterleave;
-	fbAllocInfo->mapType = mapType;
-	fbAllocInfo->stride = fbStride;
-	fbAllocInfo->height = fbHeight;
-	fbAllocInfo->lumaBitDepth = initialInfo->lumaBitdepth;
-	fbAllocInfo->chromaBitDepth = initialInfo->chromaBitdepth;
-	fbAllocInfo->num = ctx->capReqBufsCnt;
-	fbAllocInfo->endian = decOP->frameEndian;
-	fbAllocInfo->type = FB_TYPE_CODEC;
-
-	mutex_lock(&ctx->ve1_dma_mutex);
-	for (i = 0; i < ctx->capReqBufsCnt; i++) {
-		dpb_unreg = (struct rtkve1_dpb_t *)rtkve1_find_dpb_unreg((void *)ctx);
-		if (dpb_unreg == NULL) {
-			break;
-		}
-		fbUser = ((FrameBuffer *)ctx->fbUser) + i;
-		dpb_unreg->regIndex = i;
-		dpb_unreg->status |= RTKVE1_DPB_ST_REG;
-		fbUser->size = dpb_unreg->size;
-		fbUser->bufY = dpb_unreg->phys_addr;
-		fbUser->bufCb = -1;
-		fbUser->bufCr = -1;
-		fbUser->updateFbInfo = TRUE;
-		ctx->regFbCount++;
-		clearDispIndex |= (1<<i);
-		dispFlag = ~clearDispIndex;
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			"regFbCount:%d.dispFlag:0x%x\n",
-			ctx->regFbCount,dispFlag);
-	}
-	mutex_unlock(&ctx->ve1_dma_mutex);
-
-	ret = VPU_DecAllocateFrameBuffer((DecHandle)ctx->decHandle,
-					 *((FrameBufferAllocInfo *)fbAllocInfo),
-					 (FrameBuffer *)ctx->fbUser);
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"af VPU_DecAllocateFrameBuffer.ret:%d\n", ret);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"VPU_DecAllocateFrameBuffer fail.ret:%d\n", ret);
-		return -1;
-	}
-	for (i = 0; i < ctx->capReqBufsCnt; i++) {
-		fbUser = ((FrameBuffer *)ctx->fbUser) + i;
-		ve1_info(
-			VE1_WRAPPER_TAG,
-			"fbUser[%d].bufY:0x%x.size:%d.myIndex:%d.stride:%d.h:%d.seqNo:%d\n",
-			i, fbUser->bufY, fbUser->size, fbUser->myIndex,
-			fbUser->stride, fbUser->height, ctx->currSequenceNo);
-	}
-
-	if (ctx->secAxiUse == NULL) {
-		ctx->secAxiUse = kzalloc(sizeof(SecAxiUse), GFP_KERNEL);
-		if (ctx->secAxiUse == NULL) {
-			ve1_err(VE1_WRAPPER_TAG, "kzalloc secAxiUse fail\n");
-			return -1;
-		}
-	}
-	secAxiUse = (SecAxiUse *)ctx->secAxiUse;
-	memset(secAxiUse, 0, sizeof(SecAxiUse));
-	secAxiUse->u.coda9.useBitEnable = USE_BIT_INTERNAL_BUF;
-	secAxiUse->u.coda9.useIpEnable = USE_IP_INTERNAL_BUF;
-	secAxiUse->u.coda9.useDbkYEnable = USE_DBKY_INTERNAL_BUF;
-	secAxiUse->u.coda9.useDbkCEnable = USE_DBKC_INTERNAL_BUF;
-	secAxiUse->u.coda9.useOvlEnable = USE_OVL_INTERNAL_BUF;
-	secAxiUse->u.coda9.useBtpEnable = USE_BTP_INTERNAL_BUF;
-	VPU_DecGiveCommand((DecHandle)ctx->decHandle, SET_SEC_AXI, secAxiUse);
-
-	if (ctx->decCacheConfig == NULL) {
-		ctx->decCacheConfig =
-			kzalloc(sizeof(MaverickCacheConfig), GFP_KERNEL);
-		if (ctx->decCacheConfig == NULL) {
-			ve1_err(VE1_WRAPPER_TAG,
-				"kzalloc decCacheConfig fail\n");
-			return -1;
-		}
-	}
-	decCacheConfig = (MaverickCacheConfig *)ctx->decCacheConfig;
-	MaverickCache2Config(decCacheConfig,
-			     TRUE, // decoder
-			     (BOOL)decOP->cbcrInterleave, 0, 0, 3,
-			     (TiledMapType)mapType, 15);
-	VPU_DecGiveCommand((DecHandle)ctx->decHandle, SET_CACHE_CONFIG,
-			   decCacheConfig);
-
-	fbStride =
-		CalcStride(initialInfo->picWidth, initialInfo->picHeight,
-			fbFormat, decOP->cbcrInterleave,
-			(decOP->wtlEnable == TRUE ? LINEAR_FRAME_MAP :
-			(TiledMapType)(mapType)),
-			0);
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"fbStride:%d.fbFormat:%d.mapType:%d\n", fbStride, fbFormat,
-		mapType);
-
-	ret = VPU_DecRegisterFrameBuffer((DecHandle)ctx->decHandle,
-					 (FrameBuffer *)ctx->fbUser,
-					 ctx->capReqBufsCnt, fbStride, fbHeight,
-					 mapType);
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"af VPU_DecRegisterFrameBuffer.ret:%d\n", ret);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"VPU_DecRegisterFrameBuffer fail.ret:%d\n", ret);
-		return -1;
-	}
-
-	ret = VPU_DecSetDispFlag((DecHandle)ctx->decHandle, dispFlag);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"VPU_DecSetDispFlag fail.ret:%d\n", ret);
-		return -1;
-	}
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"VPU_DecSetDispFlag.dispFlag:0x%x\n", dispFlag);
-
-	return ret;
-}
-
-int rtkve1_register_new_dpb(void *pCtx, void* pDpb)
-{
-	int ret = 0;
-	struct ve1_ctx *ctx;
-	DecOpenParam *decOP;
-	DecInitialInfo *initialInfo;
-	int mapType = LINEAR_FRAME_MAP;
-	int fbHeight;
-	int fbStride;
-	FrameBufferFormat fbFormat;
-	FrameBufferFormat wtlFormat;
-	FrameBufferAllocInfo *fbAllocInfo;
-	FrameBuffer *fbUser;
-	struct rtkve1_dpb_t *dpb = NULL;
-	unsigned int clrDispFlagIndex = 0;
-	unsigned long clrDispFlagPhysAddr = 0;
-
-	if ((pCtx == NULL) || (pDpb == NULL)) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"invalid parameters.pCtx:0x%px.pDpb:0x%px\n",
-			pCtx,pDpb);
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-	dpb = (struct rtkve1_dpb_t *)pDpb;
-
-	if ((ctx->decHandle == NULL) || (ctx->fbAllocInfo == NULL) || (ctx->fbUser == NULL)) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"ctx->decHandle == NULL || ctx->fbAllocInfo == NULL || ctx->fbUser == NULL\n");
-		return -1;
-	}
-
-	decOP = (DecOpenParam *)ctx->decOP;
-	initialInfo = (DecInitialInfo *)ctx->initialInfo;
-	fbAllocInfo = (FrameBufferAllocInfo *)ctx->fbAllocInfo;
-
-	fbFormat = FORMAT_420;
-	wtlFormat = FORMAT_420;
-
-	if ((mapType == TILED_FRAME_V_MAP) && (decOP->wtlEnable == 0) &&
-		(decOP->tiled2LinearEnable == 0)) {
-		// trace VPU_GetFrameBufSize -> ProductCalculateFrameBufSize -> CalcLumaSize
-		// if TILED_FRAME_V_MAP and CODA980, VPU force use 64 align to calculate the frame buffer height (unit_size_ver_lum),
-		// it will influence the U_addr of YUV_STATE
-		fbHeight = VPU_ALIGN64(initialInfo->picHeight);
-	} else {
-		fbHeight = VPU_ALIGN32(initialInfo->picHeight);
-	}
-	fbStride = CalcStride(initialInfo->picWidth, initialInfo->picHeight,
-				fbFormat, decOP->cbcrInterleave,
-				(TiledMapType)mapType, 0);
-
-	if (fbHeight == 0 || fbStride == 0) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"incorrect fbHeight:%d.fbStride:%d.framebufSize:%d\n",
-			fbHeight, fbStride, ctx->framebufSize);
-		return -1;
-	}
-
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"cntCap2Dpb:%d.capReqBufsCnt:%d.regFbCount:%d\n",
-		ctx->cntCap2Dpb, ctx->capReqBufsCnt, ctx->regFbCount);
-
-	if (dpb->size < ctx->framebufSize) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"dpb.size:%u < expected framebufSize:%d\n",
-			dpb->size,
-			ctx->framebufSize);
-		WARN_ON(1);
-		return -1;
-	}
-
-	mutex_lock(&ctx->ve1_dma_mutex);
-	dpb->regIndex = ctx->regFbCount;
-	dpb->status |= RTKVE1_DPB_ST_REG;
-	fbUser = ((FrameBuffer *)ctx->fbUser) + ctx->regFbCount;
-	fbUser->size = dpb->size;
-	fbUser->bufY = dpb->phys_addr;
-	fbUser->bufCb = -1;
-	fbUser->bufCr = -1;
-	fbUser->updateFbInfo = TRUE;
-	clrDispFlagIndex = ctx->regFbCount;
-	clrDispFlagPhysAddr = dpb->phys_addr;
-	ctx->regFbCount++;
-	mutex_unlock(&ctx->ve1_dma_mutex);
-
-	ret = VPU_DecAllocateFrameBuffer((DecHandle)ctx->decHandle,
-			*((FrameBufferAllocInfo *)fbAllocInfo),
-			(FrameBuffer *)ctx->fbUser);
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"af VPU_DecAllocateFrameBuffer.ret:%d\n", ret);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"VPU_DecAllocateFrameBuffer fail.ret:%d\n", ret);
-		return -1;
-	}
-	ve1_info(
-		VE1_WRAPPER_TAG,
-		"fbUser[%d].bufY:0x%x.size:%d.myIndex:%d.stride:%d.h:%d.seqNo:%d\n",
-		(ctx->regFbCount-1), fbUser->bufY, fbUser->size, fbUser->myIndex,
-		fbUser->stride, fbUser->height, ctx->currSequenceNo);
-
-	ret = VPU_DecRegisterFrameBuffer((DecHandle)ctx->decHandle,
-			(FrameBuffer *)ctx->fbUser,
-			ctx->capReqBufsCnt, fbStride, fbHeight,
-			mapType);
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"af VPU_DecRegisterFrameBuffer.ret:%d\n", ret);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"VPU_DecRegisterFrameBuffer fail.ret:%d\n", ret);
-		return -1;
-	}
-
-	ret = VPU_DecClrDispFlag((DecHandle)ctx->decHandle, clrDispFlagIndex);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"VPU_DecClrDispFlag fail.ret:%d\n", ret);
-		return -1;
-	}
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"VPU_DecClrDispFlag(%d).phys_addr:0x%lx\n",
-		clrDispFlagIndex, clrDispFlagPhysAddr);
-
-	return ret;
-}
-
-int rtkve1_check_new_dpb(void *pCtx)
-{
-	int ret = 0;
-	struct ve1_ctx *ctx;
-	struct rtkve1_dpb_t *dpb_unreg = NULL;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"invalid parameters.pCtx:0x%px\n",
-			pCtx);
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	do {
-		mutex_lock(&ctx->ve1_dma_mutex);
-		dpb_unreg = (struct rtkve1_dpb_t *)rtkve1_find_dpb_unreg((void *)ctx);
-		mutex_unlock(&ctx->ve1_dma_mutex);
-		if (dpb_unreg == NULL) {
-			break;
-		}
-		ret = rtkve1_register_new_dpb(pCtx, dpb_unreg);
-		if (ret != 0) {
-			ve1_err(VE1_WRAPPER_TAG,
-				"rtkve1_register_new_dpb() fail.ret:%d\n",
-				ret);
-			break;
-		}
-	} while (1);
-
-	return ret;
-}
-
-void rtkve1_flush_dpbs(void *pCtx)
-{
-	struct ve1_ctx *ctx;
-	int i = 0;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "invalid parameters.pCtx:0x%px\n",
-			pCtx);
-		return;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	mutex_lock(&ctx->ve1_dma_mutex);
-	//rtkve1_show_dpbs(ctx);
-	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
-		if (!IS_RTKVE1_DPB_DQ(ctx->dpb[i].status) &&
-		    IS_RTKVE1_DPB_VALID(ctx->dpb[i].status)) {
-			if ((ctx->lastDoneCapBuf == NULL) ||
-				((ctx->lastDoneCapBuf != NULL) && (ctx->dpb[i].vb2_v4l2_buf != ctx->lastDoneCapBuf))) {
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"v4l2_m2m_buf_done.vb2_v4l2_buf:0x%px.phys_addr:0x%lx\n",
-					ctx->dpb[i].vb2_v4l2_buf,
-					ctx->dpb[i].phys_addr);
-				v4l2_m2m_buf_done((struct vb2_v4l2_buffer
-							*)(ctx->dpb[i].vb2_v4l2_buf),
-						VB2_BUF_STATE_ERROR);
-			}
-		}
-		else if (IS_RTKVE1_DPB_DQ(ctx->dpb[i].status)) {
-			ctx->dpb[i].status &= ~RTKVE1_DPB_ST_DQ;
-		}
-		if (IS_RTKVE1_DPB_WAIT_RECYCLE(ctx->dpb[i].status)) {
-			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			//	"clear wait recycle status.regIndex:%d.vb2_v4l2_buf:0x%px.phys_addr:0x%lx\n",
-			//	ctx->dpb[i].regIndex,
-			//	ctx->dpb[i].vb2_v4l2_buf,
-			//	ctx->dpb[i].phys_addr);
-			ctx->dpb[i].status &= ~RTKVE1_DPB_ST_WAIT_RECYCLE;
-		}
-	}
-	//rtkve1_show_dpbs(ctx);
-	mutex_unlock(&ctx->ve1_dma_mutex);
-}
-
-int ve1_alloc_frame_buffer(void *pCtx, unsigned int size,
-			   unsigned long *phys_addr)
-{
-	int ret = -1;
-	struct ve1_ctx *ctx;
-
-	if ((pCtx == NULL) || (size == 0) || (phys_addr == NULL)) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"invalid parameters.pCtx:0x%px.size:%d.phys_addr:0x%px\n",
-			pCtx, size, phys_addr);
-		return ret;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	mutex_lock(&ctx->ve1_dma_mutex);
-	do {
-		int i = 0;
-		unsigned int flags = 0;
-		dma_addr_t dma_phys_addr = 0;
-		void *virt_addr = NULL;
-		ve1_mem_reg_entry_t *entry;
-
-		if (ctx->is_svp) {
-			flags = RTK_FLAG_NONCACHED | RTK_FLAG_HWIPACC |
-				RTK_FLAG_PROTECTED_V2_VO_POOL;
-		} else {
-			flags = RTK_FLAG_NONCACHED | RTK_FLAG_HWIPACC |
-				RTK_FLAG_SCPUACC;
-		}
-
-		for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
-			if (IS_RTKVE1_DPB_EMPTY(ctx->dpb[i].status)) {
-				break;
-			}
-		}
-		if (i == VE1_ION_STRUCT_NUM) {
-			ve1_err(VE1_WRAPPER_TAG,
-				"all ve1_ion_buffer[] are used\n");
-			break;
-		}
-
-		/* We can't limit the address from dma_alloc_coherent when size <= 4096 */
-		if (size < SZ_8K)
-			size = SZ_8K;
-
-		virt_addr = dma_alloc_coherent(ctx->pdev, PAGE_ALIGN(size),
-					       &dma_phys_addr,
-					       (GFP_DMA | GFP_KERNEL));
-		if (virt_addr == NULL) {
-			ve1_err(VE1_WRAPPER_TAG,
-				"dma_alloc_coherent() fail.size:%d(%d).flags:0x%x\n",
-				PAGE_ALIGN(size), size, flags);
-			break;
-		}
-		ctx->totIonAllocatedBytes += PAGE_ALIGN(size);
-
-		*phys_addr = (unsigned long)dma_phys_addr;
-
-		ctx->dpb[i].size = PAGE_ALIGN(size);
-		ctx->dpb[i].status |= RTKVE1_DPB_ST_VALID;
-		ctx->dpb[i].phys_addr = (unsigned long)*phys_addr;
-		ctx->dpb[i].virt_addr = (unsigned long)virt_addr;
-
-		// register dpb[i] to ve1_mem
-		entry = kzalloc(sizeof(ve1_mem_reg_entry_t), GFP_KERNEL);
-		if (entry) {
-			entry->dev = ctx->pdev;
-			entry->phys_addr = ctx->dpb[i].phys_addr;
-			entry->addr = (void *) ctx->dpb[i].virt_addr;
-			entry->size = ctx->dpb[i].size;
-			ve1_mem_reg_add(entry);
-			ctx->dpb[i].reg_entry = (void *)entry;
-		}
-
-		ret = i;
-		break;
-	} while (0);
-	mutex_unlock(&ctx->ve1_dma_mutex);
-
-	return ret;
-}
-
-void ve1_free_frame_buffer(void *pCtx, unsigned long phys_addr)
-{
-	struct ve1_ctx *ctx;
-
-	if ((pCtx == NULL) || (phys_addr == 0)) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"invalid parameters.pCtx:0x%px.phys_addr:0x%lx\n", pCtx,
-			phys_addr);
-		return;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	mutex_lock(&ctx->ve1_dma_mutex);
-	do {
-		int i = 0;
-
-		for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
-			if (ctx->dpb[i].phys_addr == phys_addr) {
-				break;
-			}
-		}
-		if (i == VE1_ION_STRUCT_NUM) {
-			ve1_err(VE1_WRAPPER_TAG,
-				"not find phys_addr:0x%lx in dpb\n", phys_addr);
-			break;
-		}
-
-		if (ctx->dpb[i].reg_entry) {
-			ve1_mem_reg_remove(phys_addr);
-			kfree(ctx->dpb[i].reg_entry);
-		}
-
-		if (ctx->dpb[i].virt_addr) {
-			dma_free_coherent(ctx->pdev, ctx->dpb[i].size,
-					  (void *)ctx->dpb[i].virt_addr,
-					  (dma_addr_t)phys_addr);
-			ctx->totIonAllocatedBytes -= ctx->dpb[i].size;
-		}
-
-		memset(&ctx->dpb[i], 0, sizeof(struct rtkve1_dpb_t));
-	} while (0);
-	mutex_unlock(&ctx->ve1_dma_mutex);
-}
-
-#ifdef VPU_GET_CC
-int ve1_enable_userdata(struct ve1_ctx *ctx)
-{
-	int ret = 0;
-	vpu_buffer_t vdb;
-	DecHandle decHandle = NULL;
-	DecOpenParam *pDecOp;
-
-	if (ctx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "invalid parameters.ctx:0x%px\n", ctx);
-		return VE1_DEC_RETURN_INVALID;
-	}
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "decHandle == NULL\n");
-		return -1;
-	}
-	decHandle = (DecHandle)ctx->decHandle;
-	pDecOp = (DecOpenParam *)ctx->decOP;
-
-	if (ctx->userDataBufPhysAddr == 0) {
-		unsigned int nBufSize =
-			USER_DATA_SRC_BUF_SIZE; //(pDecOp->bitstreamFormat == STD_MPEG2 ? VPU_CC_BUF_SIZE : MVC_USERDATA_BUF_SIZE);
-		unsigned int codec_type =
-			(pDecOp->bitstreamFormat == STD_MPEG2 ? ENUM_CC_MPGE2 :
-								ENUM_CC_H264);
-		memset(&vdb, 0, sizeof(vpu_buffer_t));
-		vdb.size = SIZE_REPORT_BUF;
-		vdb.req_spec_region = 0;
-		if (ctx->is_svp) {
-			vdb.req_spec_region = VE_SECURE_PROTECTION;
-		}
-
-		if (vdi_allocate_dma_memory(VE1_COREIDX, &vdb, ctx->filp) < 0) {
-			ve1_err(VE1_WRAPPER_TAG,
-				"vdi_allocate_dma_memory fail\n");
-			return VE1_DEC_RETURN_INVALID;
-		}
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			"vdi_allocate_dma_memory userdata(0x%lx,0x%lx,0x%lx,%d,%d)\n",
-			vdb.phys_addr, vdb.virt_addr, vdb.base, vdb.size,
-			vdb.req_spec_region);
-
-		ctx->userDataBufSize = vdb.size;
-		ctx->userDataBufPhysAddr = vdb.phys_addr;
-		ctx->pUserDataBufVirtAddr = (void *)vdb.virt_addr;
-		if (ctx->is_svp) {
-			ta_TEEapi_OMX_CC_API(
-				(struct tee_context *)decHandle->teeapi_ctx,
-				decHandle->teeapi_tee_session,
-				ctx->userDataBufPhysAddr, ctx->pUserDataSrcBuf,
-				nBufSize, codec_type, ENUM_CC_AU);
-			ta_TEEapi_OMX_CC_API(
-				(struct tee_context *)decHandle->teeapi_ctx,
-				decHandle->teeapi_tee_session,
-				ctx->userDataBufPhysAddr, ctx->pUserDataSrcBuf,
-				nBufSize, codec_type, ENUM_CC_S);
-		}
-	}
-
-	ctx->userDataEnable = 1;
-	ctx->userDataReportMode = 0;
-	VPU_DecGiveCommand(decHandle, SET_ADDR_REP_USERDATA,
-			   &ctx->userDataBufPhysAddr);
-	VPU_DecGiveCommand(decHandle, SET_SIZE_REP_USERDATA,
-			   &ctx->userDataBufSize);
-	VPU_DecGiveCommand(decHandle, SET_USERDATA_REPORT_MODE,
-			   &ctx->userDataReportMode);
-	VPU_DecGiveCommand(decHandle, ENABLE_REP_USERDATA, 0);
-	ve1_info(
-		VE1_WRAPPER_TAG,
-		"alloc & enable ve1 userdata(size:%d,phys:0x%x,virt:0x%px).tot:%d\n",
-		ctx->userDataBufSize, ctx->userDataBufPhysAddr,
-		ctx->pUserDataBufVirtAddr, ctx->totIonAllocatedBytes);
-
-	return ret;
-}
-
-int ve1_get_userdata(struct ve1_ctx *ctx, unsigned char *pBuf,
-		     unsigned int nBufSize)
-{
-	int ret = 0;
-	DecOutputInfo *outputInfo = NULL;
-	unsigned int totalSize;
-
-	if ((ctx == NULL) || (pBuf == NULL) || (nBufSize == 0)) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"invalid parameters.ctx:0x%px.pBuf:0x%px.nBufSize:%d\n",
-			ctx, pBuf, nBufSize);
-		return -1;
-	}
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
-		return VE1_DEC_RETURN_INVALID;
-	}
-
-	if (ctx->outputInfo == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx->outputInfo == NULL\n");
-		return VE1_DEC_RETURN_INVALID;
-	}
-	outputInfo = (DecOutputInfo *)ctx->outputInfo;
-
-	if (outputInfo->decOutputExtData.userDataSize) {
-		// The first USER_DATA_INFO_OFFSET bytes in user data buffer is header including userDataNum/userDataSize/userDataBufFull
-		// (userDataSize+7)/8*8: the actual user data bytes occupied are align to 8. If the user data size is 804, the actual bytes occupied are 808.
-		totalSize = (outputInfo->decOutputExtData.userDataSize + 7) /
-				    8 * 8 +
-			    USER_DATA_INFO_OFFSET;
-		if (totalSize > nBufSize) {
-			ve1_err(VE1_WRAPPER_TAG,
-				"buffer size:%d to get user data is smaller than user data size:%d\n",
-				nBufSize, totalSize);
-			return VE1_DEC_RETURN_INVALID;
-		}
-		vdi_read_memory(VE1_COREIDX, ctx->userDataBufPhysAddr, pBuf,
-				totalSize, VDI_LITTLE_ENDIAN);
-		ret = totalSize;
-	}
-	return ret;
-}
-#endif
-
-int VE1_DecInit(void *pCtx)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	struct ve1_ctx *ctx;
-	int productId;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->ve1DecState != VE1_STATE_DEC_UNINIT) {
-		ve1_err(VE1_WRAPPER_TAG, "invalid ve1DecState:%d\n",
-			ctx->ve1DecState);
-		return -1;
-	}
-
-	productId = VPU_GetProductId(VE1_COREIDX);
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "productId:%d\n", productId);
-	ret = VPU_Init(VE1_COREIDX);
-	ve1_info(VE1_WRAPPER_TAG, "af VPU_Init.ret:%d\n", ret);
-	if (ret == RETCODE_NOT_FOUND_BITCODE_PATH) {
-#if defined(ENABLE_TEE_DRM_FLOW)
-		ret = RTK_VPU_InitWithBitcodeExt(VE1_COREIDX, FALSE, NULL, NULL,
-						 ctx);
-		ve1_info(VE1_WRAPPER_TAG,
-			 "af RTK_VPU_InitWithBitcodeExt.ret:%d\n", ret);
-#else
-		ret = RTK_VPU_InitWithBitcode(VE1_COREIDX, FALSE);
-		ve1_info(VE1_WRAPPER_TAG, "af RTK_VPU_InitWithBitcode.ret:%d\n",
-			 ret);
-#endif
-	}
-	if (ret == RETCODE_SUCCESS || ret == RETCODE_CALLED_BEFORE) {
-		ctx->ve1DecState = VE1_STATE_DEC_INITED;
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			"ret:%d.set ve1DecState:%d\n", ret, ctx->ve1DecState);
-	} else {
-		ve1_err(VE1_WRAPPER_TAG, "unexpected ret:%d\n", ret);
-		ret = -1;
-	}
-
-	return ret;
-}
-
-int VE1_DecOpen(void *pCtx, void *pParam)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	struct ve1_ctx *ctx;
-	struct ve1_decopen_param *param;
-	DecOpenParam *pDecOp;
-	CodStd codec_type;
-#ifdef VPU_GET_CC
-	int i;
-#endif
-
-	if ((pCtx == NULL) || (pParam == NULL)) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL or pParam == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-	param = (struct ve1_decopen_param *)pParam;
-
-	if (ctx->ve1DecState != VE1_STATE_DEC_INITED &&
-	    ctx->ve1DecState != VE1_STATE_DEC_CLOSED) {
-		ve1_err(VE1_WRAPPER_TAG, "invalid ve1DecState:%d\n",
-			ctx->ve1DecState);
-		return -1;
-	}
-
-	if (ctx->decOP == NULL) {
-		ctx->decOP = kzalloc(sizeof(DecOpenParam), GFP_KERNEL);
-		if (ctx->decOP == NULL) {
-			ve1_err(VE1_WRAPPER_TAG, "kzalloc decOP fail\n");
-			return -1;
-		}
-	}
-	pDecOp = (DecOpenParam *)ctx->decOP;
-
-	switch (param->src_fmt_fourcc) {
-	case V4L2_PIX_FMT_MPEG2:
-		codec_type = STD_MPEG2;
-		break;
-	case V4L2_PIX_FMT_MPEG4:
-		codec_type = STD_MPEG4;
-		break;
-	case V4L2_PIX_FMT_VP8:
-		codec_type = STD_VP8;
-		break;
-	case V4L2_PIX_FMT_VC1_ANNEX_G:
-		codec_type = STD_VC1;
-		break;
-	case V4L2_PIX_FMT_VC1_ANNEX_L:
-		codec_type = STD_VC1;
-		break;
-	case V4L2_PIX_FMT_H264:
-	default:
-		codec_type = STD_AVC;
-		break;
-	}
-
-	memset(pDecOp, 0, sizeof(DecOpenParam));
-	pDecOp->coreIdx = VE1_COREIDX;
-	pDecOp->bitstreamFormat = codec_type;
-	pDecOp->bitstreamBuffer = ctx->bitstream.paddr;
-	pDecOp->bitstreamBufferSize = ctx->bitstream.size;
-	ve1_info(VE1_WRAPPER_TAG,
-		 "bitstreamBuffer:0x%x.bitstreamBufferSize:%d\n",
-		 pDecOp->bitstreamBuffer, pDecOp->bitstreamBufferSize);
-	pDecOp->avcExtension = 0;
-	pDecOp->bitstreamMode = BS_MODE_PIC_END;
-
-	if (param->dst_fmt_fourcc == V4L2_PIX_FMT_NV21 ||
-	    param->dst_fmt_fourcc == V4L2_PIX_FMT_NV12) {
-		pDecOp->cbcrInterleave = 1;
-		if (param->dst_fmt_fourcc == V4L2_PIX_FMT_NV21) {
-			pDecOp->nv21 = 1;
-		}
-	}
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"src_fourcc:%4s.dst_fourcc:%4s.cbcrInterleave:%d.nv21:%d\n",
-		(char *)&param->src_fmt_fourcc, (char *)&param->dst_fmt_fourcc,
-		pDecOp->cbcrInterleave, pDecOp->nv21);
-
-	pDecOp->cbcrOrder = CBCR_ORDER_NORMAL;
-	pDecOp->frameEndian = VPU_FRAME_ENDIAN;
-	pDecOp->streamEndian = VPU_STREAM_ENDIAN;
-	pDecOp->bwbEnable = VPU_ENABLE_BWB;
-	pDecOp->filp = ctx->filp;
-	pDecOp->frameWidth = param->width;
-	pDecOp->frameHeight = param->height;
-
-	pDecOp->isUseProtectBuffer = ctx->is_svp;
-
-	ve1_info(
-		VE1_WRAPPER_TAG,
-		"------------------------------ DECODER OPTIONS ------------------------------\n");
-	ve1_info(VE1_WRAPPER_TAG, "[bitstreamFormat    ]: %d\n",
-		 pDecOp->bitstreamFormat);
-	ve1_info(VE1_WRAPPER_TAG, "[bitstreamBuffer    ]: 0x%x\n",
-		 pDecOp->bitstreamBuffer);
-	ve1_info(VE1_WRAPPER_TAG, "[bitstreamBufferSize]: %d\n",
-		 pDecOp->bitstreamBufferSize);
-	ve1_info(VE1_WRAPPER_TAG, "[mp4DeblkEnable     ]: %d\n",
-		 pDecOp->mp4DeblkEnable);
-	ve1_info(VE1_WRAPPER_TAG, "[avcExtension       ]: %d\n",
-		 pDecOp->avcExtension);
-	ve1_info(VE1_WRAPPER_TAG, "[mp4Class           ]: %d\n",
-		 pDecOp->mp4Class);
-	ve1_info(VE1_WRAPPER_TAG, "[tiled2LinearEnable ]: %d\n",
-		 pDecOp->tiled2LinearEnable);
-	ve1_info(VE1_WRAPPER_TAG, "[tiled2LinearMode   ]: %d\n",
-		 pDecOp->tiled2LinearMode);
-	ve1_info(VE1_WRAPPER_TAG, "[wtlEnable          ]: %d\n",
-		 pDecOp->wtlEnable);
-	ve1_info(VE1_WRAPPER_TAG, "[wtlMode            ]: %d\n",
-		 pDecOp->wtlMode);
-	ve1_info(VE1_WRAPPER_TAG, "[cbcrInterleave     ]: %d\n",
-		 pDecOp->cbcrInterleave);
-	ve1_info(VE1_WRAPPER_TAG, "[nv21               ]: %d\n", pDecOp->nv21);
-	ve1_info(VE1_WRAPPER_TAG, "[cbcrOrder          ]: %d\n",
-		 pDecOp->cbcrOrder);
-	ve1_info(VE1_WRAPPER_TAG, "[BWB                ]: %d\n",
-		 pDecOp->bwbEnable);
-	ve1_info(VE1_WRAPPER_TAG, "[frameEndian        ]: %d\n",
-		 pDecOp->frameEndian);
-	ve1_info(VE1_WRAPPER_TAG, "[streamEndian       ]: %d\n",
-		 pDecOp->streamEndian);
-	ve1_info(VE1_WRAPPER_TAG, "[bitstreamMode      ]: %d\n",
-		 pDecOp->bitstreamMode);
-	ve1_info(VE1_WRAPPER_TAG, "[coreIdx            ]: %d\n",
-		 pDecOp->coreIdx);
-	ve1_info(VE1_WRAPPER_TAG, "[vbWork.size        ]: %d\n",
-		 pDecOp->vbWork.size);
-	ve1_info(VE1_WRAPPER_TAG, "[vbWork.phys_addr   ]: 0x%lx\n",
-		 pDecOp->vbWork.phys_addr);
-	ve1_info(VE1_WRAPPER_TAG, "[vbWork.base        ]: 0x%lx\n",
-		 pDecOp->vbWork.base);
-	ve1_info(VE1_WRAPPER_TAG, "[vbWork.virt_addr   ]: 0x%lx\n",
-		 pDecOp->vbWork.virt_addr);
-	ve1_info(VE1_WRAPPER_TAG, "[fbc_mode           ]: %d\n",
-		 pDecOp->fbc_mode);
-	ve1_info(VE1_WRAPPER_TAG, "[virtAxiID          ]: %d\n",
-		 pDecOp->virtAxiID);
-	ve1_info(VE1_WRAPPER_TAG, "[bwOptimization     ]: %d\n",
-		 pDecOp->bwOptimization);
-	ve1_info(VE1_WRAPPER_TAG, "[afbceEnable        ]: %d\n",
-		 pDecOp->afbceEnable);
-	ve1_info(VE1_WRAPPER_TAG, "[afbceFormat        ]: %d\n",
-		 pDecOp->afbceFormat);
-	ve1_info(VE1_WRAPPER_TAG, "[isUseProtectBuffer ]: %d\n",
-		 pDecOp->isUseProtectBuffer);
-	ve1_info(
-		VE1_WRAPPER_TAG,
-		"-----------------------------------------------------------------------------\n");
-
-	ret = VPU_DecOpen((DecHandle *)&ctx->decHandle, pDecOp);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG, "VPU_DecOpen fail.ret:%d\n", ret);
-		return -1;
-	}
-	ve1_info(VE1_WRAPPER_TAG, "af VPU_DecOpen.ret:%d.handle:0x%px\n", ret,
-		 ctx->decHandle);
-
-#ifdef VPU_GET_CC
-	if ((pDecOp->bitstreamFormat == STD_AVC) ||
-	    (pDecOp->bitstreamFormat == STD_MPEG2)) {
-		// allocate user data buffer and enable ve1 user data
-		ctx->pUserDataSrcBuf = (unsigned char *)kmalloc(
-			USER_DATA_SRC_BUF_SIZE, GFP_KERNEL);
-		ve1_enable_userdata(ctx);
-	}
-#endif
-
-	ctx->ve1DecState = VE1_STATE_DEC_OPENED;
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "[-] set ve1DecState:%d\n",
-		ctx->ve1DecState);
-
-#ifdef VPU_GET_CC
-	if (pDecOp->bitstreamFormat == STD_MPEG2 ||
-	    pDecOp->bitstreamFormat == STD_AVC) {
-		for (i = 0; i < MPEG2_CC_REG_FRAME_MAX; i++) {
-			ctx->m_CCDecodeOrderWp[i] = kmalloc(
-				USER_DATA_SRC_BUF_SIZE +
-					USER_DATA_NUM_MAX * RTK_CC_HEADER_SIZE,
-				GFP_KERNEL);
-			if (ctx->m_CCDecodeOrderWp[i])
-				memset(ctx->m_CCDecodeOrderWp[i], 0,
-				       USER_DATA_SRC_BUF_SIZE +
-					       USER_DATA_NUM_MAX *
-						       RTK_CC_HEADER_SIZE);
-		}
-		ctx->cc_error_count = 0;
-
-		cc_data_channel_init();
-	}
-#endif
-	return ret;
-}
-
-int VE1_DecGetRdWrPtr(void *pCtx)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	struct ve1_ctx *ctx;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decHandle != NULL) {
-		if (((DecOpenParam *)ctx->decOP)->bitstreamMode ==
-		    BS_MODE_PIC_END) {
-			ret = VPU_DecGetBitstreamBufferEx(
-				(DecHandle)ctx->decHandle, &ctx->vpuRdPtr,
-				&ctx->vpuWrPtr, &ctx->vpuBsRingRoom);
-		} else {
-			ret = VPU_DecGetBitstreamBuffer(
-				(DecHandle)ctx->decHandle, &ctx->vpuRdPtr,
-				&ctx->vpuWrPtr, &ctx->vpuBsRingRoom);
-		}
-	}
-
-	return ret;
-}
-
-int VE1_SetStreamEnd(void *pCtx)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	struct ve1_ctx *ctx;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
-		return -1;
-	}
-
-	ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
-					   STREAM_END_SIZE);
-	ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-		"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-		ret, STREAM_END_SIZE, ctx->accuBsFeedBytes);
-	return ret;
-}
-
-int VE1_DecSeqInit(void *pCtx)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	struct ve1_ctx *ctx;
-	BOOL seqInitEscape = FALSE;
-	int int_reason;
-	int bSeqInited = 0;
-	DecInitialInfo *initialInfo;
-	unsigned long long pts_unit = PTS_UNIT;
-	unsigned int fps;
-	unsigned long valid_data = 0;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
-		return -1;
-	}
-
-	VE1_DecGetRdWrPtr(ctx);
-	if (((DecOpenParam *)ctx->decOP)->bitstreamMode == BS_MODE_INTERRUPT) {
-		valid_data = ve1_ring_valid_data(ctx->bitstream.paddr,
-						 ctx->bitstream.paddr +
-							 ctx->bitstream.size,
-						 ctx->vpuRdPtr, ctx->vpuWrPtr);
-		if (valid_data < 1024) {
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"valid data size:%ld < 1024.vpuRdPtr:0x%x.vpuWrPtr:0x%x\n",
-				valid_data, ctx->vpuRdPtr, ctx->vpuWrPtr);
-			ctx->bBufEmptyFlag = true;
-			return ret;
-		}
-	}
-
-	if (ctx->initialInfo == NULL) {
-		ctx->initialInfo = kzalloc(sizeof(DecInitialInfo), GFP_KERNEL);
-		if (ctx->initialInfo == NULL) {
-			ve1_err(VE1_WRAPPER_TAG, "kzalloc initialInfo fail\n");
-			return -1;
-		}
-	}
-	initialInfo = (DecInitialInfo *)ctx->initialInfo;
-
-	if (seqInitEscape) {
-		if (ctx->ve1DecState >= VE1_STATE_DEC_OPENED &&
-		    ctx->ve1DecState != VE1_STATE_DEC_SEQ_INIT_ISSUED) {
-			ret = VPU_DecSetEscSeqInit((DecHandle)ctx->decHandle,
-						   seqInitEscape);
-			if (ret != RETCODE_SUCCESS) {
-				ve1_err(VE1_WRAPPER_TAG,
-					"VPU_DecSetEscSeqInit fail.ret:%d\n",
-					ret);
-				return -1;
-			}
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"af VPU_DecSetEscSeqInit.ret:%d\n", ret);
-
-			ret = VPU_DecGetInitialInfo((DecHandle)ctx->decHandle,
-						    initialInfo);
-			if (ret != RETCODE_SUCCESS) {
-				ctx->ve1DecState = VE1_STATE_DEC_SEQ_INIT_DONE;
-				ve1_err(VE1_WRAPPER_TAG,
-					"VPU_DecGetInitialInfo fail.ret:%d\n",
-					ret);
-				return -1;
-			} else {
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"af VPU_DecGetInitialInfo.ret:%d\n",
-					ret);
-				ctx->seqInited = 1;
-				ctx->ve1DecState = VE1_STATE_DEC_SEQ_INIT_DONE;
-				ctx->currSequenceNo++;
-				ctx->timeTick = div_u64(pts_unit * 100, 2997);
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"set ve1DecState:%d.currSequenceNo:%d.timeTick:%lld\n",
-					ctx->ve1DecState, ctx->currSequenceNo,
-					ctx->timeTick);
-
-				if (initialInfo->fRateDenominator != -1) {
-					fps = initialInfo->fRateNumerator *
-					      100 /
-					      initialInfo->fRateDenominator;
-					ctx->timeTick =
-						div_u64(pts_unit * 100, fps);
-				}
-
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"min:%d.%dx%d(%dx%d).fps(%d/%d).timeTick:%lld\n",
-					initialInfo->minFrameBufferCount,
-					initialInfo->picWidth,
-					initialInfo->picHeight,
-					(initialInfo->picCropRect.right -
-					 initialInfo->picCropRect.left),
-					(initialInfo->picCropRect.bottom -
-					 initialInfo->picCropRect.top),
-					initialInfo->fRateNumerator,
-					initialInfo->fRateDenominator,
-					ctx->timeTick);
-			}
-		}
-	} else {
-		if (ctx->ve1DecState == VE1_STATE_DEC_SEQ_INIT_ISSUED) {
-			goto waitSeqInitDone;
-		}
-
-		if (ctx->ve1DecState >= VE1_STATE_DEC_OPENED &&
-		    ctx->ve1DecState != VE1_STATE_DEC_SEQ_INIT_ISSUED) {
-			ret = VPU_DecIssueSeqInit((DecHandle)ctx->decHandle);
-			if (ret != RETCODE_SUCCESS) {
-				ve1_err(VE1_WRAPPER_TAG,
-					"VPU_DecIssueSeqInit fail.ret:%d\n",
-					ret);
-				return -1;
-			}
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"af VPU_DecIssueSeqInit.ret:%d\n", ret);
-			ctx->ve1DecState = VE1_STATE_DEC_SEQ_INIT_ISSUED;
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"set ve1DecState:%d\n", ctx->ve1DecState);
-		}
-
-	waitSeqInitDone:
-		while (1) {
-			int_reason = VPU_WaitInterrupt(VE1_COREIDX, 10);
-			if (int_reason == -1) {
-				int_reason = 0;
-			}
-			if (int_reason) {
-				VPU_ClearInterrupt(VE1_COREIDX);
-				if (int_reason & (1 << INT_BIT_SEQ_INIT)) {
-					ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-						"INT_BIT_SEQ_INIT\n");
-					bSeqInited = 1;
-				} else if (int_reason &
-					   (1 << INT_BIT_BIT_BUF_EMPTY)) {
-					ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-						"INT_BIT_BIT_BUF_EMPTY\n");
-					ctx->bBufEmptyFlag = true;
-				}
-				break;
-			}
-		}
-
-		if (bSeqInited) {
-			ret = VPU_DecCompleteSeqInit((DecHandle)ctx->decHandle,
-						     initialInfo);
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"af VPU_DecCompleteSeqInit.ret:%d.seqInitErrReason:0x%x\n",
-				ret, initialInfo->seqInitErrReason);
-			if (ret != RETCODE_SUCCESS) {
-				ctx->ve1DecState = VE1_STATE_DEC_SEQ_INIT_DONE;
-				ve1_err(VE1_WRAPPER_TAG,
-					"VPU_DecCompleteSeqInit fail.ret:%d\n",
-					ret);
-
-				if (((DecOpenParam *)ctx->decOP)->bitstreamMode ==
-					    BS_MODE_ROLLBACK &&
-				    initialInfo->seqInitErrReason & (1 << 31)) {
-					// this happens only ROLLBACK mode case
-				}
-				return -1;
-			}
-			ctx->seqInited = 1;
-			ctx->ve1DecState = VE1_STATE_DEC_SEQ_INIT_DONE;
-			ctx->currSequenceNo++;
-			ctx->timeTick = div_u64(pts_unit * 100, 2997);
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"set ve1DecState:%d.currSequenceNo:%d.timeTick:%lld\n",
-				ctx->ve1DecState, ctx->currSequenceNo,
-				ctx->timeTick);
-
-			if (initialInfo->fRateDenominator != -1) {
-				fps = initialInfo->fRateNumerator * 100 /
-				      initialInfo->fRateDenominator;
-				ctx->timeTick = div_u64(pts_unit * 100, fps);
-			}
-
-			ve1_info(
-				VE1_WRAPPER_TAG,
-				"min:%d.%dx%d(%dx%d).fps(%d/%d).timeTick:%lld\n",
-				initialInfo->minFrameBufferCount,
-				initialInfo->picWidth, initialInfo->picHeight,
-				(initialInfo->picCropRect.right -
-				 initialInfo->picCropRect.left),
-				(initialInfo->picCropRect.bottom -
-				 initialInfo->picCropRect.top),
-				initialInfo->fRateNumerator,
-				initialInfo->fRateDenominator, ctx->timeTick);
-
-			// update vpuRdPtr to bsRdPtr
-			VE1_DecGetRdWrPtr(pCtx);
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"vpuRdPtr:0x%x.vpuWrPtr:0x%x\n",
-				ctx->vpuRdPtr, ctx->vpuWrPtr);
-			ctx->bsRdPtr = ctx->vpuRdPtr;
-		} else {
-			ve1_err(VE1_WRAPPER_TAG, "seq init failed\n");
-			return -1;
-		}
-	}
-
-	return ret;
-}
-
-int VE1_DecStartDecode(void *pCtx)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	struct ve1_ctx *ctx;
-	unsigned long valid_data = 0;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
-		return -1;
-	}
-
-	if (ctx->decParam == NULL) {
-		ctx->decParam = kzalloc(sizeof(DecParam), GFP_KERNEL);
-		if (ctx->decParam == NULL) {
-			ve1_err(VE1_WRAPPER_TAG, "kzalloc decParam fail\n");
-			return -1;
-		}
-	}
-
-	if (ctx->seqInited && (ctx->ve1DecState == VE1_STATE_DEC_SET_DPB ||
-			       ctx->ve1DecState == VE1_STATE_DEC_PIC_DONE)) {
-		VE1_DecGetRdWrPtr(ctx);
-		if ((((DecOpenParam *)ctx->decOP)->bitstreamMode ==
-		     BS_MODE_INTERRUPT) &&
-		    (!ctx->streamEnd)) {
-			valid_data = ve1_ring_valid_data(
-				ctx->bitstream.paddr,
-				ctx->bitstream.paddr + ctx->bitstream.size,
-				ctx->vpuRdPtr, ctx->vpuWrPtr);
-			if (valid_data < 1024) {
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"valid data size:%ld < 1024.vpuRdPtr:0x%x.vpuWrPtr:0x%x\n",
-					valid_data, ctx->vpuRdPtr,
-					ctx->vpuWrPtr);
-				ctx->bBufEmptyFlag = true;
-				return ret;
-			}
-		} else if (((DecOpenParam *)ctx->decOP)->bitstreamMode ==
-			   BS_MODE_PIC_END) {
-			if ((ctx->vpuRdPtr == ctx->vpuWrPtr) &&
-			    (!ctx->streamEnd)) {
-				ctx->bBufEmptyFlag = true;
-				return ret;
-			}
-		}
-
-		rtkve1_recycle_dpb(ctx);
-		ret = VPU_DecStartOneFrame((DecHandle)ctx->decHandle,
-					   (DecParam *)ctx->decParam);
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			"af VPU_DecStartOneFrame.ret:%d\n", ret);
-		if (ret != RETCODE_SUCCESS) {
-			ve1_err(VE1_WRAPPER_TAG,
-				"VPU_DecStartOneFrame fail.ret:%d\n", ret);
-			return -1;
-		}
-		ctx->ve1DecState = VE1_STATE_DEC_START_DEC_ISSUED;
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "set ve1DecState:%d\n",
-			ctx->ve1DecState);
-	}
-
-	return ret;
-}
-
-int VE1_DecWaitPicDone(void *pCtx)
-{
-	struct ve1_ctx *ctx;
-	int bPicDone = 0;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-	ctx->timeoutCount = 0;
-
-	while (1) {
-		ctx->int_reason = VPU_WaitInterrupt(VE1_COREIDX, 10);
-		if (ctx->int_reason == -1) {
-			ctx->int_reason = 0;
-			ctx->timeoutCount++;
-			if (ctx->timeoutCount > 10000) {
-				ve1_err(VE1_WRAPPER_TAG,
-					"wait interrupt timeoutCount:%d > 10000\n",
-					ctx->timeoutCount);
-				VPU_DecUpdateBitstreamBuffer(
-					(DecHandle)ctx->decHandle,
-					STREAM_END_SIZE);
-				VPU_SWReset(VE1_COREIDX, SW_RESET_FORCE,
-					    (DecHandle)ctx->decHandle);
-				VPU_DecUpdateBitstreamBuffer(
-					(DecHandle)ctx->decHandle,
-					STREAM_END_CLEAR_FLAG);
-				bPicDone = -1;
-				break;
-			}
-		}
-		if (ctx->int_reason) {
-			if (ctx->bGotNextField) {
-				ctx->bGotNextField = false;
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"bWaitNextField.clear bGotNextField.int_reason:0x%x\n",
-					ctx->int_reason);
-			}
-			ctx->timeoutCount = 0;
-			if (ctx->int_reason & (1 << INT_BIT_PIC_RUN)) {
-				VPU_ClearInterrupt(VE1_COREIDX);
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"INT_BIT_PIC_RUN(0x%x)\n",
-					ctx->int_reason);
-				ctx->int_reason = 0;
-				bPicDone = 1;
-			} else if (ctx->int_reason &
-				   (1 << INT_BIT_BIT_BUF_EMPTY)) {
-				VPU_ClearInterrupt(VE1_COREIDX);
-				VE1_DecGetRdWrPtr(ctx);
-				ctx->bufEmptyVpuWrPtr = ctx->vpuWrPtr;
-				ctx->bBufEmptyFlag = true;
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"INT_BIT_BIT_BUF_EMPTYY(0x%x).bufEmptyVpuWrPtr:0x%x\n",
-					ctx->int_reason, ctx->bufEmptyVpuWrPtr);
-			} else if (ctx->int_reason & (1 << INT_BIT_DEC_FIELD)) {
-				if (ctx->bPostponeUpBs) {
-					ctx->bPostponeUpBs = false;
-					ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
-						"bPostponeUpBs.clear bPostponeUpBs.int_reason:0x%x\n",
-						ctx->int_reason);
-				}
-				VE1_DecGetRdWrPtr(ctx);
-				ctx->bWaitNextField = true;
-				ctx->bGotNextField = false;
-				ctx->fldDoneVpuRp = ctx->vpuRdPtr;
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"INT_BIT_DEC_FIELD(0x%x).bWaitNextField.frmNum:%u.fld_rp:0x%x.vpu(0x%x,0x%x)\n",
-					ctx->int_reason, ctx->decodedFrmNum,
-					ctx->fldDoneVpuRp, ctx->vpuRdPtr,
-					ctx->vpuWrPtr);
-			}
-			break;
-		}
-	}
-
-	return bPicDone;
-}
-
-void *rtkve1_find_dpb(void *pCtx, unsigned long dpb_paddr)
-{
-	int i = 0;
-	struct ve1_ctx *ctx;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return NULL;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	mutex_lock(&ctx->ve1_dma_mutex);
-	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
-		if (IS_RTKVE1_DPB_VALID(ctx->dpb[i].status) &&
-		    (ctx->dpb[i].phys_addr == dpb_paddr)) {
-			mutex_unlock(&ctx->ve1_dma_mutex);
-			return (void *)&(ctx->dpb[i]);
-		}
-	}
-
-	mutex_unlock(&ctx->ve1_dma_mutex);
-	return NULL;
-}
-
-int VE1_UpdateDPBStatus(void *pCtx, unsigned int dpb_paddr,
-			 unsigned int sequenceNo, unsigned int status)
-{
-	int ret = 0;
-	struct ve1_ctx *ctx;
-#if defined(VE1_ALLOC_FRAME_BUFFER_BY_VDI)
-	vpu_buffer_t vdb;
-#endif
-	void *tmp_dpb = NULL;
-	struct rtkve1_dpb_t *dpb = NULL;
-	unsigned int regIndex = 0;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decHandle == NULL || ctx->decOP == NULL) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"ctx->decHandle == NULL || ctx->decOP == NULL\n");
-		return -1;
-	}
-
-	tmp_dpb = rtkve1_find_dpb(pCtx, dpb_paddr);
-	if (!tmp_dpb) {
-		ve1_err(VE1_WRAPPER_TAG, "can't find dpb_paddr:0x%x in dpb[]\n",
-			dpb_paddr);
-		return -1;
-	}
-	dpb = (struct rtkve1_dpb_t *)tmp_dpb;
-	regIndex = dpb->regIndex;
-
-	mutex_lock(&ctx->ve1_dma_mutex);
-	// recycle the frame buffer
-	if (IS_RTKVE1_DPB_VALID(status)) {
-		dpb->status &= ~RTKVE1_DPB_ST_DQ;
-		// recycle the frame buffer of previous sequence
-		if (sequenceNo < ctx->currSequenceNo) {
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"dpb_paddr:0x%x.free & set status:0x%x.seq(%d,%d).regIndex:%d.tot:%d\n",
-				dpb_paddr, dpb->status, sequenceNo,
-				ctx->currSequenceNo, regIndex,
-				ctx->totIonAllocatedBytes);
-		}
-		// recycle the frame buffer of current sequence
-		else if (sequenceNo == ctx->currSequenceNo) {
-			if (ctx->seqChangeDone) {
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"dpb_paddr:0x%x.free & set status:0x%x.seq(%d,%d).regIndex:%d.tot:%d\n",
-					dpb_paddr, dpb->status, sequenceNo,
-					ctx->currSequenceNo, regIndex,
-					ctx->totIonAllocatedBytes);
-			} else {
-				// normal case, call VPU_DecClrDispFlag() to recyle the frame buffer
-				dpb->status |= RTKVE1_DPB_ST_WAIT_RECYCLE;
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"dpb_paddr:0x%x.set status:0x%x.seq(%d,%d).regIndex:%d\n",
-					dpb_paddr, dpb->status, sequenceNo,
-					ctx->currSequenceNo, regIndex);
-			}
-		} else {
-			ve1_err(VE1_WRAPPER_TAG,
-				"invalid sequenceNo:%d.currSequenceNo:%d\n",
-				sequenceNo, ctx->currSequenceNo);
-		}
-	}
-	// cap_dqbuf the frame buffer
-	else if (IS_RTKVE1_DPB_DQ(status)) {
-		if (sequenceNo <= ctx->currSequenceNo) {
-			dpb->status |= RTKVE1_DPB_ST_DQ;
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"dpb_paddr:0x%x.set status:0x%x.seq(%d,%d).regIndex:%d\n",
-				dpb_paddr, dpb->status, sequenceNo,
-				ctx->currSequenceNo, regIndex);
-		} else {
-			ve1_err(VE1_WRAPPER_TAG,
-				"invalid sequenceNo:%d.currSequenceNo:%d\n",
-				sequenceNo, ctx->currSequenceNo);
-		}
-	} else {
-		ve1_err(VE1_WRAPPER_TAG, "invalid status:0x%x\n", status);
-	}
-
-	mutex_unlock(&ctx->ve1_dma_mutex);
-	return ret;
-}
-
-void ve1_seq_change_free_fb(struct ve1_ctx *ctx)
-{
-	FrameBuffer *fbUser;
-#if defined(VE1_ALLOC_FRAME_BUFFER_BY_VDI)
-	vpu_buffer_t vdb;
-#endif
-	int i;
-	unsigned long flags;
-	struct ve1_displayable_frame *frame;
-
-	if (ctx == NULL || ctx->decHandle == NULL || ctx->decOP == NULL ||
-	    ctx->fbUser == NULL) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"ctx == NULL || ctx->decHandle == NULL || ctx->decOP == NULL || ctx->fbUser == NULL\n");
-		return;
-	}
-
-	if (((DecOpenParam *)ctx->decOP)->wtlEnable) {
-	} else {
-		// print displayable_frame_list for debug
-		ve1_show_displayable_frame_list(ctx);
-
-		// free DPBs which not use for display (not in displayable_frame_list)
-		for (i = 0; i < ctx->regFbCount; i++) {
-			bool bFound = false;
-			fbUser = ((FrameBuffer *)ctx->fbUser) + i;
-			spin_lock_irqsave(&ctx->displayable_frame_lock, flags);
-			if (!list_empty(&ctx->displayable_frame_list)) {
-				list_for_each_entry (
-					frame, &ctx->displayable_frame_list,
-					list) {
-					if (frame->dpb_paddr == fbUser->bufY) {
-						bFound = true;
-						break;
-					}
-				}
-			}
-			spin_unlock_irqrestore(&ctx->displayable_frame_lock,
-					       flags);
-			if (!bFound) {
-				// this DPB is not in displayable_frame_list, it can be freed
-				ve1_info(
-					VE1_WRAPPER_TAG,
-					"free fbUser[%d].bufY:0x%x.size:%d.myIndex:%d.stride:%d.h:%d.seqNo:%d.tot:%d\n",
-					i, fbUser->bufY, fbUser->size,
-					fbUser->myIndex, fbUser->stride,
-					fbUser->height, ctx->currSequenceNo,
-					ctx->totIonAllocatedBytes);
-				memset(fbUser, 0, sizeof(FrameBuffer));
-			}
-		}
-	}
-}
-
-int ve1_prepare_seq_change(void *pCtx)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	struct ve1_ctx *ctx;
-	DecOutputInfo *outputInfo;
-	PhysicalAddress seqChangedRdPtr;
-	PhysicalAddress seqChangedWrPtr;
-	int seqChangedStreamEndFlag;
-	int bPicDone = 0;
-	int i = 0;
-
-	ve1_info(VE1_WRAPPER_TAG, "[+]\n");
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return VE1_DEC_RETURN_INVALID;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
-		return VE1_DEC_RETURN_INVALID;
-	}
-
-	if (ctx->outputInfo == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx->outputInfo == NULL\n");
-		return VE1_DEC_RETURN_INVALID;
-	}
-	outputInfo = (DecOutputInfo *)ctx->outputInfo;
-
-	ctx->seqChangeRequest = 1;
-	seqChangedRdPtr = outputInfo->bytePosFrameEnd;
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"use bytePosFrameEnd:0x%x instead of rdPtr:0x%x\n",
-		outputInfo->bytePosFrameEnd, outputInfo->rdPtr);
-	seqChangedWrPtr = outputInfo->wrPtr;
-	seqChangedStreamEndFlag = outputInfo->streamEndFlag;
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"seqChangedRdPtr:0x%x.seqChangedWrPtr:0x%x.seqChangedStreamEndFlag:0x%x\n",
-		seqChangedRdPtr, seqChangedWrPtr, seqChangedStreamEndFlag);
-	ret = VPU_DecSetRdPtr((DecHandle)ctx->decHandle, seqChangedRdPtr, 1);
-	VE1_DecGetRdWrPtr(pCtx);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG, "VPU_DecSetRdPtr fail.ret:%d\n", ret);
-		return VE1_DEC_RETURN_INVALID;
-	}
-	ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle, 1);
-	ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-		"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:1.accuBsFeedBytes:%d\n",
-		ret, ctx->accuBsFeedBytes);
-	VE1_DecGetRdWrPtr(pCtx);
-	ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
-					   STREAM_END_SET_FLAG);
-	ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-		"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-		ret, STREAM_END_SET_FLAG, ctx->accuBsFeedBytes);
-	VE1_DecGetRdWrPtr(pCtx);
-
-	while (outputInfo->indexFrameDisplay != -1) {
-		if (ctx->seqInited &&
-		    (ctx->ve1DecState == VE1_STATE_DEC_SET_DPB ||
-		     ctx->ve1DecState == VE1_STATE_DEC_PIC_DONE)) {
-			rtkve1_recycle_dpb(ctx);
-			ret = VPU_DecStartOneFrame((DecHandle)ctx->decHandle,
-						   (DecParam *)ctx->decParam);
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"af VPU_DecStartOneFrame.ret:%d\n", ret);
-			if (ret != RETCODE_SUCCESS) {
-				ve1_err(VE1_WRAPPER_TAG,
-					"VPU_DecStartOneFrame fail.ret:%d\n",
-					ret);
-				return VE1_DEC_RETURN_INVALID;
-			}
-			ctx->ve1DecState = VE1_STATE_DEC_START_DEC_ISSUED;
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"set ve1DecState:%d\n", ctx->ve1DecState);
-
-			while (1) {
-				ctx->int_reason =
-					VPU_WaitInterrupt(VE1_COREIDX, 10);
-				if (ctx->int_reason == -1) {
-					ctx->int_reason = 0;
-				}
-				if (ctx->int_reason) {
-					VPU_ClearInterrupt(VE1_COREIDX);
-					if (ctx->int_reason &
-					    (1 << INT_BIT_PIC_RUN)) {
-						ve1_dbg(VPU_DBG_NONE,
-							VE1_WRAPPER_TAG,
-							"INT_BIT_PIC_RUN\n");
-						ctx->int_reason = 0;
-						bPicDone = 1;
-					} else if (ctx->int_reason &
-						   (1
-						    << INT_BIT_BIT_BUF_EMPTY)) {
-						VE1_DecGetRdWrPtr(ctx);
-						ctx->bufEmptyVpuWrPtr =
-							ctx->vpuWrPtr;
-						ve1_dbg(VPU_DBG_NONE,
-							VE1_WRAPPER_TAG,
-							"INT_BIT_BIT_BUF_EMPTY.bufEmptyVpuWrPtr:0x%x\n",
-							ctx->bufEmptyVpuWrPtr);
-					}
-					break;
-				}
-			}
-
-			if (bPicDone) {
-				ret = VPU_DecGetOutputInfo(
-					(DecHandle)ctx->decHandle, outputInfo);
-				if (ret != RETCODE_SUCCESS) {
-					ve1_err(VE1_WRAPPER_TAG,
-						"VPU_DecGetOutputInfo fail.ret:%d\n",
-						ret);
-					return VE1_DEC_RETURN_INVALID;
-				}
-				ctx->lastIndexFrameDecoded =
-					outputInfo->indexFrameDecoded;
-				ctx->lastIndexFrameDisplay =
-					outputInfo->indexFrameDisplay;
-				ctx->lastDisplayFrmBufY =
-					outputInfo->dispFrame.bufY;
-				ctx->ve1DecState = VE1_STATE_DEC_PIC_DONE;
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"set ve1DecState:%d\n",
-					ctx->ve1DecState);
-
-				ctx->outputinfoSN++;
-
-				if (outputInfo->indexFrameDecoded >= 0) {
-					ctx->decodedFrmNum++;
-				}
-				if (outputInfo->indexFrameDisplay >= 0) {
-					ctx->displayFrmNum++;
-				}
-
-				ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
-					"%d.%d.%d.h:0x%px.seq:%d.dec:%d.dis:%d.POC:%d(%d,%d).type:%d(%d).pos(0x%x 0x%x 0x%x).size:%ld.suc:0x%x.err:%d.frmDisFlg:0x%x.warn:%d.nalRefIdc:%d.decFrameInfo:%d.\n",
-					ctx->outputinfoSN, ctx->decodedFrmNum,
-					ctx->displayFrmNum,
-					ctx->decHandle, ctx->currSequenceNo,
-					outputInfo->indexFrameDecoded,
-					outputInfo->indexFrameDisplay,
-					outputInfo->avcPocPic,
-					outputInfo->avcPocTop,
-					outputInfo->avcPocBot,
-					outputInfo->picType,
-					outputInfo->picTypeFirst,
-					outputInfo->bytePosFrameStart,
-					outputInfo->bytePosFrameEnd,
-					outputInfo->rdPtr,
-					ve1_ring_valid_data(
-						ctx->bitstream.paddr,
-						ctx->bitstream.paddr +
-							ctx->bitstream.size,
-						outputInfo->bytePosFrameStart,
-						outputInfo->bytePosFrameEnd),
-					outputInfo->decodingSuccess,
-					outputInfo->numOfErrMBs,
-					outputInfo->frameDisplayFlag,
-					outputInfo->warnInfo,
-					outputInfo->nalRefIdc,
-					outputInfo->decFrameInfo);
-
-				VE1_UpdateFrameQueueInfo(pCtx);
-				// update vpuRdPtr to bsRdPtr
-				VE1_DecGetRdWrPtr(pCtx);
-				ctx->bsRdPtr = ctx->vpuRdPtr;
-
-				rtkve1_add_displayble_frame_to_list(ctx);
-			}
-		} else {
-			ve1_err(VE1_WRAPPER_TAG,
-				"fail to continue decoding original sequence.ve1DecState:%d\n",
-				ctx->ve1DecState);
-		}
-	}
-
-	for (i = 0; i < ctx->regFbCount; i++) {
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			"VPU_DecClrDispFlag(%d)\n", i);
-		ret = VPU_DecClrDispFlag((DecHandle)ctx->decHandle, i);
-	}
-
-	ret = VPU_DecFrameBufferFlush((DecHandle)ctx->decHandle, NULL, NULL);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"VPU_DecFrameBufferFlush fail.ret:%d\n", ret);
-		return VE1_DEC_RETURN_INVALID;
-	}
-
-	ctx->seqChangeRequest = 0;
-	ctx->outputinfoSN = 0;
-	ctx->decodedFrmNum = 0;
-	ctx->displayFrmNum = 0;
-	ctx->seqHeaderSize = 0;
-
-	VPU_DecSetRdPtr((DecHandle)ctx->decHandle, seqChangedRdPtr, 1);
-	VE1_DecGetRdWrPtr(pCtx);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG, "VPU_DecSetRdPtr fail.ret:%d\n", ret);
-		return VE1_DEC_RETURN_INVALID;
-	}
-
-	if (seqChangedStreamEndFlag == 1) {
-		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
-						   STREAM_END_SET_FLAG);
-		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-			ret, STREAM_END_SET_FLAG, ctx->accuBsFeedBytes);
-	} else {
-		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
-						   STREAM_END_CLEAR_FLAG);
-		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-			ret, STREAM_END_CLEAR_FLAG, ctx->accuBsFeedBytes);
-	}
-	VE1_DecGetRdWrPtr(pCtx);
-
-	if (seqChangedWrPtr >= seqChangedRdPtr) {
-		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
-						   seqChangedWrPtr -
-							   seqChangedRdPtr);
-		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-			ret, (seqChangedWrPtr - seqChangedRdPtr),
-			ctx->accuBsFeedBytes);
-	} else {
-		ret = VPU_DecUpdateBitstreamBuffer(
-			(DecHandle)ctx->decHandle,
-			(((DecOpenParam *)ctx->decOP)->bitstreamBuffer +
-			 ((DecOpenParam *)ctx->decOP)->bitstreamBufferSize) -
-				seqChangedRdPtr +
-				(seqChangedWrPtr -
-				 ((DecOpenParam *)ctx->decOP)->bitstreamBuffer));
-		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-			ret,
-			((((DecOpenParam *)ctx->decOP)->bitstreamBuffer +
-			  ((DecOpenParam *)ctx->decOP)->bitstreamBufferSize) -
-			 seqChangedRdPtr +
-			 (seqChangedWrPtr -
-			  ((DecOpenParam *)ctx->decOP)->bitstreamBuffer)),
-			ctx->accuBsFeedBytes);
-	}
-	VE1_DecGetRdWrPtr(pCtx);
-
-	VPU_DecGiveCommand((DecHandle)ctx->decHandle, DEC_FREE_FRAME_BUFFER,
-			   0x00);
-
-	ve1_seq_change_free_fb(ctx);
-
-	memset(ctx->fbUser, 0, sizeof(FrameBuffer) * MAX_REG_FRAME);
-
-	ctx->seqInited = 0;
-	// for trigger queue_work pic_run_work in ve1_out_qbuf()
-	ctx->startDecode = 0;
-	ctx->seqChangeDone = 1;
-
-	ve1_info(VE1_WRAPPER_TAG, "[-]\n");
-
-	return VE1_DEC_RETURN_SEQ_CHANGE;
-}
-
-static int rtkve1_dump_yuv(void *pCtx, int fbIndex)
-{
-#if defined(RTKVE1_DUMP_YUV_EN)
-	struct ve1_ctx *ctx;
-	unsigned long fb_phys_addr = 0;
-	void *fb_virt_addr = NULL;
-	FrameBuffer *fbUser = NULL;
-	void *tmp_dpb = NULL;
-	struct rtkve1_dpb_t *dpb = NULL;
-	struct vb2_v4l2_buffer *vb2_v4l2_buf = NULL;
-	struct vb2_buffer *vb2_buf = NULL;
-	int filp_open_flags;
-	ssize_t bytes = 0;
-	loff_t pos = 0;
-
-	if ((pCtx == NULL) || (fbIndex < 0)) {
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	//if ((fbIndex >= 0) &&
-	//    (ctx->displayFrmNum == 300)) {
-	if (fbIndex >= 0) {
-		fbUser = ((FrameBuffer *)ctx->fbUser) + fbIndex;
-		fb_phys_addr = fbUser->bufY;
-		tmp_dpb = rtkve1_find_dpb((void *)ctx, fb_phys_addr);
-		if (!tmp_dpb) {
-			ve1_err(VE1_WRAPPER_TAG,
-					"can't find framePhysAddr:0x%lx in dpb[]\n",
-					fb_phys_addr);
-			return -1;
-		}
-		dpb = (struct rtkve1_dpb_t *)tmp_dpb;
-		vb2_v4l2_buf = (struct vb2_v4l2_buffer *)(dpb->vb2_v4l2_buf);
-		vb2_buf = &(vb2_v4l2_buf->vb2_buf);
-		fb_virt_addr = vb2_plane_vaddr(vb2_buf, 0);
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"dpb.index:%d.virt:0x%px.phys:0x%lx.vb2_v4l2_buf:0x%px.vb2_buf:0x%px.size:%u\n",
-				fbIndex, fb_virt_addr, fb_phys_addr,
-				(void *)vb2_v4l2_buf, (void *)vb2_buf, dpb->size);
-
-		if ((fb_virt_addr != NULL) && (dpb->size > 0)) {
-			if (ctx->bNewYuvDumpFile == 1) {
-				ctx->bNewYuvDumpFile = 0;
-				filp_open_flags = O_CREAT | O_WRONLY;
-				memset(ctx->yuvDumpFileName, 0, sizeof(unsigned char)*256);
-				snprintf(ctx->yuvDumpFileName, 256,
-						"/media/removable/32G_BLACK/ve1yuv_%d.yuv",
-						gYuvDumpSerial);
-				gYuvDumpSerial++;
-				vpu_info("%d.%s.create new ve1yuv dump:%s\n",__LINE__,__func__,
-						ctx->yuvDumpFileName);
-			} else {
-				filp_open_flags = O_APPEND | O_WRONLY;
-			}
-			ctx->yuvDumpFile =
-				(void *)filp_open(ctx->yuvDumpFileName, filp_open_flags, 0);
-			if (IS_ERR((struct file *)ctx->bsDumpFile)) {
-				ve1_err(VE1_WRAPPER_TAG, "filp_open %s fail\n",
-						ctx->yuvDumpFileName);
-			} else {
-				//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				//	"filp_open %s ok\n",
-				//	ctx->yuvDumpFileName);
-				bytes =
-					kernel_write((struct file *)(ctx->yuvDumpFile),
-								(void *)fb_virt_addr, (size_t)dpb->size, &pos);
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-						"kernel_write bytes:%ld.pos:%lld\n", bytes, pos);
-				filp_close((struct file *)(ctx->yuvDumpFile), NULL);
-				//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				//		"filp_close %s\n",
-				//		ctx->yuvDumpFileName);
-				ctx->yuvDumpFile = NULL;
-			}
-		}
-	}
-	return 0;
-#else
-	return -1;
-#endif
-}
-
-int VE1_DecPicDone(void *pCtx)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	struct ve1_ctx *ctx;
-	DecOutputInfo *outputInfo;
-#if defined(VE1_CHECK_DFB_MD5_EN)
-	int fbIndex = 0;
-	unsigned long fb_phys_addr = 0;
-	void *fb_virt_addr = NULL;
-	FrameBuffer *fbUser = NULL;
-	void *tmp_dpb = NULL;
-	struct rtkve1_dpb_t *dpb = NULL;
-	struct vb2_v4l2_buffer *vb2_v4l2_buf = NULL;
-	struct vb2_buffer *vb2_buf = NULL;
-#endif
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return VE1_DEC_RETURN_INVALID;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
-		return VE1_DEC_RETURN_INVALID;
-	}
-
-	if (ctx->outputInfo == NULL) {
-		ctx->outputInfo = kzalloc(sizeof(DecOutputInfo), GFP_KERNEL);
-		if (ctx->outputInfo == NULL) {
-			ve1_err(VE1_WRAPPER_TAG, "kzalloc outputInfo fail\n");
-			return VE1_DEC_RETURN_INVALID;
-		}
-	}
-	outputInfo = (DecOutputInfo *)ctx->outputInfo;
-
-	ret = VPU_DecGetOutputInfo((DecHandle)ctx->decHandle, outputInfo);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG, "VPU_DecGetOutputInfo fail.ret:%d\n",
-			ret);
-		return VE1_DEC_RETURN_INVALID;
-	}
-
-	if (outputInfo->indexFrameDecoded != -1) {
-		if (ctx->bPostponeUpBs) {
-			ctx->bPostponeUpBs = false;
-			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
-				"bPostponeUpBs.clear bPostponeUpBs.int_reason:0x%x\n",
-				ctx->int_reason);
-		}
-	}
-
-	if (outputInfo->indexFrameDecoded >= 0) {
-		ctx->decodedFrmNum++;
-	}
-	if (outputInfo->indexFrameDisplay >= 0) {
-		ctx->displayFrmNum++;
-	}
-
-	if (!((ctx->lastInfoFrmStart == outputInfo->bytePosFrameStart) &&
-	      (ctx->lastInfoFrmEnd == outputInfo->bytePosFrameEnd) &&
-	      (outputInfo->indexFrameDecoded == -2) &&
-	      (outputInfo->indexFrameDisplay == -3) &&
-		  (ctx->lastIndexFrameDecoded != -1))) {
-		ctx->outputinfoSN++;
-	ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
-		"%d.%d.%d.h:0x%px.seq:%d.dec:%d.dis:%d.POC:%d(%d,%d).type:%d(%d).pos(0x%x 0x%x 0x%x).size:%ld.suc:0x%x.err:%d.frmDisFlg:0x%x.warn:%d.nalRefIdc:%d.decFrameInfo:%d.vpu_debug:0x%x\n",
-		ctx->outputinfoSN, ctx->decodedFrmNum,
-		ctx->displayFrmNum, ctx->decHandle,
-		ctx->currSequenceNo, outputInfo->indexFrameDecoded,
-		outputInfo->indexFrameDisplay, outputInfo->avcPocPic,
-		outputInfo->avcPocTop, outputInfo->avcPocBot,
-		outputInfo->picType, outputInfo->picTypeFirst,
-		outputInfo->bytePosFrameStart,
-		outputInfo->bytePosFrameEnd, outputInfo->rdPtr,
-		ve1_ring_valid_data(ctx->bitstream.paddr,
-			ctx->bitstream.paddr +
-			ctx->bitstream.size,
-			outputInfo->bytePosFrameStart,
-			outputInfo->bytePosFrameEnd),
-		outputInfo->decodingSuccess, outputInfo->numOfErrMBs,
-		outputInfo->frameDisplayFlag, outputInfo->warnInfo,
-		outputInfo->nalRefIdc, outputInfo->decFrameInfo,
-		vpu_debug);
-	}
-	ctx->lastInfoFrmStart = outputInfo->bytePosFrameStart;
-	ctx->lastInfoFrmEnd = outputInfo->bytePosFrameEnd;
-
-	ctx->lastIndexFrameDecoded = outputInfo->indexFrameDecoded;
-	ctx->lastIndexFrameDisplay = outputInfo->indexFrameDisplay;
-	ctx->lastDisplayFrmBufY = outputInfo->dispFrame.bufY;
-	ctx->ve1DecState = VE1_STATE_DEC_PIC_DONE;
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "set ve1DecState:%d\n",
-		ctx->ve1DecState);
-
-	if ((((DecOpenParam *)ctx->decOP)->bitstreamFormat == STD_AVC) &&
-	    (outputInfo->indexFrameDecoded >= 0)) {
-
-		if ((outputInfo->decodingSuccess & 0x00200000) &&
-		    (outputInfo->nalRefIdc != 0)) {
-			ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
-				"dec:%d.AVC missing reference\n",
-				outputInfo->indexFrameDecoded);
-		}
-		if (outputInfo->decFrameInfo != 0) {
-			ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
-				"dec:%d.AVC missing field\n",
-				outputInfo->indexFrameDecoded);
-		}
-	}
-	if (outputInfo->numOfErrMBs) {
-		bool isThisFrmBeRefer = true;
-
-		if ((((DecOpenParam *)ctx->decOP)->bitstreamFormat ==
-		     STD_AVC) &&
-		    (outputInfo->nalRefIdc == 0)) {
-			isThisFrmBeRefer = false;
-		}
-		ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
-			"dec:%d.ErrorBlock:%d.ifRefFrame:%d\n",
-			outputInfo->indexFrameDecoded, outputInfo->numOfErrMBs,
-			isThisFrmBeRefer);
-	}
-
-	if (((DecOpenParam *)ctx->decOP)->bitstreamMode == BS_MODE_ROLLBACK &&
-	    (outputInfo->decodingSuccess & 0x10)) {
-		ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
-			"BS_MODE_ROLLBACK.empty.dec:%d.dis:%d.suc:0x%x\n",
-			outputInfo->indexFrameDecoded,
-			outputInfo->indexFrameDisplay,
-			outputInfo->decodingSuccess);
-	}
-
-	VE1_UpdateFrameQueueInfo(pCtx);
-	// update vpuRdPtr to bsRdPtr
-	VE1_DecGetRdWrPtr(pCtx);
-	ctx->bsRdPtr = ctx->vpuRdPtr;
-
-#if defined(VE1_CHECK_DFB_MD5_EN)
-	fbIndex = outputInfo->indexFrameDecoded;
-	if (fbIndex >= 0) {
-		fbUser = ((FrameBuffer *)ctx->fbUser) + fbIndex;
-		fb_phys_addr = fbUser->bufY;
-		tmp_dpb = rtkve1_find_dpb((void *)ctx, fb_phys_addr);
-		if (!tmp_dpb) {
-			ve1_err(VE1_WRAPPER_TAG,
-				"can't find framePhysAddr:0x%lx in dpb[]\n",
-				fb_phys_addr);
-			return VE1_DEC_RETURN_INVALID;
-		}
-		dpb = (struct rtkve1_dpb_t *)tmp_dpb;
-		vb2_v4l2_buf = (struct vb2_v4l2_buffer *)(dpb->vb2_v4l2_buf);
-		vb2_buf = &(vb2_v4l2_buf->vb2_buf);
-		fb_virt_addr = vb2_plane_vaddr(vb2_buf, 0);
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			"dpb.index:%d.virt:0x%px.phys:0x%lx.vb2_v4l2_buf:0x%px.vb2_buf:0x%px.size:%u\n",
-			fbIndex, fb_virt_addr, fb_phys_addr,
-			(void *)vb2_v4l2_buf, (void *)vb2_buf, dpb->size);
-		ve1_md5_hash(ve1_md5_digest, VE1_MD5_DIGEST_SIZE,
-			(char *)fb_virt_addr, dpb->size);
-	}
-#endif
-
-	rtkve1_dump_yuv((void *)ctx, outputInfo->indexFrameDisplay);
-
-	if (((outputInfo->decodingSuccess & 0x1) != 0) &&
-	    (outputInfo->sequenceChanged)) {
-		//profileIdc/MbNumX/MbNumY/MaxDecFrameBuffering are changed
-		ve1_info(VE1_WRAPPER_TAG,
-			 "Sequence information has been changed (0x%x)\n",
-			 outputInfo->sequenceChanged);
-		ret = ve1_prepare_seq_change(pCtx);
-		return ret;
-	}
-
-	if ((outputInfo->indexFrameDisplay == -1) && ctx->streamEnd) {
-		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
-											STREAM_END_CLEAR_FLAG);
-		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d\n",
-			ret, STREAM_END_CLEAR_FLAG);
-		VE1_DecGetRdWrPtr(ctx);
-		ctx->streamEnd = 0;
-		ctx->handle_eos_by = VE1_HANDLE_EOS_DEC_FINISH;
-	}
-
-	return VE1_DEC_RETURN_OK;
-}
-
-int VE1_DecCheckComplete(void *pCtx)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	struct ve1_ctx *ctx;
-	int int_reason;
-	unsigned int interrupt_timeout_cnt = 10;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
-		return -1;
-	}
-
-	if ((((DecOpenParam *)ctx->decOP)->bitstreamMode == BS_MODE_INTERRUPT) &&
-	    (ctx->ve1DecState == VE1_STATE_DEC_START_DEC_ISSUED)) {
-		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
-						   STREAM_END_SET_FLAG);
-		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-			ret, STREAM_END_SET_FLAG, ctx->accuBsFeedBytes);
-		VE1_DecGetRdWrPtr(ctx);
-
-		int_reason = 1 << INT_BIT_BIT_BUF_EMPTY;
-		while ((int_reason & (1 << INT_BIT_BIT_BUF_EMPTY)) &&
-		       (interrupt_timeout_cnt > 0)) {
-			int_reason = VPU_WaitInterrupt(VE1_COREIDX, 100);
-			if (int_reason) {
-				VPU_ClearInterrupt(VE1_COREIDX);
-			}
-			interrupt_timeout_cnt--;
-		}
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			"int_reason:0x%x.interrupt_timeout_cnt:%d\n",
-			int_reason, interrupt_timeout_cnt);
-		ret = VPU_DecGetOutputInfo((DecHandle)ctx->decHandle,
-					   (DecOutputInfo *)ctx->outputInfo);
-		if (ret != RETCODE_SUCCESS) {
-			ve1_err(VE1_WRAPPER_TAG,
-				"VPU_DecGetOutputInfo fail.ret:%d\n", ret);
-		}
-		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
-						   STREAM_END_CLEAR_FLAG);
-		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-			ret, STREAM_END_CLEAR_FLAG, ctx->accuBsFeedBytes);
-		VE1_DecGetRdWrPtr(ctx);
-		ctx->ve1DecState = VE1_STATE_DEC_PIC_DONE;
-	}
-
-	return ret;
-}
-//EXPORT_SYMBOL(VE1_DecCheckComplete);
-
-int VE1_DecClose(void *pCtx)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	struct ve1_ctx *ctx;
-	FrameBuffer *fbUser;
-	int i;
-	DecHandle decHandle = NULL;
-	DecOpenParam *pDecOp;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
-		return -1;
-	}
-	decHandle = (DecHandle)ctx->decHandle;
-	pDecOp = (DecOpenParam *)ctx->decOP;
-
-	if (ctx->ve1DecState < VE1_STATE_DEC_OPENED) {
-		ve1_err(VE1_WRAPPER_TAG, "invalid ve1DecState:%d\n",
-			ctx->ve1DecState);
-		return -1;
-	}
-
-	/* This software reset for corner case is neccessary when VPU_DecStartOneFrame()
-	 * EnterLock and doesn't LeaveLock, during this moment the system stops streaming.
-	 * The next start will be deadlock at EnterLock().
-	 */
-	if (ctx->ve1DecState != VE1_STATE_DEC_OPENED &&
-	    ctx->ve1DecState != VE1_STATE_DEC_PIC_DONE) {
-		ve1_info(VE1_WRAPPER_TAG,
-			"%s: ve1DecState=%d, VPU_SWReset for corner case\n",
-			__func__, ctx->ve1DecState);
-		VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
-			STREAM_END_SIZE);
-		VPU_SWReset(VE1_COREIDX, SW_RESET_SAFETY,
-			(DecHandle)ctx->decHandle);
-		VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
-			STREAM_END_CLEAR_FLAG);
-		ve1_info(VE1_WRAPPER_TAG, "%s: VPU_SWReset done\n", __func__);
-	}
-
-#ifdef VPU_GET_CC
-	if (pDecOp->bitstreamFormat == STD_MPEG2 ||
-	    pDecOp->bitstreamFormat == STD_AVC) {
-		cc_data_channel_exit();
-
-		for (i = 0; i < MPEG2_CC_REG_FRAME_MAX; i++) {
-			if (ctx->m_CCDecodeOrderWp[i]) {
-				kfree(ctx->m_CCDecodeOrderWp[i]);
-				ctx->m_CCDecodeOrderWp[i] = NULL;
-			}
-		}
-
-		ctx->cc_error_count = 0;
-	}
-#endif
-	// free frame buffers
-	for (i = 0; i < ctx->regFbCount * 2; i++) {
-		fbUser = ((FrameBuffer *)ctx->fbUser) + i;
-		if (fbUser->size > 0) {
-			ve1_info(
-				VE1_WRAPPER_TAG,
-				"free fbUser[%d].bufY:0x%x.size:%d.myIndex:%d.stride:%d.h:%d.seqNo:%d.tot:%d\n",
-				i, fbUser->bufY, fbUser->size, fbUser->myIndex,
-				fbUser->stride, fbUser->height,
-				ctx->currSequenceNo, ctx->totIonAllocatedBytes);
-			memset(fbUser, 0, sizeof(FrameBuffer));
-		}
-	}
-
-#ifdef VPU_GET_CC
-	if (ctx->pUserDataSrcBuf) {
-		unsigned int codec_type =
-			(pDecOp->bitstreamFormat == STD_MPEG2 ? ENUM_CC_MPGE2 :
-								ENUM_CC_H264);
-		if (ctx->is_svp)
-			ta_TEEapi_OMX_CC_API(
-				(struct tee_context *)decHandle->teeapi_ctx,
-				decHandle->teeapi_tee_session,
-				ctx->userDataBufPhysAddr, ctx->pUserDataSrcBuf,
-				USER_DATA_SRC_BUF_SIZE, codec_type, ENUM_CC_U);
-
-		kfree(ctx->pUserDataSrcBuf);
-		ctx->pUserDataSrcBuf = NULL;
-	}
-	if (ctx->userDataBufPhysAddr != 0) {
-		vpu_buffer_t vdb;
-		memset(&vdb, 0, sizeof(vpu_buffer_t));
-		vdb.size = ctx->userDataBufSize;
-		vdb.phys_addr = ctx->userDataBufPhysAddr;
-		vdi_free_dma_memory(VE1_COREIDX, &vdb);
-		ve1_info(VE1_WRAPPER_TAG, "free userdata(size:%d,phys:0x%x)\n",
-			 ctx->userDataBufSize, ctx->userDataBufPhysAddr);
-		ctx->userDataBufSize = 0;
-		ctx->userDataBufPhysAddr = 0;
-	}
-
-	// clear user data variables
-	ctx->userDataEnable = 0;
-	ctx->userDataReportMode = 0;
-#endif
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "decHandle == NULL\n");
-		return -1;
-	}
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"bf VPU_DecClose.ve1DecState:%d\n", ctx->ve1DecState);
-	ret = VPU_DecClose((DecHandle)ctx->decHandle);
-	ve1_info(VE1_WRAPPER_TAG, "af VPU_DecClose.ret:%d\n", ret);
-	ctx->decHandle = NULL;
-	ctx->ve1DecState = VE1_STATE_DEC_CLOSED;
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "set ve1DecState:%d\n",
-		ctx->ve1DecState);
-
-	return ret;
-}
-
-int VE1_DecDeInit(void *pCtx)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	struct ve1_ctx *ctx;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->ve1DecState != VE1_STATE_DEC_INITED &&
-	    ctx->ve1DecState != VE1_STATE_DEC_CLOSED) {
-		ve1_err(VE1_WRAPPER_TAG, "invalid ve1DecState:%d\n",
-			ctx->ve1DecState);
-		return -1;
-	}
-
-	ret = VPU_DeInit(VE1_COREIDX);
-	ve1_info(VE1_WRAPPER_TAG, "af VPU_DeInit.ret:%d\n", ret);
-	ctx->ve1DecState = VE1_STATE_DEC_UNINIT;
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "set ve1DecState:%d\n",
-		ctx->ve1DecState);
-
-	return ret;
-}
-
-void VE1_GetParsedInfo(void *pCtx, void *pInfo)
-{
-	struct ve1_ctx *ctx;
-	DecInitialInfo *initialInfo;
-	struct ve1_parsed_initial_info *info;
-
-	if (pCtx == NULL || pInfo == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL or pInfo == NULL\n");
-		return;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (!ctx->seqInited) {
-		ve1_err(VE1_WRAPPER_TAG, "not seqInited\n");
-		return;
-	}
-
-	initialInfo = (DecInitialInfo *)ctx->initialInfo;
-	info = (struct ve1_parsed_initial_info *)pInfo;
-
-	info->pic_width = initialInfo->picWidth;
-	info->pic_height = initialInfo->picHeight;
-	info->visible_rect_left = initialInfo->picCropRect.left;
-	info->visible_rect_top = initialInfo->picCropRect.top;
-	info->visible_rect_w =
-		initialInfo->picCropRect.right - initialInfo->picCropRect.left;
-	info->visible_rect_h =
-		initialInfo->picCropRect.bottom - initialInfo->picCropRect.top;
-	info->minDpbCount =
-		initialInfo->minFrameBufferCount + EXTRA_DEC_PIC_BUF;
-}
-
-void VE1_GetDisplayFrameInfo(void *pCtx, void *displayFrameInfo)
-{
-	struct ve1_ctx *ctx;
-	DecOpenParam *decOP;
-	DecInitialInfo *initialInfo;
-	DecOutputInfo *outputInfo;
-	struct ve1_displayable_frame *frame;
-	struct ve1_decoded_frame *frmInfo;
-
-	if (pCtx == NULL || displayFrameInfo == NULL) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"pCtx == NULL or displayFrameInfo == NULL\n");
-		return;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decOP == NULL || ctx->initialInfo == NULL ||
-	    ctx->outputInfo == NULL) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"decOP == NULL or initialInfo == NULL or outputInfo == NULL\n");
-		return;
-	}
-
-	decOP = (DecOpenParam *)ctx->decOP;
-	initialInfo = (DecInitialInfo *)ctx->initialInfo;
-	outputInfo = (DecOutputInfo *)ctx->outputInfo;
-	frame = (struct ve1_displayable_frame *)displayFrameInfo;
-	frmInfo = (struct ve1_decoded_frame *)&ctx
-			  ->frameQueue[outputInfo->indexFrameDisplay];
-
-	frame->frameBufIndex = outputInfo->indexFrameDisplay;
-	frame->Y_addr = outputInfo->dispFrame.bufY;
-	frame->U_addr =
-		(outputInfo->dispFrame.bufY +
-		 outputInfo->dispFrame.stride * outputInfo->dispFrame.height);
-	frame->bufStride = outputInfo->dispFrame.stride;
-	frame->bufHeight = outputInfo->dispFrame.height;
-	frame->picWidth = initialInfo->picWidth;
-	frame->picHeight = initialInfo->picHeight;
-	frame->rectLeft = outputInfo->rcDisplay.left;
-	frame->rectTop = outputInfo->rcDisplay.top;
-	frame->rectRight = outputInfo->rcDisplay.right;
-	frame->rectBottom = outputInfo->rcDisplay.bottom;
-	frame->bitDepth = initialInfo->lumaBitdepth;
-	if (frmInfo->pairedFldFrm) {
-		frame->mode = (frmInfo->picMode == INTERLEAVED_BOT_FIELD) ?
-				      INTERLEAVED_BOT_TOP_FIELD :
-				      INTERLEAVED_TOP_BOT_FIELD;
-	} else {
-		frame->mode = frmInfo->picMode;
-	}
-	if (decOP->nv21 == 1) {
-		frame->mode |=
-			0x1u << 16; // todo, VO_NV21_MASK of VP_PICTURE_MODE_EXT
-	}
-	frame->timeTick = ctx->timeTick;
-	frame->video_full_range_flag = frmInfo->video_full_range_flag;
-	frame->transfer_characteristics = frmInfo->transfer_characteristics;
-	frame->matrix_coefficients = frmInfo->matrix_coefficients;
-	frame->POC = frmInfo->POC;
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"idx:%d.0x%x,0x%x.%d,%d,%d,%d.(%d,%d,%d,%d).%d.%d.%lld.avcvui(%d,%d,%d).POC:%d\n",
-		frame->frameBufIndex, frame->Y_addr, frame->U_addr,
-		frame->bufStride, frame->bufHeight, frame->picWidth,
-		frame->picHeight, frame->rectLeft, frame->rectTop,
-		frame->rectRight, frame->rectBottom, frame->bitDepth,
-		frame->mode, frame->timeTick, frame->video_full_range_flag,
-		frame->transfer_characteristics, frame->matrix_coefficients, frame->POC);
-}
-
-int VE1_AllocateBitstreamBuffer(struct device *dev, unsigned long *phys_addr,
-				unsigned long *virt_addr, unsigned long size,
-				unsigned int is_svp)
-{
-	int ret = 0;
-	unsigned int flags = 0;
-	dma_addr_t dma_phys_addr = 0;
-	void *dma_virt_addr = NULL;
-
-	if (dev == NULL || phys_addr == NULL || virt_addr == NULL ||
-	    size == 0) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"dev == NULL or phys_addr == NULL or virt_addr == NULL or size == 0\n");
-		return -1;
-	}
-
-	if (is_svp) {
-		flags = RTK_FLAG_NONCACHED | RTK_FLAG_HWIPACC |
-			RTK_FLAG_PROTECTED_V2_VIDEO_POOL;
-	} else {
-		flags = RTK_FLAG_NONCACHED | RTK_FLAG_HWIPACC |
-			RTK_FLAG_SCPUACC;
-	}
-
-	/* We can't limit the address from dma_alloc_coherent when size <= 4096 */
-	if (size < SZ_8K)
-		size = SZ_8K;
-
-	dma_virt_addr = dma_alloc_coherent(
-		dev, PAGE_ALIGN(size), &dma_phys_addr, (GFP_DMA | GFP_KERNEL));
-	if (dma_virt_addr == NULL) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"dma_alloc_coherent() fail.size:%lu(%ld).flags:0x%x\n",
-			PAGE_ALIGN(size), size, flags);
-		ret = -ENOMEM;
-		return ret;
-	}
-	*phys_addr = (unsigned long)dma_phys_addr;
-	*virt_addr = (unsigned long)dma_virt_addr;
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"dma_alloc_coherent() ok.phys_addr:0x%lx.virt_addr:0x%lx.size:%lu(%ld).flags:0x%x\n",
-		*phys_addr, *virt_addr, PAGE_ALIGN(size), size, flags);
-
-	return ret;
-}
-
-int VE1_FreeBitstreamBuffer(struct device *dev, unsigned long virt_addr,
-			    unsigned long phys_addr, unsigned int size)
-{
-	int ret = 0;
-
-	if (dev == NULL || virt_addr == 0 || phys_addr == 0 || size == 0) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"dev == NULL or virt_addr == 0 or phys_addr == 0 or size == 0\n");
-		return -1;
-	}
-
-	if (virt_addr != 0) {
-		dma_free_coherent(dev, PAGE_ALIGN(size), (void *)virt_addr,
-				  (dma_addr_t)phys_addr);
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			"dma_free_coherent() ok.phys_addr:0x%lx.virt_addr:0x%lx.size:%d(%d)\n",
-			phys_addr, virt_addr, PAGE_ALIGN(size), size);
-	}
-
-	return ret;
-}
-
-static VE1_PICTURE_MODE ve1_get_picture_mode(struct ve1_ctx *ctx)
-{
-	DecOpenParam *decOP;
-	DecOutputInfo *info;
-	struct ve1_decoded_frame *frame;
-	VE1_PICTURE_MODE mode = CONSECUTIVE_FRAME;
-
-	decOP = (DecOpenParam *)ctx->decOP;
-	info = (DecOutputInfo *)ctx->outputInfo;
-	frame = (struct ve1_decoded_frame *)&ctx
-			->frameQueue[info->indexFrameDecoded];
-
-	if (decOP->bitstreamFormat == STD_MPEG2) {
-		if (info->pictureStructure == 3) // 1:TOP, 2: BOT, 3:FRAME
-		{
-			char is_prog = 0;
-			// LINUX-74, mark the condition of "info->repeatFirstField" below,
-			// according to ISO/IEC 13818-2: 1995 (E), pg 63, the explanation of repeat_first_field,
-			// if progressive_sequence is equal to 0, whether progressive_frame is equal to 0 to 1, this reconstructed frame consists fields:
-			// repeat_first_field is 1 -> consists 3 fields, repeat_first_field is 0 -> consists 2 fields,
-			// so this frame is not progressive.
-			// ref 1185 MpegDec_SetupLinks()
-			is_prog =
-				(info->progressiveSequence /* progressive sequence */
-				 ||
-				 frame->stillVOBU); /* progressive I-picture in a DVD still-VOBU */
-
-			if (is_prog)
-				mode = CONSECUTIVE_FRAME;
-			else
-				mode = MPEG2_PIC_MODE_NOT_PROG;
-		} else {
-			if (info->pictureStructure == 1)
-				mode = INTERLEAVED_TOP_FIELD;
-			if (info->pictureStructure == 2)
-				mode = INTERLEAVED_BOT_FIELD;
-		}
-	} else if (decOP->bitstreamFormat == STD_AVC) {
-		if (info->pictureStructure) // MbaffFrameFlag = ( mb_adaptive_frame_field_flag && !field_pic_flag )
-		{
-			if (info->picStrPresent == 1) {
-				if (info->picTimingStruct == 4)
-					mode = INTERLEAVED_BOT_FIELD;
-				else
-					mode = INTERLEAVED_TOP_FIELD;
-			} else // according to poc
-			{
-				if (info->avcPocBot < info->avcPocTop)
-					mode = INTERLEAVED_BOT_FIELD;
-				else
-					mode = INTERLEAVED_TOP_FIELD;
-			}
-		} else {
-			/**decFrameInfo:  H.264/AVC, MPEG-2, and VC-1
-            @** 0 : The decoded frame has paired fields.
-            @** 1 : The decoded frame has a top-field missing.
-            @** 2 : The decoded frame has a bottom-field missing.*/
-			if (info->decFrameInfo ==
-			    0) //decoded frame is paired field or frame.
-			{
-				if (info->interlacedFrame) //field_pic_flag
-				{
-					if (info->topFieldFirst)
-						mode = INTERLEAVED_TOP_FIELD;
-					else
-						mode = INTERLEAVED_BOT_FIELD;
-				} else if (info->picStrPresent == 1) {
-					if (info->picTimingStruct ==
-						    H264_PIC_STRUCT_FRAME ||
-					    info->picTimingStruct ==
-						    H264_PIC_STRUCT_FRAME_DOUBLING ||
-					    info->picTimingStruct ==
-						    H264_PIC_STRUCT_FRAME_TRIPLING) {
-						mode = CONSECUTIVE_FRAME;
-					} else if (info->picTimingStruct == 4) {
-						mode = INTERLEAVED_BOT_FIELD;
-					} else {
-						mode = INTERLEAVED_TOP_FIELD;
-					}
-				} else {
-					mode = CONSECUTIVE_FRAME;
-				}
-			} else if (info->picStrPresent == 1) {
-				if (info->picTimingStruct == 0)
-					mode = CONSECUTIVE_FRAME;
-				else if (info->picTimingStruct == 4)
-					mode = INTERLEAVED_BOT_FIELD;
-				else
-					mode = INTERLEAVED_TOP_FIELD;
-			} else //(info->decFrameInfo != 0) //decoded frame is NPF.
-			{
-				if (info->avcNpfFieldInfo == 1)
-					mode = INTERLEAVED_BOT_FIELD; //top missing
-				else if (info->avcNpfFieldInfo == 2)
-					mode = INTERLEAVED_TOP_FIELD; //bot missing
-				else if (info->avcNpfFieldInfo == 3) {
-					ve1_err(VE1_WRAPPER_TAG,
-						"AVC: top and bot fld are missing!\n");
-				} else if (info->avcNpfFieldInfo == 0) {
-					if (info->avcPocBot <
-					    info->avcPocTop) { //if pocPic = pocTop = pocBot, still assume top fld first
-						mode = INTERLEAVED_BOT_FIELD;
-					} else
-						mode = INTERLEAVED_TOP_FIELD;
-				}
-			}
-		}
-	} else if (decOP->bitstreamFormat == STD_MPEG4) {
-		if (info->interlacedFrame == 1) {
-			if (info->topFieldFirst)
-				mode = INTERLEAVED_TOP_FIELD;
-			else
-				mode = INTERLEAVED_BOT_FIELD;
-		}
-	} else {
-		mode = CONSECUTIVE_FRAME;
-	}
-
-	return mode;
-}
-
-static int ve1_get_frame_poc(struct ve1_ctx *ctx)
-{
-	DecOpenParam *decOP;
-	DecOutputInfo *outputInfo;
-	struct ve1_decoded_frame *frame;
-	int retPOC = -1;
-
-	decOP = (DecOpenParam *)ctx->decOP;
-	outputInfo = (DecOutputInfo *)ctx->outputInfo;
-	frame = (struct ve1_decoded_frame *)&ctx
-			->frameQueue[outputInfo->indexFrameDecoded];
-
-	if (decOP->bitstreamFormat == STD_AVC) {
-		if (frame->picMode == CONSECUTIVE_FRAME) {
-			retPOC = outputInfo->avcPocPic;
-		} else {
-			if (frame->picMode == INTERLEAVED_TOP_FIELD) {
-				retPOC = outputInfo->avcPocTop;
-			} else {
-				retPOC = outputInfo->avcPocBot;
-			}
-
-			if (retPOC == 0) {
-				retPOC = outputInfo->avcPocPic;
-			}
-		}
-	}
-
-	return retPOC;
-}
-
-static char ve1_check_if_paired_field_frm(struct ve1_ctx *ctx)
-{
-	DecOpenParam *decOP;
-	DecOutputInfo *info;
-	struct ve1_decoded_frame *frame;
-	char isPairedFld = 0;
-	bool isH264PicStructPaired;
-
-	decOP = (DecOpenParam *)ctx->decOP;
-	info = (DecOutputInfo *)ctx->outputInfo;
-	frame = (struct ve1_decoded_frame *)&ctx
-			->frameQueue[info->indexFrameDecoded];
-
-	if (info->picTimingStruct == H264_PIC_STRUCT_TOP_BOTTOM ||
-	    info->picTimingStruct == H264_PIC_STRUCT_BOTTOM_TOP ||
-	    info->picTimingStruct == H264_PIC_STRUCT_TOP_BOTTOM_TOP ||
-	    info->picTimingStruct == H264_PIC_STRUCT_BOTTOM_TOP_BOTTOM) {
-		isH264PicStructPaired = true;
-	} else {
-		isH264PicStructPaired = false;
-	}
-
-	if (((decOP->bitstreamFormat == STD_MPEG2) &&
-	     (info->pictureStructure == 3) &&
-	     (frame->picMode != CONSECUTIVE_FRAME)) ||
-	    ((decOP->bitstreamFormat == STD_AVC) &&
-	     ((info->pictureStructure == 1) ||
-	      ((info->decFrameInfo == 0) &&
-	       (frame->picMode != CONSECUTIVE_FRAME)) ||
-	      ((info->picStrPresent == 1) && isH264PicStructPaired))) ||
-	    ((decOP->bitstreamFormat == STD_MPEG4) &&
-	     (info->interlacedFrame == 1) &&
-	     (frame->picMode != CONSECUTIVE_FRAME))) {
-		isPairedFld = 1;
-	}
-
-	return isPairedFld;
-}
-
-void VE1_UpdateFrameQueueInfo(void *pCtx)
-{
-	struct ve1_ctx *ctx;
-	DecOpenParam *decOP;
-	DecOutputInfo *outputInfo;
-	struct ve1_decoded_frame *frame;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decOP == NULL || ctx->outputInfo == NULL) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"decOP == NULL or outputInfo == NULL\n");
-		return;
-	}
-
-	decOP = (DecOpenParam *)ctx->decOP;
-	outputInfo = (DecOutputInfo *)ctx->outputInfo;
-
-	if (outputInfo->indexFrameDecoded >= 0) {
-		frame = (struct ve1_decoded_frame *)&ctx
-				->frameQueue[outputInfo->indexFrameDecoded];
-
-		frame->picType = (outputInfo->interlacedFrame ?
-					  outputInfo->picTypeFirst :
-					  outputInfo->picType);
-		frame->repeatFirstField =
-			(signed char)outputInfo->repeatFirstField;
-		frame->errorBlock = outputInfo->numOfErrMBs;
-		frame->mvcPairIdx = -1;
-		frame->reSend = 0;
-		frame->mvcViewIdx =
-			(signed char)outputInfo->mvcPicInfo.viewIdxDecoded;
-		frame->topFieldFirst = (signed char)outputInfo->topFieldFirst;
-		frame->stillVOBU = 0;
-		frame->qualityLevel = 0;
-		frame->picMode = ve1_get_picture_mode(ctx);
-		frame->POC = ve1_get_frame_poc(ctx);
-		frame->pairedFldFrm = ve1_check_if_paired_field_frm(ctx);
-		frame->decodingSuccess = outputInfo->decodingSuccess;
-		frame->bytePosFrameStart = outputInfo->bytePosFrameStart;
-		frame->bytePosFrameEnd = outputInfo->bytePosFrameEnd;
-		if (outputInfo->avcVuiInfo.vidSigTypePresent) {
-			frame->video_full_range_flag =
-				outputInfo->avcVuiInfo.vidFullRange;
-			if (outputInfo->avcVuiInfo.colorDescPresent) {
-				frame->colour_primaries =
-					outputInfo->avcVuiInfo.colorPrimaries;
-				frame->transfer_characteristics =
-					outputInfo->avcVuiInfo
-						.vuiTransferCharacteristics;
-				frame->matrix_coefficients =
-					outputInfo->avcVuiInfo
-						.vuiMatrixCoefficients;
-			} else {
-				frame->colour_primaries = 0;
-				frame->transfer_characteristics = 0;
-				frame->matrix_coefficients = 0;
-			}
-		} else {
-			frame->video_full_range_flag = 0;
-		}
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			"type:%d.mode:%d.poc:%d.paired:%d.err:%d.avcvui(%d,%d,%d,%d)\n",
-			frame->picType, frame->picMode, frame->POC,
-			frame->pairedFldFrm, frame->errorBlock,
-			frame->video_full_range_flag, frame->colour_primaries,
-			frame->transfer_characteristics,
-			frame->matrix_coefficients);
-	}
-}
-
-static void rtkve1_dump_bs(struct ve1_ctx *ctx, uint8_t *buf,
-					uint32_t size)
-{
-#if defined(RTKVE1_DUMP_BS_EN)
-	int filp_open_flags;
-	ssize_t bytes = 0;
-	loff_t pos = 0;
-
-	if (ctx == NULL) {
-		return;
-	}
-
-	if ((buf != NULL) && (size != 0)) {
-		if (ctx->bNewBsDumpFile == 1) {
-			ctx->bNewBsDumpFile = 0;
-			filp_open_flags = O_CREAT | O_WRONLY;
-			memset(ctx->bsDumpFileName, 0, sizeof(unsigned char)*256);
-			snprintf(ctx->bsDumpFileName, 256,
-					"/media/removable/32G_BLACK/ve1bs_%d.es",
-					gBsDumpSerial);
-			gBsDumpSerial++;
-			vpu_info("%d.%s.create new ve1bs dump:%s\n",__LINE__,__func__,
-					ctx->bsDumpFileName);
-		} else {
-			filp_open_flags = O_APPEND | O_WRONLY;
-		}
-		ctx->bsDumpFile =
-			(void *)filp_open(ctx->bsDumpFileName, filp_open_flags, 0);
-		if (IS_ERR((struct file *)ctx->bsDumpFile)) {
-			ve1_err(VE1_WRAPPER_TAG, "filp_open %s fail\n",
-					ctx->bsDumpFileName);
-		} else {
-			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			//		"filp_open %s ok\n",
-			//		ctx->bsDumpFileName);
-			bytes =
-				kernel_write((struct file *)(ctx->bsDumpFile),
-							(void *)buf, (size_t)size, &pos);
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"kernel_write bytes:%ld.pos:%lld\n", bytes, pos);
-			filp_close((struct file *)(ctx->bsDumpFile), NULL);
-			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			//		"filp_close %s\n",
-			//		ctx->bsDumpFileName);
-			ctx->bsDumpFile = NULL;
-		}
-	}
-#endif
-}
-
-void rtkve1_copy_to_bitstream_buffer(struct ve1_ctx *ctx, uint8_t *buf,
-				     uint32_t size)
-{
-	unsigned long bsEndAddr = 0; // physical address
-	unsigned long newBsWrPtr = 0; // physical address
-	unsigned long virtBsWrPtr = 0; // virtual address
-	int size0 = 0;
-	int size1 = 0;
-
-	rtkve1_dump_bs(ctx, buf, size);
-
-	bsEndAddr = ctx->bitstream.paddr + ctx->bitstream.size;
-	newBsWrPtr = ctx->bsWrPtr + size;
-	virtBsWrPtr =
-		ve1_ring_phys_to_virt(ctx->bsWrPtr, ctx->bitstream.paddr,
-				      (unsigned long)ctx->bitstream.vaddr);
-
-	if (newBsWrPtr >= bsEndAddr) {
-		size0 = bsEndAddr - ctx->bsWrPtr;
-		size1 = size - size0;
-
-		if (ctx->is_svp) {
-#if defined(ENABLE_TEE_DRM_FLOW)
-			if (ctx->out_vb2_q_memory == V4L2_MEMORY_MMAP) {
-				ret = ta_TEEapi_memcpy_a7(
-					(struct tee_context *)
-						decHandle->teeapi_ctx,
-					decHandle->teeapi_tee_session,
-					ctx->bsWrPtr, buf, size0);
-				if (ret < 0) {
-					ve1_err(VE1_WRAPPER_TAG,
-						"ta_TEEapi_memcpy_a7() fail.bsWrPtr:0x%lx.buf:0x%px.size0:%d\n",
-						ctx->bsWrPtr, buf, size0);
-					return -1;
-				}
-
-				ret = ta_TEEapi_memcpy_a7(
-					(struct tee_context *)
-						decHandle->teeapi_ctx,
-					decHandle->teeapi_tee_session,
-					ctx->bitstream.paddr, buf + size0,
-					size1);
-				if (ret < 0) {
-					ve1_err(VE1_WRAPPER_TAG,
-						"ta_TEEapi_memcpy_a7() fail.bsStartAddr:0x%lx.buf+size0:0x%px.size1:%d\n",
-						ctx->bitstream.paddr,
-						buf + size0, size1);
-					return -1;
-				}
-			} else if (ctx->out_vb2_q_memory ==
-				   V4L2_MEMORY_DMABUF) {
-				ret = ta_TEEapi_memcpy(
-					(struct tee_context *)
-						decHandle->teeapi_ctx,
-					decHandle->teeapi_tee_session,
-					ctx->bsWrPtr, (uintptr_t)buf, size0);
-				if (ret < 0) {
-					ve1_err(VE1_WRAPPER_TAG,
-						"ta_TEEapi_memcpy() fail.bsWrPtr:0x%lx.buf:0x%px.size0:%d\n",
-						ctx->bsWrPtr, buf, size0);
-					return -1;
-				}
-
-				ret = ta_TEEapi_memcpy(
-					(struct tee_context *)
-						decHandle->teeapi_ctx,
-					decHandle->teeapi_tee_session,
-					ctx->bitstream.paddr,
-					(uintptr_t)buf + size0, size1);
-				if (ret < 0) {
-					ve1_err(VE1_WRAPPER_TAG,
-						"ta_TEEapi_memcpy() fail.bsStartAddr:0x%lx.buf+size0:0x%px.size1:%d\n",
-						ctx->bitstream.paddr,
-						buf + size0, size1);
-					return -1;
-				}
-			}
-#endif // #if defined(ENABLE_TEE_DRM_FLOW)
-		} else {
-			osal_memcpy((void *)virtBsWrPtr, (void *)buf, size0);
-			osal_memcpy((void *)ctx->bitstream.vaddr,
-				    (void *)(buf + size0), size1);
-		}
-		ctx->bsWrPtr = ctx->bitstream.paddr + size1;
-	} else {
-		if (ctx->is_svp) {
-#if defined(ENABLE_TEE_DRM_FLOW)
-			if (ctx->out_vb2_q_memory == V4L2_MEMORY_MMAP) {
-				ret = ta_TEEapi_memcpy_a7(
-					(struct tee_context *)
-						decHandle->teeapi_ctx,
-					decHandle->teeapi_tee_session,
-					ctx->bsWrPtr, buf, size);
-				if (ret < 0) {
-					ve1_err(VE1_WRAPPER_TAG,
-						"ta_TEEapi_memcpy_a7() fail.bsWrPtr:0x%lx.buf:0x%px.size:%d\n",
-						ctx->bsWrPtr, buf, size);
-					return -1;
-				}
-			} else if (ctx->out_vb2_q_memory ==
-				   V4L2_MEMORY_DMABUF) {
-				ret = ta_TEEapi_memcpy(
-					(struct tee_context *)
-						decHandle->teeapi_ctx,
-					decHandle->teeapi_tee_session,
-					ctx->bsWrPtr, (uintptr_t)buf, size);
-				if (ret < 0) {
-					ve1_err(VE1_WRAPPER_TAG,
-						"ta_TEEapi_memcpy() fail.bsWrPtr:0x%lx.buf:0x%px.size:%d\n",
-						ctx->bsWrPtr, buf, size);
-					return -1;
-				}
-			}
-#endif // #if defined(ENABLE_TEE_DRM_FLOW)
-		} else {
-			osal_memcpy((void *)virtBsWrPtr, (void *)buf, size);
-		}
-		ctx->bsWrPtr = newBsWrPtr;
-	}
-}
-
-int32_t BuildSeqHeader(void *pCtx, uint8_t *buf, uint32_t buf_size)
-{
-	struct ve1_ctx *ctx;
-	DecOpenParam *decOP;
-	uint8_t *pbMetaData = buf;
-	uint8_t *p = pbMetaData;
-	int32_t size = 0; // metadata header size
-	uint32_t codingType = 0;
-	uint32_t nFrameWidth, nFrameHeight, picWidth, picHeight;
-	uint32_t width_in_pixels, height_in_pixels;
-	uint32_t signature = MAKE_FOURCC('D', 'K', 'I', 'F');
-	uint32_t version = 0x00;
-	uint32_t length_of_header_in_bytes = 0x20;
-	uint32_t codec_FourCC = MAKE_FOURCC('V', 'P', '8', '0');
-	uint32_t time_base_denominator = 30;
-//	uint32_t time_base_numerator = -1;
-	uint32_t number_of_frames_in_file = 0;
-	uint32_t unused = 0;
-
-
-	if (buf == NULL || buf_size <= 0) {
-		ve1_err(VE1_WRAPPER_TAG, "buf == NULL || size <= 0\n");
-		return -1;
-	}
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-
-	ctx = (struct ve1_ctx *)pCtx;
-	decOP = (DecOpenParam *)ctx->decOP;
-
-	if (ctx->seqHeader == NULL) {
-		ctx->seqHeader = kmalloc(MAX_CHUNK_HEADER_SIZE, GFP_KERNEL);
-	}
-
-	codingType = decOP->bitstreamFormat;
-	size = 0;
-
-	if (codingType == STD_VP8) {
-		if (ctx->seqHeaderSize == 0) {
-			nFrameWidth = decOP->frameWidth;
-			nFrameHeight = decOP->frameHeight;
-			//20160926, workaround for invalid resolution
-			if (buf_size >= 10) {
-				picWidth =
-					(uint32_t)(p[7] << 8 | p[6]);
-				picHeight =
-					(uint32_t)(p[9] << 8 | p[8]);
-				if (picWidth <= 1920 && picHeight <= 1088) {
-					nFrameWidth = picWidth;
-					nFrameHeight = picHeight;
-				}
-			}
-			width_in_pixels = nFrameWidth;
-			height_in_pixels = nFrameHeight;
-
-			//signature 'DKIF'
-			ctx->seqHeader[0] = (unsigned char)(signature >> 0);
-			ctx->seqHeader[1] = (unsigned char)(signature >> 8);
-			ctx->seqHeader[2] = (unsigned char)(signature >> 16);
-			ctx->seqHeader[3] = (unsigned char)(signature >> 24);
-			//version
-			ctx->seqHeader[4] = (unsigned char)(version >> 0);
-			ctx->seqHeader[5] = (unsigned char)(version >> 8);
-			//length of header in bytes
-			ctx->seqHeader[6] =
-				(unsigned char)(length_of_header_in_bytes >> 0);
-			ctx->seqHeader[7] =
-				(unsigned char)(length_of_header_in_bytes >> 8);
-			//codec FourCC of VP80
-			ctx->seqHeader[8] = (unsigned char)(codec_FourCC >> 0);
-			ctx->seqHeader[9] = (unsigned char)(codec_FourCC >> 8);
-			ctx->seqHeader[10] =
-				(unsigned char)(codec_FourCC >> 16);
-			ctx->seqHeader[11] =
-				(unsigned char)(codec_FourCC >> 24);
-			//width
-			ctx->seqHeader[12] =
-				(unsigned char)(width_in_pixels >> 0);
-			ctx->seqHeader[13] =
-				(unsigned char)(width_in_pixels >> 8);
-			//height
-			ctx->seqHeader[14] =
-				(unsigned char)(height_in_pixels >> 0);
-			ctx->seqHeader[15] =
-				(unsigned char)(height_in_pixels >> 8);
-			//frame rate
-			ctx->seqHeader[16] =
-				(unsigned char)(time_base_denominator >> 0);
-			ctx->seqHeader[17] =
-				(unsigned char)(time_base_denominator >> 8);
-			ctx->seqHeader[18] =
-				(unsigned char)(time_base_denominator >> 16);
-			ctx->seqHeader[19] =
-				(unsigned char)(time_base_denominator >> 24);
-			//time scale(?)
-			ctx->seqHeader[20] =
-				(unsigned char)(number_of_frames_in_file >> 0);
-			ctx->seqHeader[21] =
-				(unsigned char)(number_of_frames_in_file >> 8);
-			ctx->seqHeader[22] =
-				(unsigned char)(number_of_frames_in_file >> 16);
-			ctx->seqHeader[23] =
-				(unsigned char)(number_of_frames_in_file >> 24);
-			//number of frames in file
-			ctx->seqHeader[24] =
-				(unsigned char)(number_of_frames_in_file >> 0);
-			ctx->seqHeader[25] =
-				(unsigned char)(number_of_frames_in_file >> 8);
-			ctx->seqHeader[26] =
-				(unsigned char)(number_of_frames_in_file >> 16);
-			ctx->seqHeader[27] =
-				(unsigned char)(number_of_frames_in_file >> 24);
-			//unused
-			ctx->seqHeader[28] = (unsigned char)(unused >> 0);
-			ctx->seqHeader[29] = (unsigned char)(unused >> 8);
-			ctx->seqHeader[30] = (unsigned char)(unused >> 16);
-			ctx->seqHeader[31] = (unsigned char)(unused >> 24);
-			size += 32;
-		}
-	} else {
-		size = 0;
-	}
-
-	ctx->seqHeaderSize += size;
-
-	return size;
-}
-
-int32_t BuildPicHeader(void *pCtx, uint8_t *buf, uint32_t buf_size)
-{
-	struct ve1_ctx *ctx;
-	DecOpenParam *decOP;
-	int32_t size = 0;
-	uint32_t codingType = 0;
-
-	if (buf == NULL || buf_size <= 0) {
-		ve1_err(VE1_WRAPPER_TAG, "buf == NULL || size <= 0\n");
-		return -1;
-	}
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-
-	ctx = (struct ve1_ctx *)pCtx;
-	decOP = (DecOpenParam *)ctx->decOP;
-
-	if (ctx->picHeader == NULL) {
-		ctx->picHeader = kmalloc(MAX_CHUNK_HEADER_SIZE, GFP_KERNEL);
-	}
-
-	codingType = decOP->bitstreamFormat;
-	size = 0;
-
-	if (codingType == STD_VP8) {
-		//size of frame in bytes (not including the 12-byte header)
-		ctx->picHeader[0] = (unsigned char)(buf_size >> 0);
-		ctx->picHeader[1] = (unsigned char)(buf_size >> 8);
-		ctx->picHeader[2] = (unsigned char)(buf_size >> 16);
-		ctx->picHeader[3] = (unsigned char)(buf_size >> 24);
-		//64-bit presentation timestamp
-		ctx->picHeader[4] = 0;
-		ctx->picHeader[5] = 0;
-		ctx->picHeader[6] = 0;
-		ctx->picHeader[7] = 0;
-		ctx->picHeader[8] = 0;
-		ctx->picHeader[9] = 0;
-		ctx->picHeader[10] = 0;
-		ctx->picHeader[11] = 0;
-		size += 12;
-	}
-
-	return size;
-}
-
-int VE1_DecUpdateBS(void *pCtx, uint8_t *buf, uint32_t size)
-{
-	struct ve1_ctx *ctx;
-	DecHandle decHandle = NULL;
-	int ret = 0;
-	unsigned long valid_data = 0;
-	bool queueRet = false;
-	DecOpenParam *decOP;
-	unsigned int seqHdrSize = 0;
-	unsigned int picHdrSize = 0;
-	unsigned int totalUpBsSize = 0;
-	unsigned int frame_chunk_len = 0;
-
-	if (buf == NULL || size <= 0) {
-		ve1_err(VE1_WRAPPER_TAG, "buf == NULL || size <= 0\n");
-		return -1;
-	}
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "decHandle == NULL\n");
-		return -1;
-	}
-	decHandle = (DecHandle)ctx->decHandle;
-
-	if (ctx->decOP == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx->decOP is NULL\n");
-		return -1;
-	}
-	decOP = (DecOpenParam *)ctx->decOP;
-
-	if (decOP->bitstreamFormat == STD_VP8) {
-		seqHdrSize = BuildSeqHeader((void *)ctx, buf, size);
-		if (seqHdrSize > 0) {
-			rtkve1_copy_to_bitstream_buffer(ctx, ctx->seqHeader,
-							seqHdrSize);
-			totalUpBsSize += seqHdrSize;
-		}
-		picHdrSize = BuildPicHeader((void *)ctx, buf, size);
-		if (picHdrSize > 0) {
-			frame_chunk_len = (ctx->picHeader[0]) |
-					  (ctx->picHeader[1] << 8) |
-					  (ctx->picHeader[2] << 16) |
-					  (ctx->picHeader[3] << 24);
-			rtkve1_copy_to_bitstream_buffer(ctx, ctx->picHeader,
-							picHdrSize);
-			totalUpBsSize += picHdrSize;
-		}
-	}
-
-	rtkve1_copy_to_bitstream_buffer(ctx, buf, size);
-	totalUpBsSize += size;
-
-	ret = VPU_DecUpdateBitstreamBuffer(decHandle, totalUpBsSize);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"VPU_DecUpdateBitstreamBuffer fail.ret:%d.size:%d\n",
-			ret, totalUpBsSize);
-		return -1;
-	} else {
-		if ((ctx->seqInited) &&
-			(decOP->bitstreamMode == BS_MODE_PIC_END) &&
-		    (decOP->bitstreamFormat == STD_AVC ||
-		     decOP->bitstreamFormat == STD_MPEG2 ||
-			 decOP->bitstreamFormat == STD_VP8)) {
-			ctx->bPostponeUpBs = true;
-		}
-		ctx->accuBsFeedBytes += totalUpBsSize;
-		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-			ret, totalUpBsSize, ctx->accuBsFeedBytes);
-
-		VE1_DecGetRdWrPtr(ctx);
-		// handle priority of bWaitNextField is higher than bBufEmptyFlag
-		if (ctx->bWaitNextField) {
-			if (ctx->bBufEmptyFlag) {
-				ctx->bBufEmptyFlag = false;
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"bWaitNextField.clear bBufEmptyFlag\n");
-			}
-			ctx->bGotNextField = true;
-			if (ctx->fldDoneVpuRp != ctx->vpuRdPtr) {
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"FATAL.bWaitNextField.fld_rp:0x%x != vpu_rp:0x%x\n",
-					ctx->fldDoneVpuRp, ctx->vpuRdPtr);
-			}
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"bWaitNextField.set rdPtr:0x%x.clear int_reason\n",
-				ctx->vpuRdPtr);
-			VPU_DecSetRdPtr((DecHandle)ctx->decHandle,
-					ctx->vpuRdPtr, 0);
-			VPU_ClearInterrupt(VE1_COREIDX);
-			ctx->int_reason = 0;
-			ctx->bWaitNextField = false;
-			queueRet =
-				queue_work(ctx->workqueue, &ctx->pic_run_work);
-			if (queueRet)
-				ctx->cntQueuePicRunWorkOk++;
-			else
-				ctx->cntQueuePicRunWorkFail++;
-			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"queue_work pic_run_work.cnt(%d,%d).ret:%d\n",
-				ctx->cntQueuePicRunWorkOk,
-				ctx->cntQueuePicRunWorkFail, queueRet);
-		} else if (ctx->bBufEmptyFlag) {
-			if (((DecOpenParam *)ctx->decOP)->bitstreamMode ==
-			    BS_MODE_INTERRUPT) {
-				valid_data = ve1_ring_valid_data(
-					ctx->bitstream.paddr,
-					ctx->bitstream.paddr +
-						ctx->bitstream.size,
-					ctx->vpuRdPtr, ctx->vpuWrPtr);
-				if (valid_data >= 1024) {
-					ctx->bBufEmptyFlag = false;
-				}
-			} else {
-				ctx->bBufEmptyFlag = false;
-			}
-			if (!ctx->bBufEmptyFlag) {
-				queueRet = queue_work(ctx->workqueue,
-						      &ctx->pic_run_work);
-				if (queueRet)
-					ctx->cntQueuePicRunWorkOk++;
-				else
-					ctx->cntQueuePicRunWorkFail++;
-				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"queue_work pic_run_work.cnt(%d,%d).ret:%d\n",
-					ctx->cntQueuePicRunWorkOk,
-					ctx->cntQueuePicRunWorkFail, queueRet);
-			}
-		}
-	}
-
-	return 0;
-}
-
-int rtkve1_flush_bitstream(void *pCtx)
-{
-	int ret = 0;
-	struct ve1_ctx *ctx;
-	DecHandle decHandle = NULL;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "decHandle == NULL\n");
-		return -1;
-	}
-	decHandle = (DecHandle)ctx->decHandle;
-
-	mutex_lock(&ctx->ve1_mutex);
-	ctx->accuBsFeedBytes = 0;
-	ctx->bsRdPtr = ctx->bsWrPtr;
-	ret = VPU_DecSetRdPtr(decHandle, ctx->bsWrPtr, 1);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"VPU_DecSetRdPtr fail.ret:%d\n", ret);
-		ret = -1;
-		goto out;
-	}
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"VPU_DecSetRdPtr(0x%x, 1)\n",
-		(unsigned int)ctx->bsWrPtr);
-	VE1_DecGetRdWrPtr(pCtx);
-
-	if (ctx->streamEnd) {
-		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
-											STREAM_END_CLEAR_FLAG);
-		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d\n",
-			ret, STREAM_END_CLEAR_FLAG);
-		VE1_DecGetRdWrPtr(ctx);
-		ctx->streamEnd = 0;
-	}
-	ctx->handle_eos_by = VE1_HANDLE_EOS_BY_NONE;
-	ctx->bPostponeUpBs = false;
-	ctx->dpbFull = 0;
-
-out:
-	mutex_unlock(&ctx->ve1_mutex);
-	return ret;
-}
-
-int rtkve1_flush(void *pCtx)
-{
-	int ret = 0;
-	struct ve1_ctx *ctx;
-	DecHandle decHandle = NULL;
-    int vpu_timeout_cnt = 1000;
-	unsigned int dispFlag = 0xffffffff;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "decHandle == NULL\n");
-		return -1;
-	}
-	decHandle = (DecHandle)ctx->decHandle;
-
-	mutex_lock(&ctx->ve1_mutex);
-	ctx->bFlush = true;
-	mutex_unlock(&ctx->ve1_mutex);
-
-	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
-		"bf flush_work pic_run_work\n");
-	flush_work(&ctx->pic_run_work);
-	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
-		"af flush_work pic_run_work\n");
-
-	mutex_lock(&ctx->ve1_mutex);
-	ctx->bFlush = false;
-	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
-		"VE1_DecCheckComplete\n");
-	VE1_DecCheckComplete(ctx);
-
-    if (VPU_IsBusy(VE1_COREIDX)) {
-        VPU_DecUpdateBitstreamBuffer(decHandle, STREAM_END_SET_FLAG);
-		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d\n",
-			ret, STREAM_END_SET_FLAG);
-		VE1_DecGetRdWrPtr(pCtx);
-        while (VPU_IsBusy(VE1_COREIDX) && vpu_timeout_cnt > 0) {
-            vpu_timeout_cnt --;
-            usleep_range(1000, 1000);
-        }
-        VPU_DecUpdateBitstreamBuffer(decHandle, STREAM_END_CLEAR_FLAG);
-		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d\n",
-			ret, STREAM_END_CLEAR_FLAG);
-		VE1_DecGetRdWrPtr(pCtx);
-		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
-			"vpu_timeout_cnt:%d\n",vpu_timeout_cnt);
-    }
-	ret = VPU_DecFrameBufferFlush(decHandle, NULL, NULL);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"VPU_DecFrameBufferFlush fail.ret:%d\n", ret);
-		ret = -1;
-		goto out;
-	}
-
-	ret = VPU_DecSetDispFlag(decHandle, dispFlag);
-	if (ret != RETCODE_SUCCESS) {
-		ve1_err(VE1_WRAPPER_TAG,
-			"VPU_DecSetDispFlag fail.ret:%d\n", ret);
-		ret = -1;
-		goto out;
-	}
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		"VPU_DecSetDispFlag.dispFlag:0x%x\n", dispFlag);
-
-	ctx->dpbFull = 0;
-	ctx->outputinfoSN = 0;
-	ctx->decodedFrmNum = 0;
-	ctx->displayFrmNum = 0;
-	ctx->lastInfoFrmStart = 0;
-	ctx->lastInfoFrmEnd = 0;
-
-	ret = 0;
-out:
-	mutex_unlock(&ctx->ve1_mutex);
-	return ret;
-}
\ No newline at end of file
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateful/ve2.c
===================================================================
--- kernel-5_15.orig/drivers/media/platform/realtek/vpu/stateful/ve2.c
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateful/ve2.c
@@ -295,6 +295,20 @@ int ve2_stop_streaming(struct vb2_queue
 			goto exit;
 		}
 
+		if(ctx->streamoff_cap) {
+			ret = ve2rpc_pause(ctx->cap_hndl);
+			if (ret) {
+				vpu_err("cap ve2rpc_pause fail\n");
+				goto exit;
+			}
+
+			ret = ve2rpc_flush(ctx->cap_hndl);
+			if (ret) {
+				vpu_err("cap ve2rpc_fluse fail\n");
+				goto exit;
+			}
+		}
+
 		ret = ve2rpc_reset_bs_ring_rwptr(ctx->out_hndl);
 		if (ret) {
 			vpu_err("reset bs_ringbuffer_rwptr fail\n");
@@ -316,13 +330,13 @@ int ve2_stop_streaming(struct vb2_queue
 			goto exit;
 		}
 
-		ret = ve2rpc_reset_output_ring_rwptr(ctx->cap_hndl);
+		ret = ve2rpc_reset_msg_ring_rwptr(ctx->cap_hndl);
 		if (ret) {
 			vpu_err("reset frm_ringbuffer_rwptr fail\n");
 			goto exit;
 		}
 
-		ret = ve2rpc_reset_buflock(ctx->cap_hndl, false, false);
+		ret = ve2rpc_reset_buflock(ctx->cap_hndl, false);
 		if (ret) {
 			vpu_err("ve2rpc_reset_buflock fail\n");
 			goto exit;
@@ -792,7 +806,7 @@ static void ve2_free_capture(void *ve_ct
 			goto exit;
 		}
 
-		ret = ve2rpc_reset_buflock(ctx->cap_hndl, true, E_BUFLOCK_ST_UNLOCK);
+		ret = ve2rpc_reset_buflock(ctx->cap_hndl, true);
 		if (ret) {
 			vpu_err("ve2rpc_reset_buflock to UNLOCK fail\n");
 			goto exit;
@@ -805,12 +819,6 @@ static void ve2_free_capture(void *ve_ct
 		goto exit;
 	}
 
-	ret = ve2rpc_reset_buflock(ctx->cap_hndl, true, E_BUFLOCK_ST_NORMAL);
-	if (ret) {
-		vpu_err("ve2rpc_reset_buflock fail\n");
-		goto exit;
-	}
-
 	if (ctx->is_run) {
 		ret = ve2rpc_flush(ctx->cap_hndl);
 		if (ret) {
@@ -852,7 +860,7 @@ static void ve2_free_context(void *ve_ct
 			goto exit;
 		}
 
-		ret = ve2rpc_reset_buflock(ctx->cap_hndl, true, E_BUFLOCK_ST_UNLOCK);
+		ret = ve2rpc_reset_buflock(ctx->cap_hndl, true);
 		if (ret) {
 			vpu_err("ve2rpc_reset_buflock fail\n");
 			goto exit;
@@ -1132,6 +1140,7 @@ MODULE_SOFTDEP("pre: rtk_fw_remoteproc")
 #endif
 
 MODULE_VERSION(xstr(GIT_VERSION));
+MODULE_IMPORT_NS(DMA_BUF);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("William Lee <william.lee@realtek.com>");
 MODULE_DESCRIPTION("V4L2 Realtek Video Engine 2 Codec Driver");
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateful/ve2rpc.c
===================================================================
--- kernel-5_15.orig/drivers/media/platform/realtek/vpu/stateful/ve2rpc.c
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateful/ve2rpc.c
@@ -1782,11 +1782,70 @@ struct rtkve2_buflock_t *ve2rpc_get_unus
 	return buflock;
 }
 
+static int ve2rpc_clear_buflock_thread(void *data)
+{
+	struct ve2rpc *hndl = (struct ve2rpc *)data;
+	struct ve2rpc_qframe_st *entry = NULL;
+	struct ve2rpc_qframe_st *tmp_entry = NULL;
+	uint32_t buflock_pa = 0;
+	volatile uint8_t *buflock_va;
+	int i = 0;
+
+	while (1) {
+		int ret;
+		ret = wait_event_interruptible_timeout(
+			hndl->buflock_waitq,
+			kthread_should_stop(),
+			msecs_to_jiffies(5));
+
+		if (kthread_should_stop() || (ret == -ERESTART)) {
+			mutex_lock(&hndl->qframe.lock);
+			list_for_each_entry_safe (entry, tmp_entry, &hndl->qframe.list, list) {
+				list_del(&entry->list);
+				kfree(entry);
+			}
+			mutex_unlock(&hndl->qframe.lock);
+			break;
+		}
+
+		mutex_lock(&hndl->qframe.lock);
+		list_for_each_entry_safe (entry, tmp_entry, &hndl->qframe.list, list) {
+			buflock_va = entry->buflock_va;
+			buflock_pa = entry->buflock_pa;
+			mutex_lock(&hndl->buflock_mutex);
+			if (hndl->buflock_force_quit) {
+				list_del(&entry->list);
+				kfree(entry);
+			} else if (*buflock_va == E_BUFLOCK_ST_RELEASE) {
+				*buflock_va = E_BUFLOCK_ST_NORMAL;
+				for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
+					if (buflock_pa == hndl->buflock_info[i].buflock_pa) {
+						hndl->buflock_info[i].is_used = 0;
+					}
+				}
+				list_del(&entry->list);
+				kfree(entry);
+			}
+			mutex_unlock(&hndl->buflock_mutex);
+		}
+		mutex_unlock(&hndl->qframe.lock);
+	}
+
+	hndl->buflock_force_quit = 0;
+	return 1;
+}
+
 int ve2rpc_add_to_buflock_clear_q(struct ve2rpc *cap_hndl, uint32_t buflock_pa,
 	volatile uint8_t *buflock_va)
 {
 	struct ve2rpc_qframe_st *re_qframe;
 
+	if (!cap_hndl->buflock_thread) {
+		init_waitqueue_head(&cap_hndl->buflock_waitq);
+		cap_hndl->buflock_thread = kthread_run(
+			ve2rpc_clear_buflock_thread, cap_hndl, "buflockthread");
+	}
+
 	re_qframe = kmalloc(sizeof(struct ve2rpc_qframe_st),
 			GFP_KERNEL | __GFP_ZERO);
 	if (!re_qframe) {
@@ -1802,13 +1861,11 @@ int ve2rpc_add_to_buflock_clear_q(struct
 	list_add_tail(&re_qframe->list, &cap_hndl->qframe.list);
 	mutex_unlock(&cap_hndl->qframe.lock);
 
-	queue_delayed_work(cap_hndl->qframe.wq, &cap_hndl->qframe.work,
-			   msecs_to_jiffies(2));
-
+	wake_up_interruptible(&cap_hndl->buflock_waitq);
 	return 0;
 }
 
-static void ve2rpc_add_to_mesgQ(struct ve2rpc *cap_hndl, uint32_t buflock_pa)
+static void ve2rpc_add_to_msgQ(struct ve2rpc *cap_hndl, uint32_t buflock_pa)
 {
 	uint32_t frm_idx = 0;
 	volatile ve2rpc_flash_frame_info_t *frame;
@@ -1904,60 +1961,12 @@ int ve2rpc_qframe(struct ve2rpc *cap_hnd
 	buflock_va = buflock_info->buflock_va;
 
 	mutex_lock(&prb->lock);
-	ve2rpc_add_to_mesgQ(cap_hndl, buflock_info->buflock_pa);
+	ve2rpc_add_to_msgQ(cap_hndl, buflock_info->buflock_pa);
 	mutex_unlock(&prb->lock);
 
 	return ret;
 }
 
-void ve2rpc_clear_buflock_wq(struct work_struct *work)
-{
-	struct ve2rpc_qframe_wq *wq = container_of(
-		to_delayed_work(work), struct ve2rpc_qframe_wq, work);
-	struct ve2rpc_qframe_st *entry = NULL;
-	struct ve2rpc_qframe_st *tmp_entry = NULL;
-	uint32_t buflock_pa;
-	struct ve2rpc *hndl;
-	int i = 0;
-
-	list_for_each_entry_safe (entry, tmp_entry, &wq->list, list) {
-		mutex_lock(&wq->lock);
-		if (entry) {
-			buflock_pa = entry->buflock_pa;
-			hndl = entry->hndl;
-			if (hndl->buflock_reset) {
-				list_del(&entry->list);
-				kfree(entry);
-				mutex_unlock(&wq->lock);
-				continue;
-			}
-			mutex_lock(&hndl->buflock_mutex);
-			if ((*entry->buflock_va) != E_BUFLOCK_ST_RELEASE) {
-				mutex_unlock(&hndl->buflock_mutex);
-				vpu_output_dbg(
-					"re_qframe buflock(%d) wait to RELEASE\n",
-					(*entry->buflock_va));
-				queue_delayed_work(wq->wq, &wq->work,
-						   msecs_to_jiffies(1));
-
-				mutex_unlock(&wq->lock);
-				continue;
-			}
-
-			/* DO NOT CHANGE THE ORDER START*/
-			*entry->buflock_va = E_BUFLOCK_ST_NORMAL;
-			for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
-				if (buflock_pa == hndl->buflock_info[i].buflock_pa)
-					hndl->buflock_info[i].is_used = 0;
-			}
-			mutex_unlock(&hndl->buflock_mutex);
-
-			list_del(&entry->list);
-			kfree(entry);
-		}
-		mutex_unlock(&wq->lock);
-	}
-}
 
 static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 			     uint64_t *pts, int frm_idx, bool *eos,
@@ -2012,7 +2021,7 @@ static int _ve2rpc_get_frame(struct ve2r
 		vpu_output_dbg("No decoded frame with no show frame count %d", *no_show_frm_cnt);
 		ret = -ENODATA;
 		*no_frame = true;
-		ve2rpc_add_to_mesgQ(cap_hndl, buflock_phy_addr);
+		ve2rpc_add_to_msgQ(cap_hndl, buflock_phy_addr);
 		goto exit;
 	}
 
@@ -2290,7 +2299,7 @@ exit:
 	return ret;
 }
 
-int ve2rpc_reset_output_ring_rwptr(struct ve2rpc *cap_hndl)
+int ve2rpc_reset_msg_ring_rwptr(struct ve2rpc *cap_hndl)
 {
 	volatile ve2rpc_flash_frame_info_t *frame;
 	volatile uint32_t rptr = 0;
@@ -2334,31 +2343,21 @@ exit:
 	return ret;
 }
 
-int ve2rpc_reset_buflock(struct ve2rpc *cap_hndl, bool reset_all,
-	enum buflock_status st)
+int ve2rpc_reset_buflock(struct ve2rpc *cap_hndl, bool force_unlock)
 {
 	volatile uint8_t *buflock_va;
 	int i = 0;
 
-	if (reset_all) {
-		cap_hndl->buflock_reset = 1;
-		flush_workqueue(cap_hndl->qframe.wq);
-		cap_hndl->buflock_reset = 0;
-	}
-
 	for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
 		int add_to_wait_q = 0;
 
 		buflock_va = cap_hndl->buflock_info[i].buflock_va;
 		mutex_lock(&cap_hndl->buflock_mutex);
-		if (reset_all) {
-			if (st == E_BUFLOCK_ST_UNLOCK) {
+		if (force_unlock) {
+			if (*buflock_va != E_BUFLOCK_ST_NORMAL &&
+				cap_hndl->buflock_info[i].is_used != 0) {
 				*buflock_va = E_BUFLOCK_ST_UNLOCK;
-				cap_hndl->buflock_info[i].is_used = 0;
 				add_to_wait_q = 1;
-			} else if (st == E_BUFLOCK_ST_NORMAL) {
-				*buflock_va = E_BUFLOCK_ST_NORMAL;
-				cap_hndl->buflock_info[i].is_used = 0;
 			}
 		}
 		else {
@@ -2547,8 +2546,6 @@ int ve2rpc_init_cap_handle(struct device
 		dsb(sy);
 		/* DO NOT CHANGE THE ORDER END*/
 	}
-	hndl->qframe.wq = create_workqueue("ve2rpc_qframe_wq");
-	INIT_DELAYED_WORK(&hndl->qframe.work, ve2rpc_clear_buflock_wq);
 	INIT_LIST_HEAD(&hndl->qframe.list);
 	INIT_LIST_HEAD(&hndl->qframe.tlist);
 	mutex_init(&hndl->qframe.lock);
@@ -2566,11 +2563,11 @@ int ve2rpc_uninit_handle(struct ve2rpc *
 	}
 
 	if (V4L2_TYPE_IS_CAPTURE(hndl->type)) {
-		hndl->buflock_reset = 1;
-		if (hndl->qframe.wq) {
-			flush_workqueue(hndl->qframe.wq);
-			destroy_workqueue(hndl->qframe.wq);
-			hndl->qframe.wq = NULL;
+		hndl->buflock_force_quit = 1;
+		if(hndl->buflock_thread) {
+			wake_up_interruptible(&hndl->buflock_waitq);
+			kthread_stop(hndl->buflock_thread);
+			hndl->buflock_thread = NULL;
 		}
 		mutex_destroy(&hndl->qframe.lock);
 		mutex_destroy(&hndl->travel_mutex);
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateful/ve2rpc.h
===================================================================
--- kernel-5_15.orig/drivers/media/platform/realtek/vpu/stateful/ve2rpc.h
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateful/ve2rpc.h
@@ -134,8 +134,6 @@ struct color_metrix {
 };
 
 struct ve2rpc_qframe_wq {
-	struct workqueue_struct *wq;
-	struct delayed_work work;
 	struct list_head list;
 	struct list_head tlist; //for traveling frame
 	struct mutex lock;
@@ -188,10 +186,12 @@ struct ve2rpc {
 	struct ve2rpc_ringbuf_t dpb_rb;
 	uint32_t instanceType;
 	uint32_t instanceID;
+	struct task_struct *buflock_thread;
+	wait_queue_head_t buflock_waitq;
 	struct mutex buflock_mutex;
 	void *buflock;
 	struct rtkve2_buflock_t *buflock_info;
-	bool buflock_reset;
+	bool buflock_force_quit;
 	uintptr_t *frame;
 	struct ve2rpc_qframe_wq qframe;
 	struct mutex lock;
@@ -254,8 +254,7 @@ int ve2rpc_free_travel_frame(struct ve2r
 int ve2rpc_add_travel_entry(struct ve2rpc *cap_hndl,
 	uint32_t y_phy_addr, uint32_t buflock_phy_addr,
 	void *vb2_v4l2_buf, uint32_t idx);
-int ve2rpc_reset_buflock(struct ve2rpc *cap_hndl, bool reset_all,
-			   enum buflock_status st);
+int ve2rpc_reset_buflock(struct ve2rpc *cap_hndl, bool reset_all);
 int ve2rpc_run(struct ve2rpc *hndl);
 int ve2rpc_get_info(struct ve2rpc *cap_hndl, uint32_t *info);
 int ve2rpc_inband_eos_event(struct ve2rpc_ringbuf_t *ringbuf,
@@ -286,7 +285,7 @@ int ve2rpc_get_bs_info(struct device *de
 		       uint32_t *ddr_height, uint32_t *min_reqbuf,
 		       uint32_t *bit_depth);
 int ve2rpc_enable_drop_cnt(struct ve2rpc *hndl);
-int ve2rpc_reset_output_ring_rwptr(struct ve2rpc *cap_hndl);
+int ve2rpc_reset_msg_ring_rwptr(struct ve2rpc *cap_hndl);
 int ve2rpc_reset_bs_ring_rwptr(struct ve2rpc *out_hndl);
 void __maybe_unused dump_buflock(struct ve2rpc *cap_hndl);
 
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateful/ve2rpc_cmd.h
===================================================================
--- kernel-5_15.orig/drivers/media/platform/realtek/vpu/stateful/ve2rpc_cmd.h
+++ /dev/null
@@ -1,581 +0,0 @@
-/*
- * Realtek video decoder v4l2 driver
- *
- * Copyright (c) 2021 Realtek Semiconductor Corp. All rights reserved.
- *
- * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
- *
- * This software component is confidential and proprietary to Realtek
- * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
- * or in part, of this work and its derivatives without express permission
- * is prohibited.
- */
-#ifndef __VE2RPC_CMD_H__
-#define __VE2RPC_CMD_H__
-
-#define RPC_VIDEO 0x1
-#define S_OK 0x10000000
-
-enum buflock_status {
-	E_BUFLOCK_ST_ERROR,
-	E_BUFLOCK_ST_NORMAL, /* initial state, set by ARM, allow VFW to access ve2rpc_flash_frame_info_t */
-	E_BUFLOCK_ST_TOUCH, /* VFW has completed filling ve2rpc_flash_frame_info_t, the status is set by VFW */
-	E_BUFLOCK_ST_LOCK, /* ARM start to access ve2rpc_flash_frame_info_t, the status is set by ARM */
-	E_BUFLOCK_ST_UNLOCK,
-	E_BUFLOCK_ST_RELEASE,
-};
-
-enum VIDEO_STREAM_TYPE {
-	VIDEO_STREAM_MPEG1 = 0,
-	VIDEO_STREAM_MPEG2 = 1,
-	VIDEO_STREAM_MPEG4 = 2,
-	VIDEO_STREAM_DV3 = 3,
-	VIDEO_STREAM_H263 = 4,
-	VIDEO_STREAM_H264 = 5,
-	VIDEO_STREAM_VC1 = 6,
-	VIDEO_STREAM_REALVIDEO = 7,
-	VIDEO_STREAM_MJPEG = 8,
-	VIDEO_STREAM_VP6 = 9,
-	VIDEO_STREAM_AVS = 10,
-	VIDEO_STREAM_YUV = 11,
-	VIDEO_STREAM_VP8 = 12,
-	VIDEO_STREAM_WMV7 = 13,
-	VIDEO_STREAM_WMV8 = 14,
-	VIDEO_STREAM_RAW = 15,
-	VIDEO_STREAM_THEORA = 16,
-	VIDEO_STREAM_UNKNOWN = 17,
-	VIDEO_STREAM_FJPEG = 18,
-	VIDEO_STREAM_H265 = 19,
-	VIDEO_STREAM_VP9 = 20,
-	VIDEO_STREAM_H264lv51 = 21,
-	VIDEO_STREAM_AVS2 = 22,
-	VIDEO_STREAM_AV1 = 23,
-};
-typedef enum VIDEO_STREAM_TYPE VIDEO_STREAM_TYPE;
-
-#define VIDEO_RPC_COMMON_ToAgent_Create 10
-#define VIDEO_RPC_COMMON_ToAgent_Connect 20
-#define VIDEO_RPC_COMMON_ToAgent_InitRingBuffer 30
-#define VIDEO_RPC_COMMON_ToAgent_Run 40
-#define VIDEO_RPC_COMMON_ToAgent_Pause 50
-#define VIDEO_RPC_COMMON_ToAgent_Stop 60
-#define VIDEO_RPC_COMMON_ToAgent_Destroy 70
-#define VIDEO_RPC_COMMON_ToAgent_Flush 80
-#define VIDEO_RPC_COMMON_ToAgent_SetRefClock 90
-#define VIDEO_RPC_COMMON_ToAgent_VideoCreate 100
-#define VIDEO_RPC_COMMON_ToAgent_VideoConfig 105
-#define VIDEO_RPC_COMMON_ToAgent_VideoMemoryConfig 108
-#define VIDEO_RPC_COMMON_ToAgent_VideoChunkConfig 109
-#define VIDEO_RPC_COMMON_ToAgent_VideoDestroy 110
-#define VIDEO_RPC_COMMON_ToAgent_RequestBuffer 120
-#define VIDEO_RPC_COMMON_ToAgent_ReleaseBuffer 130
-#define VIDEO_RPC_COMMON_ToAgent_ConfigLowDelay 133
-#define VIDEO_RPC_COMMON_ToAgent_SetDebugMemory 140
-#define VIDEO_RPC_COMMON_ToAgent_VCPU_DEBUG_COMMAND 141
-#define VIDEO_RPC_COMMON_ToAgent_VideoHalt 150
-#define VIDEO_RPC_COMMON_ToAgent_YUYV2RGB 160
-#define VIDEO_RPC_COMMON_ToAgent_Self_Destroy 170
-#define VIDEO_RPC_ToAgent_SetResourceInfo 550
-#define VIDEO_RPC_DEC_ToAgent_CmprsCtrl 1005
-#define VIDEO_RPC_DEC_ToAgent_DecimateCtrl 1006
-#define VIDEO_RPC_DEC_ToAgent_SetSpeed 1010
-#define VIDEO_RPC_DEC_ToAgent_SetErrorConcealmentLevel 1015
-#define VIDEO_RPC_DEC_ToAgent_Init 1020
-#define VIDEO_RPC_DEC_ToAgent_SetDeblock 1030
-#define VIDEO_RPC_DEC_ToAgent_GetVideoSequenceInfo 1035
-#define VIDEO_RPC_DEC_ToAgent_GetVideoSequenceInfo_New 1036
-#define VIDEO_RPC_DEC_ToAgent_BitstreamValidation 1040
-#define VIDEO_RPC_DEC_ToAgent_ParseResolution 1041
-#define VIDEO_RPC_DEC_ToAgent_Capability 1045
-#define VIDEO_RPC_DEC_ToAgent_SetDecoderCCBypass 1050
-#define VIDEO_RPC_DEC_ToAgent_SetDNR 1060
-#define VIDEO_RPC_DEC_ToAgent_SetRefSyncLimit 1065
-#define VIDEO_RPC_FLASH_ToAgent_SetOutput 1085
-#define VIDEO_RPC_THUMBNAIL_ToAgent_SetVscalerOutputFormat 1070
-#define VIDEO_RPC_THUMBNAIL_ToAgent_SetThreshold 1080
-#define VIDEO_RPC_VOUT_ToAgent_SetV2alpha 3090
-#define VIDEO_RPC_THUMBNAIL_ToAgent_SetStartPictureNumber 1090
-#define VIDEO_RPC_DEC_ToAgent_PrivateInfo 1095
-#define VIDEO_RPC_SUBPIC_DEC_ToAgent_Configure 5040
-#define VIDEO_RPC_SUBPIC_DEC_ToAgent_Page 5050
-#define VIDEO_RPC_JPEG_ToAgent_DEC 6010
-#define VIDEO_RPC_JPEG_ToAgent_DEC_BATCH 6011
-#define VIDEO_RPC_TRANSITION_ToAgent_Start 6020
-#define VIDEO_RPC_MIXER_FILTER_ToAgent_Configure 8010
-#define VIDEO_RPC_MIXER_FILTER_ToAgent_ConfigureWindow 8020
-#define VIDEO_RPC_MIXER_FILTER_ToAgent_SetMasterWindow 8030
-#define VIDEO_RPC_MIXER_ToAgent_PlayOneMotionJpegFrame 8040
-
-typedef enum _tagRingBufferType {
-	RINGBUFFER_STREAM,
-	RINGBUFFER_COMMAND,
-	RINGBUFFER_MESSAGE,
-	RINGBUFFER_VBI,
-	RINGBUFFER_PTS,
-	RINGBUFFER_DTVCC,
-	RINGBUFFER_STREAM1,
-	RINGBUFFER_COMMAND1,
-	RINGBUFFER_MESSAGE1,
-	RINGBUFFER_STREAM_BL,
-	RINGBUFFER_COMMAND_BL,
-	RINGBUFFER_STREAM_EL,
-	RINGBUFFER_COMMAND_EL,
-	RINGBUFFER_STREAM_MD,
-	RINGBUFFER_COMMAND_MD,
-	RINGBUFFER_STREAM_SUBES,
-	RINGBUFFER_COMMAND_SUBIB,
-	RINGBUFFER_FRAME_USER,
-	RINGBUFFER_FAKE
-} RINGBUFFER_TYPE;
-
-/** inband cmd type. I use prefix "VIDEO_DEC_" to label the cmd used in video decoder. */
-typedef enum {
-	INBAND_CMD_TYPE_PTS = 0,
-	INBAND_CMD_TYPE_PTS_SKIP,
-	INBAND_CMD_TYPE_NEW_SEG,
-	INBAND_CMD_TYPE_SEQ_END,
-	INBAND_CMD_TYPE_EOS,
-	INBAND_CMD_TYPE_CONTEXT,
-	INBAND_CMD_TYPE_DECODE,
-
-	/* Video Decoder In-band Command */
-	VIDEO_DEC_INBAND_CMD_TYPE_VOBU,
-	VIDEO_DEC_INBAND_CMD_TYPE_DVDVR_DCI_CCI,
-	VIDEO_DEC_INBAND_CMD_TYPE_DVDV_VATR,
-
-	/* MSG Type for parse mode */
-	VIDEO_DEC_INBAND_CMD_TYPE_SEG_INFO,
-	VIDEO_DEC_INBAND_CMD_TYPE_PIC_INFO,
-
-	/* Sub-picture Decoder In-band Command */
-	VIDEO_SUBP_INBAND_CMD_TYPE_SET_PALETTE,
-	VIDEO_SUBP_INBAND_CMD_TYPE_SET_HIGHLIGHT,
-
-	/* Video Mixer In-band Command */
-	VIDEO_MIXER_INBAND_CMD_TYPE_SET_BG_COLOR,
-	VIDEO_MIXER_INBAND_CMD_TYPE_SET_MIXER_RPTS,
-	VIDEO_MIXER_INBAND_CMD_TYPE_BLEND,
-
-	/* Video Scaler In-band Command */
-	VIDEO_SCALER_INBAND_CMD_TYPE_OUTPUT_FMT,
-
-	/*Dv3 resolution In-band Command*/
-	VIDEO_DV3_INBAND_CMD_TYPE_RESOLUTION,
-
-	/*MPEG4 detected In-band command*/
-	VIDEO_MPEG4_INBAND_CMD_TYPE_MP4,
-	/* Audio In-band Commands Start Here */
-
-	/* DV In-band Commands */
-	VIDEO_DV_INBAND_CMD_TYPE_VAUX,
-	VIDEO_DV_INBAND_CMD_TYPE_FF, //fast forward
-
-	/* Transport Demux In-band command */
-	VIDEO_TRANSPORT_DEMUX_INBAND_CMD_TYPE_PID,
-	VIDEO_TRANSPORT_DEMUX_INBAND_CMD_TYPE_PTS_OFFSET,
-	VIDEO_TRANSPORT_DEMUX_INBAND_CMD_TYPE_PACKET_SIZE,
-
-	/* Real Video In-band command */
-	VIDEO_RV_INBAND_CMD_TYPE_FRAME_INFO,
-	VIDEO_RV_INBAND_CMD_TYPE_FORMAT_INFO,
-	VIDEO_RV_INBAND_CMD_TYPE_SEGMENT_INFO,
-
-	/*VC1 video In-band command*/
-	VIDEO_VC1_INBAND_CMD_TYPE_SEQ_INFO,
-
-	/* general video properties */
-	VIDEO_INBAND_CMD_TYPE_VIDEO_USABILITY_INFO,
-	VIDEO_INBAND_CMD_TYPE_VIDEO_MPEG4_USABILITY_INFO,
-
-	/*MJPEG resolution In-band Command*/
-	VIDEO_MJPEG_INBAND_CMD_TYPE_RESOLUTION,
-
-	/* picture object for graphic */
-	VIDEO_GRAPHIC_INBAND_CMD_TYPE_PICTURE_OBJECT,
-	VIDEO_GRAPHIC_INBAND_CMD_TYPE_DISPLAY_INFO,
-
-	/* subtitle offset sequence id for 3D video */
-	VIDEO_DEC_INBAND_CMD_TYPE_SUBP_OFFSET_SEQUENCE_ID,
-
-	VIDEO_H264_INBAND_CMD_TYPE_DPBBYPASS,
-
-	/* Clear back frame to black color and send it to VO */
-	VIDEO_FJPEG_INBAND_CMD_TYPE_CLEAR_SCREEN,
-
-	/* each picture info of MJPEG */
-	VIDEO_FJPEG_INBAND_CMD_TYPE_PIC_INFO,
-
-	/*FJPEG resolution In-band Command*/
-	VIDEO_FJPEG_INBAND_CMD_TYPE_RESOLUTION,
-
-	/*VO receive VP_OBJ_PICTURE_TYPE In-band Command*/
-	VIDEO_VO_INBAND_CMD_TYPE_OBJ_PIC,
-	VIDEO_VO_INBAND_CMD_TYPE_OBJ_DVD_SP,
-	VIDEO_VO_INBAND_CMD_TYPE_OBJ_DVB_SP,
-	VIDEO_VO_INBAND_CMD_TYPE_OBJ_BD_SP,
-	VIDEO_VO_INBAND_CMD_TYPE_OBJ_SP_FLUSH,
-	VIDEO_VO_INBAND_CMD_TYPE_OBJ_SP_RESOLUTION,
-
-	/* VO receive writeback buffers In-band Command */
-	VIDEO_VO_INBAND_CMD_TYPE_WRITEBACK_BUFFER,
-
-	/* for VO debug, VO can dump picture */
-	VIDEO_VO_INBAND_CMD_TYPE_DUMP_PIC,
-	VIDEO_CURSOR_INBAND_CMD_TYPE_PICTURE_OBJECT,
-	VIDEO_CURSOR_INBAND_CMD_TYPE_COORDINATE_OBJECT,
-	VIDEO_TRANSCODE_INBAND_CMD_TYPE_PICTURE_OBJECT,
-	VIDEO_WRITEBACK_INBAND_CMD_TYPE_PICTURE_OBJECT,
-
-	VIDEO_VO_INBAND_CMD_TYPE_OBJ_BD_SCALE_RGB_SP,
-
-	// TV code
-	VIDEO_INBAND_CMD_TYPE_DV_CERTIFY,
-
-	/*M_DOMAIN resolution In-band Command*/
-	VIDEO_INBAND_CMD_TYPE_M_DOMAIN_RESOLUTION,
-
-	/* DTV source In-band Command */
-	VIDEO_INBAND_CMD_TYPE_SOURCE_DTV,
-
-	/* Din source copy mode In-band Command */
-	VIDEO_DIN_INBAND_CMD_TYPE_COPY_MODE,
-
-	/* Video Decoder AU In-band command */
-	VIDEO_DEC_INBAND_CMD_TYPE_AU,
-
-	/* Video Decoder parse frame In-band command */
-	VIDEO_DEC_INBAND_CMD_TYPE_PARSE_FRAME_IN,
-	VIDEO_DEC_INBAND_CMD_TYPE_PARSE_FRAME_OUT,
-
-	/* Set video decode mode In-band command */
-	VIDEO_DEC_INBAND_CMD_TYPE_NEW_DECODE_MODE,
-
-	/* Secure buffer protection */
-	VIDEO_INBAND_CMD_TYPE_SECURE_PROTECTION,
-
-	/* Dolby HDR inband command */
-	VIDEO_DEC_INBAND_CMD_TYPE_DV_PROFILE,
-
-	/* VP9 HDR10 In-band command */
-	VIDEO_VP9_INBAND_CMD_TYPE_HDR10_METADATA,
-
-	/* AV1 HDR10 In-band command */
-	VIDEO_AV1_INBAND_CMD_TYPE_HDR10_METADATA,
-
-	/* DvdPlayer tell RVSD video BS ring buffer is full */
-	VIDEO_DEC_INBAND_CMD_TYPE_BS_RINGBUF_FULL,
-
-	/* Frame Boundary In-band command */
-	VIDEO_INBAND_CMD_TYPE_FRAME_BOUNDARY = 100,
-
-	/* VO receive npp writeback buffers In-band Command */
-	VIDEO_NPP_INBAND_CMD_TYPE_WRITEBACK_BUFFER,
-	VIDEO_NPP_OUT_INBAND_CMD_TYPE_OBJ_PIC,
-
-	/* hevc encoder raw yuv data In-band Commnad */
-	VENC_INBAND_CMD_TYPE_RAWYUV,
-
-	/* hevc encoder ref yuv addr In-band Commnad */
-	VENC_INBAND_CMD_TYPE_REFYUV,
-
-	/* add frame info for user allocate */
-	VIDEO_FRAME_INBAND_ADD,
-
-	/* delete frame info for user allocate */
-	VIDEO_FRAME_INBAND_DELETE,
-} INBAND_CMD_TYPE;
-
-enum VIDEO_VF_TYPE {
-	VF_TYPE_VIDEO_MPEG2_DECODER = 0,
-	VF_TYPE_VIDEO_MPEG4_DECODER = 1,
-	VF_TYPE_VIDEO_DV_DECODER = 2,
-	VF_TYPE_VIDEO_H263_DECODER = 3,
-	VF_TYPE_VIDEO_H264_DECODER = 4,
-	VF_TYPE_VIDEO_VC1_DECODER = 5,
-	VF_TYPE_VIDEO_REAL_DECODER = 6,
-	VF_TYPE_VIDEO_JPEG_DECODER = 7,
-	VF_TYPE_VIDEO_MJPEG_DECODER = 8,
-	VF_TYPE_SPU_DECODER = 9,
-	VF_TYPE_VIDEO_OUT = 10,
-	VF_TYPE_TRANSITION = 11,
-	VF_TYPE_THUMBNAIL = 12,
-	VF_TYPE_VIDEO_VP6_DECODER = 13,
-	VF_TYPE_VIDEO_IMAGE_DECODER = 14,
-	VF_TYPE_FLASH = 15,
-	VF_TYPE_VIDEO_AVS_DECODER = 16,
-	VF_TYPE_MIXER = 17,
-	VF_TYPE_VIDEO_VP8_DECODER = 18,
-	VF_TYPE_VIDEO_WMV7_DECODER = 19,
-	VF_TYPE_VIDEO_WMV8_DECODER = 20,
-	VF_TYPE_VIDEO_RAW_DECODER = 21,
-	VF_TYPE_VIDEO_THEORA_DECODER = 22,
-	VF_TYPE_VIDEO_FJPEG_DECODER = 23,
-	VF_TYPE_VIDEO_H265_DECODER = 24,
-	VF_TYPE_VIDEO_VP9_DECODER = 25,
-	VF_TYPE_VIDEO_H264lv51_DECODER = 26,
-	VF_TYPE_VIDEO_CAPTURER = 27,
-	VF_TYPE_RAWCONV = 28,
-	VF_TYPE_TVD = 29,
-	VF_TYPE_VIDEO_ENCODER = 30,
-	VF_TYPE_VIDEO_SPLITTER = 31,
-	VF_TYPE_VIDEO_AVS2_DECODER = 32,
-	VF_TYPE_VIDEO_AV1_DECODER = 33,
-};
-typedef enum VIDEO_VF_TYPE VIDEO_VF_TYPE;
-
-typedef enum {
-	NORMAL_DECODE = 0,
-	I_ONLY_DECODE,
-	FASTFR_DECODE,
-	RESERVED1,
-	TS_NORMAL_DECODE,
-	TS_I_ONLY_DECODE,
-	TS_FASTFR_DECODE,
-	RESERVED2,
-	BITSTREAM_PARSING,
-	TRANSCODE_PARSING,
-	NORMAL_DECODE_MVC,
-	//TV code
-	NORMAL_I_ONLY_DECODE,
-	IP_ONLY_DECODE,
-	VDEC_DIRECT_DECODE = 16,
-	DRIP_I_ONLY_DECODE = 17,
-	NORMAL_DECODE_LOWDELAY = 18,
-	NO_REF_SYNC_DECODE = 32
-} DECODE_MODE;
-
-typedef struct {
-	INBAND_CMD_TYPE type;
-	unsigned int size;
-} INBAND_CMD_PKT_HEADER;
-
-typedef struct {
-	INBAND_CMD_PKT_HEADER header;
-	unsigned int wPtr;
-} NEW_SEG;
-
-typedef struct {
-	INBAND_CMD_PKT_HEADER header;
-	unsigned int RelativePTSH;
-	unsigned int RelativePTSL;
-	unsigned int PTSDurationH;
-	unsigned int PTSDurationL;
-	unsigned int skip_GOP;
-	DECODE_MODE mode;
-	unsigned int isHM91; /* for HEVC codec version 1: HM91 0: HM10+*/
-	unsigned int useAbsolutePTS; /* 0: relative PTS, 1: absolute PTS */
-} DECODE_NEW;
-
-typedef struct {
-	INBAND_CMD_PKT_HEADER header;
-	unsigned int wPtr;
-	unsigned int PTSH;
-	unsigned int PTSL;
-	unsigned int PTSH2;
-	unsigned int PTSL2;
-	unsigned int length;
-	unsigned int flag;
-} PTS_INFO2;
-
-typedef struct {
-	INBAND_CMD_PKT_HEADER header;
-	unsigned int lu_addr;
-	unsigned int ch_addr;
-	unsigned int decimate_lu_addr;
-	unsigned int decimate_ch_addr;
-	unsigned int cmprs_hdr_lu;
-	unsigned int cmprs_hdr_ch;
-	unsigned int width;
-	unsigned int height;
-	unsigned int decimate_width;
-	unsigned int decimate_height;
-	unsigned int ddr_width;
-	unsigned int ddr_height;
-	unsigned int cmprs_hdr_size;
-	unsigned int cmprs_en;
-	unsigned int lossy_en;
-	unsigned int lossy_ratio;
-	unsigned int bit_depth;
-	unsigned int decimate_en;
-	unsigned int decimate_ratio;
-} FRAME_INFO_IN;
-
-typedef struct {
-	INBAND_CMD_PKT_HEADER header;
-	unsigned int lu_addr;
-} FRAME_INFO_OUT;
-
-/**
-	\brief Mark a EOS on an address.
-		This is the last inband command of a segment and is mandatary.
-	\param wPtr
-*/
-typedef struct {
-	INBAND_CMD_PKT_HEADER header;
-	unsigned int wPtr;
-	unsigned int eventID;
-} EOS;
-
-typedef struct RPCRES_LONG {
-	uint32_t result;
-	uint32_t data;
-} RPCRES_LONG;
-
-struct RPC_RINGBUFFER {
-	unsigned int instanceID;
-	unsigned int pinID;
-	unsigned int readPtrIndex;
-	unsigned int pRINGBUFF_HEADER;
-};
-typedef struct RPC_RINGBUFFER RPC_RINGBUFFER;
-
-struct VIDEO_RPC_INSTANCE {
-	enum VIDEO_VF_TYPE type;
-};
-typedef struct VIDEO_RPC_INSTANCE VIDEO_RPC_INSTANCE;
-
-struct RPC_CONNECTION {
-	unsigned int srcInstanceID;
-	unsigned int srcPinID;
-	unsigned int desInstanceID;
-	unsigned int desPinID;
-	unsigned int mediaType;
-};
-typedef struct RPC_CONNECTION RPC_CONNECTION;
-
-struct VIDEO_RPC_DEC_SET_SPEED {
-	uint32_t instanceID;
-	uint32_t displaySpeed;
-	uint32_t decodeSkip;
-};
-typedef struct VIDEO_RPC_DEC_SET_SPEED VIDEO_RPC_DEC_SET_SPEED;
-
-struct VIDEO_RPC_DEC_INIT {
-	uint32_t instanceID;
-	VIDEO_STREAM_TYPE type;
-	struct VIDEO_RPC_DEC_SET_SPEED set_speed;
-};
-typedef struct VIDEO_RPC_DEC_INIT VIDEO_RPC_DEC_INIT;
-typedef struct RPC_STRUCT RPC_STRUCT;
-struct RPC_STRUCT {
-	uint32_t programID; // program ID defined in IDL file
-	uint32_t versionID; // version ID defined in IDL file
-	uint32_t procedureID; // function ID defined in IDL file
-	uint32_t taskID; // the caller's task ID, assign 0 if NONBLOCK_MODE
-	uint32_t sysTID;
-	uint32_t sysPID; // the callee's task ID
-	uint32_t parameterSize; // packet's body size
-	uint32_t context; // return address of reply value
-};
-;
-struct VIDEO_RPC_VOUT_MESSAGE {
-	uint32_t instanceID;
-	uint32_t message;
-	uint32_t PTShigh;
-	uint32_t PTSlow;
-	uint32_t reserved1;
-	uint32_t reserved2;
-	uint32_t reserved3;
-	uint32_t reserved4;
-};
-typedef struct VIDEO_RPC_VOUT_MESSAGE VIDEO_RPC_VOUT_MESSAGE;
-struct VIDEO_RPC_DEC_MEDIA_INFO {
-	uint32_t instanceID;
-	uint32_t width;
-	uint32_t height;
-	uint32_t frame_rate;
-	uint32_t aspect_ratio_n;
-	uint32_t aspect_ratio_d;
-	uint32_t level;
-	uint32_t profile;
-	uint32_t type_3D;
-	uint32_t par_width;
-	uint32_t par_height;
-	uint32_t type_LR;
-	uint32_t type_Scan;
-	uint32_t afd;
-};
-typedef struct VIDEO_RPC_DEC_MEDIA_INFO VIDEO_RPC_DEC_MEDIA_INFO;
-struct VIDEO_RPC_DEC_ERROR_INFO {
-	uint32_t instanceID;
-	uint32_t errCode;
-};
-typedef struct VIDEO_RPC_DEC_ERROR_INFO VIDEO_RPC_DEC_ERROR_INFO;
-
-enum VIDEO_DECODER_CC_BYPASS_MODE {
-	VIDEODECODER_CC_DROP = 0,
-	VIDEODECODER_CC_BYPASS = 1,
-	VIDEODECODER_CC_DECODE = 2,
-	VIDEODECODER_CC_CALLBACK = 3,
-};
-
-struct VIDEO_RPC_DEC_CC_BYPASS_MODE {
-	uint32_t instanceID;
-	enum VIDEO_DECODER_CC_BYPASS_MODE cc_mode;
-};
-typedef struct VIDEO_RPC_DEC_CC_BYPASS_MODE VIDEO_RPC_DEC_CC_BYPASS_MODE;
-
-enum CMPRS_RATIO {
-	CMPRS_RATIO_50 = 0,
-	CMPRS_RATIO_75 = 1,
-};
-typedef enum CMPRS_RATIO CMPRS_RATIO;
-
-struct VIDEO_RPC_DEC_CMPRS_CTRL {
-	uint32_t instanceID;
-	uint8_t mode;
-	enum CMPRS_RATIO ratio;
-	uint8_t enable;
-};
-typedef struct VIDEO_RPC_DEC_CMPRS_CTRL VIDEO_RPC_DEC_CMPRS_CTRL;
-
-struct VIDEO_RPC_DEC_BITSTREAM_BUFFER {
-	uint32_t bsBase;
-	uint32_t bsSize;
-	enum VIDEO_VF_TYPE type;
-};
-typedef struct VIDEO_RPC_DEC_BITSTREAM_BUFFER VIDEO_RPC_DEC_BITSTREAM_BUFFER;
-
-struct VIDEO_RPC_DEC_BV_RESULT {
-	uint32_t bitRate;
-	uint32_t type;
-};
-typedef struct VIDEO_RPC_DEC_BV_RESULT VIDEO_RPC_DEC_BV_RESULT;
-
-struct VIDEO_RPC_DEC_PV_RESULT {
-	uint32_t width;
-	uint32_t height;
-	uint32_t bit_depth;
-	uint32_t DPB_size;
-};
-typedef struct VIDEO_RPC_DEC_PV_RESULT VIDEO_RPC_DEC_PV_RESULT;
-
-enum VIDEO_RESOURCE_CORE_TYPE {
-        VIDEO_RESOURCE_CORE_REALTEK = 0,
-        VIDEO_RESOURCE_CORE_GOOGLE = 0 + 1,
-        VIDEO_RESOURCE_CORE_IP1 = 0 + 2,
-        VIDEO_RESOURCE_CORE_IP2 = 0 + 3,
-        VIDEO_RESOURCE_CORE_DUAL = 0 + 4,
-};
-typedef enum VIDEO_RESOURCE_CORE_TYPE VIDEO_RESOURCE_CORE_TYPE;
-
-struct VIDEO_RPC_RESOURCE_INFO {
-	int32_t resource_ctrl_sets;
-	enum VIDEO_RESOURCE_CORE_TYPE core_type;
-	int32_t video_port;
-	int32_t max_width;
-	int32_t max_height;
-	uint32_t instanceID;
-	int32_t width;
-	int32_t height;
-	int32_t framerate;
-	int32_t second_resource_ctrl_sets;
-};
-typedef struct VIDEO_RPC_RESOURCE_INFO VIDEO_RPC_RESOURCE_INFO;
-
-typedef int HRESULT;
-#define VIDEO_RPC_DEC_ToSystem_FatalError 63
-#define VIDEO_RPC_DEC_ToSystem_Deliver_MediaInfo 1020
-#define VIDEO_RPC_ToSystem_VoutMessage 1021
-#define REPLYID 99 // for registering the Reply_Handler
-#endif
\ No newline at end of file
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateful/vpu.c
===================================================================
--- kernel-5_15.orig/drivers/media/platform/realtek/vpu/stateful/vpu.c
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateful/vpu.c
@@ -384,6 +384,7 @@ static int vpu_buf_done(struct v4l2_fh *
 {
 	struct vpu_ctx *ctx = fh_to_vpu(fh);
 	unsigned long flags;
+	const struct v4l2_event eos_event = { .type = V4L2_EVENT_EOS };
 
 	v4l2_buf->field = V4L2_FIELD_NONE;
 	v4l2_buf->flags = V4L2_BUF_FLAG_KEYFRAME;
@@ -395,20 +396,16 @@ static int vpu_buf_done(struct v4l2_fh *
 
 	spin_lock_irqsave(&ctx->vpu_spin_lock, flags);
 
-	if (eos && no_frame) {
-		const struct v4l2_event eos_event = { .type = V4L2_EVENT_EOS };
-
-		vb2_set_plane_payload(&v4l2_buf->vb2_buf, 0, 0);
+	if (eos) {
+		vpu_info("%d.%s.ctx->last_buf_done = true\n", __LINE__,
+			 __func__);
+		if (no_frame)
+			vb2_set_plane_payload(&v4l2_buf->vb2_buf, 0, 0);
 		v4l2_m2m_last_buffer_done(fh->m2m_ctx, v4l2_buf);
 		v4l2_event_queue_fh(fh, &eos_event);
 		ctx->last_buf_done = true;
 	} else {
 		v4l2_m2m_buf_done(v4l2_buf, VB2_BUF_STATE_DONE);
-		if (eos) {
-			vpu_info("%d.%s.ctx->last_buf_done = true\n", __LINE__,
-				 __func__);
-			ctx->last_buf_done = true;
-		}
 	}
 
 	spin_unlock_irqrestore(&ctx->vpu_spin_lock, flags);
@@ -1157,8 +1154,6 @@ static int vpu_qbuf(struct v4l2_fh *fh,
 {
 	struct vpu_ctx *ctx = vq_to_vpu(vb->vb2_queue);
 	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
-	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
-	const struct v4l2_event eos_event = { .type = V4L2_EVENT_EOS };
 	int ret;
 
 	if (!ctx->veng_ops)
@@ -1184,18 +1179,7 @@ static int vpu_qbuf(struct v4l2_fh *fh,
 		if (ctx->stop_cmd && !v4l2_m2m_num_src_bufs_ready(fh->m2m_ctx))
 			op->vpu_stop_cmd(fh);
 
-		if (ctx->last_buf_done) {
-			vpu_info(
-				"%d.%s.last empty frame.v4l2_m2m_last_buffer_done:0x%px\n",
-				__LINE__, __func__, vbuf);
-			vb2_set_plane_payload(vb, 0, 0);
-			v4l2_m2m_last_buffer_done(fh->m2m_ctx, vbuf);
-			v4l2_event_queue_fh(fh, &eos_event);
-			ret = 0;
-		} else {
-			ret = ctx->veng_ops->ve_cap_qbuf(fh, vb);
-		}
-
+		ret = ctx->veng_ops->ve_cap_qbuf(fh, vb);
 		if (!ret) {
 			wake_up_interruptible(&ctx->vpu_cap_waitq);
 		}
@@ -1280,6 +1264,7 @@ static int vpu_reset_resource(void *fh)
 			ctx->thread_cap = NULL;
 		}
 
+		mutex_lock(&ctx->vpu_mutex);
 		ctx->veng_ops->ve_free_context(vid_ctx->ve_ctx);
 		ctx->veng_ops = NULL;
 
@@ -1299,6 +1284,7 @@ static int vpu_reset_resource(void *fh)
 		ctx->last_buf_done = false;
 		ctx->cap_retry_cnt = 0;
 		ctx->out_q_cnt = 0;
+		mutex_unlock(&ctx->vpu_mutex);
 	}
 
 	return 0;
@@ -1309,6 +1295,7 @@ static int vpu_free_capture(void *fh)
 	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
 	struct vpu_ctx *ctx = fh_to_vpu(fh);
 
+	mutex_lock(&ctx->vpu_mutex);
 	if(vid_ctx && vid_ctx->ve_ctx &&
 		ctx && ctx->veng_ops && ctx->veng_ops->ve_free_capture) {
 		if (ctx->thread_cap) {
@@ -1321,6 +1308,7 @@ static int vpu_free_capture(void *fh)
 		ctx->memory_cap = 0;
 		ctx->cap_retry_cnt = 0;
 	}
+	mutex_unlock(&ctx->vpu_mutex);
 
 	return 0;
 }
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-hw.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-hw.c
@@ -0,0 +1,2741 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Coda980 series multi-standard codec IP - decoder interface
+ *
+ * Copyright (C) 2024 CHIPS&MEDIA INC
+ */
+#include <linux/iopoll.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fh.h>
+#include <media/videobuf2-v4l2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/videobuf2-vmalloc.h>
+#include "coda-vpuapi.h"
+#include "coda-vdi.h"
+//#include "coda.h"
+#include "coda-regdefine.h"
+#include "coda-vpuapi.h"
+
+//#define DEBUG_STATELESS
+
+#define VPU_BUSY_CHECK_TIMEOUT 10000000
+#define MBC_SET_SUBBLK_EN                                                      \
+	(MBC_BASE + 0xA0) // subblk_man_mode[20] cr_subblk_man_en[19:0]
+#define CODE_BUF_SIZE (228 * 1024)
+#define TEMP_BUF_SIZE (224 * 1024)
+
+#define MAX_CODE_BUF_SIZE (512 * 1024)
+
+#define GEN_XY2AXI(INV, ZER, TBX, XY, BIT)                                     \
+	((INV) << 7 | (ZER) << 6 | (TBX) << 5 | (XY) << 4 | (BIT))
+#define GEN_CONFIG(A, B, C, D, E, F, G, H, I)                                  \
+	((A) << 20 | (B) << 19 | (C) << 18 | (D) << 17 | (E) << 16 |           \
+	 (F) << 12 | (G) << 8 | (H) << 4 | (I))
+#define X_SEL 0
+#define Y_SEL 1
+
+static int coda_wait_vpu_busy(struct vpu_device *vpu_dev, unsigned int addr)
+{
+	u32 data;
+
+	return read_poll_timeout(coda_vdi_readl, data, data == 0, 0,
+				 VPU_BUSY_CHECK_TIMEOUT, false, vpu_dev, addr);
+}
+
+int32_t coda_vpu_get_product_id(struct vpu_device *vpu_dev)
+{
+	u32 product_id = PRODUCT_ID_NONE;
+	u32 val;
+
+	val = vpu_read_reg(vpu_dev, VPU_PRODUCT_CODE_REGISTER);
+
+	switch (val) {
+	case CODA980_CODE:
+		product_id = PRODUCT_ID_980;
+		break;
+	default:
+		dev_err(vpu_dev->dev, "Invalid product id (%x)\n", val);
+		break;
+	}
+	return product_id;
+}
+
+static uint16_t coda_hex_int(char *hex)
+{
+	uint16_t val = 0;
+	while (*hex) {
+		uint8_t byte = *hex++;
+		if (byte >= '0' && byte <= '9')
+			byte = byte - '0';
+		else if (byte >= 'a' && byte <= 'f')
+			byte = byte - 'a' + 10;
+		else if (byte >= 'A' && byte <= 'F')
+			byte = byte - 'A' + 10;
+		val = (val << 4) | (byte & 0xF);
+	}
+
+	return val;
+}
+
+static int coda_convert_to_binary(uint16_t *bin, u8 *fw, uint32_t size)
+{
+	int i = 0;
+	int j = 0;
+	u8 hex[5];
+
+	for (i = 0; i < size;) {
+		memset(hex, 0x00, 5);
+		memcpy(hex, fw + i, 4);
+		bin[j++] = coda_hex_int(hex);
+		i += 5;
+	}
+
+	return j;
+}
+
+static void coda_vpu_dec_convert_to_endian(u8 *src, u8 *dst, int size)
+{
+	int i, j;
+
+	j = 0;
+	for (i = 0; i < size; i += 2) {
+		dst[j++] = src[i + 1];
+		dst[j++] = src[i];
+	}
+}
+
+static int reload_fw(struct device *dev, struct vpu_buf *common_vb,
+		     uint16_t *code_word, uint32_t size)
+{
+	u8 *fw;
+	int i, j;
+	int ret;
+	struct vpu_device *vpu_dev = dev_get_drvdata(dev);
+
+	fw = devm_kzalloc(dev, size * 2, GFP_KERNEL);
+	if (!fw) {
+		return -ENOMEM;
+	}
+
+	j = 0;
+	for (i = 0; i < size; i++) {
+		fw[j++] = (u8)(code_word[i] >> 8) & 0xff;
+		fw[j++] = (u8)(code_word[i]) & 0xff;
+	}
+
+	ret = coda_vdi_write_memory(vpu_dev, common_vb, 0, fw, size * 2,
+				    VDI_BIG_ENDIAN);
+	if (ret) {
+		devm_kfree(dev, fw);
+		return ret;
+	}
+
+	devm_kfree(dev, fw);
+	return ret;
+}
+
+bool coda_vpu_is_init(struct vpu_device *vpu_dev)
+{
+	dev_dbg(vpu_dev->dev, "%d.%s.BIT_CUR_PC : %08X\n",
+		__LINE__, __func__,
+		vpu_read_reg(vpu_dev, BIT_CUR_PC));
+	return vpu_read_reg(vpu_dev, BIT_CUR_PC) != 0;
+}
+
+int coda_vpu_re_init(struct device *dev, u8 *firmware, uint32_t size)
+{
+	struct vpu_device *vpu_dev = dev_get_drvdata(dev);
+	struct vpu_buf *common_vb;
+	dma_addr_t tempbuf;
+	dma_addr_t parabuf;
+	dma_addr_t codebuf;
+	dma_addr_t oldcodebuf;
+	int ret = 0;
+
+	common_vb = &vpu_dev->common_mem;
+	codebuf = common_vb->daddr;
+	tempbuf = codebuf + CODE_BUF_SIZE;
+	parabuf = tempbuf + TEMP_BUF_SIZE;
+	oldcodebuf = vpu_read_reg(vpu_dev, BIT_CODE_BUF_ADDR);
+
+	dev_err(vpu_dev->dev, "oldcodebuf: %llx codebuf: %llx\n", oldcodebuf,
+		codebuf);
+	if (oldcodebuf != codebuf) {
+		u8 *fw_binary;
+		int fw_sz;
+
+		fw_binary = devm_kzalloc(dev, MAX_CODE_BUF_SIZE, GFP_KERNEL);
+		fw_sz = coda_convert_to_binary((uint16_t *)fw_binary, firmware,
+					       size);
+
+		ret = reload_fw(dev, common_vb, (uint16_t *)fw_binary, fw_sz);
+		devm_kfree(dev, fw_binary);
+	}
+
+	return ret;
+}
+
+int coda_vpu_reset(struct vpu_device *vpu_dev, enum sw_reset_mode reset_mode)
+{
+	uint32_t cmd;
+	int ret;
+
+	if (reset_mode != SW_RESET_ON_BOOT) {
+		cmd = vpu_read_reg(vpu_dev, BIT_RUN_COMMAND);
+		if (cmd == DEC_SEQ_INIT || cmd == PIC_RUN) {
+			if (vpu_read_reg(vpu_dev, BIT_BUSY_FLAG) ||
+			    vpu_read_reg(vpu_dev, BIT_INT_REASON)) {
+				// stop all of pipeline
+				vpu_write_reg(vpu_dev, MBC_SET_SUBBLK_EN,
+					      ((1 << 20) | 0));
+
+				// force to set the end of Bitstream to be decoded.
+				cmd = vpu_read_reg(vpu_dev,
+						   BIT_BIT_STREAM_PARAM);
+				cmd |= 1 << 2;
+				vpu_write_reg(vpu_dev, BIT_BIT_STREAM_PARAM,
+					      cmd);
+
+				cmd = vpu_read_reg(vpu_dev, BIT_RD_PTR);
+				vpu_write_reg(vpu_dev, BIT_WR_PTR, cmd);
+
+				ret = coda_wait_vpu_busy(vpu_dev,
+							 BIT_INT_REASON);
+				if (ret) {
+					return -ETIMEDOUT;
+				}
+				// clear HW signal
+				vpu_write_reg(vpu_dev, BIT_INT_REASON, 0);
+				vpu_write_reg(vpu_dev, BIT_INT_CLEAR, 1);
+			}
+		}
+	}
+
+	// Waiting for completion of BWB transaction first
+	ret = coda_wait_vpu_busy(vpu_dev, GDI_BWB_STATUS);
+	if (ret) {
+		return -ETIMEDOUT;
+	}
+
+	// Waiting for completion of bus transaction
+	// Step1 : No more request
+	vpu_write_reg(
+		vpu_dev, GDI_BUS_CTRL,
+		0x11); // no more request {3'b0,no_more_req_sec,3'b0,no_more_req}
+
+	ret = coda_wait_vpu_busy(vpu_dev, GDI_BWB_STATUS);
+	if (ret) {
+		vpu_write_reg(vpu_dev, GDI_BUS_CTRL, 0x00);
+		return -ETIMEDOUT;
+	}
+
+	cmd = 0;
+	// Software Reset Trigger
+	if (reset_mode != SW_RESET_ON_BOOT)
+		cmd = VPU_SW_RESET_BPU_CORE | VPU_SW_RESET_BPU_BUS;
+
+	cmd |= VPU_SW_RESET_VCE_CORE | VPU_SW_RESET_VCE_BUS;
+	if (reset_mode == SW_RESET_ON_BOOT)
+		cmd |= VPU_SW_RESET_GDI_CORE |
+		       VPU_SW_RESET_GDI_BUS; // If you reset GDI, tiled map should be reconfigured
+
+	vpu_write_reg(vpu_dev, BIT_SW_RESET, cmd);
+
+	// wait until reset is done
+	if (coda_wait_vpu_busy(vpu_dev, BIT_SW_RESET_STATUS) != 0) {
+		vpu_write_reg(vpu_dev, BIT_SW_RESET, 0x00);
+		vpu_write_reg(vpu_dev, GDI_BUS_CTRL, 0x00);
+		return -ETIMEDOUT;
+	}
+
+	vpu_write_reg(vpu_dev, BIT_SW_RESET, 0);
+
+	// Step3 : must clear GDI_BUS_CTRL after done SW_RESET
+	vpu_write_reg(vpu_dev, GDI_BUS_CTRL, 0x00);
+
+	return 0;
+}
+
+static int load_fw(struct device *dev, struct vpu_buf *common_vb,
+		   uint16_t *code_word, uint32_t size)
+{
+	u8 *fw;
+	int i;
+	int ret = 0;
+	uint32_t data;
+	struct vpu_device *vpu_dev = dev_get_drvdata(dev);
+	fw = devm_kzalloc(dev, size * 2, GFP_KERNEL);
+	if (!fw) {
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < size; i += 4) {
+		fw[0] = (u8)(code_word[i + 0] >> 8) & 0xff;
+		fw[1] = (u8)(code_word[i + 0]) & 0xff;
+		fw[2] = (u8)(code_word[i + 1] >> 8) & 0xff;
+		fw[3] = (u8)(code_word[i + 1]) & 0xff;
+		fw[4] = (u8)(code_word[i + 2] >> 8) & 0xff;
+		fw[5] = (u8)(code_word[i + 2]) & 0xff;
+		fw[6] = (u8)(code_word[i + 3] >> 8) & 0xff;
+		fw[7] = (u8)(code_word[i + 3]) & 0xff;
+		ret = coda_vdi_write_memory(vpu_dev, common_vb, i * 2, fw, 8,
+					    VDI_BIG_ENDIAN);
+		if (ret < 0) {
+			dev_err(vpu_dev->dev,
+				"coda_vdi_write_memory fail.ret:%d\n", ret);
+			devm_kfree(dev, fw);
+			return ret;
+		}
+	}
+
+	vpu_write_reg(vpu_dev, BIT_INT_ENABLE, 0);
+	vpu_write_reg(vpu_dev, BIT_CODE_RUN, 0);
+
+	for (i = 0; i < 2048; ++i) {
+		data = code_word[i];
+		vpu_write_reg(vpu_dev, BIT_CODE_DOWN, (i << 16) | data);
+	}
+
+	dev_err(vpu_dev->dev, "completed to download fw : %d\n", ret);
+	devm_kfree(dev, fw);
+	return ret;
+}
+
+void coda_debug_register(struct vpu_device *vpu_dev, struct vpu_instance *inst,
+			 u32 cmd, u32 start_flag)
+{
+	int start_addr = 0x200;
+	int end_addr = 0x600;
+	int i;
+	if (start_flag)
+		dev_dbg(vpu_dev->dev, "%d.%s.START cmd : %d\n",
+			__LINE__, __func__,
+			cmd);
+	else
+		dev_dbg(vpu_dev->dev, "%d.%s.END cmd : %d\n",
+			__LINE__, __func__,
+			cmd);
+
+	dev_dbg(vpu_dev->dev, "%d.%s.BIT_CUR_PC 0: %08X\n",
+		__LINE__, __func__,
+		vpu_read_reg(vpu_dev, BIT_CUR_PC));
+	dev_dbg(vpu_dev->dev, "%d.%s.BIT_CUR_PC 1: %08X\n",
+		__LINE__, __func__,
+		vpu_read_reg(vpu_dev, BIT_CUR_PC));
+	dev_dbg(vpu_dev->dev, "%d.%s.BIT_CUR_PC 2: %08X\n",
+		__LINE__, __func__,
+		vpu_read_reg(vpu_dev, BIT_CUR_PC));
+	dev_dbg(vpu_dev->dev, "%d.%s.BIT_CUR_PC 3: %08X\n",
+		__LINE__, __func__,
+		vpu_read_reg(vpu_dev, BIT_CUR_PC));
+	dev_dbg(vpu_dev->dev, "%d.%s.BIT_CUR_PC 4: %08X\n",
+		__LINE__, __func__,
+		vpu_read_reg(vpu_dev, BIT_CUR_PC));
+
+	start_addr = 0x0;
+	end_addr = 0x200;
+
+	for (i = start_addr; i < end_addr;
+	     i = i + 16) { // host IF register 0x100 ~ 0x200
+		dev_dbg(vpu_dev->dev, "%d.%s.0x%04xh: 0x%08x 0x%08x 0x%08x 0x%08x\n\n",
+			__LINE__, __func__, i,
+			vpu_read_reg(vpu_dev, i), vpu_read_reg(vpu_dev, i + 4),
+		    vpu_read_reg(vpu_dev, i + 8),
+		    vpu_read_reg(vpu_dev, i + 0xc));
+	}
+}
+
+static int read_pinfo_buffer(struct vpu_device *vpu_dev, int addr)
+{
+	int ack;
+	int rdata;
+#define VDI_LOG_GDI_PINFO_ADDR (0x1068)
+#define VDI_LOG_GDI_PINFO_REQ (0x1060)
+#define VDI_LOG_GDI_PINFO_ACK (0x1064)
+#define VDI_LOG_GDI_PINFO_DATA (0x106c)
+	//------------------------------------------
+	// read pinfo - indirect read
+	// 1. set read addr     (GDI_PINFO_ADDR)
+	// 2. send req          (GDI_PINFO_REQ)
+	// 3. wait until ack==1 (GDI_PINFO_ACK)
+	// 4. read data         (GDI_PINFO_DATA)
+	//------------------------------------------
+	vpu_write_reg(vpu_dev, VDI_LOG_GDI_PINFO_ADDR, addr);
+	vpu_write_reg(vpu_dev, VDI_LOG_GDI_PINFO_REQ, 1);
+
+	ack = 0;
+	while (ack == 0) {
+		ack = vpu_read_reg(vpu_dev, VDI_LOG_GDI_PINFO_ACK);
+	}
+
+	rdata = vpu_read_reg(vpu_dev, VDI_LOG_GDI_PINFO_DATA);
+
+	//dev_dbg(vpu_dev->dev, "[READ PINFO] ADDR[%x], DATA[%x]", addr, rdata);
+	return rdata;
+}
+
+void coda_printf_gdi_info(struct vpu_device *vpu_dev)
+{
+	int i;
+	int bus_info_addr;
+	int tmp;
+
+	dev_dbg(vpu_dev->dev, "\n**GDI information for GDI_20\n");
+
+	for (i = 0; i < 4; i++) {
+#define VDI_LOG_GDI_INFO_CONTROL 0x1400
+		bus_info_addr = VDI_LOG_GDI_INFO_CONTROL + i * (0x20);
+
+		dev_dbg(vpu_dev->dev, "index = %02d", i);
+
+		tmp = read_pinfo_buffer(
+			vpu_dev,
+			bus_info_addr); //TiledEn<<20 ,GdiFormat<<17,IntlvCbCr,<<16 GdiYuvBufStride
+		dev_dbg(vpu_dev->dev, " control = 0x%08x", tmp);
+
+		bus_info_addr += 4;
+		tmp = read_pinfo_buffer(vpu_dev, bus_info_addr);
+		dev_dbg(vpu_dev->dev, " pic_size = 0x%08x", tmp);
+
+		bus_info_addr += 4;
+		tmp = read_pinfo_buffer(vpu_dev, bus_info_addr);
+		dev_dbg(vpu_dev->dev, " y-top = 0x%08x", tmp);
+
+		bus_info_addr += 4;
+		tmp = read_pinfo_buffer(vpu_dev, bus_info_addr);
+		dev_dbg(vpu_dev->dev, " cb-top = 0x%08x", tmp);
+
+		bus_info_addr += 4;
+		tmp = read_pinfo_buffer(vpu_dev, bus_info_addr);
+		dev_dbg(vpu_dev->dev, " cr-top = 0x%08x", tmp);
+		// bottom
+		{
+			bus_info_addr += 4;
+			tmp = read_pinfo_buffer(vpu_dev, bus_info_addr);
+			dev_dbg(vpu_dev->dev, " y-bot = 0x%08x", tmp);
+
+			bus_info_addr += 4;
+			tmp = read_pinfo_buffer(vpu_dev, bus_info_addr);
+			dev_dbg(vpu_dev->dev, " cb-bot = 0x%08x", tmp);
+
+			bus_info_addr += 4;
+			tmp = read_pinfo_buffer(vpu_dev, bus_info_addr);
+			dev_dbg(vpu_dev->dev, " cr-bot = 0x%08x", tmp);
+		}
+		dev_dbg(vpu_dev->dev, "\n");
+	}
+}
+
+// dbg message added by clair
+void coda_printf_mc_info(struct vpu_device *vpu_dev)
+{
+	int tmp;
+
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x200);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_0 = %x\n", tmp);
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x20C);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_1 = %x\n", tmp);
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x218);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_2 = %x\n", tmp);
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x230);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_3 = %x\n", tmp);
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x23C);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_3 = %x\n", tmp);
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x248);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_4 = %x\n", tmp);
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x254);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_5 = %x\n", tmp);
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x260);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_6 = %x\n", tmp);
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x26C);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_7 = %x\n", tmp);
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x278);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_8 = %x\n", tmp);
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x284);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_9 = %x\n", tmp);
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x290);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_a = %x\n", tmp);
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x29C);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_b = %x\n", tmp);
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x2A8);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_c = %x\n", tmp);
+	tmp = vpu_read_reg(vpu_dev, MC_BASE + 0x2B4);
+	dev_dbg(vpu_dev->dev, "P_MC_PIC_INDEX_d = %x\n", tmp);
+}
+
+void coda_bit_issue_command(struct vpu_device *vpu_dev,
+			    struct vpu_instance *inst, u32 cmd)
+{
+	int inst_idx = 0;
+	int cdc_mode = 0;
+	int aux_mode = 0;
+	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
+
+	inst_idx = inst->id;
+	cdc_mode = p_dec_info->open_param.codec_mode;
+	aux_mode = p_dec_info->open_param.codec_mode_aux;
+
+	vpu_write_reg(vpu_dev, BIT_WORK_BUF_ADDR, inst->work_vbuf.daddr);
+
+	vpu_write_reg(vpu_dev, BIT_BUSY_FLAG, 1);
+	vpu_write_reg(vpu_dev, BIT_RUN_INDEX, inst_idx);
+	vpu_write_reg(vpu_dev, BIT_RUN_COD_STD, cdc_mode);
+	vpu_write_reg(vpu_dev, BIT_RUN_AUX_STD, aux_mode);
+	vpu_write_reg(vpu_dev, BIT_RUN_COMMAND, cmd);
+}
+
+int coda_vpu_dec_get_result(struct vpu_instance *inst,
+			    struct dec_output_info *result)
+{
+	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
+	u32 val = 0;
+	struct vpu_device *dev = inst->dev;
+
+#ifdef DEBUG_STATELESS
+	dev_dbg(inst->dev->dev, "MSG 0: %08X \n", vpu_read_reg(dev, BIT_MSG_0));
+	dev_dbg(inst->dev->dev, "MSG 1: %08X \n", vpu_read_reg(dev, BIT_MSG_1));
+	dev_dbg(inst->dev->dev, "MSG 2: %08X \n", vpu_read_reg(dev, BIT_MSG_2));
+	dev_dbg(inst->dev->dev, "MSG 3: %08X \n", vpu_read_reg(dev, BIT_MSG_3));
+
+	// dump DMEM for debugging
+	// {
+	// 	u8 conv_data[500];
+	// 	struct avc_direct_memory avc;
+	// 	struct vpu_buf *work_buf = &inst->work_vbuf;
+	// 	int i;
+
+	// 	coda_vdi_read_memory(inst->dev, work_buf, CODA9_VP8_DIRECT_MEM_OFFSET, conv_data, sizeof(avc), VDI_BIG_ENDIAN);
+
+	// 	coda_vpu_dec_convert_to_endian(conv_data, (u8 *)&avc, sizeof(avc));
+
+	// 	for(i=0; i<sizeof(avc); i+=2) {
+	// 		dev_dbg(inst->dev->dev, "[%x] %02x %02x \n", (i+CODA9_VP8_DIRECT_MEM_OFFSET)/2, conv_data[i], conv_data[i+1]);
+	// 	}
+	// }
+	// coda_printf_gdi_info(dev);
+#endif
+	val = vpu_read_reg(dev, RET_DEC_PIC_SUCCESS);
+	result->decoding_success = val;
+	if (result->decoding_success & (1UL << 31)) {
+		dev_err(dev->dev, "failed to decode a frame (%x)\n", val);
+		return -EIO;
+	}
+
+	result->index_frame_decoded =
+		vpu_read_reg(dev, RET_DEC_PIC_DECODED_IDX);
+	result->index_frame_display =
+		vpu_read_reg(dev, RET_DEC_PIC_DISPLAY_IDX);
+
+	if (p_dec_info->open_param.map_type == LINEAR_FRAME_MAP) {
+		result->index_frame_decoded_for_tiled = -1;
+		result->index_frame_display_for_tiled = -1;
+	} else {
+		result->index_frame_decoded_for_tiled =
+			result->index_frame_decoded;
+		result->index_frame_display_for_tiled =
+			result->index_frame_display;
+	}
+
+	val = vpu_read_reg(dev, RET_DEC_PIC_SIZE); // decoding picture size
+	result->pic_width = (val >> 16) & 0xFFFF;
+	result->pic_height = (val)&0xFFFF;
+
+	val = vpu_read_reg(dev, RET_DEC_PIC_TYPE);
+	result->pic_type = val & 7;
+
+	if (p_dec_info->open_param.codec_mode == AVC_DEC) {
+		if (val & 0x40)
+			result->pic_type = PIC_TYPE_IDR;
+
+		result->avc_poc_top = vpu_read_reg(dev, RET_DEC_PIC_POC_TOP);
+		result->avc_poc_bot = vpu_read_reg(dev, RET_DEC_PIC_POC_BOT);
+		result->avc_poc_pic = vpu_read_reg(dev, RET_DEC_PIC_POC);
+	}
+
+	result->f_numberator = vpu_read_reg(
+		dev,
+		RET_DEC_PIC_FRATE_NR); //Frame rate, Aspect ratio can be changed frame by frame.
+	result->f_denominator = vpu_read_reg(dev, RET_DEC_PIC_FRATE_DR);
+	if (p_dec_info->open_param.codec_mode == AVC_DEC &&
+	    result->f_denominator > 0)
+		result->f_denominator *= 2;
+
+	if (p_dec_info->open_param.codec_mode == VPX_DEC)
+		result->aspect_rate_info = 0;
+	else
+		result->aspect_rate_info =
+			vpu_read_reg(dev, RET_DEC_PIC_ASPECT);
+
+	result->num_of_err_mbs = vpu_read_reg(dev, RET_DEC_PIC_ERR_MB);
+	val = vpu_read_reg(dev, RET_DEC_PIC_SUCCESS);
+	result->sequence_changed = ((val >> 20) & 0x1);
+	result->stream_end_flag = ((p_dec_info->stream_end_flag >> 2) & 0x01);
+
+	result->byte_pos_frame_start =
+		vpu_read_reg(dev, BIT_BYTE_POS_FRAME_START);
+	result->byte_pos_frame_end = vpu_read_reg(dev, BIT_BYTE_POS_FRAME_END);
+	result->frame_cycle = vpu_read_reg(dev, BIT_FRAME_CYCLE);
+
+	p_dec_info->stream_rd_ptr = vpu_read_reg(dev, BIT_RD_PTR);
+	p_dec_info->frame_display_flag = vpu_read_reg(dev, BIT_FRM_DIS_FLG);
+	result->frame_display_flag = p_dec_info->frame_display_flag;
+
+	result->buf_addr_y = vpu_read_reg(dev, RET_DEC_STATELESS_LINEAR_ADDR_Y);
+	result->buf_addr_cb =
+		vpu_read_reg(dev, RET_DEC_STATELESS_LINEAR_ADDR_CB);
+	result->buf_addr_cr =
+		vpu_read_reg(dev, RET_DEC_STATELESS_LINEAR_ADDR_CR);
+	dev_dbg(dev->dev,
+		"%d.%s.vpu_read_reg.buf_addr_y:0x%llx.buf_addr_cb:0x%llx.buf_addr_cr:0x%llx.poc:%d\n",
+		__LINE__, __func__,
+		result->buf_addr_y, result->buf_addr_cb, result->buf_addr_cr,
+		result->avc_poc_pic);
+
+	return 0;
+}
+
+int coda_vpu_init(struct device *dev, u8 *firmware, uint32_t size)
+{
+	struct vpu_device *vpu_dev = dev_get_drvdata(dev);
+	struct vpu_buf *common_vb;
+	dma_addr_t tempbuf;
+	dma_addr_t parabuf;
+	dma_addr_t codebuf;
+	int ret;
+	uint32_t data;
+	u8 *fw_binary;
+	int fw_sz;
+
+	fw_binary = devm_kzalloc(dev, MAX_CODE_BUF_SIZE, GFP_KERNEL);
+	fw_sz = coda_convert_to_binary((uint16_t *)fw_binary, firmware, size);
+
+	common_vb = &vpu_dev->common_mem;
+
+	codebuf = common_vb->daddr;
+	tempbuf = codebuf + CODE_BUF_SIZE;
+	parabuf = tempbuf + TEMP_BUF_SIZE;
+
+	ret = load_fw(dev, common_vb, (uint16_t *)fw_binary, fw_sz);
+	if (ret <= 0) {
+		dev_err(dev, "failed to load a firmware (%x)\n", ret);
+		devm_kfree(dev, fw_binary);
+		return ret;
+	}
+
+	vpu_write_reg(vpu_dev, BIT_PARA_BUF_ADDR, parabuf);
+	vpu_write_reg(vpu_dev, BIT_CODE_BUF_ADDR, codebuf);
+	vpu_write_reg(vpu_dev, BIT_TEMP_BUF_ADDR, tempbuf);
+
+	vpu_write_reg(vpu_dev, BIT_BIT_STREAM_CTRL, VPU_STREAM_ENDIAN);
+	vpu_write_reg(vpu_dev, BIT_FRAME_MEM_CTRL,
+		      CBCR_INTERLEAVE << 2 | VPU_FRAME_ENDIAN);
+
+	vpu_write_reg(vpu_dev, BIT_BIT_STREAM_PARAM, 0);
+
+	vpu_write_reg(vpu_dev, BIT_AXI_SRAM_USE, 0);
+	vpu_write_reg(vpu_dev, BIT_INT_ENABLE, 0);
+	vpu_write_reg(vpu_dev, BIT_ROLLBACK_STATUS, 0);
+
+	data = (1 << INT_BIT_BIT_BUF_FULL);
+	data |= (1 << INT_BIT_BIT_BUF_EMPTY);
+	data |= (1 << INT_BIT_DEC_MB_ROWS);
+	data |= (1 << INT_BIT_SEQ_INIT);
+	data |= (1 << INT_BIT_DEC_FIELD);
+	data |= (1 << INT_BIT_PIC_RUN);
+
+	vpu_write_reg(vpu_dev, BIT_INT_ENABLE, data);
+	vpu_write_reg(vpu_dev, BIT_INT_CLEAR, 0x1);
+	vpu_write_reg(vpu_dev, BIT_BUSY_FLAG, 0x1);
+	vpu_write_reg(vpu_dev, BIT_CODE_RESET, 1);
+	vpu_write_reg(vpu_dev, BIT_CODE_RUN, 1);
+
+	ret = coda_wait_vpu_busy(vpu_dev, BIT_BUSY_FLAG);
+	if (ret) {
+		dev_err(dev,
+			"%d.%s.timeout for checking  BIT_BUSY_FLAG (%x)\n",
+			__LINE__, __func__,
+			ret);
+		devm_kfree(dev, fw_binary);
+		return -ETIMEDOUT;
+	}
+	dev_dbg(dev, "%d.%s.After downloading a fw, BIT_CUR_PC : %08X\n",
+		__LINE__, __func__,
+		vpu_read_reg(vpu_dev, BIT_CUR_PC));
+
+	devm_kfree(dev, fw_binary);
+	return 0;
+}
+
+int coda_vpu_set_rd_ptr(struct vpu_instance *inst)
+{
+	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
+
+	p_dec_info->stream_rd_ptr = p_dec_info->open_param.bitstream_buffer;
+	vpu_write_reg(inst->dev, BIT_RD_PTR,
+		      p_dec_info->open_param.bitstream_buffer);
+	dev_dbg(inst->dev->dev, "%d.%s.coda_vpu_set_rd_ptr:0x%llx\n",
+		__LINE__, __func__,
+		p_dec_info->stream_rd_ptr);
+
+	return 0;
+}
+
+int coda_vpu_set_wr_ptr(struct vpu_instance *inst, int size)
+{
+	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
+
+	p_dec_info->stream_wr_ptr =
+		p_dec_info->open_param.bitstream_buffer + size;
+	dev_dbg(inst->dev->dev, "%d.%s.coda_vpu_set_wr_ptr:0x%llx \n",
+		__LINE__, __func__,
+		p_dec_info->stream_wr_ptr);
+	vpu_write_reg(inst->dev, BIT_WR_PTR,
+		p_dec_info->open_param.bitstream_buffer + size);
+
+	return 0;
+}
+
+int coda_vpu_dec_init_seq(struct vpu_instance *inst)
+{
+	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
+	struct vpu_device *dev = inst->dev;
+	u32 val;
+
+	if (!p_dec_info)
+		return -EINVAL;
+#ifdef DEBUG_STATELESS
+	vpu_write_reg(dev, BIT_MSG_0, 0xffff);
+	vpu_write_reg(dev, BIT_MSG_1, 0xffff);
+	vpu_write_reg(dev, BIT_MSG_2, 0xffff);
+	vpu_write_reg(dev, BIT_MSG_3, 0xffff);
+#endif
+	vpu_write_reg(dev, CMD_DEC_SEQ_BB_START,
+		      p_dec_info->open_param.bitstream_buffer);
+	vpu_write_reg(dev, CMD_DEC_SEQ_BB_SIZE,
+		      p_dec_info->open_param.bitstream_buffer_size /
+			      1024); // size in KBytes
+
+	vpu_write_reg(dev, CMD_DEC_SEQ_USER_DATA_OPTION, 0);
+	vpu_write_reg(dev, CMD_DEC_SEQ_USER_DATA_BASE_ADDR, 0);
+	vpu_write_reg(dev, CMD_DEC_SEQ_USER_DATA_BUF_SIZE, 0);
+
+	val = 0;
+
+	val |= (p_dec_info->open_param.reorder_enable << 1) & 0x2;
+	val |= (p_dec_info->open_param.mp4_deblk_enable & 0x1);
+	vpu_write_reg(dev, CMD_DEC_SEQ_OPTION, val);
+
+	if (p_dec_info->open_param.codec_mode == AVC_DEC) {
+		vpu_write_reg(dev, CMD_DEC_SEQ_X264_MV_EN,
+			      VPU_AVC_X264_SUPPORT);
+		vpu_write_reg(dev, CMD_DEC_SEQ_SPP_CHUNK_SIZE, VPU_GBU_SIZE);
+	}
+
+	vpu_write_reg(dev, BIT_WR_PTR, p_dec_info->stream_wr_ptr);
+	vpu_write_reg(dev, BIT_RD_PTR, p_dec_info->stream_rd_ptr);
+
+	p_dec_info->stream_end_flag &= ~(3 << 3);
+
+	if (p_dec_info->open_param.bitstream_mode == BS_MODE_PIC_END) {
+		p_dec_info->stream_end_flag |= (2 << 3);
+	}
+
+	vpu_write_reg(dev, BIT_BIT_STREAM_PARAM, p_dec_info->stream_end_flag);
+
+	val = p_dec_info->open_param.stream_endian;
+	vpu_write_reg(dev, BIT_BIT_STREAM_CTRL, val);
+
+	val = 0;
+	val |= (p_dec_info->open_param.bwb_enable << 15);
+	val |= (p_dec_info->open_param.wtl_mode << 17) |
+	       (p_dec_info->open_param.tiled2_linear_mode << 13) |
+	       (FORMAT_420 << 6);
+	val |= ((inst->cbcr_interleave)
+		<< 2); // Interleave bit position is modified
+	val |= p_dec_info->open_param.frame_endian;
+	val |= inst->nv21 << 3;
+	//dev_dbg(inst->dev->dev, "%d.%s.vpu_write_reg BIT_FRAME_MEM_CTRL.val:0x%x(cbcr_interleave:%d,nv21:%d)\n",
+	//	__LINE__,__func__,val,
+	//	inst->cbcr_interleave,inst->nv21);
+	vpu_write_reg(dev, BIT_FRAME_MEM_CTRL, val);
+
+	vpu_write_reg(dev, BIT_FRM_DIS_FLG, 0);
+
+	coda_bit_issue_command(dev, inst, DEC_SEQ_INIT);
+
+	return 0;
+}
+
+int coda_vpu_dec_get_seq_info(struct vpu_instance *vpu_inst,
+			      struct dec_initial_info *info)
+{
+	struct dec_info *p_dec_info = &vpu_inst->codec_info->dec_info;
+	struct vpu_device *dev = vpu_inst->dev;
+	u32 val;
+
+	p_dec_info->stream_rd_ptr = vpu_read_reg(dev, BIT_RD_PTR);
+	p_dec_info->frame_display_flag = vpu_read_reg(dev, BIT_FRM_DIS_FLG);
+	p_dec_info->stream_end_flag = vpu_read_reg(dev, BIT_BIT_STREAM_PARAM);
+
+	info->err_reason = 0;
+	val = vpu_read_reg(dev, RET_DEC_SEQ_SUCCESS);
+	if (val & (1 << 31)) {
+		dev_err(dev->dev, "memory access violation error (%x)\n", val);
+		return -EIO;
+	}
+
+	if (p_dec_info->open_param.bitstream_mode == BS_MODE_PIC_END) {
+		if (val & (1 << 4)) {
+			info->err_reason =
+				vpu_read_reg(dev, RET_DEC_SEQ_SEQ_ERR_REASON);
+			dev_err(dev->dev, "seq_info err reason (%x)\n",
+				info->err_reason);
+			return -EIO;
+		}
+	}
+
+	if (val == 0) {
+		info->err_reason =
+			vpu_read_reg(dev, RET_DEC_SEQ_SEQ_ERR_REASON);
+		dev_err(dev->dev, "seq_info err reason (%x)\n",
+			info->err_reason);
+		return -EIO;
+	}
+
+	info->pic_width = p_dec_info->pic_width;
+	info->pic_height = p_dec_info->pic_height;
+	info->pic_crop_rect.left = 0;
+	info->pic_crop_rect.right = p_dec_info->pic_width;
+	info->pic_crop_rect.top = 0;
+	info->pic_crop_rect.bottom = p_dec_info->pic_height;
+	info->luma_bit_depth = 8;
+	info->chroma_bit_depth = 8;
+
+	return 0;
+}
+
+static int set_tile_map_type(struct vpu_device *vpu_dev,
+			     struct tiled_map_config *map_cfg,
+			     enum tiled_map_type map_type, int width,
+			     int interleave)
+{
+	const int luma_map =
+		0x40; // zero, inv = 1'b0, zero = 1'b1 , tbxor = 1'b0, xy = 1'b0, bit = 4'd0
+	const int chro_map =
+		0x40; // zero, inv = 1'b0, zero = 1'b1 , tbxor = 1'b0, xy = 1'b0, bit = 4'd0
+	int width_chr;
+	int i;
+
+	for (i = 0; i < 32; i = i + 1) {
+		map_cfg->xy2axi_luma_map[i] = luma_map;
+		map_cfg->xy2axi_chr_map[i] = chro_map;
+	}
+
+	map_cfg->xy2axi_config = 0;
+	width_chr = (interleave) ? width : width / 2;
+
+	switch (map_type) {
+	case LINEAR_FRAME_MAP:
+	case LINEAR_FIELD_MAP:
+		map_cfg->xy2axi_config = 0;
+		return 1;
+		break;
+	case TILED_FRAME_V_MAP: {
+		// luma
+		map_cfg->xy2axi_luma_map[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		map_cfg->xy2axi_luma_map[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		map_cfg->xy2axi_luma_map[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		map_cfg->xy2axi_luma_map[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		map_cfg->xy2axi_luma_map[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		map_cfg->xy2axi_luma_map[8] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		map_cfg->xy2axi_luma_map[9] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		map_cfg->xy2axi_luma_map[10] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		map_cfg->xy2axi_luma_map[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 4);
+		map_cfg->xy2axi_luma_map[12] = GEN_XY2AXI(0, 0, 0, X_SEL, 7);
+		map_cfg->xy2axi_luma_map[13] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+
+		if (width <= 512) {
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 1024) {
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 2048) {
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else { // 4K size
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+
+		// chroma
+		map_cfg->xy2axi_chr_map[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		map_cfg->xy2axi_chr_map[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		map_cfg->xy2axi_chr_map[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		map_cfg->xy2axi_chr_map[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		map_cfg->xy2axi_chr_map[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		map_cfg->xy2axi_chr_map[8] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		map_cfg->xy2axi_chr_map[9] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		map_cfg->xy2axi_chr_map[10] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		map_cfg->xy2axi_chr_map[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		map_cfg->xy2axi_chr_map[12] = GEN_XY2AXI(1, 0, 0, X_SEL, 7);
+		map_cfg->xy2axi_chr_map[13] = GEN_XY2AXI(1, 0, 0, Y_SEL, 4);
+
+		if (width_chr <= 512) {
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 1024) {
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 2048) {
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else { // 4K size
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+
+		// xy2axi_config
+		map_cfg->xy2axi_config =
+			GEN_CONFIG(0, 0, 0, 1, 1, 15, 0, 15, 0);
+		break;
+	} // case TILED_FRAME_V_MAP
+	case TILED_FRAME_H_MAP: {
+		map_cfg->xy2axi_luma_map[3] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		map_cfg->xy2axi_luma_map[4] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		map_cfg->xy2axi_luma_map[5] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		map_cfg->xy2axi_luma_map[6] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		map_cfg->xy2axi_luma_map[7] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		map_cfg->xy2axi_luma_map[8] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		map_cfg->xy2axi_luma_map[9] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		map_cfg->xy2axi_luma_map[10] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		map_cfg->xy2axi_luma_map[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 4);
+		map_cfg->xy2axi_luma_map[12] = GEN_XY2AXI(0, 0, 0, X_SEL, 7);
+		map_cfg->xy2axi_luma_map[13] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		if (width <= 512) {
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 1024) {
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 2048) {
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else { // 4K size
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+
+		map_cfg->xy2axi_chr_map[3] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		map_cfg->xy2axi_chr_map[4] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		map_cfg->xy2axi_chr_map[5] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		map_cfg->xy2axi_chr_map[6] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		map_cfg->xy2axi_chr_map[7] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		map_cfg->xy2axi_chr_map[8] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		map_cfg->xy2axi_chr_map[9] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		map_cfg->xy2axi_chr_map[10] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		map_cfg->xy2axi_chr_map[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		map_cfg->xy2axi_chr_map[12] = GEN_XY2AXI(1, 0, 0, X_SEL, 7);
+		map_cfg->xy2axi_chr_map[13] = GEN_XY2AXI(1, 0, 0, Y_SEL, 4);
+		if (width_chr <= 512) {
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 1024) {
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 2048) {
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else { // 4K size
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+
+		// xy2axi_config
+		map_cfg->xy2axi_config =
+			GEN_CONFIG(0, 0, 0, 1, 0, 15, 15, 15, 15);
+		break;
+	} //case TILED_FRAME_H_MAP:
+	case TILED_FIELD_V_MAP: {
+		map_cfg->xy2axi_luma_map[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		map_cfg->xy2axi_luma_map[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		map_cfg->xy2axi_luma_map[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		map_cfg->xy2axi_luma_map[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		map_cfg->xy2axi_luma_map[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		map_cfg->xy2axi_luma_map[8] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		map_cfg->xy2axi_luma_map[9] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		map_cfg->xy2axi_luma_map[10] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		map_cfg->xy2axi_luma_map[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 4);
+		map_cfg->xy2axi_luma_map[12] = GEN_XY2AXI(0, 0, 0, X_SEL, 7);
+		map_cfg->xy2axi_luma_map[13] = GEN_XY2AXI(0, 0, 1, Y_SEL, 5);
+		if (width <= 512) {
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 1024) {
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 2048) {
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else { // 4K size
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+
+		map_cfg->xy2axi_chr_map[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		map_cfg->xy2axi_chr_map[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		map_cfg->xy2axi_chr_map[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		map_cfg->xy2axi_chr_map[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		map_cfg->xy2axi_chr_map[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		map_cfg->xy2axi_chr_map[8] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		map_cfg->xy2axi_chr_map[9] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		map_cfg->xy2axi_chr_map[10] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		map_cfg->xy2axi_chr_map[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		map_cfg->xy2axi_chr_map[12] = GEN_XY2AXI(1, 0, 0, X_SEL, 7);
+		map_cfg->xy2axi_chr_map[13] = GEN_XY2AXI(1, 0, 1, Y_SEL, 4);
+		if (width_chr <= 512) {
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 1024) {
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 2048) {
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else { // 4K size
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+
+		//xy2axi_config
+		map_cfg->xy2axi_config =
+			GEN_CONFIG(0, 1, 1, 1, 1, 15, 15, 15, 15);
+		break;
+	}
+	case TILED_MIXED_V_MAP: {
+		map_cfg->xy2axi_luma_map[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		map_cfg->xy2axi_luma_map[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		map_cfg->xy2axi_luma_map[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		map_cfg->xy2axi_luma_map[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		map_cfg->xy2axi_luma_map[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		map_cfg->xy2axi_luma_map[8] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		map_cfg->xy2axi_luma_map[9] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		map_cfg->xy2axi_luma_map[10] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		map_cfg->xy2axi_luma_map[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 4);
+		map_cfg->xy2axi_luma_map[12] = GEN_XY2AXI(0, 0, 0, X_SEL, 7);
+		map_cfg->xy2axi_luma_map[13] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		if (width <= 512) {
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 1024) {
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 2048) {
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else { // 4K size
+			map_cfg->xy2axi_luma_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_luma_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+
+		map_cfg->xy2axi_chr_map[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		map_cfg->xy2axi_chr_map[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		map_cfg->xy2axi_chr_map[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		map_cfg->xy2axi_chr_map[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		map_cfg->xy2axi_chr_map[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		map_cfg->xy2axi_chr_map[8] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		map_cfg->xy2axi_chr_map[9] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		map_cfg->xy2axi_chr_map[10] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		map_cfg->xy2axi_chr_map[11] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		map_cfg->xy2axi_chr_map[12] = GEN_XY2AXI(1, 0, 0, X_SEL, 7);
+		map_cfg->xy2axi_chr_map[13] = GEN_XY2AXI(1, 0, 0, Y_SEL, 4);
+		if (width_chr <= 512) {
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 1024) {
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 2048) {
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else {
+			map_cfg->xy2axi_chr_map[14] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+			map_cfg->xy2axi_chr_map[15] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+
+		//xy2axi_config
+		map_cfg->xy2axi_config = GEN_CONFIG(0, 0, 1, 1, 1, 7, 7, 7, 7);
+		break;
+	}
+	case TILED_FRAME_MB_RASTER_MAP: {
+		map_cfg->xy2axi_luma_map[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		map_cfg->xy2axi_luma_map[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		map_cfg->xy2axi_luma_map[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		map_cfg->xy2axi_luma_map[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		map_cfg->xy2axi_luma_map[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+
+		map_cfg->xy2axi_chr_map[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		map_cfg->xy2axi_chr_map[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		map_cfg->xy2axi_chr_map[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		map_cfg->xy2axi_chr_map[6] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+
+		//-----------------------------------------------------------
+		// mb_addr = mby*stride + mbx
+		// mb_addr mapping:
+		//   luma   : axi_addr[~:8] => axi_addr = {mb_addr[23:0],map_addr[7:0]}
+		//   chroma : axi_addr[~:7] => axi_addr = {mb_addr[23:0],map_addr[6:0]}
+		//-----------------------------------------------------------
+
+		//xy2axi_config
+		map_cfg->xy2axi_config = GEN_CONFIG(0, 0, 0, 1, 1, 15, 0, 7, 0);
+		break;
+	}
+	case TILED_FIELD_MB_RASTER_MAP: {
+		map_cfg->xy2axi_luma_map[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		map_cfg->xy2axi_luma_map[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		map_cfg->xy2axi_luma_map[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		map_cfg->xy2axi_luma_map[6] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+
+		map_cfg->xy2axi_chr_map[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		map_cfg->xy2axi_chr_map[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		map_cfg->xy2axi_chr_map[5] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+
+		//-----------------------------------------------------------
+		// mb_addr = mby*stride + mbx
+		// mb_addr mapping:
+		//   luma   : axi_addr[~:7] => axi_addr = {mb_addr[23:0],map_addr[6:0]}
+		//   chroma : axi_addr[~:6] => axi_addr = {mb_addr[23:0],map_addr[5:0]}
+		//-----------------------------------------------------------
+
+		//xy2axi_config
+		map_cfg->xy2axi_config = GEN_CONFIG(0, 1, 1, 1, 1, 7, 7, 3, 3);
+
+		break;
+	}
+	case TILED_FRAME_NO_BANK_MAP:
+	case TILED_FIELD_NO_BANK_MAP: {
+		// luma
+		map_cfg->xy2axi_luma_map[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		map_cfg->xy2axi_luma_map[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		map_cfg->xy2axi_luma_map[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		map_cfg->xy2axi_luma_map[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		map_cfg->xy2axi_luma_map[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		map_cfg->xy2axi_luma_map[8] = GEN_XY2AXI(0, 0, 0, Y_SEL, 4);
+		map_cfg->xy2axi_luma_map[9] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		map_cfg->xy2axi_luma_map[10] = GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+		map_cfg->xy2axi_luma_map[11] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		map_cfg->xy2axi_luma_map[12] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		map_cfg->xy2axi_luma_map[13] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		map_cfg->xy2axi_luma_map[14] = GEN_XY2AXI(0, 0, 0, X_SEL, 7);
+		map_cfg->xy2axi_luma_map[15] = GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+		if (width <= 512) {
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 1024) {
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width <= 2048) {
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else {
+			map_cfg->xy2axi_luma_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_luma_map[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_luma_map[18] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			map_cfg->xy2axi_luma_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_luma_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_luma_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_luma_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_luma_map[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+
+		// chroma
+		map_cfg->xy2axi_chr_map[3] = GEN_XY2AXI(0, 0, 0, Y_SEL, 0);
+		map_cfg->xy2axi_chr_map[4] = GEN_XY2AXI(0, 0, 0, Y_SEL, 1);
+		map_cfg->xy2axi_chr_map[5] = GEN_XY2AXI(0, 0, 0, Y_SEL, 2);
+		map_cfg->xy2axi_chr_map[6] = GEN_XY2AXI(0, 0, 0, Y_SEL, 3);
+		map_cfg->xy2axi_chr_map[7] = GEN_XY2AXI(0, 0, 0, X_SEL, 3);
+		map_cfg->xy2axi_chr_map[8] = GEN_XY2AXI(0, 0, 0, Y_SEL, 4);
+		map_cfg->xy2axi_chr_map[9] = GEN_XY2AXI(0, 0, 0, Y_SEL, 5);
+		map_cfg->xy2axi_chr_map[10] = GEN_XY2AXI(0, 0, 0, Y_SEL, 6);
+		map_cfg->xy2axi_chr_map[11] = GEN_XY2AXI(0, 0, 0, X_SEL, 4);
+		map_cfg->xy2axi_chr_map[12] = GEN_XY2AXI(0, 0, 0, X_SEL, 5);
+		map_cfg->xy2axi_chr_map[13] = GEN_XY2AXI(0, 0, 0, X_SEL, 6);
+		map_cfg->xy2axi_chr_map[14] = GEN_XY2AXI(0, 0, 0, X_SEL, 7);
+		map_cfg->xy2axi_chr_map[15] = GEN_XY2AXI(0, 0, 0, X_SEL, 8);
+
+		if (width_chr <= 512) {
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 1024) {
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else if (width_chr <= 2048) {
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		} else {
+			map_cfg->xy2axi_chr_map[16] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 9);
+			map_cfg->xy2axi_chr_map[17] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 10);
+			map_cfg->xy2axi_chr_map[18] =
+				GEN_XY2AXI(0, 0, 0, X_SEL, 11);
+			map_cfg->xy2axi_chr_map[19] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 7);
+			map_cfg->xy2axi_chr_map[20] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 8);
+			map_cfg->xy2axi_chr_map[21] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 9);
+			map_cfg->xy2axi_chr_map[22] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 10);
+			map_cfg->xy2axi_chr_map[23] =
+				GEN_XY2AXI(0, 0, 0, Y_SEL, 11);
+		}
+
+		//xy2axi_config
+		if (map_type == TILED_FRAME_NO_BANK_MAP)
+			map_cfg->xy2axi_config =
+				GEN_CONFIG(0, 0, 0, 1, 1, 15, 0, 15, 0);
+		else
+			map_cfg->xy2axi_config =
+				GEN_CONFIG(0, 1, 1, 1, 1, 15, 15, 15, 15);
+
+		break;
+	}
+	default:
+		return 0;
+		break;
+	}
+
+	for (i = 0; i < 32; i++) //xy2axi_luma_map
+		vpu_write_reg(vpu_dev, GDI_XY2AXI_LUM_BIT00 + 4 * i,
+			      map_cfg->xy2axi_luma_map[i]);
+
+	for (i = 0; i < 32; i++) //xy2axi_chr_map
+		vpu_write_reg(vpu_dev, GDI_XY2AXI_CHR_BIT00 + 4 * i,
+			      map_cfg->xy2axi_chr_map[i]);
+
+	//xy2axi_config
+	vpu_write_reg(vpu_dev, GDI_XY2AXI_CONFIG, map_cfg->xy2axi_config);
+
+	// fast access for reading
+	map_cfg->tb_separate_map = (map_cfg->xy2axi_config >> 19) & 0x1;
+	map_cfg->top_bot_split = (map_cfg->xy2axi_config >> 18) & 0x1;
+	map_cfg->tiled_map = (map_cfg->xy2axi_config >> 17) & 0x1;
+
+	return 1;
+}
+
+static int coda_config_sec_axi(struct vpu_instance *inst, int codec_mode,
+			       struct sec_axi_info *sa, int width, int height,
+			       int profile)
+{
+	int offset;
+	u32 mb_num_x = ((width & 0xFFFF) + 15) / 16;
+	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
+
+	if (!p_dec_info->open_param.sec_size_core0) {
+		sa->buf_size = 0;
+		sa->use_bit_enable = 0;
+		sa->use_ip_enable = 0;
+		sa->use_dbk_y_enable = 0;
+		sa->use_dbk_c_enable = 0;
+		sa->use_ovl_enable = 0;
+		sa->use_btp_enable = 0;
+		return 0;
+	}
+
+	sa->buf_base = p_dec_info->open_param.sec_base_core0;
+	offset = 0;
+
+	//BIT
+	if (sa->use_bit_enable) {
+		sa->buf_bit_use = sa->buf_base + offset;
+
+		switch (codec_mode) {
+		case AVC_DEC:
+			offset = offset + mb_num_x * 144;
+			break; // AVC
+		case MP2_DEC:
+			offset = offset + mb_num_x * 0;
+			break;
+		case VPX_DEC:
+			offset = offset + mb_num_x * 0;
+			break;
+		default:
+			offset = offset + mb_num_x * 16;
+			break; // MPEG-4
+		}
+
+		if (offset > p_dec_info->open_param.sec_size_core0) {
+			sa->buf_size = 0;
+			return 0;
+		}
+	}
+
+	if (sa->use_ip_enable) {
+		sa->buf_ip_acdc_use = sa->buf_base + offset;
+
+		switch (codec_mode) {
+		case AVC_DEC:
+			offset = offset + mb_num_x * 64;
+			break; // AVC
+		case MP2_DEC:
+			offset = offset + mb_num_x * 0;
+			break;
+		case VPX_DEC:
+			offset = offset + mb_num_x * 64;
+			break;
+		default:
+			offset = offset + mb_num_x * 128;
+			break; // MPEG-4
+		}
+
+		if (offset > p_dec_info->open_param.sec_size_core0) {
+			sa->buf_size = 0;
+			return 0;
+		}
+	}
+
+	//Deblock Chroma
+	if (sa->use_dbk_c_enable) {
+		sa->buf_dbk_c_use = sa->buf_base + offset;
+		switch (codec_mode) {
+		case AVC_DEC:
+			offset = (profile == 66 /*AVC BP decoder*/) ?
+					 offset + (mb_num_x * 64) :
+					 offset + (mb_num_x * 128);
+			break; // AVC
+		case MP2_DEC:
+			offset = offset + mb_num_x * 64;
+			break;
+		case VPX_DEC:
+			offset = offset + mb_num_x * 128;
+			break;
+		default:
+			offset = offset + mb_num_x * 64;
+			break;
+		}
+
+		if (offset > p_dec_info->open_param.sec_size_core0) {
+			sa->buf_size = 0;
+			return 0;
+		}
+	}
+
+	//Deblock Luma
+	if (sa->use_dbk_y_enable) {
+		sa->buf_dbk_y_use = sa->buf_base + offset;
+
+		switch (codec_mode) {
+		case AVC_DEC:
+			offset = (profile == 66 /*AVC BP decoder*/) ?
+					 offset + (mb_num_x * 64) :
+					 offset + (mb_num_x * 128);
+			break; // AVC
+		case MP2_DEC:
+			offset = offset + mb_num_x * 128;
+			break;
+		case VPX_DEC:
+			offset = offset + mb_num_x * 128;
+			break;
+		default:
+			offset = offset + mb_num_x * 128;
+			break;
+		}
+
+		if (offset > p_dec_info->open_param.sec_size_core0) {
+			sa->buf_size = 0;
+			return 0;
+		}
+	}
+
+	// check the buffer address which is 256 byte is available.
+	if (((offset + 255) & (~255)) > p_dec_info->open_param.sec_size_core0) {
+		dev_err(inst->dev->dev,
+			"%s:%d NOT ENOUGH SRAM: required(%d), sram(%d)\n",
+			__FUNCTION__, __LINE__, offset,
+			p_dec_info->open_param.sec_size_core0);
+		sa->buf_size = 0;
+		return 0;
+	}
+
+	sa->buf_size = offset;
+
+	return 1;
+}
+
+static void coda_config_maveric_cache2(struct vpu_instance *inst,
+            bool decoder,
+			u32 *cache_mode,
+			bool interleave,
+			u32 bypass,
+			u32 burst,
+			u32 merge,
+			enum tiled_map_type map_type,
+			u32 wayshape
+			)
+{
+	unsigned int cache_config = 0;
+
+	if(decoder == true) {
+        if (map_type == 0) {// LINEAR_FRAME_MAP
+            //VC1 opposite field padding is not allowable in UV separated, burst 8 and linear map
+            if(!interleave)
+                burst = 0;
+
+            wayshape = 15;
+
+            if (merge == 1)
+                merge = 3;
+
+            //GDI constraint. Width should not be over 64
+            if (( merge== 1) && (burst))
+                burst = 0;
+        }
+        else {
+            //horizontal merge constraint in tiled map
+            if (merge == 1)
+                merge = 3;
+        }
+    }
+    else { // encoder
+        if (map_type == LINEAR_FRAME_MAP) {
+            wayshape = 15;
+            //GDI constraint. Width should not be over 64
+            if ((merge == 1) && (burst))
+                burst= 0;
+        }
+        else {
+            //horizontal merge constraint in tiled map
+            if (merge == 1)
+                merge = 3;
+        }
+    }
+
+    cache_config = (merge & 0x3) << 9;
+    cache_config = cache_config | ((wayshape & 0xf) << 5);
+    cache_config = cache_config | ((burst & 0x1) << 3);
+    cache_config = cache_config | (bypass & 0x3);
+
+    if(map_type != 0)//LINEAR_FRAME_MAP
+        cache_config = cache_config | 0x00000004;
+
+    ///{16'b0, 5'b0, merge[1:0], wayshape[3:0], 1'b0, burst[0], map[0], bypass[1:0]};
+    *cache_mode = cache_config;
+
+	return;
+}
+
+static int coda_vpu_dec_put_sl_mpeg2_info(
+	struct vpu_instance *inst,
+	const struct v4l2_ctrl_mpeg2_sequence *mp2_seq,
+	const struct v4l2_ctrl_mpeg2_picture *mp2_pic,
+	const struct v4l2_ctrl_mpeg2_quantisation *mp2_quantisation)
+{
+	struct mp2_direct_memory mp2_direct;
+	struct mp2_indirect_memory mp2_indirect;
+	struct vpu_buf *work_buf = &inst->work_vbuf;
+	u8 conv_data[2048];
+	int i, j;
+	int ret;
+
+	memset(&mp2_direct, 0x00, sizeof(mp2_direct));
+	memset(&mp2_indirect, 0x00, sizeof(mp2_indirect));
+
+	coda_vdi_read_memory(inst->dev, work_buf, CODA9_MP2_DIRECT_MEM_OFFSET,
+			     conv_data, sizeof(mp2_direct), VDI_BIG_ENDIAN);
+	coda_vpu_dec_convert_to_endian(conv_data, (u8 *)&mp2_direct,
+				       sizeof(mp2_direct));
+
+	coda_vdi_read_memory(inst->dev, work_buf, CODA9_MP2_INDIRECT_MEM_OFFSET,
+			     conv_data, sizeof(mp2_indirect), VDI_BIG_ENDIAN);
+	coda_vpu_dec_convert_to_endian(conv_data, (u8 *)&mp2_indirect,
+				       sizeof(mp2_indirect));
+
+	mp2_direct.dMpeg2 = 1;
+	/* v4l2_ctrl_mpeg2_sequence */
+	if (mp2_seq->chroma_format != 1) {
+		dev_err(inst->dev->dev, "BODA supports only YUV420 :%d \n",
+			mp2_seq->chroma_format);
+		return -EINVAL;
+	}
+
+	mp2_direct.dPicXSeq = mp2_direct.dPicX = mp2_seq->horizontal_size;
+	mp2_direct.dPicYSeq = mp2_direct.dPicY = mp2_seq->vertical_size;
+	mp2_direct.dProfile = (mp2_seq->profile_and_level_indication >> 4) & 7;
+	mp2_direct.dLevel = (mp2_seq->profile_and_level_indication) & 0xF;
+	mp2_direct.dProgSeq = mp2_seq->flags;
+	if (mp2_direct.dProgSeq)
+		mp2_direct.dMbNumY = (mp2_direct.dPicY + 15) / 16;
+	else
+		mp2_direct.dMbNumY = ((mp2_direct.dPicY + 31) / 32) * 2;
+	mp2_direct.dMbNumX = (mp2_direct.dPicX + 15) / 16;
+
+	/* v4l2_ctrl_mpeg2_picture */
+	mp2_direct.dTopFieldFirst =
+		((mp2_pic->flags & V4L2_MPEG2_PIC_FLAG_TOP_FIELD_FIRST)) & 1;
+	mp2_direct.dFrameDct =
+		((mp2_pic->flags & V4L2_MPEG2_PIC_FLAG_FRAME_PRED_DCT) >> 1) &
+		1;
+	mp2_direct.dConcealMV =
+		((mp2_pic->flags & V4L2_MPEG2_PIC_FLAG_CONCEALMENT_MV) >> 2) &
+		1;
+	mp2_direct.dQScaleType =
+		((mp2_pic->flags & V4L2_MPEG2_PIC_FLAG_Q_SCALE_TYPE) >> 3) & 1;
+	mp2_direct.dVlcFormat =
+		((mp2_pic->flags & V4L2_MPEG2_PIC_FLAG_INTRA_VLC) >> 4) & 1;
+	mp2_direct.dAlternateScan =
+		((mp2_pic->flags & V4L2_MPEG2_PIC_FLAG_ALT_SCAN) >> 5) & 1;
+	mp2_direct.dRepeatFirst =
+		((mp2_pic->flags & V4L2_MPEG2_PIC_FLAG_REPEAT_FIRST) >> 6) & 1;
+	mp2_direct.dProgFrame =
+		((mp2_pic->flags & V4L2_MPEG2_PIC_FLAG_PROGRESSIVE) >> 7) & 1;
+	mp2_direct.dLoadBit = 3; // always load Qmat
+
+	for (i = 0; i < 2; i++) {
+		for (j = 0; j < 2; j++) {
+			mp2_indirect.pRSize[i][j] = mp2_pic->f_code[i][j] - 1;
+			mp2_indirect.pLimit[i][j] =
+				16 << mp2_indirect.pRSize[i][j];
+		}
+	}
+
+	mp2_direct.dPicType = mp2_pic->picture_coding_type - 1;
+	switch (mp2_pic->picture_coding_type) {
+	case V4L2_MPEG2_PIC_CODING_TYPE_I:
+		mp2_direct.dPictureI = 1;
+		mp2_direct.dPictureP = 0;
+		mp2_direct.dPictureB = 0;
+		break;
+	case V4L2_MPEG2_PIC_CODING_TYPE_P:
+		mp2_direct.dPictureI = 0;
+		mp2_direct.dPictureP = 1;
+		mp2_direct.dPictureB = 0;
+		break;
+	case V4L2_MPEG2_PIC_CODING_TYPE_B:
+		mp2_direct.dPictureI = 0;
+		mp2_direct.dPictureP = 0;
+		mp2_direct.dPictureB = 1;
+		break;
+	default:
+		dev_err(inst->dev->dev, "Check picture_coding_type :%d \n",
+			mp2_pic->picture_coding_type);
+		return -EINVAL;
+		break;
+	}
+
+	mp2_direct.dPicStruct =
+		mp2_pic->picture_structure; // 1: interlaced top field, 2: interlaced bottom field, 3: progressive frame
+	if (mp2_direct.dPicStruct == 3) {
+		mp2_direct.dField = 0;
+		mp2_direct.dFramePic = 1;
+		mp2_direct.dFieldPic = 0;
+		mp2_direct.dMbFieldY = mp2_direct.dMbNumY;
+		mp2_direct.dMbNumInPic =
+			mp2_direct.dMbNumX * mp2_direct.dMbNumY;
+	} else {
+		if (mp2_direct.dPicStruct == 2)
+			mp2_direct.dField = 1; // bottom
+		else
+			mp2_direct.dField = 0; // top
+		mp2_direct.dFramePic = 0;
+		mp2_direct.dFieldPic = 1;
+		mp2_direct.dMbFieldY = mp2_direct.dMbNumY / 2;
+		mp2_direct.dMbNumInPic =
+			(mp2_direct.dMbNumX * mp2_direct.dMbNumY) / 2;
+	}
+
+	mp2_direct.dDcPrecision = mp2_pic->intra_dc_precision;
+
+	/* v4l2_ctrl_mpeg2_quantisation */
+	for (i = 0; i < 64; i++) {
+		mp2_indirect.pIntraQMat[i] =
+			mp2_quantisation->intra_quantiser_matrix[i];
+		mp2_indirect.pInterQMat[i] =
+			mp2_quantisation->non_intra_quantiser_matrix[i];
+	}
+
+	coda_vpu_dec_convert_to_endian((u8 *)&mp2_direct, conv_data,
+				       sizeof(mp2_direct));
+	ret = coda_vdi_write_memory(inst->dev, work_buf,
+				    CODA9_MP2_DIRECT_MEM_OFFSET, conv_data,
+				    sizeof(mp2_direct), VDI_BIG_ENDIAN);
+	if (ret <= 0)
+		return ret;
+
+#ifdef DEBUG_STATELESS
+	// debugging
+	dev_dbg(inst->dev->dev, "dMpeg2         = %d \n", mp2_direct.dMpeg2);
+	dev_dbg(inst->dev->dev, "dPicXSeq       = %d \n", mp2_direct.dPicXSeq);
+	dev_dbg(inst->dev->dev, "dPicX          = %d \n", mp2_direct.dPicX);
+	dev_dbg(inst->dev->dev, "dPicYSeq       = %d \n", mp2_direct.dPicYSeq);
+	dev_dbg(inst->dev->dev, "dPicY          = %d \n", mp2_direct.dPicY);
+	dev_dbg(inst->dev->dev, "dProfile       = %d \n", mp2_direct.dProfile);
+	dev_dbg(inst->dev->dev, "dLevel         = %d \n", mp2_direct.dLevel);
+	dev_dbg(inst->dev->dev, "dProgSeq       = %d \n", mp2_direct.dProgSeq);
+	dev_dbg(inst->dev->dev, "dMbNumX        = %d \n", mp2_direct.dMbNumX);
+	dev_dbg(inst->dev->dev, "dMbNumY        = %d \n", mp2_direct.dMbNumY);
+	dev_dbg(inst->dev->dev, "dTopFieldFirst = %d \n", mp2_direct.dTopFieldFirst);
+	dev_dbg(inst->dev->dev, "dFrameDct      = %d \n", mp2_direct.dFrameDct);
+	dev_dbg(inst->dev->dev, "dConcealMV     = %d \n", mp2_direct.dConcealMV);
+	dev_dbg(inst->dev->dev, "dQScaleType    = %d \n", mp2_direct.dQScaleType);
+	dev_dbg(inst->dev->dev, "dVlcFormat     = %d \n", mp2_direct.dVlcFormat);
+	dev_dbg(inst->dev->dev, "dAlternateScan = %d \n", mp2_direct.dAlternateScan);
+	dev_dbg(inst->dev->dev, "dRepeatFirst   = %d \n", mp2_direct.dRepeatFirst);
+	dev_dbg(inst->dev->dev, "dProgFrame     = %d \n", mp2_direct.dProgFrame);
+
+	dev_dbg(inst->dev->dev, "pRSize[0][0]=%d pRSize[0][1]=%d pRSize[1][0]=%d pRSize[1][1]=%d \n",
+	       mp2_indirect.pRSize[0][0], mp2_indirect.pRSize[0][1],
+	       mp2_indirect.pRSize[1][0], mp2_indirect.pRSize[1][1]);
+	dev_dbg(inst->dev->dev, "pLimit[0][0]=%d pLimit[0][1]=%d pLimit[1][0]=%d pLimit[1][1]=%d \n",
+	       mp2_indirect.pLimit[0][0], mp2_indirect.pLimit[0][1],
+	       mp2_indirect.pLimit[1][0], mp2_indirect.pLimit[1][1]);
+	dev_dbg(inst->dev->dev, "dPicType     = %d \n", mp2_direct.dPicType);
+	dev_dbg(inst->dev->dev, "dPictureI    = %d \n", mp2_direct.dPictureI);
+	dev_dbg(inst->dev->dev, "dPictureP    = %d \n", mp2_direct.dPictureP);
+	dev_dbg(inst->dev->dev, "dPictureB    = %d \n", mp2_direct.dPictureB);
+	dev_dbg(inst->dev->dev, "dPicStruct   = %d \n", mp2_direct.dPicStruct);
+	dev_dbg(inst->dev->dev, "dField    	 = %d \n", mp2_direct.dField);
+	dev_dbg(inst->dev->dev, "dFramePic    = %d \n", mp2_direct.dFramePic);
+	dev_dbg(inst->dev->dev, "dFieldPic    = %d \n", mp2_direct.dFieldPic);
+	dev_dbg(inst->dev->dev, "dMbFieldY  	 = %d \n", mp2_direct.dMbFieldY);
+	dev_dbg(inst->dev->dev, "dMbNumInPic  = %d \n", mp2_direct.dMbNumInPic);
+	dev_dbg(inst->dev->dev, "dDcPrecision = %d \n", mp2_direct.dDcPrecision);
+#endif
+
+	coda_vpu_dec_convert_to_endian((u8 *)&mp2_indirect, conv_data,
+				       sizeof(mp2_indirect));
+	ret = coda_vdi_write_memory(inst->dev, work_buf,
+				    CODA9_MP2_INDIRECT_MEM_OFFSET, conv_data,
+				    sizeof(mp2_indirect), VDI_BIG_ENDIAN);
+	if (ret <= 0)
+		return ret;
+
+	return 0;
+}
+
+static int
+coda_vpu_dec_put_sl_vp8_info(struct vpu_instance *inst,
+			     const struct v4l2_ctrl_vp8_frame *vp8_frame)
+{
+	struct vp8_direct_memory vp8_direct;
+	struct vpu_buf *work_buf = &inst->work_vbuf;
+	u8 conv_data[2048];
+	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
+	u32 pic_chunk_size;
+	// int i,j;
+	int ret;
+
+	memset(&vp8_direct, 0x00, sizeof(vp8_direct));
+
+	coda_vdi_read_memory(inst->dev, work_buf, CODA9_VP8_DIRECT_MEM_OFFSET,
+			     conv_data, sizeof(vp8_direct), VDI_BIG_ENDIAN);
+	coda_vpu_dec_convert_to_endian(conv_data, (u8 *)&vp8_direct,
+				       sizeof(vp8_direct));
+
+	/* check sequence change */
+	if ( (vp8_direct.dSeqPicWidth != 0 && vp8_direct.dSeqPicWidth != vp8_frame->width) || (vp8_direct.dSeqPicHeight != 0 && vp8_direct.dSeqPicHeight != vp8_frame->height) )
+        return -EINVAL;
+
+	/* v4l2_ctrl_vp8_frame */
+	vp8_direct.dSeqPicWidth = vp8_frame->width;
+	vp8_direct.dSeqPicHeight = vp8_frame->height;
+	pic_chunk_size = p_dec_info->stream_wr_ptr - p_dec_info->stream_rd_ptr;
+	vp8_direct.dPicChunkSizeH = pic_chunk_size >> 16;
+	vp8_direct.dPicChunkSizeL = pic_chunk_size & 0xffff;
+
+	dev_dbg(inst->dev->dev, "dSeqPicWidth    = %d \n", vp8_direct.dSeqPicWidth);
+	dev_dbg(inst->dev->dev, "dSeqPicHeight   = %d \n", vp8_direct.dSeqPicHeight);
+	dev_dbg(inst->dev->dev, "dPicChunkSizeH  = %d \n", vp8_direct.dPicChunkSizeH);
+	dev_dbg(inst->dev->dev, "dPicChunkSizeL  = %d \n", vp8_direct.dPicChunkSizeL);
+
+	coda_vpu_dec_convert_to_endian((u8 *)&vp8_direct, conv_data,
+				       sizeof(vp8_direct));
+	ret = coda_vdi_write_memory(inst->dev, work_buf,
+				    CODA9_VP8_DIRECT_MEM_OFFSET, conv_data,
+				    sizeof(vp8_direct), VDI_BIG_ENDIAN);
+	if (ret <= 0)
+		return ret;
+
+	return 0;
+}
+
+static int coda_vpu_dec_put_sl_h264_info(
+	struct vpu_instance *inst, const struct v4l2_ctrl_h264_sps *h264_sps,
+	const struct v4l2_ctrl_h264_pps *h264_pps,
+	const struct v4l2_ctrl_h264_scaling_matrix *scaling_matrix)
+{
+	int mb_num_in_pic;
+	struct avc_direct_memory avc;
+	struct vpu_buf *work_buf = &inst->work_vbuf;
+	int ret;
+	u8 conv_data[2048];
+	int memSize;
+
+	memset(&avc, 0x00, sizeof(avc));
+
+	coda_vdi_read_memory(inst->dev, work_buf, CODA9_AVC_DIRECT_MEM_OFFSET,
+			     conv_data, sizeof(avc), VDI_BIG_ENDIAN);
+	coda_vpu_dec_convert_to_endian(conv_data, (u8 *)&avc, sizeof(avc));
+
+	avc.dChromaIdc = h264_sps->chroma_format_idc;
+
+	if (h264_sps->bit_depth_luma_minus8 != 0) {
+		dev_err(inst->dev->dev, "wrong bit_depth_luma_minus8 :%d \n",
+			h264_sps->bit_depth_luma_minus8);
+		return -EINVAL;
+	}
+
+	if (h264_sps->bit_depth_chroma_minus8 != 0) {
+		dev_err(inst->dev->dev, "wrong bit_depth_chroma_minus8 :%d \n",
+			h264_sps->bit_depth_chroma_minus8);
+		return -EINVAL;
+	}
+
+	avc.dProfileIdc = h264_sps->profile_idc;
+	avc.dConstSetflag7_0 = h264_sps->constraint_set_flags;
+	avc.dLevelIdc = h264_sps->level_idc;
+	avc.dSeqParaSetId = h264_sps->seq_parameter_set_id;
+
+	avc.dMaxFrameBit = h264_sps->log2_max_frame_num_minus4 + 4;
+	avc.dMaxFrameNumH = ((1 << avc.dMaxFrameBit) >> 16);
+	avc.dMaxFrameNumL = ((1 << avc.dMaxFrameBit) & 0xFFFF);
+	avc.dPicOrderCntType = h264_sps->pic_order_cnt_type;
+	avc.dPicOrderCntBit = h264_sps->log2_max_pic_order_cnt_lsb_minus4 + 4;
+	avc.dNumRefFrame = h264_sps->max_num_ref_frames;
+	avc.dMaxRefFrame =
+		1 >= avc.dNumRefFrame ?
+			1 :
+			avc.dNumRefFrame; // MAX(1, avc.dNumRefFrame);
+	avc.dMaxDpbSize = 16; // set as max
+	avc.dMbNumX = h264_sps->pic_width_in_mbs_minus1 + 1;
+	avc.dMbNumY = h264_sps->pic_height_in_map_units_minus1 + 1;
+
+	// dev_dbg(inst->dev->dev, "**h264_sps->flags           = 0x%x \n", h264_sps->flags);
+	avc.dPicOrderZeroFlag =
+		(h264_sps->flags &
+		 V4L2_H264_SPS_FLAG_DELTA_PIC_ORDER_ALWAYS_ZERO) >>
+		2;
+	avc.dGapsInFrameNum =
+		(h264_sps->flags &
+		 V4L2_H264_SPS_FLAG_GAPS_IN_FRAME_NUM_VALUE_ALLOWED) >>
+		3;
+	avc.dFrameMbsOnlyFlag =
+		(h264_sps->flags & V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY) >> 4;
+	avc.dMbAffFlag = (h264_sps->flags &
+			  V4L2_H264_SPS_FLAG_MB_ADAPTIVE_FRAME_FIELD) >>
+			 5;
+	avc.dDirect8x8Flag =
+		(h264_sps->flags & V4L2_H264_SPS_FLAG_DIRECT_8X8_INFERENCE) >>
+		6;
+	if (!avc.dFrameMbsOnlyFlag) {
+		avc.dMbNumY *= 2;
+	}
+
+	mb_num_in_pic = avc.dMbNumX * avc.dMbNumY;
+	avc.dMbNumInPic = mb_num_in_pic;
+
+	/*v4l2_ctrl_h264_pps*/
+	avc.dPicParaSetId = h264_pps->pic_parameter_set_id;
+	if (h264_sps->seq_parameter_set_id != h264_pps->seq_parameter_set_id) {
+		dev_err(inst->dev->dev, "PPS's seq_parameter_set_id :%d \n",
+			h264_pps->seq_parameter_set_id);
+		return -EINVAL;
+	}
+
+	if (h264_pps->num_slice_groups_minus1 != 0) {
+		dev_err(inst->dev->dev,
+			"FMO is not supported num_slice_groups_minus1 :%d \n",
+			h264_pps->num_slice_groups_minus1);
+		return -EINVAL;
+	}
+	avc.dNumSliceGrpMinus1 = 0;
+	avc.dPicNumRefIdxL0Minus1 =
+		h264_pps->num_ref_idx_l0_default_active_minus1;
+	avc.dPicNumRefIdxL1Minus1 =
+		h264_pps->num_ref_idx_l1_default_active_minus1;
+	avc.dWpIdc = h264_pps->weighted_bipred_idc;
+	avc.dPicInitQpY = h264_pps->pic_init_qp_minus26 + 26;
+	avc.dChromaQpOffset = h264_pps->chroma_qp_index_offset;
+	avc.dSecondChromaQpOffset = h264_pps->second_chroma_qp_index_offset;
+	// dev_dbg(inst->dev->dev, "**h264_pps->flags           = 0x%x \n", h264_pps->flags);
+	avc.dUseCabac =
+		(h264_pps->flags & V4L2_H264_PPS_FLAG_ENTROPY_CODING_MODE) >> 0;
+	avc.dPicOrderPrsFlag =
+		(h264_pps->flags &
+		 V4L2_H264_PPS_FLAG_BOTTOM_FIELD_PIC_ORDER_IN_FRAME_PRESENT) >>
+		1;
+	avc.dWpFlag = (h264_pps->flags & V4L2_H264_PPS_FLAG_WEIGHTED_PRED) >> 2;
+	avc.dDeblkCtrlPresent =
+		(h264_pps->flags &
+		 V4L2_H264_PPS_FLAG_DEBLOCKING_FILTER_CONTROL_PRESENT) >>
+		3;
+	avc.dConstrainIntra =
+		(h264_pps->flags & V4L2_H264_PPS_FLAG_CONSTRAINED_INTRA_PRED) >>
+		4;
+	avc.dRedundPicCntPresent =
+		(h264_pps->flags &
+		 V4L2_H264_PPS_FLAG_REDUNDANT_PIC_CNT_PRESENT) >>
+		5;
+	avc.dTransform8x8ModeFlag =
+		(h264_pps->flags & V4L2_H264_PPS_FLAG_TRANSFORM_8X8_MODE) >> 6;
+	avc.dPicScalingMatrixFlag =
+		(h264_pps->flags & V4L2_H264_PPS_FLAG_SCALING_MATRIX_PRESENT) >>
+		7;
+
+#ifdef DEBUG_STATELESS
+	dev_dbg(inst->dev->dev, "AVC params for stateless[%03d] --------------------------- \n",
+	       avc.dFrameNum + 1);
+	dev_dbg(inst->dev->dev, "dProfileIdc           = 0x%x \n", avc.dProfileIdc);
+	dev_dbg(inst->dev->dev, "dConstSetflag7_0      = 0x%x \n", avc.dConstSetflag7_0);
+	dev_dbg(inst->dev->dev, "dLevelIdc             = 0x%x \n", avc.dLevelIdc);
+	dev_dbg(inst->dev->dev, "dSeqParaSetId         = 0x%x \n", avc.dSeqParaSetId);
+
+	dev_dbg(inst->dev->dev, "dMaxFrameBit          = 0x%x \n", avc.dMaxFrameBit);
+	dev_dbg(inst->dev->dev, "dMaxFrameNumH         = 0x%x \n", avc.dMaxFrameNumH);
+	dev_dbg(inst->dev->dev, "dMaxFrameNumL         = 0x%x \n", avc.dMaxFrameNumL);
+	dev_dbg(inst->dev->dev, "dPicOrderCntType      = 0x%x \n", avc.dPicOrderCntType);
+	dev_dbg(inst->dev->dev, "dPicOrderCntBit       = 0x%x \n", avc.dPicOrderCntBit);
+	dev_dbg(inst->dev->dev, "dNumRefFrame          = 0x%x \n", avc.dNumRefFrame);
+	dev_dbg(inst->dev->dev, "dMaxRefFrame          = 0x%x \n", avc.dMaxRefFrame);
+	dev_dbg(inst->dev->dev, "dMbNumX               = 0x%x \n", avc.dMbNumX);
+	dev_dbg(inst->dev->dev, "dMbNumY               = 0x%x \n", avc.dMbNumY);
+
+	dev_dbg(inst->dev->dev, "dMbNumInPic            =0x%x \n", avc.dMbNumInPic);
+
+	dev_dbg(inst->dev->dev, "dPicOrderZeroFlag     = 0x%x \n", avc.dPicOrderZeroFlag);
+	dev_dbg(inst->dev->dev, "dGapsInFrameNum       = 0x%x \n", avc.dGapsInFrameNum);
+	dev_dbg(inst->dev->dev, "dFrameMbsOnlyFlag     = 0x%x \n", avc.dFrameMbsOnlyFlag);
+	dev_dbg(inst->dev->dev, "dMbAffFlag            = 0x%x \n", avc.dMbAffFlag);
+	dev_dbg(inst->dev->dev, "dDirect8x8Flag        = 0x%x \n", avc.dDirect8x8Flag);
+
+	dev_dbg(inst->dev->dev, "dPicParaSetId         = 0x%x \n", avc.dPicParaSetId);
+
+	dev_dbg(inst->dev->dev, "dNumSliceGrpMinus1    = 0x%x \n", avc.dNumSliceGrpMinus1);
+	dev_dbg(inst->dev->dev, "dPicNumRefIdxL0Minus1 = 0x%x \n", avc.dPicNumRefIdxL0Minus1);
+	dev_dbg(inst->dev->dev, "dPicNumRefIdxL1Minus1 = 0x%x \n", avc.dPicNumRefIdxL1Minus1);
+	dev_dbg(inst->dev->dev, "dWpIdc                = 0x%x \n", avc.dWpIdc);
+	dev_dbg(inst->dev->dev, "dPicInitQpY           = 0x%x \n", avc.dPicInitQpY);
+	dev_dbg(inst->dev->dev, "dChromaQpOffset       = 0x%x \n", avc.dChromaQpOffset);
+	dev_dbg(inst->dev->dev, "dSecondChromaQpOffset = 0x%x \n", avc.dSecondChromaQpOffset);
+
+	dev_dbg(inst->dev->dev, "dUseCabac             = 0x%x \n", avc.dUseCabac);
+	dev_dbg(inst->dev->dev, "dPicOrderPrsFlag      = 0x%x \n", avc.dPicOrderPrsFlag);
+	dev_dbg(inst->dev->dev, "dWpFlag               = 0x%x \n", avc.dWpFlag);
+	dev_dbg(inst->dev->dev, "dDeblkCtrlPresent     = 0x%x \n", avc.dDeblkCtrlPresent);
+	dev_dbg(inst->dev->dev, "dConstrainIntra       = 0x%x \n", avc.dConstrainIntra);
+	dev_dbg(inst->dev->dev, "dRedundPicCntPresent  = 0x%x \n", avc.dRedundPicCntPresent);
+	dev_dbg(inst->dev->dev, "dTransform8x8ModeFlag = 0x%x \n", avc.dTransform8x8ModeFlag);
+	dev_dbg(inst->dev->dev, "dPicScalingMatrixFlag = 0x%x \n", avc.dPicScalingMatrixFlag);
+
+	dev_dbg(inst->dev->dev, "--------------------------------------------------- \n");
+#endif
+
+	avc.dSeqScalingMatrixFlag = avc.dPicScalingMatrixFlag = 1;
+	// TODO check Qmat format for stateless
+	memSize = sizeof(struct v4l2_ctrl_h264_scaling_matrix);
+	ret = coda_vdi_write_memory(inst->dev, work_buf,
+				    CODA9_AVC_Q_MATRIX_OFFSET,
+				    (u8 *)scaling_matrix, memSize,
+				    VDI_BIG_ENDIAN);
+	if (ret <= 0)
+		return ret;
+
+	coda_vpu_dec_convert_to_endian((u8 *)&avc, conv_data, sizeof(avc));
+	ret = coda_vdi_write_memory(inst->dev, work_buf,
+				    CODA9_AVC_DIRECT_MEM_OFFSET, conv_data,
+				    sizeof(avc), VDI_BIG_ENDIAN);
+	if (ret <= 0)
+		return ret;
+
+	return 0;
+}
+
+int coda_vpu_decode(struct vpu_instance *vpu_inst, struct dec_param *option)
+{
+	struct dec_info *p_dec_info = &vpu_inst->codec_info->dec_info;
+	struct vpu_device *dev = vpu_inst->dev;
+	int ret;
+	u32 rot_mir = 0;
+	int val;
+	enum tiled_map_type map_type;
+
+	vpu_write_reg(dev, BIT_FRM_DIS_FLG, 0);
+
+	if (p_dec_info->open_param.codec_mode == AVC_DEC) {
+		struct stateless_h264_info *h264 = &option->h264;
+		ret = coda_vpu_dec_put_sl_h264_info(vpu_inst, h264->sps,
+						    h264->pps, h264->sm);
+		if (ret)
+			return ret;
+	} else if (p_dec_info->open_param.codec_mode == MP2_DEC) {
+		struct stateless_mpeg2_info *mpeg2 = &option->mpeg2;
+		ret = coda_vpu_dec_put_sl_mpeg2_info(vpu_inst, mpeg2->seq,
+						     mpeg2->pic, mpeg2->quant);
+		if (ret)
+			return ret;
+	} else if (p_dec_info->open_param.codec_mode == VPX_DEC) {
+		struct stateless_vp8_info *vp8 = &option->vp8;
+		ret = coda_vpu_dec_put_sl_vp8_info(vpu_inst, vp8->frame);
+		if (ret)
+			return ret;
+	}
+
+	dev_dbg(dev->dev,
+		"%d.%s.vpu_write_reg.buf_addr_y:0x%llx.buf_addr_cb:0x%llx.buf_addr_cr:0x%llx\n",
+		__LINE__, __func__,
+		option->buf_addr_y, option->buf_addr_cb, option->buf_addr_cr);
+	vpu_write_reg(dev, CMD_DEC_PIC_STATELESS_LINEAR_ADDR_Y,
+		      option->buf_addr_y);
+	vpu_write_reg(dev, CMD_DEC_PIC_STATELESS_LINEAR_ADDR_CB,
+		      option->buf_addr_cb);
+	vpu_write_reg(dev, CMD_DEC_PIC_STATELESS_LINEAR_ADDR_CR,
+		      option->buf_addr_cr);
+
+	vpu_write_reg(dev, RET_DEC_PIC_CROP_LEFT_RIGHT,
+		      0); // frame crop information(left, right)
+	vpu_write_reg(dev, RET_DEC_PIC_CROP_TOP_BOTTOM,
+		      0); // frame crop information(top, bottom)
+
+	map_type = p_dec_info->open_param.map_type;
+
+	if (map_type != LINEAR_FRAME_MAP && map_type != LINEAR_FIELD_MAP) {
+		int stride =
+			(p_dec_info->stride > p_dec_info->framebuf_height) ?
+				p_dec_info->stride :
+				p_dec_info->framebuf_height;
+		ret = set_tile_map_type(dev, &p_dec_info->map_cfg, map_type,
+					stride, vpu_inst->cbcr_interleave);
+	} else
+		ret = set_tile_map_type(dev, &p_dec_info->map_cfg, map_type,
+					p_dec_info->stride,
+					vpu_inst->cbcr_interleave);
+	if (!ret) {
+		return -EINVAL;
+	}
+
+	vpu_write_reg(dev, CMD_DEC_PIC_USER_DATA_BASE_ADDR, 0);
+	vpu_write_reg(dev, CMD_DEC_PIC_USER_DATA_BUF_SIZE, 0);
+
+	vpu_write_reg(dev, CMD_DEC_PIC_OPTION, 0);
+
+	vpu_write_reg(dev, CMD_DEC_PIC_NUM_ROWS, 0);
+
+	val = ((p_dec_info->sec_axi_info.use_bit_enable & 0x01) << 0 |
+	       (p_dec_info->sec_axi_info.use_ip_enable & 0x01) << 1 |
+	       (p_dec_info->sec_axi_info.use_dbk_y_enable & 0x01) << 2 |
+	       (p_dec_info->sec_axi_info.use_dbk_c_enable & 0x01) << 3 |
+	       (p_dec_info->sec_axi_info.use_ovl_enable & 0x01) << 4 |
+	       (p_dec_info->sec_axi_info.use_btp_enable & 0x01) << 5 |
+	       (p_dec_info->sec_axi_info.use_bit_enable & 0x01) << 8 |
+	       (p_dec_info->sec_axi_info.use_ip_enable & 0x01) << 9 |
+	       (p_dec_info->sec_axi_info.use_dbk_y_enable & 0x01) << 10 |
+	       (p_dec_info->sec_axi_info.use_dbk_c_enable & 0x01) << 11 |
+	       (p_dec_info->sec_axi_info.use_ovl_enable & 0x01) << 12 |
+	       (p_dec_info->sec_axi_info.use_btp_enable & 0x01) << 13);
+
+	vpu_write_reg(dev, BIT_AXI_SRAM_USE, val);
+
+	vpu_write_reg(dev, BIT_WR_PTR, p_dec_info->stream_wr_ptr);
+	vpu_write_reg(dev, BIT_RD_PTR, p_dec_info->stream_rd_ptr);
+
+	p_dec_info->stream_end_flag &= ~(3 << 3);
+	if (p_dec_info->open_param.bitstream_mode == BS_MODE_PIC_END) {
+		p_dec_info->stream_end_flag |= (2 << 3);
+	}
+	vpu_write_reg(dev, BIT_BIT_STREAM_PARAM, p_dec_info->stream_end_flag);
+	val = 0;
+	val |= (p_dec_info->open_param.bwb_enable << 15);
+	val |= (p_dec_info->open_param.wtl_mode << 17) |
+	       (p_dec_info->open_param.tiled2_linear_mode << 13) |
+	       (p_dec_info->open_param.map_type << 9) | (FORMAT_420 << 6);
+
+	if (vpu_inst->cbcr_interleave == 1)
+		val |= vpu_inst->nv21 << 3;
+
+	val |= ((vpu_inst->cbcr_interleave)
+		<< 2); // Interleave bit position is modified
+	val |= p_dec_info->open_param.frame_endian;
+	//dev_dbg(dev->dev, "%d.%s.vpu_write_reg BIT_FRAME_MEM_CTRL.val:0x%x(cbcr_interleave:%d,nv21:%d)\n",
+	//	__LINE__,__func__,val,
+	//	vpu_inst->cbcr_interleave,vpu_inst->nv21);
+	vpu_write_reg(dev, BIT_FRAME_MEM_CTRL, val);
+
+	val = p_dec_info->open_param.stream_endian;
+	vpu_write_reg(dev, BIT_BIT_STREAM_CTRL, val);
+	vpu_write_reg(
+		dev, CMD_SET_FRAME_DELAY,
+		p_dec_info->open_param
+			.frame_delay); // for SET_FRAME_DELAY, realtek AVC only,
+
+	vpu_write_reg(dev, CMD_DEC_PIC_ROT_MODE, rot_mir);
+
+#ifdef DEBUG_STATELESS // debugging
+	vpu_write_reg(dev, BIT_MSG_0, 0xffff);
+	vpu_write_reg(dev, BIT_MSG_1, 0xffff);
+	vpu_write_reg(dev, BIT_MSG_2, 0xffff);
+	vpu_write_reg(dev, BIT_MSG_3, 0xffff);
+	coda_debug_register(dev, vpu_inst, PIC_RUN, 1);
+#endif
+	coda_bit_issue_command(dev, vpu_inst, PIC_RUN);
+
+	return 0;
+}
+
+int coda_vpu_dec_register_frame_buffer(struct vpu_instance *vpu_inst,
+				       struct frame_buffer *fb_arr,
+				       enum tiled_map_type map_type, u32 count)
+{
+	struct dec_info *p_dec_info = &vpu_inst->codec_info->dec_info;
+	struct vpu_device *dev = vpu_inst->dev;
+	int i;
+	int ret;
+	u32 val;
+
+	if (map_type != LINEAR_FRAME_MAP && map_type != LINEAR_FIELD_MAP) {
+		int stride =
+			(p_dec_info->stride > p_dec_info->framebuf_height) ?
+				p_dec_info->stride :
+				p_dec_info->framebuf_height;
+		ret = set_tile_map_type(dev, &p_dec_info->map_cfg, map_type,
+					stride, vpu_inst->cbcr_interleave);
+	} else
+		ret = set_tile_map_type(dev, &p_dec_info->map_cfg, map_type,
+					p_dec_info->stride,
+					vpu_inst->cbcr_interleave);
+	if (!ret)
+		return -1;
+
+	for (i = 0; i < count; i++) {
+		vpu_inst->frame_addr[i][0][0] = (fb_arr[i].buf_y >> 24) & 0xFF;
+		vpu_inst->frame_addr[i][0][1] = (fb_arr[i].buf_y >> 16) & 0xFF;
+		vpu_inst->frame_addr[i][0][2] = (fb_arr[i].buf_y >> 8) & 0xFF;
+		vpu_inst->frame_addr[i][0][3] = (fb_arr[i].buf_y >> 0) & 0xFF;
+
+		vpu_inst->frame_addr[i][1][0] = (fb_arr[i].buf_cb >> 24) & 0xFF;
+		vpu_inst->frame_addr[i][1][1] = (fb_arr[i].buf_cb >> 16) & 0xFF;
+		vpu_inst->frame_addr[i][1][2] = (fb_arr[i].buf_cb >> 8) & 0xFF;
+		vpu_inst->frame_addr[i][1][3] = (fb_arr[i].buf_cb >> 0) & 0xFF;
+		vpu_inst->frame_addr[i][2][0] = (fb_arr[i].buf_cr >> 24) & 0xFF;
+		vpu_inst->frame_addr[i][2][1] = (fb_arr[i].buf_cr >> 16) & 0xFF;
+		vpu_inst->frame_addr[i][2][2] = (fb_arr[i].buf_cr >> 8) & 0xFF;
+		vpu_inst->frame_addr[i][2][3] = (fb_arr[i].buf_cr >> 0) & 0xFF;
+	}
+	ret = coda_vdi_write_memory(vpu_inst->dev, &vpu_inst->dev->common_mem,
+				    CODE_BUF_SIZE + TEMP_BUF_SIZE,
+				    (u8 *)vpu_inst->frame_addr,
+				    sizeof(vpu_inst->frame_addr),
+				    VDI_BIG_ENDIAN);
+	if (ret <= 0)
+		return ret;
+
+	if (p_dec_info->open_param.codec_mode == AVC_DEC) {
+		for (i = 0; i < count; i++) {
+			vpu_inst->col_mv_addr[i][0] =
+				(vpu_inst->aux_vbuf[AUX_BUF_MV_COL][i].daddr >>
+				 24) &
+				0xFF;
+			vpu_inst->col_mv_addr[i][1] =
+				(vpu_inst->aux_vbuf[AUX_BUF_MV_COL][i].daddr >>
+				 16) &
+				0xFF;
+			vpu_inst->col_mv_addr[i][2] =
+				(vpu_inst->aux_vbuf[AUX_BUF_MV_COL][i].daddr >>
+				 8) &
+				0xFF;
+			vpu_inst->col_mv_addr[i][3] =
+				(vpu_inst->aux_vbuf[AUX_BUF_MV_COL][i].daddr >>
+				 0) &
+				0xFF;
+			dev_dbg(vpu_inst->dev->dev,
+				"%d.%s.col_mv_addr[%d]:%02x %02x %02x %02x\n",
+				__LINE__, __func__, i,
+				(u32)(vpu_inst->col_mv_addr[i][0]),
+				(u32)(vpu_inst->col_mv_addr[i][1]),
+				(u32)(vpu_inst->col_mv_addr[i][2]),
+				(u32)(vpu_inst->col_mv_addr[i][3]));
+		}
+	} else {
+		vpu_inst->col_mv_addr[0][0] =
+			(vpu_inst->aux_vbuf[AUX_BUF_MV_COL][0].daddr >> 24) &
+			0xFF;
+		vpu_inst->col_mv_addr[0][1] =
+			(vpu_inst->aux_vbuf[AUX_BUF_MV_COL][0].daddr >> 16) &
+			0xFF;
+		vpu_inst->col_mv_addr[0][2] =
+			(vpu_inst->aux_vbuf[AUX_BUF_MV_COL][0].daddr >> 8) &
+			0xFF;
+		vpu_inst->col_mv_addr[0][3] =
+			(vpu_inst->aux_vbuf[AUX_BUF_MV_COL][0].daddr >> 0) &
+			0xFF;
+	}
+	ret = coda_vdi_write_memory(vpu_inst->dev, &vpu_inst->dev->common_mem,
+				    CODE_BUF_SIZE + TEMP_BUF_SIZE + 384,
+				    (u8 *)vpu_inst->col_mv_addr,
+				    sizeof(vpu_inst->col_mv_addr),
+				    VDI_BIG_ENDIAN);
+	if (ret <= 0)
+		return ret;
+
+	for (i = 0; i < count; i++) {
+		vpu_inst->frame_addr[i][0][0] =
+			(fb_arr[i].buf_y_bot >> 24) & 0xFF;
+		vpu_inst->frame_addr[i][0][1] =
+			(fb_arr[i].buf_y_bot >> 16) & 0xFF;
+		vpu_inst->frame_addr[i][0][2] =
+			(fb_arr[i].buf_y_bot >> 8) & 0xFF;
+		vpu_inst->frame_addr[i][0][3] =
+			(fb_arr[i].buf_y_bot >> 0) & 0xFF;
+
+		vpu_inst->frame_addr[i][1][0] =
+			(fb_arr[i].buf_cb_bot >> 24) & 0xFF;
+		vpu_inst->frame_addr[i][1][1] =
+			(fb_arr[i].buf_cb_bot >> 16) & 0xFF;
+		vpu_inst->frame_addr[i][1][2] =
+			(fb_arr[i].buf_cb_bot >> 8) & 0xFF;
+		vpu_inst->frame_addr[i][1][3] =
+			(fb_arr[i].buf_cb_bot >> 0) & 0xFF;
+		vpu_inst->frame_addr[i][2][0] =
+			(fb_arr[i].buf_cr_bot >> 24) & 0xFF;
+		vpu_inst->frame_addr[i][2][1] =
+			(fb_arr[i].buf_cr_bot >> 16) & 0xFF;
+		vpu_inst->frame_addr[i][2][2] =
+			(fb_arr[i].buf_cr_bot >> 8) & 0xFF;
+		vpu_inst->frame_addr[i][2][3] =
+			(fb_arr[i].buf_cr_bot >> 0) & 0xFF;
+	}
+	ret = coda_vdi_write_memory(vpu_inst->dev, &vpu_inst->dev->common_mem,
+				    CODE_BUF_SIZE + TEMP_BUF_SIZE + 384 + 128,
+				    (u8 *)vpu_inst->frame_addr,
+				    sizeof(vpu_inst->frame_addr),
+				    VDI_BIG_ENDIAN);
+	if (ret <= 0)
+		return ret;
+
+	coda_config_sec_axi(vpu_inst, p_dec_info->open_param.codec_mode,
+			    &p_dec_info->sec_axi_info, p_dec_info->stride,
+			    p_dec_info->framebuf_height,
+			    p_dec_info->initial_info.profile & 0xff);
+	vpu_write_reg(dev, CMD_SET_FRAME_BUF_NUM, count);
+	vpu_write_reg(dev, CMD_SET_FRAME_BUF_STRIDE, p_dec_info->stride);
+	vpu_write_reg(dev, CMD_SET_FRAME_AXI_BIT_ADDR,
+		      p_dec_info->sec_axi_info.buf_bit_use);
+	vpu_write_reg(dev, CMD_SET_FRAME_AXI_IPACDC_ADDR,
+		      p_dec_info->sec_axi_info.buf_ip_acdc_use);
+	vpu_write_reg(dev, CMD_SET_FRAME_AXI_DBKY_ADDR,
+		      p_dec_info->sec_axi_info.buf_dbk_y_use);
+	vpu_write_reg(dev, CMD_SET_FRAME_AXI_DBKC_ADDR,
+		      p_dec_info->sec_axi_info.buf_dbk_c_use);
+	vpu_write_reg(dev, CMD_SET_FRAME_AXI_OVL_ADDR,
+		      p_dec_info->sec_axi_info.buf_ovl_use);
+	vpu_write_reg(dev, CMD_SET_FRAME_AXI_BTP_ADDR,
+		      p_dec_info->sec_axi_info.buf_btp_use);
+	vpu_write_reg(dev, CMD_SET_FRAME_DELAY,
+		      p_dec_info->open_param.frame_delay);
+
+	coda_config_maveric_cache2(vpu_inst, true/*Decoder*/,
+			&p_dec_info->cache_mode,
+			vpu_inst->cbcr_interleave,
+			FRAME_CACHE_BYPASS,
+			FRAME_CACHE_BURST,
+			FRAME_CACHE_MERGE,
+			p_dec_info->open_param.map_type,
+			FRAME_CACHE_WAY_SHAPE
+			);
+	dev_dbg(vpu_inst->dev->dev, "%d.%s.cache_mode:0x%x\n",
+		__LINE__, __func__,
+		p_dec_info->cache_mode);
+	vpu_write_reg(dev, CMD_SET_FRAME_CACHE_CONFIG, p_dec_info->cache_mode);
+
+	if (p_dec_info->open_param.codec_mode == VPX_DEC)
+		vpu_write_reg(dev, CMD_SET_FRAME_MB_BUF_BASE,
+			      vpu_inst->slice_vbuf.daddr);
+	else if (p_dec_info->open_param.codec_mode == AVC_DEC) {
+		vpu_write_reg(dev, CMD_SET_FRAME_SLICE_BB_START,
+			      vpu_inst->slice_vbuf.daddr);
+		vpu_write_reg(dev, CMD_SET_FRAME_SLICE_BB_SIZE,
+			      (vpu_inst->slice_vbuf.size / 1024));
+	}
+
+	val = 0;
+	val |= (p_dec_info->open_param.bwb_enable << 15);
+	val |= (p_dec_info->open_param.wtl_mode << 17) |
+	       (p_dec_info->open_param.tiled2_linear_mode << 13) |
+	       (p_dec_info->open_param.map_type << 9) | (FORMAT_420 << 6);
+
+	vpu_write_reg(dev, BIT_FRAME_MEM_CTRL, val);
+	vpu_write_reg(dev, CMD_SET_FRAME_MAX_DEC_SIZE, 0);
+
+	coda_bit_issue_command(dev, vpu_inst, SET_FRAME_BUF);
+	ret = coda_wait_vpu_busy(dev, BIT_BUSY_FLAG);
+	if (ret)
+		return -ETIMEDOUT;
+
+	val = vpu_read_reg(dev, RET_SET_FRAME_SUCCESS);
+	if (val & (1UL << 31)) {
+		dev_err(vpu_inst->dev->dev,
+			"%s:%d failed to set the SET_FRAME_BUF command (%08X)\n",
+			__FUNCTION__, __LINE__, val);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+/*
+int coda_vpu_get_version(struct vpu_device *vpu_dev, uint32_t *version, uint32 *revision)
+{
+	vpu_write_reg(vpu_dev, RET_FW_VER_NUM , 0);
+
+}
+*/
\ No newline at end of file
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-regdefine.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-regdefine.h
@@ -0,0 +1,443 @@
+/* SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause) */
+/*
+ * Coda series multi-standard codec IP - Coda register definitions
+ *
+ * Copyright (C) 2024 CHIPS&MEDIA INC
+ */
+
+#ifndef __CODA_REGISTER_DEFINE_H
+#define __CODA_REGISTER_DEFINE_H
+
+/************************************************************************/
+/* COMMON REGISTERS                                                     */
+/************************************************************************/
+#define VPU_PRODUCT_NAME_REGISTER 0x1040
+#define VPU_PRODUCT_CODE_REGISTER 0x1044
+
+#define BIT_BASE 0x0000
+#define BIT_CODE_RUN (BIT_BASE + 0x000)
+#define BIT_CODE_DOWN (BIT_BASE + 0x004)
+#define BIT_INT_CLEAR (BIT_BASE + 0x00C)
+#define BIT_INT_STS (BIT_BASE + 0x010)
+#define BIT_CODE_RESET (BIT_BASE + 0x014)
+#define BIT_INT_REASON (BIT_BASE + 0x174)
+#define BIT_BUSY_FLAG (BIT_BASE + 0x160)
+#define BIT_RUN_COMMAND (BIT_BASE + 0x164)
+#define BIT_RUN_INDEX (BIT_BASE + 0x168)
+#define BIT_RUN_COD_STD (BIT_BASE + 0x16C)
+
+//------------------------------------------------------------------------------
+// REGISTER BASE
+//------------------------------------------------------------------------------
+#define BIT_BASE 0x0000
+#define GDMA_BASE 0x1000
+#define MBC_BASE 0x0400
+#define ME_BASE 0x0600
+#define MC_BASE 0x0C00
+#define DMAC_BASE 0x2000
+
+#define BW_BASE 0x03000000
+
+//------------------------------------------------------------------------------
+// HARDWARE REGISTER
+//------------------------------------------------------------------------------
+// SW Reset command
+#define VPU_SW_RESET_BPU_CORE 0x008
+#define VPU_SW_RESET_BPU_BUS 0x010
+#define VPU_SW_RESET_VCE_CORE 0x020
+#define VPU_SW_RESET_VCE_BUS 0x040
+#define VPU_SW_RESET_GDI_CORE 0x080
+#define VPU_SW_RESET_GDI_BUS 0x100
+
+#define BIT_INT_REQ (BIT_BASE + 0x008)
+#define BIT_CUR_PC (BIT_BASE + 0x018)
+#define BIT_SW_RESET (BIT_BASE + 0x024)
+#define BIT_SW_RESET_STATUS (BIT_BASE + 0x034)
+
+#define BIT_BUSY_FLAG (BIT_BASE + 0x160)
+#define BIT_RUN_COMMAND (BIT_BASE + 0x164)
+#define BIT_RUN_INDEX (BIT_BASE + 0x168)
+#define BIT_RUN_COD_STD (BIT_BASE + 0x16C)
+#define BIT_INT_ENABLE (BIT_BASE + 0x170)
+#define BIT_INT_REASON (BIT_BASE + 0x174)
+#define BIT_RUN_AUX_STD (BIT_BASE + 0x178)
+
+//------------------------------------------------------------------------------
+// GLOBAL REGISTER
+//------------------------------------------------------------------------------
+#define BIT_CODE_BUF_ADDR (BIT_BASE + 0x100)
+#define BIT_WORK_BUF_ADDR (BIT_BASE + 0x104)
+#define BIT_PARA_BUF_ADDR (BIT_BASE + 0x108)
+#define BIT_BIT_STREAM_CTRL (BIT_BASE + 0x10C)
+#define BIT_FRAME_MEM_CTRL (BIT_BASE + 0x110)
+#define BIT_BIT_STREAM_PARAM (BIT_BASE + 0x114)
+#define BIT_TEMP_BUF_ADDR (BIT_BASE + 0x118)
+
+#define BIT_RD_PTR (BIT_BASE + 0x120)
+#define BIT_WR_PTR (BIT_BASE + 0x124)
+
+#define BIT_ROLLBACK_STATUS (BIT_BASE + 0x128)
+
+#define BIT_AXI_SRAM_USE (BIT_BASE + 0x140)
+#define BIT_BYTE_POS_FRAME_START (BIT_BASE + 0x144)
+#define BIT_BYTE_POS_FRAME_END (BIT_BASE + 0x148)
+#define BIT_FRAME_CYCLE (BIT_BASE + 0x14C)
+
+#define BIT_FRM_DIS_FLG (BIT_BASE + 0x150)
+
+//------------------------------------------------------------------------------
+// [DEC SET FRAME BUF] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_SET_FRAME_BUF_NUM (BIT_BASE + 0x180)
+#define CMD_SET_FRAME_BUF_STRIDE (BIT_BASE + 0x184)
+
+#define CMD_SET_FRAME_SLICE_BB_START (BIT_BASE + 0x188)
+#define CMD_SET_FRAME_SLICE_BB_SIZE (BIT_BASE + 0x18C)
+#define CMD_SET_FRAME_AXI_BIT_ADDR (BIT_BASE + 0x190)
+#define CMD_SET_FRAME_AXI_IPACDC_ADDR (BIT_BASE + 0x194)
+#define CMD_SET_FRAME_AXI_DBKY_ADDR (BIT_BASE + 0x198)
+#define CMD_SET_FRAME_AXI_DBKC_ADDR (BIT_BASE + 0x19C)
+#define CMD_SET_FRAME_AXI_OVL_ADDR (BIT_BASE + 0x1A0)
+#define CMD_SET_FRAME_AXI_BTP_ADDR (BIT_BASE + 0x1A4)
+
+#define CMD_SET_FRAME_CACHE_SIZE (BIT_BASE + 0x1A8)
+#define CMD_SET_FRAME_CACHE_CONFIG (BIT_BASE + 0x1AC)
+#define CMD_SET_FRAME_MB_BUF_BASE (BIT_BASE + 0x1B0)
+#define CMD_SET_FRAME_MAX_DEC_SIZE (BIT_BASE + 0x1B8)
+#define CMD_SET_FRAME_DELAY (BIT_BASE + 0x1BC)
+
+#define RET_SET_FRAME_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [DEC_PARA_SET] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_DEC_PARA_SET_TYPE (BIT_BASE + 0x180)
+#define CMD_DEC_PARA_SET_SIZE (BIT_BASE + 0x184)
+#define RET_DEC_PARA_SET_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [DEC_BUF_FLUSH] COMMAND
+//------------------------------------------------------------------------------
+#define RET_DEC_BUF_FLUSH_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [SLEEP/WAKE] COMMAND
+//------------------------------------------------------------------------------
+#define RET_SLEEP_WAKE_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [SET PIC INFO] COMMAND
+//------------------------------------------------------------------------------
+#define GDI_PRI_RD_PRIO_L (GDMA_BASE + 0x000)
+#define GDI_PRI_RD_PRIO_H (GDMA_BASE + 0x004)
+#define GDI_PRI_WR_PRIO_L (GDMA_BASE + 0x008)
+#define GDI_PRI_WR_PRIO_H (GDMA_BASE + 0x00c)
+#define GDI_PRI_RD_LOCK_CNT (GDMA_BASE + 0x010)
+#define GDI_PRI_WR_LOCK_CNT (GDMA_BASE + 0x014)
+#define GDI_SEC_RD_PRIO_L (GDMA_BASE + 0x018)
+#define GDI_SEC_RD_PRIO_H (GDMA_BASE + 0x01c)
+#define GDI_SEC_WR_PRIO_L (GDMA_BASE + 0x020)
+#define GDI_SEC_WR_PRIO_H (GDMA_BASE + 0x024)
+#define GDI_SEC_RD_LOCK_CNT (GDMA_BASE + 0x028)
+#define GDI_SEC_WR_LOCK_CNT (GDMA_BASE + 0x02c)
+#define GDI_SEC_CLIENT_EN (GDMA_BASE + 0x030)
+#define GDI_CONTROL (GDMA_BASE + 0x034)
+#define GDI_PIC_INIT_HOST (GDMA_BASE + 0x038)
+
+#define GDI_HW_VERINFO (GDMA_BASE + 0x050)
+#define GDI_PINFO_REQ (GDMA_BASE + 0x060)
+#define GDI_PINFO_ACK (GDMA_BASE + 0x064)
+#define GDI_PINFO_ADDR (GDMA_BASE + 0x068)
+#define GDI_PINFO_DATA (GDMA_BASE + 0x06c)
+#define GDI_BWB_ENABLE (GDMA_BASE + 0x070)
+#define GDI_BWB_SIZE (GDMA_BASE + 0x074)
+#define GDI_BWB_STD_STRUCT (GDMA_BASE + 0x078)
+#define GDI_BWB_STATUS (GDMA_BASE + 0x07c)
+
+#define GDI_STATUS (GDMA_BASE + 0x080)
+
+#define GDI_DEBUG_0 (GDMA_BASE + 0x084)
+#define GDI_DEBUG_1 (GDMA_BASE + 0x088)
+#define GDI_DEBUG_2 (GDMA_BASE + 0x08c)
+#define GDI_DEBUG_3 (GDMA_BASE + 0x090)
+#define GDI_DEBUG_PROBE_ADDR (GDMA_BASE + 0x094)
+#define GDI_DEBUG_PROBE_DATA (GDMA_BASE + 0x098)
+
+// write protect
+#define GDI_WPROT_ERR_CLR (GDMA_BASE + 0x0A0)
+#define GDI_WPROT_ERR_RSN (GDMA_BASE + 0x0A4)
+#define GDI_WPROT_ERR_ADR (GDMA_BASE + 0x0A8)
+#define GDI_WPROT_RGN_EN (GDMA_BASE + 0x0AC)
+#define GDI_WPROT_RGN0_STA (GDMA_BASE + 0x0B0)
+#define GDI_WPROT_RGN0_END (GDMA_BASE + 0x0B4)
+#define GDI_WPROT_RGN1_STA (GDMA_BASE + 0x0B8)
+#define GDI_WPROT_RGN1_END (GDMA_BASE + 0x0BC)
+#define GDI_WPROT_RGN2_STA (GDMA_BASE + 0x0C0)
+#define GDI_WPROT_RGN2_END (GDMA_BASE + 0x0C4)
+#define GDI_WPROT_RGN3_STA (GDMA_BASE + 0x0C8)
+#define GDI_WPROT_RGN3_END (GDMA_BASE + 0x0CC)
+#define GDI_WPROT_RGN4_STA (GDMA_BASE + 0x0D0)
+#define GDI_WPROT_RGN4_END (GDMA_BASE + 0x0D4)
+#define GDI_WPROT_RGN5_STA (GDMA_BASE + 0x0D8)
+#define GDI_WPROT_RGN5_END (GDMA_BASE + 0x0DC)
+#define GDI_WPROT_REGIONS 6
+
+#define GDI_BUS_CTRL (GDMA_BASE + 0x0F0)
+#define GDI_BUS_STATUS (GDMA_BASE + 0x0F4)
+
+#define GDI_SIZE_ERR_FLAG (GDMA_BASE + 0x0e0)
+#define GDI_ADR_RQ_SIZE_ERR_PRI0 (GDMA_BASE + 0x100)
+#define GDI_ADR_RQ_SIZE_ERR_PRI1 (GDMA_BASE + 0x104)
+#define GDI_ADR_RQ_SIZE_ERR_PRI1 (GDMA_BASE + 0x104)
+#define GDI_ADR_RQ_SIZE_ERR_PRI2 (GDMA_BASE + 0x108)
+#define GDI_ADR_WQ_SIZE_ERR_PRI0 (GDMA_BASE + 0x10c)
+#define GDI_ADR_WQ_SIZE_ERR_PRI1 (GDMA_BASE + 0x110)
+#define GDI_ADR_WQ_SIZE_ERR_PRI2 (GDMA_BASE + 0x114)
+
+#define GDI_ADR_RQ_SIZE_ERR_SEC0 (GDMA_BASE + 0x118)
+#define GDI_ADR_RQ_SIZE_ERR_SEC1 (GDMA_BASE + 0x11c)
+#define GDI_ADR_RQ_SIZE_ERR_SEC2 (GDMA_BASE + 0x120)
+
+#define GDI_ADR_WQ_SIZE_ERR_SEC0 (GDMA_BASE + 0x124)
+#define GDI_ADR_WQ_SIZE_ERR_SEC1 (GDMA_BASE + 0x128)
+#define GDI_ADR_WQ_SIZE_ERR_SEC2 (GDMA_BASE + 0x12c)
+
+#define GDI_INFO_CONTROL (GDMA_BASE + 0x400)
+#define GDI_INFO_PIC_SIZE (GDMA_BASE + 0x404)
+// GDI 2.0 register
+#define GDI_INFO_BASE_Y_TOP (GDMA_BASE + 0x408)
+#define GDI_INFO_BASE_CB_TOP (GDMA_BASE + 0x40C)
+#define GDI_INFO_BASE_CR_TOP (GDMA_BASE + 0x410)
+#define GDI_INFO_BASE_Y_BOT (GDMA_BASE + 0x414)
+#define GDI_INFO_BASE_CB_BOT (GDMA_BASE + 0x418)
+#define GDI_INFO_BASE_CR_BOT (GDMA_BASE + 0x41C)
+#define GDI_XY2AXI_LUM_BIT00 (GDMA_BASE + 0x800)
+#define GDI_XY2AXI_LUM_BIT1F (GDMA_BASE + 0x87C)
+#define GDI_XY2AXI_CHR_BIT00 (GDMA_BASE + 0x880)
+#define GDI_XY2AXI_CHR_BIT1F (GDMA_BASE + 0x8FC)
+#define GDI_XY2AXI_CONFIG (GDMA_BASE + 0x900)
+
+//GDI 1.0 register
+#define GDI_INFO_BASE_Y (GDMA_BASE + 0x408)
+#define GDI_INFO_BASE_CB (GDMA_BASE + 0x40C)
+#define GDI_INFO_BASE_CR (GDMA_BASE + 0x410)
+
+#define GDI_XY2_CAS_0 (GDMA_BASE + 0x800)
+#define GDI_XY2_CAS_F (GDMA_BASE + 0x83C)
+
+#define GDI_XY2_BA_0 (GDMA_BASE + 0x840)
+#define GDI_XY2_BA_1 (GDMA_BASE + 0x844)
+#define GDI_XY2_BA_2 (GDMA_BASE + 0x848)
+#define GDI_XY2_BA_3 (GDMA_BASE + 0x84C)
+
+#define GDI_XY2_RAS_0 (GDMA_BASE + 0x850)
+#define GDI_XY2_RAS_F (GDMA_BASE + 0x88C)
+
+#define GDI_XY2_RBC_CONFIG (GDMA_BASE + 0x890)
+#define GDI_RBC2_AXI_0 (GDMA_BASE + 0x8A0)
+#define GDI_RBC2_AXI_1F (GDMA_BASE + 0x91C)
+#define GDI_TILEDBUF_BASE (GDMA_BASE + 0x920)
+
+//------------------------------------------------------------------------------
+// Product, Reconfiguration Information
+//------------------------------------------------------------------------------
+#define DBG_CONFIG_REPORT_0 (GDMA_BASE + 0x040) //product name and version
+#define DBG_CONFIG_REPORT_1                                                    \
+	(GDMA_BASE + 0x044) //interface configuration, hardware definition
+#define DBG_CONFIG_REPORT_2 (GDMA_BASE + 0x048) //standard definition
+#define DBG_CONFIG_REPORT_3 (GDMA_BASE + 0x04C) //standard detail definition
+#define DBG_CONFIG_REPORT_4 (GDMA_BASE + 0x050) //definition in cnm_define
+#define DBG_CONFIG_REPORT_5 (GDMA_BASE + 0x054)
+#define DBG_CONFIG_REPORT_6 (GDMA_BASE + 0x058)
+#define DBG_CONFIG_REPORT_7 (GDMA_BASE + 0x05C)
+
+//------------------------------------------------------------------------------
+// MEMORY COPY MODULE REGISTER
+//------------------------------------------------------------------------------
+#define ADDR_DMAC_PIC_RUN (DMAC_BASE + 0x000)
+#define ADDR_DMAC_PIC_STATUS (DMAC_BASE + 0x004)
+#define ADDR_DMAC_PIC_OP_MODE (DMAC_BASE + 0x008)
+#define ADDR_DMAC_ID (DMAC_BASE + 0x00c) //the result muse be 0x4d435059
+
+#define ADDR_DMAC_SRC_BASE_Y (DMAC_BASE + 0x010)
+#define ADDR_DMAC_SRC_BASE_CB (DMAC_BASE + 0x014)
+#define ADDR_DMAC_SRC_BASE_CR (DMAC_BASE + 0x018)
+#define ADDR_DMAC_SRC_STRIDE (DMAC_BASE + 0x01c)
+
+#define ADDR_DMAC_DST_BASE_Y (DMAC_BASE + 0x020)
+#define ADDR_DMAC_DST_BASE_CB (DMAC_BASE + 0x024)
+#define ADDR_DMAC_DST_BASE_CR (DMAC_BASE + 0x028)
+#define ADDR_DMAC_DST_STRIDE (DMAC_BASE + 0x02c)
+
+#define ADDR_DMAC_SRC_MB_POS_X (DMAC_BASE + 0x030)
+#define ADDR_DMAC_SRC_MB_POS_Y (DMAC_BASE + 0x034)
+#define ADDR_DMAC_SRC_MB_BLK_X (DMAC_BASE + 0x038)
+#define ADDR_DMAC_SRC_MB_BLK_Y (DMAC_BASE + 0x03c)
+
+#define ADDR_DMAC_DST_MB_POS_X (DMAC_BASE + 0x040)
+#define ADDR_DMAC_DST_MB_POS_Y (DMAC_BASE + 0x044)
+#define ADDR_DMAC_DST_MB_BLK_X (DMAC_BASE + 0x048)
+#define ADDR_DMAC_DST_MB_BLK_Y (DMAC_BASE + 0x04c)
+
+#define ADDR_DMAC_SET_COLOR_Y (DMAC_BASE + 0x050)
+#define ADDR_DMAC_SET_COLOR_CB (DMAC_BASE + 0x054)
+#define ADDR_DMAC_SET_COLOR_CR (DMAC_BASE + 0x058)
+
+#define ADDR_DMAC_SUB_SAMPLE_X (DMAC_BASE + 0x060)
+#define ADDR_DMAC_SUB_SAMPLE_Y (DMAC_BASE + 0x064)
+
+//------------------------------------------------------------------------------
+// DMAC
+//------------------------------------------------------------------------------
+#define DMAC_DMAC_RUN (DMAC_BASE + 0x00)
+#define DMAC_SOFT_RESET (DMAC_BASE + 0x04)
+#define DMAC_DMAC_MODE (DMAC_BASE + 0x08)
+#define DMAC_DESC_ADDR (DMAC_BASE + 0x0c)
+#define DMAC_DESC0 (DMAC_BASE + 0x10)
+#define DMAC_DESC1 (DMAC_BASE + 0x14)
+#define DMAC_DESC2 (DMAC_BASE + 0x18)
+#define DMAC_DESC3 (DMAC_BASE + 0x1c)
+#define DMAC_DESC4 (DMAC_BASE + 0x20)
+#define DMAC_DESC5 (DMAC_BASE + 0x24)
+#define DMAC_DESC6 (DMAC_BASE + 0x28)
+#define DMAC_DESC7 (DMAC_BASE + 0x2c)
+
+//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
+// [FIRMWARE VERSION] COMMAND
+// [32:16] project number =>
+// [16:0]  version => xxxx.xxxx.xxxxxxxx
+//------------------------------------------------------------------------------
+#define RET_FW_VER_NUM (BIT_BASE + 0x1c0)
+#define RET_FW_CODE_REV (BIT_BASE + 0x1c4)
+
+// for debugging
+#define BIT_MSG_0 (BIT_BASE + 0x130)
+#define BIT_MSG_1 (BIT_BASE + 0x134)
+#define BIT_MSG_2 (BIT_BASE + 0x138)
+#define BIT_MSG_3 (BIT_BASE + 0x13C)
+
+//------------------------------------------------------------------------------
+// [DEC SEQ INIT] COMMAND
+//------------------------------------------------------------------------------
+#define CMD_DEC_SEQ_BB_START (BIT_BASE + 0x180)
+#define CMD_DEC_SEQ_BB_SIZE (BIT_BASE + 0x184)
+#define CMD_DEC_SEQ_OPTION (BIT_BASE + 0x188)
+
+#define CMD_DEC_SEQ_MP4_ASP_CLASS (BIT_BASE + 0x19C)
+#define CMD_DEC_SEQ_VC1_STREAM_FMT (BIT_BASE + 0x19C)
+#define CMD_DEC_SEQ_X264_MV_EN (BIT_BASE + 0x19C)
+#define CMD_DEC_SEQ_SPP_CHUNK_SIZE (BIT_BASE + 0x1A0)
+
+// For MPEG2 only
+#define CMD_DEC_SEQ_USER_DATA_OPTION (BIT_BASE + 0x194)
+#define CMD_DEC_SEQ_USER_DATA_BASE_ADDR (BIT_BASE + 0x1AC)
+#define CMD_DEC_SEQ_USER_DATA_BUF_SIZE (BIT_BASE + 0x1B0)
+
+#define CMD_DEC_SEQ_INIT_ESCAPE (BIT_BASE + 0x114)
+
+#define RET_DEC_SEQ_BIT_RATE (BIT_BASE + 0x1B4)
+#define RET_DEC_SEQ_EXT_INFO (BIT_BASE + 0x1B8)
+#define RET_DEC_SEQ_SUCCESS (BIT_BASE + 0x1C0)
+#define RET_DEC_SEQ_SRC_SIZE (BIT_BASE + 0x1C4)
+
+#define RET_DEC_SEQ_ASPECT (BIT_BASE + 0x1C8)
+#define RET_DEC_SEQ_FRAME_NEED (BIT_BASE + 0x1CC)
+#define RET_DEC_SEQ_FRAME_DELAY (BIT_BASE + 0x1D0)
+#define RET_DEC_SEQ_INFO (BIT_BASE + 0x1D4)
+#define RET_DEC_SEQ_VP8_SCALE_INFO (BIT_BASE + 0x1D4)
+
+#define RET_DEC_SEQ_CROP_LEFT_RIGHT (BIT_BASE + 0x1D8)
+#define RET_DEC_SEQ_CROP_TOP_BOTTOM (BIT_BASE + 0x1DC)
+#define RET_DEC_SEQ_SEQ_ERR_REASON (BIT_BASE + 0x1E0)
+
+#define RET_DEC_SEQ_FRATE_NR (BIT_BASE + 0x1E4)
+#define RET_DEC_SEQ_FRATE_DR (BIT_BASE + 0x1E8)
+#define RET_DEC_SEQ_HEADER_REPORT (BIT_BASE + 0x1EC)
+#define RET_DEC_SEQ_VUI_INFO (BIT_BASE + 0x18C)
+#define RET_DEC_SEQ_VUI_INFO_2 (BIT_BASE + 0x17C)
+#define RET_DEC_SEQ_VUI_PIC_STRUCT (BIT_BASE + 0x1A8)
+
+#define RET_DEC_SEQ_MP2_BAR_LEFT_RIGHT (BIT_BASE + 0x180)
+#define RET_DEC_SEQ_MP2_BAR_TOP_BOTTOM (BIT_BASE + 0x184)
+
+#define RET_DEC_PIC_MP2_OFFSET1 (BIT_BASE + 0x19C) // for MP2
+#define RET_DEC_PIC_MP2_OFFSET2 (BIT_BASE + 0x1A0) // for MP2
+#define RET_DEC_PIC_MP2_OFFSET3 (BIT_BASE + 0x1A4) // for MP2
+#define RET_DEC_PIC_MP2_OFFSET_NUM (BIT_BASE + 0x1A8) // for MP2
+
+//------------------------------------------------------------------------------
+// [DEC SEQ END] COMMAND
+//------------------------------------------------------------------------------
+#define RET_DEC_SEQ_END_SUCCESS (BIT_BASE + 0x1C0)
+
+//------------------------------------------------------------------------------
+// [DEC PIC RUN] COMMAND
+//----------------------------------------------------
+#define CMD_DEC_PIC_ROT_MODE (BIT_BASE + 0x180)
+#define CMD_DEC_PIC_ROT_INDEX (BIT_BASE + 0x184)
+#define CMD_DEC_PIC_ROT_ADDR_Y (BIT_BASE + 0x188)
+#define CMD_DEC_PIC_ROT_ADDR_CB (BIT_BASE + 0x18C)
+#define CMD_DEC_PIC_ROT_ADDR_CR (BIT_BASE + 0x190)
+#define CMD_DEC_PIC_ROT_STRIDE (BIT_BASE + 0x1B8)
+#define CMD_DEC_PIC_OPTION (BIT_BASE + 0x194)
+
+#define CMD_DEC_PIC_ROT_BOTTOM_Y (BIT_BASE + 0x1E8) // coda980 only
+#define CMD_DEC_PIC_ROT_BOTTOM_CB (BIT_BASE + 0x1EC) // coda980 only
+#define CMD_DEC_PIC_ROT_BOTTOM_CR (BIT_BASE + 0x1F0) // coda980 only
+
+#define CMD_DEC_PIC_OPTION (BIT_BASE + 0x194)
+
+#define CMD_DEC_PIC_STATELESS_LINEAR_ADDR_Y (BIT_BASE + 0x19C)
+#define CMD_DEC_PIC_STATELESS_LINEAR_ADDR_CB (BIT_BASE + 0x1A0)
+#define CMD_DEC_PIC_STATELESS_LINEAR_ADDR_CR (BIT_BASE + 0x1A4)
+
+#define CMD_DEC_PIC_USER_DATA_BASE_ADDR (BIT_BASE + 0x1AC)
+#define CMD_DEC_PIC_USER_DATA_BUF_SIZE (BIT_BASE + 0x1B0)
+
+#define CMD_DEC_PIC_NUM_ROWS (BIT_BASE + 0x1B4)
+#define CMD_DEC_PIC_THO_PIC_PARA (BIT_BASE + 0x198)
+#define CMD_DEC_PIC_THO_QMAT_ADDR (BIT_BASE + 0x1A0)
+#define CMD_DEC_PIC_THO_MB_PARA_ADDR (BIT_BASE + 0x1A4)
+#define RET_DEC_PIC_VUI_PIC_STRUCT (BIT_BASE + 0x1A8)
+#define RET_DEC_PIC_AVC_FPA_SEI0 (BIT_BASE + 0x19C)
+#define RET_DEC_PIC_AVC_FPA_SEI1 (BIT_BASE + 0x1A0)
+#define RET_DEC_PIC_AVC_FPA_SEI2 (BIT_BASE + 0x1A4)
+#define RET_DEC_NUM_MB_ROWS (BIT_BASE + 0x1B4) // it will be update
+#define RET_DEC_PIC_AVC_SEI_RP_INFO (BIT_BASE + 0x1B4)
+#define RET_DEC_PIC_HRD_INFO (BIT_BASE + 0x1B8)
+#define RET_DEC_PIC_SIZE (BIT_BASE + 0x1BC)
+#define RET_DEC_PIC_FRAME_NUM (BIT_BASE + 0x1C0)
+#define RET_DEC_PIC_FRAME_IDX (BIT_BASE + 0x1C4)
+#define RET_DEC_PIC_DISPLAY_IDX (BIT_BASE + 0x1C4)
+#define RET_DEC_PIC_ERR_MB (BIT_BASE + 0x1C8)
+#define RET_DEC_PIC_TYPE (BIT_BASE + 0x1CC)
+#define RET_DEC_PIC_POST (BIT_BASE + 0x1D0) // for VC1
+#define RET_DEC_PIC_MVC_REPORT (BIT_BASE + 0x1D0) // for MVC
+#define RET_DEC_PIC_OPTION (BIT_BASE + 0x1D4)
+#define RET_DEC_PIC_SUCCESS (BIT_BASE + 0x1D8)
+#define RET_DEC_PIC_CUR_IDX (BIT_BASE + 0x1DC)
+#define RET_DEC_PIC_DECODED_IDX (BIT_BASE + 0x1DC)
+#define RET_DEC_PIC_CROP_LEFT_RIGHT (BIT_BASE + 0x1E0) // for AVC, MPEG-2
+#define RET_DEC_PIC_CROP_TOP_BOTTOM (BIT_BASE + 0x1E4) // for AVC, MPEG-2
+#define RET_DEC_PIC_MODULO_TIME_BASE (BIT_BASE + 0x1E0) // for MP4
+#define RET_DEC_PIC_VOP_TIME_INCREMENT (BIT_BASE + 0x1E4) // for MP4
+#define RET_DEC_PIC_RV_TR (BIT_BASE + 0x1E8)
+#define RET_DEC_PIC_VP8_PIC_REPORT (BIT_BASE + 0x1E8)
+#define RET_DEC_PIC_ATSC_USER_DATA_INFO (BIT_BASE + 0x1E8) // H.264, MEPEG2
+#define RET_DEC_PIC_VUI_INFO_2 (BIT_BASE + 0x17C) // H.264, MPEG2
+#define RET_DEC_PIC_VUI_INFO (BIT_BASE + 0x1EC)
+#define RET_DEC_PIC_RV_TR_BFRAME (BIT_BASE + 0x1EC)
+#define RET_DEC_PIC_ASPECT (BIT_BASE + 0x1F0)
+#define RET_DEC_PIC_VP8_SCALE_INFO (BIT_BASE + 0x1F0)
+#define RET_DEC_PIC_FRATE_NR (BIT_BASE + 0x1F4)
+#define RET_DEC_PIC_FRATE_DR (BIT_BASE + 0x1F8)
+#define RET_DEC_PIC_POC_TOP (BIT_BASE + 0x1AC)
+#define RET_DEC_PIC_POC_BOT (BIT_BASE + 0x1B0)
+#define RET_DEC_PIC_POC (BIT_BASE + 0x1B0)
+
+#define RET_DEC_STATELESS_LINEAR_ADDR_Y (BIT_BASE + 0x190)
+#define RET_DEC_STATELESS_LINEAR_ADDR_CB (BIT_BASE + 0x194)
+#define RET_DEC_STATELESS_LINEAR_ADDR_CR (BIT_BASE + 0x198)
+
+#endif
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-stateless-vpu-dec.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-stateless-vpu-dec.c
@@ -0,0 +1,2135 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Coda980 series multi-standard codec IP - decoder interface
+ *
+ * Copyright (C) 2024 CHIPS&MEDIA INC
+ */
+#include "coda-vpu.h"
+#include "coda.h"
+
+#define MAX_CTRL_LIST 3
+
+//#define DEBUG_STATELESS
+#define LINEAR_FRAME_MAP_TYPE
+
+struct stateless_info {
+	struct vb2_v4l2_buffer *src;
+	struct vb2_v4l2_buffer *dst;
+	union {
+		struct stateless_mpeg2_info mpeg2;
+		struct stateless_vp8_info vp8;
+		struct stateless_h264_info h264;
+	};
+};
+
+struct sl_ctrl_desc {
+	struct v4l2_ctrl_config cfg;
+};
+
+struct sl_ctrls {
+	const struct sl_ctrl_desc *ctrls;
+	unsigned int num_ctrls;
+};
+
+static const struct sl_ctrl_desc sl_mpeg2_ctrl_descs[] = {
+	{
+		.cfg.id = V4L2_CID_STATELESS_MPEG2_SEQUENCE,
+	},
+	{
+		.cfg.id = V4L2_CID_STATELESS_MPEG2_PICTURE,
+	},
+	{
+		.cfg.id = V4L2_CID_STATELESS_MPEG2_QUANTISATION,
+	},
+};
+
+static const struct sl_ctrls sl_mpeg2_ctrls = {
+	.ctrls = sl_mpeg2_ctrl_descs,
+	.num_ctrls = ARRAY_SIZE(sl_mpeg2_ctrl_descs),
+};
+
+static const struct sl_ctrl_desc sl_vp8_ctrl_descs[] = {
+	{
+		.cfg.id = V4L2_CID_STATELESS_VP8_FRAME,
+	},
+};
+
+static const struct sl_ctrls sl_vp8_ctrls = {
+	.ctrls = sl_vp8_ctrl_descs,
+	.num_ctrls = ARRAY_SIZE(sl_vp8_ctrl_descs),
+};
+
+static const struct sl_ctrl_desc sl_h264_ctrl_descs[] = {
+	{
+		.cfg.id = V4L2_CID_STATELESS_H264_DECODE_PARAMS,
+	},
+	{
+		.cfg.id = V4L2_CID_STATELESS_H264_SPS,
+	},
+	{
+		.cfg.id = V4L2_CID_STATELESS_H264_PPS,
+	},
+	{
+		.cfg.id = V4L2_CID_STATELESS_H264_SCALING_MATRIX,
+	},
+	{
+		.cfg.id = V4L2_CID_STATELESS_H264_DECODE_MODE,
+		.cfg.min = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,
+		.cfg.def = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,
+		.cfg.max = V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED,
+	},
+	{
+		.cfg.id = V4L2_CID_STATELESS_H264_START_CODE,
+		.cfg.min = V4L2_STATELESS_H264_START_CODE_ANNEX_B,
+		.cfg.def = V4L2_STATELESS_H264_START_CODE_ANNEX_B,
+		.cfg.max = V4L2_STATELESS_H264_START_CODE_ANNEX_B,
+	},
+	{
+		.cfg.id = V4L2_CID_STATELESS_H264_SLICE_PARAMS,
+	},
+	{
+		.cfg.id = V4L2_CID_STATELESS_H264_PRED_WEIGHTS,
+	},
+};
+
+static const struct sl_ctrls sl_h264_ctrls = {
+	.ctrls = sl_h264_ctrl_descs,
+	.num_ctrls = ARRAY_SIZE(sl_h264_ctrl_descs),
+};
+
+static const struct sl_ctrls *sl_ctrls_list[MAX_CTRL_LIST] = {
+	&sl_mpeg2_ctrls,
+	&sl_vp8_ctrls,
+	&sl_h264_ctrls,
+};
+
+static const struct vpu_format coda980_vpu_dec_fmt_list[3][6] = {
+	[VPU_FMT_TYPE_CODEC] = {
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_MPEG2_SLICE,
+			.max_width = MPEG2_MAX_DEC_PIC_WIDTH,
+			.min_width = MPEG2_MIN_DEC_PIC_WIDTH,
+			.max_height = MPEG2_MAX_DEC_PIC_HEIGHT,
+			.min_height = MPEG2_MIN_DEC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_VP8_FRAME,
+			.max_width = VP8_MAX_DEC_PIC_WIDTH,
+			.min_width = VP8_MIN_DEC_PIC_WIDTH,
+			.max_height = VP8_MAX_DEC_PIC_HEIGHT,
+			.min_height = VP8_MIN_DEC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_H264_SLICE,
+			.max_width = AVC_MAX_DEC_PIC_WIDTH,
+			.min_width = AVC_MIN_DEC_PIC_WIDTH,
+			.max_height = AVC_MAX_DEC_PIC_HEIGHT,
+			.min_height = AVC_MIN_DEC_PIC_HEIGHT,
+			.num_planes = 1,
+		},		
+	},
+	[VPU_FMT_TYPE_RAW] = {
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_YUV420,
+			.max_width = RAW_MAX_DEC_PIC_WIDTH,
+			.min_width = RAW_MIN_DEC_PIC_WIDTH,
+			.max_height = RAW_MAX_DEC_PIC_HEIGHT,
+			.min_height = RAW_MIN_DEC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_NV12,
+			.max_width = RAW_MAX_DEC_PIC_WIDTH,
+			.min_width = RAW_MIN_DEC_PIC_WIDTH,
+			.max_height = RAW_MAX_DEC_PIC_HEIGHT,
+			.min_height = RAW_MIN_DEC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_NV21,
+			.max_width = RAW_MAX_DEC_PIC_WIDTH,
+			.min_width = RAW_MIN_DEC_PIC_WIDTH,
+			.max_height = RAW_MAX_DEC_PIC_HEIGHT,
+			.min_height = RAW_MIN_DEC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_YUV420M,
+			.max_width = RAW_MAX_DEC_PIC_WIDTH,
+			.min_width = RAW_MIN_DEC_PIC_WIDTH,
+			.max_height = RAW_MAX_DEC_PIC_HEIGHT,
+			.min_height = RAW_MIN_DEC_PIC_HEIGHT,
+			.num_planes = 3,
+		},
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_NV12M,
+			.max_width = RAW_MAX_DEC_PIC_WIDTH,
+			.min_width = RAW_MIN_DEC_PIC_WIDTH,
+			.max_height = RAW_MAX_DEC_PIC_HEIGHT,
+			.min_height = RAW_MIN_DEC_PIC_HEIGHT,
+			.num_planes = 2,
+		},
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_NV21M,
+			.max_width = RAW_MAX_DEC_PIC_WIDTH,
+			.min_width = RAW_MIN_DEC_PIC_WIDTH,
+			.max_height = RAW_MAX_DEC_PIC_HEIGHT,
+			.min_height = RAW_MIN_DEC_PIC_HEIGHT,
+			.num_planes = 2,
+		},
+	}
+};
+
+static void coda_vpu_dec_destroy_instance(struct vpu_instance *inst);
+
+static struct v4l2_ctrl *stateless_find_control(struct vpu_instance *inst,
+						u32 id)
+{
+	struct v4l2_ctrl_handler *hdl = &inst->v4l2_ctrl_hdl;
+
+	return v4l2_ctrl_find(hdl, id);
+}
+
+static void *stateless_find_control_data(struct vpu_instance *inst, u32 id)
+{
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = stateless_find_control(inst, id);
+	if (ctrl)
+		return ctrl->p_cur.p;
+
+	return NULL;
+}
+
+/*static u32 stateless_control_num_elems(struct vpu_instance *inst, u32 id)
+{
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = stateless_find_control(inst, id);
+	if (ctrl)
+		return ctrl->elems;
+
+	return 0;
+}*/
+
+static enum cod_std coda_to_vpu_codstd(unsigned int v4l2_pix_fmt)
+{
+	switch (v4l2_pix_fmt) {
+	case V4L2_PIX_FMT_H264_SLICE:
+		return STD_AVC;
+	case V4L2_PIX_FMT_VP8_FRAME:
+		return STD_VP8;
+	case V4L2_PIX_FMT_MPEG2_SLICE:
+		return STD_MPEG2;
+	default:
+		return STD_MAX;
+	}
+}
+
+static const struct vpu_format *coda_find_vpu_fmt(unsigned int v4l2_pix_fmt,
+						  enum vpu_fmt_type type)
+{
+	unsigned int index;
+
+	for (index = 0; index < ARRAY_SIZE(coda980_vpu_dec_fmt_list[type]);
+	     index++) {
+		if (coda980_vpu_dec_fmt_list[type][index].v4l2_pix_fmt ==
+		    v4l2_pix_fmt)
+			return &coda980_vpu_dec_fmt_list[type][index];
+	}
+
+	return NULL;
+}
+
+static const struct vpu_format *coda_find_vpu_fmt_by_idx(unsigned int idx,
+							 enum vpu_fmt_type type)
+{
+	if (idx >= ARRAY_SIZE(coda980_vpu_dec_fmt_list[type]))
+		return NULL;
+
+	if (!coda980_vpu_dec_fmt_list[type][idx].v4l2_pix_fmt)
+		return NULL;
+
+	return &coda980_vpu_dec_fmt_list[type][idx];
+}
+
+static void coda_update_pix_fmt(struct v4l2_pix_format_mplane *pix_mp,
+				unsigned int width, unsigned int height)
+{
+	pix_mp->flags = 0;
+	pix_mp->field = V4L2_FIELD_NONE;
+	memset(pix_mp->reserved, 0, sizeof(pix_mp->reserved));
+
+	switch (pix_mp->pixelformat) {
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+		pix_mp->width = round_up(width, 32);
+		pix_mp->height = round_up(height, 32);
+		pix_mp->plane_fmt[0].bytesperline = pix_mp->width;
+		pix_mp->plane_fmt[0].sizeimage =
+			pix_mp->width * pix_mp->height * 3 / 2;
+		break;
+	case V4L2_PIX_FMT_YUV420M:
+		pix_mp->width = round_up(width, 32);
+		pix_mp->height = round_up(height, 32);
+		pix_mp->plane_fmt[0].bytesperline = pix_mp->width;
+		pix_mp->plane_fmt[0].sizeimage = pix_mp->width * pix_mp->height;
+		pix_mp->plane_fmt[1].bytesperline = pix_mp->width / 2;
+		pix_mp->plane_fmt[1].sizeimage =
+			pix_mp->width * pix_mp->height / 4;
+		pix_mp->plane_fmt[2].bytesperline = pix_mp->width / 2;
+		pix_mp->plane_fmt[2].sizeimage =
+			pix_mp->width * pix_mp->height / 4;
+		break;
+	case V4L2_PIX_FMT_NV12M:
+	case V4L2_PIX_FMT_NV21M:
+		pix_mp->width = round_up(width, 32);
+		pix_mp->height = round_up(height, 32);
+		pix_mp->plane_fmt[0].bytesperline = pix_mp->width;
+		pix_mp->plane_fmt[0].sizeimage = pix_mp->width * pix_mp->height;
+		pix_mp->plane_fmt[1].bytesperline = pix_mp->width;
+		pix_mp->plane_fmt[1].sizeimage =
+			pix_mp->width * pix_mp->height / 2;
+		break;
+	default:
+		pix_mp->width = width;
+		pix_mp->height = height;
+		pix_mp->plane_fmt[0].bytesperline = 0;
+		if (!pix_mp->plane_fmt[0].sizeimage)
+			pix_mp->plane_fmt[0].sizeimage = width * height;
+		break;
+	}
+}
+
+static int coda_vpu_dec_give_command(struct vpu_instance *inst,
+				     enum codec_command cmd, void *param)
+{
+	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
+	int ret = 0;
+
+	switch (cmd) {
+	case DEC_SET_STATELESS_WIDTH:
+		p_dec_info->pic_width = *((int *)param);
+		break;
+	case DEC_SET_STATELESS_HEGIHT:
+		p_dec_info->pic_height = *((int *)param);
+		break;
+	case DEC_SET_STATELESS_NUM_FRAMES:
+		p_dec_info->pic_num = *((int *)param);
+		break;
+	case DEC_SET_STATELESS_PROFILE:
+		p_dec_info->profile = *((int *)param);
+		break;
+	case DEC_RESET_FRAMEBUF_INFO: {
+		int i = 0;
+		for (i = 0; i < CODA_MAX_FBS; i++) {
+			coda_vdi_free_dma_memory(inst->dev,
+						 &inst->frame_vbuf[i]);
+			memset(&inst->frame_buf[i], 0,
+			       sizeof(struct frame_buffer));
+
+			dev_dbg(inst->dev->dev,
+				"%d.%s.free.#%02d.mvcolbuf.size:%ld.daddr:0x%llx.vaddr:0x%px\n",
+				__LINE__, __func__, i,
+				inst->aux_vbuf[AUX_BUF_MV_COL][i].size,
+				inst->aux_vbuf[AUX_BUF_MV_COL][i].daddr,
+				inst->aux_vbuf[AUX_BUF_MV_COL][i].vaddr);
+			coda_vdi_free_dma_memory(
+				inst->dev, &inst->aux_vbuf[AUX_BUF_MV_COL][i]);
+		}
+		coda_vdi_free_dma_memory(inst->dev, &inst->slice_vbuf);
+		break;
+	}
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static void coda_vpu_dec_buf_queue_src(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct vpu_instance *inst = vb2_get_drv_priv(vb->vb2_queue);
+
+	dev_dbg(inst->dev->dev,
+		"type %4d index %4d size[0] %4ld size[1] : %4ld | size[2] : %4ld\n",
+		vb->type, vb->index, vb2_plane_size(&vbuf->vb2_buf, 0),
+		vb2_plane_size(&vbuf->vb2_buf, 1),
+		vb2_plane_size(&vbuf->vb2_buf, 2));
+
+	vbuf->sequence = inst->queued_src_buf_num++;
+
+	v4l2_m2m_buf_queue(inst->v4l2_fh.m2m_ctx, vbuf);
+}
+
+static void coda_vpu_dec_buf_queue_dst(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct vpu_instance *inst = vb2_get_drv_priv(vb->vb2_queue);
+
+	dev_dbg(inst->dev->dev,
+		"type %4d index %4d size[0] %4ld size[1] : %4ld | size[2] : %4ld\n",
+		vb->type, vb->index, vb2_plane_size(&vbuf->vb2_buf, 0),
+		vb2_plane_size(&vbuf->vb2_buf, 1),
+		vb2_plane_size(&vbuf->vb2_buf, 2));
+
+	vbuf->sequence = inst->queued_dst_buf_num++;
+	v4l2_m2m_buf_queue(inst->v4l2_fh.m2m_ctx, vbuf);
+}
+
+static void coda_vpu_dec_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct vpu_buffer *vpu_buf = coda_to_vpu_buf(vbuf);
+
+	vpu_buf->consumed = false;
+	if (V4L2_TYPE_IS_OUTPUT(vb->type))
+		coda_vpu_dec_buf_queue_src(vb);
+	else
+		coda_vpu_dec_buf_queue_dst(vb);
+}
+
+static int coda_vpu_dec_queue_setup(struct vb2_queue *q,
+				    unsigned int *num_buffers,
+				    unsigned int *num_planes,
+				    unsigned int sizes[],
+				    struct device *alloc_devs[])
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(q);
+	struct v4l2_pix_format_mplane inst_format =
+		(V4L2_TYPE_IS_OUTPUT(q->type)) ? inst->src_fmt : inst->dst_fmt;
+	unsigned int i;
+
+	dev_dbg(inst->dev->dev, "%s: num_buffers %d num_planes %d type %d\n",
+		__func__, *num_buffers, *num_planes, q->type);
+
+	if (*num_planes) {
+		if (inst_format.num_planes != *num_planes)
+			return -EINVAL;
+
+		for (i = 0; i < *num_planes; i++) {
+			if (sizes[i] < inst_format.plane_fmt[i].sizeimage)
+				return -EINVAL;
+		}
+	} else {
+		*num_planes = inst_format.num_planes;
+		for (i = 0; i < *num_planes; i++) {
+			sizes[i] = inst_format.plane_fmt[i].sizeimage;
+			dev_dbg(inst->dev->dev, "size[%d] : %d\n", i, sizes[i]);
+		}
+	}
+
+	return 0;
+}
+
+static int coda_vpu_dec_buf_out_validate(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+
+	vbuf->field = V4L2_FIELD_NONE;
+	return 0;
+}
+
+static int coda_vpu_dec_buf_prepare(struct vb2_buffer *vb)
+{
+	return 0;
+}
+
+static int coda_vpu_dec_querycap(struct file *file, void *fh,
+				 struct v4l2_capability *cap)
+{
+	strscpy(cap->driver, VPU_DEC_DRV_NAME, sizeof(cap->driver));
+	strscpy(cap->card, VPU_DEC_DRV_NAME, sizeof(cap->card));
+	strscpy(cap->bus_info, "platform:" VPU_DEC_DRV_NAME,
+		sizeof(cap->bus_info));
+
+	return 0;
+}
+
+static int coda_vpu_dec_enum_framesizes(struct file *f, void *fh,
+					struct v4l2_frmsizeenum *fsize)
+{
+	const struct vpu_format *vpu_fmt;
+
+	if (fsize->index)
+		return -EINVAL;
+
+	vpu_fmt = coda_find_vpu_fmt(fsize->pixel_format, VPU_FMT_TYPE_CODEC);
+	if (!vpu_fmt) {
+		vpu_fmt = coda_find_vpu_fmt(fsize->pixel_format,
+					    VPU_FMT_TYPE_RAW);
+		if (!vpu_fmt)
+			return -EINVAL;
+	}
+
+	fsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;
+	fsize->stepwise.min_width = vpu_fmt->min_width;
+	fsize->stepwise.max_width = vpu_fmt->max_width;
+	fsize->stepwise.step_width = CODA_DEC_PIC_SIZE_STEP;
+	fsize->stepwise.min_height = vpu_fmt->min_height;
+	fsize->stepwise.max_height = vpu_fmt->max_height;
+	fsize->stepwise.step_height = CODA_DEC_PIC_SIZE_STEP;
+
+	return 0;
+}
+
+static int coda_vpu_dec_enum_fmt_cap(struct file *file, void *fh,
+				     struct v4l2_fmtdesc *f)
+{
+	const struct vpu_format *vpu_fmt;
+
+	vpu_fmt = coda_find_vpu_fmt_by_idx(f->index, VPU_FMT_TYPE_RAW);
+	if (!vpu_fmt)
+		return -EINVAL;
+
+	f->pixelformat = vpu_fmt->v4l2_pix_fmt;
+	f->flags = 0;
+
+	return 0;
+}
+
+static int coda_vpu_dec_try_fmt_cap(struct file *file, void *fh,
+				    struct v4l2_format *f)
+{
+	struct vpu_instance *inst = coda_to_vpu_inst(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	const struct vpu_format *vpu_fmt;
+	int width, height;
+
+	dev_dbg(inst->dev->dev, "%s: 4cc %d w %d h %d plane %d colorspace %d\n",
+		__func__, pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	if (!V4L2_TYPE_IS_CAPTURE(f->type))
+		return -EINVAL;
+
+	vpu_fmt = coda_find_vpu_fmt(pix_mp->pixelformat, VPU_FMT_TYPE_RAW);
+	if (!vpu_fmt) {
+		width = inst->dst_fmt.width;
+		height = inst->dst_fmt.height;
+		pix_mp->pixelformat = inst->dst_fmt.pixelformat;
+		pix_mp->num_planes = inst->dst_fmt.num_planes;
+	} else {
+		width = clamp(pix_mp->width, vpu_fmt->min_width,
+			      round_up(inst->src_fmt.width, 32));
+		height = clamp(pix_mp->height, vpu_fmt->min_height,
+			       inst->src_fmt.height);
+		pix_mp->pixelformat = vpu_fmt->v4l2_pix_fmt;
+		pix_mp->num_planes = vpu_fmt->num_planes;
+	}
+	coda_update_pix_fmt(pix_mp, width, height);
+	pix_mp->colorspace = inst->colorspace;
+	pix_mp->ycbcr_enc = inst->ycbcr_enc;
+	pix_mp->quantization = inst->quantization;
+	pix_mp->xfer_func = inst->xfer_func;
+
+	return 0;
+}
+
+static int coda_vpu_dec_s_fmt_cap(struct file *file, void *fh,
+				  struct v4l2_format *f)
+{
+	struct vpu_instance *inst = coda_to_vpu_inst(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i, ret;
+
+	dev_dbg(inst->dev->dev, "%s: 4cc %d w %d h %d plane %d colorspace %d\n",
+		__func__, pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	ret = coda_vpu_dec_try_fmt_cap(file, fh, f);
+	if (ret)
+		return ret;
+
+	inst->dst_fmt.width = pix_mp->width;
+	inst->dst_fmt.height = pix_mp->height;
+	inst->dst_fmt.pixelformat = pix_mp->pixelformat;
+	inst->dst_fmt.field = pix_mp->field;
+	inst->dst_fmt.flags = pix_mp->flags;
+	inst->dst_fmt.num_planes = pix_mp->num_planes;
+	for (i = 0; i < inst->dst_fmt.num_planes; i++) {
+		inst->dst_fmt.plane_fmt[i].bytesperline =
+			pix_mp->plane_fmt[i].bytesperline;
+		inst->dst_fmt.plane_fmt[i].sizeimage =
+			pix_mp->plane_fmt[i].sizeimage;
+	}
+
+	dev_dbg(inst->dev->dev, "%d.%s.dst_fmt.pixelformat:%4s\n", __LINE__,
+		__func__, (char *)&inst->dst_fmt.pixelformat);
+	if (inst->dst_fmt.pixelformat == V4L2_PIX_FMT_NV12 ||
+	    inst->dst_fmt.pixelformat == V4L2_PIX_FMT_NV12M) {
+		inst->cbcr_interleave = true;
+		inst->nv21 = false;
+	} else if (inst->dst_fmt.pixelformat == V4L2_PIX_FMT_NV21 ||
+		   inst->dst_fmt.pixelformat == V4L2_PIX_FMT_NV21M) {
+		inst->cbcr_interleave = true;
+		inst->nv21 = true;
+	} else {
+		inst->cbcr_interleave = false;
+		inst->nv21 = false;
+	}
+
+	return 0;
+}
+
+static int coda_vpu_dec_g_fmt_cap(struct file *file, void *fh,
+				  struct v4l2_format *f)
+{
+	struct vpu_instance *inst = coda_to_vpu_inst(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i;
+
+	pix_mp->width = inst->dst_fmt.width;
+	pix_mp->height = inst->dst_fmt.height;
+	pix_mp->pixelformat = inst->dst_fmt.pixelformat;
+	pix_mp->field = inst->dst_fmt.field;
+	pix_mp->flags = inst->dst_fmt.flags;
+	pix_mp->num_planes = inst->dst_fmt.num_planes;
+	for (i = 0; i < pix_mp->num_planes; i++) {
+		pix_mp->plane_fmt[i].bytesperline =
+			inst->dst_fmt.plane_fmt[i].bytesperline;
+		pix_mp->plane_fmt[i].sizeimage =
+			inst->dst_fmt.plane_fmt[i].sizeimage;
+	}
+
+	pix_mp->colorspace = inst->colorspace;
+	pix_mp->ycbcr_enc = inst->ycbcr_enc;
+	pix_mp->quantization = inst->quantization;
+	pix_mp->xfer_func = inst->xfer_func;
+
+	return 0;
+}
+
+static int coda_vpu_dec_enum_fmt_out(struct file *file, void *fh,
+				     struct v4l2_fmtdesc *f)
+{
+	struct vpu_instance *inst = coda_to_vpu_inst(fh);
+	const struct vpu_format *vpu_fmt;
+
+	dev_dbg(inst->dev->dev, "%s: index %d\n", __func__, f->index);
+
+	vpu_fmt = coda_find_vpu_fmt_by_idx(f->index, VPU_FMT_TYPE_CODEC);
+	if (!vpu_fmt)
+		return -EINVAL;
+
+	f->pixelformat = vpu_fmt->v4l2_pix_fmt;
+
+	return 0;
+}
+
+static int coda_vpu_dec_try_fmt_out(struct file *file, void *fh,
+				    struct v4l2_format *f)
+{
+	struct vpu_instance *inst = coda_to_vpu_inst(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	const struct vpu_format *vpu_fmt;
+	int width, height;
+
+	dev_dbg(inst->dev->dev, "%s: 4cc %d w %d h %d plane %d colorspace %d\n",
+		__func__, pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	if (!V4L2_TYPE_IS_OUTPUT(f->type))
+		return -EINVAL;
+
+	vpu_fmt = coda_find_vpu_fmt(pix_mp->pixelformat, VPU_FMT_TYPE_CODEC);
+	if (!vpu_fmt) {
+		width = inst->src_fmt.width;
+		height = inst->src_fmt.height;
+		pix_mp->pixelformat = inst->src_fmt.pixelformat;
+		pix_mp->num_planes = inst->src_fmt.num_planes;
+	} else {
+		width = pix_mp->width;
+		height = pix_mp->height;
+		pix_mp->pixelformat = vpu_fmt->v4l2_pix_fmt;
+		pix_mp->num_planes = vpu_fmt->num_planes;
+	}
+
+	coda_update_pix_fmt(pix_mp, width, height);
+
+	return 0;
+}
+
+static int coda_vpu_dec_s_fmt_out(struct file *file, void *fh,
+				  struct v4l2_format *f)
+{
+	struct vpu_instance *inst = coda_to_vpu_inst(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i, ret;
+
+	dev_dbg(inst->dev->dev, "%s: 4cc %d w %d h %d plane %d colorspace %d\n",
+		__func__, pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	ret = coda_vpu_dec_try_fmt_out(file, fh, f);
+	if (ret)
+		return ret;
+
+	inst->src_fmt.width = pix_mp->width;
+	inst->src_fmt.height = pix_mp->height;
+	inst->src_fmt.pixelformat = pix_mp->pixelformat;
+	inst->src_fmt.field = pix_mp->field;
+	inst->src_fmt.flags = pix_mp->flags;
+	inst->src_fmt.num_planes = pix_mp->num_planes;
+	for (i = 0; i < inst->src_fmt.num_planes; i++) {
+		inst->src_fmt.plane_fmt[i].bytesperline =
+			pix_mp->plane_fmt[i].bytesperline;
+		inst->src_fmt.plane_fmt[i].sizeimage =
+			pix_mp->plane_fmt[i].sizeimage;
+	}
+
+	inst->colorspace = pix_mp->colorspace;
+	inst->ycbcr_enc = pix_mp->ycbcr_enc;
+	inst->quantization = pix_mp->quantization;
+	inst->xfer_func = pix_mp->xfer_func;
+
+	coda_update_pix_fmt(&inst->dst_fmt, pix_mp->width, pix_mp->height);
+	inst->std = coda_to_vpu_codstd(inst->src_fmt.pixelformat);
+
+	return 0;
+}
+
+static int coda_vpu_dec_g_fmt_out(struct file *file, void *fh,
+				  struct v4l2_format *f)
+{
+	struct vpu_instance *inst = coda_to_vpu_inst(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i;
+
+	pix_mp->width = inst->src_fmt.width;
+	pix_mp->height = inst->src_fmt.height;
+	pix_mp->pixelformat = inst->src_fmt.pixelformat;
+	pix_mp->field = inst->src_fmt.field;
+	pix_mp->flags = inst->src_fmt.flags;
+	pix_mp->num_planes = inst->src_fmt.num_planes;
+	for (i = 0; i < pix_mp->num_planes; i++) {
+		pix_mp->plane_fmt[i].bytesperline =
+			inst->src_fmt.plane_fmt[i].bytesperline;
+		pix_mp->plane_fmt[i].sizeimage =
+			inst->src_fmt.plane_fmt[i].sizeimage;
+	}
+
+	pix_mp->colorspace = inst->colorspace;
+	pix_mp->ycbcr_enc = inst->ycbcr_enc;
+	pix_mp->quantization = inst->quantization;
+	pix_mp->xfer_func = inst->xfer_func;
+
+	return 0;
+}
+
+static int coda_vpu_dec_allocate_ring_buffer(struct vpu_instance *inst)
+{
+	int ret;
+	struct vpu_buf *ring_buffer = &inst->bitstream_vbuf;
+
+	ring_buffer->size =
+		ALIGN(inst->src_fmt.plane_fmt[0].sizeimage, 1024) * 4;
+	ret = coda_vdi_allocate_dma_memory(inst->dev, ring_buffer);
+	if (ret) {
+		dev_dbg(inst->dev->dev,
+			"%s: allocate ring buffer of size %zu fail: %d\n",
+			__func__, ring_buffer->size, ret);
+		return ret;
+	}
+
+	inst->last_rd_ptr = ring_buffer->daddr;
+
+	return 0;
+}
+
+static int coda_set_dec_openparam(struct dec_open_param *open_param,
+				  struct vpu_instance *inst)
+{
+	if (inst->std == STD_AVC)
+		open_param->codec_mode = AVC_DEC;
+	else if (inst->std == STD_MPEG2)
+		open_param->codec_mode = MP2_DEC;
+	else if (inst->std == STD_VP8) {
+		open_param->codec_mode = VPX_DEC;
+		open_param->codec_mode_aux = VPX_AUX_VP8;
+	} else {
+		return -EINVAL;
+	}
+
+	open_param->bitstream_buffer = inst->bitstream_vbuf.daddr;
+	open_param->bitstream_buffer_size = inst->bitstream_vbuf.size;
+	open_param->frame_endian = VDI_LITTLE_ENDIAN;
+	open_param->stream_endian = VDI_LITTLE_ENDIAN;
+#ifdef LINEAR_FRAME_MAP_TYPE
+	open_param->map_type = LINEAR_FRAME_MAP;
+	open_param->wtl_enable = 0;
+	open_param->wtl_mode = FF_NONE;
+	open_param->bwb_enable = 0;
+#else
+	open_param->map_type = TILED_FRAME_V_MAP;
+	open_param->wtl_enable = 1;
+	open_param->wtl_mode = FF_FRAME;
+	open_param->bwb_enable = 1;
+#endif
+	open_param->reorder_enable = 0;
+	open_param->sec_base_core0 = inst->dev->sram_buf.daddr;
+	open_param->sec_size_core0 = inst->dev->sram_buf.size;
+	open_param->frame_delay = -1;
+	// stateless uses pic_end mode
+	open_param->bitstream_mode = BS_MODE_PIC_END;
+
+	return 0;
+}
+
+static int coda_vpu_dec_create_instance(struct vpu_instance *inst)
+{
+	int ret;
+	struct dec_open_param open_param;
+	struct dec_info *p_dec_info;
+	struct vpu_buf *slice_vbuf;
+
+	dev_dbg(inst->dev->dev, "%s: enter\n", __func__);
+
+	memset(&open_param, 0, sizeof(struct dec_open_param));
+
+	inst->std = coda_to_vpu_codstd(inst->src_fmt.pixelformat);
+	if (inst->std == STD_MAX) {
+		dev_err(inst->dev->dev, "unsupported pixelformat: %.4s\n",
+			(char *)&inst->src_fmt.pixelformat);
+		return -EINVAL;
+	}
+
+	inst->work_vbuf.size = WORK_BUF_SIZE;
+	if (inst->std == STD_AVC) {
+		inst->work_vbuf.size += PS_SAVE_SIZE;
+	}
+
+	ret = coda_vdi_allocate_dma_memory(inst->dev, &inst->work_vbuf);
+	if (ret) {
+		dev_dbg(inst->dev->dev,
+			"%s: allocate work buffer of size %zu fail: %d\n",
+			__func__, inst->work_vbuf.size, ret);
+		return ret;
+	}
+
+	coda_set_dec_openparam(&open_param, inst);
+
+	inst->codec_info = kzalloc(sizeof(*inst->codec_info), GFP_KERNEL);
+	if (!inst->codec_info) {
+		coda_vdi_free_dma_memory(inst->dev, &inst->work_vbuf);
+		return -ENOMEM;
+	}
+
+	p_dec_info = &inst->codec_info->dec_info;
+	dev_dbg(inst->dev->dev, "[bitstream_buffer:\t0x%llx]\n",
+		open_param.bitstream_buffer);
+	dev_dbg(inst->dev->dev, "[bitstream_buffer_size:\t%d]\n",
+		open_param.bitstream_buffer_size);
+	dev_dbg(inst->dev->dev, "[codec_mode:\t\t%d]\n",
+		open_param.codec_mode);
+	dev_dbg(inst->dev->dev, "[codec_mode_aux:\t\t%d]\n",
+		open_param.codec_mode_aux);
+	dev_dbg(inst->dev->dev, "[mp4_deblk_enable:\t%d]\n",
+		open_param.mp4_deblk_enable);
+	dev_dbg(inst->dev->dev, "[avc_extension:\t\t%d]\n",
+		open_param.avc_extension);
+	dev_dbg(inst->dev->dev, "[reorder_enable:\t\t%d]\n",
+		open_param.reorder_enable);
+	dev_dbg(inst->dev->dev, "[mp4_class:\t\t%d]\n",
+		open_param.mp4_class);
+	dev_dbg(inst->dev->dev, "[tiled2_linear_enable:\t%d]\n",
+		open_param.tiled2_linear_enable);
+	dev_dbg(inst->dev->dev, "[tiled2_linear_mode:\t%d]\n",
+		open_param.tiled2_linear_mode);
+	dev_dbg(inst->dev->dev, "[wtl_enable:\t\t%d]\n",
+		open_param.wtl_enable);
+	dev_dbg(inst->dev->dev, "[wtl_mode:\t\t%d]\n",
+		open_param.wtl_mode);
+	dev_dbg(inst->dev->dev, "[bwb_enable:\t\t%d]\n",
+		open_param.bwb_enable);
+	dev_dbg(inst->dev->dev, "[frame_endian:\t\t%d]\n",
+		open_param.frame_endian);
+	dev_dbg(inst->dev->dev, "[stream_endian:\t\t%d]\n",
+		open_param.stream_endian);
+	dev_dbg(inst->dev->dev, "[bitstream_mode:\t\t%d]\n",
+		open_param.bitstream_mode);
+	dev_dbg(inst->dev->dev, "[map_type:\t\t%d]\n",
+		open_param.map_type);
+	dev_dbg(inst->dev->dev, "[sec_base_core0:\t\t0x%llx]\n",
+		open_param.sec_base_core0);
+	dev_dbg(inst->dev->dev, "[sec_size_core0:\t\t%d]\n",
+		open_param.sec_size_core0);
+	dev_dbg(inst->dev->dev, "[frame_delay:\t\t%d]\n",
+		open_param.frame_delay);
+	memcpy(&p_dec_info->open_param, &open_param,
+	       sizeof(struct dec_open_param));
+
+	p_dec_info->sec_axi_info.use_bit_enable = 0;
+	p_dec_info->sec_axi_info.use_ip_enable = 0;
+	p_dec_info->sec_axi_info.use_dbk_y_enable = 0;
+	p_dec_info->sec_axi_info.use_dbk_c_enable = 0;
+	p_dec_info->sec_axi_info.use_ovl_enable = 0;
+	p_dec_info->sec_axi_info.use_btp_enable = 0;
+
+	p_dec_info->stream_wr_ptr = inst->bitstream_vbuf.daddr;
+	p_dec_info->stream_rd_ptr = inst->bitstream_vbuf.daddr;
+
+	if (open_param.codec_mode == VPX_DEC) {
+		slice_vbuf = &inst->slice_vbuf;
+		slice_vbuf->size = VP8_MB_SAVE_SIZE;
+		ret = coda_vdi_allocate_dma_memory(inst->dev, slice_vbuf);
+		if (ret) {
+			dev_dbg(inst->dev->dev,
+				"%s: allocate vpx slice buffer of size %zu fail: %d\n",
+				__func__, inst->work_vbuf.size, ret);
+			return ret;
+		}
+	} else if (open_param.codec_mode == AVC_DEC) {
+		slice_vbuf = &inst->slice_vbuf;
+		slice_vbuf->size = SLICE_SAVE_SIZE;
+		ret = coda_vdi_allocate_dma_memory(inst->dev, slice_vbuf);
+		if (ret) {
+			dev_dbg(inst->dev->dev,
+				"%s: allocate vpx slice buffer of size %zu fail: %d\n",
+				__func__, inst->work_vbuf.size, ret);
+			return ret;
+		}
+	}
+
+	inst->state = VPU_INST_STATE_OPEN;
+
+	return 0;
+}
+
+static int coda_vpu_dec_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(q);
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: type %d\n", __func__, q->type);
+
+	return ret;
+}
+
+static void coda_vpu_return_buffer(struct vb2_queue *vq, u32 state)
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(vq);
+	struct vb2_v4l2_buffer *vbuf;
+
+	for (;;) {
+		if (V4L2_TYPE_IS_OUTPUT(vq->type))
+			vbuf = v4l2_m2m_src_buf_remove(inst->v4l2_fh.m2m_ctx);
+		else
+			vbuf = v4l2_m2m_dst_buf_remove(inst->v4l2_fh.m2m_ctx);
+
+		if (!vbuf)
+			break;
+
+		v4l2_ctrl_request_complete(vbuf->vb2_buf.req_obj.req,
+					   &inst->v4l2_ctrl_hdl);
+		dev_err(inst->dev->dev, "Marked request %p as complete\n",
+			vbuf->vb2_buf.req_obj.req);
+
+		dev_dbg(inst->dev->dev,
+			"%d.%s.%s.v4l2_m2m_buf_done.state:%d.vbuf:%px\n",
+			__LINE__, __func__,
+			(V4L2_TYPE_IS_OUTPUT(vq->type)?"OUT":"CAP"),
+			state, (void *)vbuf);
+		v4l2_m2m_buf_done(vbuf, state);
+	}
+}
+
+static void coda_vpu_dec_stop_streaming(struct vb2_queue *q)
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(q);
+	struct v4l2_m2m_ctx *m2m_ctx = inst->v4l2_fh.m2m_ctx;
+
+	dev_dbg(inst->dev->dev, "%s: type %d\n", __func__, q->type);
+
+	v4l2_m2m_suspend(inst->dev->m2m_dev);
+	coda_vpu_return_buffer(q, VB2_BUF_STATE_ERROR);
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		inst->queued_src_buf_num = 0;
+		inst->output_stopped = true;
+	} else {
+		if (v4l2_m2m_has_stopped(m2m_ctx))
+			v4l2_m2m_clear_state(m2m_ctx);
+
+		if (inst->output_stopped) {
+			inst->state = VPU_INST_STATE_NONE;
+			coda_vpu_dec_destroy_instance(inst);
+			inst->output_stopped = false;
+		} else {
+			inst->state = VPU_INST_STATE_OPEN;
+		}
+
+		inst->queued_dst_buf_num = 0;
+		coda_vpu_dec_give_command(inst, DEC_RESET_FRAMEBUF_INFO, NULL);
+	}
+	v4l2_m2m_resume(inst->dev->m2m_dev);
+}
+
+static void coda_vpu_dec_buf_request_complete(struct vb2_buffer *vb)
+{
+	struct vpu_instance *ctx = vb2_get_drv_priv(vb->vb2_queue);
+
+	v4l2_ctrl_request_complete(vb->req_obj.req, &ctx->v4l2_ctrl_hdl);
+}
+
+static const struct v4l2_ioctl_ops coda_vpu_dec_ioctl_ops = {
+	.vidioc_querycap = coda_vpu_dec_querycap,
+	.vidioc_enum_framesizes = coda_vpu_dec_enum_framesizes,
+
+	.vidioc_enum_fmt_vid_cap = coda_vpu_dec_enum_fmt_cap,
+	.vidioc_s_fmt_vid_cap_mplane = coda_vpu_dec_s_fmt_cap,
+	.vidioc_g_fmt_vid_cap_mplane = coda_vpu_dec_g_fmt_cap,
+	.vidioc_try_fmt_vid_cap_mplane = coda_vpu_dec_try_fmt_cap,
+
+	.vidioc_enum_fmt_vid_out = coda_vpu_dec_enum_fmt_out,
+	.vidioc_s_fmt_vid_out_mplane = coda_vpu_dec_s_fmt_out,
+	.vidioc_g_fmt_vid_out_mplane = coda_vpu_dec_g_fmt_out,
+	.vidioc_try_fmt_vid_out_mplane = coda_vpu_dec_try_fmt_out,
+
+	.vidioc_reqbufs = v4l2_m2m_ioctl_reqbufs,
+	.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,
+	.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,
+	.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,
+	.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,
+	.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,
+	.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,
+
+	.vidioc_streamon = v4l2_m2m_ioctl_streamon,
+	.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,
+
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static const struct vb2_ops coda_vpu_dec_vb2_ops = {
+	.queue_setup = coda_vpu_dec_queue_setup,
+	.buf_out_validate = coda_vpu_dec_buf_out_validate,
+	.buf_prepare = coda_vpu_dec_buf_prepare,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+	.buf_queue = coda_vpu_dec_buf_queue,
+	.start_streaming = coda_vpu_dec_start_streaming,
+	.stop_streaming = coda_vpu_dec_stop_streaming,
+	.buf_request_complete = coda_vpu_dec_buf_request_complete,
+};
+
+static void coda_set_default_format(struct v4l2_pix_format_mplane *src_fmt,
+				    struct v4l2_pix_format_mplane *dst_fmt)
+{
+	const struct vpu_format *vpu_fmt;
+
+	vpu_fmt = coda_find_vpu_fmt_by_idx(2, VPU_FMT_TYPE_CODEC);
+
+	src_fmt->pixelformat = vpu_fmt->v4l2_pix_fmt;
+	src_fmt->num_planes = vpu_fmt->num_planes;
+	coda_update_pix_fmt(src_fmt, 720, 480);
+
+	vpu_fmt = coda_find_vpu_fmt_by_idx(0, VPU_FMT_TYPE_RAW);
+
+	dst_fmt->pixelformat = vpu_fmt->v4l2_pix_fmt;
+	dst_fmt->num_planes = vpu_fmt->num_planes;
+	coda_update_pix_fmt(dst_fmt, 736, 480);
+}
+
+int coda_vpu_dec_close(struct vpu_instance *inst, u32 *fail_res)
+{
+	if (inst->codec_info)
+		kfree(inst->codec_info);
+	inst->codec_info = NULL;
+	return 0;
+}
+
+static int coda_vpu_dec_queue_init(void *priv, struct vb2_queue *src_vq,
+				   struct vb2_queue *dst_vq)
+{
+	struct vpu_instance *inst = priv;
+	int ret;
+
+	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	src_vq->io_modes = VB2_MMAP | VB2_DMABUF;
+	src_vq->mem_ops = &vb2_dma_contig_memops;
+	src_vq->ops = &coda_vpu_dec_vb2_ops;
+	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	src_vq->buf_struct_size = sizeof(struct vpu_buffer);
+	src_vq->drv_priv = inst;
+	src_vq->lock = &inst->dev->dev_lock;
+	src_vq->dev = inst->dev->v4l2_dev.dev;
+	src_vq->supports_requests = true;
+	ret = vb2_queue_init(src_vq);
+	if (ret)
+		return ret;
+
+	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	dst_vq->io_modes = VB2_MMAP | VB2_DMABUF;
+	dst_vq->mem_ops = &vb2_dma_contig_memops;
+	dst_vq->ops = &coda_vpu_dec_vb2_ops;
+	dst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	dst_vq->buf_struct_size = sizeof(struct vpu_buffer);
+	dst_vq->min_buffers_needed = 1;
+	dst_vq->drv_priv = inst;
+	dst_vq->lock = &inst->dev->dev_lock;
+	dst_vq->dev = inst->dev->v4l2_dev.dev;
+	ret = vb2_queue_init(dst_vq);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int coda_vpu_dec_issue_seq_init(struct vpu_instance *inst,
+				       struct stateless_info *info)
+{
+	int pic_width = 0;
+	int pic_height = 0;
+	int pic_num = 0;
+	int ret;
+	int profile = 0;
+
+	switch (inst->std) {
+	case STD_MPEG2:
+		//pic_width = info->mpeg2.seq->horizontal_size;
+		//pic_height = info->mpeg2.seq->vertical_size;
+		pic_num = 3;
+		break;
+	case STD_VP8:
+		//pic_width = info->vp8.frame->width;
+		//pic_height = info->vp8.frame->height;
+		pic_num = 4;
+		break;
+	case STD_AVC:
+		//pic_width = (info->h264.sps->pic_width_in_mbs_minus1 + 1) * 16;
+		//pic_height =
+		//	(info->h264.sps->pic_height_in_map_units_minus1 + 1) *
+		//	16;
+		pic_num = info->h264.sps->max_num_ref_frames + 2;
+		profile = info->h264.sps->profile_idc;
+		break;
+	default:
+		break;
+	}
+
+	pic_width = inst->src_fmt.width;
+	pic_height = inst->src_fmt.height;
+
+	dev_info(inst->dev->dev, "width : %d, height : %d, pic_num : %d \n",
+		 pic_width, pic_height, pic_num);
+	coda_vpu_dec_give_command(inst, DEC_SET_STATELESS_WIDTH, &pic_width);
+	coda_vpu_dec_give_command(inst, DEC_SET_STATELESS_HEGIHT, &pic_height);
+	coda_vpu_dec_give_command(inst, DEC_SET_STATELESS_NUM_FRAMES, &pic_num);
+	coda_vpu_dec_give_command(inst, DEC_SET_STATELESS_PROFILE, &profile);
+
+	ret = coda_vpu_dec_init_seq(inst);
+
+	return ret;
+}
+
+static int coda_vpu_dec_complete_seq_init(struct vpu_instance *inst,
+					  struct dec_initial_info *info)
+{
+	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
+	int ret;
+
+	ret = coda_vpu_dec_get_seq_info(inst, info);
+	if (!ret)
+		p_dec_info->initial_info_obtained = true;
+
+	info->wr_ptr = p_dec_info->stream_wr_ptr;
+	p_dec_info->stride = inst->dst_fmt.width;
+	dev_dbg(inst->dev->dev,
+		"%d.%s.stream_rd_ptr:0x%llx.stream_wr_ptr:0x%llx.stride:%d\n",
+		__LINE__, __func__, p_dec_info->stream_rd_ptr,
+		p_dec_info->stream_wr_ptr, p_dec_info->stride);
+
+	p_dec_info->initial_info = *info;
+
+	dev_dbg(inst->dev->dev, "[err_reason:\t\t0x%x]\n", info->err_reason);
+	dev_dbg(inst->dev->dev, "[pic_width:\t\t%d]\n", info->pic_width);
+	dev_dbg(inst->dev->dev, "[pic_height:\t\t%d]\n", info->pic_height);
+	dev_dbg(inst->dev->dev, "[pic_crop_rect:\t%d,%d,%d,%d]\n",
+		info->pic_crop_rect.left, info->pic_crop_rect.right,
+		info->pic_crop_rect.top, info->pic_crop_rect.bottom);
+	dev_dbg(inst->dev->dev, "[luma_bit_depth:\t\t%d]\n",
+		info->luma_bit_depth);
+	dev_dbg(inst->dev->dev, "[chroma_bit_depth:\t%d]\n",
+		info->chroma_bit_depth);
+	dev_dbg(inst->dev->dev, "[rd_ptr:\t\t\t0x%llx]\n",
+		info->rd_ptr);
+	dev_dbg(inst->dev->dev, "[wr_ptr:\t\t\t0x%llx]\n",
+		info->wr_ptr);
+
+	return ret;
+}
+
+static int coda_calc_fbc_stride(u32 width, u32 height,
+				enum tiled_map_type map_type, int format)
+{
+	int stride = 0;
+
+	if (height > width) {
+		if ((map_type >= TILED_FRAME_V_MAP &&
+		     map_type <= TILED_MIXED_V_MAP) ||
+		    map_type == TILED_FRAME_NO_BANK_MAP ||
+		    map_type == TILED_FIELD_NO_BANK_MAP)
+			width = ALIGN(height, 16); // TiledMap constraints
+	}
+
+	if (map_type == LINEAR_FRAME_MAP) {
+		switch (format) {
+		case FORMAT_420:
+		case FORMAT_422:
+		case FORMAT_444:
+		case FORMAT_400:
+			stride = ALIGN(width, 32);
+			break;
+		}
+	} else {
+		width = (width < height) ? height : width;
+		stride = (width > 4096) ?
+				 8192 :
+				 (width > 2048) ?
+				 4096 :
+				 (width > 1024) ? 2048 :
+						  (width > 512) ? 1024 : 512;
+	}
+
+	return stride;
+}
+
+static int coda_calc_luma_size(int stride, int height,
+			       enum tiled_map_type map_type)
+{
+	u32 unit_size_hor_lum;
+	u32 unit_size_ver_lum;
+	u32 size_dpb_lum;
+	u32 field_map;
+	u32 size_dpb_lum_4k;
+
+	if (map_type == TILED_FIELD_V_MAP ||
+	    map_type == TILED_FIELD_NO_BANK_MAP || map_type == LINEAR_FIELD_MAP)
+		field_map = 1;
+	else
+		field_map = 0;
+
+	unit_size_hor_lum = 0;
+	unit_size_ver_lum = 0;
+	size_dpb_lum = 0;
+	size_dpb_lum_4k = 0;
+
+	if (map_type == LINEAR_FRAME_MAP || map_type == LINEAR_FIELD_MAP) {
+		size_dpb_lum = stride * height;
+	} else {
+		unit_size_hor_lum = stride;
+		unit_size_ver_lum = (((height >> field_map) + 63) / 64) *
+				    64; // unit vertical size is 64 pixel (4MB)
+		size_dpb_lum =
+			unit_size_hor_lum * (unit_size_ver_lum << field_map);
+	}
+
+	return size_dpb_lum;
+}
+
+static int coda_calc_chroma_size(int stride, int height,
+				 enum tiled_map_type map_type,
+				 bool cbcr_interleave, int format)
+{
+	int chr_size_y, chr_size_x;
+	int chr_vscale, chr_hscale;
+	int unit_size_hor_chr, unit_size_ver_chr;
+	u32 size_dpb_chr, size_dpb_chr_4k;
+	int field_map;
+
+	unit_size_hor_chr = 0;
+	unit_size_ver_chr = 0;
+	size_dpb_chr = 0;
+	size_dpb_chr_4k = 0;
+
+	chr_hscale = 1;
+	chr_vscale = 1;
+
+	switch (format) {
+	case FORMAT_420:
+		chr_hscale = 2;
+		chr_vscale = 2;
+		break;
+	case FORMAT_422:
+		chr_hscale = 2;
+		break;
+	case FORMAT_444:
+		break;
+	default:
+		return 0;
+	}
+
+	if (map_type == TILED_FIELD_V_MAP ||
+	    map_type == TILED_FIELD_NO_BANK_MAP)
+		field_map = 1;
+	else
+		field_map = 0;
+
+	if (map_type == LINEAR_FRAME_MAP || map_type == LINEAR_FIELD_MAP) {
+		switch (format) {
+		case FORMAT_420:
+			unit_size_hor_chr = stride / 2;
+			unit_size_ver_chr = height / 2;
+			break;
+		case FORMAT_422:
+			unit_size_hor_chr = ALIGN(stride / 2, 16);
+			unit_size_ver_chr = height;
+			break;
+		case FORMAT_444:
+			unit_size_hor_chr = stride;
+			unit_size_ver_chr = height;
+			break;
+		case FORMAT_400:
+			unit_size_hor_chr = 0;
+			unit_size_ver_chr = 0;
+			break;
+		default:
+			break;
+		}
+
+		size_dpb_chr = (format == FORMAT_400) ?
+				       0 :
+				       unit_size_ver_chr * unit_size_hor_chr;
+	} else {
+		chr_size_y = (height >> field_map) / chr_hscale;
+		chr_size_x =
+			cbcr_interleave == true ? stride : stride / chr_vscale;
+
+		unit_size_hor_chr = (chr_size_x > 4096) ?
+					    8192 :
+					    (chr_size_x > 2048) ?
+					    4096 :
+					    (chr_size_x > 1024) ?
+					    2048 :
+					    (chr_size_x > 512) ? 1024 : 512;
+		unit_size_ver_chr = ((chr_size_y + 63) / 64) *
+				    64; // unit vertical size is 64 pixel (4MB)
+
+		size_dpb_chr =
+			unit_size_hor_chr * (unit_size_ver_chr << field_map);
+		size_dpb_chr /= (cbcr_interleave == true ? 2 : 1);
+	}
+
+	return size_dpb_chr;
+}
+
+int coda_vpu_dec_register_frame_buffer_ex(struct vpu_instance *inst,
+					  int num_of_dec_fbs, int stride,
+					  int height, int map_type)
+{
+	struct dec_info *p_dec_info;
+	int ret;
+	struct vpu_device *vpu_dev = inst->dev;
+	struct frame_buffer *fb;
+
+	if (num_of_dec_fbs > CODA_MAX_FBS)
+		return -EINVAL;
+
+	p_dec_info = &inst->codec_info->dec_info;
+	p_dec_info->framebuf_height = height;
+
+	if (!p_dec_info->initial_info_obtained)
+		return -EINVAL;
+
+	if (stride < p_dec_info->initial_info.pic_width || (stride % 8 != 0) ||
+	    height < p_dec_info->initial_info.pic_height)
+		return -EINVAL;
+
+	ret = mutex_lock_interruptible(&vpu_dev->hw_lock);
+	if (ret)
+		return ret;
+
+	fb = inst->frame_buf;
+	ret = coda_vpu_dec_register_frame_buffer(inst, &fb[0], map_type,
+						 num_of_dec_fbs);
+
+	mutex_unlock(&vpu_dev->hw_lock);
+
+	return ret;
+}
+
+static void coda_vpu_dec_release_fb(struct vpu_instance *inst)
+{
+	int i;
+
+	for (i = 0; i < CODA_MAX_FBS; i++)
+		coda_vdi_free_dma_memory(inst->dev, &inst->frame_vbuf[i]);
+	for (i = 0; i < CODA_MAX_FBS; i++) {
+		dev_dbg(inst->dev->dev,
+			"%d.%s.free.#%02d.mvcolbuf.size:%ld.daddr:0x%llx.vaddr:0x%px\n",
+			__LINE__, __func__, i,
+			inst->aux_vbuf[AUX_BUF_MV_COL][i].size,
+			inst->aux_vbuf[AUX_BUF_MV_COL][i].daddr,
+			inst->aux_vbuf[AUX_BUF_MV_COL][i].vaddr);
+		coda_vdi_free_dma_memory(inst->dev,
+					 &inst->aux_vbuf[AUX_BUF_MV_COL][i]);
+	}
+}
+
+static int coda_prepare_fb(struct vpu_instance *inst)
+{
+	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
+	unsigned int fb_num = 0;
+	int i;
+	unsigned int fb_stride = 0;
+	unsigned int fb_height = 0;
+	int luma_size, chroma_size;
+	int ret;
+	enum tiled_map_type map_type = p_dec_info->open_param.map_type;
+
+	fb_num = p_dec_info->pic_num;
+	dev_dbg(inst->dev->dev, "coda_prepare_fb: %d \n", fb_num);
+
+	fb_stride =
+		coda_calc_fbc_stride(inst->src_fmt.width, inst->src_fmt.height,
+				     p_dec_info->open_param.map_type,
+				     FORMAT_420);
+
+	if (p_dec_info->open_param.codec_mode == VPX_DEC)
+		fb_height = ALIGN(inst->src_fmt.height, 64);
+	else
+		fb_height = ALIGN(inst->src_fmt.height, 32);
+
+	dev_dbg(inst->dev->dev,
+		"%d.%s.src_fmt(w:%d,h:%d).map_type:%d.fb_stride:%d.fb_height:%d\n",
+		__LINE__, __func__, inst->src_fmt.width, inst->src_fmt.height,
+		p_dec_info->open_param.map_type, fb_stride, fb_height);
+
+	for (i = 0; i < fb_num; i++) {
+		struct frame_buffer *frame = &inst->frame_buf[i];
+		struct vpu_buf *vframe = &inst->frame_vbuf[i];
+		int field_frame;
+		int fb_size;
+
+		luma_size = coda_calc_luma_size(fb_stride, fb_height, map_type);
+		chroma_size =
+			coda_calc_chroma_size(fb_stride, fb_height, map_type,
+					      inst->cbcr_interleave,
+					      FORMAT_420);
+		fb_size = luma_size + chroma_size * 2;
+		dev_dbg(inst->dev->dev,
+			"%d.%s.%d.fb_size:%d.luma_size:%d.chroma_size:%d\n",
+			__LINE__, __func__, i, fb_size, luma_size, chroma_size);
+		vframe->size = fb_size;
+		ret = coda_vdi_allocate_dma_memory(inst->dev, vframe);
+		if (ret) {
+			dev_err(inst->dev->dev,
+				"%s: Allocating FBC buf of size %zu, fail: %d\n",
+				__func__, vframe->size, ret);
+			goto error;
+		}
+		dev_dbg(inst->dev->dev,
+			"%d.%s.%d.frame_vbuf.size:%ld.daddr:0x%llx.vaddr:0x%px\n",
+			__LINE__, __func__, i, vframe->size, vframe->daddr,
+			vframe->vaddr);
+
+		field_frame = (map_type == TILED_FIELD_V_MAP ||
+			       map_type == TILED_FIELD_NO_BANK_MAP ||
+			       map_type == LINEAR_FIELD_MAP);
+
+		frame->buf_y = vframe->daddr;
+		frame->buf_cb = vframe->daddr + (luma_size >> field_frame);
+		frame->buf_cr = frame->buf_cb + (chroma_size >> field_frame);
+		dev_dbg(inst->dev->dev,
+			"%d.%s.%d.buf_y:0x%llx.buf_cb:0x%llx.buf_cr:0x%llx.field_frame:%d\n",
+			__LINE__, __func__, i, frame->buf_y, frame->buf_cb,
+			frame->buf_cr, field_frame);
+
+		switch (map_type) {
+		case TILED_FIELD_V_MAP:
+		case TILED_FIELD_NO_BANK_MAP:
+			frame->buf_y_bot =
+				frame->buf_y + (fb_size >> field_frame);
+			frame->buf_cb_bot =
+				frame->buf_y_bot + (luma_size >> field_frame);
+			if (inst->cbcr_interleave == false)
+				frame->buf_cr_bot =
+					frame->buf_cb_bot +
+					(chroma_size >> field_frame);
+			break;
+		case TILED_FRAME_V_MAP:
+		case TILED_FRAME_H_MAP:
+		case TILED_MIXED_V_MAP:
+		case TILED_FRAME_NO_BANK_MAP:
+			frame->buf_y_bot = frame->buf_y;
+			frame->buf_cb_bot = frame->buf_cb;
+			if (inst->cbcr_interleave == false) {
+				frame->buf_cr_bot = frame->buf_cr;
+			}
+			break;
+		case TILED_FIELD_MB_RASTER_MAP:
+			frame->buf_y_bot = frame->buf_y + (luma_size >> 1);
+			frame->buf_cb_bot = frame->buf_cb + chroma_size;
+			break;
+		default:
+			frame->buf_y_bot = 0;
+			frame->buf_cb_bot = 0;
+			frame->buf_cr_bot = 0;
+			break;
+		}
+
+		frame->width = inst->src_fmt.width;
+		frame->stride = fb_stride;
+		frame->height = fb_height;
+		dev_dbg(inst->dev->dev,
+			"%d.%s.%d.frame(width:%d.stride:%d.height:%d)\n",
+			__LINE__, __func__, i, frame->width, frame->stride,
+			frame->height);
+	}
+
+	if (p_dec_info->open_param.codec_mode != AVC_DEC) {
+		int size_mvcolbuf;
+		struct vpu_buf *vframe = &inst->aux_vbuf[AUX_BUF_MV_COL][0];
+
+		size_mvcolbuf =
+			((p_dec_info->initial_info.pic_width + 31) & ~31) *
+			((p_dec_info->initial_info.pic_height + 31) & ~31);
+		size_mvcolbuf = (size_mvcolbuf * 3) / 2;
+		size_mvcolbuf = (size_mvcolbuf + 4) / 5;
+		size_mvcolbuf = ((size_mvcolbuf + 7) / 8) * 8;
+		vframe->size = size_mvcolbuf;
+		ret = coda_vdi_allocate_dma_memory(inst->dev, vframe);
+		if (ret) {
+			dev_err(inst->dev->dev,
+				"%s: Allocating MV_COL buf of size %zu, fail: %d\n",
+				__func__, vframe->size, ret);
+			goto error;
+		}
+		dev_dbg(inst->dev->dev,
+			"%d.%s.mvcolbuf.size:%ld.daddr:0x%llx.vaddr:0x%px\n",
+			__LINE__, __func__, vframe->size, vframe->daddr,
+			vframe->vaddr);
+	} else {
+		for (i = 0; i < fb_num; i++) {
+			int size_mvcolbuf;
+			struct vpu_buf *vframe =
+				&inst->aux_vbuf[AUX_BUF_MV_COL][i];
+
+			size_mvcolbuf =
+				((p_dec_info->initial_info.pic_width + 31) &
+				 ~31) *
+				((p_dec_info->initial_info.pic_height + 31) &
+				 ~31);
+			size_mvcolbuf = (size_mvcolbuf * 3) / 2;
+			size_mvcolbuf = (size_mvcolbuf + 4) / 5;
+			size_mvcolbuf = ((size_mvcolbuf + 7) / 8) * 8;
+			vframe->size = size_mvcolbuf;
+			ret = coda_vdi_allocate_dma_memory(inst->dev, vframe);
+			if (ret) {
+				dev_err(inst->dev->dev,
+					"%s: Allocating MV_COL buf of size %zu, fail: %d\n",
+					__func__, vframe->size, ret);
+				goto error;
+			}
+			dev_dbg(inst->dev->dev,
+				"%d.%s.alloc.#%02d.mvcolbuf.size:%ld.daddr:0x%llx.vaddr:0x%px\n",
+				__LINE__, __func__, i, vframe->size,
+				vframe->daddr, vframe->vaddr);
+		}
+	}
+	dev_dbg(inst->dev->dev, "register_frame_buffer num: %d \n", fb_num);
+	ret = coda_vpu_dec_register_frame_buffer_ex(inst, fb_num, fb_stride,
+						    fb_height, map_type);
+	if (ret)
+		goto error;
+
+	inst->state = VPU_INST_STATE_PIC_RUN;
+
+	return 0;
+error:
+	coda_vpu_dec_release_fb(inst);
+
+	return ret;
+}
+
+static int coda_vpu_dec_set_wr_ptr(struct vpu_instance *inst, int size)
+{
+	coda_vpu_set_wr_ptr(inst, size);
+
+	return 0;
+}
+
+static int coda_vpu_dec_set_rd_ptr(struct vpu_instance *inst)
+{
+	coda_vpu_set_rd_ptr(inst);
+
+	return 0;
+}
+
+static int coda_vpu_dec_start_one_frame(struct vpu_instance *inst,
+					struct dec_param *param)
+{
+	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
+	int ret;
+
+	if (p_dec_info->stride ==
+	    0) // this means frame buffers have not been registered.
+		return -EINVAL;
+
+	ret = coda_vpu_decode(inst, param);
+
+	return ret;
+}
+
+static int coda_vpu_dec_start_frame(struct vpu_instance *inst,
+				    struct stateless_info *info)
+{
+	int ret;
+	struct vb2_v4l2_buffer *src_buf, *dst_buf;
+	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
+	struct dec_param pic_param;
+
+	if (inst->std == STD_AVC)
+		pic_param.h264 = info->h264;
+	else if (inst->std == STD_MPEG2)
+		pic_param.mpeg2 = info->mpeg2;
+	else if (inst->std == STD_VP8)
+		pic_param.vp8 = info->vp8;
+	else {
+		dev_err(inst->dev->dev, "unknown codec\n");
+		return -EINVAL;
+	}
+
+	src_buf = info->src;
+	if (src_buf) {
+		u8 *src_addr = vb2_plane_vaddr(&src_buf->vb2_buf, 0);
+		int src_size = vb2_get_plane_payload(&src_buf->vb2_buf, 0);
+		ret = coda_vdi_write_memory(
+			inst->dev, &inst->bitstream_vbuf, 0, src_addr, src_size,
+			p_dec_info->open_param.stream_endian);
+		if (ret <= 0)
+			return -EIO;
+
+		coda_vpu_dec_set_rd_ptr(inst);
+		coda_vpu_dec_set_wr_ptr(inst, src_size);
+	} else
+		return -EINVAL;
+
+	dst_buf = info->dst;
+	if (dst_buf) {
+		void *buf_vaddr_y = NULL;
+		u32 buf_size = 0;
+		dma_addr_t buf_addr_y = 0, buf_addr_cb = 0, buf_addr_cr = 0;
+		u32 fb_stride = inst->dst_fmt.width;
+		u32 luma_size = fb_stride * inst->dst_fmt.height;
+		u32 chroma_size = (fb_stride / 2) * (inst->dst_fmt.height / 2);
+
+		if (inst->dst_fmt.num_planes == 1) {
+			buf_size = vb2_plane_size(&dst_buf->vb2_buf, 0);
+			buf_addr_y = vb2_dma_contig_plane_dma_addr(
+				&dst_buf->vb2_buf, 0);
+			buf_addr_cb = buf_addr_y + luma_size;
+			buf_addr_cr = buf_addr_cb + chroma_size;
+			buf_vaddr_y = vb2_plane_vaddr(&dst_buf->vb2_buf, 0);
+			dev_dbg(inst->dev->dev,
+				"%d.%s.vb2_v4l2_buf:%px.buf_addr_y:0x%llx.cb:0x%llx.cr:0x%llx.buf_size:%d.buf_vaddr_y:%px\n",
+				__LINE__, __func__,
+				(void *)dst_buf,
+				buf_addr_y, buf_addr_cb, buf_addr_cr,
+				buf_size, buf_vaddr_y);
+		} else if (inst->dst_fmt.num_planes == 2) {
+			buf_size = vb2_plane_size(&dst_buf->vb2_buf, 0) +
+				   vb2_plane_size(&dst_buf->vb2_buf, 1);
+			buf_addr_y = vb2_dma_contig_plane_dma_addr(
+				&dst_buf->vb2_buf, 0);
+			buf_addr_cb = vb2_dma_contig_plane_dma_addr(
+				&dst_buf->vb2_buf, 1);
+			buf_addr_cr = buf_addr_cb + chroma_size;
+			dev_dbg(inst->dev->dev,
+				"%d.%s.vb2_v4l2_buf:%px.buf_addr_y:0x%llx.cb:0x%llx.cr:0x%llx.buf_size:%d\n",
+				__LINE__, __func__,
+				(void *)dst_buf,
+				buf_addr_y, buf_addr_cb, buf_addr_cr,
+				buf_size);
+		} else if (inst->dst_fmt.num_planes == 3) {
+			buf_size = vb2_plane_size(&dst_buf->vb2_buf, 0) +
+				   vb2_plane_size(&dst_buf->vb2_buf, 1) +
+				   vb2_plane_size(&dst_buf->vb2_buf, 2);
+			buf_addr_y = vb2_dma_contig_plane_dma_addr(
+				&dst_buf->vb2_buf, 0);
+			buf_addr_cb = vb2_dma_contig_plane_dma_addr(
+				&dst_buf->vb2_buf, 1);
+			buf_addr_cr = vb2_dma_contig_plane_dma_addr(
+				&dst_buf->vb2_buf, 2);
+			dev_dbg(inst->dev->dev,
+				"%d.%s.vb2_v4l2_buf:%px.buf_addr_y:0x%llx.cb:0x%llx.cr:0x%llx.buf_size:%d\n",
+				__LINE__, __func__,
+				(void *)dst_buf,
+				buf_addr_y, buf_addr_cb, buf_addr_cr,
+				buf_size);
+		}
+		pic_param.buf_addr_y = buf_addr_y;
+		pic_param.buf_addr_cb = buf_addr_cb;
+		pic_param.buf_addr_cr = buf_addr_cr;
+	} else
+		return -EINVAL;
+
+	return coda_vpu_dec_start_one_frame(inst, &pic_param);
+}
+
+static void coda_handle_decoded_frame(struct vpu_instance *inst,
+				      dma_addr_t addr)
+{
+	struct vb2_v4l2_buffer *src_buf;
+	struct vb2_v4l2_buffer *dst_buf;
+	struct vpu_buffer *vpu_buf;
+
+	src_buf = v4l2_m2m_next_src_buf(inst->v4l2_fh.m2m_ctx);
+	if (!src_buf) {
+		dev_err(inst->dev->dev, "not found src buffer \n");
+		return;
+	}
+
+	vpu_buf = coda_to_vpu_buf(src_buf);
+	if (!vpu_buf)
+		return;
+
+	dst_buf = coda_get_dst_buf_by_addr(inst, addr);
+	if (dst_buf) {
+		dev_dbg(inst->dev->dev, "copying metadata \n");
+		v4l2_m2m_buf_copy_metadata(src_buf, dst_buf, true);
+	}
+
+	src_buf = v4l2_m2m_src_buf_remove(inst->v4l2_fh.m2m_ctx);
+	dev_dbg(inst->dev->dev,
+		"%d.%s.OUT.v4l2_m2m_buf_done.src_buf:%px\n",
+		__LINE__, __func__,
+		(void *)src_buf);
+	v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);
+}
+
+static void coda_handle_display_frame(struct vpu_instance *inst,
+				      dma_addr_t addr)
+{
+	struct vb2_v4l2_buffer *dst_buf;
+
+	dst_buf = coda_get_dst_buf_by_addr(inst, addr);
+	if (!dst_buf) {
+		dev_err(inst->dev->dev, "not found dsiplay buffer\n");
+		return;
+	}
+
+	if (inst->dst_fmt.num_planes == 1) {
+		vb2_set_plane_payload(&dst_buf->vb2_buf, 0,
+				      inst->dst_fmt.plane_fmt[0].sizeimage);
+	} else if (inst->dst_fmt.num_planes == 2) {
+		vb2_set_plane_payload(&dst_buf->vb2_buf, 0,
+				      inst->dst_fmt.plane_fmt[0].sizeimage);
+		vb2_set_plane_payload(&dst_buf->vb2_buf, 1,
+				      inst->dst_fmt.plane_fmt[1].sizeimage);
+	} else if (inst->dst_fmt.num_planes == 3) {
+		vb2_set_plane_payload(&dst_buf->vb2_buf, 0,
+				      inst->dst_fmt.plane_fmt[0].sizeimage);
+		vb2_set_plane_payload(&dst_buf->vb2_buf, 1,
+				      inst->dst_fmt.plane_fmt[1].sizeimage);
+		vb2_set_plane_payload(&dst_buf->vb2_buf, 2,
+				      inst->dst_fmt.plane_fmt[2].sizeimage);
+	}
+
+	dst_buf->field = V4L2_FIELD_NONE;
+	v4l2_m2m_dst_buf_remove_by_buf(inst->v4l2_fh.m2m_ctx, dst_buf);
+	dev_dbg(inst->dev->dev,
+		"%d.%s.CAP.v4l2_m2m_buf_done.dst_buf:%px\n",
+		__LINE__, __func__,
+		(void *)dst_buf);
+	v4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);
+}
+
+static int coda_vpu_dec_get_info(struct vpu_instance *inst,
+				 struct stateless_info *info)
+{
+	int ret;
+	struct dec_output_info dec_info;
+
+	memset(&dec_info, 0x00, sizeof(dec_info));
+
+	ret = coda_vpu_dec_get_result(inst, &dec_info);
+	if (ret)
+		return ret;
+
+	dev_dbg(inst->dev->dev, "decoding_success : %d \n",
+		 dec_info.decoding_success);
+	dev_dbg(inst->dev->dev,
+		 "width: %d, height: %d, pic type:%d num_of_err_mbs:%d \n",
+		 dec_info.pic_width, dec_info.pic_height, dec_info.pic_type,
+		 dec_info.num_of_err_mbs);
+	dev_dbg(inst->dev->dev,
+		 "index_frame_decoded:%d, index_frame_display:%d \n",
+		 dec_info.index_frame_decoded, dec_info.index_frame_display);
+	dev_dbg(inst->dev->dev, "dec_info.buf_addr_y: %llx \n",
+		 dec_info.buf_addr_y);
+	dev_dbg(inst->dev->dev, "dec_info.buf_addr_cb: %llx \n",
+		 dec_info.buf_addr_cb);
+	dev_dbg(inst->dev->dev, "dec_info.buf_addr_cr: %llx \n",
+		 dec_info.buf_addr_cr);
+	dev_dbg(inst->dev->dev, "dec_info.avc_poc_pic: %d \n",
+		 dec_info.avc_poc_pic);
+
+	coda_handle_decoded_frame(inst, dec_info.buf_addr_y);
+	coda_handle_display_frame(inst, dec_info.buf_addr_y);
+
+	return 0;
+}
+
+static void coda_vpu_dec_return_buf(struct vpu_instance *inst,
+				    struct stateless_info *info,
+				    enum vb2_buffer_state state)
+{
+	v4l2_m2m_buf_remove_by_buf(&inst->v4l2_fh.m2m_ctx->out_q_ctx,
+				   info->src);
+	v4l2_m2m_buf_remove_by_buf(&inst->v4l2_fh.m2m_ctx->cap_q_ctx,
+				   info->dst);
+	dev_dbg(inst->dev->dev,
+		"%d.%s.v4l2_m2m_buf_done.error.src_buf:%px.dst_buf:%px\n",
+		__LINE__, __func__,
+		(void *)info->src, (void *)info->dst);
+	v4l2_m2m_buf_done(info->src, VB2_BUF_STATE_ERROR);
+	v4l2_m2m_buf_done(info->dst, VB2_BUF_STATE_ERROR);
+}
+
+static int coda_vpu_dec_start_decode(struct vpu_instance *inst)
+{
+	int ret = 0;
+	struct stateless_info info = {};
+	struct media_request *src_req;
+	struct dec_initial_info initial_info;
+
+	dev_dbg(inst->dev->dev, "%d.%s.enter\n", __LINE__, __func__);
+
+	if (inst->state == VPU_INST_STATE_NONE) {
+		dev_dbg(inst->dev->dev, "%d.%s.VPU_INST_STATE_NONE\n", __LINE__,
+				__func__);
+		ret = coda_vpu_dec_allocate_ring_buffer(inst);
+		if (ret)
+			goto exit;
+
+		ret = coda_vpu_dec_create_instance(inst);
+		if (ret)
+			goto exit;
+	}
+
+	info.src = v4l2_m2m_next_src_buf(inst->v4l2_fh.m2m_ctx);
+	info.dst = v4l2_m2m_next_dst_buf(inst->v4l2_fh.m2m_ctx);
+
+	src_req = info.src->vb2_buf.req_obj.req;
+
+	if (src_req)
+		v4l2_ctrl_request_setup(src_req, &inst->v4l2_ctrl_hdl);
+
+	switch (inst->std) {
+	case STD_MPEG2:
+		info.mpeg2.seq = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_MPEG2_SEQUENCE);
+		info.mpeg2.pic = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_MPEG2_PICTURE);
+		info.mpeg2.quant = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_MPEG2_QUANTISATION);
+		break;
+	case STD_VP8:
+		info.vp8.frame = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_VP8_FRAME);
+		break;
+	case STD_AVC:
+		info.h264.sps = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_H264_SPS);
+		info.h264.pps = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_H264_PPS);
+		info.h264.sm = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_H264_SCALING_MATRIX);
+		info.h264.dpram = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_H264_DECODE_PARAMS);
+		break;
+	default:
+		break;
+	}
+
+	if (src_req)
+		v4l2_ctrl_request_complete(src_req, &inst->v4l2_ctrl_hdl);
+
+	switch (inst->state) {
+	case VPU_INST_STATE_OPEN:
+		dev_dbg(inst->dev->dev, "%d.%s.VPU_INST_STATE_OPEN\n", __LINE__,
+			__func__);
+		ret = mutex_lock_interruptible(&inst->dev->hw_lock);
+		if (ret)
+			return ret;
+
+		ret = coda_vpu_dec_issue_seq_init(inst, &info);
+		if (ret) {
+			mutex_unlock(&inst->dev->hw_lock);
+			break;
+		}
+
+		if (coda_vpu_wait_interrupt(inst, VPU_DEC_TIMEOUT) < 0) {
+			dev_err(inst->dev->dev,
+				"%d.%s.failed to call vpu_wait_interrupt()\n",
+				__LINE__, __func__);
+			coda_debug_register(inst->dev, inst, DEC_SEQ_INIT, 0);
+			mutex_unlock(&inst->dev->hw_lock);
+			break;
+		}
+
+		memset(&initial_info, 0, sizeof(struct dec_initial_info));
+		ret = coda_vpu_dec_complete_seq_init(inst, &initial_info);
+		mutex_unlock(&inst->dev->hw_lock);
+		if (ret)
+			break;
+
+		inst->state = VPU_INST_STATE_INIT_SEQ;
+
+		fallthrough;
+	case VPU_INST_STATE_INIT_SEQ:
+		dev_dbg(inst->dev->dev, "%d.%s.VPU_INST_STATE_INIT_SEQ\n",
+			__LINE__, __func__);
+		ret = coda_prepare_fb(inst);
+		if (ret)
+			break;
+
+		fallthrough;
+	case VPU_INST_STATE_PIC_RUN:
+		dev_dbg(inst->dev->dev, "%d.%s.VPU_INST_STATE_PIC_RUN\n",
+			__LINE__, __func__);
+		if (inst->std == STD_MPEG2 &&
+		    (info.mpeg2.pic->picture_structure == 1 ||
+		     info.mpeg2.pic->picture_structure == 2)) {
+			dev_err(inst->dev->dev,
+				"not support field encoded stream of mpeg2 \n");
+			coda_vpu_dec_return_buf(inst, &info,
+						VB2_BUF_STATE_ERROR);
+			return 0;
+		}
+
+		ret = mutex_lock_interruptible(&inst->dev->hw_lock);
+		if (ret)
+			return ret;
+
+		ret = coda_vpu_dec_start_frame(inst, &info);
+		if (ret) {
+			coda_vpu_dec_return_buf(inst, &info,
+						VB2_BUF_STATE_ERROR);
+			mutex_unlock(&inst->dev->hw_lock);
+			break;
+		}
+
+		if (coda_vpu_wait_interrupt(inst, VPU_DEC_TIMEOUT) < 0) {
+			dev_err(inst->dev->dev,
+				"%d.%s.failed to call vpu_wait_interrupt()\n",
+				__LINE__, __func__);
+			mutex_unlock(&inst->dev->hw_lock);
+			break;
+		}
+#ifdef DEBUG_STATELESS // debugging
+		coda_debug_register(inst->dev, inst, PIC_RUN, 0);
+#endif
+		coda_vpu_dec_get_info(inst, &info);
+
+		mutex_unlock(&inst->dev->hw_lock);
+		break;
+	default:
+		break;
+	}
+exit:
+	dev_dbg(inst->dev->dev, "%d.%s.leave.ret:%d\n", __LINE__, __func__,
+		ret);
+	return ret;
+}
+
+static void coda_vpu_dec_stop_decode(struct vpu_instance *inst)
+{
+	dev_dbg(inst->dev->dev, "%s: state %d\n", __func__, inst->state);
+
+	inst->state = VPU_INST_STATE_STOP;
+}
+
+static const struct vpu_instance_ops coda_vpu_dec_inst_ops = {
+	.start_process = coda_vpu_dec_start_decode,
+	.stop_process = coda_vpu_dec_stop_decode,
+	.finish_process = NULL,
+};
+
+static int init_ctrls_list(struct vpu_instance *ctx)
+{
+	int i;
+	int j;
+	int ctrls_cnt = 0;
+	const struct sl_ctrls *ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctx->v4l2_ctrl_hdl;
+
+	for (i = 0; i < MAX_CTRL_LIST; i++) {
+		ctrls_cnt += sl_ctrls_list[i]->num_ctrls;
+	}
+	v4l2_ctrl_handler_init(hdl, ctrls_cnt);
+
+	for (i = 0; i < MAX_CTRL_LIST; i++) {
+		ctrls = sl_ctrls_list[i];
+		for (j = 0; j < ctrls->num_ctrls; j++)
+			v4l2_ctrl_new_custom(hdl, &ctrls->ctrls[j].cfg, NULL);
+	}
+
+	if (hdl->error) {
+		dev_err(ctx->dev->dev,
+			"Failed to initialize control handler\n");
+		v4l2_ctrl_handler_free(hdl);
+		return hdl->error;
+	}
+
+	ctx->v4l2_fh.ctrl_handler = hdl;
+	v4l2_ctrl_handler_setup(hdl);
+
+	return 0;
+}
+
+static int coda_vpu_open_dec(struct file *filp)
+{
+	struct video_device *vdev = video_devdata(filp);
+	struct vpu_device *dev = video_drvdata(filp);
+	struct vpu_instance *inst = NULL;
+	int ret;
+
+	inst = kzalloc(sizeof(*inst), GFP_KERNEL);
+	if (!inst)
+		return -ENOMEM;
+
+	inst->dev = dev;
+	inst->type = VPU_INST_TYPE_DEC;
+	inst->ops = &coda_vpu_dec_inst_ops;
+
+	v4l2_fh_init(&inst->v4l2_fh, vdev);
+	filp->private_data = &inst->v4l2_fh;
+	v4l2_fh_add(&inst->v4l2_fh);
+
+	inst->v4l2_fh.m2m_ctx =
+		v4l2_m2m_ctx_init(dev->m2m_dev, inst, coda_vpu_dec_queue_init);
+	if (IS_ERR(inst->v4l2_fh.m2m_ctx)) {
+		ret = PTR_ERR(inst->v4l2_fh.m2m_ctx);
+		goto free_inst;
+	}
+
+	if (init_ctrls_list(inst)) {
+		ret = -ENODEV;
+		goto err_m2m_release;
+	}
+
+	coda_set_default_format(&inst->src_fmt, &inst->dst_fmt);
+	inst->colorspace = V4L2_COLORSPACE_DEFAULT;
+	inst->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	inst->quantization = V4L2_QUANTIZATION_DEFAULT;
+	inst->xfer_func = V4L2_XFER_FUNC_DEFAULT;
+
+	init_completion(&inst->irq_done);
+
+	inst->id = ida_alloc(&inst->dev->inst_ida, GFP_KERNEL);
+	if (inst->id < 0) {
+		dev_warn(inst->dev->dev, "Allocating instance ID, fail: %d\n",
+			 inst->id);
+		ret = inst->id;
+		goto cleanup_inst;
+	}
+
+	ret = mutex_lock_interruptible(&dev->dev_lock);
+	if (ret)
+		goto cleanup_inst;
+
+	mutex_unlock(&dev->dev_lock);
+	return 0;
+
+cleanup_inst:
+	v4l2_ctrl_handler_free(&inst->v4l2_ctrl_hdl);
+err_m2m_release:
+	v4l2_m2m_ctx_release(inst->v4l2_fh.m2m_ctx);
+free_inst:
+	kfree(inst);
+
+	return ret;
+}
+
+static void coda_vpu_dec_destroy_instance(struct vpu_instance *inst)
+{
+	u32 fail_res;
+	int ret;
+
+	ret = coda_vpu_dec_close(inst, &fail_res);
+	if (ret) {
+		dev_err(inst->dev->dev, "failed destroy instance: %d (%d)\n",
+			ret, fail_res);
+	}
+
+	coda_vpu_dec_release_fb(inst);
+	coda_vdi_free_dma_memory(inst->dev, &inst->work_vbuf);
+	coda_vdi_free_dma_memory(inst->dev, &inst->temp_vbuf);
+	coda_vdi_free_dma_memory(inst->dev, &inst->vui_vbuf);
+	coda_vdi_free_dma_memory(inst->dev, &inst->bitstream_vbuf);
+
+	inst->state = VPU_INST_STATE_NONE;
+}
+
+static int coda_vpu_dec_release(struct file *filp)
+{
+	struct vpu_instance *inst = coda_to_vpu_inst(filp->private_data);
+
+	mutex_lock(&inst->dev->dev_lock);
+	if (inst->state != VPU_INST_STATE_NONE) {
+		v4l2_m2m_suspend(inst->dev->m2m_dev);
+		coda_vpu_dec_destroy_instance(inst);
+		v4l2_m2m_resume(inst->dev->m2m_dev);
+	}
+	mutex_unlock(&inst->dev->dev_lock);
+
+	v4l2_m2m_ctx_release(inst->v4l2_fh.m2m_ctx);
+	v4l2_ctrl_handler_free(&inst->v4l2_ctrl_hdl);
+	v4l2_fh_del(&inst->v4l2_fh);
+	v4l2_fh_exit(&inst->v4l2_fh);
+	ida_free(&inst->dev->inst_ida, inst->id);
+	kfree(inst);
+
+	return 0;
+}
+
+static const struct v4l2_file_operations coda_vpu_dec_fops = {
+	.owner = THIS_MODULE,
+	.open = coda_vpu_open_dec,
+	.release = coda_vpu_dec_release,
+	.unlocked_ioctl = video_ioctl2,
+	.poll = v4l2_m2m_fop_poll,
+	.mmap = v4l2_m2m_fop_mmap,
+};
+
+int coda_vpu_dec_register_device(struct vpu_device *dev)
+{
+	struct video_device *vdev_dec;
+	int ret;
+
+	vdev_dec =
+		devm_kzalloc(dev->v4l2_dev.dev, sizeof(*vdev_dec), GFP_KERNEL);
+	if (!vdev_dec)
+		return -ENOMEM;
+
+	dev->video_dev_dec = vdev_dec;
+
+	strscpy(vdev_dec->name, VPU_DEC_DEV_NAME, sizeof(vdev_dec->name));
+	vdev_dec->fops = &coda_vpu_dec_fops;
+	vdev_dec->ioctl_ops = &coda_vpu_dec_ioctl_ops;
+	vdev_dec->release = video_device_release_empty;
+	vdev_dec->v4l2_dev = &dev->v4l2_dev;
+	vdev_dec->vfl_dir = VFL_DIR_M2M;
+	vdev_dec->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;
+	vdev_dec->lock = &dev->dev_lock;
+
+	video_set_drvdata(vdev_dec, dev);
+
+	ret = video_register_device(vdev_dec, VFL_TYPE_VIDEO, -1);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+void coda_vpu_dec_unregister_device(struct vpu_device *dev)
+{
+	video_unregister_device(dev->video_dev_dec);
+}
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-vdi.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-vdi.c
@@ -0,0 +1,209 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Coda980 series multi-standard codec IP - decoder interface
+ *
+ * Copyright (C) 2024 CHIPS&MEDIA INC
+ */
+#include <linux/bug.h>
+#include <linux/delay.h>
+
+#include "coda-vdi.h"
+#include "coda-vpuconfig.h"
+#include "coda-regdefine.h"
+#include "coda-vpuapi.h"
+
+#define VDI_SYSTEM_ENDIAN VDI_LITTLE_ENDIAN
+#define VDI_128BIT_BUS_SYSTEM_ENDIAN VDI_128BIT_LITTLE_ENDIAN
+
+static int vdi_convert_endian(unsigned int endian)
+{
+	return (endian & 0x0f);
+}
+
+static uint32_t convert_endian_coda9_to_wave4(uint32_t endian)
+{
+	uint32_t converted_endian = endian;
+	switch (endian) {
+	case VDI_LITTLE_ENDIAN:
+		converted_endian = 0;
+		break;
+	case VDI_BIG_ENDIAN:
+		converted_endian = 7;
+		break;
+	case VDI_32BIT_LITTLE_ENDIAN:
+		converted_endian = 4;
+		break;
+	case VDI_32BIT_BIG_ENDIAN:
+		converted_endian = 3;
+		break;
+	}
+	return converted_endian;
+}
+
+static void byte_swap(unsigned char *data, int len)
+{
+	u8 temp;
+	int i;
+
+	for (i = 0; i < len; i += 2) {
+		temp = data[i];
+		data[i] = data[i + 1];
+		data[i + 1] = temp;
+	}
+}
+
+static void word_swap(unsigned char *data, int len)
+{
+	u16 temp;
+	u16 *ptr = (u16 *)data;
+	int i;
+	s32 size = len / sizeof(uint16_t);
+
+	for (i = 0; i < size; i += 2) {
+		temp = ptr[i];
+		ptr[i] = ptr[i + 1];
+		ptr[i + 1] = temp;
+	}
+}
+
+static void dword_swap(unsigned char *data, int len)
+{
+	u32 temp;
+	u32 *ptr = (u32 *)data;
+	s32 size = len / sizeof(uint32_t);
+	int i;
+
+	for (i = 0; i < size; i += 2) {
+		temp = ptr[i];
+		ptr[i] = ptr[i + 1];
+		ptr[i + 1] = temp;
+	}
+}
+
+static void lword_swap(unsigned char *data, int len)
+{
+	u64 temp;
+	u64 *ptr = (u64 *)data;
+	s32 size = len / sizeof(uint64_t);
+	int i;
+
+	for (i = 0; i < size; i += 2) {
+		temp = ptr[i];
+		ptr[i] = ptr[i + 1];
+		ptr[i + 1] = temp;
+	}
+}
+
+static int coda_swap_endian(unsigned char *data, int len, int endian)
+{
+	int changes;
+	int sys_endian;
+	bool byteChange, wordChange, dwordChange, lwordChange;
+
+	sys_endian = VDI_SYSTEM_ENDIAN;
+
+	endian = vdi_convert_endian(endian);
+	sys_endian = vdi_convert_endian(sys_endian);
+	if (endian == sys_endian)
+		return 0;
+
+	endian = convert_endian_coda9_to_wave4(endian);
+	sys_endian = convert_endian_coda9_to_wave4(sys_endian);
+
+	changes = endian ^ sys_endian;
+	byteChange = changes & 0x01;
+	wordChange = ((changes & 0x02) == 0x02);
+	dwordChange = ((changes & 0x04) == 0x04);
+	lwordChange = ((changes & 0x08) == 0x08);
+
+	if (byteChange)
+		byte_swap(data, len);
+	if (wordChange)
+		word_swap(data, len);
+	if (dwordChange)
+		dword_swap(data, len);
+	if (lwordChange)
+		lword_swap(data, len);
+
+	return 1;
+}
+
+int coda_vdi_write_memory(struct vpu_device *vpu_dev, struct vpu_buf *vb,
+			  size_t offset, u8 *data, int len, int endian)
+{
+	if (!vb || !vb->vaddr) {
+		dev_err(vpu_dev->dev,
+			"%s(): unable to write to unmapped buffer\n", __func__);
+		return -EINVAL;
+	}
+
+	if (offset > vb->size || len > vb->size || offset + len > vb->size) {
+		dev_err(vpu_dev->dev, "%s(): buffer too small\n", __func__);
+		return -ENOSPC;
+	}
+
+	coda_swap_endian(data, len, endian);
+	memcpy(vb->vaddr + offset, data, len);
+	return len;
+}
+
+int coda_vdi_read_memory(struct vpu_device *vpu_dev, struct vpu_buf *vb,
+			 size_t offset, u8 *data, int len, int endian)
+{
+	if (!vb || !vb->vaddr) {
+		dev_err(vpu_dev->dev,
+			"%s(): unable to write to unmapped buffer\n", __func__);
+		return -EINVAL;
+	}
+
+	if (offset > vb->size || len > vb->size || offset + len > vb->size) {
+		dev_err(vpu_dev->dev, "%s(): buffer too small\n", __func__);
+		return -ENOSPC;
+	}
+	memcpy(data, vb->vaddr + offset, len);
+	coda_swap_endian(data, len, endian);
+	return len;
+}
+
+int coda_vdi_allocate_dma_memory(struct vpu_device *vpu_dev, struct vpu_buf *vb)
+{
+	void *vaddr;
+	dma_addr_t daddr;
+
+	if (!vb->size) {
+		dev_err(vpu_dev->dev, "%s(): requested size==0\n", __func__);
+		return -EINVAL;
+	}
+	vaddr = dma_alloc_coherent(vpu_dev->dev, vb->size, &daddr, GFP_KERNEL);
+	if (!vaddr)
+		return -ENOMEM;
+	vb->vaddr = vaddr;
+	vb->daddr = daddr;
+
+	return 0;
+}
+
+void coda_vdi_free_dma_memory(struct vpu_device *vpu_dev, struct vpu_buf *vb)
+{
+	if (vb->size == 0)
+		return;
+
+	if (!vb->vaddr)
+		dev_err(vpu_dev->dev,
+			"%s(): requested free of unmapped buffer\n", __func__);
+	else
+		dma_free_coherent(vpu_dev->dev, vb->size, vb->vaddr, vb->daddr);
+
+	memset(vb, 0, sizeof(*vb));
+}
+
+void coda_vdi_writel(struct vpu_device *vpu_dev, unsigned int addr,
+		     unsigned int data)
+{
+	writel(data, vpu_dev->vdb_register + addr);
+}
+
+unsigned int coda_vdi_readl(struct vpu_device *vpu_dev, u32 addr)
+{
+	return readl(vpu_dev->vdb_register + addr);
+}
\ No newline at end of file
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-vdi.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-vdi.h
@@ -0,0 +1,51 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Coda980 series multi-standard codec IP - decoder interface
+ *
+ * Copyright (C) 2024 CHIPS&MEDIA INC
+ */
+#ifndef CODA_VDI_H
+#define CODA_VDI_H
+
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+
+/* system register write */
+#define vpu_write_reg(VPU_INST, ADDR, DATA)                                    \
+	coda_vdi_writel(VPU_INST, ADDR, DATA)
+/* system register read */
+#define vpu_read_reg(CORE, ADDR) coda_vdi_readl(CORE, ADDR)
+
+struct vpu_buf {
+	size_t size;
+	dma_addr_t daddr;
+	void *vaddr;
+};
+
+enum endian_mode {
+	VDI_LITTLE_ENDIAN = 0, /* 64bit LE */
+	VDI_BIG_ENDIAN, /* 64bit BE */
+	VDI_32BIT_LITTLE_ENDIAN,
+	VDI_32BIT_BIG_ENDIAN,
+	/* WAVE PRODUCTS */
+	VDI_128BIT_LITTLE_ENDIAN = 16,
+	VDI_128BIT_LE_BYTE_SWAP,
+	VDI_128BIT_LE_WORD_SWAP,
+	VDI_128BIT_LE_WORD_BYTE_SWAP,
+	VDI_128BIT_LE_DWORD_SWAP,
+	VDI_128BIT_LE_DWORD_BYTE_SWAP,
+	VDI_128BIT_LE_DWORD_WORD_SWAP,
+	VDI_128BIT_LE_DWORD_WORD_BYTE_SWAP,
+	VDI_128BIT_BE_DWORD_WORD_BYTE_SWAP,
+	VDI_128BIT_BE_DWORD_WORD_SWAP,
+	VDI_128BIT_BE_DWORD_BYTE_SWAP,
+	VDI_128BIT_BE_DWORD_SWAP,
+	VDI_128BIT_BE_WORD_BYTE_SWAP,
+	VDI_128BIT_BE_WORD_SWAP,
+	VDI_128BIT_BE_BYTE_SWAP,
+	VDI_128BIT_BIG_ENDIAN = 31,
+	VDI_ENDIAN_MAX
+};
+
+#endif
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-vpu-v4l2.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-vpu-v4l2.c
@@ -0,0 +1,146 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Coda series multi-standard codec IP - v4l2 interface
+ *
+ * Copyright (C) 2024 CHIPS&MEDIA INC
+ */
+#include "coda-vpu.h"
+
+static void coda_vpu_device_run_timeout(struct work_struct *work)
+{
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct vpu_device *dev =
+		container_of(dwork, struct vpu_device, task_timer);
+	struct vpu_instance *inst = v4l2_m2m_get_curr_priv(dev->m2m_dev);
+	struct vb2_v4l2_buffer *src_buf = NULL;
+	struct vb2_v4l2_buffer *dst_buf = NULL;
+
+	if (!inst)
+		return;
+
+	src_buf = v4l2_m2m_src_buf_remove(inst->v4l2_fh.m2m_ctx);
+	if (src_buf)
+		v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);
+
+	dst_buf = v4l2_m2m_dst_buf_remove(inst->v4l2_fh.m2m_ctx);
+	if (dst_buf)
+		v4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);
+
+	v4l2_m2m_job_finish(inst->dev->m2m_dev, inst->v4l2_fh.m2m_ctx);
+}
+
+static void coda_vpu_device_run(void *priv)
+{
+	struct vpu_instance *inst = priv;
+	int ret;
+
+	dev_dbg(inst->dev->dev, "[%d]%s: state %d\n", inst->id, __func__,
+		inst->state);
+
+	ret = inst->ops->start_process(inst);
+	if (ret == -ENOMEM)
+		inst->state = VPU_INST_STATE_STOP;
+
+	v4l2_m2m_job_finish(inst->dev->m2m_dev, inst->v4l2_fh.m2m_ctx);
+}
+
+static int coda_vpu_job_ready(void *priv)
+{
+	struct vpu_instance *inst = priv;
+
+	dev_dbg(inst->dev->dev, "[%d]%s: state %d\n", inst->id, __func__,
+		inst->state);
+
+	if (inst->state == VPU_INST_STATE_STOP)
+		return 0;
+
+	return 1;
+}
+
+static void coda_vpu_job_abort(void *priv)
+{
+	struct vpu_instance *inst = priv;
+
+	dev_dbg(inst->dev->dev, "[%d]%s: state %d\n", inst->id, __func__,
+		inst->state);
+
+	inst->ops->stop_process(inst);
+}
+
+static const struct v4l2_m2m_ops coda_vpu_m2m_ops = {
+	.device_run = coda_vpu_device_run,
+	.job_ready = coda_vpu_job_ready,
+	.job_abort = coda_vpu_job_abort,
+};
+
+int coda_vpu_init_m2m_dev(struct vpu_device *dev)
+{
+	dev->m2m_dev = v4l2_m2m_init(&coda_vpu_m2m_ops);
+	if (IS_ERR(dev->m2m_dev)) {
+		dev_err(dev->dev, "v4l2_m2m_init fail: %ld\n",
+			PTR_ERR(dev->m2m_dev));
+		return PTR_ERR(dev->m2m_dev);
+	}
+
+	INIT_DELAYED_WORK(&dev->task_timer, coda_vpu_device_run_timeout);
+
+	return 0;
+}
+
+void coda_vpu_release_m2m_dev(struct vpu_device *dev)
+{
+	v4l2_m2m_release(dev->m2m_dev);
+}
+
+void coda_return_bufs(struct vb2_queue *q, u32 state)
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(q);
+	struct v4l2_m2m_ctx *m2m_ctx = inst->v4l2_fh.m2m_ctx;
+	struct v4l2_ctrl_handler v4l2_ctrl_hdl = inst->v4l2_ctrl_hdl;
+	struct vb2_v4l2_buffer *vbuf;
+
+	for (;;) {
+		if (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+			vbuf = v4l2_m2m_src_buf_remove(m2m_ctx);
+		else
+			vbuf = v4l2_m2m_dst_buf_remove(m2m_ctx);
+		if (!vbuf)
+			return;
+		v4l2_ctrl_request_complete(vbuf->vb2_buf.req_obj.req,
+					   &v4l2_ctrl_hdl);
+		v4l2_m2m_buf_done(vbuf, state);
+	}
+}
+
+int coda_vpu_wait_interrupt(struct vpu_instance *inst, unsigned int timeout)
+{
+	int ret;
+
+	ret = wait_for_completion_timeout(&inst->dev->irq_done,
+					  msecs_to_jiffies(timeout));
+	if (!ret)
+		return -ETIMEDOUT;
+
+	reinit_completion(&inst->dev->irq_done);
+
+	return 0;
+}
+
+struct vb2_v4l2_buffer *coda_get_dst_buf_by_addr(struct vpu_instance *inst,
+						 dma_addr_t addr)
+{
+	struct vb2_v4l2_buffer *vb2_v4l2_buf;
+	struct v4l2_m2m_buffer *v4l2_m2m_buf;
+	struct vb2_v4l2_buffer *dst_buf = NULL;
+
+	v4l2_m2m_for_each_dst_buf (inst->v4l2_fh.m2m_ctx, v4l2_m2m_buf) {
+		vb2_v4l2_buf = &v4l2_m2m_buf->vb;
+		if (addr ==
+		    vb2_dma_contig_plane_dma_addr(&vb2_v4l2_buf->vb2_buf, 0)) {
+			dst_buf = vb2_v4l2_buf;
+			break;
+		}
+	}
+
+	return dst_buf;
+}
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-vpu.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-vpu.h
@@ -0,0 +1,51 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Coda980 series multi-standard codec IP - decoder interface
+ *
+ * Copyright (C) 2024 CHIPS&MEDIA INC
+ */
+#ifndef CODA_VPU_H
+#define CODA_VPU_H
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fh.h>
+#include <media/videobuf2-v4l2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/videobuf2-vmalloc.h>
+#include "coda-vpuconfig.h"
+#include "coda-vpuapi.h"
+
+struct vpu_buffer {
+	struct v4l2_m2m_buffer v4l2_m2m_buf;
+	bool consumed;
+};
+
+enum vpu_fmt_type { VPU_FMT_TYPE_CODEC = 0, VPU_FMT_TYPE_RAW = 1 };
+
+struct vpu_format {
+	unsigned int v4l2_pix_fmt;
+	unsigned int max_width;
+	unsigned int min_width;
+	unsigned int max_height;
+	unsigned int min_height;
+	unsigned int num_planes;
+};
+
+static inline struct vpu_buffer *coda_to_vpu_buf(struct vb2_v4l2_buffer *vbuf)
+{
+	return container_of(vbuf, struct vpu_buffer, v4l2_m2m_buf.vb);
+}
+
+static inline struct vpu_instance *coda_to_vpu_inst(struct v4l2_fh *vfh)
+{
+	return container_of(vfh, struct vpu_instance, v4l2_fh);
+}
+
+int coda_vpu_dec_register_device(struct vpu_device *dev);
+void coda_vpu_dec_unregister_device(struct vpu_device *dev);
+void coda_vpu_release_m2m_dev(struct vpu_device *dev);
+void coda_vpu_dec_unregister_device(struct vpu_device *dev);
+
+#endif
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-vpuapi.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-vpuapi.h
@@ -0,0 +1,1060 @@
+/* SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause) */
+/*
+ * Coda980 series multi-standard codec IP - helper definitions
+ *
+ * Copyright (C) 2024 CHIPS&MEDIA INC
+ */
+
+#ifndef CODA_VPUAPI_H
+#define CODA_VPUAPI_H
+
+#include <linux/kfifo.h>
+#include <linux/idr.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/v4l2-ctrls.h>
+#include "coda-vpuconfig.h"
+#include "coda-vdi.h"
+
+#define DISPLAY_IDX_FLAG_SEQ_END -1
+#define DISPLAY_IDX_FLAG_NO_FB -3
+#define DECODED_IDX_FLAG_NO_FB -1
+#define DECODED_IDX_FLAG_SKIP -2
+#define DECODED_IDX_FLAG_FLUSHED -3
+
+#define RECON_IDX_FLAG_ENC_END -1
+#define RECON_IDX_FLAG_ENC_DELAY -2
+#define RECON_IDX_FLAG_HEADER_ONLY -3
+#define RECON_IDX_FLAG_CHANGE_PARAM -4
+
+enum product_id {
+	PRODUCT_ID_980,
+	PRODUCT_ID_960 = 1,
+	PRODUCT_ID_NONE,
+};
+
+enum codec_command {
+	DEC_SET_STATELESS_WIDTH,
+	DEC_SET_STATELESS_HEGIHT,
+	DEC_SET_STATELESS_NUM_FRAMES,
+	DEC_SET_STATELESS_PROFILE,
+	DEC_RESET_FRAMEBUF_INFO,
+};
+struct vpu_attr {
+	u32 product_id;
+	char product_name[8]; /* product name in ascii code */
+	u32 product_version;
+	u32 fw_version;
+	u32 customer_id;
+	u32 support_decoders; /* bitmask */
+	u32 support_encoders; /* bitmask */
+	u32 support_backbone : 1;
+	u32 support_avc10bit_enc : 1;
+	u32 support_hevc10bit_enc : 1;
+	u32 support_vcore_backbone : 1;
+	u32 support_vcpu_backbone : 1;
+};
+
+enum vpu_instance_type { VPU_INST_TYPE_DEC = 0, VPU_INST_TYPE_ENC = 1 };
+
+enum vpu_instance_state {
+	VPU_INST_STATE_NONE = 0,
+	VPU_INST_STATE_OPEN = 1,
+	VPU_INST_STATE_INIT_SEQ = 2,
+	VPU_INST_STATE_PIC_RUN = 3,
+	VPU_INST_STATE_SEEK = 4,
+	VPU_INST_STATE_STOP = 5
+};
+
+#define CODA_MAX_FBS 31
+
+/*
+ * common struct and definition
+ */
+enum { AVC_DEC = 0,
+       MP2_DEC = 2,
+       VPX_DEC = 7,
+       MAX_DEC = 7,
+       MAX_CODECS,
+};
+
+enum cod_std {
+	STD_AVC,
+	STD_VC1,
+	STD_MPEG2,
+	STD_MPEG4,
+	STD_H263,
+	STD_DIV3,
+	STD_RV,
+	STD_AVS,
+	STD_THO = 9,
+	STD_VP3,
+	STD_VP8,
+	STD_HEVC,
+	STD_VP9,
+	STD_AVS2,
+	STD_MAX
+};
+
+enum { VPX_AUX_THO = 0, VPX_AUX_VP6 = 1, VPX_AUX_VP8 = 2, VPX_AUX_NUM };
+
+enum tiled_map_type {
+	LINEAR_FRAME_MAP = 0, /**< Linear frame map type */
+	TILED_FRAME_V_MAP =
+		1, /**< Tiled frame vertical map type (CODA9 only) */
+	TILED_FRAME_H_MAP =
+		2, /**< Tiled frame horizontal map type (CODA9 only) */
+	TILED_FIELD_V_MAP =
+		3, /**< Tiled field vertical map type (CODA9 only) */
+	TILED_MIXED_V_MAP =
+		4, /**< Tiled mixed vertical map type (CODA9 only) */
+	TILED_FRAME_MB_RASTER_MAP =
+		5, /**< Tiled frame MB raster map type (CODA9 only) */
+	TILED_FIELD_MB_RASTER_MAP =
+		6, /**< Tiled field MB raster map type (CODA9 only) */
+	TILED_FRAME_NO_BANK_MAP = 7,
+	/**< Tiled frame no bank map. (CODA9 only) */ // coda980 only
+	TILED_FIELD_NO_BANK_MAP = 8,
+	/**< Tiled field no bank map. (CODA9 only) */ // coda980 only
+	LINEAR_FIELD_MAP = 9,
+	/**< Linear field map type. (CODA9 only) */ // coda980 only
+	CODA_TILED_MAP_TYPE_MAX = 10,
+	COMPRESSED_FRAME_MAP = 10,
+	/**< Compressed frame map type (WAVE only) */ // WAVE4 only
+	ARM_COMPRESSED_FRAME_MAP = 12,
+	/**< AFBC(ARM Frame Buffer Compression) compressed frame map type */ // AFBC enabled WAVE decoder
+	TILED_MAP_TYPE_MAX
+};
+
+enum frame_flag {
+	FF_NONE =
+		0, /**< Frame buffer type when tiled2linear or wtlEnable is disabled */
+	FF_FRAME = 1, /**< Frame buffer type to store one frame */
+	FF_FIELD =
+		2, /**< Frame buffer type to store top field or bottom field separately */
+};
+
+enum aux_buffer_type {
+	AUX_BUF_MV_COL,
+	AUX_BUF_TYPE_MAX,
+};
+
+enum coda_interrupt_bit {
+	INT_BIT_INIT = 0,
+	INT_BIT_SEQ_INIT = 1,
+	INT_BIT_SEQ_END = 2,
+	INT_BIT_PIC_RUN = 3,
+	INT_BIT_FRAMEBUF_SET = 4,
+	INT_BIT_ENC_HEADER = 5,
+	INT_BIT_DEC_PARA_SET = 7,
+	INT_BIT_DEC_BUF_FLUSH = 8,
+	INT_BIT_USERDATA = 9,
+	INT_BIT_DEC_FIELD = 10,
+#ifdef SUPPORT_CDB
+	INT_BIT_DEBUFFER = 12,
+#endif
+	INT_BIT_DEC_MB_ROWS = 13,
+	INT_BIT_BIT_BUF_EMPTY = 14,
+	INT_BIT_BIT_BUF_FULL = 15
+};
+
+// BIT_RUN command
+enum { DEC_SEQ_INIT = 1,
+       ENC_SEQ_INIT = 1,
+       DEC_SEQ_END = 2,
+       ENC_SEQ_END = 2,
+       PIC_RUN = 3,
+       SET_FRAME_BUF = 4,
+       ENCODE_HEADER = 5,
+       ENC_PARA_SET = 6,
+       DEC_PARA_SET = 7,
+       DEC_BUF_FLUSH = 8,
+       RC_CHANGE_PARAMETER = 9,
+       VPU_SLEEP = 10,
+       VPU_WAKE = 11,
+       ENC_ROI_INIT = 12,
+       FIRMWARE_GET = 0xf };
+
+enum sw_reset_mode {
+	SW_RESET_SAFETY, /**< It resets VPU in safe way. It waits until pending bus transaction is completed and then perform reset. */
+	SW_RESET_FORCE, /**< It forces to reset VPU without waiting pending bus transaction to be completed. It is used for immediate termination such as system off. */
+	SW_RESET_ON_BOOT /**< This is the default reset mode that is executed since system booting.  This mode is actually executed in VPU_Init(), so does not have to be used independently. */
+};
+
+enum cb_cr_order { CBCR_ORDER_NORMAL, CBCR_ORDER_REVERSED };
+
+enum bit_stream_mode {
+	BS_MODE_INTERRUPT,
+	BS_MODE_RESERVED, /* reserved for the future */
+	BS_MODE_PIC_END,
+};
+
+enum display_mode {
+	DISP_MODE_DISP_ORDER, /* VPU returns the display frame buffer by display order */
+	DISP_MODE_DEC_ORDER, /* VPU returns the display frame buffer by decoding order */
+};
+
+enum frame_buffer_format {
+	FORMAT_ERR = -1,
+	FORMAT_420 = 0, /* 8bit */
+	FORMAT_422, /* 8bit */
+	FORMAT_224, /* 8bit */
+	FORMAT_444, /* 8bit */
+	FORMAT_400, /* 8bit */
+
+	/* little endian perspective */
+	/* | addr 0 | addr 1 | */
+	FORMAT_420_P10_16BIT_MSB = 5, /* lsb |000000xx|xxxxxxxx | msb */
+	FORMAT_420_P10_16BIT_LSB, /* lsb |xxxxxxx |xx000000 | msb */
+	FORMAT_420_P10_32BIT_MSB, /* lsb |00xxxxxxxxxxxxxxxxxxxxxxxxxxx| msb */
+	FORMAT_420_P10_32BIT_LSB, /* lsb |xxxxxxxxxxxxxxxxxxxxxxxxxxx00| msb */
+
+	/* 4:2:2 packed format */
+	/* little endian perspective */
+	/* | addr 0 | addr 1 | */
+	FORMAT_422_P10_16BIT_MSB, /* lsb |000000xx |xxxxxxxx | msb */
+	FORMAT_422_P10_16BIT_LSB, /* lsb |xxxxxxxx |xx000000 | msb */
+	FORMAT_422_P10_32BIT_MSB, /* lsb |00xxxxxxxxxxxxxxxxxxxxxxxxxxx| msb */
+	FORMAT_422_P10_32BIT_LSB, /* lsb |xxxxxxxxxxxxxxxxxxxxxxxxxxx00| msb */
+
+	/* 4:4:4 packed format */
+	/* little endian perspective */
+	/* | addr 0 | addr 1 | */
+	FORMAT_444_P10_16BIT_MSB, /* lsb |000000xx |xxxxxxxx | msb */
+	FORMAT_444_P10_16BIT_LSB, /* lsb |xxxxxxxx |xx000000 | msb */
+	FORMAT_444_P10_32BIT_MSB, /* lsb |00xxxxxxxxxxxxxxxxxxxxxxxxxxx| msb */
+	FORMAT_444_P10_32BIT_LSB, /* lsb |xxxxxxxxxxxxxxxxxxxxxxxxxxx00| msb */
+
+	/* 4:0:0 packed format */
+	/* little endian perspective */
+	/* | addr 0 | addr 1 | */
+	FORMAT_400_P10_16BIT_MSB, /* lsb |000000xx |xxxxxxxx | msb */
+	FORMAT_400_P10_16BIT_LSB, /* lsb |xxxxxxxx |xx000000 | msb */
+	FORMAT_400_P10_32BIT_MSB, /* lsb |00xxxxxxxxxxxxxxxxxxxxxxxxxxx| msb */
+	FORMAT_400_P10_32BIT_LSB, /* lsb |xxxxxxxxxxxxxxxxxxxxxxxxxxx00| msb */
+
+	FORMAT_YUYV, /* 8bit packed format : Y0U0Y1V0 Y2U1Y3V1 ... */
+	FORMAT_YUYV_P10_16BIT_MSB,
+	FORMAT_YUYV_P10_16BIT_LSB,
+	FORMAT_YUYV_P10_32BIT_MSB,
+	FORMAT_YUYV_P10_32BIT_LSB,
+
+	FORMAT_YVYU, /* 8bit packed format : Y0V0Y1U0 Y2V1Y3U1 ... */
+	FORMAT_YVYU_P10_16BIT_MSB,
+	FORMAT_YVYU_P10_16BIT_LSB,
+	FORMAT_YVYU_P10_32BIT_MSB,
+	FORMAT_YVYU_P10_32BIT_LSB,
+
+	FORMAT_UYVY, /* 8bit packed format : U0Y0V0Y1 U1Y2V1Y3 ... */
+	FORMAT_UYVY_P10_16BIT_MSB,
+	FORMAT_UYVY_P10_16BIT_LSB,
+	FORMAT_UYVY_P10_32BIT_MSB,
+	FORMAT_UYVY_P10_32BIT_LSB,
+
+	FORMAT_VYUY, /* 8bit packed format : V0Y0U0Y1 V1Y2U1Y3 ... */
+	FORMAT_VYUY_P10_16BIT_MSB,
+	FORMAT_VYUY_P10_16BIT_LSB,
+	FORMAT_VYUY_P10_32BIT_MSB,
+	FORMAT_VYUY_P10_32BIT_LSB,
+
+	FORMAT_RGB_32BIT_PACKED = 90,
+	FORMAT_YUV444_32BIT_PACKED,
+	FORMAT_RGB_P10_32BIT_PACKED,
+	FORMAT_YUV444_P10_32BIT_PACKED,
+
+	FORMAT_RGB_24BIT_PACKED = 95,
+	FORMAT_YUV444_24BIT_PACKED,
+	FORMAT_YUV444_24BIT,
+
+	FORMAT_MAX,
+};
+
+enum PicType {
+	PIC_TYPE_I = 0, /**< I picture */
+	PIC_TYPE_KEY = 0, /**< KEY frame for AV1*/
+	PIC_TYPE_P = 1, /**< P picture */
+	PIC_TYPE_INTER = 1, /**< Inter frame for AV1*/
+	PIC_TYPE_B = 2, /**< B picture (except VC1) */
+	PIC_TYPE_REPEAT = 2, /**< Repeat frame (VP9 only) */
+	PIC_TYPE_AV1_INTRA = 2, /**< Intra only frame (AV1 only) */
+	PIC_TYPE_VC1_BI = 2, /**< VC1 BI picture (VC1 only) */
+	PIC_TYPE_VC1_B = 3, /**< VC1 B picture (VC1 only) */
+	PIC_TYPE_D =
+		3, /**< D picture in MPEG2 that is only composed of DC coefficients (MPEG2 only) */
+	PIC_TYPE_S =
+		3, /**< S picture in MPEG4 that is an acronym of Sprite and used for GMC (MPEG4 only)*/
+	PIC_TYPE_AVS2_F = 3, /**< F picture in AVS2 */
+	PIC_TYPE_AV1_SWITCH = 3, /**< Switch frame (AV1 only) */
+	PIC_TYPE_VC1_P_SKIP = 4, /**< VC1 P skip picture (VC1 only) */
+	PIC_TYPE_MP4_P_SKIP_NOT_CODED =
+		4, /**< Not Coded P Picture in MPEG4 packed mode */
+	PIC_TYPE_AVS2_S = 4, /**< S picture in AVS2 */
+	PIC_TYPE_IDR = 5, /**< H.264/H.265 IDR picture */
+	PIC_TYPE_AVS2_G = 5, /**< G picture in AVS2 */
+	PIC_TYPE_AVS2_GB = 6, /**< GB picture in AVS2 */
+	PIC_TYPE_MAX /**< No Meaning */
+};
+
+struct vp8_direct_memory {
+	u16 dSeqPicWidth; //08h
+	u16 dSeqPicHeight; //09h
+	u16 dSeqHScale; //0Ah
+	u16 dSeqVScale; //0Bh
+	u16 dMbNumX; //0Ch
+	u16 dMbNumY; //0Dh
+	u16 dMbNumInPic; //0Eh
+	u16 dPicChunkSizeH; //0Fh
+	u16 dPicChunkSizeL; //10h
+} __attribute__((packed));
+
+struct mp2_direct_memory {
+	//------------------------------------------------------------------------------
+	//    [20 - 2F] STD CODEC/ORDERING/DEBUG LAYER SUBROUTINE
+	//------------------------------------------------------------------------------
+	u16 dMpeg2; //025h
+	u16 dProgSeq; //026h
+	u16 dLoadBit; //027h
+	u16 dFrameRate; //028h
+	u16 dFRateExtN; //029h
+	u16 dFRateExtD; //02Ah
+	u16 dRefCnt; //02Bh
+	u16 dProfile; //02Ch
+	u16 dLevel; //02Dh
+	u16 dDummy0; //02Eh
+	//------------------------------------------------------------------------------
+	//    [30 - 4F] PICTURE LAYER SUBROUTINE
+	//------------------------------------------------------------------------------
+	u16 dPicTypePrev; //02Fh
+	u16 dDcPrecision; //030h
+	u16 dFramePic; //031h
+	u16 dFieldPic; //032h
+	u16 dField; //033h
+	u16 dPicType; //034h
+	u16 dAlternateScan; //035h
+	u16 dQScaleType; //036h
+	u16 dVlcFormat; //037h
+	u16 dConcealMV; //038h
+	u16 dTopFieldFirst; //039h
+	u16 dRepeatFirst; //03Ah
+	u16 dSecondField; //03Bh
+	u16 dFrameDct; //03Ch
+	u16 dPicStruct; //03Dh
+	u16 dProgFrame; //03Eh
+	u16 dFieldSeq; //03Fh
+	u16 dPictureI; //040h
+	u16 dPictureP; //041h
+	u16 dPictureB; //042h
+	u16 dFirstFieldPicType; //043h
+	u16 dFirstFieldPictureI; //044h
+	u16 dMbFieldY; //045h
+	u16 dVertMBA; //046h
+	u16 dFirstMbInSlice; //047h
+	u16 dMbAInc; //048h
+	u16 dPictureD; //049h
+	u16 dMp2MvpCmd1; //04Ah
+	u16 dMp2MvpCmd2; //04Bh
+	u16 dLinearFrmIdx; //04Ch
+	u16 dDummy1; //04Dh
+	u16 dDummy2; //04Eh
+	u16 dErrReasonFlag; //04Fh
+	u16 dTemp; //050h
+	u16 dTemp2; //051h
+	u16 dPicX; //052h
+	u16 dPicY; //053h
+	u16 dMbNumInPic; //054h
+	u16 dMbNumX; //055h
+	u16 dMbNumY; //056h
+	u16 dMbAddr; //057h
+	u16 dMbPosX; //058h
+	u16 dMbPosY; //059h
+	u16 dNumPad; //05Ah
+	u16 dActiveFormat; //05Bh
+	u16 dPrevVertMBA; //05Ch
+	u16 dPicXSeq; //05Dh
+	u16 dPicYSeq; //05Eh
+	u16 dPicHeaderDecoded; //05Fh
+} __attribute__((packed));
+
+struct mp2_indirect_memory {
+	u16 pRSize[2][2]; //400h
+	u16 pLimit[2][2]; //404h
+	u16 pDummy[8]; //408h
+	u16 pIdxQueue[16]; //410h
+	u16 pIntraQMat[64]; //420h
+	u16 pInterQMat[64]; //460h
+} __attribute__((packed));
+
+struct avc_direct_memory {
+	//------------------------------------------------------------------------------
+	//    SPS/PPS/SLICE HEADER VARIABLES
+	//------------------------------------------------------------------------------
+	u16 dSeqParaSetId; //10h
+	u16 dProfileIdc; //11h
+	u16 dMaxRefFrame; //12h
+	u16 dMaxFrameBit; //13h
+	u16 dMaxFrameNumH; //14h
+	u16 dMaxFrameNumL; //15h
+	u16 dPicOrderCntType; //16h
+	u16 dPicOrderCntBit; //17h
+	u16 dPicOrderZeroFlag; //18h
+	u16 dNumRefFrame; //19h
+	u16 dGapsInFrameNum; //1Ah
+	u16 dFrameMbsOnlyFlag; //1Bh
+	u16 dMbAffFlag; //1Ch
+	u16 dDirect8x8Flag; //1Dh
+	u16 dMbNumInPic; //1Eh
+	u16 dLevelIdc; //1Fh
+	u16 dMaxDpbSize; //20h
+	u16 dReorderEnable; //21h
+	u16 dChromaIdc; //22h
+	u16 dPicStructFlag; //23h
+	u16 dConstSetflag7_0; //24h
+	u16 dAspectRatioH; //25h
+	u16 dAspectRatioL; //26h
+	u16 dBitRateH; //27h
+	u16 dBitRateL; //28h
+	u16 dPicParaSetId; //29h
+	u16 dPicOrderPrsFlag; //2Ah
+	u16 dNumSliceGrpMinus1; //2Bh
+	u16 dPicNumRefIdxL0Minus1; //2Ch
+	u16 dUseCabac; //2Dh
+	u16 dPicNumRefIdxL1Minus1; //2Eh
+	u16 dWpFlag; //2Fh
+	u16 dWpIdc; //30h
+	u16 dPicInitQpY; //31h
+	u16 dChromaQpOffset; //32h
+	u16 dDeblkCtrlPresent; //33h
+	u16 dConstrainIntra; //34h
+	u16 dRedundPicCntPresent; //35h
+	u16 dSecondChromaQpOffset; //36h
+	u16 dTransform8x8ModeFlag; //37h
+	u16 dSliceType; //38h
+	u16 dFrameNum; //39h
+	u16 dFirstFieldExist; //3Ah
+	u16 dFirstFieldNalRefFlag; //3Bh
+	u16 dFirstFieldFrameNum; //3Ch
+	u16 dFirstFieldBottom; //3Dh
+	u16 dFirstFieldFrameIdx; //3Eh
+	u16 dFieldPicFlag; //3Fh
+	u16 dSecondField; //40h
+	u16 dPicType; //41h
+	u16 dBottomFieldFlag; //42h
+	u16 dMbAff; //43h
+	u16 dMbNumPic; //44h
+	u16 dIdrPicId; //45h
+	u16 dDirectMvMode; //46h
+	u16 dCabacInitIdc; //47h
+	u16 dNumRefIdxL0Minus1; //48h
+	u16 dNumRefIdxL1Minus1; //49h
+	u16 dSliceQpY; //4Ah
+	u16 dDisableDeblk; //4Bh
+	u16 dDeblkOffsetA; //4Ch
+	u16 dDeblkOffsetB; //4Dh
+
+	//------------------------------------------------------------------------------
+	//    PICTURE VARIABLES
+	//------------------------------------------------------------------------------
+	u16 dNalRefIdc; //4Eh
+	u16 dIdrPicture; //4Fh
+	u16 dCurFrameNum; //50h
+	u16 dFirstSlice; //51h
+	u16 dFirstMbAddr; //52h
+	u16 dFrmErrMbNum; //53h
+	u16 dDecFrameNumH; //54h
+	u16 dDecFrameNumL; //55h
+	u16 dPrevDispPicIdx; //56h
+
+	//------------------------------------------------------------------------------
+	//    MB VARIABLES
+	//------------------------------------------------------------------------------
+	u16 dMbNumX; //57h
+	u16 dMbNumY; //58h
+	u16 dMbAddr; //59h
+	u16 dMbIntra; //5Ah
+	u16 dMbPosX; //5Bh
+	u16 dMbPosY; //5Ch
+	u16 dMbType; //5Dh
+	u16 dMcWpMode; //5Eh
+	u16 dMcLogWdYc; //5Fh
+	u16 dBIdxCur; //60h
+	u16 dCpbMinus1; //61h
+	u16 dHeaderIsrFlag; //62h
+	u16 dBIdxNxt; //63h
+	u16 dBIdxSaveR7; //64h
+	u16 dPsRetFlag; //65h
+	u16 dPicStride; //66h
+
+	//------------------------------------------------------------------------------
+	//    HP SCALING_MATRIX_PARAMETER
+	//------------------------------------------------------------------------------
+	u16 dSeqScalingMatrixFlag; //67h
+	u16 dPicScalingMatrixFlag; //68h
+	u16 dSeqScalingListFlag; //69h
+	u16 dPicScalingListFlag; //6Ah
+	u16 dSeqDefScalingList; //6Bh
+	u16 dPicDefScalingList; //6Ch
+
+	//------------------------------------------------------------------------------
+	//    MV COL
+	//------------------------------------------------------------------------------
+	u16 dReorderInitListNum; //6Dh
+	u16 dDecColPicAddrH; //6Eh
+	u16 dDecColPicAddrL; //6Fh
+	u16 dRefColPicAddrH; //70h
+	u16 dRefColPicAddrL; //71h
+	u16 dDpbPocCurH; //72h
+	u16 dDpbPocCurL; //73h
+	u16 dDpbPocTopH; //74h
+	u16 dDpbPocTopL; //75h
+	u16 dDpbPocBotH; //76h
+	u16 dDpbPocBotL; //77h
+	u16 dColPicLong; //78h
+	u16 dColPicField; //79h
+	u16 dNearPocBot; //7Ah
+
+	//------------------------------------------------------------------------------
+	//    MMCO
+	//------------------------------------------------------------------------------
+	u16 dMmcoCurRefNum; //7Bh
+	u16 dMmcoCurRefType; //7Ch
+	u16 dMmcoSlideWinOutFlag; //7Dh
+	u16 dMmcoResetFlag; //7Eh
+	u16 dFrameBufNum; //7Fh
+	u16 dMmcoPrevRefFrameNum; //80h
+	u16 dMmcoPrevDispPicIdx; //81h
+	u16 dDpbPrevMmcoResetFlag; //82h
+
+	//------------------------------------------------------------------------------
+	//    FrameIdx
+	//------------------------------------------------------------------------------
+	u16 dPrevDecFrameIdx; //83h
+	u16 dDecFrameIdx; //84h
+	u16 dDispFrameIdx; //85h
+	u16 dSuccess; //86h
+
+	//------------------------------------------------------------------------------
+	//    ROTATOR (POST PROCESSING)
+	//------------------------------------------------------------------------------
+	u16 dPostRotateMode; //87h
+	u16 dPostRotateEn; //88h
+	u16 dPostInFrmIdx; //89h
+	u16 dPostDstFrmIdx; //8Ah
+	u16 dPostMbNumX; //8Bh
+	u16 dPostMbNumY; //8Ch
+	u16 dPostMbPosX; //8Dh
+	u16 dPostMbPosY; //8Eh
+	u16 dPostProcEn; //8Fh
+
+	//------------------------------------------------------------------------------
+	//    SLICE BUFFER / VUI PARAMETER
+	//------------------------------------------------------------------------------
+	u16 dNalHrdParamFlag; //90h
+	u16 dVclHrdParamFlag; //91h
+	u16 dPrevNalRefIdc; //92h
+	u16 dPrevIdrPicture; //93h
+	u16 dFirstVclNal; //94h
+	u16 dSaveNalRefIdc; //95h
+	u16 dSaveIdrPicture; //96h
+	u16 dBpSliceBufLack; //97h
+
+	//------------------------------------------------------------------------------
+	//    SPS/PPS BUFFER
+	//------------------------------------------------------------------------------
+	u16 dPpsBackupedFlag; //98h
+	u16 dSpsBufRdPtrH; //99h
+	u16 dSpsBufRdPtrL; //9Ah
+	u16 dPsBufIsrFlag; //9Bh
+	u16 dAlignBit; //9Ch
+	u16 dZeroNum; //9Dh
+	u16 dNumBit; //9Eh
+	u16 dMcFastInterpolDisable; //9Fh
+
+	//------------------------------------------------------------------------------
+	//    ADD-ON FEATURE VARIABLES
+	//------------------------------------------------------------------------------
+	u16 dIdrPicFlagField; //A0h
+	u16 dSliceTypeDecoded; //A1h
+	u16 dSliceTypeField; //A2h
+	u16 dPicStruct; //A3h
+	u16 dNpfIdx; //A4h
+	u16 dSkipFlag; //A5h
+	u16 dUserDataPtr; //A6h
+	u16 dMvcReportH; //A7h
+	u16 dMvcReportL; //A8h
+	u16 dBackupPsId; //A9h
+	u16 dDisableConcealMethods; //AAh
+	u16 dAvcDecCodeNumH; //ABh
+	u16 dAvcDecCodeNumL; //ACh
+	u16 dAuFound; //ADh
+	u16 dErrReasonFlag; //AEh
+	u16 dEnUserFrmDelay; //AFh
+	u16 dActiveFormat; //B0h
+	u16 dX264MvExpEn; //B1h
+	u16 dFrameNumbak; //B2h
+	u16 dDpbBufferingReported; //B3h
+	u16 dChunkReuse; //B4h
+	u16 dUserDataBaseAddrH; //B5h
+	u16 dUserDataBaseAddrL; //B6h
+	u16 dUserDataBufSizeH; //B7h
+	u16 dUserDataBufSizeL; //B8h
+	u16 dSliceTypeCur; //B9h
+	u16 dSliceTypeTop; //BAh
+	u16 dSliceTypeBot; //BBh
+	u16 dIdrFrameFlag; //BCh
+	u16 dSeqChanged; //BDh
+	u16 dWrongFrameNumFlag; //BEh
+	u16 dClosedCaptionType; //BFh
+	u16 dRecoveryFrameCnt; //C0h
+	u16 dExactRecoveryPoint; //C1h
+	u16 dBrokenLinkFlag; //C2h
+	u16 dChangingSliceGroupIdc; //C3h
+	u16 dDpbAllocFlag; //C4h
+	u16 dDpbPutPicFlag; //C5h
+	u16 dCheckMaxFrameSize; //C6h
+	u16 FREE_C7; //C7h
+	u16 FREE_C8; //C8h
+	u16 FREE_C9; //C9h
+	u16 FREE_CA; //CAh
+	u16 FREE_CB; //CBh
+	u16 FREE_CC; //CCh
+	u16 FREE_CD; //CDh
+	u16 FREE_CE; //CEh
+	u16 FREE_CF; //CFh
+	u16 dMbSkipRun; //D0h
+	u16 dSkipRunCntDown; //D1h
+	u16 FREE_D2; //D2h
+	u16 dFirstFrame; //D3h
+
+	//------------------------------------------------------------------------------
+	//    MULTI VPU FULL FRAME PARALLEL DECODER
+	//------------------------------------------------------------------------------
+	u16 dMbySyncEnable; //D4h
+	u16 dMbySyncFrameNum; //D5h
+
+	//------------------------------------------------------------------------------
+	//    AVC_BASELINE
+	//------------------------------------------------------------------------------
+	u16 dFmoMapType; //D6h
+	u16 dFmoNumGrp; //D7h
+	u16 dFmoNumGrpMinus1; //D8h
+	u16 dFmoGrp; //D9h
+	u16 dFmoGrpChangeDir; //DAh
+	u16 dFmoGrpChangeRate; //DBh
+	u16 dFmoMbNumGrp0; //DCh
+	u16 dFmoMap345; //DDh
+	u16 dFmoCycleBit; //DEh
+	u16 dFmoSliceBufInit; //DFh
+	u16 dFmoPrevGrp; //E0h
+	u16 dFmoMbAvailA; //E1h
+	u16 dFmoMbAvailD; //E2h
+	u16 dFmoMbAvail; //E3h
+	u16 dExtBitBufR1Bak; //E4h
+
+	//------------------------------------------------------------------------------
+	//    DPB
+	//------------------------------------------------------------------------------
+	u16 dDpbBufCnt; //E5h
+	u16 dDpbDispFifoWrPtr; //E6h
+	u16 dDpbDispFifoRdPtr; //E7h
+	u16 dDpbDispFifoCnt; //E8h
+	u16 dDpbFrameDelay; //E9h
+	u16 dDpbNumReorderFrame; //EAh
+	u16 dDpbMaxDecBuffering; //EBh
+} __attribute__((packed));
+
+struct vpu_rect {
+	u32 left; /* A horizontal pixel offset of top-left corner of rectangle from (0, 0) */
+	u32 top; /* A vertical pixel offset of top-left corner of rectangle from (0, 0) */
+	u32 right; /* A horizontal pixel offset of bottom-right corner of rectangle from (0, 0) */
+	u32 bottom; /* A vertical pixel offset of bottom-right corner of rectangle from (0, 0) */
+};
+
+struct dec_user_data {
+	u32 header;
+	u32 num;
+	dma_addr_t buf_addr;
+	u32 size; /* this is the size of user data. */
+	bool buf_full;
+};
+
+struct sec_axi_info {
+	u32 use_bit_enable : 1;
+	u32 use_ip_enable : 1;
+	u32 use_dbk_y_enable : 1;
+	u32 use_dbk_c_enable : 1;
+	u32 use_ovl_enable : 1;
+	u32 use_btp_enable : 1;
+	dma_addr_t buf_bit_use;
+	dma_addr_t buf_ip_acdc_use;
+	dma_addr_t buf_dbk_y_use;
+	dma_addr_t buf_dbk_c_use;
+	dma_addr_t buf_ovl_use;
+	dma_addr_t buf_btp_use;
+	int buf_size;
+	dma_addr_t buf_base;
+};
+
+struct frame_buffer {
+	dma_addr_t buf_y;
+	dma_addr_t buf_cb;
+	dma_addr_t buf_cr;
+	dma_addr_t buf_y_bot;
+	dma_addr_t buf_cb_bot;
+	dma_addr_t buf_cr_bot;
+	enum tiled_map_type map_type;
+	unsigned int stride; /* A horizontal stride for given frame buffer */
+	unsigned int width; /* A width for given frame buffer */
+	unsigned int height; /* A height for given frame buffer */
+	unsigned int sequence_no;
+	int index;
+	u32 luma_bitdepth : 4;
+	u32 chroma_bitdepth : 4;
+	u32 chroma_format_idc : 2;
+};
+
+struct instance_buffer {
+	dma_addr_t temp_base; /* It indicates the start address of temp buffer. */
+	u32 temp_size; /* It indicates the size of temp buffer. */
+	//	dma_addr_t sec_base_core0; /* It indicates the start address of secondary-axi buffer. */
+	//	u32 sec_size_core0; /* It indicates the size of secondary-axi buffer. */
+	dma_addr_t work_base; /* It indicates the start address of work buffer. */
+	u32 work_size; /* It indicates the size of work buffer. */
+};
+
+struct tho_scale_info {
+	int frame_width; /**< This value is used for width of frame buffer. */
+	int frame_height; /**< This value is used for height of frame buffer. */
+	int pic_width; /**< This value is used for width of the displayable picture region. */
+	int pic_height; /**< This value is used for height of the displayable picture region. */
+	int picoffset_x; /**< This value is located at the lower-left corner of the displayable picture region. */
+	int picoffset_y; /**< This value is located at the lower-left corner of the displayable picture region. */
+};
+
+struct vp8_scale_info {
+	unsigned h_scale_factor : 2;
+	unsigned v_scale_factor : 2; /**< This is an upscaling factor for vertical expansion. The value could be 0 to 3, meaning of each value is described in above table. */
+	unsigned pic_width : 14; /**< Picture width in units of sample */
+	unsigned pic_height : 14; /**< Picture height in units of sample */
+};
+
+struct mp2_bardata_info {
+	int bar_left;
+	int bar_right;
+	int bar_top;
+	int bar_bottom;
+};
+
+struct dec_initial_info {
+	s32 pic_width;
+	s32 pic_height;
+	s32 f_rate_numerator; /* the numerator part of frame rate fraction */
+	s32 f_rate_denominator; /* the denominator part of frame rate fraction */
+	struct vpu_rect pic_crop_rect;
+	s32 mp4_data_partition_enable;
+	s32 mp4_reversible_vlc_enable;
+	s32 mp4_short_video_header;
+	s32 h263_annexj_enable;
+	s32 frame_buf_delay;
+	s32 normal_slice_size;
+	s32 worst_slice_size;
+	s32 max_sub_layers;
+	s32 profile;
+	s32 level;
+	s32 tier;
+	s32 interlace; /**< When this value is 1, decoded stream may be decoded into progressive or interlace frame. Otherwise, decoded stream is progressive frame. */
+	s32 constraint_set_flag
+		[4]; /**< constraint_set0_flag ~ constraint_set3_flag in H.264/AVC SPS */
+	s32 direct8x8_flag; /**< direct_8x8_inference_flag in H.264/AVC SPS */
+	s32 vc1_psf; /**< Progressive Segmented Frame(PSF) in VC1 sequence layer */
+	s32 is_ext_sar;
+	s32 max_num_reffrm_flag;
+	s32 max_num_reffrm;
+	s32 aspect_rate_info;
+	s32 bitrate; /**< The bitrate value written in bitstream syntax. If there is no bitRate, this reports -1. */
+	struct tho_scale_info
+		thoscale_info; /**< This is the Theora picture size information. Refer to <<vpuapi_h_ThoScaleInfo>>. */
+	struct vp8_scale_info
+		vp8scale_info; /**< This is VP8 upsampling information. Refer to <<vpuapi_h_Vp8ScaleInfo>>. */
+	s32 mp2_low_delay; /**< This is low_delay syntax of sequence extension in MPEG2 specification. */
+	s32 mp2_disp_versize; /**< This is display_vertical_size syntax of sequence display extension in MPEG2 specification. */
+	s32 mp2_disp_horsize; /**< This is display_horizontal_size syntax of sequence display extension in MPEG2 specification. */
+	u32 user_data_header; /**< Refer to userDataHeader in <<vpuapi_h_DecOutputExtData>>. */
+	s32 user_data_num; /**< Refer to userDataNum in <<vpuapi_h_DecOutputExtData>>. */
+	s32 user_data_size; /**< Refer to userDataSize in <<vpuapi_h_DecOutputExtData>>. */
+	s32 user_databuf_full; /**< Refer to userDataBufFull in <<vpuapi_h_DecOutputExtData>>. */
+	//VUI information
+	s32 chroma_format_idc; /**< A chroma format indicator */
+	s32 luma_bit_depth; /**< A bit-depth of luma sample */
+	s32 chroma_bit_depth; /**< A bit-depth of chroma sample */
+
+	int mp2_color_primaries;
+	int mp2_transfer_char;
+	int mp2_matrix_coeff;
+
+	s32 err_reason;
+	s32 warn_info;
+	dma_addr_t rd_ptr; /**< A read pointer of bitstream buffer */
+	dma_addr_t wr_ptr; /**< A write pointer of bitstream buffer */
+	//AvcVuiInfo      avcVuiInfo;    /**< This is H.264/AVC VUI information. Refer to <<vpuapi_h_AvcVuiInfo>>. */
+	struct mp2_bardata_info
+		mp2bar_data_info; /**< This is bar information in MPEG2 user data. For details about this, please see the document 'ATSC Digital Television Standard: Part 4:2009'. */
+	u32 sequence_no; /**< This is the number of sequence information. This variable is increased by 1 when VPU detects change of sequence. */
+	s32 num_reorder_frames; /**< only for coda7q */
+};
+
+struct dec_open_param {
+	dma_addr_t bitstream_buffer;
+	int bitstream_buffer_size;
+
+	int codec_mode;
+	int codec_mode_aux;
+
+	int mp4_deblk_enable;
+	int avc_extension;
+
+	int reorder_enable;
+	int mp4_class;
+	int tiled2_linear_enable;
+	int tiled2_linear_mode;
+	int wtl_enable;
+	int wtl_mode;
+
+	int bwb_enable;
+	enum endian_mode frame_endian;
+	enum endian_mode stream_endian;
+	enum bit_stream_mode bitstream_mode;
+	enum tiled_map_type map_type;
+	dma_addr_t
+		sec_base_core0; /* It indicates the start address of secondary-axi buffer. */
+	u32 sec_size_core0; /* It indicates the size of secondary-axi buffer. */
+	int frame_delay;
+};
+
+struct stateless_mpeg2_info {
+	const struct v4l2_ctrl_mpeg2_sequence *seq;
+	const struct v4l2_ctrl_mpeg2_picture *pic;
+	const struct v4l2_ctrl_mpeg2_quantisation *quant;
+};
+
+struct stateless_vp8_info {
+	const struct v4l2_ctrl_vp8_frame *frame;
+};
+
+struct stateless_h264_info {
+	const struct v4l2_ctrl_h264_sps *sps;
+	const struct v4l2_ctrl_h264_pps *pps;
+	const struct v4l2_ctrl_h264_scaling_matrix *sm;
+	const struct v4l2_ctrl_h264_slice_params *spram;
+	const struct v4l2_ctrl_h264_decode_params *dpram;
+	const struct v4l2_ctrl_h264_pred_weights *pwht;
+};
+
+struct dec_param {
+	dma_addr_t
+		buf_addr_y; /**< It specifies the Y buffer address of stateless decoding. */
+	dma_addr_t
+		buf_addr_cb; /**< It specifies the Cb buffer address of stateless decoding. */
+	dma_addr_t
+		buf_addr_cr; /**< It specifies the Cr buffer address of stateless decoding. */
+
+	struct stateless_mpeg2_info mpeg2;
+	struct stateless_vp8_info vp8;
+	struct stateless_h264_info h264;
+};
+
+struct report_cycle {
+	u32 host_cmd_s; /* Start Tick of DEC_PIC/ENC_PIC host command for the picture */
+	u32 host_cmd_e; /* End tick of DEC_PIC/ENC_PIC host command for the picture (until host get the result for the picture) */
+	u32 proc_s; /* Start tick of processing hw block for the picture */
+	u32 proc_e; /* End tick of processing hw block for the picture */
+	u32 vpu_s; /* Start tick of decoding/encoding for the picture */
+	u32 vpu_e; /* End tick of decoding/encoding for the picture */
+	u32 frame_cycle; /* The total cycle of host command for the picture */
+	u32 proc_cycle; /* The total cycle of processing for the picture */
+	u32 vpu_cycle; /* The total cycle of decoding/encoding for the picture except processing cycle */
+};
+
+struct timestamp_info {
+	u32 hour;
+	u32 min;
+	u32 sec;
+	u32 ms;
+};
+
+struct dec_output_info {
+	int decoding_success;
+	int index_frame_decoded;
+	int index_frame_display;
+	int index_frame_decoded_for_tiled;
+	int index_frame_display_for_tiled;
+	int pic_width;
+	int pic_height;
+	int pic_type;
+	int aspect_rate_info;
+	int num_of_err_mbs;
+	int sequence_changed;
+	int stream_end_flag : 1;
+	int f_numberator;
+	int f_denominator;
+	int avc_poc_pic;
+	int avc_poc_top;
+	int avc_poc_bot;
+	dma_addr_t byte_pos_frame_start;
+	dma_addr_t byte_pos_frame_end;
+	int frame_cycle; /* this variable reports the number of cycles for processing a frame. */
+	int frame_display_flag;
+	dma_addr_t buf_addr_y;
+	dma_addr_t buf_addr_cb;
+	dma_addr_t buf_addr_cr;
+};
+
+struct tiled_map_config {
+	int xy2axi_luma_map[32];
+	int xy2axi_chr_map[32];
+	int xy2axi_config;
+
+	int tb_separate_map;
+	int top_bot_split;
+	int tiled_map;
+	int conv_linear;
+};
+
+struct dec_info {
+	struct dec_open_param open_param;
+	struct dec_initial_info initial_info;
+	int pic_width;
+	int pic_height;
+	int pic_num;
+	int stride;
+	int profile;
+	int framebuf_height;
+	dma_addr_t stream_wr_ptr;
+	dma_addr_t stream_rd_ptr;
+	int stream_end_flag;
+	int frame_display_flag;
+	struct vpu_buf vb_mv[CODA_MAX_FBS];
+	struct vpu_buf vb_fbc_y_tbl[CODA_MAX_FBS];
+	struct vpu_buf vb_fbc_c_tbl[CODA_MAX_FBS];
+	struct vpu_buf vb_def_cdf;
+	struct vpu_buf vb_seg_map;
+	struct vpu_buf vb_pre_ent;
+	struct frame_buffer disp_buf[CODA_MAX_FBS];
+	bool initial_info_obtained;
+	struct sec_axi_info sec_axi_info;
+	dma_addr_t user_data_buf_addr;
+	u32 user_data_enable;
+	u32 user_data_buf_size;
+	struct dec_output_info dec_out_info[CODA_MAX_FBS];
+	int seq_change_mask;
+	u32 cycle_per_tick;
+	enum frame_buffer_format wtl_format;
+	struct tiled_map_config map_cfg;
+	u32 cache_mode;
+};
+
+struct vpu_instance;
+
+struct vpu_instance_ops {
+	int (*start_process)(struct vpu_instance *inst);
+	void (*stop_process)(struct vpu_instance *inst);
+	void (*finish_process)(struct vpu_instance *inst);
+};
+
+struct vpu_instance {
+	struct list_head list;
+	struct v4l2_fh v4l2_fh;
+	struct v4l2_ctrl_handler v4l2_ctrl_hdl;
+	struct vpu_device *dev;
+	struct completion irq_done;
+
+	struct v4l2_pix_format_mplane src_fmt;
+	struct v4l2_pix_format_mplane dst_fmt;
+	struct v4l2_rect crop;
+	enum v4l2_colorspace colorspace;
+	enum v4l2_xfer_func xfer_func;
+	enum v4l2_ycbcr_encoding ycbcr_enc;
+	enum v4l2_quantization quantization;
+
+	enum vpu_instance_state state;
+	enum vpu_instance_type type;
+	const struct vpu_instance_ops *ops;
+
+	enum cod_std std;
+	u32 id;
+	union {
+		struct dec_info dec_info;
+	} * codec_info;
+	struct frame_buffer frame_buf[CODA_MAX_FBS];
+	struct vpu_buf frame_vbuf[CODA_MAX_FBS];
+	u32 queued_src_buf_num;
+	u32 queued_dst_buf_num;
+	bool next_buf_last;
+	bool cbcr_interleave;
+	bool nv21;
+	bool eos;
+	bool output_stopped;
+
+	struct vpu_buf bitstream_vbuf;
+	dma_addr_t last_rd_ptr;
+	size_t remaining_consumed_bytes;
+
+	struct vpu_buf aux_vbuf[AUX_BUF_TYPE_MAX][CODA_MAX_FBS];
+	struct vpu_buf work_vbuf;
+	struct vpu_buf temp_vbuf;
+	struct vpu_buf ar_vbuf;
+	struct vpu_buf vui_vbuf;
+	struct vpu_buf slice_vbuf;
+
+	u8 frame_addr[CODA_MAX_FBS][3][4];
+	u8 col_mv_addr[CODA_MAX_FBS][4];
+};
+
+struct vpu_device {
+	struct device *dev;
+	struct v4l2_device v4l2_dev;
+	struct media_device mdev;
+	struct v4l2_m2m_dev *m2m_dev;
+	struct list_head instances;
+	struct video_device *video_dev_dec;
+	struct mutex dev_lock; /* lock for the src, dst v4l2 queues */
+	struct mutex hw_lock; /* lock hw configurations */
+	int irq;
+	enum product_id product;
+	struct vpu_attr attr;
+	struct vpu_buf common_mem;
+	u32 last_performance_cycles;
+	struct gen_pool *sram_pool;
+	struct vpu_buf sram_buf;
+	void __iomem *vdb_register;
+	u32 product_code;
+	struct completion irq_done;
+	struct ida inst_ida;
+	struct kfifo irq_status;
+	struct delayed_work task_timer;
+	struct clk_bulk_data *clks;
+	struct kthread_work work;
+	struct kthread_worker *worker;
+	int vpu_poll_interval;
+	int num_clks;
+};
+
+void coda_vdi_free_dma_memory(struct vpu_device *vpu_dev, struct vpu_buf *vb);
+int coda_vdi_allocate_dma_memory(struct vpu_device *vpu_dev,
+				 struct vpu_buf *vb);
+int coda_vpu_init_m2m_dev(struct vpu_device *dev);
+void coda_vpu_release_m2m_dev(struct vpu_device *dev);
+void coda_return_bufs(struct vb2_queue *q, u32 state);
+
+void coda_vdi_writel(struct vpu_device *vpu_dev, unsigned int addr,
+		     unsigned int data);
+unsigned int coda_vdi_readl(struct vpu_device *vpu_dev, u32 addr);
+int coda_vdi_write_memory(struct vpu_device *vpu_dev, struct vpu_buf *vb,
+			  size_t offset, u8 *data, int len, int endian);
+int coda_vdi_read_memory(struct vpu_device *vpu_dev, struct vpu_buf *vb,
+			 size_t offset, u8 *data, int len, int endian);
+
+int coda_vpu_wait_interrupt(struct vpu_instance *inst, unsigned int timeout);
+struct vb2_v4l2_buffer *coda_get_dst_buf_by_addr(struct vpu_instance *inst,
+						 dma_addr_t addr);
+
+#endif
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-vpuconfig.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda-vpuconfig.h
@@ -0,0 +1,83 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Coda980 series multi-standard codec IP - decoder interface
+ *
+ * Copyright (C) 2024 CHIPS&MEDIA INC
+ */
+#ifndef CODA_VPUCONFIG_H
+#define CODA_VPUCONFIG_H
+
+#include "coda-vdi.h"
+
+#define CODA980_CODE 0x9800
+
+#define SIZE_COMMON (1 * 1024 * 1024)
+
+#define VPU_REORDER_ENABLE                                                     \
+	1 // it can be set to 1 to handle reordering DPB in host side.
+#define CBCR_INTERLEAVE                                                        \
+	1 //[default 1 for BW checking with CnMViedo Conformance] 0 (chroma separate mode), 1 (chroma interleave mode) // if the type of tiledmap uses the kind of MB_RASTER_MAP. must set to enable CBCR_INTERLEAVE
+#define VPU_ENABLE_BWB 1
+#define FRAME_CACHE_BYPASS       0
+#define FRAME_CACHE_BURST        0
+#define FRAME_CACHE_MERGE        3
+#define FRAME_CACHE_WAY_SHAPE    15
+
+#define HOST_ENDIAN VDI_LITTLE_ENDIAN
+#define VPU_FRAME_ENDIAN VDI_LITTLE_ENDIAN
+#define VPU_STREAM_ENDIAN VDI_LITTLE_ENDIAN
+#define VPU_USER_DATA_ENDIAN VDI_LITTLE_ENDIAN
+#define DRAM_BUS_WIDTH 8
+
+#define CODA_VPU_TIMEOUT 60000
+
+#define MAX_DEC_PIC_WIDTH 4096
+#define MAX_DEC_PIC_HEIGHT 2304
+
+#define AVC_MIN_DEC_PIC_WIDTH 64U
+#define AVC_MIN_DEC_PIC_HEIGHT 64U
+#define AVC_MAX_DEC_PIC_WIDTH 4096U
+#define AVC_MAX_DEC_PIC_HEIGHT 2304U
+
+#define VP8_MIN_DEC_PIC_WIDTH 64U
+#define VP8_MIN_DEC_PIC_HEIGHT 64U
+#define VP8_MAX_DEC_PIC_WIDTH 1920U
+#define VP8_MAX_DEC_PIC_HEIGHT 1088U
+
+#define MPEG2_MIN_DEC_PIC_WIDTH 64U
+#define MPEG2_MIN_DEC_PIC_HEIGHT 64U
+#define MPEG2_MAX_DEC_PIC_WIDTH 1920U
+#define MPEG2_MAX_DEC_PIC_HEIGHT 1088U
+
+#define RAW_MIN_DEC_PIC_WIDTH 64U
+#define RAW_MIN_DEC_PIC_HEIGHT 64U
+#define RAW_MAX_DEC_PIC_WIDTH 4096U
+#define RAW_MAX_DEC_PIC_HEIGHT 2304U
+
+#define CODA_DEC_PIC_SIZE_STEP 1
+
+#define PS_SAVE_SIZE                                                           \
+	((320 + 8) * 1024 *                                                    \
+	 4) // sps[64], pps[256], backupPsBuf[8] for rollback, error concealment (each 4Kbyte)
+#define VP8_MB_SAVE_SIZE                                                       \
+	(17 * 4 *                                                              \
+	 (MAX_DEC_PIC_WIDTH * MAX_DEC_PIC_HEIGHT /                             \
+	  256)) // MB information + split MVs)*4*MbNumbyte
+//----- slice save buffer --------------------//
+#define SLICE_SAVE_SIZE                                                        \
+	(MAX_DEC_PIC_WIDTH * MAX_DEC_PIC_HEIGHT * 3 /                          \
+	 4) // this buffer for ASO/FMO
+#define WORK_BUF_SIZE (80 * 1024)
+
+#define VPU_AVC_X264_SUPPORT 1
+#define VPU_GBU_SIZE 1024
+
+#define VPU_DEC_TIMEOUT 1000
+
+#define CODA9_AVC_Q_MATRIX_OFFSET (0x3500)
+#define CODA9_AVC_DIRECT_MEM_OFFSET (0x10 * 2)
+#define CODA9_MP2_INDIRECT_MEM_OFFSET (0x400 * 2)
+#define CODA9_MP2_DIRECT_MEM_OFFSET (0x25 * 2)
+#define CODA9_VP8_DIRECT_MEM_OFFSET (0x8 * 2)
+
+#endif
\ No newline at end of file
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/coda.h
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Coda980 series multi-standard codec IP - decoder interface
+ *
+ * Copyright (C) 2024 CHIPS&MEDIA INC
+ */
+#ifndef CODA_H
+#define CODA_H
+
+#define VPU_DEC_DEV_NAME "C&M Coda VPU decoder"
+#define VPU_DEC_DRV_NAME "Coda-dec"
+
+int32_t coda_vpu_get_product_id(struct vpu_device *vpu_dev);
+bool coda_vpu_is_init(struct vpu_device *vpu_dev);
+int coda_vpu_re_init(struct device *dev, u8 *firmware, uint32_t size);
+int coda_vpu_init(struct device *dev, u8 *firmware, uint32_t size);
+int coda_vpu_reset(struct vpu_device *vpu_dev, enum sw_reset_mode reset_mode);
+void coda_bit_issue_command(struct vpu_device *vpu_dev,
+			    struct vpu_instance *inst, u32 cmd);
+int coda_vpu_dec_init_seq(struct vpu_instance *inst);
+int coda_vpu_dec_get_seq_info(struct vpu_instance *vpu_inst,
+			      struct dec_initial_info *info);
+void coda_debug_register(struct vpu_device *vpu_dev, struct vpu_instance *inst,
+			 u32 cmd, u32 start_flag);
+int coda_vpu_dec_register_frame_buffer(struct vpu_instance *vpu_inst,
+				       struct frame_buffer *fb_arr,
+				       enum tiled_map_type map_type, u32 count);
+int coda_vpu_set_rd_ptr(struct vpu_instance *inst);
+int coda_vpu_set_wr_ptr(struct vpu_instance *inst, int size);
+int coda_vpu_decode(struct vpu_instance *vpu_inst, struct dec_param *option);
+int coda_vpu_dec_get_result(struct vpu_instance *inst,
+			    struct dec_output_info *result);
+
+#endif
\ No newline at end of file
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/vpu.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/coda/vpu.c
@@ -0,0 +1,460 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Coda980 series multi-standard codec IP - platform driver
+ *
+ * Copyright (C) 2024 CHIPS&MEDIA INC
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/of_address.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/genalloc.h>
+#include <linux/firmware.h>
+#include <linux/interrupt.h>
+
+#include "coda-vpu.h"
+#include "coda-regdefine.h"
+#include "coda.h"
+
+#define VPU_PLATFORM_DEVICE_NAME "Coda-dec"
+
+#define VPU_CLK_NAME "vcodec"
+
+#define CODA_IS_DEC BIT(1)
+
+// rtk
+#define VDI_SRAM_BASE_ADDR 0x00000000
+#define VDI_CODA9_SRAM_SIZE 0x1D000
+
+static int ve_cti_en = 1;
+static int ve_idle_en = 0;
+#define VE_CTRL_REG (BIT_BASE + 0x3000)
+#define VE_CTI_GRP_REG (BIT_BASE + 0x3004)
+#define VE_MBIST_CTRL (BIT_BASE + 0x3C08)
+#define VE_BISR_POWER_RESET (BIT_BASE + 0x3CB0)
+
+static void ve1_wrapper_setup(struct vpu_device *dev)
+{
+	unsigned int ctrl_1;
+	unsigned int ctrl_2;
+	unsigned int ctrl_3;
+	unsigned int ctrl_4;
+	int i;
+
+	if (!dev) {
+		return;
+	}
+
+	ctrl_1 = coda_vdi_readl(dev, VE_CTRL_REG);
+	ctrl_2 = coda_vdi_readl(dev, VE_CTI_GRP_REG);
+	ctrl_3 = coda_vdi_readl(dev, VE_BISR_POWER_RESET);
+	ctrl_1 |= (ve_cti_en << 1 | ve_idle_en << 6);
+	/* ve1_cti_cmd_depth for 1296 timing issue */
+	ctrl_2 = (ctrl_2 & ~(0x3f << 24)) | (0x1a << 24);
+	ctrl_3 |= (1 << 12);
+	/*Set BISR POWER RESET bit12 to 1, make AXI available in stark*/
+	coda_vdi_writel(dev, VE_CTRL_REG, ctrl_1);
+	coda_vdi_writel(dev, VE_CTI_GRP_REG, ctrl_2);
+	coda_vdi_writel(dev, VE_BISR_POWER_RESET, ctrl_3);
+
+	for (i = 0; i < 2; i++) { //workaround for TP1CK MEM TEST1 in stark
+		ctrl_4 = coda_vdi_readl(dev, VE_MBIST_CTRL);
+		ctrl_4 ^= (1 << 2); //toggle TEST1 signal of MEM
+		coda_vdi_writel(dev, VE_MBIST_CTRL, ctrl_4);
+	}
+}
+
+struct coda_match_data {
+	int flags;
+	const char *fw_name;
+	unsigned int sram_size;
+};
+
+static const struct coda_match_data coda988_data = {
+	.flags = CODA_IS_DEC,
+	.fw_name = "coda988_codec_fw.bin",
+	.sram_size = 0x34600,
+};
+
+static int coda_initialize_vpu(struct device *dev, u8 *code, uint32_t size)
+{
+	int ret;
+	struct vpu_device *vpu_dev = dev_get_drvdata(dev);
+
+	ret = mutex_lock_interruptible(&vpu_dev->hw_lock);
+	if (ret)
+		return ret;
+
+	if (coda_vpu_is_init(vpu_dev))
+		goto mutex_unlock;
+
+	ret = coda_vpu_reset(vpu_dev, SW_RESET_ON_BOOT);
+	if (ret) {
+		dev_err(vpu_dev->dev, "failed to reset the coda vpu  (%x)\n",
+			ret);
+		goto mutex_unlock;
+	}
+
+	ret = coda_vpu_init(dev, (void *)code, size);
+	if (ret) {
+		dev_err(vpu_dev->dev,
+			"failed to initialize the coda vpu  (%x)\n", ret);
+	}
+
+mutex_unlock:
+	mutex_unlock(&vpu_dev->hw_lock);
+
+	return ret;
+}
+
+int coda_vpu_init_with_bitcode(struct device *dev, u8 *code, uint32_t size)
+{
+	if (!code || size == 0)
+		return -EINVAL;
+
+	return coda_initialize_vpu(dev, code, size);
+}
+
+static int coda_vpu_load_firmware(struct device *dev, const char *fw_name)
+{
+	const struct firmware *fw;
+	int ret;
+
+	ret = request_firmware(&fw, fw_name, dev);
+	if (ret) {
+		dev_err(dev, "request_firmware fail\n");
+		return ret;
+	}
+
+	dev_dbg(dev, "%d.%s.fw size : %ld\n", __LINE__, __func__, fw->size);
+	ret = coda_vpu_init_with_bitcode(dev, (u8 *)fw->data, fw->size);
+	if (ret) {
+		dev_err(dev, "vpu_init_with_bitcode fail\n");
+		goto release_fw;
+	}
+	release_firmware(fw);
+
+	return 0;
+
+release_fw:
+	release_firmware(fw);
+	return ret;
+}
+
+static irqreturn_t coda_vpu_irq_thread(int irq, void *dev_id)
+{
+	struct vpu_device *dev = dev_id;
+	struct vpu_instance *inst;
+	int irq_status, ret;
+
+	while (kfifo_len(&dev->irq_status)) {
+		inst = v4l2_m2m_get_curr_priv(dev->m2m_dev);
+		ret = kfifo_out(&dev->irq_status, &irq_status, sizeof(int));
+		if (!ret)
+			break;
+		complete(&dev->irq_done);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t coda_vpu_irq(int irq, void *dev_id)
+{
+	struct vpu_device *dev = dev_id;
+	u32 irq_status;
+
+	if (coda_vdi_readl(dev, BIT_INT_STS)) {
+		irq_status = coda_vdi_readl(dev, BIT_INT_REASON);
+		coda_vdi_writel(dev, BIT_INT_CLEAR, 0x1);
+		coda_vdi_writel(dev, BIT_INT_REASON,
+				0); // Coda9VpuClearInterrupt
+
+		kfifo_in(&dev->irq_status, &irq_status, sizeof(int));
+		//dev_dbg(dev->dev, "%d.%s.irq_status: %08X\n", __LINE__, __func__, irq_status);
+
+		return IRQ_WAKE_THREAD;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static const struct media_device_ops coda9_m2m_media_ops = {
+	.req_validate = vb2_request_validate,
+	.req_queue = v4l2_m2m_request_queue,
+};
+
+static int coda_vpu_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct vpu_device *dev;
+	const struct coda_match_data *match_data;
+
+	dev_dbg(&pdev->dev, "%d.%s.enter\n", __LINE__, __func__);
+
+	match_data = device_get_match_data(&pdev->dev);
+	if (!match_data) {
+		dev_err(&pdev->dev, "missing match_data\n");
+		return -EINVAL;
+	}
+	dev_dbg(&pdev->dev, "%d.%s.match_data(%d, 0x%x, %s)\n", __LINE__,
+		 __func__, match_data->flags, match_data->sram_size,
+		 match_data->fw_name);
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+	dev->vdb_register = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(dev->vdb_register))
+		return PTR_ERR(dev->vdb_register);
+
+	ret = of_reserved_mem_device_init(&pdev->dev);
+	if (ret)
+		dev_warn(&pdev->dev, "init reserved memory failed");
+
+	ida_init(&dev->inst_ida);
+	dev_dbg(&pdev->dev, "%d.%s.vdb_register:0x%px\n", __LINE__, __func__,
+		dev->vdb_register);
+
+	mutex_init(&dev->dev_lock);
+	mutex_init(&dev->hw_lock);
+	init_completion(&dev->irq_done);
+	dev_set_drvdata(&pdev->dev, dev);
+	dev->dev = &pdev->dev;
+
+	ret = devm_clk_bulk_get_all(&pdev->dev, &dev->clks);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "Getting clocks, fail: %d\n", ret);
+		ret = 0;
+	}
+	dev->num_clks = ret;
+	dev_dbg(&pdev->dev, "%d.%s.num_clks:%d\n", __LINE__, __func__,
+		dev->num_clks);
+
+	ret = clk_bulk_prepare_enable(dev->num_clks, dev->clks);
+	if (ret) {
+		dev_err(&pdev->dev, "Enabling clocks, fail: %d\n", ret);
+		return ret;
+	}
+	/*
+	dev->sram_pool = of_gen_pool_get(pdev->dev.of_node, "sram", 0);
+	if (!dev->sram_pool) {
+		dev_warn(&pdev->dev, "sram node not found\n");
+	} else {
+		dev->sram_buf.size = match_data->sram_size;
+		dev->sram_buf.vaddr = gen_pool_dma_alloc(dev->sram_pool,
+							 dev->sram_buf.size,
+							 &dev->sram_buf.daddr);
+		if (!dev->sram_buf.vaddr)
+			dev->sram_buf.size = 0;
+
+		dev_dbg(&pdev->dev, "sram daddr: %pad, size: 0x%lx\n",
+			 &dev->sram_buf.daddr, dev->sram_buf.size);
+	}
+*/
+	dev->sram_buf.size = VDI_CODA9_SRAM_SIZE;
+	dev->sram_buf.daddr = VDI_SRAM_BASE_ADDR;
+	dev->sram_buf.vaddr = NULL;
+	dev_dbg(&pdev->dev, "%d.%s.sram_buf(%ld, 0x%llx)\n", __LINE__, __func__,
+		dev->sram_buf.size, dev->sram_buf.daddr);
+
+	/*
+	np = of_parse_phandle(pdev->dev.of_node, "boot", 0);
+	if (!np) {
+		dev_err(&pdev->dev, "boot node is not found.\n");
+		ret = -ENODEV;
+		goto err_vdi_init;
+	}
+
+	ret = of_address_to_resource(np, 0, &mem);
+	of_node_put(np);
+	if (ret) {
+		dev_err(&pdev->dev, "boot resource not available.\n");
+		goto err_vdi_init;
+	}
+
+	dev->common_mem.daddr = mem.start;
+	dev->common_mem.size = resource_size(&mem);
+	if (dev->common_mem.size < SIZE_COMMON) {
+		dev_err(&pdev->dev, "boot memory size is small.\n");
+		goto err_vdi_init;
+	}
+
+	dev->common_mem.vaddr = devm_memremap(&pdev->dev,
+					      dev->common_mem.daddr,
+					      dev->common_mem.size,
+					      MEMREMAP_WC);
+	if (!dev->common_mem.vaddr) {
+		dev_err(&pdev->dev, "boot memory mapping fail.\n");
+		goto err_vdi_init;
+	}
+
+	dev_dbg(&pdev->dev, "boot daddr: %pad, size: 0x%lx\n",
+		 &dev->common_mem.daddr, dev->common_mem.size);
+*/
+	dev->common_mem.size = SIZE_COMMON;
+	ret = coda_vdi_allocate_dma_memory(dev, &dev->common_mem);
+	if (ret) {
+		dev_err(&pdev->dev, "%d.%s.coda_vdi_allocate_dma_memory fail\n",
+			__LINE__, __func__);
+		goto err_vdi_init;
+	}
+	dev_dbg(&pdev->dev, "%d.%s.common_mem(%lu, 0x%llx, 0x%px)\n", __LINE__,
+		__func__, dev->common_mem.size, dev->common_mem.daddr,
+		dev->common_mem.vaddr);
+
+	ve1_wrapper_setup(dev);
+
+	dev->product_code = coda_vdi_readl(dev, VPU_PRODUCT_CODE_REGISTER);
+	dev->product = coda_vpu_get_product_id(dev);
+	dev_dbg(&pdev->dev, "%d.%s.product_code:0x%x.product:0x%x\n", __LINE__,
+		 __func__, dev->product_code, dev->product);
+
+	dev->mdev.dev = &pdev->dev;
+
+	strscpy(dev->mdev.model, VPU_DEC_DRV_NAME, sizeof(dev->mdev.model));
+
+	media_device_init(&dev->mdev);
+	dev->mdev.ops = &coda9_m2m_media_ops;
+	dev->v4l2_dev.mdev = &dev->mdev;
+
+	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "v4l2_device_register fail: %d\n", ret);
+		goto err_vdi_init;
+	}
+
+	if (match_data->flags & CODA_IS_DEC) {
+		ret = coda_vpu_dec_register_device(dev);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"coda_vpu_dec_register_device fail: %d\n", ret);
+			goto err_v4l2_unregister;
+		}
+	}
+
+	ret = coda_vpu_init_m2m_dev(dev);
+	if (ret)
+		goto err_dec_unreg;
+
+	ret = v4l2_m2m_register_media_controller(
+		dev->m2m_dev, dev->video_dev_dec,
+		MEDIA_ENT_F_PROC_VIDEO_DECODER);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to init m2m media controller\n");
+		goto err_m2m_dev_release;
+	}
+
+	ret = media_device_register(&dev->mdev);
+	if (ret)
+		goto err_m2m_media_release;
+
+	if (kfifo_alloc(&dev->irq_status, 16 * sizeof(int), GFP_KERNEL)) {
+		dev_err(&pdev->dev, "failed to allocate fifo\n");
+		goto err_media_unregister;
+	}
+
+	ret = coda_vpu_load_firmware(&pdev->dev, match_data->fw_name);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to coda_vpu_load_firmware: %d\n",
+			ret);
+		goto err_kfifo_free;
+	}
+
+	dev->irq = platform_get_irq(pdev, 0);
+	if (dev->irq < 0) {
+		dev_err(&pdev->dev, "failed to get irq resource\n");
+		ret = -ENXIO;
+		goto err_kfifo_free;
+	}
+
+	dev_dbg(&pdev->dev, "%d.%s.device irq : %d\n", __LINE__, __func__, dev->irq);
+	ret = devm_request_threaded_irq(&pdev->dev, dev->irq, coda_vpu_irq,
+					coda_vpu_irq_thread, 0, "vpu_irq", dev);
+	if (ret) {
+		dev_err(&pdev->dev, "fail to register interrupt handler: %d\n",
+			ret);
+		goto err_kfifo_free;
+	}
+
+	dev_err(&pdev->dev,
+		"Added wave driver with caps %s and product code 0x%x\n",
+		match_data->flags & CODA_IS_DEC ? "'DECODE'" : "",
+		dev->product_code);
+
+	dev_dbg(&pdev->dev, "%d.%s.leave\n", __LINE__, __func__);
+	return 0;
+
+err_kfifo_free:
+	kfifo_free(&dev->irq_status);
+err_media_unregister:
+	media_device_unregister(&dev->mdev);
+err_m2m_media_release:
+	v4l2_m2m_unregister_media_controller(dev->m2m_dev);
+err_m2m_dev_release:
+	coda_vpu_release_m2m_dev(dev);
+err_dec_unreg:
+	if (match_data->flags & CODA_IS_DEC)
+		coda_vpu_dec_unregister_device(dev);
+err_v4l2_unregister:
+	v4l2_device_unregister(&dev->v4l2_dev);
+	media_device_cleanup(&dev->mdev);
+err_vdi_init:
+	/*
+	if (dev->sram_pool && dev->sram_buf.vaddr)
+		gen_pool_free(dev->sram_pool,
+			(unsigned long)dev->sram_buf.vaddr,
+			dev->sram_buf.size);
+*/
+	if (dev->common_mem.vaddr) {
+		coda_vdi_free_dma_memory(dev, &dev->common_mem);
+	}
+	clk_bulk_disable_unprepare(dev->num_clks, dev->clks);
+
+	dev_err(&pdev->dev, "%d.%s.leave.ret:%d\n", __LINE__, __func__, ret);
+	return ret;
+}
+
+static int coda_vpu_remove(struct platform_device *pdev)
+{
+	struct vpu_device *dev = dev_get_drvdata(&pdev->dev);
+	/*
+	if (dev->sram_pool && dev->sram_buf.vaddr)
+		gen_pool_free(dev->sram_pool,
+			      (unsigned long)dev->sram_buf.vaddr,
+			      dev->sram_buf.size);
+*/
+	if (dev->common_mem.vaddr) {
+		coda_vdi_free_dma_memory(dev, &dev->common_mem);
+	}
+	clk_bulk_disable_unprepare(dev->num_clks, dev->clks);
+	media_device_unregister(&dev->mdev);
+	v4l2_m2m_unregister_media_controller(dev->m2m_dev);
+	coda_vpu_release_m2m_dev(dev);
+	coda_vpu_dec_unregister_device(dev);
+	v4l2_device_unregister(&dev->v4l2_dev);
+	media_device_cleanup(&dev->mdev);
+	kfifo_free(&dev->irq_status);
+
+	return 0;
+}
+
+static const struct of_device_id coda980_dt_ids[] = {
+	{ .compatible = "realtek,rtk13xx-ve1", .data = &coda988_data },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, coda980_dt_ids);
+
+static struct platform_driver coda_vpu_driver = {
+	.driver = {
+		.name = VPU_PLATFORM_DEVICE_NAME,
+		.of_match_table = of_match_ptr(coda980_dt_ids),
+		},
+	.probe = coda_vpu_probe,
+	.remove = coda_vpu_remove,
+};
+
+module_platform_driver(coda_vpu_driver);
+MODULE_DESCRIPTION("chips&media VPU V4L2 driver");
+MODULE_LICENSE("Dual BSD/GPL");
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-common.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-common.c
@@ -0,0 +1,97 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+
+#include <linux/v4l2-common.h>
+#include "rtkve-common.h"
+
+struct vpu_buf *rtkve_allocate_dma_memory(struct device *dev, size_t size)
+{
+	struct vpu_buf *buf_hdl = NULL;
+	void *vaddr;
+	dma_addr_t dma_addr;
+
+	if (!size) {
+		dev_err(dev, "%s(): requested size==0\n", __func__);
+		goto exit;
+	}
+#if 0
+	if (size < SZ_8K)
+		size = SZ_8K;
+#endif
+	buf_hdl = kzalloc(sizeof(*buf_hdl), GFP_KERNEL);
+	if (!buf_hdl) {
+		dev_err(dev, "%s allocate vpu_buf fail, No Memory\n", __func__);
+		goto exit;
+	}
+
+	vaddr = dma_alloc_coherent(dev, size, &dma_addr, GFP_KERNEL);
+	if (!vaddr) {
+		dev_err(dev, "%s dma_alloc fail \n", __func__);
+		kfree(buf_hdl);
+		buf_hdl = NULL;
+		goto exit;
+	}
+
+	buf_hdl->vaddr = vaddr;
+	buf_hdl->daddr = dma_addr;
+	buf_hdl->size = size;
+	memset(buf_hdl->vaddr, 0, size);
+exit:
+	return buf_hdl;
+}
+
+void rtkve_free_dma_memory(struct device *dev, struct vpu_buf *vb)
+{
+	if (vb->size == 0)
+		goto exit;
+
+	if (!vb->vaddr)
+		dev_err(dev, "%s(): requested free of unmapped buffer\n",
+			__func__);
+	else
+		dma_free_coherent(dev, vb->size, vb->vaddr, vb->daddr);
+
+	kfree(vb);
+exit:
+	return;
+}
+
+void word_endian_convert(uint8_t *dst, uint8_t *src, int len)
+{
+	int i;
+	uint16_t *s_ptr = (uint16_t *)src;
+	uint16_t *d_ptr = (uint16_t *)dst;
+	int size = len / sizeof(uint16_t);
+
+	for (i = 0; i < size; i++) {
+		d_ptr[i] = htons(s_ptr[i]);
+	}
+}
+
+void dword_endian_convert(uint8_t *dst, uint8_t *src, int len)
+{
+	int i;
+	uint32_t *s_ptr = (uint32_t *)src;
+	uint32_t *d_ptr = (uint32_t *)dst;
+	int size = len / sizeof(uint32_t);
+
+	for (i = 0; i < size; i++) {
+		d_ptr[i] = htonl(s_ptr[i]);
+	}
+}
+
+uint64_t htonll(long long val)
+{
+	return (((long long)htonl(val)) << 32) + htonl(val >> 32);
+}
+
+void qword_endian_convert(uint8_t *dst, uint8_t *src, int len)
+{
+	int i;
+	uint64_t *s_ptr = (uint64_t *)src;
+	uint64_t *d_ptr = (uint64_t *)dst;
+	int size = len / sizeof(uint64_t);
+
+	for (i = 0; i < size; i++) {
+		d_ptr[i] = htonll(s_ptr[i]);
+	}
+}
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-common.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-common.h
@@ -0,0 +1,213 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+#ifndef RTKVE_COMMON_H
+#define RTKVE_COMMON_H
+
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/v4l2-ctrls.h>
+
+#include "rtkve-rpc-def.h"
+
+#define VPU_DEC_DRV_NAME "rtkve-dec"
+#define VPU_DEC_DEV_NAME "RTK Video Engine decoder"
+
+#define RTKVE_MAX_FBS 32
+#define DROP_CNT_MAX 8
+
+//#define INFORM_DROP
+
+enum cod_std { STD_HEVC, STD_VP9, STD_AV1, STD_MAX };
+
+enum vpu_fmt_type { VPU_FMT_TYPE_CODEC = 0, VPU_FMT_TYPE_RAW = 1 };
+
+enum vpu_instance_state {
+	VPU_INST_STATE_NONE = 0,
+	VPU_INST_STATE_OPEN = 1,
+	VPU_INST_STATE_INIT_SEQ = 2,
+	VPU_INST_STATE_PIC_RUN = 3,
+	VPU_INST_STATE_SEEK = 4,
+	VPU_INST_STATE_STOP = 5
+};
+
+enum vpu_instance_type { VPU_INST_TYPE_DEC = 0, VPU_INST_TYPE_ENC = 1 };
+
+struct vpu_buf {
+	size_t size;
+	dma_addr_t daddr;
+	void *vaddr;
+};
+
+struct stateless_hevc_info {
+	const struct v4l2_ctrl_hevc_sps *sps;
+	const struct v4l2_ctrl_hevc_pps *pps;
+	const struct v4l2_ctrl_hevc_scaling_matrix *sm;
+	const struct v4l2_ctrl_hevc_slice_params *spram;
+	const struct v4l2_ctrl_hevc_decode_params *dpram;
+	uint32_t spram_cnt;
+};
+
+struct stateless_vp9_info {
+	const struct v4l2_ctrl_vp9_frame *frame;
+	const struct v4l2_ctrl_vp9_compressed_hdr *cmprs_hdr;
+};
+
+struct stateless_av1_info {
+	const struct v4l2_ctrl_av1_sequence *seq;
+	const struct v4l2_ctrl_av1_frame *frm;
+	const struct v4l2_ctrl_av1_film_grain *film_grain;
+	const struct v4l2_ctrl_av1_tile_group_entry *tge;
+	uint32_t tge_cnt;
+};
+
+struct vpu_rect {
+	u32 left; /* A horizontal pixel offset of top-left corner of rectangle from (0, 0) */
+	u32 top; /* A vertical pixel offset of top-left corner of rectangle from (0, 0) */
+	u32 right; /* A horizontal pixel offset of bottom-right corner of rectangle from (0, 0) */
+	u32 bottom; /* A vertical pixel offset of bottom-right corner of rectangle from (0, 0) */
+};
+
+struct frame_buffer {
+	dma_addr_t buf_y;
+	dma_addr_t buf_cb;
+	dma_addr_t buf_cr;
+	dma_addr_t buf_y_bot;
+	dma_addr_t buf_cb_bot;
+	dma_addr_t buf_cr_bot;
+	unsigned int stride; /* A horizontal stride for given frame buffer */
+	unsigned int width; /* A width for given frame buffer */
+	unsigned int height; /* A height for given frame buffer */
+	unsigned int sequence_no;
+	int index;
+	u32 luma_bitdepth : 4;
+	u32 chroma_bitdepth : 4;
+	u32 chroma_format_idc : 2;
+};
+
+struct dec_output_info {
+	int pic_width;
+	int pic_height;
+	int pic_type;
+	int aspect_rate_info;
+	int num_of_err_mbs;
+	u32 buf_addr_y;
+	u32 buf_addr_c;
+	u32 drop_timestamp;
+};
+
+struct dec_param {
+	dma_addr_t
+		buf_addr_y; /**< It specifies the Y buffer address of stateless decoding. */
+	dma_addr_t
+		buf_addr_c; /**< It specifies the Cb buffer address of stateless decoding. */
+	unsigned int wPtr; //PTS_INFO
+	unsigned int PTSH; //PTS_INFO
+	unsigned int PTSL;
+	unsigned int pre_PTSH; //PTS_INFO
+	unsigned int pre_PTSL;
+	u32 bs_len;
+#if 0
+	struct stateless_hevc_info	hevc;
+	struct stateless_vp9_info	vp9;
+	struct stateless_av1_info	av1;
+#endif
+	//struct AV1_V4L2_CTRL_INFO av1;
+};
+
+struct pts_mapping {
+	struct list_head list;
+	uint32_t pts;
+	dma_addr_t y_addr;
+};
+
+struct vpu_instance {
+	struct list_head list;
+	struct v4l2_fh v4l2_fh;
+	struct v4l2_ctrl_handler v4l2_ctrl_hdl;
+	struct vpu_device *dev;
+
+	struct v4l2_pix_format_mplane src_fmt;
+	struct v4l2_pix_format_mplane dst_fmt;
+	struct v4l2_rect crop;
+	enum v4l2_colorspace colorspace;
+	enum v4l2_xfer_func xfer_func;
+	enum v4l2_ycbcr_encoding ycbcr_enc;
+	enum v4l2_quantization quantization;
+
+	enum vpu_instance_state state;
+	enum vpu_instance_type type;
+
+	enum VIDEO_STREAM_TYPE std;
+	u32 id;
+	u32 queued_src_buf_num;
+	u32 queued_dst_buf_num;
+	bool nv21;
+	bool eos;
+	bool is_10bit_bitstream;
+
+	struct vpu_handler *flash_hdl;
+	struct vpu_handler *dec_hdl;
+
+	struct task_struct *input_thread;
+	wait_queue_head_t input_waitq;
+	wait_queue_head_t output_waitq;
+	struct work_struct decode_work;
+
+	struct list_head srcbuf_list;
+	struct list_head dstbuf_list;
+	struct list_head pts_mapping_list;
+	struct mutex pts_mutex;
+	spinlock_t srcbuf_lock;
+	spinlock_t dstbuf_lock;
+
+	//stateful
+	bool initialized;
+	bool is_bs_error;
+	bool is_decoder_error;
+	u32 drop_cnt;
+	u32 drop_timestamp[DROP_CNT_MAX];
+};
+
+struct rtkve_match_data {
+	const struct vpu_format *(*find_vpu_fmt)(unsigned int v4l2_pix_fmt,
+						 enum vpu_fmt_type type);
+	const struct vpu_format *(*find_vpu_fmt_by_idx)(unsigned int idx,
+							enum vpu_fmt_type type);
+	int (*ctrls_setup)(struct vpu_instance *inst);
+	int (*queue_init)(void *priv, struct vb2_queue *src_vq,
+			  struct vb2_queue *dst_vq);
+	void (*dev_run_work)(struct work_struct *work);
+	void (*stop_decode)(struct vpu_instance *inst);
+	int (*create_instance)(struct vpu_instance *inst);
+	void (*destroy_instance)(struct vpu_instance *inst);
+	void (*suspend)(struct vpu_instance *inst);
+	void (*resume)(struct vpu_instance *inst);
+
+	bool is_stateless;
+};
+
+struct vpu_device {
+	struct device *dev;
+	struct v4l2_device v4l2_dev;
+	struct media_device mdev;
+	struct v4l2_m2m_dev *m2m_dev;
+	struct list_head instances;
+	const struct rtkve_match_data *rtkve_mdata;
+	struct video_device *video_dev_dec;
+	struct mutex dev_lock; /* lock for the src, dst v4l2 queues */
+	struct mutex hw_lock; /* lock hw configurations */
+	struct kthread_work work;
+	struct kthread_worker *worker;
+	struct workqueue_struct *decode_workqueue;
+};
+
+struct vpu_buf *rtkve_allocate_dma_memory(struct device *dev, size_t size);
+void rtkve_free_dma_memory(struct device *dev, struct vpu_buf *vb);
+uint64_t htonll(long long val);
+void word_endian_convert(uint8_t *dst, uint8_t *src, int len);
+void dword_endian_convert(uint8_t *dst, uint8_t *src, int len);
+void qword_endian_convert(uint8_t *dst, uint8_t *src, int len);
+#endif
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-dec-drv.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-dec-drv.c
@@ -0,0 +1,378 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/of_address.h>
+#include <linux/genalloc.h>
+#include <linux/firmware.h>
+#include <linux/of_reserved_mem.h>
+
+#include "rtkve-vpu.h"
+
+#define VPU_PLATFORM_DEVICE_NAME "rtkve-dec"
+
+#define VPU_CLK_NAME "vcodec"
+
+#define MAX_DEC_INST_NUM (15)
+// rtk
+
+static const struct media_device_ops rtkve_m2m_media_ops = {
+	.req_validate = vb2_request_validate,
+	.req_queue = v4l2_m2m_request_queue,
+};
+
+static int rtkve_dec_open(struct file *filp)
+{
+	struct video_device *vdev = video_devdata(filp);
+	struct vpu_device *dev = video_drvdata(filp);
+	const struct rtkve_match_data *dec_pdata = NULL;
+	struct vpu_instance *inst = NULL;
+	int ret;
+
+	if (!dev) {
+		ret = -EBUSY;
+		dev_err(dev->dev, "V4L2 decoder device not ready yet\n");
+		goto exit;
+	}
+
+	ret = mutex_lock_interruptible(&dev->dev_lock);
+	if (ret) {
+		ret = -ERESTARTSYS;
+		goto exit;
+	}
+
+	inst = kzalloc(sizeof(*inst), GFP_KERNEL);
+	if (!inst) {
+		ret = -ENOMEM;
+		dev_err(dev->dev, "V4L2 decoder resource allocation failure\n");
+		goto unlock_mutex;
+	}
+
+	dec_pdata = dev->rtkve_mdata;
+	inst->dev = dev;
+	inst->type = VPU_INST_TYPE_DEC;
+
+	v4l2_fh_init(&inst->v4l2_fh, vdev);
+	filp->private_data = &inst->v4l2_fh;
+	v4l2_fh_add(&inst->v4l2_fh);
+
+	inst->v4l2_fh.m2m_ctx =
+		v4l2_m2m_ctx_init(dev->m2m_dev, inst, dec_pdata->queue_init);
+	if (IS_ERR(inst->v4l2_fh.m2m_ctx)) {
+		ret = PTR_ERR(inst->v4l2_fh.m2m_ctx);
+		goto free_inst;
+	}
+
+	if (dec_pdata->ctrls_setup(inst)) {
+		ret = -ENODEV;
+		goto err_m2m_release;
+	}
+
+	rtkve_set_default_format(inst, &inst->src_fmt, &inst->dst_fmt);
+	inst->colorspace = V4L2_COLORSPACE_DEFAULT;
+	inst->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	inst->quantization = V4L2_QUANTIZATION_DEFAULT;
+	inst->xfer_func = V4L2_XFER_FUNC_DEFAULT;
+
+	INIT_WORK(&inst->decode_work, dec_pdata->dev_run_work);
+	init_waitqueue_head(&inst->input_waitq);
+	init_waitqueue_head(&inst->output_waitq);
+
+	list_add_tail(&inst->list, &dev->instances);
+	mutex_unlock(&dev->dev_lock);
+	return 0;
+
+err_m2m_release:
+	v4l2_m2m_ctx_release(inst->v4l2_fh.m2m_ctx);
+free_inst:
+	kfree(inst);
+unlock_mutex:
+	mutex_unlock(&dev->dev_lock);
+exit:
+	return ret;
+}
+
+static int rtkve_dec_release(struct file *file)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(file->private_data);
+	struct vpu_device *dev = NULL;
+
+	if (!inst || !inst->dev)
+		goto exit;
+
+	dev = inst->dev;
+
+	mutex_lock(&dev->dev_lock);
+	v4l2_m2m_ctx_release(inst->v4l2_fh.m2m_ctx);
+
+	if (inst->state != VPU_INST_STATE_NONE) {
+		const struct rtkve_match_data *dec_pdata = dev->rtkve_mdata;
+
+		v4l2_m2m_suspend(dev->m2m_dev);
+		dec_pdata->destroy_instance(inst);
+		v4l2_m2m_resume(dev->m2m_dev);
+	}
+
+	v4l2_ctrl_handler_free(&inst->v4l2_ctrl_hdl);
+	v4l2_fh_del(&inst->v4l2_fh);
+	v4l2_fh_exit(&inst->v4l2_fh);
+	list_del(&inst->list);
+	kfree(inst);
+	inst = NULL;
+	mutex_unlock(&dev->dev_lock);
+exit:
+	return 0;
+}
+
+static const struct v4l2_file_operations rtkve_dec_fops = {
+	.owner = THIS_MODULE,
+	.open = rtkve_dec_open,
+	.release = rtkve_dec_release,
+	.unlocked_ioctl = video_ioctl2,
+	.poll = v4l2_m2m_fop_poll,
+	.mmap = v4l2_m2m_fop_mmap,
+};
+
+static int rtkve_dec_register_device(struct vpu_device *dev, bool is_stateless)
+{
+	struct video_device *vdev_dec;
+	int ret = 0;
+
+	vdev_dec =
+		devm_kzalloc(dev->v4l2_dev.dev, sizeof(*vdev_dec), GFP_KERNEL);
+	if (!vdev_dec) {
+		ret = -ENOMEM;
+		dev_err(dev->dev, "alloc devm failed\n");
+		goto exit;
+	}
+
+	dev->video_dev_dec = vdev_dec;
+
+	strscpy(vdev_dec->name, VPU_DEC_DEV_NAME, sizeof(vdev_dec->name));
+	vdev_dec->fops = &rtkve_dec_fops;
+	vdev_dec->ioctl_ops = &rtkve_dec_ioctl_ops;
+	vdev_dec->release = video_device_release_empty;
+	vdev_dec->v4l2_dev = &dev->v4l2_dev;
+	vdev_dec->vfl_dir = VFL_DIR_M2M;
+	vdev_dec->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;
+	vdev_dec->lock = &dev->dev_lock;
+
+	if (is_stateless) {
+		v4l2_disable_ioctl(vdev_dec, VIDIOC_DECODER_CMD);
+		v4l2_disable_ioctl(vdev_dec, VIDIOC_TRY_DECODER_CMD);
+	}
+
+	video_set_drvdata(vdev_dec, dev);
+
+	ret = video_register_device(vdev_dec, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		dev_err(dev->dev, "video_register_device failed, ret %d\n",
+			ret);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+static void rtkve_dec_unregister_device(struct vpu_device *dev)
+{
+	video_unregister_device(dev->video_dev_dec);
+}
+
+static int rtkve_dec_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct vpu_device *dev;
+
+	dev_info(&pdev->dev, "%d.%s.enter\n", __LINE__, __func__);
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&pdev->dev, "alloc devm failed\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	dev->rtkve_mdata = device_get_match_data(&pdev->dev);
+	if (!dev->rtkve_mdata) {
+		dev_err(&pdev->dev, "missing match_data\n");
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	ret = of_reserved_mem_device_init(&pdev->dev);
+	if (ret)
+		dev_warn(&pdev->dev, "init reserved memory failed");
+	else
+		pdev->dev.coherent_dma_mask = 0x60000000;
+
+	mutex_init(&dev->dev_lock);
+	mutex_init(&dev->hw_lock);
+	dev_set_drvdata(&pdev->dev, dev);
+	dev->dev = &pdev->dev;
+	strscpy(dev->mdev.model, VPU_DEC_DRV_NAME, sizeof(dev->mdev.model));
+
+	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "v4l2_device_register fail: %d\n", ret);
+		goto exit;
+	}
+
+	ret = rtkve_dec_init_m2m_dev(dev);
+	if (ret)
+		goto err_dec_unreg;
+
+	dev->decode_workqueue = alloc_ordered_workqueue(
+		VPU_DEC_DRV_NAME, WQ_MEM_RECLAIM | WQ_FREEZABLE);
+	if (!dev->decode_workqueue) {
+		dev_err(&pdev->dev, "Failed to create decode workqueue");
+		ret = -EINVAL;
+		goto err_dec_workq;
+	}
+
+	ret = rtkve_dec_register_device(dev, dev->rtkve_mdata->is_stateless);
+	if (ret) {
+		dev_err(&pdev->dev, "coda_vpu_dec_register_device fail: %d\n",
+			ret);
+		goto err_v4l2_unregister;
+	}
+
+	if (dev->rtkve_mdata->is_stateless) {
+		media_device_init(&dev->mdev);
+		dev->mdev.dev = &pdev->dev;
+		dev->mdev.ops = &rtkve_m2m_media_ops;
+		dev->v4l2_dev.mdev = &dev->mdev;
+
+		ret = v4l2_m2m_register_media_controller(
+			dev->m2m_dev, dev->video_dev_dec,
+			MEDIA_ENT_F_PROC_VIDEO_DECODER);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"failed to init m2m media controller\n");
+			goto err_m2m_dev_release;
+		}
+
+		ret = media_device_register(&dev->mdev);
+		if (ret)
+			goto err_m2m_media_release;
+	}
+
+	INIT_LIST_HEAD(&dev->instances);
+
+	dev_info(&pdev->dev, "%d.%s.leave\n", __LINE__, __func__);
+	return 0;
+
+err_m2m_media_release:
+	if (dev->m2m_dev)
+		v4l2_m2m_unregister_media_controller(dev->m2m_dev);
+err_m2m_dev_release:
+	media_device_cleanup(&dev->mdev);
+	rtkve_dec_unregister_device(dev);
+err_v4l2_unregister:
+	destroy_workqueue(dev->decode_workqueue);
+err_dec_workq:
+	v4l2_m2m_release(dev->m2m_dev);
+err_dec_unreg:
+	v4l2_device_unregister(&dev->v4l2_dev);
+
+exit:
+	dev_err(&pdev->dev, "%d.%s.leave.ret:%d\n", __LINE__, __func__, ret);
+	return ret;
+}
+
+static int rtkve_dec_remove(struct platform_device *pdev)
+{
+	struct vpu_device *dev = dev_get_drvdata(&pdev->dev);
+
+	if (dev->decode_workqueue)
+		destroy_workqueue(dev->decode_workqueue);
+
+	media_device_unregister(&dev->mdev);
+	v4l2_m2m_unregister_media_controller(dev->m2m_dev);
+	v4l2_m2m_release(dev->m2m_dev);
+	rtkve_dec_unregister_device(dev);
+	v4l2_device_unregister(&dev->v4l2_dev);
+	media_device_cleanup(&dev->mdev);
+
+	return 0;
+}
+
+static const struct of_device_id rtkve_dt_ids[] = {
+	//{ .compatible = "realtek,rtd16xxb-ve2", .data = &rtkve2_data_stateful },
+	{ .compatible = "realtek,rtd16xxb-ve2-sl",
+	  .data = &rtkve2_data_stateless },
+	{ .compatible = "realtek,kent-ve2-sl",
+	  .data = &rtkve2_data_stateless },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, rtkve_dt_ids);
+
+static int rtkve_dec_suspend(struct device *dev)
+{
+	struct vpu_device *vdev = dev_get_drvdata(dev);
+	const struct rtkve_match_data *dec_pdata = vdev->rtkve_mdata;
+	struct vpu_instance *inst = NULL;
+	int ret = 0;
+
+	list_for_each_entry(inst, &vdev->instances, list) {
+		if (inst && inst->state != VPU_INST_STATE_NONE) {
+			mutex_lock(&inst->dev->dev_lock);
+			dec_pdata->suspend(inst);
+			mutex_unlock(&inst->dev->dev_lock);
+		}
+	}
+
+	return ret;
+}
+
+static int rtkve_dec_resume(struct device *dev)
+{
+	struct vpu_device *vdev = dev_get_drvdata(dev);
+	const struct rtkve_match_data *dec_pdata = vdev->rtkve_mdata;
+	struct vpu_instance *inst = NULL;
+	int ret = 0;
+
+	list_for_each_entry(inst, &vdev->instances, list) {
+		if (inst && inst->state != VPU_INST_STATE_NONE) {
+			pr_err("rtkve_dec_resume %d", __LINE__);
+			mutex_lock(&inst->dev->dev_lock);
+			dec_pdata->resume(inst);
+			mutex_unlock(&inst->dev->dev_lock);
+		}
+	}
+
+	return ret;
+}
+
+static const struct dev_pm_ops rtkve_pm_ops = {
+	.suspend = rtkve_dec_suspend,
+	.resume = rtkve_dec_resume,
+};
+
+static struct platform_driver rtkve_driver = {
+	.driver = {
+		.name = VPU_PLATFORM_DEVICE_NAME,
+		.of_match_table = of_match_ptr(rtkve_dt_ids),
+		.pm	= &rtkve_pm_ops,
+		},
+	.probe = rtkve_dec_probe,
+	.remove = rtkve_dec_remove,
+};
+
+module_platform_driver(rtkve_driver);
+MODULE_DESCRIPTION("RTK Video Engine V4L2 driver");
+MODULE_LICENSE("Dual BSD/GPL");
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-dec-v4l2.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-dec-v4l2.c
@@ -0,0 +1,510 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#include "rtkve-vpu.h"
+
+void rtkve_update_pix_fmt(struct vpu_instance *inst,
+				 struct v4l2_pix_format_mplane *pix_mp,
+				 unsigned int width, unsigned int height)
+{
+	unsigned int alignment = 0;
+	pix_mp->flags = 0;
+	pix_mp->field = V4L2_FIELD_NONE;
+	memset(pix_mp->reserved, 0, sizeof(pix_mp->reserved));
+
+	switch (pix_mp->pixelformat) {
+	case V4L2_PIX_FMT_NV12:
+		alignment = 64;
+		if (inst->src_fmt.pixelformat == V4L2_PIX_FMT_AV1_FRAME)
+			alignment = 128;
+
+		width = round_up(width, alignment);
+		height = round_up(height, alignment);
+
+		if (inst->is_10bit_bitstream) {
+			alignment = 32;
+			if (inst->src_fmt.pixelformat == V4L2_PIX_FMT_HEVC_SLICE)
+				alignment = 64;
+
+			pix_mp->width = round_up(width * 10 / 8, alignment);
+		} else {
+			pix_mp->width = width;
+		}
+
+		pix_mp->height = height;
+		if (pix_mp->num_planes == 1) {
+			pix_mp->plane_fmt[0].bytesperline = pix_mp->width;
+			pix_mp->plane_fmt[0].sizeimage =
+				pix_mp->width * pix_mp->height * 3 / 2;
+		} else if (pix_mp->num_planes == 2) {
+			pix_mp->plane_fmt[0].bytesperline = pix_mp->width;
+			pix_mp->plane_fmt[0].sizeimage =
+				pix_mp->width * pix_mp->height;
+			pix_mp->plane_fmt[1].bytesperline = pix_mp->width;
+			pix_mp->plane_fmt[1].sizeimage =
+				pix_mp->plane_fmt[0].sizeimage / 2;
+		}
+		break;
+	default:
+		pix_mp->width = width;
+		pix_mp->height = height;
+		pix_mp->plane_fmt[0].bytesperline = 0;
+		if (!pix_mp->plane_fmt[0].sizeimage)
+			pix_mp->plane_fmt[0].sizeimage = width * height;
+
+		if (pix_mp->plane_fmt[0].sizeimage > RAW_DEFAULT_SIZEIMAGE)
+			pix_mp->plane_fmt[0].sizeimage = RAW_DEFAULT_SIZEIMAGE;
+
+		break;
+	}
+}
+
+void rtkve_set_default_format(struct vpu_instance *inst,
+			      struct v4l2_pix_format_mplane *src_fmt,
+			      struct v4l2_pix_format_mplane *dst_fmt)
+{
+	const struct rtkve_match_data *dec_pdata = inst->dev->rtkve_mdata;
+	const struct vpu_format *vpu_fmt;
+
+	vpu_fmt = dec_pdata->find_vpu_fmt_by_idx(0, VPU_FMT_TYPE_CODEC);
+
+	src_fmt->pixelformat = vpu_fmt->v4l2_pix_fmt;
+	src_fmt->num_planes = vpu_fmt->num_planes;
+	rtkve_update_pix_fmt(inst, src_fmt, 720, 480);
+
+	vpu_fmt = dec_pdata->find_vpu_fmt_by_idx(0, VPU_FMT_TYPE_RAW);
+
+	dst_fmt->pixelformat = vpu_fmt->v4l2_pix_fmt;
+	dst_fmt->num_planes = vpu_fmt->num_planes;
+	rtkve_update_pix_fmt(inst, dst_fmt, 736, 480);
+}
+
+static int rtkve_dec_querycap(struct file *file, void *fh,
+			      struct v4l2_capability *cap)
+{
+	strscpy(cap->driver, VPU_DEC_DRV_NAME, sizeof(cap->driver));
+	strscpy(cap->card, VPU_DEC_DRV_NAME, sizeof(cap->card));
+	strscpy(cap->bus_info, "platform:" VPU_DEC_DRV_NAME,
+		sizeof(cap->bus_info));
+
+	return 0;
+}
+
+static int rtkve_dec_enum_framesizes(struct file *f, void *fh,
+				     struct v4l2_frmsizeenum *fsize)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	const struct rtkve_match_data *dec_pdata = inst->dev->rtkve_mdata;
+	const struct vpu_format *vpu_fmt;
+	int ret = 0;
+
+	if (fsize->index) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	vpu_fmt = dec_pdata->find_vpu_fmt(fsize->pixel_format,
+					  VPU_FMT_TYPE_CODEC);
+	if (!vpu_fmt) {
+		vpu_fmt = dec_pdata->find_vpu_fmt(fsize->pixel_format,
+						  VPU_FMT_TYPE_RAW);
+		if (!vpu_fmt) {
+			ret = -EINVAL;
+			goto exit;
+		}
+	}
+
+	fsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;
+	fsize->stepwise.min_width = vpu_fmt->min_width;
+	fsize->stepwise.max_width = vpu_fmt->max_width;
+	fsize->stepwise.step_width = RTKVE_DEC_PIC_SIZE_STEP;
+	fsize->stepwise.min_height = vpu_fmt->min_height;
+	fsize->stepwise.max_height = vpu_fmt->max_height;
+	fsize->stepwise.step_height = RTKVE_DEC_PIC_SIZE_STEP;
+
+exit:
+	return ret;
+}
+
+static int rtkve_dec_enum_fmt_cap(struct file *file, void *fh,
+				  struct v4l2_fmtdesc *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	const struct rtkve_match_data *dec_pdata = inst->dev->rtkve_mdata;
+	const struct vpu_format *vpu_fmt;
+	int ret = 0;
+
+	vpu_fmt = dec_pdata->find_vpu_fmt_by_idx(f->index, VPU_FMT_TYPE_RAW);
+	if (!vpu_fmt) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	f->pixelformat = vpu_fmt->v4l2_pix_fmt;
+	f->flags = 0;
+
+exit:
+	return ret;
+}
+
+static int rtkve_dec_try_fmt_cap(struct file *file, void *fh,
+				 struct v4l2_format *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	const struct rtkve_match_data *dec_pdata = inst->dev->rtkve_mdata;
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	const struct vpu_format *vpu_fmt;
+	int width, height;
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: 4cc %d w %d h %d plane %d colorspace %d\n",
+		__func__, pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	if (!V4L2_TYPE_IS_CAPTURE(f->type)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	vpu_fmt =
+		dec_pdata->find_vpu_fmt(pix_mp->pixelformat, VPU_FMT_TYPE_RAW);
+	if (!vpu_fmt) {
+		width = inst->dst_fmt.width;
+		height = inst->dst_fmt.height;
+		pix_mp->pixelformat = inst->dst_fmt.pixelformat;
+		pix_mp->num_planes = inst->dst_fmt.num_planes;
+	} else {
+		width = clamp(pix_mp->width, vpu_fmt->min_width,
+			       inst->src_fmt.width);
+		height = clamp(pix_mp->height, vpu_fmt->min_height,
+			       inst->src_fmt.height);
+		pix_mp->pixelformat = vpu_fmt->v4l2_pix_fmt;
+		pix_mp->num_planes = vpu_fmt->num_planes;
+	}
+
+	rtkve_update_pix_fmt(inst, pix_mp, width, height);
+	pix_mp->colorspace = inst->colorspace;
+	pix_mp->ycbcr_enc = inst->ycbcr_enc;
+	pix_mp->quantization = inst->quantization;
+	pix_mp->xfer_func = inst->xfer_func;
+
+exit:
+	return ret;
+}
+
+static int rtkve_dec_s_fmt_cap(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i, ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: 4cc %d w %d h %d plane %d colorspace %d\n",
+		__func__, pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	ret = rtkve_dec_try_fmt_cap(file, fh, f);
+	if (ret) {
+		dev_err(inst->dev->dev, "rtkve_dec_try_fmt_cap fail");
+		goto exit;
+	}
+
+	inst->dst_fmt.width = pix_mp->width;
+	inst->dst_fmt.height = pix_mp->height;
+	inst->dst_fmt.pixelformat = pix_mp->pixelformat;
+	inst->dst_fmt.field = pix_mp->field;
+	inst->dst_fmt.flags = pix_mp->flags;
+	inst->dst_fmt.num_planes = pix_mp->num_planes;
+	for (i = 0; i < inst->dst_fmt.num_planes; i++) {
+		inst->dst_fmt.plane_fmt[i].bytesperline =
+			pix_mp->plane_fmt[i].bytesperline;
+		inst->dst_fmt.plane_fmt[i].sizeimage =
+			pix_mp->plane_fmt[i].sizeimage;
+	}
+
+	dev_dbg(inst->dev->dev, "%d.%s.dst_fmt.pixelformat:%4s\n", __LINE__,
+		__func__, (char *)&inst->dst_fmt.pixelformat);
+	if (inst->dst_fmt.pixelformat == V4L2_PIX_FMT_NV12 ||
+	    inst->dst_fmt.pixelformat == V4L2_PIX_FMT_NV12M) {
+		inst->nv21 = false;
+	} else if (inst->dst_fmt.pixelformat == V4L2_PIX_FMT_NV21 ||
+		   inst->dst_fmt.pixelformat == V4L2_PIX_FMT_NV21M) {
+		inst->nv21 = true;
+	} else {
+		inst->nv21 = false;
+	}
+
+exit:
+	return ret;
+}
+
+static int rtkve_dec_g_fmt_cap(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i;
+
+	pix_mp->width = inst->dst_fmt.width;
+	pix_mp->height = inst->dst_fmt.height;
+	pix_mp->pixelformat = inst->dst_fmt.pixelformat;
+	pix_mp->field = inst->dst_fmt.field;
+	pix_mp->flags = inst->dst_fmt.flags;
+	pix_mp->num_planes = inst->dst_fmt.num_planes;
+	for (i = 0; i < pix_mp->num_planes; i++) {
+		pix_mp->plane_fmt[i].bytesperline =
+			inst->dst_fmt.plane_fmt[i].bytesperline;
+		pix_mp->plane_fmt[i].sizeimage =
+			inst->dst_fmt.plane_fmt[i].sizeimage;
+	}
+
+	pix_mp->colorspace = inst->colorspace;
+	pix_mp->ycbcr_enc = inst->ycbcr_enc;
+	pix_mp->quantization = inst->quantization;
+	pix_mp->xfer_func = inst->xfer_func;
+
+	return 0;
+}
+
+static int rtkve_dec_enum_fmt_out(struct file *file, void *fh,
+				  struct v4l2_fmtdesc *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	const struct rtkve_match_data *dec_pdata = inst->dev->rtkve_mdata;
+	const struct vpu_format *vpu_fmt;
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: index %d\n", __func__, f->index);
+
+	vpu_fmt = dec_pdata->find_vpu_fmt_by_idx(f->index, VPU_FMT_TYPE_CODEC);
+	if (!vpu_fmt) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	f->pixelformat = vpu_fmt->v4l2_pix_fmt;
+
+exit:
+	return ret;
+}
+
+static int rtkve_dec_try_fmt_out(struct file *file, void *fh,
+				 struct v4l2_format *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	const struct rtkve_match_data *dec_pdata = inst->dev->rtkve_mdata;
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	const struct vpu_format *vpu_fmt;
+	int width, height;
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: 4cc %d w %d h %d plane %d colorspace %d\n",
+		__func__, pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	if (!V4L2_TYPE_IS_OUTPUT(f->type)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	vpu_fmt = dec_pdata->find_vpu_fmt(pix_mp->pixelformat,
+					  VPU_FMT_TYPE_CODEC);
+	if (!vpu_fmt) {
+		width = inst->src_fmt.width;
+		height = inst->src_fmt.height;
+		pix_mp->pixelformat = inst->src_fmt.pixelformat;
+		pix_mp->num_planes = inst->src_fmt.num_planes;
+	} else {
+		width = pix_mp->width;
+		height = pix_mp->height;
+		pix_mp->pixelformat = vpu_fmt->v4l2_pix_fmt;
+		pix_mp->num_planes = vpu_fmt->num_planes;
+	}
+
+	rtkve_update_pix_fmt(inst, pix_mp, width, height);
+exit:
+	return ret;
+}
+
+static int rtkve_dec_s_fmt_out(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i, ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: 4cc %d w %d h %d plane %d colorspace %d\n",
+		__func__, pix_mp->pixelformat, pix_mp->width, pix_mp->height,
+		pix_mp->num_planes, pix_mp->colorspace);
+
+	ret = rtkve_dec_try_fmt_out(file, fh, f);
+	if (ret) {
+		dev_err(inst->dev->dev, "rtkve_dec_try_fmt_out fail");
+		goto exit;
+	}
+
+	inst->src_fmt.width = pix_mp->width;
+	inst->src_fmt.height = pix_mp->height;
+	inst->src_fmt.pixelformat = pix_mp->pixelformat;
+	inst->src_fmt.field = pix_mp->field;
+	inst->src_fmt.flags = pix_mp->flags;
+	inst->src_fmt.num_planes = pix_mp->num_planes;
+	for (i = 0; i < inst->src_fmt.num_planes; i++) {
+		inst->src_fmt.plane_fmt[i].bytesperline =
+			pix_mp->plane_fmt[i].bytesperline;
+		inst->src_fmt.plane_fmt[i].sizeimage =
+			pix_mp->plane_fmt[i].sizeimage;
+	}
+
+	inst->colorspace = pix_mp->colorspace;
+	inst->ycbcr_enc = pix_mp->ycbcr_enc;
+	inst->quantization = pix_mp->quantization;
+	inst->xfer_func = pix_mp->xfer_func;
+
+	rtkve_update_pix_fmt(inst, &inst->dst_fmt,
+		pix_mp->width, pix_mp->height);
+exit:
+	return ret;
+}
+
+static int rtkve_dec_g_fmt_out(struct file *file, void *fh,
+			       struct v4l2_format *f)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(fh);
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	int i;
+
+	pix_mp->width = inst->src_fmt.width;
+	pix_mp->height = inst->src_fmt.height;
+	pix_mp->pixelformat = inst->src_fmt.pixelformat;
+	pix_mp->field = inst->src_fmt.field;
+	pix_mp->flags = inst->src_fmt.flags;
+	pix_mp->num_planes = inst->src_fmt.num_planes;
+	for (i = 0; i < pix_mp->num_planes; i++) {
+		pix_mp->plane_fmt[i].bytesperline =
+			inst->src_fmt.plane_fmt[i].bytesperline;
+		pix_mp->plane_fmt[i].sizeimage =
+			inst->src_fmt.plane_fmt[i].sizeimage;
+	}
+
+	pix_mp->colorspace = inst->colorspace;
+	pix_mp->ycbcr_enc = inst->ycbcr_enc;
+	pix_mp->quantization = inst->quantization;
+	pix_mp->xfer_func = inst->xfer_func;
+
+	return 0;
+}
+
+static int rtkve_dec_reqbufs(struct file *file, void *priv,
+			     struct v4l2_requestbuffers *rb)
+{
+	struct vpu_instance *inst = rtkve_to_vpu_inst(priv);
+	struct vpu_device *dev = inst->dev;
+	const struct rtkve_match_data *dec_pdata = dev->rtkve_mdata;
+	int ret = 0;
+
+	ret = v4l2_m2m_ioctl_reqbufs(file, priv, rb);
+	if (ret)
+		goto exit;
+
+	if (rb->count != 0 && !inst->flash_hdl && !inst->dec_hdl)
+		ret = dec_pdata->create_instance(inst);
+
+exit:
+	return ret;
+}
+
+struct v4l2_ioctl_ops rtkve_dec_ioctl_ops = {
+	.vidioc_querycap = rtkve_dec_querycap,
+	.vidioc_enum_framesizes = rtkve_dec_enum_framesizes,
+
+	.vidioc_enum_fmt_vid_cap = rtkve_dec_enum_fmt_cap,
+	.vidioc_s_fmt_vid_cap_mplane = rtkve_dec_s_fmt_cap,
+	.vidioc_g_fmt_vid_cap_mplane = rtkve_dec_g_fmt_cap,
+	.vidioc_try_fmt_vid_cap_mplane = rtkve_dec_try_fmt_cap,
+
+	.vidioc_enum_fmt_vid_out = rtkve_dec_enum_fmt_out,
+	.vidioc_s_fmt_vid_out_mplane = rtkve_dec_s_fmt_out,
+	.vidioc_g_fmt_vid_out_mplane = rtkve_dec_g_fmt_out,
+	.vidioc_try_fmt_vid_out_mplane = rtkve_dec_try_fmt_out,
+
+	.vidioc_reqbufs = rtkve_dec_reqbufs,
+	.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,
+	.vidioc_create_bufs = v4l2_m2m_ioctl_create_bufs,
+	.vidioc_prepare_buf = v4l2_m2m_ioctl_prepare_buf,
+	.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,
+	.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,
+	.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,
+
+	.vidioc_streamon = v4l2_m2m_ioctl_streamon,
+	.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,
+
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static void rtkve_dec_device_run(void *priv)
+{
+	struct vpu_instance *inst = priv;
+
+	dev_dbg(inst->dev->dev, "[%d]%s: state %d\n", inst->id, __func__,
+		inst->state);
+
+	queue_work(inst->dev->decode_workqueue, &inst->decode_work);
+}
+
+static int rtkve_dec_job_ready(void *priv)
+{
+	struct vpu_instance *inst = priv;
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "[%d]%s: state %d\n", inst->id, __func__,
+		inst->state);
+
+	if (inst->state == VPU_INST_STATE_STOP && inst->eos)
+		ret = 0;
+	else
+		ret = 1;
+
+	return ret;
+}
+
+static void rtkve_dec_job_abort(void *priv)
+{
+	struct vpu_instance *inst = priv;
+	struct vpu_device *dev = inst->dev;
+	const struct rtkve_match_data *dec_pdata = dev->rtkve_mdata;
+
+	dev_dbg(inst->dev->dev, "[%d]%s: state %d\n", inst->id, __func__,
+		inst->state);
+
+	dec_pdata->stop_decode(inst);
+}
+
+static const struct v4l2_m2m_ops rtkve_dec_m2m_ops = {
+	.device_run = rtkve_dec_device_run,
+	.job_ready = rtkve_dec_job_ready,
+	.job_abort = rtkve_dec_job_abort,
+};
+
+int rtkve_dec_init_m2m_dev(struct vpu_device *dev)
+{
+	dev->m2m_dev = v4l2_m2m_init(&rtkve_dec_m2m_ops);
+	if (IS_ERR(dev->m2m_dev)) {
+		dev_err(dev->dev, "v4l2_m2m_init fail: %ld\n",
+			PTR_ERR(dev->m2m_dev));
+		return PTR_ERR(dev->m2m_dev);
+	}
+
+	return 0;
+}
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-rpc-def.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-rpc-def.h
@@ -0,0 +1,591 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#ifndef RTKVE_RPC_DEF_H
+#define RTKVE_RPC_DEF_H
+
+#include <linux/types.h>
+#include "rtkve-sl-ctrl.h"
+
+#define RTKVE_MAX_DPB_NUM (64)
+
+#define VIDEO_RPC_COMMON_ToAgent_Create 10
+#define VIDEO_RPC_COMMON_ToAgent_Connect 20
+#define VIDEO_RPC_COMMON_ToAgent_InitRingBuffer 30
+#define VIDEO_RPC_COMMON_ToAgent_Run 40
+#define VIDEO_RPC_COMMON_ToAgent_Pause 50
+#define VIDEO_RPC_COMMON_ToAgent_Stop 60
+#define VIDEO_RPC_COMMON_ToAgent_Destroy 70
+#define VIDEO_RPC_COMMON_ToAgent_Flush 80
+#define VIDEO_RPC_COMMON_ToAgent_SetRefClock 90
+#define VIDEO_RPC_COMMON_ToAgent_VideoCreate 100
+#define VIDEO_RPC_COMMON_ToAgent_VideoConfig 105
+#define VIDEO_RPC_COMMON_ToAgent_VideoMemoryConfig 108
+#define VIDEO_RPC_COMMON_ToAgent_VideoChunkConfig 109
+#define VIDEO_RPC_COMMON_ToAgent_VideoDestroy 110
+#define VIDEO_RPC_COMMON_ToAgent_RequestBuffer 120
+#define VIDEO_RPC_COMMON_ToAgent_ReleaseBuffer 130
+#define VIDEO_RPC_COMMON_ToAgent_ConfigLowDelay 133
+#define VIDEO_RPC_COMMON_ToAgent_SetDebugMemory 140
+#define VIDEO_RPC_COMMON_ToAgent_VCPU_DEBUG_COMMAND 141
+#define VIDEO_RPC_COMMON_ToAgent_VideoHalt 150
+#define VIDEO_RPC_COMMON_ToAgent_YUYV2RGB 160
+#define VIDEO_RPC_COMMON_ToAgent_Self_Destroy 170
+#define VIDEO_RPC_ToAgent_SetResourceInfo 550
+#define VIDEO_RPC_DEC_ToAgent_CmprsCtrl 1005
+#define VIDEO_RPC_DEC_ToAgent_DecimateCtrl 1006
+#define VIDEO_RPC_DEC_ToAgent_SetSpeed 1010
+#define VIDEO_RPC_DEC_ToAgent_SetErrorConcealmentLevel 1015
+#define VIDEO_RPC_DEC_ToAgent_Init 1020
+#define VIDEO_RPC_DEC_ToAgent_SetDeblock 1030
+#define VIDEO_RPC_DEC_ToAgent_GetVideoSequenceInfo 1035
+#define VIDEO_RPC_DEC_ToAgent_GetVideoSequenceInfo_New 1036
+#define VIDEO_RPC_DEC_ToAgent_BitstreamValidation 1040
+#define VIDEO_RPC_DEC_ToAgent_ParseResolution 1041
+#define VIDEO_RPC_DEC_ToAgent_Capability 1045
+#define VIDEO_RPC_DEC_ToAgent_SetDecoderCCBypass 1050
+#define VIDEO_RPC_DEC_ToAgent_SetDNR 1060
+#define VIDEO_RPC_DEC_ToAgent_SetRefSyncLimit 1065
+#define VIDEO_RPC_FLASH_ToAgent_SetOutput 1085
+#define VIDEO_RPC_THUMBNAIL_ToAgent_SetVscalerOutputFormat 1070
+#define VIDEO_RPC_THUMBNAIL_ToAgent_SetThreshold 1080
+#define VIDEO_RPC_VOUT_ToAgent_SetV2alpha 3090
+#define VIDEO_RPC_THUMBNAIL_ToAgent_SetStartPictureNumber 1090
+#define VIDEO_RPC_DEC_ToAgent_PrivateInfo 1095
+#define VIDEO_RPC_SUBPIC_DEC_ToAgent_Configure 5040
+#define VIDEO_RPC_SUBPIC_DEC_ToAgent_Page 5050
+#define VIDEO_RPC_JPEG_ToAgent_DEC 6010
+#define VIDEO_RPC_JPEG_ToAgent_DEC_BATCH 6011
+#define VIDEO_RPC_TRANSITION_ToAgent_Start 6020
+#define VIDEO_RPC_MIXER_FILTER_ToAgent_Configure 8010
+#define VIDEO_RPC_MIXER_FILTER_ToAgent_ConfigureWindow 8020
+#define VIDEO_RPC_MIXER_FILTER_ToAgent_SetMasterWindow 8030
+#define VIDEO_RPC_MIXER_ToAgent_PlayOneMotionJpegFrame 8040
+
+typedef int HRESULT;
+#define VIDEO_RPC_DEC_ToSystem_FatalError 63
+#define VIDEO_RPC_DEC_ToSystem_Deliver_MediaInfo 1020
+#define VIDEO_RPC_ToSystem_VoutMessage 1021
+#define REPLYID 99 // for registering the Reply_Handler
+
+enum RINGBUFFER_TYPE {
+	RINGBUFFER_STREAM,
+	RINGBUFFER_COMMAND,
+	RINGBUFFER_MESSAGE,
+	RINGBUFFER_VBI,
+	RINGBUFFER_PTS,
+	RINGBUFFER_DTVCC,
+	RINGBUFFER_STREAM1,
+	RINGBUFFER_COMMAND1,
+	RINGBUFFER_MESSAGE1,
+	RINGBUFFER_STREAM_BL,
+	RINGBUFFER_COMMAND_BL,
+	RINGBUFFER_STREAM_EL,
+	RINGBUFFER_COMMAND_EL,
+	RINGBUFFER_STREAM_MD,
+	RINGBUFFER_COMMAND_MD,
+	RINGBUFFER_STREAM_SUBES,
+	RINGBUFFER_COMMAND_SUBIB,
+	RINGBUFFER_FRAME_USER,
+	RINGBUFFER_V4L2_CONTROL,
+	RINGBUFFER_FAKE
+};
+
+enum VIDEO_VF_TYPE {
+	VF_TYPE_VIDEO_MPEG2_DECODER = 0,
+	VF_TYPE_VIDEO_MPEG4_DECODER = 1,
+	VF_TYPE_VIDEO_DV_DECODER = 2,
+	VF_TYPE_VIDEO_H263_DECODER = 3,
+	VF_TYPE_VIDEO_H264_DECODER = 4,
+	VF_TYPE_VIDEO_VC1_DECODER = 5,
+	VF_TYPE_VIDEO_REAL_DECODER = 6,
+	VF_TYPE_VIDEO_JPEG_DECODER = 7,
+	VF_TYPE_VIDEO_MJPEG_DECODER = 8,
+	VF_TYPE_SPU_DECODER = 9,
+	VF_TYPE_VIDEO_OUT = 10,
+	VF_TYPE_TRANSITION = 11,
+	VF_TYPE_THUMBNAIL = 12,
+	VF_TYPE_VIDEO_VP6_DECODER = 13,
+	VF_TYPE_VIDEO_IMAGE_DECODER = 14,
+	VF_TYPE_FLASH = 15,
+	VF_TYPE_VIDEO_AVS_DECODER = 16,
+	VF_TYPE_MIXER = 17,
+	VF_TYPE_VIDEO_VP8_DECODER = 18,
+	VF_TYPE_VIDEO_WMV7_DECODER = 19,
+	VF_TYPE_VIDEO_WMV8_DECODER = 20,
+	VF_TYPE_VIDEO_RAW_DECODER = 21,
+	VF_TYPE_VIDEO_THEORA_DECODER = 22,
+	VF_TYPE_VIDEO_FJPEG_DECODER = 23,
+	VF_TYPE_VIDEO_H265_DECODER = 24,
+	VF_TYPE_VIDEO_VP9_DECODER = 25,
+	VF_TYPE_VIDEO_H264lv51_DECODER = 26,
+	VF_TYPE_VIDEO_CAPTURER = 27,
+	VF_TYPE_RAWCONV = 28,
+	VF_TYPE_TVD = 29,
+	VF_TYPE_VIDEO_ENCODER = 30,
+	VF_TYPE_VIDEO_SPLITTER = 31,
+	VF_TYPE_VIDEO_AVS2_DECODER = 32,
+	VF_TYPE_VIDEO_AV1_DECODER = 33,
+};
+
+enum VIDEO_STREAM_TYPE {
+	VIDEO_STREAM_MPEG1 = 0,
+	VIDEO_STREAM_MPEG2 = 1,
+	VIDEO_STREAM_MPEG4 = 2,
+	VIDEO_STREAM_DV3 = 3,
+	VIDEO_STREAM_H263 = 4,
+	VIDEO_STREAM_H264 = 5,
+	VIDEO_STREAM_VC1 = 6,
+	VIDEO_STREAM_REALVIDEO = 7,
+	VIDEO_STREAM_MJPEG = 8,
+	VIDEO_STREAM_VP6 = 9,
+	VIDEO_STREAM_AVS = 10,
+	VIDEO_STREAM_YUV = 11,
+	VIDEO_STREAM_VP8 = 12,
+	VIDEO_STREAM_WMV7 = 13,
+	VIDEO_STREAM_WMV8 = 14,
+	VIDEO_STREAM_RAW = 15,
+	VIDEO_STREAM_THEORA = 16,
+	VIDEO_STREAM_UNKNOWN = 17,
+	VIDEO_STREAM_FJPEG = 18,
+	VIDEO_STREAM_H265 = 19,
+	VIDEO_STREAM_VP9 = 20,
+	VIDEO_STREAM_H264lv51 = 21,
+	VIDEO_STREAM_AVS2 = 22,
+	VIDEO_STREAM_AV1 = 23,
+};
+
+enum CMPRS_RATIO {
+	CMPRS_RATIO_50 = 0,
+	CMPRS_RATIO_75 = 1,
+};
+
+/** inband cmd type. I use prefix "VIDEO_DEC_" to label the cmd used in video decoder. */
+enum INBAND_CMD_TYPE {
+	INBAND_CMD_TYPE_PTS = 0,
+	INBAND_CMD_TYPE_PTS_SKIP,
+	INBAND_CMD_TYPE_NEW_SEG,
+	INBAND_CMD_TYPE_SEQ_END,
+	INBAND_CMD_TYPE_EOS,
+	INBAND_CMD_TYPE_CONTEXT,
+	INBAND_CMD_TYPE_DECODE,
+
+	/* Video Decoder In-band Command */
+	VIDEO_DEC_INBAND_CMD_TYPE_VOBU,
+	VIDEO_DEC_INBAND_CMD_TYPE_DVDVR_DCI_CCI,
+	VIDEO_DEC_INBAND_CMD_TYPE_DVDV_VATR,
+
+	/* MSG Type for parse mode */
+	VIDEO_DEC_INBAND_CMD_TYPE_SEG_INFO,
+	VIDEO_DEC_INBAND_CMD_TYPE_PIC_INFO,
+
+	/* Sub-picture Decoder In-band Command */
+	VIDEO_SUBP_INBAND_CMD_TYPE_SET_PALETTE,
+	VIDEO_SUBP_INBAND_CMD_TYPE_SET_HIGHLIGHT,
+
+	/* Video Mixer In-band Command */
+	VIDEO_MIXER_INBAND_CMD_TYPE_SET_BG_COLOR,
+	VIDEO_MIXER_INBAND_CMD_TYPE_SET_MIXER_RPTS,
+	VIDEO_MIXER_INBAND_CMD_TYPE_BLEND,
+
+	/* Video Scaler In-band Command */
+	VIDEO_SCALER_INBAND_CMD_TYPE_OUTPUT_FMT,
+
+	/*Dv3 resolution In-band Command*/
+	VIDEO_DV3_INBAND_CMD_TYPE_RESOLUTION,
+
+	/*MPEG4 detected In-band command*/
+	VIDEO_MPEG4_INBAND_CMD_TYPE_MP4,
+	/* Audio In-band Commands Start Here */
+
+	/* DV In-band Commands */
+	VIDEO_DV_INBAND_CMD_TYPE_VAUX,
+	VIDEO_DV_INBAND_CMD_TYPE_FF, //fast forward
+
+	/* Transport Demux In-band command */
+	VIDEO_TRANSPORT_DEMUX_INBAND_CMD_TYPE_PID,
+	VIDEO_TRANSPORT_DEMUX_INBAND_CMD_TYPE_PTS_OFFSET,
+	VIDEO_TRANSPORT_DEMUX_INBAND_CMD_TYPE_PACKET_SIZE,
+
+	/* Real Video In-band command */
+	VIDEO_RV_INBAND_CMD_TYPE_FRAME_INFO,
+	VIDEO_RV_INBAND_CMD_TYPE_FORMAT_INFO,
+	VIDEO_RV_INBAND_CMD_TYPE_SEGMENT_INFO,
+
+	/*VC1 video In-band command*/
+	VIDEO_VC1_INBAND_CMD_TYPE_SEQ_INFO,
+
+	/* general video properties */
+	VIDEO_INBAND_CMD_TYPE_VIDEO_USABILITY_INFO,
+	VIDEO_INBAND_CMD_TYPE_VIDEO_MPEG4_USABILITY_INFO,
+
+	/*MJPEG resolution In-band Command*/
+	VIDEO_MJPEG_INBAND_CMD_TYPE_RESOLUTION,
+
+	/* picture object for graphic */
+	VIDEO_GRAPHIC_INBAND_CMD_TYPE_PICTURE_OBJECT,
+	VIDEO_GRAPHIC_INBAND_CMD_TYPE_DISPLAY_INFO,
+
+	/* subtitle offset sequence id for 3D video */
+	VIDEO_DEC_INBAND_CMD_TYPE_SUBP_OFFSET_SEQUENCE_ID,
+
+	VIDEO_H264_INBAND_CMD_TYPE_DPBBYPASS,
+
+	/* Clear back frame to black color and send it to VO */
+	VIDEO_FJPEG_INBAND_CMD_TYPE_CLEAR_SCREEN,
+
+	/* each picture info of MJPEG */
+	VIDEO_FJPEG_INBAND_CMD_TYPE_PIC_INFO,
+
+	/*FJPEG resolution In-band Command*/
+	VIDEO_FJPEG_INBAND_CMD_TYPE_RESOLUTION,
+
+	/*VO receive VP_OBJ_PICTURE_TYPE In-band Command*/
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_PIC,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_DVD_SP,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_DVB_SP,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_BD_SP,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_SP_FLUSH,
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_SP_RESOLUTION,
+
+	/* VO receive writeback buffers In-band Command */
+	VIDEO_VO_INBAND_CMD_TYPE_WRITEBACK_BUFFER,
+
+	/* for VO debug, VO can dump picture */
+	VIDEO_VO_INBAND_CMD_TYPE_DUMP_PIC,
+	VIDEO_CURSOR_INBAND_CMD_TYPE_PICTURE_OBJECT,
+	VIDEO_CURSOR_INBAND_CMD_TYPE_COORDINATE_OBJECT,
+	VIDEO_TRANSCODE_INBAND_CMD_TYPE_PICTURE_OBJECT,
+	VIDEO_WRITEBACK_INBAND_CMD_TYPE_PICTURE_OBJECT,
+
+	VIDEO_VO_INBAND_CMD_TYPE_OBJ_BD_SCALE_RGB_SP,
+
+	// TV code
+	VIDEO_INBAND_CMD_TYPE_DV_CERTIFY,
+
+	/*M_DOMAIN resolution In-band Command*/
+	VIDEO_INBAND_CMD_TYPE_M_DOMAIN_RESOLUTION,
+
+	/* DTV source In-band Command */
+	VIDEO_INBAND_CMD_TYPE_SOURCE_DTV,
+
+	/* Din source copy mode In-band Command */
+	VIDEO_DIN_INBAND_CMD_TYPE_COPY_MODE,
+
+	/* Video Decoder AU In-band command */
+	VIDEO_DEC_INBAND_CMD_TYPE_AU,
+
+	/* Video Decoder parse frame In-band command */
+	VIDEO_DEC_INBAND_CMD_TYPE_PARSE_FRAME_IN,
+	VIDEO_DEC_INBAND_CMD_TYPE_PARSE_FRAME_OUT,
+
+	/* Set video decode mode In-band command */
+	VIDEO_DEC_INBAND_CMD_TYPE_NEW_DECODE_MODE,
+
+	/* Secure buffer protection */
+	VIDEO_INBAND_CMD_TYPE_SECURE_PROTECTION,
+
+	/* Dolby HDR inband command */
+	VIDEO_DEC_INBAND_CMD_TYPE_DV_PROFILE,
+
+	/* VP9 HDR10 In-band command */
+	VIDEO_VP9_INBAND_CMD_TYPE_HDR10_METADATA,
+
+	/* AV1 HDR10 In-band command */
+	VIDEO_AV1_INBAND_CMD_TYPE_HDR10_METADATA,
+
+	/* DvdPlayer tell RVSD video BS ring buffer is full */
+	VIDEO_DEC_INBAND_CMD_TYPE_BS_RINGBUF_FULL,
+
+	/* Frame Boundary In-band command */
+	VIDEO_INBAND_CMD_TYPE_FRAME_BOUNDARY = 100,
+
+	/* VO receive npp writeback buffers In-band Command */
+	VIDEO_NPP_INBAND_CMD_TYPE_WRITEBACK_BUFFER,
+	VIDEO_NPP_OUT_INBAND_CMD_TYPE_OBJ_PIC,
+
+	/* hevc encoder raw yuv data In-band Commnad */
+	VENC_INBAND_CMD_TYPE_RAWYUV,
+
+	/* hevc encoder ref yuv addr In-band Commnad */
+	VENC_INBAND_CMD_TYPE_REFYUV,
+
+	/* add frame info for user allocate */
+	VIDEO_FRAME_INBAND_ADD,
+
+	/* delete frame info for user allocate */
+	VIDEO_FRAME_INBAND_DELETE,
+
+	VIDEO_AV1_INBAND_CMD_TYPE_V4L2_CTRL = 108,
+	VIDEO_HEVC_INBAND_CMD_TYPE_V4L2_CTRL = 109,
+	VIDEO_VP9_INBAND_CMD_TYPE_V4L2_CTRL = 110,
+};
+
+enum DECODE_MODE {
+	NORMAL_DECODE = 0,
+	I_ONLY_DECODE,
+	FASTFR_DECODE,
+	RESERVED1,
+	TS_NORMAL_DECODE,
+	TS_I_ONLY_DECODE,
+	TS_FASTFR_DECODE,
+	RESERVED2,
+	BITSTREAM_PARSING,
+	TRANSCODE_PARSING,
+	NORMAL_DECODE_MVC,
+	//TV code
+	NORMAL_I_ONLY_DECODE,
+	IP_ONLY_DECODE,
+	VDEC_DIRECT_DECODE = 16,
+	DRIP_I_ONLY_DECODE = 17,
+	NORMAL_DECODE_LOWDELAY = 18,
+	NO_REF_SYNC_DECODE = 32
+};
+
+enum VIDEO_RESOURCE_CORE_TYPE {
+        VIDEO_RESOURCE_CORE_REALTEK = 0,
+        VIDEO_RESOURCE_CORE_GOOGLE = 0 + 1,
+        VIDEO_RESOURCE_CORE_IP1 = 0 + 2,
+        VIDEO_RESOURCE_CORE_IP2 = 0 + 3,
+        VIDEO_RESOURCE_CORE_DUAL = 0 + 4,
+};
+
+struct _tagRingBufferHeader {
+	volatile uint32_t magic; //Magic number
+	volatile uint32_t beginAddr;
+	volatile uint32_t size;
+	volatile uint32_t
+		bufferID; // RINGBUFFER_TYPE, choose a type from RINGBUFFER_TYPE
+	volatile uint32_t writePtr;
+	volatile uint32_t numOfReadPtr;
+	volatile uint32_t reserve2; //Reserve for Red Zone
+	volatile uint32_t reserve3; //Reserve for Red Zone
+	volatile uint32_t readPtr[4];
+	volatile int32_t fileOffset;
+	volatile int32_t requestedFileOffset;
+	volatile int32_t fileSize;
+	volatile int32_t bSeekable; //Can't be sought if data is streamed by HTTP
+};
+
+struct RPC_RINGBUFFER {
+	uint32_t instanceID;
+	uint32_t pinID;
+	uint32_t readPtrIndex;
+	uint32_t pRINGBUFF_HEADER;
+};
+
+struct VIDEO_RPC_VOUT_MESSAGE {
+	uint32_t instanceID;
+	uint32_t message;
+	uint32_t PTShigh;
+	uint32_t PTSlow;
+	uint32_t reserved1;
+	uint32_t reserved2;
+	uint32_t reserved3;
+	uint32_t reserved4;
+};
+
+struct VIDEO_RPC_DEC_ERROR_INFO {
+	uint32_t instanceID;
+	uint32_t errCode;
+};
+
+struct VIDEO_RPC_DEC_MEDIA_INFO {
+	uint32_t instanceID;
+	uint32_t width;
+	uint32_t height;
+	uint32_t frame_rate;
+	uint32_t aspect_ratio_n;
+	uint32_t aspect_ratio_d;
+	uint32_t level;
+	uint32_t profile;
+	uint32_t type_3D;
+	uint32_t par_width;
+	uint32_t par_height;
+	uint32_t type_LR;
+	uint32_t type_Scan;
+	uint32_t afd;
+};
+
+struct VIDEO_RPC_DEC_SET_SPEED {
+	uint32_t instanceID;
+	uint32_t displaySpeed;
+	uint32_t decodeSkip;
+};
+
+struct VIDEO_RPC_DEC_INIT {
+	uint32_t instanceID;
+	enum VIDEO_STREAM_TYPE type;
+	struct VIDEO_RPC_DEC_SET_SPEED set_speed;
+};
+
+struct VIDEO_RPC_RESOURCE_INFO {
+	int32_t resource_ctrl_sets;
+	enum VIDEO_RESOURCE_CORE_TYPE core_type;
+	int32_t video_port;
+	int32_t max_width;
+	int32_t max_height;
+	uint32_t instanceID;
+	int32_t width;
+	int32_t height;
+	int32_t framerate;
+	int32_t second_resource_ctrl_sets;
+};
+
+struct VIDEO_RPC_DEC_CMPRS_CTRL {
+	uint32_t instanceID;
+	uint8_t mode;
+	enum CMPRS_RATIO ratio;
+	uint8_t enable;
+};
+
+struct VIDEO_RPC_DEC_BITSTREAM_BUFFER {
+	uint32_t bsBase;
+	uint32_t bsSize;
+	enum VIDEO_VF_TYPE type;
+};
+
+struct VIDEO_RPC_DEC_PV_RESULT {
+	uint32_t width;
+	uint32_t height;
+	uint32_t bit_depth;
+	uint32_t DPB_size;
+};
+
+struct RPC_STRUCT {
+	uint32_t programID; // program ID defined in IDL file
+	uint32_t versionID; // version ID defined in IDL file
+	uint32_t procedureID; // function ID defined in IDL file
+	uint32_t taskID; // the caller's task ID, assign 0 if NONBLOCK_MODE
+	uint32_t sysTID;
+	uint32_t sysPID; // the callee's task ID
+	uint32_t parameterSize; // packet's body size
+	uint32_t context; // return address of reply value
+};
+
+struct RPC_CONNECTION {
+	uint32_t srcInstanceID;
+	uint32_t srcPinID;
+	uint32_t desInstanceID;
+	uint32_t desPinID;
+	uint32_t mediaType;
+};
+
+struct RPCRES_LONG {
+	uint32_t result;
+	uint32_t data;
+};
+
+//inband
+struct INBAND_CMD_PKT_HEADER {
+	enum INBAND_CMD_TYPE type;
+	uint32_t size;
+};
+
+struct NEW_SEG {
+	struct INBAND_CMD_PKT_HEADER header;
+	uint32_t wPtr;
+};
+
+struct VIDEO_RPC_INSTANCE {
+	enum VIDEO_VF_TYPE type;
+};
+
+struct DECODE_NEW {
+	struct INBAND_CMD_PKT_HEADER header;
+	unsigned int RelativePTSH;
+	unsigned int RelativePTSL;
+	unsigned int PTSDurationH;
+	unsigned int PTSDurationL;
+	unsigned int skip_GOP;
+	enum DECODE_MODE mode;
+	unsigned int isHM91; /* for HEVC codec version 1: HM91 0: HM10+*/
+	unsigned int useAbsolutePTS; /* 0: relative PTS, 1: absolute PTS */
+};
+
+struct PTS_INFO2 {
+	struct INBAND_CMD_PKT_HEADER header;
+	unsigned int wPtr;
+	unsigned int PTSH;
+	unsigned int PTSL;
+	unsigned int PTSH2;
+	unsigned int PTSL2;
+	unsigned int length;
+	unsigned int flag;
+};
+
+struct HEVC_V4L2_CTRL_INFO {
+	struct INBAND_CMD_PKT_HEADER header;
+	struct ctrl_hevc_sps sps;
+	struct ctrl_hevc_pps pps;
+	struct ctrl_hevc_scaling_matrix scaling_matrix;
+	struct ctrl_hevc_decode_params decode_params;
+	unsigned int dpb_entry_y_dma_addr[HEVC_DPB_ENTRIES_NUM_MAX];
+	unsigned int dpb_entry_c_dma_addr[HEVC_DPB_ENTRIES_NUM_MAX];
+	unsigned int y_dma_addr;
+	unsigned int c_dma_addr;
+	unsigned int wPtr; //PTS_INFO
+	unsigned int PTSH; //PTS_INFO
+	unsigned int PTSL; //PTS_INFO
+	unsigned int bs_len;
+	unsigned int slice_param_num;
+};
+
+#define VP9_MAX_REFS_PER_FRAME 3
+#define VP9_MAX_REF_FRAMES 8
+
+struct VP9_V4L2_CTRL_INFO {
+	struct INBAND_CMD_PKT_HEADER header;
+	struct ctrl_vp9_frame uncmprs_frame;
+	struct ctrl_vp9_compressed_hdr cmprs_hdr;
+	unsigned char refresh_frame_flags;
+	unsigned int refresh_frame_ts_high;
+	unsigned int refresh_frame_ts_low;
+	unsigned int frame_refs_y_dma_addr[VP9_MAX_REFS_PER_FRAME];
+	unsigned int frame_refs_c_dma_addr[VP9_MAX_REFS_PER_FRAME];
+	unsigned int y_dma_addr;
+	unsigned int c_dma_addr;
+	unsigned int wPtr; //PTS_INFO
+	unsigned int PTSH; //PTS_INFO
+	unsigned int PTSL; //PTS_INFO
+	unsigned int bs_len;
+};
+
+/*
+* struct AV1_CTRL_INFO - control value.
+* @av1_sequence:       AV1 sequence structure.
+* @av1_tile_group_entry: AV1 tile group entry structure.
+* @av1_frame:        AV1 frame structure.
+* @av1_film_grain:       AV1 film grain structure.
+* @reference_frame_y_dma_addr: y dma address of the reference frame slots.
+* @reference_frame_c_dma_addr: c dma address of the reference frame slots.
+* @y_dma_addr:       frame buffer y dma address
+* @c_dma_addr:       frame buffer c dma address
+*/
+struct AV1_V4L2_CTRL_INFO {
+	struct INBAND_CMD_PKT_HEADER header;
+	struct ctrl_av1_sequence av1_sequence;
+	struct ctrl_av1_tile_group_entry
+		av1_tile_group_entry[AV1_MAX_TILE_COUNT];
+	struct ctrl_av1_frame av1_frame;
+	struct ctrl_av1_film_grain av1_film_grain;
+	unsigned int reference_frame_y_dma_addr[AV1_TOTAL_REFS_PER_FRAME];
+	unsigned int reference_frame_c_dma_addr[AV1_TOTAL_REFS_PER_FRAME];
+	unsigned int y_dma_addr;
+	unsigned int c_dma_addr;
+	unsigned int wPtr; //PTS_INFO
+	unsigned int PTSH; //PTS_INFO
+	unsigned int PTSL; //PTS_INFO
+	unsigned int bs_len;
+};
+#endif
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-rpc.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-rpc.c
@@ -0,0 +1,1364 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+
+#include <media/v4l2-ioctl.h>
+
+#include <soc/realtek/rtk-krpc-agent.h>
+
+#include "rtkve-rpc.h"
+#include "rtkve-common.h"
+
+#define RPC_BUF_SIZE (1024)
+#define BS_RINGBUF_SIZE (0x1000000)
+#define INBAND_RINGBUF_SIZE (0x40000)
+#define DPB_RINGBUF_SIZE (0x40000)
+#define PRE_PARSING_ERROR (0x80000000)
+
+static struct rtk_krpc_ept_info *get_ve2_krpc_info(void)
+{
+	struct device_node *np;
+	struct rtk_krpc_ept_info *vcpu_ept_info = NULL;
+
+	np = of_find_compatible_node(NULL, NULL, "realtek,ve2rpc");
+	if (!np)
+		goto exit;
+
+	vcpu_ept_info = of_krpc_ept_info_get(np, 0);
+
+exit:
+	return vcpu_ept_info;
+}
+
+static int SendReply(struct rtk_krpc_ept_info *krpc_ept_info,
+		     uint32_t req_taskID, int32_t req_context,
+		     char *ReplyParameter, // parameter's start address
+		     uint32_t ParameterSize) // parameter's size
+{
+	ssize_t val;
+	struct rpc_struct *rpc;
+	char *mem_ToShm;
+	char *p;
+	int size_ToShm = 0; // total mem size for writing to share memory
+	uint32_t *context;
+	int ret = 0;
+
+	mem_ToShm = kmalloc(sizeof(struct RPC_STRUCT) + sizeof(uint32_t) +
+				    ParameterSize,
+			    GFP_KERNEL | __GFP_ZERO);
+	if (!mem_ToShm) {
+		pr_err("SendReply malloc fail\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+	p = mem_ToShm;
+	rpc = (struct rpc_struct *)p;
+	p += sizeof(struct rpc_struct);
+	context = (uint32_t *)p;
+	*context = htonl(req_taskID);
+	size_ToShm += sizeof(uint32_t);
+	p += sizeof(uint32_t);
+	for (context = (uint32_t *)p; (char *)context < p + ParameterSize;
+	     context++) {
+		*context = *ReplyParameter;
+		ReplyParameter += sizeof(uint32_t);
+	}
+	size_ToShm += ParameterSize;
+	rpc->programID = REPLYID;
+	rpc->versionID = REPLYID;
+	rpc->procedureID = 0;
+	rpc->mycontext = req_context; // fill in req's para addr
+	rpc->taskID = 0xffffffff;
+	rpc->sysPID = 0xffffffff;
+	rpc->parameterSize = size_ToShm;
+	size_ToShm += sizeof(struct rpc_struct);
+	val = rtk_send_rpc(krpc_ept_info, mem_ToShm, size_ToShm);
+	if (val != size_ToShm) {
+		pr_err("ve2RPC: ERROR in send kernel RPC\n");
+		ret = -EINVAL;
+	}
+	kfree(mem_ToShm);
+
+exit:
+	return ret;
+}
+
+static int handle_rpc_command(struct rtk_krpc_ept_info *krpc_ept_info,
+			      char *buf)
+{
+	struct vpu_handler *hndl = (struct vpu_handler *)krpc_ept_info->priv;
+	//struct v4l2_fh *fh = hndl->fh;
+	int cmd;
+	char *event;
+	HRESULT retval = S_OK;
+	ssize_t size = 0;
+	struct rpc_struct *rpc_head = (struct rpc_struct *)buf;
+	uint32_t width = 0;
+	uint32_t height = 0;
+	int ret = 0;
+
+	dev_dbg(hndl->dev, "rpc_kern_ve2_read, cmd %d, count %lu, size %d\n",
+		rpc_head->procedureID, sizeof(rpc_head),
+		rpc_head->parameterSize);
+	cmd = rpc_head->procedureID;
+	switch (cmd) {
+	case VIDEO_RPC_DEC_ToSystem_FatalError:
+		event = kmalloc(sizeof(struct VIDEO_RPC_DEC_ERROR_INFO),
+				GFP_KERNEL | __GFP_ZERO);
+		if (!event) {
+			dev_err(hndl->dev,
+				"VIDEO_RPC_DEC_ERROR_INFO event malloc fail\n");
+			ret = -ENOMEM;
+			goto exit;
+		}
+		if (rpc_head->parameterSize !=
+		    sizeof(struct VIDEO_RPC_DEC_ERROR_INFO)) {
+			dev_err(hndl->dev,
+				"vclient: VIDEO_RPC_DEC_ToSystem_FatalError: rpc data size not match(expect:%lu real:%ld rpc->parameterSize:%d)\n",
+				sizeof(struct VIDEO_RPC_DEC_ERROR_INFO), size,
+				rpc_head->parameterSize);
+		}
+		memcpy(event, buf + sizeof(struct rpc_struct),
+		       rpc_head->parameterSize);
+		dev_err(hndl->dev, "ve2 decode error!!\n");
+		kfree(event);
+		break;
+	case VIDEO_RPC_DEC_ToSystem_Deliver_MediaInfo:
+		event = kmalloc(sizeof(struct VIDEO_RPC_DEC_MEDIA_INFO),
+				GFP_KERNEL | __GFP_ZERO);
+		if (!event) {
+			dev_err(hndl->dev,
+				"VIDEO_RPC_DEC_MEDIA_INFO event malloc fail\n");
+			ret = -ENOMEM;
+			goto exit;
+		}
+		if (rpc_head->parameterSize !=
+		    sizeof(struct VIDEO_RPC_DEC_MEDIA_INFO)) {
+			dev_err(hndl->dev,
+				"vclient: VIDEO_RPC_DEC_MEDIA_INFO: rpc data size not match(expect:%lu real:%ld rpc->parameterSize:%d)\n",
+				sizeof(struct VIDEO_RPC_DEC_MEDIA_INFO), size,
+				rpc_head->parameterSize);
+		}
+		memcpy(event, buf + sizeof(struct rpc_struct),
+		       rpc_head->parameterSize);
+		kfree(event);
+		break;
+	case VIDEO_RPC_ToSystem_VoutMessage:
+		event = kmalloc(sizeof(struct VIDEO_RPC_VOUT_MESSAGE),
+				GFP_KERNEL | __GFP_ZERO);
+		if (!event) {
+			dev_err(hndl->dev,
+				"VIDEO_RPC_VOUT_MESSAGE event malloc fail\n");
+			ret = -ENOMEM;
+			goto exit;
+		}
+		if (rpc_head->parameterSize !=
+		    sizeof(struct VIDEO_RPC_VOUT_MESSAGE)) {
+			dev_err(hndl->dev,
+				"vclient: VIDEO_RPC_VOUT_MESSAGE: rpc data size not match(expect:%lu real:%ld rpc->parameterSize:%d)\n",
+				sizeof(struct VIDEO_RPC_VOUT_MESSAGE), size,
+				rpc_head->parameterSize);
+		}
+		memcpy(event, buf + sizeof(struct rpc_struct),
+		       rpc_head->parameterSize);
+		dev_dbg(hndl->dev,
+			"instanceID %x, message %x, PTShigh %x, PTSlow %x, reserved %x %x %x %x\n",
+			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)
+				      ->instanceID),
+			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)->message),
+			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)->PTShigh),
+			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)->PTSlow),
+			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)
+				      ->reserved1),
+			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)
+				      ->reserved2),
+			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)
+				      ->reserved3),
+			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)
+				      ->reserved4));
+
+		width = ((struct VIDEO_RPC_VOUT_MESSAGE *)event)->reserved1;
+		height = ((struct VIDEO_RPC_VOUT_MESSAGE *)event)->reserved2;
+#if 0
+		if (!hndl->is_adaptive_playback)
+			hndl->main_rb.pRBH->reserve3 = htonl(width << 16 | height);
+
+		vpu_get_cap_fmt(fh, (void *)&vpu_fmt);
+		vpu_fmt.spec.fmt.pix_mp.width = width;
+		vpu_fmt.spec.fmt.pix_mp.height = height;
+		vpu_fmt.spec.fmt.pix_mp.plane_fmt[0].bytesperline = width;
+		vpu_update_cap_fmt(fh, (void *)&vpu_fmt);
+
+		vpu_notify_event_resolution_change(fh);
+#endif
+		kfree(event);
+		break;
+	default:
+		break;
+	}
+	if (rpc_head->taskID != 0)
+		SendReply(hndl->vcpu_ept_info, rpc_head->taskID,
+			  rpc_head->mycontext, (char *)&retval, sizeof(retval));
+
+exit:
+	return ret;
+}
+
+static int krpc_vcpu_cb(struct rtk_krpc_ept_info *krpc_ept_info, char *buf)
+{
+	uint32_t *tmp;
+	struct rpc_struct *rpc = (struct rpc_struct *)buf;
+
+	if (rpc->programID == REPLYID) {
+		tmp = (uint32_t *)(buf + sizeof(struct rpc_struct));
+		*(krpc_ept_info->retval) = *(tmp + 1);
+
+		complete(&krpc_ept_info->ack);
+	} else {
+		handle_rpc_command(krpc_ept_info, buf);
+	}
+
+	return 0;
+}
+
+static char *prepare_rpc_data(struct rtk_krpc_ept_info *krpc_ept_info,
+			      uint32_t command, uint32_t param1,
+			      uint32_t param2, int *len)
+{
+	struct rpc_struct *rpc;
+	uint32_t *tmp;
+	char *buf;
+
+	*len = sizeof(struct rpc_struct) + 3 * sizeof(uint32_t);
+	buf = kmalloc(sizeof(struct rpc_struct) + 3 * sizeof(uint32_t),
+		      GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	rpc = (struct rpc_struct *)buf;
+	rpc->programID = KERNELID;
+	rpc->versionID = KERNELID;
+	rpc->procedureID = 0;
+	rpc->taskID = krpc_ept_info->id;
+	rpc->sysTID = krpc_ept_info->id;
+	rpc->sysPID = krpc_ept_info->id;
+	rpc->parameterSize = 3 * sizeof(uint32_t);
+	rpc->mycontext = 0;
+	tmp = (uint32_t *)(buf + sizeof(struct rpc_struct));
+	*tmp = command;
+	*(tmp + 1) = param1;
+	*(tmp + 2) = param2;
+
+	return buf;
+}
+
+int rtkve_send_rpc(struct rtk_krpc_ept_info *krpc_ept_info, char *buf, int len,
+		   uint32_t *retval)
+{
+	int ret = 0;
+
+	mutex_lock(&krpc_ept_info->send_mutex);
+
+	krpc_ept_info->retval = retval;
+	rtk_send_rpc(krpc_ept_info, buf, len);
+	if (!wait_for_completion_timeout(&krpc_ept_info->ack, RPC_TIMEOUT)) {
+		pr_err("[%s]kernel rpc timeout: %s...\n", __func__,
+		       krpc_ept_info->name);
+		rtk_krpc_dump_ringbuf_info(krpc_ept_info);
+		mutex_unlock(&krpc_ept_info->send_mutex);
+		ret = -EINVAL;
+		goto exit;
+	}
+	mutex_unlock(&krpc_ept_info->send_mutex);
+
+exit:
+	return ret;
+}
+
+static int send_rpc(struct vpu_handler *hndl, int opt, uint32_t command,
+		    uint32_t param1, uint32_t param2, uint32_t *retval)
+{
+	int ret = 0;
+	char *buf;
+	int len;
+
+	if (opt == RPC_VIDEO) {
+		buf = prepare_rpc_data(hndl->vcpu_ept_info, command, param1,
+				       param2, &len);
+		if (!IS_ERR(buf)) {
+			ret = rtkve_send_rpc(hndl->vcpu_ept_info, buf, len,
+					     retval);
+			kfree(buf);
+		}
+	}
+
+	return ret;
+}
+
+static int rtkve_rpc_shuttle(struct vpu_handler *hndl, int cmd, void *data,
+			     int size, void *rpc_ret, int rpc_ret_size)
+{
+	struct vpu_buf *rpc_buf;
+	int offset;
+	uint32_t dat;
+	unsigned int RPC_ret;
+	int ret = 0;
+
+	rpc_buf = rtkve_allocate_dma_memory(hndl->dev, RPC_BUF_SIZE);
+	if (!rpc_buf) {
+		dev_err(hndl->dev,
+			"%s: Allocating shuttle buf of size %d, fail: %d\n",
+			__func__, RPC_BUF_SIZE, ret);
+		goto exit;
+	}
+
+	memcpy_toio(rpc_buf->vaddr, data, size);
+	dsb(sy);
+	offset = get_rpc_alignment_offset(size);
+	dat = rpc_buf->daddr;
+
+	if (send_rpc(hndl, RPC_VIDEO, cmd, dat, dat + offset, &RPC_ret)) {
+		rtkve_free_dma_memory(hndl->dev, rpc_buf);
+		dev_err(hndl->dev, "rtkve rpc shuttle fail, cmd %d\n", cmd);
+		ret = -EPERM;
+	} else {
+		if (RPC_ret == S_OK) {
+			if (rpc_ret)
+				memcpy_toio(rpc_ret, rpc_buf->vaddr + offset,
+					    rpc_ret_size);
+			rtkve_free_dma_memory(hndl->dev, rpc_buf);
+			ret = 0;
+		} else {
+			rtkve_free_dma_memory(hndl->dev, rpc_buf);
+			dev_err(hndl->dev, "rtkve rpc return fail, cmd %d\n",
+				cmd);
+			ret = -EPERM;
+		}
+	}
+exit:
+	return ret;
+}
+
+int rtkve_rpc_open(struct vpu_handler *hndl, int type)
+{
+	struct VIDEO_RPC_INSTANCE instance;
+	struct RPCRES_LONG retval;
+	unsigned int ret = 0;
+
+	if (!hndl) {
+		pr_err("%s, handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	hndl->vcpu_ept_info = get_ve2_krpc_info();
+	ret = krpc_info_init(hndl->vcpu_ept_info, "ve2rpc", krpc_vcpu_cb);
+	if (ret) {
+		dev_err(hndl->dev, "%s krpc_info_init fail\n",
+			v4l2_type_names[hndl->type]);
+		goto exit;
+	}
+	hndl->vcpu_ept_info->priv = (void *)hndl;
+
+	instance.type = htonl(type);
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_COMMON_ToAgent_Create,
+				&instance, sizeof(instance), &retval,
+				sizeof(retval));
+	if (ret) {
+		dev_err(hndl->dev, "fail to open decoder(%s)\n",
+			v4l2_type_names[hndl->type]);
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+	hndl->inst_type = type;
+	if (htonl(retval.result) == S_OK) {
+		hndl->inst_id = htonl(retval.data);
+	} else {
+		dev_err(hndl->dev, "fail to get instance(%s)\n",
+			v4l2_type_names[hndl->type]);
+		mutex_unlock(&hndl->lock);
+		ret = (-EPERM);
+	}
+	mutex_unlock(&hndl->lock);
+exit:
+	return ret;
+}
+
+int rtkve_rpc_close(struct vpu_handler *hndl)
+{
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+	if (hndl->inst_id) {
+		uint32_t inst_id;
+		int ret;
+
+		inst_id = htonl(hndl->inst_id);
+		ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_COMMON_ToAgent_Destroy,
+					&inst_id, sizeof(inst_id), NULL, 0);
+		if (ret) {
+			mutex_unlock(&hndl->lock);
+			dev_err(hndl->dev, "fail to close decoder(%s)\n",
+				v4l2_type_names[hndl->type]);
+			ret = -EPERM;
+			goto exit;
+		}
+	}
+
+	krpc_info_deinit(hndl->vcpu_ept_info);
+	krpc_ept_info_put(hndl->vcpu_ept_info);
+
+	hndl->inst_type = -1;
+	hndl->inst_id = -1;
+	mutex_unlock(&hndl->lock);
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_connect(struct vpu_handler *src, struct vpu_handler *dst)
+{
+	struct RPC_CONNECTION connection;
+	int ret = 0;
+
+	if (!src || !src->inst_id) {
+		pr_err("%s decoder handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (!dst || !dst->inst_id) {
+		pr_err("%s flash handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+	mutex_lock(&dst->lock);
+	mutex_lock(&src->lock);
+
+	memset(&connection, 0, sizeof(connection));
+	connection.srcInstanceID = htonl(src->inst_id);
+	connection.desInstanceID = htonl(dst->inst_id);
+
+	ret = rtkve_rpc_shuttle(src, VIDEO_RPC_COMMON_ToAgent_Connect,
+				&connection, sizeof(connection), NULL, 0);
+	mutex_unlock(&src->lock);
+	mutex_unlock(&dst->lock);
+	if (ret) {
+		dev_err(src->dev, "fail to do connect cmd %d \n",
+			VIDEO_RPC_COMMON_ToAgent_Connect);
+		ret = -EPERM;
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_set_role(struct vpu_handler *hndl, enum VIDEO_STREAM_TYPE type)
+{
+	struct VIDEO_RPC_DEC_INIT info;
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, decoder handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->inst_id);
+	info.set_speed.instanceID = htonl(hndl->inst_id);
+	info.set_speed.displaySpeed = 0;
+	info.set_speed.decodeSkip = 0;
+	info.type = htonl(type);
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_DEC_ToAgent_Init, &info,
+				sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do init cmd %d \n",
+			VIDEO_RPC_DEC_ToAgent_Init);
+		ret = (-EPERM);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_enable_drop_cnt(struct vpu_handler *hndl)
+{
+	struct VIDEO_RPC_RESOURCE_INFO info;
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, decoder handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->inst_id);
+	info.resource_ctrl_sets = htonl(0x80);
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_ToAgent_SetResourceInfo, &info,
+				sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do set drop cnt %d \n",
+			VIDEO_RPC_ToAgent_SetResourceInfo);
+		ret = (-EPERM);
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_set_cmprs(struct vpu_handler *hndl, uint8_t enable)
+{
+	struct VIDEO_RPC_DEC_CMPRS_CTRL info;
+	int ret = 0;
+
+	if (!hndl || !hndl->inst_id) {
+		pr_err("%s, handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&hndl->lock);
+	memset(&info, 0, sizeof(info));
+
+	info.instanceID = htonl(hndl->inst_id);
+	info.mode = 0;
+	info.ratio = htonl(CMPRS_RATIO_75);
+	info.enable = htonl(enable);
+
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_DEC_ToAgent_CmprsCtrl, &info,
+				sizeof(info), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do cmprs cmd %d \n",
+			VIDEO_RPC_DEC_ToAgent_CmprsCtrl);
+		ret = -EPERM;
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+static int rtkve_rpc_common(struct vpu_handler *hndl, int cmd)
+{
+	uint32_t instanceID;
+	int ret = 0;
+
+	mutex_lock(&hndl->lock);
+	if (!hndl || !hndl->inst_id || hndl->inst_id == -1) {
+		pr_err("%s, handler is NULL", __func__);
+		ret = -EPERM;
+		mutex_unlock(&hndl->lock);
+		goto exit;
+	}
+
+	instanceID = htonl(hndl->inst_id);
+	ret = rtkve_rpc_shuttle(hndl, cmd, &instanceID, sizeof(instanceID),
+				NULL, 0);
+	if (ret) {
+		dev_err(hndl->dev, "fail to do cmd %d \n", cmd);
+		ret = -EPERM;
+		mutex_unlock(&hndl->lock);
+		goto exit;
+	}
+	mutex_unlock(&hndl->lock);
+exit:
+	return ret;
+}
+
+int rtkve_rpc_run(struct vpu_handler *hndl)
+{
+	int ret = 0;
+
+	ret = rtkve_rpc_common(hndl, VIDEO_RPC_COMMON_ToAgent_Run);
+	return ret;
+}
+
+int rtkve_rpc_pause(struct vpu_handler *hndl)
+{
+	int ret = 0;
+
+	ret = rtkve_rpc_common(hndl, VIDEO_RPC_COMMON_ToAgent_Pause);
+	return ret;
+}
+
+int rtkve_rpc_flush(struct vpu_handler *hndl)
+{
+	int ret = 0;
+
+	ret = rtkve_rpc_common(hndl, VIDEO_RPC_COMMON_ToAgent_Flush);
+	return ret;
+}
+
+int rtkve_rpc_stop(struct vpu_handler *hndl)
+{
+	int ret = 0;
+
+	ret = rtkve_rpc_common(hndl, VIDEO_RPC_COMMON_ToAgent_Stop);
+	return ret;
+}
+
+static int rtkve_rpc_set_ringbuf(struct vpu_handler *hndl,
+				 struct rtkve_ringbuf_t *prb, uint32_t bodysize,
+				 enum RINGBUFFER_TYPE type)
+{
+	struct RPC_RINGBUFFER ringbuffer;
+	struct vpu_buf *body;
+	struct vpu_buf *head;
+	int ret = 0;
+
+	if (!hndl) {
+		pr_err("%s, handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	body = rtkve_allocate_dma_memory(hndl->dev, bodysize);
+	if (!body) {
+		dev_err(hndl->dev,
+			"%s: Allocating body buf of size %d, fail: %d\n",
+			__func__, bodysize, ret);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	head = rtkve_allocate_dma_memory(hndl->dev,
+					 sizeof(struct _tagRingBufferHeader));
+	if (!head) {
+		dev_err(hndl->dev,
+			"%s: Allocating head buf of size %ld, fail: %d\n",
+			__func__, sizeof(struct _tagRingBufferHeader), ret);
+		goto err_head_exit;
+	}
+
+	memset(prb, 0, sizeof(struct rtkve_ringbuf_t));
+	mutex_init(&prb->lock);
+	prb->buf_hdl = body;
+	prb->phyaddr = body->daddr;
+	prb->virtaddr = (uint8_t *)body->vaddr;
+	prb->hdr_hdl = head;
+	prb->phyaddr_hdr = head->daddr;
+	prb->virtaddr_hdr = (uint8_t *)head->vaddr;
+	prb->size = bodysize;
+	prb->limit = prb->phyaddr + bodysize;
+
+	prb->pRBH = (volatile struct _tagRingBufferHeader *)head->vaddr;
+	prb->pRBH->size = htonl(bodysize);
+	prb->pRBH->numOfReadPtr = htonl(1);
+	prb->pRBH->beginAddr = htonl(body->daddr);
+	prb->pRBH->writePtr = htonl(body->daddr);
+	prb->pRBH->readPtr[0] = htonl(body->daddr);
+	prb->pRBH->readPtr[1] = htonl(body->daddr);
+	prb->pRBH->readPtr[2] = htonl(body->daddr);
+	prb->pRBH->readPtr[3] = htonl(body->daddr);
+#define VRB_STRUCT_VERSION 1
+#define VRPC_FLASH_FORMAT_SEND_BUF_ID 5
+	prb->pRBH->reserve2 = 0;
+	prb->pRBH->reserve3 = 0;
+	prb->pRBH->bufferID = htonl(type);
+
+	if (RINGBUFFER_FAKE == type)
+		goto exit;
+
+	mutex_lock(&hndl->lock);
+	ringbuffer.instanceID = htonl(hndl->inst_id);
+	ringbuffer.readPtrIndex = 0;
+	ringbuffer.pinID = 0;
+	ringbuffer.pRINGBUFF_HEADER = htonl(head->daddr);
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_COMMON_ToAgent_InitRingBuffer,
+				&ringbuffer, sizeof(ringbuffer), NULL, 0);
+	mutex_unlock(&hndl->lock);
+	if (ret)
+		goto exit;
+
+	return 0;
+
+err_head_exit:
+	rtkve_free_dma_memory(hndl->dev, body);
+exit:
+	return ret;
+}
+
+static int rtkve_rpc_release_ringbuf(struct vpu_handler *hndl,
+				     struct rtkve_ringbuf_t *ringbuf)
+{
+	int ret = 0;
+
+	if (!hndl) {
+		pr_err("%s, handler is NULL", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (!ringbuf) {
+		dev_err(hndl->dev, "Invaild input in %s\n", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (ringbuf->hdr_hdl) {
+		mutex_lock(&ringbuf->lock);
+		rtkve_free_dma_memory(hndl->dev, ringbuf->hdr_hdl);
+		ringbuf->hdr_hdl = NULL;
+		mutex_unlock(&ringbuf->lock);
+	}
+
+	if (ringbuf->buf_hdl) {
+		mutex_lock(&ringbuf->lock);
+		rtkve_free_dma_memory(hndl->dev, ringbuf->buf_hdl);
+		ringbuf->buf_hdl = NULL;
+		mutex_unlock(&ringbuf->lock);
+	}
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_init_flash(struct vpu_handler *flash_hdl)
+{
+	struct RPC_RINGBUFFER ringbuffer;
+	struct rtkve_ringbuf_t *prb = &flash_hdl->flash.mesg_rb;
+	int ret = 0;
+
+	ret = rtkve_rpc_open(flash_hdl, VF_TYPE_FLASH);
+	if (ret) {
+		dev_err(flash_hdl->dev, "fail to open vpu flash\n");
+		ret = (-EPERM);
+		goto exit;
+	}
+
+	mutex_lock(&flash_hdl->lock);
+	ringbuffer.instanceID = htonl(flash_hdl->inst_id);
+	ringbuffer.readPtrIndex = 0;
+	ringbuffer.pinID = 0;
+	ringbuffer.pRINGBUFF_HEADER = htonl(prb->phyaddr_hdr);
+	ret = rtkve_rpc_shuttle(flash_hdl, VIDEO_RPC_COMMON_ToAgent_InitRingBuffer,
+				&ringbuffer, sizeof(ringbuffer), NULL, 0);
+	mutex_unlock(&flash_hdl->lock);
+	if (ret)
+		goto err_mesg_exit;
+
+	return 0;
+
+err_mesg_exit:
+	rtkve_rpc_close(flash_hdl);
+exit:
+	return ret;
+}
+
+int rtkve_rpc_create_flash(struct vpu_instance *inst)
+{
+	struct vpu_handler *flash_hdl;
+	volatile struct rtkve_flash_frame_info_t *frame;
+	uint8_t is_secure = 0;
+	int i;
+	int ret = 0;
+
+	flash_hdl = kzalloc(sizeof(struct vpu_handler), GFP_KERNEL);
+	if (!flash_hdl) {
+		dev_err(inst->dev->dev, "allocate flash handle fail\n");
+		ret = (-ENOMEM);
+		goto err_exit;
+	}
+
+	flash_hdl->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	flash_hdl->dev = inst->dev->dev;
+	flash_hdl->inst_id = -1;
+	ret = rtkve_rpc_open(flash_hdl, VF_TYPE_FLASH);
+	if (ret) {
+		dev_err(flash_hdl->dev, "fail to open vpu flash\n");
+		ret = (-EPERM);
+		goto err_open_exit;
+	}
+
+	ret = rtkve_rpc_set_ringbuf(flash_hdl, &flash_hdl->flash.mesg_rb,
+				    (sizeof(struct rtkve_flash_frame_info_t)) *
+					    RTKVE_MAX_DPB_NUM,
+				    RINGBUFFER_MESSAGE);
+	if (ret) {
+		dev_err(flash_hdl->dev, "fail to initial mesg rb\n");
+		goto err_mesg_exit;
+	}
+
+	inst->flash_hdl = flash_hdl;
+
+	{
+#define VRB_STRUCT_VERSION 1
+#define VRPC_FLASH_FORMAT_SEND_BUF_ID 5
+		flash_hdl->flash.mesg_rb.pRBH->reserve2 =
+			htonl((RTKVE_MAX_DPB_NUM << 24 & 0xff000000) |
+			      (is_secure << 16 & 0x00ff0000) |
+			      (VRB_STRUCT_VERSION << 8 & 0xff00) |
+			      VRPC_FLASH_FORMAT_SEND_BUF_ID);
+#if 0
+		flash_hdl->flash.mesg_rb.pRBH->reserve3 =
+			htonl(1 /*width*/ << 16 | 1 /*height*/);
+#endif
+	}
+
+	flash_hdl->flash.frame =
+		kzalloc(sizeof(uintptr_t) * RTKVE_MAX_DPB_NUM, GFP_KERNEL);
+	frame = (volatile struct rtkve_flash_frame_info_t *)
+			flash_hdl->flash.mesg_rb.virtaddr;
+
+	//flash_hdl->outputRingIdx = 0;
+	for (i = 0; i < RTKVE_MAX_DPB_NUM; i++) {
+		flash_hdl->flash.frame[i] = (uintptr_t)&frame[i];
+		/* DO NOT CHANGE THE ORDER BEGIN*/
+		dsb(sy);
+		frame[i].nClkTimeHigh = -1;
+		frame[i].nClkTimeLow = -1;
+		frame[i].nPicPhysicalAddr =
+			htonl((uint32_t)(uintptr_t)&frame[i]);
+		frame[i].nPicCPhysicalAddr = 0;
+		frame[i].nPicWidth = PIC_SIZE_INVALID;
+		frame[i].nPicHeight = PIC_SIZE_INVALID;
+		frame[i].pUserData = false;
+		dsb(sy);
+		/* DO NOT CHANGE THE ORDER END*/
+	}
+
+	return 0;
+
+err_mesg_exit:
+	rtkve_rpc_close(flash_hdl);
+err_open_exit:
+	kfree(flash_hdl);
+err_exit:
+	return ret;
+}
+
+int rtkve_rpc_destroy_flash(struct vpu_instance *inst)
+{
+	struct vpu_handler *flash_hdl = inst->flash_hdl;
+	struct vpu_flash_info *info = &flash_hdl->flash;
+	int ret = 0;
+
+	if (!flash_hdl)
+		goto exit;
+
+	if (info->frame) {
+		kfree(info->frame);
+		info->frame = NULL;
+	}
+	rtkve_rpc_release_ringbuf(flash_hdl, &info->mesg_rb);
+	rtkve_rpc_close(flash_hdl);
+
+	if (flash_hdl)
+		kfree(flash_hdl);
+
+	flash_hdl = NULL;
+exit:
+	return ret;
+}
+
+int rtkve_rpc_init_decoder(struct vpu_handler *dec_hdl, uint32_t ctrl_ring_size)
+{
+	struct RPC_RINGBUFFER ringbuffer;
+	struct rtkve_ringbuf_t *prb_bs = &dec_hdl->dec.bs_rb;
+	struct rtkve_ringbuf_t *prb_inband = &dec_hdl->dec.inband_rb;
+	struct rtkve_ringbuf_t *prb_ctrl = &dec_hdl->dec.ctrl_info_rb;
+	struct rtkve_ringbuf_t *prb_dpb = &dec_hdl->dec.dpb_rb;
+	int ret = 0;
+
+	ret = rtkve_rpc_open(dec_hdl, VF_TYPE_VIDEO_MPEG2_DECODER);
+	if (ret) {
+		dev_err(dec_hdl->dev, "fail to open vpu decoder\n");
+		ret = (-EPERM);
+		goto exit;
+	}
+
+	mutex_lock(&dec_hdl->lock);
+	ringbuffer.instanceID = htonl(dec_hdl->inst_id);
+	ringbuffer.readPtrIndex = 0;
+	ringbuffer.pinID = 0;
+	ringbuffer.pRINGBUFF_HEADER = htonl(prb_bs->phyaddr_hdr);
+	ret = rtkve_rpc_shuttle(dec_hdl, VIDEO_RPC_COMMON_ToAgent_InitRingBuffer,
+				&ringbuffer, sizeof(ringbuffer), NULL, 0);
+	mutex_unlock(&dec_hdl->lock);
+	if (ret) {
+		dev_err(dec_hdl->dev, "fail to initial bs rb\n");
+		ret = (-EPERM);
+		goto err_close;
+	}
+
+	mutex_lock(&dec_hdl->lock);
+	ringbuffer.instanceID = htonl(dec_hdl->inst_id);
+	ringbuffer.readPtrIndex = 0;
+	ringbuffer.pinID = 0;
+	ringbuffer.pRINGBUFF_HEADER = htonl(prb_inband->phyaddr_hdr);
+	ret = rtkve_rpc_shuttle(dec_hdl, VIDEO_RPC_COMMON_ToAgent_InitRingBuffer,
+				&ringbuffer, sizeof(ringbuffer), NULL, 0);
+	mutex_unlock(&dec_hdl->lock);
+	if (ret) {
+		dev_err(dec_hdl->dev, "fail to initial inband rb\n");
+		ret = (-EPERM);
+		goto err_close;
+	}
+
+	if (ctrl_ring_size) {
+		mutex_lock(&dec_hdl->lock);
+		ringbuffer.instanceID = htonl(dec_hdl->inst_id);
+		ringbuffer.readPtrIndex = 0;
+		ringbuffer.pinID = 0;
+		ringbuffer.pRINGBUFF_HEADER = htonl(prb_ctrl->phyaddr_hdr);
+		ret = rtkve_rpc_shuttle(dec_hdl, VIDEO_RPC_COMMON_ToAgent_InitRingBuffer,
+					&ringbuffer, sizeof(ringbuffer), NULL, 0);
+		mutex_unlock(&dec_hdl->lock);
+		if (ret) {
+			dev_err(dec_hdl->dev, "fail to initial ctrl rb\n");
+			ret = (-EPERM);
+			goto err_close;
+		}
+	} else {
+		mutex_lock(&dec_hdl->lock);
+		ringbuffer.instanceID = htonl(dec_hdl->inst_id);
+		ringbuffer.readPtrIndex = 0;
+		ringbuffer.pinID = 0;
+		ringbuffer.pRINGBUFF_HEADER = htonl(prb_dpb->phyaddr_hdr);
+		ret = rtkve_rpc_shuttle(dec_hdl, VIDEO_RPC_COMMON_ToAgent_InitRingBuffer,
+					&ringbuffer, sizeof(ringbuffer), NULL, 0);
+		mutex_unlock(&dec_hdl->lock);
+		if (ret) {
+			dev_err(dec_hdl->dev, "fail to initial dpbl rb\n");
+			ret = (-EPERM);
+			goto err_close;
+		}
+	}
+
+	return 0;
+err_close:
+	rtkve_rpc_close(dec_hdl);
+exit:
+	return ret;
+}
+
+int rtkve_rpc_create_decoder(struct vpu_instance *inst, uint32_t ctrl_ring_size)
+{
+	struct vpu_handler *dec_hdl;
+	int ret = 0;
+
+	dec_hdl = kzalloc(sizeof(struct vpu_handler), GFP_KERNEL);
+	if (!dec_hdl) {
+		dev_err(inst->dev->dev, "allocate decoder handle fail\n");
+		ret = (-ENOMEM);
+		goto err_exit;
+	}
+
+	dec_hdl->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	dec_hdl->dev = inst->dev->dev;
+	dec_hdl->inst_id = -1;
+	ret = rtkve_rpc_open(dec_hdl, VF_TYPE_VIDEO_MPEG2_DECODER);
+	if (ret) {
+		dev_err(dec_hdl->dev, "fail to open vpu decoder\n");
+		ret = (-EPERM);
+		goto err_open_exit;
+	}
+
+	ret = rtkve_rpc_set_ringbuf(dec_hdl, &dec_hdl->dec.bs_rb,
+				    BS_RINGBUF_SIZE, RINGBUFFER_STREAM);
+	if (ret) {
+		dev_err(dec_hdl->dev, "fail to initial bs rb\n");
+		ret = (-EPERM);
+		goto err_bs_exit;
+	}
+
+	ret = rtkve_rpc_set_ringbuf(dec_hdl, &dec_hdl->dec.inband_rb,
+				    INBAND_RINGBUF_SIZE, RINGBUFFER_COMMAND);
+	if (ret) {
+		dev_err(dec_hdl->dev, "fail to initial inband rb\n");
+		ret = (-EPERM);
+		goto err_inband_exit;
+	}
+
+	if (ctrl_ring_size) {
+		ret = rtkve_rpc_set_ringbuf(dec_hdl, &dec_hdl->dec.ctrl_info_rb,
+					    ctrl_ring_size,
+					    RINGBUFFER_V4L2_CONTROL);
+		if (ret) {
+			dev_err(dec_hdl->dev, "fail to initial ctrl rb\n");
+			ret = (-EPERM);
+			goto err_dpb_exit;
+		}
+	} else {
+		ret = rtkve_rpc_set_ringbuf(dec_hdl, &dec_hdl->dec.dpb_rb,
+					    DPB_RINGBUF_SIZE,
+					    RINGBUFFER_FRAME_USER);
+		if (ret) {
+			dev_err(dec_hdl->dev, "fail to initial dpbl rb\n");
+			ret = (-EPERM);
+			goto err_dpb_exit;
+		}
+	}
+
+	inst->dec_hdl = dec_hdl;
+
+	return 0;
+
+err_dpb_exit:
+	rtkve_rpc_release_ringbuf(dec_hdl, &dec_hdl->dec.inband_rb);
+err_inband_exit:
+	rtkve_rpc_release_ringbuf(dec_hdl, &dec_hdl->dec.bs_rb);
+err_bs_exit:
+	rtkve_rpc_close(dec_hdl);
+err_open_exit:
+	kfree(dec_hdl);
+err_exit:
+	return ret;
+}
+
+int rtkve_rpc_destroy_decoder(struct vpu_instance *inst)
+{
+	struct vpu_handler *dec_hdl = inst->dec_hdl;
+	struct vpu_decoder_info *info = &dec_hdl->dec;
+	int ret = 0;
+
+	if (!dec_hdl)
+		goto exit;
+
+	rtkve_rpc_release_ringbuf(dec_hdl, &info->ctrl_info_rb);
+	rtkve_rpc_release_ringbuf(dec_hdl, &info->inband_rb);
+	rtkve_rpc_release_ringbuf(dec_hdl, &info->bs_rb);
+
+	rtkve_rpc_close(dec_hdl);
+	if (dec_hdl)
+		kfree(dec_hdl);
+
+	dec_hdl = NULL;
+exit:
+	return ret;
+}
+
+int rtkve_rpc_suspend(struct vpu_instance *inst)
+{
+	struct vpu_handler *flash_hndl = inst->flash_hdl;
+	struct vpu_handler *dec_hndl = inst->dec_hdl;
+	int ret = 0;
+
+	ret = rtkve_rpc_pause(dec_hndl);
+	if (ret) {
+		dev_err(dec_hndl->dev, "failed pause decode instance: %d\n",
+			ret);
+	}
+
+	ret = rtkve_rpc_pause(flash_hndl);
+	if (ret) {
+		dev_err(dec_hndl->dev, "failed pause decode instance: %d\n",
+			ret);
+	}
+	return ret;
+}
+
+int rtkve_rpc_resume(struct vpu_instance *inst, uint32_t ctrl_size)
+{
+	struct vpu_handler *flash_hdl = inst->flash_hdl;
+	struct vpu_handler *dec_hdl = inst->dec_hdl;
+	int ret = 0;
+
+	ret = rtkve_rpc_init_flash(flash_hdl);
+	if (ret)
+		goto exit;
+
+	ret = rtkve_rpc_init_decoder(dec_hdl, ctrl_size);
+	if (ret)
+		goto exit;
+
+exit:
+	return ret;
+}
+
+int rtkve_rpc_get_bs_info(struct device *dev, enum VIDEO_STREAM_TYPE codec,
+			  uint32_t size, void *buf,
+			  struct rtkve_pre_parsing_info *info)
+{
+	struct vpu_handler *hndl;
+	struct vpu_buf *bs_buf;
+	struct VIDEO_RPC_DEC_BITSTREAM_BUFFER input = { 0 };
+	struct VIDEO_RPC_DEC_PV_RESULT output = { 0 };
+	uint32_t paddr = 0;
+	int ret = 0;
+
+	hndl = kzalloc(sizeof(struct vpu_handler), GFP_KERNEL);
+	hndl->dev = dev;
+	hndl->vcpu_ept_info = get_ve2_krpc_info();
+	ret = krpc_info_init(hndl->vcpu_ept_info, "ve2rpc", krpc_vcpu_cb);
+	hndl->vcpu_ept_info->priv = (void *)hndl;
+
+	bs_buf = rtkve_allocate_dma_memory(hndl->dev, size);
+	if (!bs_buf) {
+		dev_err(hndl->dev,
+			"%s: Allocating pre bs buf of size %d, fail: %d\n",
+			__func__, size, ret);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	memcpy(bs_buf->vaddr, buf, size);
+
+	paddr = (uint32_t)bs_buf->daddr; // TODO
+	input.bsBase = htonl(paddr);
+	input.bsSize = htonl(size);
+
+	if (codec == VIDEO_STREAM_H265) {
+		input.type = htonl(VF_TYPE_VIDEO_H265_DECODER);
+	} else if (codec == VIDEO_STREAM_VP9) {
+		input.type = htonl(VF_TYPE_VIDEO_VP9_DECODER);
+	} else if (codec == VIDEO_STREAM_AV1) {
+		input.type = htonl(VF_TYPE_VIDEO_AV1_DECODER);
+	} else {
+		input.type = htonl(VF_TYPE_VIDEO_H265_DECODER);
+		dev_err(hndl->dev, "%s, unsupport codec %d", __func__, codec);
+	}
+	ret = rtkve_rpc_shuttle(hndl, VIDEO_RPC_DEC_ToAgent_ParseResolution,
+				&input,
+				sizeof(struct VIDEO_RPC_DEC_BITSTREAM_BUFFER),
+				&output,
+				sizeof(struct VIDEO_RPC_DEC_PV_RESULT));
+	if (ret) {
+		dev_err(hndl->dev, "fail to do cmd ParseResolution %d \n",
+			VIDEO_RPC_DEC_ToAgent_BitstreamValidation);
+	}
+
+	info->width = htonl(output.width) >> 16;
+	info->height = htonl(output.height) >> 16;
+	info->ddr_width = htonl(output.width) & 0xffff;
+	info->ddr_height = htonl(output.height) & 0xffff;
+	info->min_reqbuf = htonl(output.DPB_size);
+	info->bit_depth = htonl(output.bit_depth);
+	if (info->bit_depth != PRE_PARSING_ERROR)
+		info->bit_depth = (info->bit_depth == 1) ? 10 : 8;
+
+	rtkve_free_dma_memory(hndl->dev, bs_buf);
+	krpc_info_deinit(hndl->vcpu_ept_info);
+	krpc_ept_info_put(hndl->vcpu_ept_info);
+	kfree(hndl);
+exit:
+	return ret;
+}
+
+static void rtkve_inband_memcpy(uint8_t *des, uint8_t *src, unsigned int size)
+{
+	unsigned int *src_int32 = (unsigned int *)src;
+	unsigned int *des_int32 = (unsigned int *)des;
+	unsigned int i;
+
+	for (i = 0; i < (size / sizeof(int)); i++)
+		des_int32[i] = htonl(src_int32[i]);
+
+	dsb(sy);
+}
+
+int rtkve_write_rb(struct rtkve_ringbuf_t *ringbuf, int type, uint8_t *buf,
+		   int size)
+{
+	volatile struct rtkve_ringbuf_t *rb = ringbuf;
+	uint32_t wp, rp;
+	void *wptr, *next, *addr_end;
+	uint8_t over = 0;
+	int ret = 0;
+
+	if (!ringbuf) {
+		pr_err("invaild input ringbuf %p", ringbuf);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&ringbuf->lock);
+
+	wp = htonl(rb->pRBH->writePtr);
+	rp = htonl(rb->pRBH->readPtr[0]);
+
+	if (rp > wp && (int)(rp - wp - 1) < size) {
+		mutex_unlock(&ringbuf->lock);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (wp > rp && (int)(rp + rb->size - wp - 1) < size) {
+		mutex_unlock(&ringbuf->lock);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	wptr = rb->virtaddr + (wp - rb->phyaddr);
+	addr_end = rb->virtaddr + rb->size;
+	next = wptr + size;
+	if (next >= addr_end) {
+		over = 1;
+		next -= rb->size;
+	}
+
+	if (over) {
+		int size0 = 0;
+		int size1 = 0;
+
+		size0 = rb->virtaddr + rb->size - (uint8_t *)wptr;
+		size1 = size - size0;
+
+		if (type == RINGBUFFER_STREAM ||
+		    type == RINGBUFFER_V4L2_CONTROL) {
+			if (size0 != 0)
+				memcpy_toio(wptr, buf, size0);
+
+			if (size1 != 0)
+				memcpy_toio(rb->virtaddr, buf + size0, size1);
+		} else {
+			if (size0 != 0)
+				rtkve_inband_memcpy(wptr, buf,
+						    (unsigned int)size0);
+
+			if (size1 != 0)
+				rtkve_inband_memcpy(rb->virtaddr, buf + size0,
+						    (unsigned int)size1);
+		}
+	} else {
+		if (type == RINGBUFFER_STREAM ||
+		    type == RINGBUFFER_V4L2_CONTROL)
+			memcpy_toio(wptr, buf, size);
+		else
+			rtkve_inband_memcpy(wptr, buf, (unsigned int)size);
+	}
+
+	rb->pRBH->writePtr =
+		htonl(rb->phyaddr + ((uint8_t *)next - rb->virtaddr));
+	dsb(sy);
+
+	mutex_unlock(&ringbuf->lock);
+exit:
+	return ret;
+}
+
+int rtkve_inband_newseg(struct vpu_handler *hndl)
+{
+	struct NEW_SEG cmd;
+	struct rtkve_ringbuf_t *cmb_ringbuf = &hndl->dec.inband_rb;
+	struct rtkve_ringbuf_t *bs_ringbuf = &hndl->dec.bs_rb;
+	int ret = 0;
+
+	mutex_lock(&bs_ringbuf->lock);
+	cmd.header.type = INBAND_CMD_TYPE_NEW_SEG;
+	cmd.header.size = sizeof(cmd);
+	cmd.wPtr = htonl(bs_ringbuf->pRBH->writePtr);
+	mutex_unlock(&bs_ringbuf->lock);
+
+	ret = rtkve_write_rb(cmb_ringbuf, RINGBUFFER_COMMAND, (uint8_t *)&cmd,
+			     sizeof(cmd));
+
+	return ret;
+}
+
+int rtkve_inband_decode(struct vpu_handler *hndl, enum DECODE_MODE mode)
+{
+	struct DECODE_NEW cmd;
+	int64_t relativePTS = 0;
+	int64_t duration = -1;
+	int ret = 0;
+
+	cmd.header.type = INBAND_CMD_TYPE_DECODE;
+	cmd.header.size = sizeof(struct DECODE_NEW);
+	cmd.RelativePTSH = relativePTS >> 32;
+	cmd.RelativePTSL = relativePTS;
+	cmd.PTSDurationH = duration >> 32;
+	cmd.PTSDurationL = duration;
+	cmd.skip_GOP = 0;
+	cmd.mode = mode;
+	cmd.isHM91 = 0;
+	cmd.useAbsolutePTS = 1;
+
+	ret = rtkve_write_rb(&hndl->dec.inband_rb, RINGBUFFER_COMMAND,
+			     (uint8_t *)&cmd, sizeof(cmd));
+
+	return ret;
+}
+
+int rtkve_inband_pts2(struct vpu_handler *hndl, uint32_t wptr, uint64_t pts,
+		      uint64_t pts2, uint32_t length, uint32_t flag)
+{
+	struct PTS_INFO2 cmd;
+	int ret = 0;
+
+	if (!length) {
+		pr_err("%s wrong length %d\n", __func__, length);
+		goto exit;
+	}
+
+	cmd.header.type = INBAND_CMD_TYPE_PTS;
+	cmd.header.size = sizeof(struct PTS_INFO2);
+	cmd.wPtr = wptr;
+	cmd.PTSH = pts >> 32;
+	cmd.PTSL = pts;
+	cmd.PTSH2 = pts2 >> 32;
+	cmd.PTSL2 = pts2;
+	cmd.length = length;
+	cmd.flag = flag;
+
+	ret = rtkve_write_rb(&hndl->dec.inband_rb, RINGBUFFER_COMMAND,
+			     (uint8_t *)&cmd, sizeof(cmd));
+
+exit:
+	return ret;
+}
+
+int rtkve_inband_setup_ctrl(struct vpu_handler *hndl, uint32_t ctrl_size)
+{
+	volatile struct rtkve_ringbuf_t *rb = &hndl->dec.ctrl_info_rb;
+	uint32_t wp, rp;
+	void *wptr, *next, *addr_end;
+	int ret = 0;
+
+	wp = htonl(rb->pRBH->writePtr);
+	rp = htonl(rb->pRBH->readPtr[0]);
+
+	if (rp > wp && (int)(rp - wp - 1) < ctrl_size) {
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (wp > rp && (int)(rp + rb->size - wp - 1) < ctrl_size) {
+		ret = -EPERM;
+		goto exit;
+	}
+
+	wptr = rb->virtaddr + (wp - rb->phyaddr);
+	addr_end = rb->virtaddr + rb->size;
+	next = wptr + ctrl_size;
+	if (next >= addr_end) {
+		next -= rb->size;
+	}
+
+	rb->pRBH->writePtr =
+		htonl(rb->phyaddr + ((uint8_t *)next - rb->virtaddr));
+	dsb(sy);
+exit:
+	return ret;
+}
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-rpc.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-rpc.h
@@ -0,0 +1,109 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#ifndef RTKVE_RPC_H
+#define RTKVE_RPC_H
+
+#include "rtkve-rpc-def.h"
+#include "rtkve-common.h"
+#include "rtkve_frame.h"
+
+struct rtkve_ringbuf_t {
+	struct mutex lock;
+	volatile struct _tagRingBufferHeader *pRBH;
+	uint32_t phyaddr;
+	uint32_t phyaddr_hdr;
+	uint32_t limit;
+	uint32_t size;
+	uint8_t *virtaddr;
+	uint8_t *virtaddr_hdr;
+	void *hdr_hdl;
+	void *buf_hdl;
+};
+
+struct rtkve_buflock_t {
+	volatile uint8_t *buflock_va;
+	uint32_t buflock_pa;
+	uint32_t idx;
+	bool is_used;
+};
+
+struct rtkve_pre_parsing_info {
+	uint32_t width;
+	uint32_t height;
+	uint32_t min_reqbuf;
+	uint32_t bit_depth;
+	uint32_t ddr_width;
+	uint32_t ddr_height;
+};
+
+struct vpu_decoder_info {
+	struct rtkve_ringbuf_t bs_rb;
+	struct rtkve_ringbuf_t inband_rb;
+	union {
+		struct rtkve_ringbuf_t ctrl_info_rb;
+		struct rtkve_ringbuf_t dpb_rb;
+	};
+	struct rtkve_pre_parsing_info parsing_info;
+};
+
+struct vpu_flash_info {
+	struct rtkve_ringbuf_t mesg_rb;
+	uint32_t outputRingIdx;
+	uintptr_t *frame;
+};
+
+struct vpu_handler {
+	struct rtk_krpc_ept_info *vcpu_ept_info;
+	struct mutex lock;
+	uint32_t inst_type;
+	uint32_t inst_id;
+	struct device *dev;
+	int type;
+	bool is_running;
+	union {
+		struct vpu_decoder_info dec;
+		struct vpu_flash_info flash;
+	};
+};
+
+int rtkve_rpc_open(struct vpu_handler *hndl, int type);
+int rtkve_rpc_close(struct vpu_handler *hndl);
+int rtkve_rpc_connect(struct vpu_handler *src, struct vpu_handler *dst);
+int rtkve_rpc_set_role(struct vpu_handler *hndl, enum VIDEO_STREAM_TYPE type);
+int rtkve_rpc_enable_drop_cnt(struct vpu_handler *hndl);
+int rtkve_rpc_set_cmprs(struct vpu_handler *hndl, uint8_t enable);
+int rtkve_rpc_run(struct vpu_handler *hndl);
+int rtkve_rpc_pause(struct vpu_handler *hndl);
+int rtkve_rpc_flush(struct vpu_handler *hndl);
+int rtkve_rpc_stop(struct vpu_handler *hndl);
+int rtkve_rpc_create_flash(struct vpu_instance *inst);
+int rtkve_rpc_destroy_flash(struct vpu_instance *inst);
+int rtkve_rpc_create_decoder(struct vpu_instance *inst,
+			     uint32_t ctrl_ring_size);
+int rtkve_rpc_destroy_decoder(struct vpu_instance *inst);
+int rtkve_rpc_suspend(struct vpu_instance *inst);
+int rtkve_rpc_resume(struct vpu_instance *inst, uint32_t ctrl_size);
+int rtkve_rpc_get_bs_info(struct device *dev, enum VIDEO_STREAM_TYPE codec,
+			  uint32_t size, void *buf,
+			  struct rtkve_pre_parsing_info *info);
+int rtkve_inband_newseg(struct vpu_handler *hndl);
+int rtkve_inband_decode(struct vpu_handler *hndl, enum DECODE_MODE mode);
+int rtkve_inband_setup_ctrl(struct vpu_handler *hndl, uint32_t ctrl_size);
+int rtkve_inband_pts2(struct vpu_handler *hndl, uint32_t wptr, uint64_t pts,
+		      uint64_t pts2, uint32_t length, uint32_t flag);
+
+int rtkve_write_rb(struct rtkve_ringbuf_t *ringbuf, int type, uint8_t *buf,
+		   int size);
+
+#endif
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-av1.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-av1.c
@@ -0,0 +1,315 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+
+#include <media/videobuf2-dma-contig.h>
+
+#include "rtkve-sl-ctrl.h"
+#include "rtkve-common.h"
+#include "rtkve-rpc.h"
+#include "rtkve-sl-av1.h"
+
+static void rtkve_av1_setup_sequence(struct AV1_V4L2_CTRL_INFO *av1,
+				     struct stateless_av1_info *ctrl)
+{
+	struct ctrl_av1_sequence *seq = &av1->av1_sequence;
+	const struct v4l2_ctrl_av1_sequence *ctrl_seq = ctrl->seq;
+
+	seq->flags = htonl(ctrl_seq->flags);
+	seq->seq_profile = ctrl_seq->seq_profile;
+	seq->order_hint_bits = ctrl_seq->order_hint_bits;
+	seq->bit_depth = ctrl_seq->bit_depth;
+	seq->reserved = ctrl_seq->reserved;
+	seq->max_frame_width_minus_1 = htons(ctrl_seq->max_frame_width_minus_1);
+	seq->max_frame_height_minus_1 =
+		htons(ctrl_seq->max_frame_height_minus_1);
+}
+
+static void
+rtkve_av1_setup_tile_info(struct AV1_V4L2_CTRL_INFO *av1,
+			  const struct v4l2_av1_tile_info *ctrl_info)
+{
+	struct av1_tile_info *info = &av1->av1_frame.tile_info;
+
+	info->flags = ctrl_info->flags;
+	info->context_update_tile_id = ctrl_info->context_update_tile_id;
+	info->tile_cols = ctrl_info->tile_cols;
+	info->tile_rows = ctrl_info->tile_rows;
+	dword_endian_convert((uint8_t *)info->mi_col_starts,
+			     (uint8_t *)ctrl_info->mi_col_starts,
+			     sizeof(ctrl_info->mi_col_starts));
+	dword_endian_convert((uint8_t *)info->mi_row_starts,
+			     (uint8_t *)ctrl_info->mi_row_starts,
+			     sizeof(ctrl_info->mi_row_starts));
+	dword_endian_convert((uint8_t *)info->width_in_sbs_minus_1,
+			     (uint8_t *)ctrl_info->width_in_sbs_minus_1,
+			     sizeof(ctrl_info->width_in_sbs_minus_1));
+	dword_endian_convert((uint8_t *)info->height_in_sbs_minus_1,
+			     (uint8_t *)ctrl_info->height_in_sbs_minus_1,
+			     sizeof(ctrl_info->height_in_sbs_minus_1));
+	info->tile_size_bytes = ctrl_info->tile_size_bytes;
+	memcpy(&info->reserved, ctrl_info->reserved,
+	       sizeof(ctrl_info->reserved));
+}
+
+static void
+rtkve_av1_setup_segment(struct AV1_V4L2_CTRL_INFO *av1,
+			const struct v4l2_av1_segmentation *ctrl_seg)
+{
+	struct av1_segmentation *seg = &av1->av1_frame.segmentation;
+
+	seg->flags = ctrl_seg->flags;
+	seg->last_active_seg_id = ctrl_seg->last_active_seg_id;
+	memcpy(&seg->feature_enabled, &ctrl_seg->feature_enabled,
+	       sizeof(ctrl_seg->feature_enabled));
+	word_endian_convert((uint8_t *)seg->feature_data,
+			    (uint8_t *)ctrl_seg->feature_data,
+			    sizeof(ctrl_seg->feature_data));
+}
+
+static void rtkve_av1_setup_loop_restoration(
+	struct AV1_V4L2_CTRL_INFO *av1,
+	const struct v4l2_av1_loop_restoration *ctrl_lr)
+{
+	struct av1_loop_restoration *lr = &av1->av1_frame.loop_restoration;
+
+	lr->flags = ctrl_lr->flags;
+	lr->lr_unit_shift = ctrl_lr->lr_unit_shift;
+	lr->lr_uv_shift = ctrl_lr->lr_uv_shift;
+	lr->reserved = ctrl_lr->reserved;
+	dword_endian_convert((uint8_t *)lr->frame_restoration_type,
+			     (uint8_t *)ctrl_lr->frame_restoration_type,
+			     sizeof(ctrl_lr->frame_restoration_type));
+	dword_endian_convert((uint8_t *)lr->loop_restoration_size,
+			     (uint8_t *)ctrl_lr->loop_restoration_size,
+			     sizeof(ctrl_lr->loop_restoration_size));
+}
+
+static void
+rtkve_av1_setup_global_motion(struct AV1_V4L2_CTRL_INFO *av1,
+			      const struct v4l2_av1_global_motion *ctrl_gm)
+{
+	struct av1_global_motion *gm = &av1->av1_frame.global_motion;
+
+	memcpy(&gm->flags, &ctrl_gm->flags, sizeof(ctrl_gm->flags));
+	dword_endian_convert((uint8_t *)gm->type, (uint8_t *)ctrl_gm->type,
+			     sizeof(ctrl_gm->type));
+	dword_endian_convert((uint8_t *)gm->params, (uint8_t *)ctrl_gm->params,
+			     sizeof(ctrl_gm->params));
+	gm->invalid = ctrl_gm->invalid;
+	memcpy(&gm->reserved, &ctrl_gm->reserved, sizeof(ctrl_gm->reserved));
+}
+
+static int rtkve_av1_setup_ref_frm(struct vpu_instance *inst,
+				   struct AV1_V4L2_CTRL_INFO *av1,
+				   struct stateless_av1_info *ctrl)
+{
+	const struct v4l2_ctrl_av1_frame *ctrl_frm = ctrl->frm;
+	struct vb2_queue *vq;
+	struct vb2_buffer *vb;
+	uint64_t ref_idx;
+	u32 luma_size;
+	int ret = 0;
+	int i = 0;
+
+	/* reference buffers */
+	vq = v4l2_m2m_get_vq(inst->v4l2_fh.m2m_ctx,
+			     V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	if (!vq) {
+		ret = -EINVAL;
+		dev_err(inst->dev->dev, "%s can't find vb2_queue", __func__);
+		goto exit;
+	}
+
+	luma_size = inst->dst_fmt.width * inst->dst_fmt.height;
+	for (i = 0; i < V4L2_AV1_REFS_PER_FRAME; i++) {
+		int ref_frm_idx = ctrl_frm->ref_frame_idx[i];
+		ref_idx = ctrl_frm->reference_frame_ts[ref_frm_idx];
+
+		vb = vb2_find_buffer(vq, ref_idx);
+		if (!vb)
+			continue;
+
+		av1->reference_frame_y_dma_addr[i] =
+			htonl(vb2_dma_contig_plane_dma_addr(vb, 0));
+		av1->reference_frame_c_dma_addr[i] =
+			htonl(vb2_dma_contig_plane_dma_addr(vb, 0) + luma_size);
+	}
+exit:
+	return ret;
+}
+
+static void rtkve_av1_setup_frame(struct vpu_instance *inst,
+				  struct AV1_V4L2_CTRL_INFO *av1,
+				  struct stateless_av1_info *ctrl)
+{
+	struct ctrl_av1_frame *frm = &av1->av1_frame;
+	const struct v4l2_ctrl_av1_frame *ctrl_frm = ctrl->frm;
+	uint32_t ref_frm_ts_h[AV1_TOTAL_REFS_PER_FRAME];
+	uint32_t ref_frm_ts_l[AV1_TOTAL_REFS_PER_FRAME];
+	int i = 0;
+
+	rtkve_av1_setup_tile_info(av1, &ctrl_frm->tile_info);
+	memcpy(&frm->quantization, &ctrl_frm->quantization,
+	       sizeof(ctrl_frm->quantization));
+	frm->superres_denom = ctrl_frm->superres_denom;
+	rtkve_av1_setup_segment(av1, &ctrl_frm->segmentation);
+
+	memcpy(&frm->loop_filter, &ctrl_frm->loop_filter,
+	       sizeof(ctrl_frm->loop_filter));
+	memcpy(&frm->cdef, &ctrl_frm->cdef, sizeof(ctrl_frm->cdef));
+	memcpy(&frm->skip_mode_frame, &ctrl_frm->skip_mode_frame,
+	       sizeof(ctrl_frm->skip_mode_frame));
+	frm->primary_ref_frame = ctrl_frm->primary_ref_frame;
+	rtkve_av1_setup_loop_restoration(av1, &ctrl_frm->loop_restoration);
+	rtkve_av1_setup_global_motion(av1, &ctrl_frm->global_motion);
+	frm->flags = htonl(ctrl_frm->flags);
+	frm->frame_type = htonl(ctrl_frm->frame_type);
+	frm->order_hint = htonl(ctrl_frm->order_hint);
+	frm->upscaled_width = htonl(ctrl_frm->upscaled_width);
+	frm->interpolation_filter = htonl(ctrl_frm->interpolation_filter);
+	frm->tx_mode = htonl(ctrl_frm->tx_mode);
+	frm->frame_width_minus_1 = htonl(ctrl_frm->frame_width_minus_1);
+	frm->frame_height_minus_1 = htonl(ctrl_frm->frame_height_minus_1);
+	frm->render_width_minus_1 = htons(ctrl_frm->render_width_minus_1);
+	frm->render_height_minus_1 = htons(ctrl_frm->render_height_minus_1);
+	frm->current_frame_id = htonl(ctrl_frm->current_frame_id);
+	dword_endian_convert((uint8_t *)frm->buffer_removal_time,
+			     (uint8_t *)ctrl_frm->buffer_removal_time,
+			     sizeof(ctrl_frm->buffer_removal_time));
+	memcpy(&frm->reserved, &ctrl_frm->reserved, sizeof(ctrl_frm->reserved));
+	dword_endian_convert((uint8_t *)frm->order_hints,
+			     (uint8_t *)ctrl_frm->order_hints,
+			     sizeof(ctrl_frm->order_hints));
+	for (i = 0; i < V4L2_AV1_TOTAL_REFS_PER_FRAME; i++) {
+		ref_frm_ts_h[i] = ctrl_frm->reference_frame_ts[i] >> 32;
+		ref_frm_ts_l[i] = ctrl_frm->reference_frame_ts[i] & 0xFFFFFFFF;
+	}
+
+	dword_endian_convert((uint8_t *)frm->reference_frame_ts_h,
+			     (uint8_t *)ref_frm_ts_h,
+			     sizeof(ctrl_frm->order_hints));
+	dword_endian_convert((uint8_t *)frm->reference_frame_ts_l,
+			     (uint8_t *)ref_frm_ts_l,
+			     sizeof(ctrl_frm->order_hints));
+	memcpy(&frm->ref_frame_idx, &ctrl_frm->ref_frame_idx,
+	       sizeof(ctrl_frm->ref_frame_idx));
+	frm->refresh_frame_flags = ctrl_frm->refresh_frame_flags;
+}
+
+static void rtkve_av1_setup_film_grain(struct AV1_V4L2_CTRL_INFO *av1,
+				       struct stateless_av1_info *ctrl)
+{
+	struct ctrl_av1_film_grain *fg = &av1->av1_film_grain;
+	const struct v4l2_ctrl_av1_film_grain *ctrl_fg = ctrl->film_grain;
+
+	fg->flags = ctrl_fg->flags;
+	fg->cr_mult = ctrl_fg->cr_mult;
+	fg->grain_seed = htons(ctrl_fg->grain_seed);
+	fg->film_grain_params_ref_idx = ctrl_fg->film_grain_params_ref_idx;
+	fg->num_y_points = ctrl_fg->num_y_points;
+	memcpy(&fg->point_y_value, &ctrl_fg->point_y_value,
+	       sizeof(ctrl_fg->point_y_value));
+	memcpy(&fg->point_y_scaling, &ctrl_fg->point_y_scaling,
+	       sizeof(ctrl_fg->point_y_scaling));
+	fg->num_cb_points = ctrl_fg->num_cb_points;
+	memcpy(&fg->point_cb_value, &ctrl_fg->point_cb_value,
+	       sizeof(ctrl_fg->point_cb_value));
+	memcpy(&fg->point_cb_scaling, &ctrl_fg->point_cb_scaling,
+	       sizeof(ctrl_fg->point_cb_scaling));
+	fg->num_cr_points = ctrl_fg->num_cr_points;
+	memcpy(&fg->point_cr_value, &ctrl_fg->point_cr_value,
+	       sizeof(ctrl_fg->point_cr_value));
+	memcpy(&fg->point_cr_scaling, &ctrl_fg->point_cr_scaling,
+	       sizeof(ctrl_fg->point_cr_scaling));
+	fg->grain_scaling_minus_8 = ctrl_fg->grain_scaling_minus_8;
+	fg->ar_coeff_lag = ctrl_fg->ar_coeff_lag;
+	memcpy(&fg->ar_coeffs_y_plus_128, &ctrl_fg->ar_coeffs_y_plus_128,
+	       sizeof(ctrl_fg->ar_coeffs_y_plus_128));
+	memcpy(&fg->ar_coeffs_cb_plus_128, &ctrl_fg->ar_coeffs_cb_plus_128,
+	       sizeof(ctrl_fg->ar_coeffs_cb_plus_128));
+	memcpy(&fg->ar_coeffs_cr_plus_128, &ctrl_fg->ar_coeffs_cr_plus_128,
+	       sizeof(ctrl_fg->ar_coeffs_cr_plus_128));
+	fg->ar_coeff_shift_minus_6 = ctrl_fg->ar_coeff_shift_minus_6;
+	fg->grain_scale_shift = ctrl_fg->grain_scale_shift;
+	fg->cb_mult = ctrl_fg->cb_mult;
+	fg->cb_luma_mult = ctrl_fg->cb_luma_mult;
+	fg->cr_luma_mult = ctrl_fg->cr_luma_mult;
+	fg->cb_offset = htons(ctrl_fg->cb_offset);
+	fg->cr_offset = htons(ctrl_fg->cr_offset);
+	memcpy(&fg->reserved, &ctrl_fg->reserved, sizeof(ctrl_fg->reserved));
+}
+
+static void rtkve_av1_setup_tile_group_entry(struct AV1_V4L2_CTRL_INFO *av1,
+					     struct stateless_av1_info *ctrl)
+{
+	const struct v4l2_ctrl_av1_tile_group_entry *ctrl_tge = ctrl->tge;
+	const struct v4l2_ctrl_av1_frame *ctrl_frm = ctrl->frm;
+	struct ctrl_av1_tile_group_entry *tge = av1->av1_tile_group_entry;
+	int tile_cnt = 0;
+
+	tile_cnt =
+		ctrl_frm->tile_info.tile_cols * ctrl_frm->tile_info.tile_rows;
+
+	if (ctrl->tge_cnt != tile_cnt || tile_cnt > V4L2_AV1_MAX_TILE_COUNT) {
+		pr_err("invalid tge_cnt %d, tile_cnt:%d\n", ctrl->tge_cnt,
+		       tile_cnt);
+		goto exit;
+	}
+
+	dword_endian_convert((uint8_t *)tge, (uint8_t *)ctrl_tge,
+			     tile_cnt *
+				     sizeof(struct ctrl_av1_tile_group_entry));
+
+exit:
+	return;
+}
+
+uint32_t rtkve_get_av1_ctrl_size(void)
+{
+	return sizeof(struct AV1_V4L2_CTRL_INFO);
+}
+
+int rtkve_setup_av1_ctrl_info(struct vpu_instance *inst, void *info,
+			      struct dec_param *param, void *wp)
+{
+	struct stateless_av1_info *ctrl = (struct stateless_av1_info *)info;
+	struct AV1_V4L2_CTRL_INFO *cmd = (struct AV1_V4L2_CTRL_INFO *)wp;
+	struct vpu_handler *hndl = inst->dec_hdl;
+	struct rtkve_ringbuf_t *rb = &hndl->dec.ctrl_info_rb;
+	int ret = 0;
+
+	mutex_lock(&rb->lock);
+
+	rtkve_av1_setup_sequence(cmd, ctrl);
+	rtkve_av1_setup_frame(inst, cmd, ctrl);
+	rtkve_av1_setup_ref_frm(inst, cmd, ctrl);
+	rtkve_av1_setup_film_grain(cmd, ctrl);
+	rtkve_av1_setup_tile_group_entry(cmd, ctrl);
+
+	cmd->y_dma_addr = htonl(param->buf_addr_y);
+	cmd->c_dma_addr = htonl(param->buf_addr_c);
+	cmd->wPtr = htonl(param->wPtr);
+	cmd->PTSH = htonl(param->PTSH);
+	cmd->PTSL = htonl(param->PTSL);
+	cmd->bs_len = htonl(param->bs_len);
+
+	cmd->header.type = htonl(VIDEO_AV1_INBAND_CMD_TYPE_V4L2_CTRL);
+	cmd->header.size = htonl(sizeof(struct AV1_V4L2_CTRL_INFO));
+	dsb(sy);
+
+	rtkve_inband_setup_ctrl(hndl, sizeof(struct AV1_V4L2_CTRL_INFO));
+	mutex_unlock(&rb->lock);
+
+	return ret;
+}
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-av1.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-av1.h
@@ -0,0 +1,24 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+
+#ifndef RTKVE_SL_AV1_H
+#define RTKVE_SL_AV1_H
+
+uint32_t rtkve_get_av1_ctrl_size(void);
+int rtkve_setup_av1_ctrl_info(struct vpu_instance *inst, void *info,
+			      struct dec_param *param, void *wp);
+int rtkve_setup_hevc_ctrl_info(struct vpu_instance *inst, void *info,
+			       struct dec_param *param, void *wp);
+
+#endif
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-ctrl.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-ctrl.h
@@ -0,0 +1,1258 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+
+#ifndef RTKVE_SL_CTRL_H
+#define RTKVE_SL_CTRL_H
+
+#include <linux/types.h>
+
+/* Stateless HEVC controls */
+#define HEVC_DPB_ENTRIES_NUM_MAX 16
+
+/**
+ * struct ctrl_hevc_sps - ITU-T Rec. H.265: Sequence parameter set
+ *
+ * @video_parameter_set_id: specifies the value of the
+ *			vps_video_parameter_set_id of the active VPS
+ * @seq_parameter_set_id: provides an identifier for the SPS for
+ *			  reference by other syntax elements
+ * @pic_width_in_luma_samples:	specifies the width of each decoded picture
+ *				in units of luma samples
+ * @pic_height_in_luma_samples: specifies the height of each decoded picture
+ *				in units of luma samples
+ * @bit_depth_luma_minus8: this value plus 8specifies the bit depth of the
+ *                         samples of the luma array
+ * @bit_depth_chroma_minus8: this value plus 8 specifies the bit depth of the
+ *                           samples of the chroma arrays
+ * @log2_max_pic_order_cnt_lsb_minus4: this value plus 4 specifies the value of
+ *                                     the variable MaxPicOrderCntLsb
+ * @sps_max_dec_pic_buffering_minus1: this value plus 1 specifies the maximum
+ *                                    required size of the decoded picture
+ *                                    buffer for the codec video sequence
+ * @sps_max_num_reorder_pics: indicates the maximum allowed number of pictures
+ * @sps_max_latency_increase_plus1: not equal to 0 is used to compute the
+ *				    value of SpsMaxLatencyPictures array
+ * @log2_min_luma_coding_block_size_minus3: plus 3 specifies the minimum
+ *					    luma coding block size
+ * @log2_diff_max_min_luma_coding_block_size: specifies the difference between
+ *					      the maximum and minimum luma
+ *					      coding block size
+ * @log2_min_luma_transform_block_size_minus2: plus 2 specifies the minimum luma
+ *					       transform block size
+ * @log2_diff_max_min_luma_transform_block_size: specifies the difference between
+ *						 the maximum and minimum luma
+ *						 transform block size
+ * @max_transform_hierarchy_depth_inter: specifies the maximum hierarchy
+ *					 depth for transform units of
+ *					 coding units coded in inter
+ *					 prediction mode
+ * @max_transform_hierarchy_depth_intra: specifies the maximum hierarchy
+ *					 depth for transform units of
+ *					 coding units coded in intra
+ *					 prediction mode
+ * @pcm_sample_bit_depth_luma_minus1: this value plus 1 specifies the number of
+ *                                    bits used to represent each of PCM sample
+ *                                    values of the luma component
+ * @pcm_sample_bit_depth_chroma_minus1: this value plus 1 specifies the number
+ *                                      of bits used to represent each of PCM
+ *                                      sample values of the chroma components
+ * @log2_min_pcm_luma_coding_block_size_minus3: this value plus 3 specifies the
+ *                                              minimum size of coding blocks
+ * @log2_diff_max_min_pcm_luma_coding_block_size: specifies the difference between
+ *						  the maximum and minimum size of
+ *						  coding blocks
+ * @num_short_term_ref_pic_sets: specifies the number of st_ref_pic_set()
+ *				 syntax structures included in the SPS
+ * @num_long_term_ref_pics_sps: specifies the number of candidate long-term
+ *				reference pictures that are specified in the SPS
+ * @chroma_format_idc: specifies the chroma sampling
+ * @sps_max_sub_layers_minus1: this value plus 1 specifies the maximum number
+ *                             of temporal sub-layers
+ * @reserved: padding field. Should be zeroed by applications.
+ * @flags: see V4L2_HEVC_SPS_FLAG_{}
+ */
+struct ctrl_hevc_sps {
+	__u8 video_parameter_set_id;
+	__u8 seq_parameter_set_id;
+	__u16 pic_width_in_luma_samples;
+	__u16 pic_height_in_luma_samples;
+	__u8 bit_depth_luma_minus8;
+	__u8 bit_depth_chroma_minus8;
+	__u8 log2_max_pic_order_cnt_lsb_minus4;
+	__u8 sps_max_dec_pic_buffering_minus1;
+	__u8 sps_max_num_reorder_pics;
+	__u8 sps_max_latency_increase_plus1;
+	__u8 log2_min_luma_coding_block_size_minus3;
+	__u8 log2_diff_max_min_luma_coding_block_size;
+	__u8 log2_min_luma_transform_block_size_minus2;
+	__u8 log2_diff_max_min_luma_transform_block_size;
+	__u8 max_transform_hierarchy_depth_inter;
+	__u8 max_transform_hierarchy_depth_intra;
+	__u8 pcm_sample_bit_depth_luma_minus1;
+	__u8 pcm_sample_bit_depth_chroma_minus1;
+	__u8 log2_min_pcm_luma_coding_block_size_minus3;
+	__u8 log2_diff_max_min_pcm_luma_coding_block_size;
+	__u8 num_short_term_ref_pic_sets;
+	__u8 num_long_term_ref_pics_sps;
+	__u8 chroma_format_idc;
+	__u8 sps_max_sub_layers_minus1;
+
+	__u8 reserved[6];
+	__u64 flags;
+};
+
+/**
+ * struct ctrl_hevc_pps - ITU-T Rec. H.265: Picture parameter set
+ *
+ * @pic_parameter_set_id: identifies the PPS for reference by other
+ *			  syntax elements
+ * @num_extra_slice_header_bits: specifies the number of extra slice header
+ *				 bits that are present in the slice header RBSP
+ *				 for coded pictures referring to the PPS.
+ * @num_ref_idx_l0_default_active_minus1: this value plus 1 specifies the
+ *                                        inferred value of num_ref_idx_l0_active_minus1
+ * @num_ref_idx_l1_default_active_minus1: this value plus 1 specifies the
+ *                                        inferred value of num_ref_idx_l1_active_minus1
+ * @init_qp_minus26: this value plus 26 specifies the initial value of SliceQp Y for
+ *		     each slice referring to the PPS
+ * @diff_cu_qp_delta_depth: specifies the difference between the luma coding
+ *			    tree block size and the minimum luma coding block
+ *			    size of coding units that convey cu_qp_delta_abs
+ *			    and cu_qp_delta_sign_flag
+ * @pps_cb_qp_offset: specify the offsets to the luma quantization parameter Cb
+ * @pps_cr_qp_offset: specify the offsets to the luma quantization parameter Cr
+ * @num_tile_columns_minus1: this value plus 1 specifies the number of tile columns
+ *			     partitioning the picture
+ * @num_tile_rows_minus1: this value plus 1 specifies the number of tile rows partitioning
+ *			  the picture
+ * @column_width_minus1: this value plus 1 specifies the width of the each tile column in
+ *			 units of coding tree blocks
+ * @row_height_minus1: this value plus 1 specifies the height of the each tile row in
+ *		       units of coding tree blocks
+ * @pps_beta_offset_div2: specify the default deblocking parameter offsets for
+ *			  beta divided by 2
+ * @pps_tc_offset_div2: specify the default deblocking parameter offsets for tC
+ *			divided by 2
+ * @log2_parallel_merge_level_minus2: this value plus 2 specifies the value of
+ *                                    the variable Log2ParMrgLevel
+ * @reserved: padding field. Should be zeroed by applications.
+ * @flags: see V4L2_HEVC_PPS_FLAG_{}
+ */
+struct ctrl_hevc_pps {
+	__u8 pic_parameter_set_id;
+	__u8 num_extra_slice_header_bits;
+	__u8 num_ref_idx_l0_default_active_minus1;
+	__u8 num_ref_idx_l1_default_active_minus1;
+	__s8 init_qp_minus26;
+	__u8 diff_cu_qp_delta_depth;
+	__s8 pps_cb_qp_offset;
+	__s8 pps_cr_qp_offset;
+	__u8 num_tile_columns_minus1;
+	__u8 num_tile_rows_minus1;
+	__u8 column_width_minus1[20];
+	__u8 row_height_minus1[22];
+	__s8 pps_beta_offset_div2;
+	__s8 pps_tc_offset_div2;
+	__u8 log2_parallel_merge_level_minus2;
+	__u8 reserved;
+	__u64 flags;
+};
+
+/**
+ * struct hevc_dpb_entry - HEVC decoded picture buffer entry
+ *
+ * @timestamp: timestamp of the V4L2 capture buffer to use as reference.
+ * @flags: long term flag for the reference frame
+ * @field_pic: whether the reference is a field picture or a frame.
+ * @reserved: padding field. Should be zeroed by applications.
+ * @pic_order_cnt_val: the picture order count of the current picture.
+ */
+struct hevc_dpb_entry {
+	__u64 timestamp;
+	__u8 flags;
+	__u8 field_pic;
+	__u16 reserved;
+	__s32 pic_order_cnt_val;
+};
+
+/**
+ * struct hevc_pred_weight_table - HEVC weighted prediction parameters
+ *
+ * @delta_luma_weight_l0: the difference of the weighting factor applied
+ *			  to the luma prediction value for list 0
+ * @luma_offset_l0: the additive offset applied to the luma prediction value
+ *		    for list 0
+ * @delta_chroma_weight_l0: the difference of the weighting factor applied
+ *			    to the chroma prediction values for list 0
+ * @chroma_offset_l0: the difference of the additive offset applied to
+ *		      the chroma prediction values for list 0
+ * @delta_luma_weight_l1: the difference of the weighting factor applied
+ *			  to the luma prediction value for list 1
+ * @luma_offset_l1: the additive offset applied to the luma prediction value
+ *		    for list 1
+ * @delta_chroma_weight_l1: the difference of the weighting factor applied
+ *			    to the chroma prediction values for list 1
+ * @chroma_offset_l1: the difference of the additive offset applied to
+ *		      the chroma prediction values for list 1
+ * @luma_log2_weight_denom: the base 2 logarithm of the denominator for
+ *			    all luma weighting factors
+ * @delta_chroma_log2_weight_denom: the difference of the base 2 logarithm
+ *				    of the denominator for all chroma
+ *				    weighting factors
+ */
+struct hevc_pred_weight_table {
+	__s8 delta_luma_weight_l0[HEVC_DPB_ENTRIES_NUM_MAX];
+	__s8 luma_offset_l0[HEVC_DPB_ENTRIES_NUM_MAX];
+	__s8 delta_chroma_weight_l0[HEVC_DPB_ENTRIES_NUM_MAX][2];
+	__s8 chroma_offset_l0[HEVC_DPB_ENTRIES_NUM_MAX][2];
+
+	__s8 delta_luma_weight_l1[HEVC_DPB_ENTRIES_NUM_MAX];
+	__s8 luma_offset_l1[HEVC_DPB_ENTRIES_NUM_MAX];
+	__s8 delta_chroma_weight_l1[HEVC_DPB_ENTRIES_NUM_MAX][2];
+	__s8 chroma_offset_l1[HEVC_DPB_ENTRIES_NUM_MAX][2];
+
+	__u8 luma_log2_weight_denom;
+	__s8 delta_chroma_log2_weight_denom;
+};
+
+/**
+ * struct ctrl_hevc_slice_params - HEVC slice parameters
+ *
+ * This control is a dynamically sized 1-dimensional array,
+ * V4L2_CTRL_FLAG_DYNAMIC_ARRAY flag must be set when using it.
+ *
+ * @bit_size: size (in bits) of the current slice data
+ * @data_byte_offset: offset (in bytes) to the video data in the current slice data
+ * @num_entry_point_offsets: specifies the number of entry point offset syntax
+ *			     elements in the slice header.
+ * @nal_unit_type: specifies the coding type of the slice (B, P or I)
+ * @nuh_temporal_id_plus1: minus 1 specifies a temporal identifier for the NAL unit
+ * @slice_type: see V4L2_HEVC_SLICE_TYPE_{}
+ * @colour_plane_id: specifies the colour plane associated with the current slice
+ * @slice_pic_order_cnt: specifies the picture order count
+ * @num_ref_idx_l0_active_minus1: this value plus 1 specifies the maximum
+ *                                reference index for reference picture list 0
+ *                                that may be used to decode the slice
+ * @num_ref_idx_l1_active_minus1: this value plus 1 specifies the maximum
+ *                                reference index for reference picture list 1
+ *                                that may be used to decode the slice
+ * @collocated_ref_idx: specifies the reference index of the collocated picture used
+ *			for temporal motion vector prediction
+ * @five_minus_max_num_merge_cand: specifies the maximum number of merging
+ *				   motion vector prediction candidates supported in
+ *				   the slice subtracted from 5
+ * @slice_qp_delta: specifies the initial value of QpY to be used for the coding
+ *		    blocks in the slice
+ * @slice_cb_qp_offset: specifies a difference to be added to the value of pps_cb_qp_offset
+ * @slice_cr_qp_offset: specifies a difference to be added to the value of pps_cr_qp_offset
+ * @slice_act_y_qp_offset: screen content extension parameters
+ * @slice_act_cb_qp_offset: screen content extension parameters
+ * @slice_act_cr_qp_offset: screen content extension parameters
+ * @slice_beta_offset_div2: specify the deblocking parameter offsets for beta divided by 2
+ * @slice_tc_offset_div2: specify the deblocking parameter offsets for tC divided by 2
+ * @pic_struct: indicates whether a picture should be displayed as a frame or as one or
+ *		more fields
+ * @reserved0: padding field. Should be zeroed by applications.
+ * @slice_segment_addr: specifies the address of the first coding tree block in
+ *			the slice segment
+ * @ref_idx_l0: the list of L0 reference elements as indices in the DPB
+ * @ref_idx_l1: the list of L1 reference elements as indices in the DPB
+ * @short_term_ref_pic_set_size: specifies the size of short-term reference
+ *				 pictures set included in the SPS
+ * @long_term_ref_pic_set_size: specifies the size of long-term reference
+ *				pictures set include in the SPS
+ * @pred_weight_table: the prediction weight coefficients for inter-picture
+ *		       prediction
+ * @reserved1: padding field. Should be zeroed by applications.
+ * @flags: see V4L2_HEVC_SLICE_PARAMS_FLAG_{}
+ */
+struct ctrl_hevc_slice_params {
+	__u32 bit_size;
+	__u32 data_byte_offset;
+	__u32 num_entry_point_offsets;
+
+	/* ISO/IEC 23008-2, ITU-T Rec. H.265: NAL unit header */
+	__u8 nal_unit_type;
+	__u8 nuh_temporal_id_plus1;
+
+	/* ISO/IEC 23008-2, ITU-T Rec. H.265: General slice segment header */
+	__u8 slice_type;
+	__u8 colour_plane_id;
+	__s32 slice_pic_order_cnt;
+	__u8 num_ref_idx_l0_active_minus1;
+	__u8 num_ref_idx_l1_active_minus1;
+	__u8 collocated_ref_idx;
+	__u8 five_minus_max_num_merge_cand;
+	__s8 slice_qp_delta;
+	__s8 slice_cb_qp_offset;
+	__s8 slice_cr_qp_offset;
+	__s8 slice_act_y_qp_offset;
+	__s8 slice_act_cb_qp_offset;
+	__s8 slice_act_cr_qp_offset;
+	__s8 slice_beta_offset_div2;
+	__s8 slice_tc_offset_div2;
+
+	/* ISO/IEC 23008-2, ITU-T Rec. H.265: Picture timing SEI message */
+	__u8 pic_struct;
+
+	__u8 reserved0[3];
+	/* ISO/IEC 23008-2, ITU-T Rec. H.265: General slice segment header */
+	__u32 slice_segment_addr;
+	__u8 ref_idx_l0[HEVC_DPB_ENTRIES_NUM_MAX];
+	__u8 ref_idx_l1[HEVC_DPB_ENTRIES_NUM_MAX];
+	__u16 short_term_ref_pic_set_size;
+	__u16 long_term_ref_pic_set_size;
+
+	/* ISO/IEC 23008-2, ITU-T Rec. H.265: Weighted prediction parameter */
+	struct hevc_pred_weight_table pred_weight_table;
+
+	__u8 reserved1[2];
+	__u64 flags;
+};
+
+/**
+ * struct ctrl_hevc_decode_params - HEVC decode parameters
+ *
+ * @pic_order_cnt_val: picture order count
+ * @short_term_ref_pic_set_size: specifies the size of short-term reference
+ *				 pictures set included in the SPS of the first slice
+ * @long_term_ref_pic_set_size: specifies the size of long-term reference
+ *				pictures set include in the SPS of the first slice
+ * @num_active_dpb_entries: the number of entries in dpb
+ * @num_poc_st_curr_before: the number of reference pictures in the short-term
+ *			    set that come before the current frame
+ * @num_poc_st_curr_after: the number of reference pictures in the short-term
+ *			   set that come after the current frame
+ * @num_poc_lt_curr: the number of reference pictures in the long-term set
+ * @poc_st_curr_before: provides the index of the short term before references
+ *			in DPB array
+ * @poc_st_curr_after: provides the index of the short term after references
+ *		       in DPB array
+ * @poc_lt_curr: provides the index of the long term references in DPB array
+ * @num_delta_pocs_of_ref_rps_idx: same as the derived value NumDeltaPocs[RefRpsIdx],
+ *				   can be used to parse the RPS data in slice headers
+ *				   instead of skipping it with @short_term_ref_pic_set_size.
+ * @reserved: padding field. Should be zeroed by applications.
+ * @dpb: the decoded picture buffer, for meta-data about reference frames
+ * @flags: see V4L2_HEVC_DECODE_PARAM_FLAG_{}
+ */
+struct ctrl_hevc_decode_params {
+	__s32 pic_order_cnt_val;
+	__u16 short_term_ref_pic_set_size;
+	__u16 long_term_ref_pic_set_size;
+	__u8 num_active_dpb_entries;
+	__u8 num_poc_st_curr_before;
+	__u8 num_poc_st_curr_after;
+	__u8 num_poc_lt_curr;
+	__u8 poc_st_curr_before[HEVC_DPB_ENTRIES_NUM_MAX];
+	__u8 poc_st_curr_after[HEVC_DPB_ENTRIES_NUM_MAX];
+	__u8 poc_lt_curr[HEVC_DPB_ENTRIES_NUM_MAX];
+	__u8 num_delta_pocs_of_ref_rps_idx;
+	__u8 reserved[3];
+	struct hevc_dpb_entry dpb[HEVC_DPB_ENTRIES_NUM_MAX];
+	__u64 flags;
+};
+
+/**
+ * struct ctrl_hevc_scaling_matrix - HEVC scaling lists parameters
+ *
+ * @scaling_list_4x4: scaling list is used for the scaling process for
+ *		      transform coefficients. The values on each scaling
+ *		      list are expected in raster scan order
+ * @scaling_list_8x8: scaling list is used for the scaling process for
+ *		      transform coefficients. The values on each scaling
+ *		      list are expected in raster scan order
+ * @scaling_list_16x16:	scaling list is used for the scaling process for
+ *			transform coefficients. The values on each scaling
+ *			list are expected in raster scan order
+ * @scaling_list_32x32:	scaling list is used for the scaling process for
+ *			transform coefficients. The values on each scaling
+ *			list are expected in raster scan order
+ * @scaling_list_dc_coef_16x16:	scaling list is used for the scaling process
+ *				for transform coefficients. The values on each
+ *				scaling list are expected in raster scan order.
+ * @scaling_list_dc_coef_32x32:	scaling list is used for the scaling process
+ *				for transform coefficients. The values on each
+ *				scaling list are expected in raster scan order.
+ */
+struct ctrl_hevc_scaling_matrix {
+	__u8 scaling_list_4x4[6][16];
+	__u8 scaling_list_8x8[6][64];
+	__u8 scaling_list_16x16[6][64];
+	__u8 scaling_list_32x32[2][64];
+	__u8 scaling_list_dc_coef_16x16[6];
+	__u8 scaling_list_dc_coef_32x32[2];
+};
+
+/* Stateless VP9 controls */
+/**
+ * struct vp9_loop_filter - VP9 loop filter parameters
+ *
+ * @ref_deltas: contains the adjustment needed for the filter level based on the
+ * chosen reference frame. If this syntax element is not present in the bitstream,
+ * users should pass its last value.
+ * @mode_deltas: contains the adjustment needed for the filter level based on the
+ * chosen mode.	If this syntax element is not present in the bitstream, users should
+ * pass its last value.
+ * @level: indicates the loop filter strength.
+ * @sharpness: indicates the sharpness level.
+ * @flags: combination of V4L2_VP9_LOOP_FILTER_FLAG_{} flags.
+ * @reserved: padding field. Should be zeroed by applications.
+ *
+ * This structure contains all loop filter related parameters. See sections
+ * '7.2.8 Loop filter semantics' of the VP9 specification for more details.
+ */
+struct vp9_loop_filter {
+	__s8 ref_deltas[4];
+	__s8 mode_deltas[2];
+	__u8 level;
+	__u8 sharpness;
+	__u8 flags;
+	__u8 reserved[7];
+};
+
+/**
+ * struct vp9_quantization - VP9 quantization parameters
+ *
+ * @base_q_idx: indicates the base frame qindex.
+ * @delta_q_y_dc: indicates the Y DC quantizer relative to base_q_idx.
+ * @delta_q_uv_dc: indicates the UV DC quantizer relative to base_q_idx.
+ * @delta_q_uv_ac: indicates the UV AC quantizer relative to base_q_idx.
+ * @reserved: padding field. Should be zeroed by applications.
+ *
+ * Encodes the quantization parameters. See section '7.2.9 Quantization params
+ * syntax' of the VP9 specification for more details.
+ */
+struct vp9_quantization {
+	__u8 base_q_idx;
+	__s8 delta_q_y_dc;
+	__s8 delta_q_uv_dc;
+	__s8 delta_q_uv_ac;
+	__u8 reserved[4];
+};
+
+/**
+ * struct vp9_segmentation - VP9 segmentation parameters
+ *
+ * @feature_data: data attached to each feature. Data entry is only valid if
+ * the feature is enabled. The array shall be indexed with segment number as
+ * the first dimension (0..7) and one of V4L2_VP9_SEG_{} as the second dimension.
+ * @feature_enabled: bitmask defining which features are enabled in each segment.
+ * The value for each segment is a combination of V4L2_VP9_SEGMENT_FEATURE_ENABLED(id)
+ * values where id is one of V4L2_VP9_SEG_LVL_{}.
+ * @tree_probs: specifies the probability values to be used when decoding a
+ * Segment-ID. See '5.15. Segmentation map' section of the VP9 specification
+ * for more details.
+ * @pred_probs: specifies the probability values to be used when decoding a
+ * Predicted-Segment-ID. See '6.4.14. Get segment id syntax' section of :ref:`vp9`
+ * for more details.
+ * @flags: combination of V4L2_VP9_SEGMENTATION_FLAG_{} flags.
+ * @reserved: padding field. Should be zeroed by applications.
+ *
+ * Encodes the quantization parameters. See section '7.2.10 Segmentation params syntax' of
+ * the VP9 specification for more details.
+ */
+struct vp9_segmentation {
+	__s16 feature_data[8][4];
+	__u8 feature_enabled[8];
+	__u8 tree_probs[7];
+	__u8 pred_probs[3];
+	__u8 flags;
+	__u8 reserved[5];
+};
+
+/**
+ * struct ctrl_vp9_frame - VP9 frame decoding control
+ *
+ * @lf: loop filter parameters. See &v4l2_vp9_loop_filter for more details.
+ * @quant: quantization parameters. See &v4l2_vp9_quantization for more details.
+ * @seg: segmentation parameters. See &v4l2_vp9_segmentation for more details.
+ * @flags: combination of V4L2_VP9_FRAME_FLAG_{} flags.
+ * @compressed_header_size: compressed header size in bytes.
+ * @uncompressed_header_size: uncompressed header size in bytes.
+ * @frame_width_minus_1: add 1 to it and you'll get the frame width expressed in pixels.
+ * @frame_height_minus_1: add 1 to it and you'll get the frame height expressed in pixels.
+ * @render_width_minus_1: add 1 to it and you'll get the expected render width expressed in
+ * pixels. This is not used during the decoding process but might be used by HW scalers
+ * to prepare a frame that's ready for scanout.
+ * @render_height_minus_1: add 1 to it and you'll get the expected render height expressed in
+ * pixels. This is not used during the decoding process but might be used by HW scalers
+ * to prepare a frame that's ready for scanout.
+ * @last_frame_ts: "last" reference buffer timestamp.
+ * The timestamp refers to the timestamp field in struct v4l2_buffer.
+ * Use v4l2_timeval_to_ns() to convert the struct timeval to a __u64.
+ * @golden_frame_ts: "golden" reference buffer timestamp.
+ * The timestamp refers to the timestamp field in struct v4l2_buffer.
+ * Use v4l2_timeval_to_ns() to convert the struct timeval to a __u64.
+ * @alt_frame_ts: "alt" reference buffer timestamp.
+ * The timestamp refers to the timestamp field in struct v4l2_buffer.
+ * Use v4l2_timeval_to_ns() to convert the struct timeval to a __u64.
+ * @ref_frame_sign_bias: a bitfield specifying whether the sign bias is set for a given
+ * reference frame. Either of V4L2_VP9_SIGN_BIAS_{}.
+ * @reset_frame_context: specifies whether the frame context should be reset to default values.
+ * Either of V4L2_VP9_RESET_FRAME_CTX_{}.
+ * @frame_context_idx: frame context that should be used/updated.
+ * @profile: VP9 profile. Can be 0, 1, 2 or 3.
+ * @bit_depth: bits per components. Can be 8, 10 or 12. Note that not all profiles support
+ * 10 and/or 12 bits depths.
+ * @interpolation_filter: specifies the filter selection used for performing inter prediction.
+ * Set to one of V4L2_VP9_INTERP_FILTER_{}.
+ * @tile_cols_log2: specifies the base 2 logarithm of the width of each tile (where the width
+ * is measured in units of 8x8 blocks). Shall be less than or equal to 6.
+ * @tile_rows_log2: specifies the base 2 logarithm of the height of each tile (where the height
+ * is measured in units of 8x8 blocks).
+ * @reference_mode: specifies the type of inter prediction to be used.
+ * Set to one of V4L2_VP9_REFERENCE_MODE_{}.
+ * @reserved: padding field. Should be zeroed by applications.
+ */
+struct ctrl_vp9_frame {
+	struct vp9_loop_filter lf;
+	struct vp9_quantization quant;
+	struct vp9_segmentation seg;
+	__u32 flags;
+	__u16 compressed_header_size;
+	__u16 uncompressed_header_size;
+	__u16 frame_width_minus_1;
+	__u16 frame_height_minus_1;
+	__u16 render_width_minus_1;
+	__u16 render_height_minus_1;
+	__u64 last_frame_ts;
+	__u64 golden_frame_ts;
+	__u64 alt_frame_ts;
+	__u8 ref_frame_sign_bias;
+	__u8 reset_frame_context;
+	__u8 frame_context_idx;
+	__u8 profile;
+	__u8 bit_depth;
+	__u8 interpolation_filter;
+	__u8 tile_cols_log2;
+	__u8 tile_rows_log2;
+	__u8 reference_mode;
+	__u8 reserved[7];
+};
+
+/**
+ * struct vp9_mv_probs - VP9 Motion vector probability updates
+ * @joint: motion vector joint probability updates.
+ * @sign: motion vector sign probability updates.
+ * @classes: motion vector class probability updates.
+ * @class0_bit: motion vector class0 bit probability updates.
+ * @bits: motion vector bits probability updates.
+ * @class0_fr: motion vector class0 fractional bit probability updates.
+ * @fr: motion vector fractional bit probability updates.
+ * @class0_hp: motion vector class0 high precision fractional bit probability updates.
+ * @hp: motion vector high precision fractional bit probability updates.
+ *
+ * This structure contains new values of motion vector probabilities.
+ * A value of zero in an array element means there is no update of the relevant probability.
+ * See `struct v4l2_vp9_prob_updates` for details.
+ */
+struct vp9_mv_probs {
+	__u8 joint[3];
+	__u8 sign[2];
+	__u8 classes[2][10];
+	__u8 class0_bit[2];
+	__u8 bits[2][10];
+	__u8 class0_fr[2][2][3];
+	__u8 fr[2][3];
+	__u8 class0_hp[2];
+	__u8 hp[2];
+};
+
+/**
+ * struct ctrl_vp9_compressed_hdr - VP9 probability updates control
+ * @tx_mode: specifies the TX mode. Set to one of V4L2_VP9_TX_MODE_{}.
+ * @tx8: TX 8x8 probability updates.
+ * @tx16: TX 16x16 probability updates.
+ * @tx32: TX 32x32 probability updates.
+ * @coef: coefficient probability updates.
+ * @skip: skip probability updates.
+ * @inter_mode: inter mode probability updates.
+ * @interp_filter: interpolation filter probability updates.
+ * @is_inter: is inter-block probability updates.
+ * @comp_mode: compound prediction mode probability updates.
+ * @single_ref: single ref probability updates.
+ * @comp_ref: compound ref probability updates.
+ * @y_mode: Y prediction mode probability updates.
+ * @uv_mode: UV prediction mode probability updates.
+ * @partition: partition probability updates.
+ * @mv: motion vector probability updates.
+ *
+ * This structure holds the probabilities update as parsed in the compressed
+ * header (Spec 6.3). These values represent the value of probability update after
+ * being translated with inv_map_table[] (see 6.3.5). A value of zero in an array element
+ * means that there is no update of the relevant probability.
+ *
+ * This control is optional and needs to be used when dealing with the hardware which is
+ * not capable of parsing the compressed header itself. Only drivers which need it will
+ * implement it.
+ */
+struct ctrl_vp9_compressed_hdr {
+	__u8 tx_mode;
+	__u8 tx8[2][1];
+	__u8 tx16[2][2];
+	__u8 tx32[2][3];
+	__u8 coef[4][2][2][6][6][3];
+	__u8 skip[3];
+	__u8 inter_mode[7][3];
+	__u8 interp_filter[4][2];
+	__u8 is_inter[4];
+	__u8 comp_mode[5];
+	__u8 single_ref[5][2];
+	__u8 comp_ref[5];
+	__u8 y_mode[4][9];
+	__u8 uv_mode[10][9];
+	__u8 partition[16][3];
+
+	struct vp9_mv_probs mv;
+};
+
+/* Stateless AV1 controls */
+
+#define AV1_TOTAL_REFS_PER_FRAME 8
+#define AV1_CDEF_MAX 8
+#define AV1_NUM_PLANES_MAX 3 /* 1 if monochrome, 3 otherwise */
+#define AV1_MAX_SEGMENTS 8
+#define AV1_MAX_OPERATING_POINTS (1 << 5) /* 5 bits to encode */
+#define AV1_REFS_PER_FRAME 7
+#define AV1_MAX_NUM_Y_POINTS (1 << 4) /* 4 bits to encode */
+#define AV1_MAX_NUM_CB_POINTS (1 << 4) /* 4 bits to encode */
+#define AV1_MAX_NUM_CR_POINTS (1 << 4) /* 4 bits to encode */
+#define AV1_AR_COEFFS_SIZE 25 /* (2 * 3 * (3 + 1)) + 1 */
+#define AV1_MAX_NUM_PLANES 3
+#define AV1_MAX_TILE_COLS 64
+#define AV1_MAX_TILE_ROWS 64
+#define AV1_MAX_TILE_COUNT 512
+
+#define AV1_SEQUENCE_FLAG_STILL_PICTURE 0x00000001
+#define AV1_SEQUENCE_FLAG_USE_128X128_SUPERBLOCK 0x00000002
+#define AV1_SEQUENCE_FLAG_ENABLE_FILTER_INTRA 0x00000004
+#define AV1_SEQUENCE_FLAG_ENABLE_INTRA_EDGE_FILTER 0x00000008
+#define AV1_SEQUENCE_FLAG_ENABLE_INTERINTRA_COMPOUND 0x00000010
+#define AV1_SEQUENCE_FLAG_ENABLE_MASKED_COMPOUND 0x00000020
+#define AV1_SEQUENCE_FLAG_ENABLE_WARPED_MOTION 0x00000040
+#define AV1_SEQUENCE_FLAG_ENABLE_DUAL_FILTER 0x00000080
+#define AV1_SEQUENCE_FLAG_ENABLE_ORDER_HINT 0x00000100
+#define AV1_SEQUENCE_FLAG_ENABLE_JNT_COMP 0x00000200
+#define AV1_SEQUENCE_FLAG_ENABLE_REF_FRAME_MVS 0x00000400
+#define AV1_SEQUENCE_FLAG_ENABLE_SUPERRES 0x00000800
+#define AV1_SEQUENCE_FLAG_ENABLE_CDEF 0x00001000
+#define AV1_SEQUENCE_FLAG_ENABLE_RESTORATION 0x00002000
+#define AV1_SEQUENCE_FLAG_MONO_CHROME 0x00004000
+#define AV1_SEQUENCE_FLAG_COLOR_RANGE 0x00008000
+#define AV1_SEQUENCE_FLAG_SUBSAMPLING_X 0x00010000
+#define AV1_SEQUENCE_FLAG_SUBSAMPLING_Y 0x00020000
+#define AV1_SEQUENCE_FLAG_FILM_GRAIN_PARAMS_PRESENT 0x00040000
+#define AV1_SEQUENCE_FLAG_SEPARATE_UV_DELTA_Q 0x00080000
+
+/**
+ * struct ctrl_av1_sequence - AV1 Sequence
+ *
+ * Represents an AV1 Sequence OBU. See section 5.5 "Sequence header OBU syntax"
+ * for more details.
+ *
+ * @flags: See AV1_SEQUENCE_FLAG_{}.
+ * @seq_profile: specifies the features that can be used in the coded video
+ * sequence.
+ * @order_hint_bits: specifies the number of bits used for the order_hint field
+ * at each frame.
+ * @bit_depth: the bitdepth to use for the sequence as described in section
+ * 5.5.2 "Color config syntax".
+ * @reserved: padding field. Should be zeroed by applications.
+ * @max_frame_width_minus_1: specifies the maximum frame width minus 1 for the
+ * frames represented by this sequence header.
+ * @max_frame_height_minus_1: specifies the maximum frame height minus 1 for the
+ * frames represented by this sequence header.
+ */
+struct ctrl_av1_sequence {
+	uint32_t flags;
+	uint8_t seq_profile;
+	uint8_t order_hint_bits;
+	uint8_t bit_depth;
+	uint8_t reserved;
+	uint16_t max_frame_width_minus_1;
+	uint16_t max_frame_height_minus_1;
+};
+
+/**
+ * struct ctrl_av1_tile_group_entry - AV1 Tile Group entry
+ *
+ * Represents a single AV1 tile inside an AV1 Tile Group. Note that MiRowStart,
+ * MiRowEnd, MiColStart and MiColEnd can be retrieved from struct
+ * av1_tile_info in struct ctrl_av1_frame using tile_row and
+ * tile_col. See section 6.10.1 "General tile group OBU semantics" for more
+ * details.
+ *
+ * @tile_offset: offset from the OBU data, i.e. where the coded tile data
+ * actually starts.
+ * @tile_size: specifies the size in bytes of the coded tile. Equivalent to
+ * "TileSize" in the AV1 Specification.
+ * @tile_row: specifies the row of the current tile. Equivalent to "TileRow" in
+ * the AV1 Specification.
+ * @tile_col: specifies the col of the current tile. Equivalent to "TileCol" in
+ * the AV1 Specification.
+ */
+struct ctrl_av1_tile_group_entry {
+	uint32_t tile_offset;
+	uint32_t tile_size;
+	uint32_t tile_row;
+	uint32_t tile_col;
+};
+
+/**
+ * enum av1_warp_model - AV1 Warp Model as described in section 3
+ * "Symbols and abbreviated terms" of the AV1 Specification.
+ *
+ * @AV1_WARP_MODEL_IDENTITY: Warp model is just an identity transform.
+ * @AV1_WARP_MODEL_TRANSLATION: Warp model is a pure translation.
+ * @AV1_WARP_MODEL_ROTZOOM: Warp model is a rotation + symmetric zoom +
+ * translation.
+ * @AV1_WARP_MODEL_AFFINE: Warp model is a general affine transform.
+ */
+enum av1_warp_model {
+	AV1_WARP_MODEL_IDENTITY = 0,
+	AV1_WARP_MODEL_TRANSLATION = 1,
+	AV1_WARP_MODEL_ROTZOOM = 2,
+	AV1_WARP_MODEL_AFFINE = 3,
+};
+
+/**
+ * enum av1_reference_frame - AV1 reference frames
+ *
+ * @AV1_REF_INTRA_FRAME: Intra Frame Reference
+ * @AV1_REF_LAST_FRAME: Last Reference Frame
+ * @AV1_REF_LAST2_FRAME: Last2 Reference Frame
+ * @AV1_REF_LAST3_FRAME: Last3 Reference Frame
+ * @AV1_REF_GOLDEN_FRAME: Golden Reference Frame
+ * @AV1_REF_BWDREF_FRAME: BWD Reference Frame
+ * @AV1_REF_ALTREF2_FRAME: Alternative2 Reference Frame
+ * @AV1_REF_ALTREF_FRAME: Alternative Reference Frame
+ */
+enum av1_reference_frame {
+	AV1_REF_INTRA_FRAME = 0,
+	AV1_REF_LAST_FRAME = 1,
+	AV1_REF_LAST2_FRAME = 2,
+	AV1_REF_LAST3_FRAME = 3,
+	AV1_REF_GOLDEN_FRAME = 4,
+	AV1_REF_BWDREF_FRAME = 5,
+	AV1_REF_ALTREF2_FRAME = 6,
+	AV1_REF_ALTREF_FRAME = 7,
+};
+
+#define AV1_GLOBAL_MOTION_IS_INVALID(ref) (1 << (ref))
+
+#define AV1_GLOBAL_MOTION_FLAG_IS_GLOBAL 0x1
+#define AV1_GLOBAL_MOTION_FLAG_IS_ROT_ZOOM 0x2
+#define AV1_GLOBAL_MOTION_FLAG_IS_TRANSLATION 0x4
+/**
+ * struct av1_global_motion - AV1 Global Motion parameters as described in
+ * section 6.8.17 "Global motion params semantics" of the AV1 specification.
+ *
+ * @flags: A bitfield containing the flags per reference frame. See
+ * AV1_GLOBAL_MOTION_FLAG_{}
+ * @type: The type of global motion transform used.
+ * @params: this field has the same meaning as "gm_params" in the AV1
+ * specification.
+ * @invalid: bitfield indicating whether the global motion params are invalid
+ * for a given reference frame. See section 7.11.3.6 Setup shear process and
+ * the variable "warpValid". Use AV1_GLOBAL_MOTION_IS_INVALID(ref) to
+ * create a suitable mask.
+ * @reserved: padding field. Should be zeroed by applications.
+ */
+
+struct av1_global_motion {
+	uint8_t flags[AV1_TOTAL_REFS_PER_FRAME];
+	enum av1_warp_model type[AV1_TOTAL_REFS_PER_FRAME];
+	int32_t params[AV1_TOTAL_REFS_PER_FRAME][6];
+	uint8_t invalid;
+	uint8_t reserved[3];
+};
+
+/**
+ * enum av1_frame_restoration_type - AV1 Frame Restoration Type
+ * @AV1_FRAME_RESTORE_NONE: no filtering is applied.
+ * @AV1_FRAME_RESTORE_WIENER: Wiener filter process is invoked.
+ * @AV1_FRAME_RESTORE_SGRPROJ: self guided filter process is invoked.
+ * @AV1_FRAME_RESTORE_SWITCHABLE: restoration filter is swichtable.
+ */
+enum av1_frame_restoration_type {
+	AV1_FRAME_RESTORE_NONE = 0,
+	AV1_FRAME_RESTORE_WIENER = 1,
+	AV1_FRAME_RESTORE_SGRPROJ = 2,
+	AV1_FRAME_RESTORE_SWITCHABLE = 3,
+};
+
+#define AV1_LOOP_RESTORATION_FLAG_USES_LR 0x1
+#define AV1_LOOP_RESTORATION_FLAG_USES_CHROMA_LR 0x2
+
+/**
+ * struct av1_loop_restoration - AV1 Loop Restauration as described in
+ * section 6.10.15 "Loop restoration params semantics" of the AV1 specification.
+ *
+ * @flags: See AV1_LOOP_RESTORATION_FLAG_{}.
+ * @lr_unit_shift: specifies if the luma restoration size should be halved.
+ * @lr_uv_shift: specifies if the chroma size should be half the luma size.
+ * @reserved: padding field. Should be zeroed by applications.
+ * @frame_restoration_type: specifies the type of restoration used for each
+ * plane. See enum av1_frame_restoration_type.
+ * @loop_restoration_size: specifies the size of loop restoration units in units
+ * of samples in the current plane.
+ */
+struct av1_loop_restoration {
+	uint8_t flags;
+	uint8_t lr_unit_shift;
+	uint8_t lr_uv_shift;
+	uint8_t reserved;
+	enum av1_frame_restoration_type
+		frame_restoration_type[AV1_NUM_PLANES_MAX];
+	uint32_t loop_restoration_size[AV1_MAX_NUM_PLANES];
+};
+
+/**
+ * struct av1_cdef - AV1 CDEF params semantics as described in section
+ * 6.10.14 "CDEF params semantics" of the AV1 specification
+ *
+ * @damping_minus_3: controls the amount of damping in the deringing filter.
+ * @bits: specifies the number of bits needed to specify which CDEF filter to
+ * apply.
+ * @y_pri_strength: specifies the strength of the primary filter.
+ * @y_sec_strength: specifies the strength of the secondary filter.
+ * @uv_pri_strength: specifies the strength of the primary filter.
+ * @uv_sec_strength: specifies the strength of the secondary filter.
+ */
+struct av1_cdef {
+	uint8_t damping_minus_3;
+	uint8_t bits;
+	uint8_t y_pri_strength[AV1_CDEF_MAX];
+	uint8_t y_sec_strength[AV1_CDEF_MAX];
+	uint8_t uv_pri_strength[AV1_CDEF_MAX];
+	uint8_t uv_sec_strength[AV1_CDEF_MAX];
+};
+
+#define AV1_SEGMENTATION_FLAG_ENABLED 0x1
+#define AV1_SEGMENTATION_FLAG_UPDATE_MAP 0x2
+#define AV1_SEGMENTATION_FLAG_TEMPORAL_UPDATE 0x4
+#define AV1_SEGMENTATION_FLAG_UPDATE_DATA 0x8
+#define AV1_SEGMENTATION_FLAG_SEG_ID_PRE_SKIP 0x10
+
+/**
+ * enum av1_segment_feature - AV1 segment features as described in section
+ * 3 "Symbols and abbreviated terms" of the AV1 specification.
+ *
+ * @AV1_SEG_LVL_ALT_Q: Index for quantizer segment feature.
+ * @AV1_SEG_LVL_ALT_LF_Y_V: Index for vertical luma loop filter segment
+ * feature.
+ * @AV1_SEG_LVL_REF_FRAME: Index for reference frame segment feature.
+ * @AV1_SEG_LVL_REF_SKIP: Index for skip segment feature.
+ * @AV1_SEG_LVL_REF_GLOBALMV: Index for global mv feature.
+ * @AV1_SEG_LVL_MAX: Number of segment features.
+ */
+enum av1_segment_feature {
+	AV1_SEG_LVL_ALT_Q = 0,
+	AV1_SEG_LVL_ALT_LF_Y_V = 1,
+	AV1_SEG_LVL_REF_FRAME = 5,
+	AV1_SEG_LVL_REF_SKIP = 6,
+	AV1_SEG_LVL_REF_GLOBALMV = 7,
+	AV1_SEG_LVL_MAX = 8
+};
+
+#define AV1_SEGMENT_FEATURE_ENABLED(id) (1 << (id))
+
+/**
+ * struct av1_segmentation - AV1 Segmentation params as defined in section
+ * 6.8.13 "Segmentation params semantics" of the AV1 specification.
+ *
+ * @flags: see AV1_SEGMENTATION_FLAG_{}.
+ * @last_active_seg_id: indicates the highest numbered segment id that has some
+ * enabled feature. This is used when decoding the segment id to only decode
+ * choices corresponding to used segments.
+ * @feature_enabled: bitmask defining which features are enabled in each
+ * segment. Use AV1_SEGMENT_FEATURE_ENABLED to build a suitable mask.
+ * @feature_data: data attached to each feature. Data entry is only valid if the
+ * feature is enabled
+ */
+struct av1_segmentation {
+	uint8_t flags;
+	uint8_t last_active_seg_id;
+	uint8_t feature_enabled[AV1_MAX_SEGMENTS];
+	int16_t feature_data[AV1_MAX_SEGMENTS][AV1_SEG_LVL_MAX];
+};
+
+#define AV1_LOOP_FILTER_FLAG_DELTA_ENABLED 0x1
+#define AV1_LOOP_FILTER_FLAG_DELTA_UPDATE 0x2
+#define AV1_LOOP_FILTER_FLAG_DELTA_LF_PRESENT 0x4
+#define AV1_LOOP_FILTER_FLAG_DELTA_LF_MULTI 0x8
+
+/**
+ * struct av1_loop_filter - AV1 Loop filter params as defined in section
+ * 6.8.10 "Loop filter semantics" and 6.8.16 "Loop filter delta parameters
+ * semantics" of the AV1 specification.
+ *
+ * @flags: see AV1_LOOP_FILTER_FLAG_{}
+ * @level: an array containing loop filter strength values. Different loop
+ * filter strength values from the array are used depending on the image plane
+ * being filtered, and the edge direction (vertical or horizontal) being
+ * filtered.
+ * @sharpness: indicates the sharpness level. The loop_filter_level and
+ * loop_filter_sharpness together determine when a block edge is filtered, and
+ * by how much the filtering can change the sample values. The loop filter
+ * process is described in section 7.14 of the AV1 specification.
+ * @ref_deltas: contains the adjustment needed for the filter level based on the
+ * chosen reference frame. If this syntax element is not present, it maintains
+ * its previous value.
+ * @mode_deltas: contains the adjustment needed for the filter level based on
+ * the chosen mode. If this syntax element is not present, it maintains its
+ * previous value.
+ * @delta_lf_res: specifies the left shift which should be applied to decoded
+ * loop filter delta values.
+ */
+struct av1_loop_filter {
+	uint8_t flags;
+	uint8_t level[4];
+	uint8_t sharpness;
+	int8_t ref_deltas[AV1_TOTAL_REFS_PER_FRAME];
+	int8_t mode_deltas[2];
+	uint8_t delta_lf_res;
+};
+
+#define AV1_QUANTIZATION_FLAG_DIFF_UV_DELTA 0x1
+#define AV1_QUANTIZATION_FLAG_USING_QMATRIX 0x2
+#define AV1_QUANTIZATION_FLAG_DELTA_Q_PRESENT 0x4
+
+/**
+ * struct av1_quantization - AV1 Quantization params as defined in section
+ * 6.8.11 "Quantization params semantics" of the AV1 specification.
+ *
+ * @flags: see AV1_QUANTIZATION_FLAG_{}
+ * @base_q_idx: indicates the base frame qindex. This is used for Y AC
+ * coefficients and as the base value for the other quantizers.
+ * @delta_q_y_dc: indicates the Y DC quantizer relative to base_q_idx.
+ * @delta_q_u_dc: indicates the U DC quantizer relative to base_q_idx.
+ * @delta_q_u_ac: indicates the U AC quantizer relative to base_q_idx.
+ * @delta_q_v_dc: indicates the V DC quantizer relative to base_q_idx.
+ * @delta_q_v_ac: indicates the V AC quantizer relative to base_q_idx.
+ * @qm_y: specifies the level in the quantizer matrix that should be used for
+ * luma plane decoding.
+ * @qm_u: specifies the level in the quantizer matrix that should be used for
+ * chroma U plane decoding.
+ * @qm_v: specifies the level in the quantizer matrix that should be used for
+ * chroma V plane decoding.
+ * @delta_q_res: specifies the left shift which should be applied to decoded
+ * quantizer index delta values.
+ */
+struct av1_quantization {
+	uint8_t flags;
+	uint8_t base_q_idx;
+	int8_t delta_q_y_dc;
+	int8_t delta_q_u_dc;
+	int8_t delta_q_u_ac;
+	int8_t delta_q_v_dc;
+	int8_t delta_q_v_ac;
+	uint8_t qm_y;
+	uint8_t qm_u;
+	uint8_t qm_v;
+	uint8_t delta_q_res;
+};
+
+#define AV1_TILE_INFO_FLAG_UNIFORM_TILE_SPACING 0x1
+
+/**
+ * struct av1_tile_info - AV1 Tile info as defined in section 6.8.14 "Tile
+ * info semantics" of the AV1 specification.
+ *
+ * @flags: see AV1_TILE_INFO_FLAG_{}
+ * @context_update_tile_id: specifies which tile to use for the CDF update.
+ * @tile_rows: specifies the number of tiles down the frame.
+ * @tile_cols: specifies the number of tiles across the frame.
+ * @mi_col_starts: an array specifying the start column (in units of 4x4 luma
+ * samples) for each tile across the image.
+ * @mi_row_starts: an array specifying the start row (in units of 4x4 luma
+ * samples) for each tile down the image.
+ * @width_in_sbs_minus_1: specifies the width of a tile minus 1 in units of
+ * superblocks.
+ * @height_in_sbs_minus_1:  specifies the height of a tile minus 1 in units of
+ * superblocks.
+ * @tile_size_bytes: specifies the number of bytes needed to code each tile
+ * size.
+ * @reserved: padding field. Should be zeroed by applications.
+ */
+struct av1_tile_info {
+	uint8_t flags;
+	uint8_t context_update_tile_id;
+	uint8_t tile_cols;
+	uint8_t tile_rows;
+	uint32_t mi_col_starts[AV1_MAX_TILE_COLS + 1];
+	uint32_t mi_row_starts[AV1_MAX_TILE_ROWS + 1];
+	uint32_t width_in_sbs_minus_1[AV1_MAX_TILE_COLS];
+	uint32_t height_in_sbs_minus_1[AV1_MAX_TILE_ROWS];
+	uint8_t tile_size_bytes;
+	uint8_t reserved[3];
+};
+
+/**
+ * enum av1_frame_type - AV1 Frame Type
+ *
+ * @AV1_KEY_FRAME: Key frame
+ * @AV1_INTER_FRAME: Inter frame
+ * @AV1_INTRA_ONLY_FRAME: Intra-only frame
+ * @AV1_SWITCH_FRAME: Switch frame
+ */
+enum av1_frame_type {
+	AV1_KEY_FRAME = 0,
+	AV1_INTER_FRAME = 1,
+	AV1_INTRA_ONLY_FRAME = 2,
+	AV1_SWITCH_FRAME = 3
+};
+
+/**
+ * enum av1_interpolation_filter - AV1 interpolation filter types
+ *
+ * @AV1_INTERPOLATION_FILTER_EIGHTTAP: eight tap filter
+ * @AV1_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH: eight tap smooth filter
+ * @AV1_INTERPOLATION_FILTER_EIGHTTAP_SHARP: eight tap sharp filter
+ * @AV1_INTERPOLATION_FILTER_BILINEAR: bilinear filter
+ * @AV1_INTERPOLATION_FILTER_SWITCHABLE: filter selection is signaled at
+ * the block level
+ *
+ * See section 6.8.9 "Interpolation filter semantics" of the AV1 specification
+ * for more details.
+ */
+enum av1_interpolation_filter {
+	AV1_INTERPOLATION_FILTER_EIGHTTAP = 0,
+	AV1_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH = 1,
+	AV1_INTERPOLATION_FILTER_EIGHTTAP_SHARP = 2,
+	AV1_INTERPOLATION_FILTER_BILINEAR = 3,
+	AV1_INTERPOLATION_FILTER_SWITCHABLE = 4,
+};
+
+/**
+ * enum av1_tx_mode - AV1 Tx mode as described in section 6.8.21 "TX mode
+ * semantics" of the AV1 specification.
+ * @AV1_TX_MODE_ONLY_4X4: the inverse transform will use only 4x4
+ * transforms
+ * @AV1_TX_MODE_LARGEST: the inverse transform will use the largest
+ * transform size that fits inside the block
+ * @AV1_TX_MODE_SELECT: the choice of transform size is specified
+ * explicitly for each block.
+ */
+enum av1_tx_mode {
+	AV1_TX_MODE_ONLY_4X4 = 0,
+	AV1_TX_MODE_LARGEST = 1,
+	AV1_TX_MODE_SELECT = 2
+};
+
+#define AV1_FRAME_FLAG_SHOW_FRAME 0x00000001
+#define AV1_FRAME_FLAG_SHOWABLE_FRAME 0x00000002
+#define AV1_FRAME_FLAG_ERROR_RESILIENT_MODE 0x00000004
+#define AV1_FRAME_FLAG_DISABLE_CDF_UPDATE 0x00000008
+#define AV1_FRAME_FLAG_ALLOW_SCREEN_CONTENT_TOOLS 0x00000010
+#define AV1_FRAME_FLAG_FORCE_INTEGER_MV 0x00000020
+#define AV1_FRAME_FLAG_ALLOW_INTRABC 0x00000040
+#define AV1_FRAME_FLAG_USE_SUPERRES 0x00000080
+#define AV1_FRAME_FLAG_ALLOW_HIGH_PRECISION_MV 0x00000100
+#define AV1_FRAME_FLAG_IS_MOTION_MODE_SWITCHABLE 0x00000200
+#define AV1_FRAME_FLAG_USE_REF_FRAME_MVS 0x00000400
+#define AV1_FRAME_FLAG_DISABLE_FRAME_END_UPDATE_CDF 0x00000800
+#define AV1_FRAME_FLAG_ALLOW_WARPED_MOTION 0x00001000
+#define AV1_FRAME_FLAG_REFERENCE_SELECT 0x00002000
+#define AV1_FRAME_FLAG_REDUCED_TX_SET 0x00004000
+#define AV1_FRAME_FLAG_SKIP_MODE_ALLOWED 0x00008000
+#define AV1_FRAME_FLAG_SKIP_MODE_PRESENT 0x00010000
+#define AV1_FRAME_FLAG_FRAME_SIZE_OVERRIDE 0x00020000
+#define AV1_FRAME_FLAG_BUFFER_REMOVAL_TIME_PRESENT 0x00040000
+#define AV1_FRAME_FLAG_FRAME_REFS_SHORT_SIGNALING 0x00080000
+
+/**
+ * struct ctrl_av1_frame - Represents an AV1 Frame Header OBU.
+ *
+ * @tile_info: tile info
+ * @quantization: quantization params
+ * @segmentation: segmentation params
+ * @superres_denom: the denominator for the upscaling ratio.
+ * @loop_filter: loop filter params
+ * @cdef: cdef params
+ * @skip_mode_frame: specifies the frames to use for compound prediction when
+ * skip_mode is equal to 1.
+ * @primary_ref_frame: specifies which reference frame contains the CDF values
+ * and other state that should be loaded at the start of the frame.
+ * @loop_restoration: loop restoration params
+ * @global_motion: global motion params
+ * @flags: see AV1_FRAME_FLAG_{}
+ * @frame_type: specifies the AV1 frame type
+ * @order_hint: specifies OrderHintBits least significant bits of the expected
+ * output order for this frame.
+ * @upscaled_width: the upscaled width.
+ * @interpolation_filter: specifies the filter selection used for performing
+ * inter prediction.
+ * @tx_mode: specifies how the transform size is determined.
+ * @frame_width_minus_1: add 1 to get the frame's width.
+ * @frame_height_minus_1: add 1 to get the frame's height
+ * @render_width_minus_1: add 1 to get the render width of the frame in luma
+ * samples.
+ * @render_height_minus_1: add 1 to get the render height of the frame in luma
+ * samples.
+ * @current_frame_id: specifies the frame id number for the current frame. Frame
+ * id numbers are additional information that do not affect the decoding
+ * process, but provide decoders with a way of detecting missing reference
+ * frames so that appropriate action can be taken.
+ * @buffer_removal_time: specifies the frame removal time in units of DecCT clock
+ * ticks counted from the removal time of the last random access point for
+ * operating point opNum.
+ * @reserved: padding field. Should be zeroed by applications.
+ * @order_hints: specifies the expected output order hint for each reference
+ * frame. This field corresponds to the OrderHints variable from the
+ * specification (section 5.9.2 "Uncompressed header syntax"). As such, this is
+ * only used for non-intra frames and ignored otherwise. order_hints[0] is
+ * always ignored.
+ * @reference_frame_ts: the V4L2 timestamp of the reference frame slots.
+ * @ref_frame_idx: used to index into @reference_frame_ts when decoding
+ * inter-frames. The meaning of this array is the same as in the specification.
+ * The timestamp refers to the timestamp field in struct v4l2_buffer. Use
+ * v4l2_timeval_to_ns() to convert the struct timeval to a __u64.
+ * @refresh_frame_flags: contains a bitmask that specifies which reference frame
+ * slots will be updated with the current frame after it is decoded.
+ */
+struct ctrl_av1_frame {
+	struct av1_tile_info tile_info;
+	struct av1_quantization quantization;
+	uint8_t superres_denom;
+	struct av1_segmentation segmentation;
+	struct av1_loop_filter loop_filter;
+	struct av1_cdef cdef;
+	uint8_t skip_mode_frame[2];
+	uint8_t primary_ref_frame;
+	struct av1_loop_restoration loop_restoration;
+	struct av1_global_motion global_motion;
+	uint32_t flags;
+	enum av1_frame_type frame_type;
+	uint32_t order_hint;
+	uint32_t upscaled_width;
+	enum av1_interpolation_filter interpolation_filter;
+	enum av1_tx_mode tx_mode;
+	uint32_t frame_width_minus_1;
+	uint32_t frame_height_minus_1;
+	uint16_t render_width_minus_1;
+	uint16_t render_height_minus_1;
+
+	uint32_t current_frame_id;
+	uint32_t buffer_removal_time[AV1_MAX_OPERATING_POINTS];
+	uint8_t reserved[4];
+	uint32_t order_hints[AV1_TOTAL_REFS_PER_FRAME];
+	uint32_t reference_frame_ts_h[AV1_TOTAL_REFS_PER_FRAME];
+	uint32_t reference_frame_ts_l[AV1_TOTAL_REFS_PER_FRAME];
+	int8_t ref_frame_idx[AV1_REFS_PER_FRAME];
+	uint8_t refresh_frame_flags;
+};
+
+#define AV1_FILM_GRAIN_FLAG_APPLY_GRAIN 0x1
+#define AV1_FILM_GRAIN_FLAG_UPDATE_GRAIN 0x2
+#define AV1_FILM_GRAIN_FLAG_CHROMA_SCALING_FROM_LUMA 0x4
+#define AV1_FILM_GRAIN_FLAG_OVERLAP 0x8
+#define AV1_FILM_GRAIN_FLAG_CLIP_TO_RESTRICTED_RANGE 0x10
+
+/**
+ * struct ctrl_av1_film_grain - AV1 Film Grain parameters.
+ *
+ * Film grain parameters as specified by section 6.8.20 of the AV1 Specification.
+ *
+ * @flags: see AV1_FILM_GRAIN_{}.
+ * @cr_mult: represents a multiplier for the cr component used in derivation of
+ * the input index to the cr component scaling function.
+ * @grain_seed: specifies the starting value for the pseudo-random numbers used
+ * during film grain synthesis.
+ * @film_grain_params_ref_idx: indicates which reference frame contains the
+ * film grain parameters to be used for this frame.
+ * @num_y_points: specifies the number of points for the piece-wise linear
+ * scaling function of the luma component.
+ * @point_y_value: represents the x (luma value) coordinate for the i-th point
+ * of the piecewise linear scaling function for luma component. The values are
+ * signaled on the scale of 0..255. In case of 10 bit video, these values
+ * correspond to luma values divided by 4. In case of 12 bit video, these values
+ * correspond to luma values divided by 16.
+ * @point_y_scaling:  represents the scaling (output) value for the i-th point
+ * of the piecewise linear scaling function for luma component.
+ * @num_cb_points: specifies the number of points for the piece-wise linear
+ * scaling function of the cb component.
+ * @point_cb_value: represents the x coordinate for the i-th point of the
+ * piece-wise linear scaling function for cb component. The values are signaled
+ * on the scale of 0..255.
+ * @point_cb_scaling: represents the scaling (output) value for the i-th point
+ * of the piecewise linear scaling function for cb component.
+ * @num_cr_points: specifies represents the number of points for the piece-wise
+ * linear scaling function of the cr component.
+ * @point_cr_value:  represents the x coordinate for the i-th point of the
+ * piece-wise linear scaling function for cr component. The values are signaled
+ * on the scale of 0..255.
+ * @point_cr_scaling:  represents the scaling (output) value for the i-th point
+ * of the piecewise linear scaling function for cr component.
+ * @grain_scaling_minus_8: represents the shift ??8 applied to the values of the
+ * chroma component. The grain_scaling_minus_8 can take values of 0..3 and
+ * determines the range and quantization step of the standard deviation of film
+ * grain.
+ * @ar_coeff_lag: specifies the number of auto-regressive coefficients for luma
+ * and chroma.
+ * @ar_coeffs_y_plus_128: specifies auto-regressive coefficients used for the Y
+ * plane.
+ * @ar_coeffs_cb_plus_128: specifies auto-regressive coefficients used for the U
+ * plane.
+ * @ar_coeffs_cr_plus_128: specifies auto-regressive coefficients used for the V
+ * plane.
+ * @ar_coeff_shift_minus_6: specifies the range of the auto-regressive
+ * coefficients. Values of 0, 1, 2, and 3 correspond to the ranges for
+ * auto-regressive coefficients of [-2, 2), [-1, 1), [-0.5, 0.5) and [-0.25,
+ * 0.25) respectively.
+ * @grain_scale_shift: specifies how much the Gaussian random numbers should be
+ * scaled down during the grain synthesis process.
+ * @cb_mult: represents a multiplier for the cb component used in derivation of
+ * the input index to the cb component scaling function.
+ * @cb_luma_mult: represents a multiplier for the average luma component used in
+ * derivation of the input index to the cb component scaling function.
+ * @cr_luma_mult: represents a multiplier for the average luma component used in
+ * derivation of the input index to the cr component scaling function.
+ * @cb_offset: represents an offset used in derivation of the input index to the
+ * cb component scaling function.
+ * @cr_offset: represents an offset used in derivation of the input index to the
+ * cr component scaling function.
+ * @reserved: padding field. Should be zeroed by applications.
+ */
+struct ctrl_av1_film_grain {
+	uint8_t flags;
+	uint8_t cr_mult;
+	uint16_t grain_seed;
+	uint8_t film_grain_params_ref_idx;
+	uint8_t num_y_points;
+	uint8_t point_y_value[AV1_MAX_NUM_Y_POINTS];
+	uint8_t point_y_scaling[AV1_MAX_NUM_Y_POINTS];
+	uint8_t num_cb_points;
+	uint8_t point_cb_value[AV1_MAX_NUM_CB_POINTS];
+	uint8_t point_cb_scaling[AV1_MAX_NUM_CB_POINTS];
+	uint8_t num_cr_points;
+	uint8_t point_cr_value[AV1_MAX_NUM_CR_POINTS];
+	uint8_t point_cr_scaling[AV1_MAX_NUM_CR_POINTS];
+	uint8_t grain_scaling_minus_8;
+	uint8_t ar_coeff_lag;
+	uint8_t ar_coeffs_y_plus_128[AV1_AR_COEFFS_SIZE];
+	uint8_t ar_coeffs_cb_plus_128[AV1_AR_COEFFS_SIZE];
+	uint8_t ar_coeffs_cr_plus_128[AV1_AR_COEFFS_SIZE];
+	uint8_t ar_coeff_shift_minus_6;
+	uint8_t grain_scale_shift;
+	uint8_t cb_mult;
+	uint8_t cb_luma_mult;
+	uint8_t cr_luma_mult;
+	uint16_t cb_offset;
+	uint16_t cr_offset;
+	uint8_t reserved[4];
+};
+
+#endif
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-hevc.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-hevc.c
@@ -0,0 +1,161 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#include "rtkve-sl-ctrl.h"
+#include "rtkve-common.h"
+#include "rtkve-rpc.h"
+#include "rtkve-sl-hevc.h"
+
+uint32_t rtkve_get_hevc_ctrl_size(void)
+{
+	return sizeof(struct HEVC_V4L2_CTRL_INFO);
+}
+
+static void rtkve_hevc_setup_sps(struct HEVC_V4L2_CTRL_INFO *hevc,
+				 struct stateless_hevc_info *ctrl)
+{
+	struct ctrl_hevc_sps *sps = &hevc->sps;
+	const struct v4l2_ctrl_hevc_sps *ctrl_sps = ctrl->sps;
+
+	sps->video_parameter_set_id = ctrl_sps->video_parameter_set_id;
+	sps->seq_parameter_set_id = ctrl_sps->seq_parameter_set_id;
+	sps->pic_width_in_luma_samples =
+		htons(ctrl_sps->pic_width_in_luma_samples);
+	sps->pic_height_in_luma_samples =
+		htons(ctrl_sps->pic_height_in_luma_samples);
+	sps->bit_depth_luma_minus8 = ctrl_sps->bit_depth_luma_minus8;
+	sps->bit_depth_chroma_minus8 = ctrl_sps->bit_depth_chroma_minus8;
+	sps->log2_max_pic_order_cnt_lsb_minus4 =
+		ctrl_sps->log2_max_pic_order_cnt_lsb_minus4;
+	sps->sps_max_dec_pic_buffering_minus1 =
+		ctrl_sps->sps_max_dec_pic_buffering_minus1;
+	sps->sps_max_num_reorder_pics = ctrl_sps->sps_max_num_reorder_pics;
+	sps->sps_max_latency_increase_plus1 =
+		ctrl_sps->sps_max_latency_increase_plus1;
+	sps->log2_min_luma_coding_block_size_minus3 =
+		ctrl_sps->log2_min_luma_coding_block_size_minus3;
+	sps->log2_diff_max_min_luma_coding_block_size =
+		ctrl_sps->log2_diff_max_min_luma_coding_block_size;
+	sps->log2_min_luma_transform_block_size_minus2 =
+		ctrl_sps->log2_min_luma_transform_block_size_minus2;
+	sps->log2_diff_max_min_luma_transform_block_size =
+		ctrl_sps->log2_diff_max_min_luma_transform_block_size;
+	sps->max_transform_hierarchy_depth_inter =
+		ctrl_sps->max_transform_hierarchy_depth_inter;
+	sps->max_transform_hierarchy_depth_intra =
+		ctrl_sps->max_transform_hierarchy_depth_intra;
+	sps->pcm_sample_bit_depth_luma_minus1 =
+		ctrl_sps->pcm_sample_bit_depth_luma_minus1;
+	sps->pcm_sample_bit_depth_chroma_minus1 =
+		ctrl_sps->pcm_sample_bit_depth_chroma_minus1;
+	sps->log2_min_pcm_luma_coding_block_size_minus3 =
+		ctrl_sps->log2_min_pcm_luma_coding_block_size_minus3;
+	sps->log2_diff_max_min_pcm_luma_coding_block_size =
+		ctrl_sps->log2_diff_max_min_pcm_luma_coding_block_size;
+	sps->num_short_term_ref_pic_sets =
+		ctrl_sps->num_short_term_ref_pic_sets;
+	sps->num_long_term_ref_pics_sps = ctrl_sps->num_long_term_ref_pics_sps;
+	sps->chroma_format_idc = ctrl_sps->chroma_format_idc;
+	sps->sps_max_sub_layers_minus1 = ctrl_sps->sps_max_sub_layers_minus1;
+	memcpy(&sps->reserved, &ctrl_sps->reserved, sizeof(ctrl_sps->reserved));
+	sps->flags = htonll(ctrl_sps->flags);
+}
+
+static void rtkve_hevc_setup_pps(struct HEVC_V4L2_CTRL_INFO *hevc,
+				 struct stateless_hevc_info *ctrl)
+{
+	struct ctrl_hevc_pps *pps = &hevc->pps;
+	const struct v4l2_ctrl_hevc_pps *ctrl_pps = ctrl->pps;
+
+	memcpy(pps, ctrl_pps, sizeof(struct v4l2_ctrl_hevc_pps));
+	pps->flags = htonll(ctrl_pps->flags);
+}
+
+static void rtkve_hevc_setup_scaling_matrix(struct HEVC_V4L2_CTRL_INFO *hevc,
+					    struct stateless_hevc_info *ctrl)
+{
+	struct ctrl_hevc_scaling_matrix *sm = &hevc->scaling_matrix;
+	const struct v4l2_ctrl_hevc_scaling_matrix *ctrl_sm = ctrl->sm;
+
+	memcpy(sm, ctrl_sm, sizeof(struct v4l2_ctrl_hevc_scaling_matrix));
+}
+
+static void rtkve_hevc_setup_decode_params(struct HEVC_V4L2_CTRL_INFO *hevc,
+					   struct stateless_hevc_info *ctrl)
+{
+	struct ctrl_hevc_decode_params *dp = &hevc->decode_params;
+	const struct v4l2_ctrl_hevc_decode_params *ctrl_dp = ctrl->dpram;
+	int i = 0;
+
+	dp->pic_order_cnt_val = htonl(ctrl_dp->pic_order_cnt_val);
+	dp->short_term_ref_pic_set_size =
+		htons(ctrl_dp->short_term_ref_pic_set_size);
+	dp->long_term_ref_pic_set_size =
+		htons(ctrl_dp->long_term_ref_pic_set_size);
+	dp->num_active_dpb_entries = ctrl_dp->num_active_dpb_entries;
+	dp->num_poc_st_curr_before = ctrl_dp->num_poc_st_curr_before;
+	dp->num_poc_st_curr_after = ctrl_dp->num_poc_st_curr_after;
+	dp->num_poc_lt_curr = ctrl_dp->num_poc_lt_curr;
+	memcpy(&dp->poc_st_curr_before, &ctrl_dp->poc_st_curr_before,
+	       sizeof(ctrl_dp->poc_st_curr_before));
+	memcpy(&dp->poc_st_curr_after, &ctrl_dp->poc_st_curr_after,
+	       sizeof(ctrl_dp->poc_st_curr_after));
+	memcpy(&dp->poc_lt_curr, &ctrl_dp->poc_lt_curr,
+	       sizeof(ctrl_dp->poc_lt_curr));
+	dp->num_delta_pocs_of_ref_rps_idx =
+		ctrl_dp->num_delta_pocs_of_ref_rps_idx;
+	memcpy(&dp->reserved, &ctrl_dp->reserved, sizeof(ctrl_dp->reserved));
+	for (i = 0; i < HEVC_DPB_ENTRIES_NUM_MAX; i++) {
+		dp->dpb[i].timestamp = htonll(ctrl_dp->dpb[i].timestamp);
+		dp->dpb[i].flags = ctrl_dp->dpb[i].flags;
+		dp->dpb[i].field_pic = ctrl_dp->dpb[i].field_pic;
+		dp->dpb[i].reserved = htons(ctrl_dp->dpb[i].reserved);
+		dp->dpb[i].pic_order_cnt_val =
+			htonl(ctrl_dp->dpb[i].pic_order_cnt_val);
+	}
+	dp->flags = htonll(ctrl_dp->flags);
+}
+
+int rtkve_setup_hevc_ctrl_info(struct vpu_instance *inst, void *info,
+			       struct dec_param *param, void *wp)
+{
+	struct stateless_hevc_info *ctrl = (struct stateless_hevc_info *)info;
+	struct HEVC_V4L2_CTRL_INFO *cmd = (struct HEVC_V4L2_CTRL_INFO *)wp;
+	struct vpu_handler *hndl = inst->dec_hdl;
+	struct rtkve_ringbuf_t *rb = &hndl->dec.ctrl_info_rb;
+
+	mutex_lock(&rb->lock);
+
+	rtkve_hevc_setup_sps(cmd, ctrl);
+	rtkve_hevc_setup_pps(cmd, ctrl);
+	rtkve_hevc_setup_scaling_matrix(cmd, ctrl);
+	rtkve_hevc_setup_decode_params(cmd, ctrl);
+
+	cmd->y_dma_addr = htonl(param->buf_addr_y);
+	cmd->c_dma_addr = htonl(param->buf_addr_c);
+	cmd->wPtr = htonl(param->wPtr);
+	cmd->PTSH = htonl(param->PTSH);
+	cmd->PTSL = htonl(param->PTSL);
+	cmd->bs_len = htonl(param->bs_len);
+	cmd->slice_param_num = htonl(ctrl->spram_cnt);
+
+	cmd->header.type = htonl(VIDEO_AV1_INBAND_CMD_TYPE_V4L2_CTRL);
+	cmd->header.size = htonl(sizeof(struct HEVC_V4L2_CTRL_INFO));
+	dsb(sy);
+
+	rtkve_inband_setup_ctrl(hndl, sizeof(struct HEVC_V4L2_CTRL_INFO));
+
+	mutex_unlock(&rb->lock);
+
+	return 0;
+}
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-hevc.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-hevc.h
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+
+#ifndef RTKVE_SL_HEVC_H
+#define RTKVE_SL_HEVC_H
+
+uint32_t rtkve_get_hevc_ctrl_size(void);
+#endif
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-vp9.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-vp9.c
@@ -0,0 +1,149 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#include <media/videobuf2-dma-contig.h>
+
+#include "rtkve-sl-ctrl.h"
+#include "rtkve-common.h"
+#include "rtkve-rpc.h"
+#include "rtkve-sl-hevc.h"
+#include "rtkve-sl-vp9.h"
+
+static void rtkve_vp9_setup_frame(struct VP9_V4L2_CTRL_INFO *vp9,
+				  struct stateless_vp9_info *ctrl)
+{
+	struct ctrl_vp9_frame *frm = &vp9->uncmprs_frame;
+	const struct v4l2_ctrl_vp9_frame *ctrl_frm = ctrl->frame;
+
+	memcpy(&frm->lf, &ctrl_frm->lf, sizeof(ctrl_frm->lf));
+	memcpy(&frm->quant, &ctrl_frm->quant, sizeof(ctrl_frm->quant));
+	memcpy(&frm->seg, &ctrl_frm->seg, sizeof(ctrl_frm->seg));
+	word_endian_convert((uint8_t *)&frm->seg.feature_data,
+			     (uint8_t *)&ctrl_frm->seg.feature_data,
+			     sizeof(ctrl_frm->seg.feature_data));
+	frm->flags = htonl(ctrl_frm->flags);
+	frm->compressed_header_size = htons(ctrl_frm->compressed_header_size);
+	frm->uncompressed_header_size =
+		htons(ctrl_frm->uncompressed_header_size);
+	frm->frame_width_minus_1 = htons(ctrl_frm->frame_width_minus_1);
+	frm->frame_height_minus_1 = htons(ctrl_frm->frame_height_minus_1);
+	frm->render_width_minus_1 = htons(ctrl_frm->render_width_minus_1);
+	frm->render_height_minus_1 = htons(ctrl_frm->render_height_minus_1);
+	frm->last_frame_ts = htonll(ctrl_frm->last_frame_ts);
+	frm->golden_frame_ts = htonll(ctrl_frm->golden_frame_ts);
+	frm->alt_frame_ts = htonll(ctrl_frm->alt_frame_ts);
+	frm->ref_frame_sign_bias = ctrl_frm->ref_frame_sign_bias;
+	frm->reset_frame_context = ctrl_frm->reset_frame_context;
+	frm->frame_context_idx = ctrl_frm->frame_context_idx;
+	frm->profile = ctrl_frm->profile;
+	frm->bit_depth = ctrl_frm->bit_depth;
+	frm->interpolation_filter = ctrl_frm->interpolation_filter;
+	frm->tile_cols_log2 = ctrl_frm->tile_cols_log2;
+	frm->tile_rows_log2 = ctrl_frm->tile_rows_log2;
+	frm->reference_mode = ctrl_frm->reference_mode;
+	memcpy(&frm->reserved, &ctrl_frm->reserved, sizeof(ctrl_frm->reserved));
+}
+
+static int rtkve_vp9_setup_ref_frame(struct vpu_instance *inst,
+				  struct VP9_V4L2_CTRL_INFO *vp9, struct stateless_vp9_info *ctrl)
+{
+	const struct v4l2_ctrl_vp9_frame *ctrl_frm = ctrl->frame;
+	struct vb2_buffer *vb;
+	struct vb2_queue *vq;
+	u32 luma_size;
+	u64 timestamp = 0;
+	int i = 0;
+	int ret = 0;
+
+	vq = v4l2_m2m_get_vq(inst->v4l2_fh.m2m_ctx,
+			     V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+	if (!vq) {
+		ret = -EINVAL;
+		dev_err(inst->dev->dev, "%s can't find vb2_queue", __func__);
+		goto exit;
+	}
+
+	luma_size = inst->dst_fmt.width * inst->dst_fmt.height;
+
+	for (i =0; i < VP9_MAX_REFS_PER_FRAME; i++)
+	{
+		if (i == 0)
+			timestamp = ctrl_frm->last_frame_ts;
+		else if (i == 1)
+			timestamp = ctrl_frm->golden_frame_ts;
+		else
+			timestamp = ctrl_frm->alt_frame_ts;
+
+		vb = vb2_find_buffer(vq, timestamp);
+		if (!vb)
+			continue;
+
+		vp9->frame_refs_y_dma_addr[i] =
+				htonl(vb2_dma_contig_plane_dma_addr(vb, 0));
+		vp9->frame_refs_c_dma_addr[i] =
+				htonl(vb2_dma_contig_plane_dma_addr(vb, 0) + luma_size);
+	}
+exit:
+	return ret;
+}
+
+static void rtkve_vp9_setup_cmprs_hdr(struct VP9_V4L2_CTRL_INFO *vp9,
+				      struct stateless_vp9_info *ctrl)
+{
+	struct ctrl_vp9_compressed_hdr *cmprs_hdr = &vp9->cmprs_hdr;
+	const struct v4l2_ctrl_vp9_compressed_hdr *ctrl_frm = ctrl->cmprs_hdr;
+
+	memcpy(cmprs_hdr, ctrl_frm,
+	       sizeof(struct v4l2_ctrl_vp9_compressed_hdr));
+}
+
+uint32_t rtkve_get_vp9_ctrl_size(void)
+{
+	return sizeof(struct VP9_V4L2_CTRL_INFO);
+}
+
+int rtkve_setup_vp9_ctrl_info(struct vpu_instance *inst, void *info,
+			      struct dec_param *param, void *wp)
+{
+	struct stateless_vp9_info *ctrl = (struct stateless_vp9_info *)info;
+	struct VP9_V4L2_CTRL_INFO *cmd = (struct VP9_V4L2_CTRL_INFO *)wp;
+	struct vpu_handler *hndl = inst->dec_hdl;
+	struct rtkve_ringbuf_t *rb = &hndl->dec.ctrl_info_rb;
+	int ret = 0;
+
+	mutex_lock(&rb->lock);
+
+	rtkve_vp9_setup_frame(cmd, ctrl);
+	rtkve_vp9_setup_ref_frame(inst, cmd, ctrl);
+	rtkve_vp9_setup_cmprs_hdr(cmd, ctrl);
+
+	//cmd->refresh_frame_flags = ctrl->frame->refresh_frame_flags;
+
+	cmd->y_dma_addr = htonl(param->buf_addr_y);
+	cmd->c_dma_addr = htonl(param->buf_addr_c);
+	cmd->refresh_frame_ts_high = htonl(param->pre_PTSH);
+	cmd->refresh_frame_ts_low = htonl(param->pre_PTSL);
+	cmd->wPtr = htonl(param->wPtr);
+	cmd->PTSH = htonl(param->PTSH);
+	cmd->PTSL = htonl(param->PTSL);
+	cmd->bs_len = htonl(param->bs_len);
+
+	cmd->header.type = htonl(VIDEO_VP9_INBAND_CMD_TYPE_V4L2_CTRL);
+	cmd->header.size = htonl(sizeof(struct VP9_V4L2_CTRL_INFO));
+	dsb(sy);
+
+	rtkve_inband_setup_ctrl(hndl, sizeof(struct VP9_V4L2_CTRL_INFO));
+	mutex_unlock(&rb->lock);
+
+	return ret;
+}
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-vp9.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-sl-vp9.h
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#ifndef RTKVE_SL_VP9_H
+#define RTKVE_SL_VP9_H
+
+uint32_t rtkve_get_vp9_ctrl_size(void);
+int rtkve_setup_vp9_ctrl_info(struct vpu_instance *inst, void *info,
+			      struct dec_param *param, void *wp);
+
+#endif
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-stateless-vpu-dec.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-stateless-vpu-dec.c
@@ -0,0 +1,1913 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#include "rtkve-rpc.h"
+#include "rtkve-vpu.h"
+#include "rtkve-sl-hevc.h"
+#include "rtkve-sl-vp9.h"
+#include "rtkve-sl-av1.h"
+
+#define MAX_CTRL_LIST (3)
+#define CTRL_RINGBUF_NUM (32)
+#define MEANINGLESS (~0)
+
+static int rtkve_sl_dec_stop(struct vpu_instance *inst, unsigned int type);
+static void rtkve_sl_dec_return_dstbuf(struct vpu_instance *inst);
+extern void rtkve_update_pix_fmt(struct vpu_instance *inst,
+				 struct v4l2_pix_format_mplane *pix_mp,
+				 unsigned int width, unsigned int height);
+
+struct sl_ctrl_desc {
+	struct v4l2_ctrl_config cfg;
+};
+
+struct sl_ctrls {
+	const struct sl_ctrl_desc *ctrls;
+	unsigned int num_ctrls;
+};
+
+static const struct sl_ctrl_desc sl_hevc_ctrl_descs[] = {
+	{
+		.cfg = {
+			.id = V4L2_CID_STATELESS_HEVC_SPS,
+		},
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_STATELESS_HEVC_PPS,
+		},
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_STATELESS_HEVC_SLICE_PARAMS,
+			.dims   = { 256 },
+		},
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_STATELESS_HEVC_SCALING_MATRIX,
+		},
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_STATELESS_HEVC_DECODE_PARAMS,
+		},
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_MPEG_VIDEO_HEVC_PROFILE,
+			.def = V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN,
+			.max = V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN,
+			.menu_skip_mask =
+				BIT(V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE),
+		},
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_MPEG_VIDEO_HEVC_LEVEL,
+			.min = V4L2_MPEG_VIDEO_HEVC_LEVEL_1,
+			.def = V4L2_MPEG_VIDEO_HEVC_LEVEL_4,
+			.max = V4L2_MPEG_VIDEO_HEVC_LEVEL_4_1,
+		},
+	},
+
+	{
+		.cfg = {
+			.id = V4L2_CID_STATELESS_HEVC_DECODE_MODE,
+			.min = V4L2_STATELESS_HEVC_DECODE_MODE_FRAME_BASED,
+			.def = V4L2_STATELESS_HEVC_DECODE_MODE_FRAME_BASED,
+			.max = V4L2_STATELESS_HEVC_DECODE_MODE_FRAME_BASED,
+		},
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_STATELESS_HEVC_START_CODE,
+			.min = V4L2_STATELESS_HEVC_START_CODE_ANNEX_B,
+			.def = V4L2_STATELESS_HEVC_START_CODE_ANNEX_B,
+			.max = V4L2_STATELESS_HEVC_START_CODE_ANNEX_B,
+		},
+	},
+};
+
+static const struct sl_ctrls sl_hevc_ctrls = {
+	.ctrls = sl_hevc_ctrl_descs,
+	.num_ctrls = ARRAY_SIZE(sl_hevc_ctrl_descs),
+};
+
+static const struct sl_ctrl_desc sl_vp9_ctrl_descs[] = {
+	{
+		.cfg = {
+			.id = V4L2_CID_STATELESS_VP9_FRAME,
+		},
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_STATELESS_VP9_COMPRESSED_HDR,
+		},
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_MPEG_VIDEO_VP9_PROFILE,
+			.min = V4L2_MPEG_VIDEO_VP9_PROFILE_0,
+			.def = V4L2_MPEG_VIDEO_VP9_PROFILE_0,
+			.max = V4L2_MPEG_VIDEO_VP9_PROFILE_0,
+			.menu_skip_mask = BIT(V4L2_MPEG_VIDEO_VP9_PROFILE_1),
+		},
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_MPEG_VIDEO_VP9_LEVEL,
+			.min = V4L2_MPEG_VIDEO_VP9_LEVEL_1_0,
+			.def = V4L2_MPEG_VIDEO_VP9_LEVEL_4_0,
+			.max = V4L2_MPEG_VIDEO_VP9_LEVEL_4_1,
+		},
+	},
+};
+
+static const struct sl_ctrls sl_vp9_ctrls = {
+	.ctrls = sl_vp9_ctrl_descs,
+	.num_ctrls = ARRAY_SIZE(sl_vp9_ctrl_descs),
+};
+
+static const struct sl_ctrl_desc sl_av1_ctrl_descs[] = {
+	{
+		.cfg = {
+			.id = V4L2_CID_STATELESS_AV1_SEQUENCE,
+
+		},
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_STATELESS_AV1_FRAME,
+
+		},
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_STATELESS_AV1_TILE_GROUP_ENTRY,
+			.dims = { V4L2_AV1_MAX_TILE_COUNT },
+
+		},
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_STATELESS_AV1_FILM_GRAIN,
+		},
+	},
+#if 0
+	{
+		.cfg = {
+			.id = V4L2_CID_MPEG_VIDEO_AV1_PROFILE,
+			.min = V4L2_MPEG_VIDEO_AV1_PROFILE_MAIN,
+			.def = V4L2_MPEG_VIDEO_AV1_PROFILE_MAIN,
+			.max = V4L2_MPEG_VIDEO_AV1_PROFILE_PROFESSIONAL,
+		},
+	},
+	{
+		.cfg = {
+			.id = V4L2_CID_MPEG_VIDEO_AV1_LEVEL,
+			.min = V4L2_MPEG_VIDEO_AV1_LEVEL_2_0,
+			.def = V4L2_MPEG_VIDEO_AV1_LEVEL_4_0,
+			.max = V4L2_MPEG_VIDEO_AV1_LEVEL_5_1,
+		},
+	},
+#endif
+};
+
+static const struct sl_ctrls sl_av1_ctrls = {
+	.ctrls = sl_av1_ctrl_descs,
+	.num_ctrls = ARRAY_SIZE(sl_av1_ctrl_descs),
+};
+
+static const struct sl_ctrls *sl_ctrls_list[MAX_CTRL_LIST] = {
+	&sl_hevc_ctrls,
+	&sl_vp9_ctrls,
+	&sl_av1_ctrls,
+};
+
+static const struct vpu_format rtkve_stateless_dec_fmt_list[2][3] = {
+	[VPU_FMT_TYPE_CODEC] = {
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_HEVC_SLICE,
+			.max_width = HEVC_MAX_DEC_PIC_WIDTH,
+			.min_width = HEVC_MIN_DEC_PIC_WIDTH,
+			.max_height = HEVC_MAX_DEC_PIC_HEIGHT,
+			.min_height = HEVC_MIN_DEC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_VP9_FRAME,
+			.max_width = VP9_MAX_DEC_PIC_WIDTH,
+			.min_width = VP9_MIN_DEC_PIC_WIDTH,
+			.max_height = VP9_MAX_DEC_PIC_HEIGHT,
+			.min_height = VP9_MIN_DEC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_AV1_FRAME,
+			.max_width = AV1_MAX_DEC_PIC_WIDTH,
+			.min_width = AV1_MIN_DEC_PIC_WIDTH,
+			.max_height = AV1_MAX_DEC_PIC_HEIGHT,
+			.min_height = AV1_MIN_DEC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+	},
+	[VPU_FMT_TYPE_RAW] = {
+		{
+			.v4l2_pix_fmt = V4L2_PIX_FMT_NV12,
+			.max_width = RAW_MAX_DEC_PIC_WIDTH,
+			.min_width = RAW_MIN_DEC_PIC_WIDTH,
+			.max_height = RAW_MAX_DEC_PIC_HEIGHT,
+			.min_height = RAW_MIN_DEC_PIC_HEIGHT,
+			.num_planes = 1,
+		},
+	}
+};
+
+static inline struct vpu_instance *ctrl_to_dec_inst(struct v4l2_ctrl *ctrl)
+{
+	return container_of(ctrl->handler, struct vpu_instance, v4l2_ctrl_hdl);
+}
+
+static int rtkve_sl_dec_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct vpu_instance *inst = ctrl_to_dec_inst(ctrl);
+	struct v4l2_ctrl_hevc_sps *h265;
+	struct v4l2_ctrl_vp9_frame *frame;
+	struct v4l2_ctrl_av1_sequence *seq;
+	int ret = 0;
+
+	if (!ctrl || !ctrl->p_new.p) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	switch (ctrl->id) {
+	case V4L2_CID_STATELESS_HEVC_SPS:
+		h265 = (struct v4l2_ctrl_hevc_sps *)ctrl->p_new.p;
+
+		if (h265->bit_depth_chroma_minus8 == 2 &&
+		    h265->bit_depth_luma_minus8 == 2) {
+			inst->is_10bit_bitstream = true;
+		} else if (h265->bit_depth_chroma_minus8 != 0 &&
+			   h265->bit_depth_luma_minus8 != 0) {
+			dev_err(inst->dev->dev,
+				"HEVC: chroma_minus8:%d, luma_minus8:%d",
+				h265->bit_depth_chroma_minus8,
+				h265->bit_depth_luma_minus8);
+			ret = -EINVAL;
+		}
+		break;
+	case V4L2_CID_STATELESS_VP9_FRAME:
+		frame = (struct v4l2_ctrl_vp9_frame *)ctrl->p_new.p;
+
+		if (frame->bit_depth == 10) {
+			inst->is_10bit_bitstream = true;
+		} else if (frame->bit_depth != 8) {
+			dev_err(inst->dev->dev, "VP9: bit_depth:%d",
+				frame->bit_depth);
+			ret = -EINVAL;
+		}
+		break;
+	case V4L2_CID_STATELESS_AV1_SEQUENCE:
+		seq = (struct v4l2_ctrl_av1_sequence *)ctrl->p_new.p;
+
+		if (seq->bit_depth == 10) {
+			inst->is_10bit_bitstream = true;
+		} else if (seq->bit_depth != 8) {
+			dev_err(inst->dev->dev, "AV1: bit_depth:%d",
+				seq->bit_depth);
+			ret = -EINVAL;
+		}
+		break;
+	default:
+		//do nothing;
+		break;
+	}
+
+	rtkve_update_pix_fmt(inst, &inst->dst_fmt,
+	     inst->src_fmt.width, inst->src_fmt.height);
+
+exit:
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops rtkve_sl_dec_ctrl_ops = {
+	.s_ctrl = rtkve_sl_dec_s_ctrl,
+};
+
+static const struct vpu_format *rtkve_sl_dec_find_fmt(unsigned int v4l2_pix_fmt,
+						      enum vpu_fmt_type type)
+{
+	unsigned int index;
+	const struct vpu_format *fmt = NULL;
+
+	for (index = 0; index < ARRAY_SIZE(rtkve_stateless_dec_fmt_list[type]);
+	     index++) {
+		if (rtkve_stateless_dec_fmt_list[type][index].v4l2_pix_fmt ==
+		    v4l2_pix_fmt)
+			fmt = &rtkve_stateless_dec_fmt_list[type][index];
+	}
+
+	return fmt;
+}
+
+static const struct vpu_format *
+rtkve_sl_dec_find_fmt_by_idx(unsigned int idx, enum vpu_fmt_type type)
+{
+	const struct vpu_format *fmt = NULL;
+
+	if (idx >= ARRAY_SIZE(rtkve_stateless_dec_fmt_list[type]))
+		goto exit;
+
+	if (!rtkve_stateless_dec_fmt_list[type][idx].v4l2_pix_fmt)
+		goto exit;
+
+	fmt = &rtkve_stateless_dec_fmt_list[type][idx];
+
+exit:
+	return fmt;
+}
+
+static struct v4l2_ctrl *stateless_find_control(struct vpu_instance *inst,
+						u32 id)
+{
+	struct v4l2_ctrl_handler *hdl = &inst->v4l2_ctrl_hdl;
+
+	return v4l2_ctrl_find(hdl, id);
+}
+#if 0
+static u32 stateless_print_control_param(struct vpu_instance *inst, u32 id)
+{
+	struct v4l2_ctrl *ctrl;
+
+	ctrl = stateless_find_control(inst, id);
+	if (ctrl) {
+		pr_err("nr_of_dims %d, elems %d, elem_size %d", ctrl->nr_of_dims, ctrl->elems, ctrl->elem_size);
+	}
+
+	return 0;
+}
+#endif
+static u32 stateless_find_control_elems(struct vpu_instance *inst, u32 id)
+{
+	struct v4l2_ctrl *ctrl;
+	u32 cnt = 0;
+
+	ctrl = stateless_find_control(inst, id);
+	if (ctrl)
+		cnt = ctrl->elems;
+
+	return cnt;
+}
+
+static void *stateless_find_control_data(struct vpu_instance *inst, u32 id)
+{
+	struct v4l2_ctrl *ctrl;
+	void *data = NULL;
+
+	ctrl = stateless_find_control(inst, id);
+	if (ctrl)
+		data = ctrl->p_cur.p;
+
+	return data;
+}
+
+static void memset_volatile(volatile void *dest, char val, size_t len)
+{
+	volatile char *ptr = dest;
+	while (len-- > 0) {
+		*ptr++ = val;
+	}
+}
+
+static struct vpu_instance *fh_to_inst(struct v4l2_fh *fh)
+{
+	struct vpu_instance *inst =
+		container_of(fh, struct vpu_instance, v4l2_fh);
+	return inst;
+}
+
+static enum VIDEO_STREAM_TYPE
+rtkve_dec_to_vpu_str_type(unsigned int v4l2_pix_fmt)
+{
+	enum VIDEO_STREAM_TYPE type = 0xFFFF;
+
+	switch (v4l2_pix_fmt) {
+	case V4L2_PIX_FMT_HEVC_SLICE:
+		type = VIDEO_STREAM_H265;
+		break;
+	case V4L2_PIX_FMT_VP9_FRAME:
+		type = VIDEO_STREAM_VP9;
+		break;
+	case V4L2_PIX_FMT_AV1_FRAME:
+		type = VIDEO_STREAM_AV1;
+		break;
+	default:
+		pr_err("unsupport codec! %p4cc\n", &v4l2_pix_fmt);
+		break;
+	}
+	return type;
+}
+
+static uint32_t rtkve_dec_get_ctrl_info_size(struct vpu_instance *inst)
+{
+	uint32_t size = 0;
+
+	switch (inst->std) {
+	case VIDEO_STREAM_H265:
+		size = rtkve_get_hevc_ctrl_size();
+		dev_dbg(inst->dev->dev, "%s, HEVC size %d", __func__, size);
+		break;
+	case VIDEO_STREAM_VP9:
+		size = rtkve_get_vp9_ctrl_size();
+		dev_dbg(inst->dev->dev, "%s, VP9 size %d", __func__, size);
+		break;
+	case VIDEO_STREAM_AV1:
+		size = rtkve_get_av1_ctrl_size();
+		dev_dbg(inst->dev->dev, "%s, AV1 size %d", __func__, size);
+		break;
+	default:
+		dev_err(inst->dev->dev, "unknown codec\n");
+	}
+
+	return size;
+}
+
+static int rtkve_sl_dec_create_instance(struct vpu_instance *inst)
+{
+	uint32_t ctrl_size;
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: enter\n", __func__);
+
+	inst->std = rtkve_dec_to_vpu_str_type(inst->src_fmt.pixelformat);
+	if (inst->std == 0xFFFF) {
+		dev_err(inst->dev->dev, "unsupported pixelformat: %.4s\n",
+			(char *)&inst->src_fmt.pixelformat);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	ret = rtkve_rpc_create_flash(inst);
+	if (ret) {
+		dev_err(inst->dev->dev, "create flash fail\n");
+		goto exit;
+	}
+
+	ctrl_size = rtkve_dec_get_ctrl_info_size(inst) * CTRL_RINGBUF_NUM;
+	ret = rtkve_rpc_create_decoder(inst, ctrl_size);
+	if (ret) {
+		dev_err(inst->dev->dev, "create flash fail\n");
+		goto exit;
+	}
+
+	ret = rtkve_rpc_connect(inst->dec_hdl, inst->flash_hdl);
+	if (ret) {
+		dev_err(inst->dev->dev, "connect fail\n");
+		goto exit;
+	}
+
+	ret = rtkve_rpc_set_role(inst->dec_hdl, inst->std);
+	if (ret) {
+		dev_err(inst->dev->dev, "set role fail\n");
+		goto exit;
+	}
+#ifdef INFORM_DROP
+	ret = rtkve_rpc_enable_drop_cnt(inst->dec_hdl);
+	if (ret) {
+		dev_err(inst->dev->dev, "set drop cnt fail\n");
+		goto exit;
+	}
+
+	memset(inst->drop_timestamp, MEANINGLESS, sizeof(inst->drop_timestamp));
+	INIT_LIST_HEAD(&inst->pts_mapping_list);
+	mutex_init(&inst->pts_mutex);
+#endif
+	ret = rtkve_rpc_set_cmprs(inst->dec_hdl, 0);
+	if (ret) {
+		dev_err(inst->dev->dev, "set cmprs fail\n");
+		goto exit;
+	}
+
+	INIT_LIST_HEAD(&inst->srcbuf_list);
+	INIT_LIST_HEAD(&inst->dstbuf_list);
+	spin_lock_init(&inst->srcbuf_lock);
+	spin_lock_init(&inst->dstbuf_lock);
+
+	inst->state = VPU_INST_STATE_OPEN;
+exit:
+	return ret;
+}
+
+static void rtkve_sl_dec_destroy_instance(struct vpu_instance *inst)
+{
+	struct vpu_handler *flash_hndl = inst->flash_hdl;
+	struct vpu_handler *dec_hndl = inst->dec_hdl;
+	int ret = 0;
+
+	if (!inst || !flash_hndl || !dec_hndl) {
+		goto exit;
+	}
+
+	ret = rtkve_rpc_stop(flash_hndl);
+	if (ret) {
+		dev_err(inst->dev->dev, "failed destroy flash instance: %d\n",
+			ret);
+	}
+	flash_hndl->is_running = false;
+
+	ret = rtkve_rpc_stop(dec_hndl);
+	if (ret) {
+		dev_err(inst->dev->dev, "failed destroy decode instance: %d\n",
+			ret);
+	}
+	dec_hndl->is_running = false;
+
+	if (inst->input_thread) {
+		wake_up_interruptible(&inst->input_waitq);
+		kthread_stop(inst->input_thread);
+		inst->input_thread = NULL;
+	}
+
+	ret = rtkve_rpc_destroy_flash(inst);
+	if (ret) {
+		dev_err(inst->dev->dev, "failed destroy flash instance: %d\n",
+			ret);
+	}
+
+	ret = rtkve_rpc_destroy_decoder(inst);
+	if (ret) {
+		dev_err(inst->dev->dev, "failed destroy dec instance: %d\n",
+			ret);
+	}
+
+#ifdef INFORM_DROP
+	{
+		struct pts_mapping *entry = NULL;
+		struct pts_mapping *tmp_entry = NULL;
+		mutex_lock(&inst->pts_mutex);
+		list_for_each_entry_safe (entry, tmp_entry, &inst->pts_mapping_list,
+					  list) {
+			list_del(&entry->list);
+			kfree(entry);
+		}
+		mutex_unlock(&inst->pts_mutex);
+	}
+#endif
+exit:
+	return;
+}
+
+static void rtkve_sl_dec_suspend(struct vpu_instance *inst)
+{
+	rtkve_rpc_suspend(inst);
+}
+
+static void rtkve_sl_dec_resume(struct vpu_instance *inst)
+{
+	struct vpu_handler *flash_hndl = inst->flash_hdl;
+	struct vpu_handler *dec_hndl = inst->dec_hdl;
+	int ret = 0;
+
+	if (flash_hndl->is_running) {
+		ret = rtkve_rpc_run(flash_hndl);
+		if (ret) {
+			dev_err(inst->dev->dev, "rtkve_rpc_run flash_hdl fail\n");
+			goto exit;
+		}
+	}
+
+	if (dec_hndl->is_running) {
+		ret = rtkve_rpc_run(dec_hndl);
+		if (ret) {
+			dev_err(inst->dev->dev, "rtkve_rpc_run dec_hdl fail\n");
+			goto exit;
+		}
+	}
+
+exit:
+	return;
+}
+
+static void rtkve_sl_dec_buf_queue_src(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct vpu_instance *inst = vb2_get_drv_priv(vb->vb2_queue);
+	struct vpu_buffer *src_buf = rtkve_to_vpu_buf(vbuf);
+	unsigned long flags;
+
+	dev_dbg(inst->dev->dev,
+		"type %4d index %4d size[0] %4ld size[1] : %4ld | size[2] : %4ld\n",
+		vb->type, vb->index, vb2_plane_size(&vbuf->vb2_buf, 0),
+		vb2_plane_size(&vbuf->vb2_buf, 1),
+		vb2_plane_size(&vbuf->vb2_buf, 2));
+
+	vbuf->sequence = inst->queued_src_buf_num++;
+
+	v4l2_m2m_buf_queue(inst->v4l2_fh.m2m_ctx, vbuf);
+	spin_lock_irqsave(&inst->srcbuf_lock, flags);
+	list_add_tail(&src_buf->list, &inst->srcbuf_list);
+	spin_unlock_irqrestore(&inst->srcbuf_lock, flags);
+
+	wake_up_interruptible(&inst->input_waitq);
+	if (inst->state == VPU_INST_STATE_PIC_RUN)
+		wake_up_interruptible(&inst->output_waitq);
+}
+
+static struct vpu_buffer *rtkve_sl_dec_next_srcbuf(struct vpu_instance *inst,
+				   bool check_consume)
+{
+	struct vpu_buffer *b = NULL;
+	unsigned long flags;
+	bool is_found = 0;
+
+	spin_lock_irqsave(&inst->srcbuf_lock, flags);
+	if (list_empty(&inst->srcbuf_list)) {
+		spin_unlock_irqrestore(&inst->srcbuf_lock, flags);
+		goto exit;
+	}
+
+	list_for_each_entry (b, &inst->srcbuf_list, list) {
+		if (b && ((check_consume && b->consumed == false) ||
+			(!check_consume))) {
+			is_found = 1;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&inst->srcbuf_lock, flags);
+exit:
+	return (is_found ? b : NULL);
+}
+
+static struct vb2_v4l2_buffer *rtkve_sl_dec_remove_srcbuf(struct vpu_instance *inst,
+				   struct vpu_buffer *buf)
+{
+	struct vpu_buffer *b = NULL;
+	struct vpu_buffer *b_tmp = NULL;
+	unsigned long flags;
+	bool is_found = 0;
+
+	spin_lock_irqsave(&inst->srcbuf_lock, flags);
+	list_for_each_entry_safe (b, b_tmp, &inst->srcbuf_list,
+		list) {
+		if (buf == b) {
+			b->consumed = false;
+			list_del(&b->list);
+			is_found = 1;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&inst->srcbuf_lock, flags);
+
+	return (is_found ? &b->v4l2_m2m_buf.vb : NULL);
+}
+
+static void rtkve_sl_dec_return_srcbuf(struct vpu_instance *inst)
+{
+	struct vpu_buffer *vpu_src = rtkve_sl_dec_next_srcbuf(inst, false);
+	unsigned long flags;
+
+	while(vpu_src) {
+		spin_lock_irqsave(&inst->srcbuf_lock, flags);
+		vpu_src->referenced = false;
+		spin_unlock_irqrestore(&inst->srcbuf_lock, flags);
+
+		rtkve_sl_dec_remove_srcbuf(inst, vpu_src);
+		vpu_src = rtkve_sl_dec_next_srcbuf(inst, false);
+	}
+}
+
+static void rtkve_sl_dec_add_mesg(struct vpu_handler *hndl)
+{
+	volatile struct rtkve_flash_frame_info_t *frame;
+	struct vpu_flash_info *info = &hndl->flash;
+	struct rtkve_ringbuf_t *prb;
+	uint32_t frm_idx = 0;
+
+	prb = &info->mesg_rb;
+	if (!prb) {
+		pr_err("%s ringbuffer isn't ready\n", __func__);
+		goto exit;
+	}
+
+	mutex_lock(&prb->lock);
+
+	frm_idx = hndl->flash.outputRingIdx++;
+	if (hndl->flash.outputRingIdx >= RTKVE_MAX_DPB_NUM)
+		hndl->flash.outputRingIdx = 0;
+
+	frame = (volatile struct rtkve_flash_frame_info_t *)
+			hndl->flash.frame[frm_idx];
+
+
+	memset_volatile(frame, 0, sizeof(struct rtkve_flash_frame_info_t));
+	frame->nPicFlags = 0;
+	frame->nPicWidth = PIC_SIZE_INVALID;
+	frame->nPicHeight = PIC_SIZE_INVALID;
+	frame->nClkTimeHigh = -1;
+	frame->nClkTimeLow = -1;
+	frame->pUserData = true;
+	mutex_unlock(&prb->lock);
+
+	dsb(sy);
+exit:
+	return;
+}
+
+static int rtkve_sl_dec_queue_msg_queue(struct vpu_instance *inst,
+					struct vb2_buffer *vb)
+{
+	rtkve_sl_dec_add_mesg(inst->flash_hdl);
+	return 0;
+}
+
+static void rtkve_sl_dec_buf_queue_dst(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct vpu_buffer *dst_buf = rtkve_to_vpu_buf(vbuf);
+	struct vpu_instance *inst = vb2_get_drv_priv(vb->vb2_queue);
+	unsigned long flags;
+
+	dev_dbg(inst->dev->dev,
+		"type %4d index %4d size[0] %4ld size[1] : %4ld | size[2] : %4ld\n",
+		vb->type, vb->index, vb2_plane_size(&vbuf->vb2_buf, 0),
+		vb2_plane_size(&vbuf->vb2_buf, 1),
+		vb2_plane_size(&vbuf->vb2_buf, 2));
+
+	vbuf->sequence = inst->queued_dst_buf_num++;
+	v4l2_m2m_buf_queue(inst->v4l2_fh.m2m_ctx, vbuf);
+	spin_lock_irqsave(&inst->dstbuf_lock, flags);
+	list_add_tail(&dst_buf->list, &inst->dstbuf_list);
+	spin_unlock_irqrestore(&inst->dstbuf_lock, flags);
+
+	rtkve_sl_dec_queue_msg_queue(inst, vb);
+}
+
+static void rtkve_sl_dec_return_buffer(struct vb2_queue *vq, u32 state)
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(vq);
+	struct vb2_v4l2_buffer *vbuf;
+
+	for (;;) {
+		if (V4L2_TYPE_IS_OUTPUT(vq->type))
+			vbuf = v4l2_m2m_src_buf_remove(inst->v4l2_fh.m2m_ctx);
+		else
+			vbuf = v4l2_m2m_dst_buf_remove(inst->v4l2_fh.m2m_ctx);
+
+		if (!vbuf)
+			break;
+
+		if (vbuf->vb2_buf.req_obj.req)
+			v4l2_ctrl_request_complete(vbuf->vb2_buf.req_obj.req,
+						   &inst->v4l2_ctrl_hdl);
+
+		v4l2_m2m_buf_done(vbuf, state);
+
+		dev_dbg(inst->dev->dev, "Marked request %px as complete\n",
+			vbuf->vb2_buf.req_obj.req);
+	}
+}
+
+static void rtkve_sl_dec_buf_request_complete(struct vb2_buffer *vb)
+{
+	struct vpu_instance *ctx = vb2_get_drv_priv(vb->vb2_queue);
+
+	v4l2_ctrl_request_complete(vb->req_obj.req, &ctx->v4l2_ctrl_hdl);
+}
+
+static int rtkve_sl_dec_queue_setup(struct vb2_queue *q,
+				    unsigned int *num_buffers,
+				    unsigned int *num_planes,
+				    unsigned int sizes[],
+				    struct device *alloc_devs[])
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(q);
+	struct v4l2_pix_format_mplane inst_format =
+		(V4L2_TYPE_IS_OUTPUT(q->type)) ? inst->src_fmt : inst->dst_fmt;
+	unsigned int i;
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%s: num_buffers %d num_planes %d type %d\n",
+		__func__, *num_buffers, *num_planes, q->type);
+
+	if (*num_planes) {
+		if (inst_format.num_planes != *num_planes) {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		for (i = 0; i < *num_planes; i++) {
+			if (sizes[i] < inst_format.plane_fmt[i].sizeimage) {
+				ret = -EINVAL;
+				goto exit;
+			}
+		}
+	} else {
+		*num_planes = inst_format.num_planes;
+		for (i = 0; i < *num_planes; i++) {
+			sizes[i] = inst_format.plane_fmt[i].sizeimage;
+			dev_dbg(inst->dev->dev, "size[%d] : %d\n", i, sizes[i]);
+		}
+	}
+exit:
+	return ret;
+}
+
+static int rtkve_sl_dec_buf_out_validate(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+
+	vbuf->field = V4L2_FIELD_NONE;
+	return 0;
+}
+
+static int rtkve_sl_dec_buf_prepare(struct vb2_buffer *vb)
+{
+	return 0;
+}
+
+static void rtkve_sl_dec_buf_queue(struct vb2_buffer *vb)
+{
+	if (V4L2_TYPE_IS_OUTPUT(vb->type))
+		rtkve_sl_dec_buf_queue_src(vb);
+	else
+		rtkve_sl_dec_buf_queue_dst(vb);
+}
+
+static int rtkve_sl_dec_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(q);
+	int ret = 0;
+
+	dev_info(inst->dev->dev, "%s: type %s, %p4cc\n", __func__,
+		v4l2_type_names[q->type], &inst->src_fmt.pixelformat);
+
+	return ret;
+}
+
+static void rtkve_sl_dec_stop_streaming(struct vb2_queue *q)
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(q);
+	struct v4l2_m2m_ctx *m2m_ctx = inst->v4l2_fh.m2m_ctx;
+
+	dev_info(inst->dev->dev, "%s: type %s\n", __func__, v4l2_type_names[q->type]);
+
+	v4l2_m2m_suspend(inst->dev->m2m_dev);
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		if (inst->input_thread) {
+			kthread_stop(inst->input_thread);
+			wake_up_interruptible(&inst->input_waitq);
+			inst->input_thread = NULL;
+		}
+		rtkve_sl_dec_return_srcbuf(inst);
+	} else {
+		rtkve_sl_dec_return_dstbuf(inst);
+	}
+
+	rtkve_sl_dec_return_buffer(q, VB2_BUF_STATE_ERROR);
+
+	rtkve_sl_dec_stop(inst, q->type);
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
+		inst->queued_src_buf_num = 0;
+	} else {
+		if (v4l2_m2m_has_stopped(m2m_ctx))
+			v4l2_m2m_clear_state(m2m_ctx);
+		inst->state = VPU_INST_STATE_OPEN;
+
+		inst->queued_dst_buf_num = 0;
+	}
+	v4l2_m2m_resume(inst->dev->m2m_dev);
+}
+
+static const struct vb2_ops rtkve_sl_dec_vb2_ops = {
+	.queue_setup = rtkve_sl_dec_queue_setup,
+	.buf_out_validate = rtkve_sl_dec_buf_out_validate,
+	.buf_prepare = rtkve_sl_dec_buf_prepare,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+	.buf_queue = rtkve_sl_dec_buf_queue,
+	.start_streaming = rtkve_sl_dec_start_streaming,
+	.stop_streaming = rtkve_sl_dec_stop_streaming,
+	.buf_request_complete = rtkve_sl_dec_buf_request_complete,
+};
+
+static int rtkve_sl_dec_queue_init(void *priv, struct vb2_queue *src_vq,
+				   struct vb2_queue *dst_vq)
+{
+	struct vpu_instance *inst = priv;
+	int ret;
+
+	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	src_vq->io_modes = VB2_MMAP | VB2_DMABUF;
+	src_vq->mem_ops = &vb2_dma_contig_memops;
+	src_vq->ops = &rtkve_sl_dec_vb2_ops;
+	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	src_vq->buf_struct_size = sizeof(struct vpu_buffer);
+	src_vq->drv_priv = inst;
+	src_vq->lock = &inst->dev->dev_lock;
+	src_vq->dev = inst->dev->v4l2_dev.dev;
+	src_vq->supports_requests = true;
+	ret = vb2_queue_init(src_vq);
+	if (ret)
+		goto exit;
+
+	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	dst_vq->io_modes = VB2_MMAP | VB2_DMABUF;
+	dst_vq->mem_ops = &vb2_dma_contig_memops;
+	dst_vq->ops = &rtkve_sl_dec_vb2_ops;
+	dst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	dst_vq->buf_struct_size = sizeof(struct vpu_buffer);
+	dst_vq->min_buffers_needed = 1;
+	dst_vq->drv_priv = inst;
+	dst_vq->lock = &inst->dev->dev_lock;
+	dst_vq->dev = inst->dev->v4l2_dev.dev;
+	ret = vb2_queue_init(dst_vq);
+	if (ret)
+		goto exit;
+
+exit:
+	return ret;
+}
+
+static void rtkve_sl_dec_handle_src_buf(struct vpu_instance *inst)
+{
+	struct vb2_v4l2_buffer *src_buf;
+	struct vpu_buffer *vpu_buf;
+
+	src_buf = v4l2_m2m_next_src_buf(inst->v4l2_fh.m2m_ctx);
+	if (!src_buf) {
+		dev_info(inst->dev->dev, "not found src buffer \n");
+		goto exit;
+	}
+
+	vpu_buf = rtkve_to_vpu_buf(src_buf);
+	if (!vpu_buf)
+		goto exit;
+
+	rtkve_sl_dec_remove_srcbuf(inst, vpu_buf);
+	src_buf = v4l2_m2m_src_buf_remove(inst->v4l2_fh.m2m_ctx);
+	v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);
+
+exit:
+	return;
+}
+
+static struct vpu_buffer *rtkve_sl_dec_next_dstbuf(struct vpu_instance *inst,
+				   bool check_consume)
+{
+	struct vpu_buffer *b = NULL;
+	unsigned long flags;
+	bool is_found = 0;
+
+	spin_lock_irqsave(&inst->dstbuf_lock, flags);
+	if (list_empty(&inst->dstbuf_list)) {
+		spin_unlock_irqrestore(&inst->dstbuf_lock, flags);
+		goto exit;
+	}
+
+	list_for_each_entry (b, &inst->dstbuf_list, list) {
+		if (b && ((check_consume && b->consumed == false) ||
+			(!check_consume))) {
+			is_found = 1;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&inst->dstbuf_lock, flags);
+exit:
+	return (is_found ? b : NULL);
+}
+
+static struct vb2_v4l2_buffer *rtkve_sl_dec_remove_dstbuf(struct vpu_instance *inst,
+				   struct vpu_buffer *buf)
+{
+	struct vpu_buffer *b = NULL;
+	struct vpu_buffer *b_tmp = NULL;
+	unsigned long flags;
+	bool is_found = 0;
+
+	spin_lock_irqsave(&inst->dstbuf_lock, flags);
+	list_for_each_entry_safe (b, b_tmp, &inst->dstbuf_list,
+		list) {
+		if (buf == b) {
+			b->consumed = false;
+			list_del(&b->list);
+			is_found = 1;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&inst->dstbuf_lock, flags);
+
+	return (is_found ? &b->v4l2_m2m_buf.vb : NULL);
+}
+
+static void rtkve_sl_dec_return_dstbuf(struct vpu_instance *inst)
+{
+	struct vpu_buffer *vpu_dst = rtkve_sl_dec_next_dstbuf(inst, false);
+	unsigned long flags;
+
+	while(vpu_dst) {
+		spin_lock_irqsave(&inst->dstbuf_lock, flags);
+		vpu_dst->referenced = false;
+		spin_unlock_irqrestore(&inst->dstbuf_lock, flags);
+
+		rtkve_sl_dec_remove_dstbuf(inst, vpu_dst);
+		vpu_dst = rtkve_sl_dec_next_dstbuf(inst, false);
+	}
+}
+
+static int rtkve_sl_dec_get_rb_space(struct rtkve_ringbuf_t *ringbuf, char bRead,
+				 char bAtom)
+{
+	volatile struct rtkve_ringbuf_t *rb = ringbuf;
+	unsigned int wp, rp, space;
+
+	if (!ringbuf) {
+		pr_err("invaild input ringbuf %p", ringbuf);
+		return -EPERM;
+	}
+	mutex_lock(&ringbuf->lock);
+	wp = htonl(rb->pRBH->writePtr);
+	rp = htonl(rb->pRBH->readPtr[0]);
+	if (bRead) {
+		space = (rp > wp) ? (wp + rb->size - rp) :
+				    (wp - rp);
+	} else {
+		if (bAtom && rp <= wp) {
+			int s1 = rb->phyaddr + rb->size - wp - 1;
+			int s2 = rp - rb->phyaddr - 1;
+			space = (s1 > s2) ? s1 : s2;
+		} else {
+			space = (rp > wp) ? (rp - wp - 1) :
+					    (rp + rb->size - wp - 1);
+		}
+	}
+	dsb(sy);
+	mutex_unlock(&ringbuf->lock);
+
+	return space;
+}
+
+static int rtkve_sl_dec_write_bs(struct vpu_handler *hndl, uint8_t *buf,
+			     uint32_t len, u32 seq)
+{
+	struct rtkve_ringbuf_t *bs_ringbuf = &hndl->dec.bs_rb;
+	struct rtkve_ringbuf_t *inband_ringbuf = &hndl->dec.inband_rb;
+	int space = 0;
+	int ret = 0;
+
+	space = rtkve_sl_dec_get_rb_space(bs_ringbuf, 0, 1);
+	if (space < len) {
+		dev_err(hndl->dev, "bitstream buffer is too small %d, %d\n",
+			space, len);
+		ret = -ENOSPC;
+		goto exit;
+	}
+
+	space = rtkve_sl_dec_get_rb_space(inband_ringbuf, 0, 1);
+	if (space < 512) {
+		dev_err(hndl->dev, "inband buffer is too small %d\n", space);
+		ret = -ENOSPC;
+		goto exit;
+	}
+
+	dev_dbg(hndl->dev, "rtkve_sl_dec_write_bs, len %d", len);
+	ret = rtkve_write_rb(bs_ringbuf, RINGBUFFER_STREAM, buf, len);
+	if (ret) {
+		dev_err(hndl->dev, "rtkve_write_rb RINGBUFFER_STREAM fail %d\n",
+			ret);
+		ret = -EFAULT;
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+static struct vb2_v4l2_buffer *
+rtkve_sl_dec_get_dstbuf_by_addr(struct vpu_instance *inst, dma_addr_t addr)
+{
+	struct vb2_v4l2_buffer *vb2_v4l2_buf;
+	struct v4l2_m2m_buffer *v4l2_m2m_buf;
+	struct vb2_v4l2_buffer *dst_buf = NULL;
+
+	v4l2_m2m_for_each_dst_buf (inst->v4l2_fh.m2m_ctx, v4l2_m2m_buf) {
+		vb2_v4l2_buf = &v4l2_m2m_buf->vb;
+		if (addr ==
+		    vb2_dma_contig_plane_dma_addr(&vb2_v4l2_buf->vb2_buf, 0)) {
+			dst_buf = vb2_v4l2_buf;
+			break;
+		}
+	}
+	return dst_buf;
+}
+
+#ifdef INFORM_DROP
+static bool rtkve_sl_dec_remove_from_list_by_addr(struct vpu_instance *inst,
+			     dma_addr_t addr)
+{
+	struct pts_mapping *entry = NULL;
+	struct pts_mapping *tmp_entry = NULL;
+	bool is_found = false;
+
+	mutex_lock(&inst->pts_mutex);
+	list_for_each_entry_safe (entry, tmp_entry, &inst->pts_mapping_list,
+				  list) {
+		if (entry && entry->y_addr == addr) {
+			is_found = true;
+			list_del(&entry->list);
+			kfree(entry);
+			break;
+		}
+	}
+	mutex_unlock(&inst->pts_mutex);
+
+	return is_found;
+}
+
+static struct vb2_v4l2_buffer *
+rtkve_sl_dec_get_dstbuf_by_timestamp(struct vpu_instance *inst,
+			     u32 timestamp)
+{
+	struct pts_mapping *entry = NULL;
+	struct pts_mapping *tmp_entry = NULL;
+	dma_addr_t addr;
+	bool is_found = false;
+
+	mutex_lock(&inst->pts_mutex);
+	list_for_each_entry_safe (entry, tmp_entry, &inst->pts_mapping_list,
+				  list) {
+		if (entry && entry->pts == timestamp) {
+			addr = entry->y_addr;
+			is_found = true;
+			list_del(&entry->list);
+			kfree(entry);
+			break;
+		}
+	}
+	mutex_unlock(&inst->pts_mutex);
+
+	return (is_found ? rtkve_sl_dec_get_dstbuf_by_addr(inst, addr) : NULL);
+}
+#endif
+
+static int rtkve_sl_dec_get_result(struct vpu_instance *inst,
+				   struct vpu_flash_info *info, int frm_idx,
+				   struct dec_output_info *result)
+{
+	volatile struct rtkve_flash_frame_info_t *frame;
+#ifdef INFORM_DROP
+	uint32_t nVersion = 0;
+#endif
+
+	frame = (volatile struct rtkve_flash_frame_info_t *)info->frame[frm_idx];
+	dsb(sy);
+
+	result->buf_addr_y = htonl(frame->nPicPhysicalAddr);
+	result->buf_addr_c = htonl(frame->nPicCPhysicalAddr);
+
+#ifdef INFORM_DROP
+	nVersion = htonl(frame->nVersion);
+	if (nVersion == 0x8001) {
+		int i = 0;
+
+		inst->drop_cnt = htonl(frame->noShowFrame_count);
+		for (i=0; i < inst->drop_cnt; i++) {
+			inst->drop_timestamp[i] = htonl(frame->noShowFrame_picId[i]);
+		}
+		result->drop_timestamp = inst->drop_timestamp[0];
+		inst->drop_timestamp[0] = MEANINGLESS;
+		inst->drop_cnt --;
+	} else
+#endif
+	{
+		result->drop_timestamp = MEANINGLESS;
+	}
+	return 0;
+}
+
+static int rtkve_sl_check_wrptr(struct rtkve_ringbuf_t *prb)
+{
+	int ret = 0;
+	mutex_lock(&prb->lock);
+	if (prb->pRBH->readPtr[0] != prb->pRBH->writePtr)
+		ret = 1;
+	mutex_unlock(&prb->lock);
+	return ret;
+}
+
+static int rtkve_sl_dec_get_dispbuf(struct vpu_instance *inst,
+				 struct vpu_handler *hndl, struct dec_output_info *dec_info)
+{
+	struct vpu_flash_info *info = &hndl->flash;
+	struct rtkve_ringbuf_t *prb;
+	int ret = 0;
+
+	prb = &info->mesg_rb;
+
+	if (prb->pRBH) {
+		int val = 0;
+		val = wait_event_interruptible_timeout(
+			inst->output_waitq,
+			kthread_should_stop() ||
+			rtkve_sl_check_wrptr(prb),
+			msecs_to_jiffies(10));
+		if (!val) {
+			ret = -EAGAIN;
+			goto exit;
+#ifdef INFORM_DROP
+		} else if (inst->drop_cnt) {
+			int i = 0;
+
+			for (i = 0; i < DROP_CNT_MAX; i++) {
+				if (inst->drop_timestamp[i] != MEANINGLESS) {
+					dec_info->drop_timestamp = inst->drop_timestamp[i];
+					inst->drop_timestamp[i] = MEANINGLESS;
+					inst->drop_cnt--;
+					break;
+				}
+			}
+			goto exit;
+#endif
+		} else {
+			int rp_idx;
+			uint32_t next_rp;
+
+			mutex_lock(&prb->lock);
+			rp_idx = (htonl(prb->pRBH->readPtr[0]) -
+				  htonl(prb->pRBH->beginAddr)) /
+				 sizeof(struct rtkve_flash_frame_info_t);
+
+			rtkve_sl_dec_get_result(inst, info, rp_idx, dec_info);
+
+			next_rp = htonl(prb->pRBH->readPtr[0]) + sizeof(struct rtkve_flash_frame_info_t);
+			if (next_rp < prb->limit)
+				prb->pRBH->readPtr[0] = htonl(next_rp);
+			else
+				prb->pRBH->readPtr[0] = prb->pRBH->beginAddr;
+			dsb(sy);
+			mutex_unlock(&prb->lock);
+		}
+	} else {
+		pr_err("wrong ringbuffer header\n");
+	}
+exit:
+	return ret;
+}
+
+static void rtkve_sl_dec_handle_dst_buf(struct vpu_instance *inst,
+					      dma_addr_t addr, enum vb2_buffer_state state,
+					      u32 timestamp)
+{
+	struct vb2_v4l2_buffer *dst_buf;
+	struct vpu_buffer *vpu_dst;
+
+#ifdef INFORM_DROP
+	if (state != VB2_BUF_STATE_ERROR) {
+		dst_buf = rtkve_sl_dec_get_dstbuf_by_addr(inst, addr);
+		if (!dst_buf) {
+			dev_err(inst->dev->dev, "not found dsiplay buffer\n");
+			goto exit;
+		}
+
+		{
+			bool ret = 0;
+			ret = rtkve_sl_dec_remove_from_list_by_addr(inst, addr);
+			if (!ret)
+				dev_err(inst->dev->dev, "not found timestamp mapping buffer\n");
+		}
+	} else {
+		dst_buf = rtkve_sl_dec_get_dstbuf_by_timestamp(inst, timestamp);
+		if (!dst_buf) {
+			dev_err(inst->dev->dev, "not found dsiplay buffer: timestamp %d\n", timestamp);
+			goto exit;
+		}
+	}
+#else
+	dst_buf = rtkve_sl_dec_get_dstbuf_by_addr(inst, addr);
+	if (!dst_buf) {
+		dev_err(inst->dev->dev, "not found dsiplay buffer\n");
+		goto exit;
+	}
+#endif
+
+	if (inst->dst_fmt.num_planes == 1) {
+		vb2_set_plane_payload(&dst_buf->vb2_buf, 0,
+				      inst->dst_fmt.plane_fmt[0].sizeimage);
+	} else if (inst->dst_fmt.num_planes == 2) {
+		if (state != VB2_BUF_STATE_ERROR) {
+			vb2_set_plane_payload(&dst_buf->vb2_buf, 0,
+					      inst->dst_fmt.plane_fmt[0].sizeimage);
+			vb2_set_plane_payload(&dst_buf->vb2_buf, 1,
+					      inst->dst_fmt.plane_fmt[1].sizeimage);
+		} else {
+			vb2_set_plane_payload(&dst_buf->vb2_buf, 0,
+					      0);
+			vb2_set_plane_payload(&dst_buf->vb2_buf, 1,
+					      0);
+		}
+	}
+
+	dst_buf->field = V4L2_FIELD_NONE;
+
+	vpu_dst = rtkve_to_vpu_buf(dst_buf);
+	rtkve_sl_dec_remove_dstbuf(inst, vpu_dst);
+	v4l2_m2m_dst_buf_remove_by_buf(inst->v4l2_fh.m2m_ctx, dst_buf);
+	v4l2_m2m_buf_done(dst_buf, state);
+
+exit:
+	return;
+}
+
+static int rtkve_sl_dec_prepare_ctrl(struct vpu_instance *inst,
+			      struct media_request *src_req, struct dec_param *pic_param)
+{
+	struct vpu_handler *hndl = inst->dec_hdl;
+	struct rtkve_ringbuf_t *ctrl_rb = &hndl->dec.ctrl_info_rb;
+	struct stateless_info info = {};
+	void *wptr = NULL;
+	int ret = 0;
+
+	if (!src_req) {
+		ret = -EINVAL;
+		dev_err(inst->dev->dev, "%s, src_req is NULL !!", __func__);
+		goto exit;
+	}
+
+	v4l2_ctrl_request_setup(src_req, &inst->v4l2_ctrl_hdl);
+
+	switch (inst->std) {
+	case VIDEO_STREAM_H265:
+		info.hevc.sps = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_HEVC_SPS);
+		info.hevc.pps = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_HEVC_PPS);
+		info.hevc.sm = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_HEVC_SCALING_MATRIX);
+		info.hevc.spram = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_HEVC_SLICE_PARAMS);
+		info.hevc.spram_cnt = stateless_find_control_elems(
+			inst, V4L2_CID_STATELESS_HEVC_SLICE_PARAMS);
+		info.hevc.dpram = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_HEVC_DECODE_PARAMS);
+		break;
+	case VIDEO_STREAM_VP9:
+		info.vp9.frame = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_VP9_FRAME);
+		info.vp9.cmprs_hdr = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_VP9_COMPRESSED_HDR);
+		break;
+	case VIDEO_STREAM_AV1:
+		info.av1.seq = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_AV1_SEQUENCE);
+		info.av1.frm = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_AV1_FRAME);
+		info.av1.film_grain = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_AV1_FILM_GRAIN);
+		info.av1.tge = stateless_find_control_data(
+			inst, V4L2_CID_STATELESS_AV1_TILE_GROUP_ENTRY);
+		info.av1.tge_cnt = stateless_find_control_elems(
+			inst, V4L2_CID_STATELESS_AV1_TILE_GROUP_ENTRY);
+		break;
+	default:
+		break;
+	}
+
+	mutex_lock(&ctrl_rb->lock);
+	wptr = ctrl_rb->virtaddr +
+		(htonl(ctrl_rb->pRBH->writePtr) - ctrl_rb->phyaddr);
+	mutex_unlock(&ctrl_rb->lock);
+
+	dev_dbg(inst->dev->dev, "%s ctrl y addr %pad\n", __func__, &pic_param->buf_addr_y);
+
+	switch (inst->std) {
+	case VIDEO_STREAM_H265:
+		rtkve_setup_hevc_ctrl_info(inst, (void *)&info.hevc,
+					   pic_param, (void *)wptr);
+		break;
+	case VIDEO_STREAM_VP9:
+		rtkve_setup_vp9_ctrl_info(inst, (void *)&info.vp9, pic_param,
+					  (void *)wptr);
+		break;
+	case VIDEO_STREAM_AV1:
+		rtkve_setup_av1_ctrl_info(inst, (void *)&info.av1, pic_param,
+					  (void *)wptr);
+		break;
+	default:
+		dev_err(inst->dev->dev, "unknown codec\n");
+		ret = -EINVAL;
+	}
+exit:
+	return ret;
+}
+
+static int rtkve_sl_dec_prepare_bs(struct vpu_instance *inst,
+			      struct vb2_v4l2_buffer *src_buf, struct dec_param *pic_param)
+{
+	u64 timestamp = 0;
+	uint32_t ori_bs_wptr = 0;
+	int src_size = 0;
+	u8 *src_addr = NULL;
+	struct rtkve_ringbuf_t *bs_ringbuf = &inst->dec_hdl->dec.bs_rb;
+	int ret = 0;
+
+	if (!src_buf) {
+		ret = -EINVAL;
+		dev_err(inst->dev->dev, "%s, src_buf is NULL !!", __func__);
+		goto exit;
+	}
+
+	src_addr = vb2_plane_vaddr(&src_buf->vb2_buf, 0);
+	timestamp = src_buf->vb2_buf.timestamp;
+	src_size = vb2_get_plane_payload(&src_buf->vb2_buf, 0);
+	ori_bs_wptr = htonl(bs_ringbuf->pRBH->writePtr);
+	ret = rtkve_sl_dec_write_bs(inst->dec_hdl, src_addr, src_size,
+				src_buf->sequence);
+	if (ret < 0)
+		goto exit;
+
+	pic_param->bs_len = src_size;
+	pic_param->wPtr = ori_bs_wptr;
+	pic_param->PTSH = timestamp >> 32;
+	pic_param->PTSL = timestamp & 0xFFFFFFFF;
+
+exit:
+	return ret;
+}
+
+static int rtkve_sl_dec_prepare_dst(struct vpu_instance *inst,
+			      struct vb2_v4l2_buffer *dst_buf, struct dec_param *pic_param)
+{
+	dma_addr_t buf_addr_y = 0, buf_addr_c = 0;
+	unsigned long flags;
+	struct vpu_buffer *vpu_dst;
+	u32 luma_size = inst->dst_fmt.width * inst->dst_fmt.height;
+	int ret = 0;
+
+	if (!dst_buf) {
+		ret = -EINVAL;
+		dev_err(inst->dev->dev, "%s, dst_buf is NULL !!", __func__);
+		goto exit;
+	}
+
+	if (inst->dst_fmt.num_planes == 1) {
+		buf_addr_y = vb2_dma_contig_plane_dma_addr(
+			&dst_buf->vb2_buf, 0);
+		buf_addr_c = buf_addr_y + luma_size;
+	} else if (inst->dst_fmt.num_planes == 2) {
+		buf_addr_y = vb2_dma_contig_plane_dma_addr(
+			&dst_buf->vb2_buf, 0);
+		buf_addr_c = vb2_dma_contig_plane_dma_addr(
+			&dst_buf->vb2_buf, 1);
+	}
+
+	pic_param->buf_addr_y = buf_addr_y;
+	pic_param->buf_addr_c = buf_addr_c;
+
+	vpu_dst = rtkve_to_vpu_buf(dst_buf);
+	spin_lock_irqsave(&inst->dstbuf_lock, flags);
+	if (vpu_dst->referenced) {
+		pic_param->pre_PTSH = dst_buf->vb2_buf.timestamp >> 32;
+		pic_param->pre_PTSL =
+			dst_buf->vb2_buf.timestamp & 0xFFFFFFFF;
+	} else {
+		pic_param->pre_PTSH = MEANINGLESS;
+		pic_param->pre_PTSL = MEANINGLESS;
+		vpu_dst->referenced = true;
+	}
+	spin_unlock_irqrestore(&inst->dstbuf_lock, flags);
+#ifdef INFORM_DROP
+	{
+		struct pts_mapping *p = (struct pts_mapping *)kmalloc(
+					sizeof(struct pts_mapping), GFP_KERNEL | __GFP_ZERO);
+		if (!p) {
+			dev_err(inst->dev->dev, "malloc pts mapping fail\n");
+			ret = -ENOMEM;
+			goto exit;
+		}
+		p->pts = pic_param->PTSL;
+		p->y_addr = pic_param->buf_addr_y;
+		mutex_lock(&inst->pts_mutex);
+		list_add_tail(&p->list, &inst->pts_mapping_list);
+		mutex_unlock(&inst->pts_mutex);
+	}
+#endif
+exit:
+	return ret;
+}
+
+static int rtkve_sl_dec_prepare_input(struct vpu_instance *inst)
+{
+	struct vpu_buffer *vpu_src, *vpu_dst;
+	struct vb2_v4l2_buffer *src_buf, *dst_buf;
+	struct media_request *src_req;
+	struct dec_param pic_param;
+	unsigned long flags;
+	int ret = 0;
+
+	vpu_src = rtkve_sl_dec_next_srcbuf(inst, true);
+	if (!vpu_src) {
+		ret = -EAGAIN;
+		goto exit;
+	}
+
+	vpu_dst = rtkve_sl_dec_next_dstbuf(inst, true);
+	if (!vpu_dst) {
+		ret = -EAGAIN;
+		goto exit;
+	}
+
+	dst_buf = &vpu_dst->v4l2_m2m_buf.vb;
+	src_buf = &vpu_src->v4l2_m2m_buf.vb;
+	src_req = src_buf->vb2_buf.req_obj.req;
+
+	ret = rtkve_sl_dec_prepare_bs(inst, src_buf, &pic_param);
+	if (ret < 0)
+		goto exit;
+
+	ret = rtkve_sl_dec_prepare_dst(inst, dst_buf, &pic_param);
+	if (ret < 0)
+		goto exit;
+	ret = rtkve_sl_dec_prepare_ctrl(inst, src_req, &pic_param);
+	if (ret < 0)
+		goto exit;
+
+	spin_lock_irqsave(&inst->srcbuf_lock, flags);
+	vpu_src->consumed = true;
+	spin_unlock_irqrestore(&inst->srcbuf_lock, flags);
+
+	spin_lock_irqsave(&inst->dstbuf_lock, flags);
+	vpu_dst->consumed = true;
+	spin_unlock_irqrestore(&inst->dstbuf_lock, flags);
+	wake_up_interruptible(&inst->output_waitq);
+exit:
+	return ret;
+}
+
+static int rtkve_sl_dec_has_resource(struct vpu_instance *inst)
+{
+	struct vpu_buffer *vpu_src = NULL;
+	struct vpu_buffer *vpu_dst = NULL;
+	int ret = 0;
+
+	vpu_src = rtkve_sl_dec_next_srcbuf(inst, true);
+	if(!vpu_src)
+		goto exit;
+
+	vpu_dst = rtkve_sl_dec_next_dstbuf(inst, true);
+	if(!vpu_dst)
+		goto exit;
+
+	ret = 1;
+exit:
+	return ret;
+}
+
+static int input_thread(void *data)
+{
+	struct v4l2_fh *fh = (struct v4l2_fh *)data;
+	struct vpu_instance *inst = fh_to_inst(fh);
+	int ret = 0;
+
+	while (1) {
+		ret = wait_event_interruptible_timeout(
+			inst->input_waitq,
+			kthread_should_stop() ||
+			rtkve_sl_dec_has_resource(inst),
+			msecs_to_jiffies(10));
+
+		if (kthread_should_stop() || (ret == -ERESTART)) {
+			ret = 1;
+			break;
+		} else if (ret == 0) {
+			continue;
+		}
+
+		ret = rtkve_sl_dec_prepare_input(inst);
+		if (ret != 0)
+			continue;
+	}
+	return ret;
+}
+
+static int rtkve_sl_dec_start(struct vpu_instance *inst)
+{
+	int ret = 0;
+
+	ret = rtkve_inband_newseg(inst->dec_hdl);
+	if (ret) {
+		dev_err(inst->dev->dev, "rtkve_inband_newseg fail\n");
+		goto exit;
+	}
+
+	ret = rtkve_inband_decode(inst->dec_hdl, NORMAL_DECODE);
+	if (ret) {
+		dev_err(inst->dev->dev, "rtkve_inband_decode fail\n");
+		goto exit;
+	}
+
+	ret = rtkve_rpc_run(inst->flash_hdl);
+	if (ret) {
+		dev_err(inst->dev->dev, "rtkve_rpc_run flash_hdl fail\n");
+		goto exit;
+	}
+	inst->flash_hdl->is_running = true;
+
+	ret = rtkve_rpc_run(inst->dec_hdl);
+	if (ret) {
+		dev_err(inst->dev->dev, "rtkve_rpc_run dec_hdl fail\n");
+		goto exit;
+	}
+	inst->dec_hdl->is_running = true;
+
+	inst->input_thread =
+		kthread_run(input_thread, &inst->v4l2_fh, "inputhread");
+
+exit:
+	return ret;
+}
+
+static int  rtkve_sl_dec_reset_msg_ring(struct vpu_handler *hndl)
+{
+	volatile struct rtkve_flash_frame_info_t *frame;
+	volatile uint32_t rptr = 0;
+	struct rtkve_ringbuf_t *prb;
+	int ret = 0;
+
+	if (!hndl) {
+		pr_err("cap isn't ready\n");
+		ret = -EPERM;
+		goto exit;
+	}
+
+	prb = &hndl->flash.mesg_rb;
+	if (!prb) {
+		pr_err("%s ringbuffer isn't ready\n", __func__);
+		ret = -EPERM;
+		goto exit;
+	}
+
+	mutex_lock(&prb->lock);
+
+	while (prb->pRBH->readPtr[0] != prb->pRBH->writePtr) {
+		rptr = (htonl(prb->pRBH->readPtr[0]) -
+					  htonl(prb->pRBH->beginAddr)) /
+					 sizeof(struct rtkve_flash_frame_info_t);
+		frame = (volatile struct rtkve_flash_frame_info_t *)hndl->flash.frame[rptr];
+		frame->pUserData = false;
+		rptr = htonl(prb->pRBH->readPtr[0]) + sizeof(struct rtkve_flash_frame_info_t);
+		if (rptr < prb->limit)
+			prb->pRBH->readPtr[0] = htonl(rptr);
+		else
+			prb->pRBH->readPtr[0] = prb->pRBH->beginAddr;
+		dsb(sy);
+	}
+
+	hndl->flash.outputRingIdx = (htonl(prb->pRBH->writePtr) -
+				  htonl(prb->pRBH->beginAddr)) /
+				 sizeof(struct rtkve_flash_frame_info_t);
+
+	mutex_unlock(&prb->lock);
+exit:
+	return ret;
+}
+
+static int rtkve_sl_dec_stop(struct vpu_instance *inst, unsigned int type)
+{
+	int ret = 0;
+
+	if (!inst || !inst->dec_hdl || !inst->flash_hdl) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (V4L2_TYPE_IS_OUTPUT(type)) {
+		if (inst->dec_hdl->is_running) {
+			ret = rtkve_rpc_pause(inst->dec_hdl);
+			if (ret) {
+				dev_err(inst->dev->dev, "rtkve_rpc_pause fail\n");
+				ret = -EPERM;
+				goto exit;
+			}
+
+			ret = rtkve_rpc_flush(inst->dec_hdl);
+			if (ret) {
+				dev_err(inst->dev->dev, "rtkve_rpc_flush fail\n");
+				ret = -EPERM;
+				goto exit;
+			}
+		}
+	} else {
+		if (inst->dec_hdl->is_running) {
+			ret = rtkve_rpc_pause(inst->dec_hdl);
+			if (ret) {
+				dev_err(inst->dev->dev, "rtkve_rpc_pause fail\n");
+				ret = -EPERM;
+				goto exit;
+			}
+		}
+
+		if (inst->flash_hdl->is_running) {
+			ret = rtkve_rpc_pause(inst->flash_hdl);
+			if (ret) {
+				dev_err(inst->dev->dev, "rtkve_rpc_pause fail\n");
+				ret = -EPERM;
+				goto exit;
+			}
+
+			ret = rtkve_rpc_flush(inst->flash_hdl);
+			if (ret) {
+				dev_err(inst->dev->dev, "rtkve_rpc_flush fail\n");
+				ret = -EPERM;
+				goto exit;
+			}
+
+			ret = rtkve_sl_dec_reset_msg_ring(inst->flash_hdl);
+			if (ret) {
+				dev_err(inst->dev->dev, "flash reset msg rwptr fail\n");
+				goto exit;
+			}
+		}
+	}
+
+exit:
+	return ret;
+}
+#if 0
+static int gOutbufDumpSerial = 0;
+bool bNewOutbufDumpFile = 1;
+unsigned char outbufDumpFileName[256];
+static void rtkve_dump_bs(uint8_t* buf,
+					uint32_t offset, uint32_t len)
+{
+	void *outbufDumpFile;
+	int filp_open_flags;
+	ssize_t bytes = 0;
+	loff_t pos = 0;
+
+	if ((buf != NULL) && (len != 0)) {
+		filp_open_flags = O_CREAT | O_WRONLY;
+		memset(outbufDumpFileName, 0, sizeof(unsigned char)*256);
+		snprintf(outbufDumpFileName, 256,
+				"/mnt/bs_dump/bs%d.es",
+				gOutbufDumpSerial);
+		gOutbufDumpSerial++;
+		pr_err("%d.%s.create new outbuf dump:%s\n",__LINE__,__func__,
+				outbufDumpFileName);
+
+		outbufDumpFile =
+			(void *)filp_open(outbufDumpFileName, filp_open_flags, 0);
+		if (IS_ERR((struct file *)outbufDumpFile)) {
+			pr_err("%d.%s.filp_open %s fail\n",__LINE__,__func__,
+					outbufDumpFileName);
+		} else {
+			//vpu_info("%d.%s.filp_open %s ok\n",__LINE__,__func__,
+			//		ctx->outbufDumpFileName);
+			bytes =
+				kernel_write((struct file *)(outbufDumpFile),
+							(void *)(buf + offset), (size_t)len, &pos);
+			//vpu_info("%d.%s.kernel_write bytes:%ld.pos:%lld\n",__LINE__,__func__,
+			//		bytes, pos);
+			filp_close((struct file *)(outbufDumpFile), NULL);
+			//vpu_info("%d.%s.filp_close %s\n",__LINE__,__func__,
+			//		ctx->outbufDumpFileName);
+			outbufDumpFile = NULL;
+		}
+	}
+}
+#endif
+
+static void rtkve_sl_dec_start_decode(struct work_struct *work)
+{
+	struct vpu_instance *inst =
+		container_of(work, struct vpu_instance, decode_work);
+	struct vb2_v4l2_buffer *src_buf, *dst_buf;
+	struct media_request *src_req;
+	struct dec_output_info dec_info = { 0 };
+	struct vpu_handler *hndl = inst->flash_hdl;
+	enum vb2_buffer_state state;
+	int ret = 0;
+
+	dev_dbg(inst->dev->dev, "%d.%s.enter\n", __LINE__, __func__);
+
+	src_buf = v4l2_m2m_next_src_buf(inst->v4l2_fh.m2m_ctx);
+	if (!src_buf)
+		goto exit;
+
+	dst_buf = v4l2_m2m_next_dst_buf(inst->v4l2_fh.m2m_ctx);
+	if (!dst_buf)
+		goto exit;
+
+	src_req = src_buf->vb2_buf.req_obj.req;
+
+	switch (inst->state) {
+	case VPU_INST_STATE_NONE:
+		dev_dbg(inst->dev->dev, "%d.%s.VPU_INST_STATE_NONE\n", __LINE__,
+			__func__);
+		fallthrough;
+	case VPU_INST_STATE_OPEN:
+		inst->state = VPU_INST_STATE_INIT_SEQ;
+		fallthrough;
+	case VPU_INST_STATE_INIT_SEQ:
+		rtkve_sl_dec_start(inst);
+		inst->state = VPU_INST_STATE_PIC_RUN;
+		fallthrough;
+	case VPU_INST_STATE_PIC_RUN:
+		ret = rtkve_sl_dec_get_dispbuf(inst, hndl, &dec_info);
+		if (ret)
+			break;
+
+		dev_dbg(inst->dev->dev, "get frame 0x%x !!!!", dec_info.buf_addr_y);
+		v4l2_m2m_buf_copy_metadata(src_buf, dst_buf, true);
+
+		state = (dec_info.drop_timestamp != MEANINGLESS) ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE;
+		rtkve_sl_dec_handle_dst_buf(inst, dec_info.buf_addr_y, state, dec_info.drop_timestamp);
+
+		v4l2_ctrl_request_complete(src_req, &inst->v4l2_ctrl_hdl);
+
+		rtkve_sl_dec_handle_src_buf(inst);
+		break;
+	default:
+		break;
+	}
+
+exit:
+	v4l2_m2m_job_finish(inst->dev->m2m_dev, inst->v4l2_fh.m2m_ctx);
+
+	dev_dbg(inst->dev->dev, "%d.%s.leave.ret:%d\n", __LINE__, __func__,
+		ret);
+	return;
+}
+
+static void rtkve_sl_dec_stop_decode(struct vpu_instance *inst)
+{
+	dev_dbg(inst->dev->dev, "%s: state %d\n", __func__, inst->state);
+
+	inst->state = VPU_INST_STATE_STOP;
+}
+
+static int rtkve_sl_dec_init_ctrls(struct vpu_instance *inst)
+{
+	struct v4l2_ctrl_handler *hdl = &inst->v4l2_ctrl_hdl;
+	const struct sl_ctrls *sl_ctrls;
+	int i = 0;
+	int j = 0;
+	int ctrls_cnt = 0;
+	int ret = 0;
+
+	for (i = 0; i < MAX_CTRL_LIST; i++) {
+		ctrls_cnt += sl_ctrls_list[i]->num_ctrls;
+	}
+	v4l2_ctrl_handler_init(hdl, ctrls_cnt);
+
+	for (i = 0; i < MAX_CTRL_LIST; i++) {
+		sl_ctrls = sl_ctrls_list[i];
+
+		for (j = 0; j < sl_ctrls->num_ctrls; j++) {
+			struct v4l2_ctrl_config cfg = sl_ctrls->ctrls[j].cfg;
+			cfg.ops = &rtkve_sl_dec_ctrl_ops;
+			v4l2_ctrl_new_custom(hdl, &cfg, NULL);
+      if (hdl->error)
+        dev_err(inst->dev->dev, "Failed to create control_id:%u ret:%d\n", cfg.id, hdl->error);
+		}
+	}
+
+	if (hdl->error) {
+		dev_err(inst->dev->dev,
+			"Failed to initialize control handler\n");
+		v4l2_ctrl_handler_free(hdl);
+		ret = hdl->error;
+		goto exit;
+	}
+
+	inst->v4l2_fh.ctrl_handler = hdl;
+	v4l2_ctrl_handler_setup(hdl);
+exit:
+	return ret;
+}
+
+const struct rtkve_match_data rtkve2_data_stateless = {
+	.ctrls_setup = rtkve_sl_dec_init_ctrls,
+	.dev_run_work = rtkve_sl_dec_start_decode,
+	.find_vpu_fmt = rtkve_sl_dec_find_fmt,
+	.find_vpu_fmt_by_idx = rtkve_sl_dec_find_fmt_by_idx,
+	.queue_init = rtkve_sl_dec_queue_init,
+	.create_instance = rtkve_sl_dec_create_instance,
+	.stop_decode = rtkve_sl_dec_stop_decode,
+	.destroy_instance = rtkve_sl_dec_destroy_instance,
+	.suspend = rtkve_sl_dec_suspend,
+	.resume = rtkve_sl_dec_resume,
+	.is_stateless = true,
+};
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-vpu.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve-vpu.h
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#ifndef RTKVE_VPU_H
+#define RTKVE_VPU_H
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fh.h>
+#include <media/videobuf2-v4l2.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/videobuf2-vmalloc.h>
+
+#include "rtkve-common.h"
+
+
+#define MAX_DEC_PIC_WIDTH 4096
+#define MAX_DEC_PIC_HEIGHT 2304
+
+#define HEVC_MIN_DEC_PIC_WIDTH 64U
+#define HEVC_MIN_DEC_PIC_HEIGHT 64U
+#define HEVC_MAX_DEC_PIC_WIDTH 4096U
+#define HEVC_MAX_DEC_PIC_HEIGHT 2304U
+
+#define VP9_MIN_DEC_PIC_WIDTH 64U
+#define VP9_MIN_DEC_PIC_HEIGHT 64U
+#define VP9_MAX_DEC_PIC_WIDTH 4096U
+#define VP9_MAX_DEC_PIC_HEIGHT 2304U
+
+#define AV1_MIN_DEC_PIC_WIDTH 64U
+#define AV1_MIN_DEC_PIC_HEIGHT 64U
+#define AV1_MAX_DEC_PIC_WIDTH 4096U
+#define AV1_MAX_DEC_PIC_HEIGHT 2304U
+
+#define RAW_MIN_DEC_PIC_WIDTH 64U
+#define RAW_MIN_DEC_PIC_HEIGHT 64U
+#define RAW_MAX_DEC_PIC_WIDTH 4096U
+#define RAW_MAX_DEC_PIC_HEIGHT 2304U
+
+#define RAW_DEFAULT_SIZEIMAGE (3 * 1024 * 1024)
+
+#define RTKVE_DEC_PIC_SIZE_STEP 1
+
+struct vpu_format {
+	unsigned int v4l2_pix_fmt;
+	unsigned int max_width;
+	unsigned int min_width;
+	unsigned int max_height;
+	unsigned int min_height;
+	unsigned int num_planes;
+};
+
+struct vpu_buffer {
+	struct v4l2_m2m_buffer v4l2_m2m_buf;
+	bool consumed;
+	bool referenced;
+	struct list_head list;
+};
+
+struct stateless_info {
+	struct vb2_v4l2_buffer *src;
+	struct vb2_v4l2_buffer *dst;
+	union {
+		struct stateless_hevc_info hevc;
+		struct stateless_vp9_info vp9;
+		struct stateless_av1_info av1;
+	};
+};
+
+extern struct v4l2_ioctl_ops rtkve_dec_ioctl_ops;
+extern const struct rtkve_match_data rtkve2_data_stateless;
+//extern const struct rtkve_match_data rtkve2_data_stateful;
+
+static inline struct vpu_instance *rtkve_to_vpu_inst(struct v4l2_fh *vfh)
+{
+	return container_of(vfh, struct vpu_instance, v4l2_fh);
+}
+
+static inline struct vpu_buffer *rtkve_to_vpu_buf(struct vb2_v4l2_buffer *vbuf)
+{
+	return container_of(vbuf, struct vpu_buffer, v4l2_m2m_buf.vb);
+}
+
+void rtkve_set_default_format(struct vpu_instance *inst,
+			      struct v4l2_pix_format_mplane *src_fmt,
+			      struct v4l2_pix_format_mplane *dst_fmt);
+int rtkve_dec_init_m2m_dev(struct vpu_device *dev);
+#endif
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve_frame.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/rtkve/rtkve_frame.h
@@ -0,0 +1,216 @@
+/*
+ * Realtek video decoder v4l2 driver
+ *
+ * Copyright (c) 2021 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: LicenseRef-Realtek-Proprietary
+ *
+ * This software component is confidential and proprietary to Realtek
+ * Semiconductor Corp. Disclosure, reproduction, redistribution, in whole
+ * or in part, of this work and its derivatives without express permission
+ * is prohibited.
+ */
+#ifndef __RTKVE_FRAME_H__
+#define __RTKVE_FRAME_H__
+
+#include <linux/types.h>
+
+#define PIC_SIZE_INVALID ((uint32_t)-1)
+
+#define VE2RPC_FLASH_FRAME_INFO_VERSION 1
+#define VE2RPC_FLASH_FRAME_INFO_SIZE 384
+
+#define VE2RPC_DVO_INFO_DOLBY_VISION_SIGN (0xECECECEC)
+
+/**
+ * Indicate if a frame has a base layer frame dequeued from flash driver
+ */
+#define VE2RPC_DVO_INFO_FLAGS_BL_DEQUEUED (0x00000001)
+
+/**
+ * Indicate if a frame has a enhance layer frame dequeued from flash driver
+ */
+#define VE2RPC_DVO_INFO_FLAGS_EL_DEQUEUED (0x00000002)
+
+/**
+ * Indicate if a frame is the first frame after flushing
+ */
+#define VE2RPC_DVO_INFO_FLAGS_FLUSHED (0x00000004)
+
+#define VRPC_FRAME_INFO_FLAG_EOS 0x00000001
+#define VRPC_FRAME_INFO_FLAG_DATACORRUPT 0x00000002
+#define VRPC_FRAME_INFO_FLAG_DISCARD 0x00000004
+
+typedef struct __attribute__((__packed__)) rtkve_hdr_info_t {
+	uint32_t hdr_type;
+	uint8_t nTransferCharacteristics;
+	uint8_t nMatrixCoefficiets;
+	uint8_t nColorPrimaries;
+	uint8_t bVideoFullRangeFlag;
+	// offset = 8
+	uint16_t nDisplayPrimariesX[3];
+	uint16_t nDisplayPrimariesY[3];
+	uint16_t nWhitePointX;
+	uint16_t nWhitePointY;
+	uint16_t reserve2[4];
+	// offset = 8 + 24
+	uint32_t nMaxDisplayMasteringLuminance;
+	uint32_t nMinDisplayMasteringLuminance;
+	uint32_t nMaxCLL;
+	uint32_t nMaxFALL;
+	uint32_t nHdrType;
+	uint32_t reserve3[3];
+	// size = 8 + 24 + 32 = 64
+} rtkve_hdr_info_t;
+typedef struct __attribute__((__packed__)) rtkve_frame_info_t {
+	void *pixel;
+	uint32_t phyaddr;
+	uint32_t width;
+	uint32_t height;
+	uint32_t ptsLow;
+	uint32_t ptsHigh;
+	uint32_t pts2High;
+	uint32_t pts2Low;
+	uint32_t ptsSeiHigh;
+	uint32_t ptsSeiLow;
+	uint32_t flag;
+	uint32_t keyId;
+	uint32_t framerate;
+	uint32_t progressive;
+	uint32_t pitch;
+	uint32_t cpitch;
+	uint32_t reserve[2];
+	// offset = 72
+	uint8_t checkPicCoding;
+	uint8_t bitDepthLuma;
+	uint8_t bitDepthChroma;
+	uint8_t completeFields;
+	uint32_t phyaddrY;
+	uint32_t phyaddrC;
+	uint32_t offset;
+	uint32_t picCoding;
+	uint32_t interlaceMode;
+	rtkve_hdr_info_t hdrInfo;
+	uint32_t reserve2[8];
+	uint32_t blid;
+	uint32_t ext_data_in_use;
+	uint32_t is_ext_video;
+	uint32_t nDecClkTime;
+	uint32_t nDecFrameCount;
+	uint32_t is_frame_decoded;
+	uint32_t hdr_metadata_addr;
+	uint32_t hdr_metadata_size;
+	bool has_pts;
+	uint64_t nTimeStamp;
+	bool bWaitReleaseByBLID;
+	bool bPeekFrame;
+	uint64_t nFilledLen;
+} rtkve_frame_info_t;
+/*
+ * VCPU Flash output farme info data structure
+ * Size = 256 bytes
+ * */
+struct rtkve_flash_frame_info_t {
+	unsigned int nSize;
+	unsigned int nVersion;
+	unsigned int pUserData;
+	unsigned int nRRKey;
+	unsigned int nContext;
+	unsigned int nBufID;
+	unsigned int nPicFlags;
+	unsigned int nPicWidth;
+	unsigned int nPicHeight;
+	unsigned int nDecimatePicWidth;
+	unsigned int nDecimateicHeight;
+	unsigned int nBitDepthLuma;
+	unsigned int nBitDepthChroma;
+
+	unsigned int nPtsHigh;
+	unsigned int nPtsLow;
+	unsigned int nRPtsHigh;
+	unsigned int nRPtsLow;
+	unsigned int nPts2High;
+	unsigned int nPts2Low;
+	unsigned int nPicPhysicalAddr;
+	unsigned int nPicPitch;
+	unsigned int nClkTimeHigh;
+	unsigned int nClkTimeLow;
+	unsigned int nDecClkTime;
+	unsigned int nDecFrameCount;
+	unsigned int nFramerateD;
+	unsigned int nFramerateN;
+	unsigned int eScanType; /* 0: progressive, 1: interlaced */
+	/* nInterlaceMode define  */
+	unsigned int nInterlaceMode;
+	unsigned int nSeiPtsHigh; /* SEI PTS High */
+	unsigned int nSeiPtsSLow; /* SEI PTS Low */
+	unsigned int nPicCPitch;
+	unsigned int nPicCPhysicalAddr;
+	unsigned int nSampleWidth;
+	unsigned int nSampleHeight;
+	unsigned int qlevel_sel_y;
+	unsigned int qlevel_sel_c;
+	/* nHDR_Type define */
+	unsigned int nHDR_Type;
+	unsigned int nDisplayPrimaries_X[3];
+	unsigned int nDisplayPrimaries_Y[3];
+	unsigned int nWhitePoint_X;
+	unsigned int nWhitePoint_Y;
+	unsigned int nMaxDisplayMasteringLuminance;
+	unsigned int nMinDisplayMasteringLuminance;
+	unsigned int nTransferCharacteristics;
+	unsigned int nMatrixCoefficiets;
+	unsigned int nVideoFullRangeFlag;
+	unsigned int nMaxCLL;
+	unsigned int nMaxFALL;
+	unsigned int hdr_metadata_addr;
+	unsigned int hdr_metadata_size;
+	unsigned int tch_metadata_addr;
+	unsigned int tch_metadata_size;
+	unsigned int film_grain_metadata_addr;
+	unsigned int film_grain_metadata_size;
+
+	/* 0: raw, 1: lossless, 2: lossy */
+	unsigned int nCmprsMode;
+	unsigned int nPicYCmprsHdrAddr;
+	unsigned int nPicCCmprsHdrAddr;
+	unsigned int nPicCmprsPitch;
+	unsigned int nPicCPhysicalAddr2;
+
+	unsigned int nBufLockPhysicalAddr;
+	unsigned int max_fb_num;
+	unsigned int max_cmprs_head_size;
+
+	unsigned int nLinearPicPhysicalAddr;
+	unsigned int nLinearPicCPhysicalAddr;
+	unsigned int nLinearPicWidth;
+	unsigned int nLinearPicHeight;
+	unsigned int nLinearPicPitch;
+
+	unsigned int nPixelAR_hor;
+	unsigned int nPixelAR_ver;
+	union {
+		unsigned int data;
+		struct {
+			unsigned int have_timecode : 1; // bit[0]
+			unsigned int seconds : 6; // bit[6:1]
+			unsigned int minutes : 6; // bit[12:7]
+			unsigned int hours : 5; // bit[17:13]
+			unsigned int frames : 9; // bit[26:18]
+		};
+	} nHevc_tc_timestamp;
+	union {
+		unsigned int data;
+		struct {
+			unsigned int colour_primaries : 8; // bit[7:0]
+			unsigned int transferCharacteristics : 8; // bit[15:8]
+		};
+	} nVUI_information;
+	unsigned int dv_rpu_metadata_addr;
+	unsigned int dv_rpu_metadata_size;
+	unsigned int noShowFrame_count;
+	unsigned int noShowFrame_picId[8];
+	unsigned int reserved[9];
+};
+
+#endif
Index: kernel-5_15/drivers/media/platform/realtek/vpu/Kconfig
===================================================================
--- kernel-5_15.orig/drivers/media/platform/realtek/vpu/Kconfig
+++ kernel-5_15/drivers/media/platform/realtek/vpu/Kconfig
@@ -17,16 +17,16 @@ config VIDEO_REALTEK
 	help
 	  Realtek video codec driver HW capability to decode.
 
-config VIDEO_RTK_CODA
-	tristate "Realtek CODA support"
+config VIDEO_RTK_VCODEC
+	tristate "Realtek Stateful V4L2 Video Codec support"
 	depends on VIDEO_REALTEK
 	depends on ARCH_REALTEK || COMPILE_TEST
 	help
-	  Enable support for Realtek SoC CODA decoder.
+	  Enable support for Realtek SoC Stateful V4L2 decoder.
 
-config VIDEO_RTK_VCODEC
-	tristate "Realtek Video Codec support"
+config VIDEO_RTK_VCODEC_SL
+	tristate "Realtek Stateless V4L2 Video Codec support"
 	depends on VIDEO_REALTEK
 	depends on ARCH_REALTEK || COMPILE_TEST
 	help
-	  Enable support for Realtek SoC VE2 decoder.
+	  Enable support for Realtek SoC Stateless V4L2 decoder.
Index: kernel-5_15/drivers/media/platform/realtek/vpu/stateless/Makefile
===================================================================
--- kernel-5_15.orig/drivers/media/platform/realtek/vpu/stateless/Makefile
+++ kernel-5_15/drivers/media/platform/realtek/vpu/stateless/Makefile
@@ -1,12 +1,22 @@
 # SPDX-License-Identifier: GPL-2.0
 
-obj-$(CONFIG_VIDEO_RTK_CODA) += coda9.o
+obj-$(CONFIG_VIDEO_RTK_VCODEC_SL) += coda9.o rtkve.o
 
-coda9-y += \
-	coda-hw.o \
-	coda-vdi.o \
-	coda-vpu-v4l2.o \
-	coda-stateless-vpu-dec.o \
-	vpu.o
+coda9-y := \
+	coda/coda-hw.o \
+	coda/coda-vdi.o \
+	coda/coda-vpu-v4l2.o \
+	coda/coda-stateless-vpu-dec.o \
+	coda/vpu.o
+
+rtkve-y := \
+	rtkve/rtkve-common.o	\
+	rtkve/rtkve-rpc.o	\
+	rtkve/rtkve-sl-hevc.o	\
+	rtkve/rtkve-sl-vp9.o	\
+	rtkve/rtkve-sl-av1.o	\
+	rtkve/rtkve-stateless-vpu-dec.o	\
+	rtkve/rtkve-dec-v4l2.o	\
+	rtkve/rtkve-dec-drv.o
 
 EXTRA_CFLAGS += -Wframe-larger-than=4096
