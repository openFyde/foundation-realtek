From 97fd037315e38f4478fe05f251226e277e4e5536 Mon Sep 17 00:00:00 2001
From: Edward Wu <edwardwu@realtek.com>
Date: Wed, 17 Jul 2024 14:45:57 +0800
Subject: [PATCH 2/6] media: rtk_vdec_rtd16xxb: update v4l2 driver

internal v4l2 commit:
362d21fea1d1afbf6754d733dd63ca6f7a24291a

Change-Id: I7e99558c86415cf13c71095ddf74768c55b0fd6c
---
 .../media/platform/rtk_vdec_rtd16xxb/drv_if.c |   8 ++
 .../media/platform/rtk_vdec_rtd16xxb/drv_if.h |   1 +
 .../platform/rtk_vdec_rtd16xxb/ve1_wrapper.c  |  86 ++++++++-------
 .../media/platform/rtk_vdec_rtd16xxb/ve2.c    |  74 ++++++++-----
 .../media/platform/rtk_vdec_rtd16xxb/ve2rpc.c | 101 +++++++++++-------
 .../media/platform/rtk_vdec_rtd16xxb/ve2rpc.h |   5 +
 .../media/platform/rtk_vdec_rtd16xxb/vpu.c    |  26 ++++-
 7 files changed, 191 insertions(+), 110 deletions(-)

diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c b/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c
index ad7449d74be6..a6f017f35f74 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c
@@ -42,6 +42,7 @@ module_param_named(debug, vpu_debug, int, 0600);
 
 #define VPU_NAME "realtek-vpu"
 #define ENABLE_ADAPTIVE_PLAYBACK (0)
+#define ENABLE_REORDER_PTS (0)
 #define INVERT_BITVAL_1 (~1)
 
 ssize_t get_video_status(struct device *dev, struct device_attribute *attr,
@@ -278,6 +279,12 @@ static int vpu_s_ctrl(struct v4l2_ctrl *ctrl)
 		       sizeof(struct rtk_dec_params));
 
 		ctx->params.dec_params.is_adaptive_playback = ENABLE_ADAPTIVE_PLAYBACK;
+#ifndef REORDER_PTS
+		if (ctx->params.dec_params.enable_pts_reorder) {
+			ctx->params.dec_params.enable_pts_reorder = 0;
+			vpu_err("Driver doesn't support enabling pts reorder\n");
+		}
+#endif
 		break;
 	}
 	case V4L2_CID_COLORIMETRY_HDR10_CLL_INFO: {
@@ -1036,6 +1043,7 @@ static int vpu_open(struct file *file)
 
 	memset(&ctx->params, 0, sizeof(struct videc_params));
 	ctx->params.dec_params.is_adaptive_playback = ENABLE_ADAPTIVE_PLAYBACK;
+	ctx->params.dec_params.enable_pts_reorder = ENABLE_REORDER_PTS;
 
 	atomic_inc(&dev->num_inst);
 	hasVideo = 1;
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.h b/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.h
index fcb3ca37262d..35f2ab998530 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.h
@@ -42,6 +42,7 @@ struct rtk_dec_params {
 	uint32_t primaries;
 
 	uint8_t is_adaptive_playback;
+	uint8_t enable_pts_reorder;
 };
 
 struct videc_params {
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_wrapper.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_wrapper.c
index c99f7495d64f..635cc248a059 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_wrapper.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_wrapper.c
@@ -617,6 +617,8 @@ int rtkve1_register_dpbs(void *pCtx)
 	struct rtkve1_dpb_t *dpb_unreg = NULL;
 	unsigned int dispFlag = 0;
 	unsigned int clearDispIndex = 0;
+	SecAxiUse *secAxiUse;
+	MaverickCacheConfig *decCacheConfig;
 
 	if (pCtx == NULL) {
 		ve1_err(VE1_WRAPPER_TAG,
@@ -753,6 +755,50 @@ int rtkve1_register_dpbs(void *pCtx)
 			fbUser->stride, fbUser->height, ctx->currSequenceNo);
 	}
 
+	if (ctx->secAxiUse == NULL) {
+		ctx->secAxiUse = kzalloc(sizeof(SecAxiUse), GFP_KERNEL);
+		if (ctx->secAxiUse == NULL) {
+			ve1_err(VE1_WRAPPER_TAG, "kzalloc secAxiUse fail\n");
+			return -1;
+		}
+	}
+	secAxiUse = (SecAxiUse *)ctx->secAxiUse;
+	memset(secAxiUse, 0, sizeof(SecAxiUse));
+	secAxiUse->u.coda9.useBitEnable = USE_BIT_INTERNAL_BUF;
+	secAxiUse->u.coda9.useIpEnable = USE_IP_INTERNAL_BUF;
+	secAxiUse->u.coda9.useDbkYEnable = USE_DBKY_INTERNAL_BUF;
+	secAxiUse->u.coda9.useDbkCEnable = USE_DBKC_INTERNAL_BUF;
+	secAxiUse->u.coda9.useOvlEnable = USE_OVL_INTERNAL_BUF;
+	secAxiUse->u.coda9.useBtpEnable = USE_BTP_INTERNAL_BUF;
+	VPU_DecGiveCommand((DecHandle)ctx->decHandle, SET_SEC_AXI, secAxiUse);
+
+	if (ctx->decCacheConfig == NULL) {
+		ctx->decCacheConfig =
+			kzalloc(sizeof(MaverickCacheConfig), GFP_KERNEL);
+		if (ctx->decCacheConfig == NULL) {
+			ve1_err(VE1_WRAPPER_TAG,
+				"kzalloc decCacheConfig fail\n");
+			return -1;
+		}
+	}
+	decCacheConfig = (MaverickCacheConfig *)ctx->decCacheConfig;
+	MaverickCache2Config(decCacheConfig,
+			     TRUE, // decoder
+			     (BOOL)decOP->cbcrInterleave, 0, 0, 3,
+			     (TiledMapType)mapType, 15);
+	VPU_DecGiveCommand((DecHandle)ctx->decHandle, SET_CACHE_CONFIG,
+			   decCacheConfig);
+
+	fbStride =
+		CalcStride(initialInfo->picWidth, initialInfo->picHeight,
+			fbFormat, decOP->cbcrInterleave,
+			(decOP->wtlEnable == TRUE ? LINEAR_FRAME_MAP :
+			(TiledMapType)(mapType)),
+			0);
+	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+		"fbStride:%d.fbFormat:%d.mapType:%d\n", fbStride, fbFormat,
+		mapType);
+
 	ret = VPU_DecRegisterFrameBuffer((DecHandle)ctx->decHandle,
 					 (FrameBuffer *)ctx->fbUser,
 					 ctx->capReqBufsCnt, fbStride, fbHeight,
@@ -1522,8 +1568,6 @@ int VE1_DecSeqInit(void *pCtx)
 	unsigned long long pts_unit = PTS_UNIT;
 	unsigned int fps;
 	unsigned long valid_data = 0;
-	SecAxiUse *secAxiUse;
-	MaverickCacheConfig *decCacheConfig;
 
 	if (pCtx == NULL) {
 		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
@@ -1615,40 +1659,6 @@ int VE1_DecSeqInit(void *pCtx)
 					initialInfo->fRateNumerator,
 					initialInfo->fRateDenominator,
 					ctx->timeTick);
-
-				if (ctx->secAxiUse == NULL) {
-					ctx->secAxiUse = kzalloc(sizeof(SecAxiUse), GFP_KERNEL);
-					if (ctx->secAxiUse == NULL) {
-						ve1_err(VE1_WRAPPER_TAG, "kzalloc secAxiUse fail\n");
-						return -1;
-					}
-				}
-				secAxiUse = (SecAxiUse *)ctx->secAxiUse;
-				memset(secAxiUse, 0, sizeof(SecAxiUse));
-				secAxiUse->u.coda9.useBitEnable = USE_BIT_INTERNAL_BUF;
-				secAxiUse->u.coda9.useIpEnable = USE_IP_INTERNAL_BUF;
-				secAxiUse->u.coda9.useDbkYEnable = USE_DBKY_INTERNAL_BUF;
-				secAxiUse->u.coda9.useDbkCEnable = USE_DBKC_INTERNAL_BUF;
-				secAxiUse->u.coda9.useOvlEnable = USE_OVL_INTERNAL_BUF;
-				secAxiUse->u.coda9.useBtpEnable = USE_BTP_INTERNAL_BUF;
-				VPU_DecGiveCommand((DecHandle)ctx->decHandle, SET_SEC_AXI, secAxiUse);
-
-				if (ctx->decCacheConfig == NULL) {
-					ctx->decCacheConfig =
-						kzalloc(sizeof(MaverickCacheConfig), GFP_KERNEL);
-					if (ctx->decCacheConfig == NULL) {
-						ve1_err(VE1_WRAPPER_TAG,
-							"kzalloc decCacheConfig fail\n");
-						return -1;
-					}
-				}
-				decCacheConfig = (MaverickCacheConfig *)ctx->decCacheConfig;
-				MaverickCache2Config(decCacheConfig,
-							TRUE, // decoder
-							(BOOL)((DecOpenParam *)ctx->decOP)->cbcrInterleave, 0, 0, 3,
-							(TiledMapType)LINEAR_FRAME_MAP, 15);
-				VPU_DecGiveCommand((DecHandle)ctx->decHandle, SET_CACHE_CONFIG,
-						decCacheConfig);
 			}
 		}
 	} else {
@@ -1955,8 +1965,7 @@ int VE1_UpdateDPBStatus(void *pCtx, unsigned int dpb_paddr,
 	if (!tmp_dpb) {
 		ve1_err(VE1_WRAPPER_TAG, "can't find dpb_paddr:0x%x in dpb[]\n",
 			dpb_paddr);
-		ret = -1;
-		goto out;
+		return -1;
 	}
 	dpb = (struct rtkve1_dpb_t *)tmp_dpb;
 	regIndex = dpb->regIndex;
@@ -2012,7 +2021,6 @@ int VE1_UpdateDPBStatus(void *pCtx, unsigned int dpb_paddr,
 		ve1_err(VE1_WRAPPER_TAG, "invalid status:0x%x\n", status);
 	}
 
-out:
 	mutex_unlock(&ctx->ve1_dma_mutex);
 	return ret;
 }
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c
index 3acff06a58ea..548584ce9e3b 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c
@@ -48,7 +48,9 @@ typedef struct {
 struct ve2_ctx {
 	struct ve2rpc *out_hndl;
 	struct ve2rpc *cap_hndl;
+#ifdef REORDER_PTS
 	struct list_head pts_list;
+#endif
 	bool eosEvent;
 	bool eos;
 	bool no_frame;
@@ -319,18 +321,24 @@ int ve2_stop_streaming(struct vb2_queue *q)
 		ve2_make_undq_capbuf_done(ctx);
 
 		ctx->internal_buf_cnt = 0;
+#ifdef REORDER_PTS
 		ctx->cap_hndl->pre_pts = 0;
+#endif
 		ctx->streamoff_cap = 1;
 		ctx->streamon_cap = 0;
 	}
 
+#ifdef REORDER_PTS
 	if (ctx->streamoff_out && ctx->streamoff_cap) {
-		ret = ve2rpc_free_pts(ctx->out_hndl);
-		if (ret) {
-			vpu_err("ve2rpc_free_pts fail\n");
-			goto exit;
+		if (ctx->out_hndl->is_pts_reorder) {
+			ret = ve2rpc_free_pts(ctx->out_hndl);
+			if (ret) {
+				vpu_err("ve2rpc_free_pts fail\n");
+				goto exit;
+			}
 		}
 	}
+#endif
 exit:
 	return ret;
 }
@@ -365,7 +373,7 @@ static int ve2_out_qbuf(void *fh, uint8_t *buf, uint32_t len, uint64_t pts,
 		return -EINVAL;
 	}
 
-	if (v_ctx->cap_fmt.misc.bufcnt > 0 &&
+	if (ctx->internal_buf_cnt > 0 && v_ctx->cap_fmt.misc.bufcnt > 0 &&
 		ctx->internal_buf_cnt > (v_ctx->cap_fmt.misc.bufcnt << 1)) {
 		vpu_input_dbg("too many internal buffers %d, %d\n", ctx->internal_buf_cnt,
 		      v_ctx->cap_fmt.misc.bufcnt);
@@ -377,18 +385,21 @@ static int ve2_out_qbuf(void *fh, uint8_t *buf, uint32_t len, uint64_t pts,
 		vpu_input_dbg("ve2rpc_write_bs fail, ret %d\n", ret);
 		return ret;
 	} else {
-		struct pts_queue *p = (struct pts_queue *)kmalloc(
-			sizeof(struct pts_queue), GFP_KERNEL | __GFP_ZERO);
-		if (!p) {
-			vpu_err("ve2_out_qbuf malloc fail\n");
-			return -ENOMEM;
+#ifdef REORDER_PTS
+		if (ctx->out_hndl->is_pts_reorder) {
+			struct pts_queue *p = (struct pts_queue *)kmalloc(
+				sizeof(struct pts_queue), GFP_KERNEL | __GFP_ZERO);
+			if (!p) {
+				vpu_err("ve2_out_qbuf malloc fail\n");
+				return -ENOMEM;
+			}
+			p->pts = pts;
+			p->idx = sequence;
+			mutex_lock(&ctx->cap_hndl->pts_mutex);
+			list_add_tail(&p->list, &ctx->pts_list);
+			mutex_unlock(&ctx->cap_hndl->pts_mutex);
 		}
-		p->pts = pts;
-		p->idx = sequence;
-		mutex_lock(&ctx->cap_hndl->pts_mutex);
-		list_add_tail(&p->list, &ctx->pts_list);
-		mutex_unlock(&ctx->cap_hndl->pts_mutex);
-
+#endif
 		ctx->internal_buf_cnt++;
 	}
 
@@ -608,6 +619,10 @@ int ve2_cap_dqbuf(void *fh, uint8_t *buf, uint64_t *pts,
 	update_color_matrix(fh);
 	ret = ve2rpc_dqframe(ctx->cap_hndl, disp_buf, pts, &ctx->eos,
 			     &ctx->no_frame, &no_show_frm_cnt);
+
+	if (ctx->internal_buf_cnt && ret != -EBUSY)
+		ctx->internal_buf_cnt -= (no_show_frm_cnt + 1);
+
 	if (ret) {
 		//ve2_cap_dqbuf fail is normal
 		return ret;
@@ -626,7 +641,6 @@ int ve2_cap_dqbuf(void *fh, uint8_t *buf, uint64_t *pts,
 
 	ve2rpc_update_dpb_st(ctx->cap_hndl,  *disp_buf, RTKVE2_DPB_ST_DQ);
 
-	ctx->internal_buf_cnt -= (no_show_frm_cnt + 1);
 	return 0;
 }
 
@@ -662,14 +676,22 @@ static void *ve2_alloc_context(void *fh)
 	}
 
 	ctx->cap_hndl->is_adaptive_playback =
-		vid_ctx->params.dec_params.is_adaptive_playback;
-	ctx->out_hndl->is_adaptive_playback =
+		ctx->out_hndl->is_adaptive_playback =
 		vid_ctx->params.dec_params.is_adaptive_playback;
 
-	INIT_LIST_HEAD(&ctx->pts_list);
-	ctx->cap_hndl->pts_queue = &ctx->pts_list;
-	ctx->out_hndl->pts_queue = &ctx->pts_list;
-
+#ifdef REORDER_PTS
+	ctx->cap_hndl->is_pts_reorder =
+		ctx->out_hndl->is_pts_reorder =
+		vid_ctx->params.dec_params.enable_pts_reorder;
+
+	if (vid_ctx->params.dec_params.enable_pts_reorder) {
+		ctx->cap_hndl->lastID = 0;
+		mutex_init(&ctx->cap_hndl->pts_mutex);
+		INIT_LIST_HEAD(&ctx->pts_list);
+		ctx->cap_hndl->pts_queue = &ctx->pts_list;
+		ctx->out_hndl->pts_queue = &ctx->pts_list;
+	}
+#endif
 	if (!ctx->out_hndl || !ctx->cap_hndl) {
 		vpu_err("ve2rpc_init_handle fail\n");
 		goto error;
@@ -800,8 +822,10 @@ static void ve2_free_context(void *ve_ctx)
 	}
 #endif
 
-	mutex_destroy(&ctx->cap_hndl->pts_mutex);
-
+#ifdef REORDER_PTS
+	if (ctx->cap_hndl->is_pts_reorder)
+		mutex_destroy(&ctx->cap_hndl->pts_mutex);
+#endif
 	ret = ve2rpc_uninit_handle(ctx->out_hndl);
 	if (ret) {
 		vpu_err("ve2rpc_uninit_handle fail out\n");
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.c
index f18773bebf46..1627dfbdc0e2 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.c
@@ -1529,8 +1529,16 @@ int ve2rpc_write_bs(struct ve2rpc *hndl, uint8_t *buf, uint32_t len,
 	}
 
 	writePtrforPTS = htonl(hndl->main_rb.pRBH->writePtr);
-	ret = ve2rpc_inband_pts2(&hndl->sub_rb, writePtrforPTS,
-				 (uint64_t)sequence << 32, pts, len, 0);
+#ifdef REORDER_PTS
+	if (hndl->is_pts_reorder) {
+		ret = ve2rpc_inband_pts2(&hndl->sub_rb, writePtrforPTS,
+					 (uint64_t)sequence << 32, pts, len, 0);
+	} else
+#endif
+	{
+		ret = ve2rpc_inband_pts2(&hndl->sub_rb, writePtrforPTS,
+					 (uint64_t)pts, sequence, len, 0);
+	}
 	if (ret) {
 		vpu_err("ve2rpc_inband_pts2 fail %d\n", ret);
 		return -EFAULT;
@@ -1953,17 +1961,17 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 	volatile uint8_t *buflock_va;
 	uint32_t flags;
 	uint32_t nVersion = 0;
-
-	unsigned int ptsHigh = 0;
-	int ptsLow = 0;
+	uint32_t ptsHigh = 0;
+	uint32_t ptsLow = 0;
 	uint64_t frmPTS = 0;
-
+#ifdef REORDER_PTS
 	struct pts_queue *entry = NULL;
 	struct pts_queue *match_entry = NULL;
 	struct pts_queue *tmp_entry = NULL;
 
 	uint64_t estPTS = ULLONG_MAX;
 	uint32_t estIdx = UINT_MAX;
+#endif
 	uint32_t y_phy_addr = 0;
 	uint32_t c_phy_addr = 0;
 	uint32_t buflock_phy_addr = 0;
@@ -1993,6 +2001,11 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 
 	dsb(sy);
 
+	if(*no_show_frm_cnt)
+		pr_err("decoded frame with no show frame count %d", *no_show_frm_cnt);
+	else
+		*no_show_frm_cnt = 0;
+
 	if (nVersion == 0x8001) {
 		pr_err("No decoded frame with no show frame count %d", *no_show_frm_cnt);
 		ret = -ENODATA;
@@ -2013,49 +2026,56 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 		}
 	}
 	mutex_unlock(&cap_hndl->travel_mutex);
-
-	mutex_lock(&cap_hndl->pts_mutex);
-	//find the smallest pts
-	if (cap_hndl->pts_queue) {
-		list_for_each_entry (entry, cap_hndl->pts_queue, list) {
-			if (entry && entry->pts < estPTS) {
-				estPTS = entry->pts;
-				estIdx = entry->idx;
-				match_entry = entry;
+#ifdef REORDER_PTS
+	if (cap_hndl->is_pts_reorder) {
+		mutex_lock(&cap_hndl->pts_mutex);
+		//find the smallest pts
+		if (cap_hndl->pts_queue) {
+			list_for_each_entry (entry, cap_hndl->pts_queue, list) {
+				if (entry && entry->pts < estPTS) {
+					estPTS = entry->pts;
+					estIdx = entry->idx;
+					match_entry = entry;
+				}
 			}
 		}
-	}
 
-	//delete this node
-	if (cap_hndl->pts_queue) {
-		list_for_each_entry_safe (entry, tmp_entry, cap_hndl->pts_queue,
-					  list) {
-			if (entry && entry == match_entry) {
-				list_del(&entry->list);
-				kfree(entry);
+		//delete this node
+		if (cap_hndl->pts_queue) {
+			list_for_each_entry_safe (entry, tmp_entry, cap_hndl->pts_queue,
+						  list) {
+				if (entry && entry == match_entry) {
+					list_del(&entry->list);
+					kfree(entry);
+				}
 			}
 		}
-	}
-	mutex_unlock(&cap_hndl->pts_mutex);
+		mutex_unlock(&cap_hndl->pts_mutex);
 
-	frmPTS = estPTS;
-	if (ptsHigh != estIdx)
-		vpu_output_dbg("Refine PTS\n");
+		frmPTS = estPTS;
+		if (ptsHigh != estIdx)
+			vpu_output_dbg("Refine PTS\n");
 
-	if (cap_hndl->pre_pts > frmPTS)
-		vpu_warn("PTS roll back %lld => %lld\n", cap_hndl->pre_pts,
-			 frmPTS);
+		if (cap_hndl->pre_pts > frmPTS)
+			vpu_warn("PTS roll back %lld => %lld\n", cap_hndl->pre_pts,
+				 frmPTS);
 
-	cap_hndl->pre_pts = frmPTS;
+		cap_hndl->pre_pts = frmPTS;
 
-	if (!ptsLow) {
-		cap_hndl->lastID = ptsHigh;
-	} else {
-		if (ptsHigh == cap_hndl->lastID || ptsLow < 0) {
-			frmPTS += (ptsLow * 100 / 9);
+		if (!ptsLow) {
+			cap_hndl->lastID = ptsHigh;
 		} else {
-			vpu_warn("invalid pts %d %d", ptsHigh, ptsLow);
+			if (ptsHigh == cap_hndl->lastID || ptsLow < 0) {
+				frmPTS += (ptsLow * 100 / 9);
+			} else {
+				vpu_warn("invalid pts %d %d", ptsHigh, ptsLow);
+			}
 		}
+	}else
+#endif
+	{
+		frmPTS = ptsHigh;
+		frmPTS = (frmPTS << 32) | ptsLow;
 	}
 
 	if (pts)
@@ -2184,7 +2204,7 @@ int ve2rpc_dqframe(struct ve2rpc *cap_hndl, void *disp_buf, uint64_t *pts,
 
 	return ret;
 }
-
+#ifdef REORDER_PTS
 int ve2rpc_free_pts(struct ve2rpc *cap_hndl)
 {
 	struct pts_queue *entry;
@@ -2205,6 +2225,7 @@ int ve2rpc_free_pts(struct ve2rpc *cap_hndl)
 	mutex_unlock(&cap_hndl->pts_mutex);
 	return 0;
 }
+#endif
 
 int ve2rpc_free_travel_frame(struct ve2rpc *cap_hndl)
 {
@@ -2486,7 +2507,6 @@ int ve2rpc_init_cap_handle(struct device *dev, struct ve2rpc **handle,
 			hndl->main_rb.rbinfo.buf_uncached;
 
 	hndl->outputRingIdx = 0;
-	hndl->lastID = 0;
 	hndl->col_matrix.matrix_coefficients = COLOR_MATRIX_COEF_DEFAULT;
 	for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
 		hndl->frame[i] = (uintptr_t)&frame[i];
@@ -2516,7 +2536,6 @@ int ve2rpc_init_cap_handle(struct device *dev, struct ve2rpc **handle,
 	INIT_LIST_HEAD(&hndl->qframe.list);
 	INIT_LIST_HEAD(&hndl->qframe.tlist);
 	mutex_init(&hndl->qframe.lock);
-	mutex_init(&hndl->pts_mutex);
 	mutex_init(&hndl->travel_mutex);
 	mutex_init(&hndl->dpb_mutex);
 
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.h b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.h
index ac3ce46cb241..e65298c490d4 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.h
@@ -195,10 +195,12 @@ struct ve2rpc {
 	uintptr_t *frame;
 	struct ve2rpc_qframe_wq qframe;
 	struct mutex lock;
+#ifdef REORDER_PTS
 	struct mutex pts_mutex;
 	struct list_head *pts_queue;
 	uint64_t pre_pts;
 	int lastID;
+#endif
 	uint32_t rpc_id;
 	struct rtk_krpc_ept_info *vcpu_ept_info;
 	struct v4l2_fh *fh;
@@ -217,6 +219,7 @@ struct ve2rpc {
 	uint8_t is_secure;
 	uint8_t is_adaptive_playback;
 	uint8_t is_error;
+	uint8_t is_pts_reorder;
 };
 
 struct pts_queue {
@@ -244,7 +247,9 @@ int ve2rpc_init_out_handle(struct device *dev, struct ve2rpc **handle,
 int ve2rpc_init_cap_handle(struct device *dev, struct ve2rpc **handle,
 			   uint8_t is_secure, struct v4l2_fh *fh);
 int ve2rpc_uninit_handle(struct ve2rpc *hndl);
+#ifdef REORDER_PTS
 int ve2rpc_free_pts(struct ve2rpc *cap_hndl);
+#endif
 int ve2rpc_free_travel_frame(struct ve2rpc *cap_hndl);
 int ve2rpc_add_travel_entry(struct ve2rpc *cap_hndl,
 	uint32_t y_phy_addr, uint32_t buflock_phy_addr,
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c b/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c
index 976f4d61abc3..4c33d138be15 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c
@@ -959,17 +959,21 @@ int vpu_stop_streaming(struct vb2_queue *q)
 	//int i = 0;
 	//struct vb2_buffer *vb2 = NULL;
 
-	if (!ctx->veng_ops)
+	if (!ctx || !ctx->veng_ops)
 		return -EINVAL;
 
 	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
-		wake_up_interruptible(&ctx->vpu_out_waitq);
-		if (ctx->thread_out)
+		if (ctx->thread_out) {
+			wake_up_interruptible(&ctx->vpu_out_waitq);
 			kthread_stop(ctx->thread_out);
+			ctx->thread_out = NULL;
+		}
 	} else {
-		wake_up_interruptible(&ctx->vpu_cap_waitq);
-		if (ctx->thread_cap)
+		if (ctx->thread_cap) {
+			wake_up_interruptible(&ctx->vpu_cap_waitq);
 			kthread_stop(ctx->thread_cap);
+			ctx->thread_cap = NULL;
+		}
 	}
 
 	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
@@ -1136,6 +1140,18 @@ static int vpu_reset_resource(void *fh)
 
 	if(vid_ctx && vid_ctx->ve_ctx &&
 		ctx && ctx->veng_ops) {
+		if (ctx->thread_out) {
+			wake_up_interruptible(&ctx->vpu_out_waitq);
+			kthread_stop(ctx->thread_out);
+			ctx->thread_out = NULL;
+		}
+
+		if (ctx->thread_cap) {
+			wake_up_interruptible(&ctx->vpu_cap_waitq);
+			kthread_stop(ctx->thread_cap);
+			ctx->thread_cap = NULL;
+		}
+
 		ctx->veng_ops->ve_free_context(vid_ctx->ve_ctx);
 		ctx->veng_ops = NULL;
 
-- 
2.45.2

