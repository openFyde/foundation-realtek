From ec8d77dc7feb9c6bce36cb68c1fa40cbdc8d4db9 Mon Sep 17 00:00:00 2001
From: Edward Wu <edwardwu@realtek.com>
Date: Tue, 18 Jun 2024 10:46:11 +0800
Subject: [PATCH] update v4l2 0619

Change-Id: I013b58f0e89b3df0f81c252af77bac49932a7722
---
 .../media/platform/rtk_vdec_rtd16xxb/drv_if.c |  34 +++++-
 .../media/platform/rtk_vdec_rtd16xxb/drv_if.h |   3 +
 .../platform/rtk_vdec_rtd16xxb/ve1_v4l2.c     |  12 +-
 .../media/platform/rtk_vdec_rtd16xxb/ve2.c    |  10 +-
 .../media/platform/rtk_vdec_rtd16xxb/vpu.c    | 113 ++++++++++++------
 .../media/platform/rtk_vdec_rtd16xxb/vpu.h    |   1 +
 6 files changed, 125 insertions(+), 48 deletions(-)

diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c b/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c
index d3c33e6b73cc..e5e3e2c7e6ea 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c
@@ -433,6 +433,33 @@ int vpu_ctrls_setup(struct videc_ctx *ctx)
 	return v4l2_ctrl_handler_setup(&ctx->ctrl_hdl);
 }
 
+static int videc_reqbufs(struct file *file, void *priv,
+				struct v4l2_requestbuffers *rb)
+{
+	const struct vpu_fmt_ops *op = get_vpu_fmt_ops();
+	struct v4l2_fh *fh = file->private_data;
+	struct videc_ctx *ctx = file2ctx(file);
+	int ret = 0;
+
+	ret = v4l2_m2m_ioctl_reqbufs(file, priv, rb);
+	if (ret)
+		return ret;
+
+	if (V4L2_TYPE_IS_OUTPUT(rb->type))
+		ctx->reqbuf_out = rb->count;
+	else
+		ctx->reqbuf_cap = rb->count;
+
+	if (ctx->reqbuf_out == 0 && ctx->reqbuf_cap == 0) {
+		op->vpu_reset_resource(fh);
+		ctx->ve_ctx = NULL;
+		ctx->reqbuf_out = -1;
+		ctx->reqbuf_cap = -1;
+	}
+
+	return ret;
+}
+
 static int videc_querybuf(struct file *file, void *priv,
 			  struct v4l2_buffer *buf)
 {
@@ -605,7 +632,7 @@ static const struct v4l2_ioctl_ops vpu_ioctl_ops = {
 	.vidioc_try_fmt_vid_out_mplane	= videc_try_fmt_vid_out,
 	.vidioc_s_fmt_vid_out_mplane = videc_s_fmt_vid_out,
 
-	.vidioc_reqbufs = v4l2_m2m_ioctl_reqbufs,
+	.vidioc_reqbufs = videc_reqbufs,
 	.vidioc_querybuf = videc_querybuf,
 	.vidioc_qbuf = videc_qbuf,
 	.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,
@@ -946,6 +973,8 @@ static int vpu_open(struct file *file)
 		kfree(ctx);
 		goto open_unlock;
 	}
+	ctx->reqbuf_out = -1;
+	ctx->reqbuf_cap = -1;
 
 	v4l2_fh_init(&ctx->fh, video_devdata(file));
 	file->private_data = &ctx->fh;
@@ -999,7 +1028,8 @@ static int vpu_release(struct file *file)
 	v4l2_m2m_ctx_release(ctx->fh.m2m_ctx);
 	mutex_unlock(&dev->dev_mutex);
 
-	vpu_free_context(ctx->vpu_ctx);
+	if (ctx->vpu_ctx)
+		vpu_free_context(ctx->vpu_ctx);
 
 	v4l2_ctrl_handler_free(&ctx->ctrl_hdl);
 
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.h b/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.h
index 3391097e8d08..fcb3ca37262d 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.h
@@ -60,6 +60,9 @@ struct videc_ctx {
 	void *vpu_ctx; /* context of vpu */
 	void *ve_ctx; /* context of video engine */
 
+	int reqbuf_out;
+	int reqbuf_cap;
+
 	struct v4l2_ctrl_handler ctrl_hdl;
 	struct videc_params params;
 };
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_v4l2.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_v4l2.c
index 2af79f1267eb..2e3a2c3479c0 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_v4l2.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_v4l2.c
@@ -832,7 +832,7 @@ static void ve1_free_context(void *pCtx)
 	}
 	ctx = (struct ve1_ctx *)pCtx;
 
-	if (ctx->ops->seq_end_work) {
+	if (ctx->ops && ctx->ops->seq_end_work) {
 		// queue seq_end_work on workqueue
 		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "queue_work seq_end_work\n");
 		queue_work(ctx->workqueue, &ctx->seq_end_work);
@@ -849,12 +849,14 @@ static void ve1_free_context(void *pCtx)
 		ctx->workqueue = NULL;
 	}
 
-	if (ctx->ops->release) {
+	if (ctx->ops && ctx->ops->release) {
 		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "ops->release\n");
 		ctx->ops->release(ctx);
 	}
 
-	mutex_lock(&ctx->ve1_mutex);
+	if (ctx->ops)
+		mutex_lock(&ctx->ve1_mutex);
+
 	if (ctx->decOP) {
 		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "kfree decOP\n");
 		kfree(ctx->decOP);
@@ -905,7 +907,9 @@ static void ve1_free_context(void *pCtx)
 		kfree(ctx->picHeader);
 		ctx->picHeader = NULL;
 	}
-	mutex_unlock(&ctx->ve1_mutex);
+
+	if (ctx->ops)
+		mutex_unlock(&ctx->ve1_mutex);
 
 	kfree(ctx);
 }
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c
index 327dea1a4a01..770915a16ba1 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c
@@ -22,6 +22,7 @@
 #endif
 #include <media/v4l2-mem2mem.h>
 #include <media/videobuf2-dma-contig.h>
+#include <media/v4l2-ioctl.h>
 
 #include "drv_if.h"
 #include "vpu.h"
@@ -258,12 +259,14 @@ int ve2_start_streaming(struct vb2_queue *q, uint32_t count, int pixelformat)
 
 	if (V4L2_TYPE_IS_OUTPUT(type)) {
 		ctx->streamon_out = 1;
+		ctx->streamoff_out = 0;
 		ctx->out_hndl->type = type;
 #ifdef VPU_GET_CC
 		cc_data_channel_init();
 #endif
 	} else {
 		ctx->streamon_cap = 1;
+		ctx->streamoff_cap = 0;
 		ctx->cap_hndl->type = type;
 	}
 
@@ -439,6 +442,8 @@ int ve2_stop_streaming(struct vb2_queue *q)
 			return ret;
 		}
 		ctx->cap_hndl = NULL;
+		ctx->streamon_out = 0;
+		ctx->streamon_cap = 0;
 	}
 
 	if (V4L2_TYPE_IS_OUTPUT(type))
@@ -529,7 +534,7 @@ static int ve2_cap_qbuf(void *fh, struct vb2_buffer *vb)
 	vb2_v4l2_buf = to_vb2_v4l2_buffer(vb);
 
 	cap_buf_paddr = vb2_dma_contig_plane_dma_addr(vb, 0);
-	if (!ctx->streamon_cap) {
+	if (ctx->cap_hndl->dpb_cnt < vb->vb2_queue->num_buffers) {
 		uint32_t cap_buf_size = 0;
 
 		cap_buf_size = vb2_plane_size(vb, 0);
@@ -776,8 +781,7 @@ static int ve2_stop_cmd(void *fh, int pixelformat)
 		goto out;
 	}
 
-	if (ctx->eosEvent == 0 &&
-		hndl->out_q_fill_cnt >= v_ctx->out_q_cnt) {
+	if (ctx->eosEvent == 0) {
 		if (v_ctx->out_fmt.spec.fmt.pix_mp.pixelformat ==
 		    V4L2_PIX_FMT_HEVC)
 			ve2rpc_inband_eos_event(&hndl->sub_rb,
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c b/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c
index b1e8489bb2a9..713ccddb6bc6 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c
@@ -749,9 +749,11 @@ static int vpu_s_fmt_cap(struct v4l2_fh *fh, struct v4l2_format *f)
 
 static int vpu_s_fmt_out(struct v4l2_fh *fh, struct v4l2_format *f)
 {
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
 	struct vpu_ctx *ctx = fh_to_vpu(fh);
 	const struct vpu_fmt *fmt = NULL;
 	int pixelformat = 0;
+	int ret = 0;
 
 	fmt = find_format(f);
 	if (!fmt) {
@@ -777,8 +779,8 @@ static int vpu_s_fmt_out(struct v4l2_fh *fh, struct v4l2_format *f)
 	case V4L2_PIX_FMT_VC1_ANNEX_L:
 		/* Set VE1 ops */
 		if (!ctx->ve1_ops) {
-			mutex_unlock(&ctx->vpu_mutex);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto exit;
 		}
 		ctx->veng_ops = ctx->ve1_ops;
 		ctx->out_fmt.misc.VideoEngine = VIDEO_ENGINE_1;
@@ -788,8 +790,8 @@ static int vpu_s_fmt_out(struct v4l2_fh *fh, struct v4l2_format *f)
 	case V4L2_PIX_FMT_AV1:
 		/* Set VE2 ops */
 		if (!ctx->ve2_ops) {
-			mutex_unlock(&ctx->vpu_mutex);
-			return -EINVAL;
+			ret =  -EINVAL;
+			goto exit;
 		}
 		ctx->veng_ops = ctx->ve2_ops;
 		ctx->out_fmt.misc.VideoEngine = VIDEO_ENGINE_2;
@@ -807,6 +809,18 @@ static int vpu_s_fmt_out(struct v4l2_fh *fh, struct v4l2_format *f)
 	ctx->cap_fmt.spec.fmt.pix_mp.quantization = f->fmt.pix_mp.quantization;
 	ctx->cap_fmt.spec.fmt.pix_mp.xfer_func = f->fmt.pix_mp.xfer_func;
 
+	/* Allocate video engine context */
+	if (!vid_ctx->ve_ctx) {
+		vid_ctx->ve_ctx =
+			ctx->veng_ops->ve_alloc_context(vid_ctx->file);
+		if (!vid_ctx->ve_ctx) {
+			ret = -EINVAL;
+			pr_err("JJJ %s, %d", __func__, __LINE__);
+			goto exit;
+		}
+	}
+
+exit:
 	mutex_unlock(&ctx->vpu_mutex);
 
 	return 0;
@@ -871,17 +885,6 @@ int vpu_start_streaming(struct vb2_queue *q, uint32_t count)
 	}
 
 	mutex_lock(&ctx->vpu_mutex);
-	/* Allocate video engine context */
-	if (!vid_ctx->ve_ctx) {
-		vid_ctx->ve_ctx =
-			ctx->veng_ops->ve_alloc_context(vid_ctx->file);
-		if (!vid_ctx->ve_ctx) {
-			mutex_unlock(&ctx->vpu_mutex);
-			ret = -EINVAL;
-			goto exit;
-		}
-	}
-
 	ret = ctx->veng_ops->ve_start_streaming(q, count, pixelformat);
 	if (ret) {
 		vpu_err("Failed to start streaming %d\n", ret);
@@ -965,29 +968,6 @@ int vpu_stop_streaming(struct vb2_queue *q)
 	else
 		ctx->is_cap_started = 0;
 	if (!ctx->is_cap_started && !ctx->is_out_started) {
-		if(vid_ctx->ve_ctx) {
-			ctx->veng_ops->ve_free_context(vid_ctx->ve_ctx);
-			vid_ctx->ve_ctx = NULL;
-		}
-		ctx->veng_ops = NULL;
-
-		// reset other variables of struct videc_ctx
-		// init ctx->out with default value
-		memcpy(&ctx->out_fmt, &out_fmt[0], sizeof(struct vpu_fmt));
-		// init ctx->cap with default value
-		memcpy(&ctx->cap_fmt, &cap_fmt[0], sizeof(struct vpu_fmt));
-		memset(&ctx->rect, 0, sizeof(struct v4l2_rect));
-		ctx->thread_out = NULL;
-		ctx->thread_cap = NULL;
-		ctx->seq_out = 1;
-		ctx->seq_cap = 1;
-		ctx->memory_out = 0;
-		ctx->memory_cap = 0;
-		ctx->stop_cmd = false;
-		ctx->last_buf_done = false;
-		ctx->miss_last_buf_done = false;
-		ctx->cap_retry_cnt = 0;
-		ctx->out_q_cnt = 0;
 		reinit_completion(&ctx->bs_parsing_comp);
 	}
 
@@ -1096,6 +1076,40 @@ static int vpu_stop_cmd(void *fh)
 	return ret;
 }
 
+static int vpu_reset_resource(void *fh)
+{
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	struct vpu_ctx *ctx = fh_to_vpu(fh);
+
+	if(vid_ctx && vid_ctx->ve_ctx &&
+		ctx && ctx->veng_ops) {
+		ctx->veng_ops->ve_free_context(vid_ctx->ve_ctx);
+		ctx->veng_ops = NULL;
+
+		// reset other variables of struct videc_ctx
+		// init ctx->out with default value
+		memcpy(&ctx->out_fmt, &out_fmt[0], sizeof(struct vpu_fmt));
+		// init ctx->cap with default value
+		memcpy(&ctx->cap_fmt, &cap_fmt[0], sizeof(struct vpu_fmt));
+		memset(&ctx->rect, 0, sizeof(struct v4l2_rect));
+		ctx->thread_out = NULL;
+		ctx->thread_cap = NULL;
+		ctx->seq_out = 1;
+		ctx->seq_cap = 1;
+		ctx->memory_out = 0;
+		ctx->memory_cap = 0;
+		ctx->stop_cmd = false;
+		ctx->last_buf_done = false;
+		ctx->miss_last_buf_done = false;
+		ctx->cap_retry_cnt = 0;
+		ctx->out_q_cnt = 0;
+	}else {
+		vpu_err("Reset nothing");
+	}
+
+	return 0;
+}
+
 void *vpu_get_frmsize(uint32_t pixel_format)
 {
 	int i = 0;
@@ -1200,6 +1214,7 @@ const static struct vpu_fmt_ops ops = {
 	.vpu_abort = vpu_abort,
 	.vpu_g_crop = vpu_g_crop,
 	.vpu_stop_cmd = vpu_stop_cmd,
+	.vpu_reset_resource = vpu_reset_resource,
 };
 
 const struct vpu_fmt_ops *get_vpu_fmt_ops(void)
@@ -1259,7 +1274,27 @@ void *vpu_alloc_context(void)
 
 void vpu_free_context(void *ctx)
 {
-	kfree(ctx);
+	struct vpu_ctx *vpu_ctx = ctx;
+
+	// reset other variables of struct videc_ctx
+	// init ctx->out with default value
+	memcpy(&vpu_ctx->out_fmt, &out_fmt[0], sizeof(struct vpu_fmt));
+	// init ctx->cap with default value
+	memcpy(&vpu_ctx->cap_fmt, &cap_fmt[0], sizeof(struct vpu_fmt));
+	memset(&vpu_ctx->rect, 0, sizeof(struct v4l2_rect));
+	vpu_ctx->thread_out = NULL;
+	vpu_ctx->thread_cap = NULL;
+	vpu_ctx->seq_out = 1;
+	vpu_ctx->seq_cap = 1;
+	vpu_ctx->memory_out = 0;
+	vpu_ctx->memory_cap = 0;
+	vpu_ctx->stop_cmd = false;
+	vpu_ctx->last_buf_done = false;
+	vpu_ctx->miss_last_buf_done = false;
+	vpu_ctx->cap_retry_cnt = 0;
+	vpu_ctx->out_q_cnt = 0;
+
+	kfree(vpu_ctx);
 }
 /*
  * Register video engine operations.
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.h b/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.h
index d7a884794526..7ba9cf992271 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.h
@@ -78,6 +78,7 @@ struct vpu_fmt_ops {
 	int (*vpu_abort)(void *priv, int type);
 	int (*vpu_g_crop)(void *fh, struct v4l2_rect *rect);
 	int (*vpu_stop_cmd)(void *fh);
+	int (*vpu_reset_resource)(void *fh);
 };
 
 const struct vpu_fmt_ops *get_vpu_fmt_ops(void);
-- 
2.45.2

