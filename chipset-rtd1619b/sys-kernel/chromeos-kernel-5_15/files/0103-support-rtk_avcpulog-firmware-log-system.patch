From ec0598f69283e85487d5b904d5ce79be865a7224 Mon Sep 17 00:00:00 2001
From: Edward Wu <edwardwu@realtek.com>
Date: Thu, 18 Jul 2024 06:21:19 +0800
Subject: [PATCH] support rtk_avcpulog firmware log system

recipes-kernel: rtk_fw_remoteproc: fix error and warning message from checkpatch
recipes-kernel: rtk_fw_remoteproc: fix improper validation of log settings
recipes-kernel: rtk_fw_remoteproc: read log buffer settings from DTB and update them to IPC shared memory
recipes-kernel: rtk_avcpulog: use request_module() to ensure module dependency
recipes-kernel: auto loading rtk_avcpulog module
arm64: dts: rtd16xxb: reserved firmware log buffer
recipes-kernel: rtk_avcpulog: update module dependency
arm64: dts: rtd16xxb: rtk_avcpu: remove unnecessary nodes
recipes-kernel: rtk_avcpulog: update avcpu log interface to latest version

Change-Id: Id39b2dd522055b23baf2f731a0aed4abc9221fd4
---
 arch/arm64/boot/dts/realtek/rtd16xxb.dtsi |  21 ++-
 drivers/remoteproc/rtk_fw_remoteproc.c    | 164 ++++++++++++++--
 drivers/soc/realtek/common/Kconfig        |   2 +-
 drivers/soc/realtek/common/rtk_avcpulog.c | 219 +++++++++++++++-------
 4 files changed, 319 insertions(+), 87 deletions(-)

diff --git a/arch/arm64/boot/dts/realtek/rtd16xxb.dtsi b/arch/arm64/boot/dts/realtek/rtd16xxb.dtsi
index ea0d06866732..17e7cbb85ec0 100644
--- a/arch/arm64/boot/dts/realtek/rtd16xxb.dtsi
+++ b/arch/arm64/boot/dts/realtek/rtd16xxb.dtsi
@@ -104,6 +104,21 @@ cma_reserved_1:linux,cma_1 {
 			reusable;
 		};
 
+		alog: alog {
+			reg = <0x0487D000 0x8000>;
+			no-map;
+		};
+
+		vlog: vlog {
+			reg = <0x04885000 0x8000>;
+			no-map;
+		};
+
+		hlog0: hlog0 {
+			reg = <0x0488D000 0x8000>;
+			no-map;
+		};
+
 	};
 
 	clocks {
@@ -916,20 +931,14 @@ rtk_avcpu: rtk_avcpu {
 		status = "disabled";
 
 		alog {
-			hwlocks = <&sb2_lock_avlog 0>;
-			sync_lock_timeout = <500>; /* ms */
 			log_check_period = <500>; /* ms */
 		};
 
 		vlog {
-			hwlocks = <&sb2_lock_avlog 0>;
-			sync_lock_timeout = <500>; /* ms */
 			log_check_period = <500>; /* ms */
 		};
 
 		hlog {
-			hwlocks = <&sb2_lock_avlog 0>;
-			sync_lock_timeout = <500>; /* ms */
 			log_check_period = <500>; /* ms */
 		};
 	};
diff --git a/drivers/remoteproc/rtk_fw_remoteproc.c b/drivers/remoteproc/rtk_fw_remoteproc.c
index b2e35d76d3de..6cfd2a5e8eb8 100644
--- a/drivers/remoteproc/rtk_fw_remoteproc.c
+++ b/drivers/remoteproc/rtk_fw_remoteproc.c
@@ -23,6 +23,8 @@
 #include <linux/slab.h>
 #include <soc/realtek/rtk_tee.h>
 #include <soc/realtek/memory.h>
+#include <soc/realtek/rtk_ipc_shm.h>
+#include <soc/realtek/rtk-rpmsg.h>
 
 #define FIT_IMAGES "images"
 #define MAX_DELIVER_SIZE (3 * 1024 * 1024)
@@ -30,6 +32,7 @@
 #define VFW       0xff04
 #define HIFI_FW   0xff0a
 #define AFW_CERT  21
+#define TOT_NR_FWS 8
 
 struct rtk_fw_rproc {
 	struct rproc *rproc;
@@ -38,6 +41,131 @@ struct rtk_fw_rproc {
 	const char *fw_name;
 };
 
+static uint32_t log_addr[TOT_NR_FWS] = { 0 };
+static uint32_t log_size[TOT_NR_FWS] = { 0 };
+static uint32_t log_level[TOT_NR_FWS] = { 0 };
+
+static char log_dev_name[TOT_NR_FWS][6] = {
+	[AUDIO_ID] = "alog",
+	[VIDEO_ID] = "vlog",
+	[HIFI_ID] = "hlog0",
+};
+
+static void fdt_find_log_shm(unsigned int id)
+{
+	struct device_node *log_dev;
+	int len;
+	const __be32 *prop;
+
+	switch (id) {
+	case AUDIO_ID:
+		log_dev = of_find_node_by_path("/reserved-memory/alog");
+		break;
+	case VIDEO_ID:
+		log_dev = of_find_node_by_path("/reserved-memory/vlog");
+		break;
+	case HIFI_ID:
+		log_dev = of_find_node_by_path("/reserved-memory/hlog0");
+		break;
+	default:
+		return;
+	}
+
+	if (log_dev) {
+		prop = of_get_property(log_dev, "reg", &len);
+		if (prop) {
+			if (len != (2 * sizeof(__be32)))
+				pr_info("Invalid %s property setting.\n",
+					log_dev_name[id]);
+			else {
+				log_addr[id] = cpu_to_be32(*prop);
+				log_size[id] = cpu_to_be32(*(++prop));
+				pr_info("Found %s buffer at 0x%x, size:0x%x.\n",
+					log_dev_name[id], log_addr[id],
+					log_size[id]);
+			}
+		}
+	}
+	of_node_put(log_dev);
+}
+
+static void fdt_find_log_level(unsigned int id)
+{
+	struct device_node *log_dev;
+	int len;
+	const __be32 *prop;
+
+	switch (id) {
+	case AUDIO_ID:
+		log_dev = of_find_node_by_path("/rtk_avcpu/alog");
+		break;
+	case VIDEO_ID:
+		log_dev = of_find_node_by_path("/rtk_avcpu/vlog");
+		break;
+	case HIFI_ID:
+		log_dev = of_find_node_by_path("/rtk_avcpu/hlog");
+		break;
+	default:
+		return;
+	}
+
+	if (log_dev) {
+		prop = of_get_property(log_dev, "lvl", &len);
+		if (prop) {
+			if (len != sizeof(__be32))
+				pr_info("Invalid %s level setting.\n",
+					log_dev_name[id]);
+			else {
+				log_level[id] = cpu_to_be32(*prop);
+				pr_info("Found %s level setting:0x%x.\n",
+					log_dev_name[id], log_level[id]);
+			}
+		}
+	}
+	of_node_put(log_dev);
+}
+
+static void log_shm_setup(unsigned int id)
+{
+	struct avcpu_syslog_struct __iomem *avlog_p;
+
+	switch (id) {
+	case AUDIO_ID:
+		avlog_p =
+			(struct avcpu_syslog_struct
+				 *)(IPC_SHM_VIRT + offsetof(struct rtk_ipc_shm,
+							    printk_buffer));
+		break;
+	case VIDEO_ID:
+		avlog_p = (struct avcpu_syslog_struct
+				   *)(IPC_SHM_VIRT +
+				      offsetof(struct rtk_ipc_shm,
+					       video_printk_buffer));
+		break;
+	case HIFI_ID:
+		avlog_p = (struct avcpu_syslog_struct
+				   *)(IPC_SHM_VIRT +
+				      offsetof(struct rtk_ipc_shm,
+					       hifi_printk_buffer));
+		break;
+	default:
+		avlog_p = NULL;
+		break;
+	}
+	if (avlog_p) {
+		/* Check if buffer info is valid */
+		if ((log_addr[id] && (!log_size[id])) ||
+		    ((!log_addr[id]) && log_size[id]))
+			pr_err("Invalid %s setting (addr:0x%x, size:0x%x)",
+			       log_dev_name[id], log_addr[id], log_size[id]);
+		else {
+			avlog_p->log_buf_addr = log_addr[id];
+			avlog_p->log_buf_len = log_size[id];
+			avlog_p->con_start = log_level[id];
+		}
+	}
+}
+
 static int trust_fw_load(struct rproc *rproc, const struct firmware *fw)
 {
 	struct device *dev = &rproc->dev;
@@ -56,11 +184,9 @@ static int trust_fw_load(struct rproc *rproc, const struct firmware *fw)
 
 	/* alloc uncached memory */
 	vaddr = dma_alloc_coherent(dev->parent, size, &dma, GFP_KERNEL);
-	if (!vaddr) {
-		dev_err(dev, "dma_alloc coherent fail\n");
-		ret = false;
-		goto err;
-	}
+	if (!vaddr)
+		return -ENOMEM;
+
 	memcpy(vaddr, fw->data, fw->size);
 
 	arm_smccc_smc(0x8400ff39, dma, fw->size,
@@ -143,6 +269,7 @@ static int acpu_start(struct rproc *rproc)
 	struct arm_smccc_res res;
 	void __iomem *map_bit;
 
+	log_shm_setup(AUDIO_ID);
 	dev_info(&rproc->dev, "afw bring up\n");
 
 	pll_acpu1_lpf_rs_set(8);
@@ -209,6 +336,7 @@ static int acpu_stop(struct rproc *rproc)
 static void pll_ve2_set_analog(unsigned int val)
 {
 	void __iomem *map_bit;
+
 	map_bit = ioremap(SYS_PLL_VE2_1, 0x120);
 	writel(val, map_bit);
 	iounmap(map_bit);
@@ -234,6 +362,7 @@ static int vcpu_start(struct rproc *rproc)
 {
 	void __iomem *map_bit;
 
+	log_shm_setup(VIDEO_ID);
 	dev_info(&rproc->dev, "vfw bring up\n");
 
 	map_bit = ioremap(VCPU_STARTUP_FLAG, 0x120);
@@ -266,7 +395,7 @@ static int vcpu_stop(struct rproc *rproc)
 
 #define SYS_PLL_HIFI1		0x980001D8
 #define SYS_PLL_HIFI2		0x980001DC
-#define SYS_PLL_SSC_DIG_HIFI0 	0x980006E0
+#define SYS_PLL_SSC_DIG_HIFI0	0x980006E0
 #define SYS_PLL_SSC_DIG_HIFI1	0x980006E4
 
 #define HIFI_PLL_486MHZ 0x00010800
@@ -320,6 +449,7 @@ void set_hifi_pll_and_ssc_control(uint32_t freq_setting)
 static void disable_hifi_pll(void)
 {
 	void __iomem *map_bit;
+
 	map_bit = ioremap(SYS_PLL_HIFI2, 0x120);
 	writel(0x00000004, map_bit);
 	iounmap(map_bit);
@@ -343,7 +473,7 @@ static int _do_npu_bisr(void)
 
 	/* 50 ms timeout for checking SRAM bist is done */
 	map_bit = ioremap(0x98086800, 0x120);
-	for (i = 0;i < TIMEOUT_MS; i++) {
+	for (i = 0; i < TIMEOUT_MS; i++) {
 		if ((readl(map_bit) & 0x10) == 0x10)
 			break;
 		udelay(1000);
@@ -471,6 +601,7 @@ static int hifi_start(struct rproc *rproc)
 	struct arm_smccc_res res;
 	int ret;
 
+	log_shm_setup(HIFI_ID);
 	dev_info(&rproc->dev, "hifi bring up\n");
 
 	hifi_poweron();
@@ -526,9 +657,8 @@ static int rtk_register_rproc(struct device *dev, struct device_node *node)
 	if (ret) {
 		dev_err(dev, "No firmware type given\n");
 		return -ENODEV;
-	} else {
-		dev_info(dev, "Register rproc type %s\n", fw_type);
 	}
+	dev_info(dev, "Register rproc type %s\n", fw_type);
 
 	ret = of_property_read_string(node, "name-firmware",
 				      &fw_name);
@@ -563,15 +693,14 @@ static int rtk_register_rproc(struct device *dev, struct device_node *node)
 	rtk_rproc->fw_name = fw_name;
 	rtk_rproc->node = node;
 
-	if (!strcmp(fw_type, "acpu")) {
+	if (!strcmp(fw_type, "acpu"))
 		rtk_rproc->cert_type = AFW;
-	} else if (!strcmp(fw_type, "vcpu")) {
+	else if (!strcmp(fw_type, "vcpu"))
 		rtk_rproc->cert_type = VFW;
-	} else if (!strcmp(fw_type, "hifi")) {
+	else if (!strcmp(fw_type, "hifi"))
 		rtk_rproc->cert_type = HIFI_FW;
-	} else if (!strcmp(fw_type, "avcert")) {
+	else if (!strcmp(fw_type, "avcert"))
 		rtk_rproc->cert_type = AFW_CERT;
-	}
 
 	dev_set_drvdata(dev, rproc);
 
@@ -682,6 +811,13 @@ static struct platform_driver rtk_rproc_driver = {
 
 static int __init rtk_rproc_init(void)
 {
+	int i;
+
+	for (i = 0; i < TOT_NR_FWS; i++) {
+		fdt_find_log_shm(i);
+		fdt_find_log_level(i);
+	}
+
 	return platform_driver_register(&rtk_rproc_driver);
 }
 late_initcall(rtk_rproc_init);
diff --git a/drivers/soc/realtek/common/Kconfig b/drivers/soc/realtek/common/Kconfig
index 2dc5b180b4da..74829a06ea0e 100644
--- a/drivers/soc/realtek/common/Kconfig
+++ b/drivers/soc/realtek/common/Kconfig
@@ -127,7 +127,7 @@ config RTK_DBGPROT
 
 config RTK_AVCPU_LOG
 	tristate "Realtek AVCPU share memory logging system"
-	depends on RPMSG_RTK_RPC
+	depends on RTK_FW_REMOTEPROC
 	default y
 	help
 	  Enable AVCPU share memory logging read from userspace
diff --git a/drivers/soc/realtek/common/rtk_avcpulog.c b/drivers/soc/realtek/common/rtk_avcpulog.c
index 27d3d39f5657..f53c2d6ad9af 100644
--- a/drivers/soc/realtek/common/rtk_avcpulog.c
+++ b/drivers/soc/realtek/common/rtk_avcpulog.c
@@ -20,23 +20,31 @@
 #include <linux/platform_device.h>
 #include <linux/io.h>
 #include <linux/hwspinlock.h>
+#include <linux/timer.h>
+#include <linux/sched/clock.h>
 #include <soc/realtek/rtk_ipc_shm.h>
 
+static unsigned int tag_rfsh = 30;
+module_param(tag_rfsh, uint, 0444);
+MODULE_PARM_DESC(tag_rfsh,
+		 "Refresh time of Ktime tag in seconds, default 30s;");
+
 struct log_device_info_t {
 	char name[16];
 	unsigned int offset;
 };
 
 static const struct log_device_info_t log_device_info_list[] = {
-	{"alog", offsetof(struct rtk_ipc_shm, printk_buffer)},
-	{"vlog", offsetof(struct rtk_ipc_shm, video_printk_buffer)},
-	{"hlog", offsetof(struct rtk_ipc_shm, hifi_printk_buffer)},
+	{ "alog", offsetof(struct rtk_ipc_shm, printk_buffer) },
+	{ "vlog", offsetof(struct rtk_ipc_shm, video_printk_buffer) },
+	{ "hlog", offsetof(struct rtk_ipc_shm, hifi_printk_buffer) },
 };
 
-#define MODULE_NAME		"avlog"
-#define MODULE_NUM		(ARRAY_SIZE(log_device_info_list))
-#define HWSEM_DEF_TIMEOUT	500 /* msec */
-#define WORK_DEF_DELAY_TIME	500 /* msec */
+#define MODULE_NAME "avlog"
+#define MODULE_NUM (ARRAY_SIZE(log_device_info_list))
+#define WORK_DEF_DELAY_TIME 500 /* msec */
+#define SYSDBG_MAP_BASE 0x980076E4
+#define TAG_LINE_MAX 128
 
 enum LOG_STAT {
 	L_NOTAVAIL = 0,
@@ -59,10 +67,11 @@ struct log_device_t {
 	atomic_t cnt;
 	enum LOG_STAT stat;
 	struct task_struct *tsk;
-	u64 record_start;
+	unsigned int record_start;
 	struct completion completion;
 	/* dynamic vars doesn't require lock */
 	unsigned int work_delay;
+	bool tag_updt;
 };
 
 struct avlog_ctl_t {
@@ -71,9 +80,14 @@ struct avlog_ctl_t {
 	struct cdev cdev;
 	/* dynamic vars */
 	struct log_device_t log_device[MODULE_NUM];
+	struct timer_list syslog_tag_timer;
+	void __iomem *sysdbg_p;
 };
 
-static int log_buf_check_adjust(u64 *rec_start, u64 *end, u32 buf_sz)
+static struct avlog_ctl_t *avlog_ctl;
+
+static int log_buf_check_adjust(unsigned int *rec_start, unsigned int *end,
+				u32 buf_sz)
 {
 	int ret = 0;
 
@@ -83,8 +97,7 @@ static int log_buf_check_adjust(u64 *rec_start, u64 *end, u32 buf_sz)
 	if (*rec_start > *end && *end < buf_sz)
 		*end += (UINT_MAX + 1);
 
-	if (*rec_start > *end ||
-	    *end - *rec_start > buf_sz) {
+	if (*rec_start > *end || *end - *rec_start > buf_sz) {
 		*rec_start = *end - buf_sz;
 		ret = 1;
 	}
@@ -94,7 +107,8 @@ static int log_buf_check_adjust(u64 *rec_start, u64 *end, u32 buf_sz)
 
 static void log_check_work_fn(struct work_struct *work)
 {
-	struct log_device_t *log_device = container_of(work, struct log_device_t, log_check_work.work);
+	struct log_device_t *log_device =
+		container_of(work, struct log_device_t, log_check_work.work);
 	uint32_t log_end;
 
 	/* check if log had updated, if yes wake up reader. If not,	*/
@@ -113,8 +127,9 @@ static void log_check_work_fn(struct work_struct *work)
 		complete_all(&log_device->completion);
 		log_device->stat = L_RUNNING;
 	} else {
-		if (!schedule_delayed_work(&log_device->log_check_work,
-			msecs_to_jiffies(log_device->work_delay))) {
+		if (!schedule_delayed_work(
+			    &log_device->log_check_work,
+			    msecs_to_jiffies(log_device->work_delay))) {
 			/* wake up reader directly or reader may sleep forever */
 			pr_err("%s: fail to schedule work\n", __func__);
 			log_device->stat = L_ERR;
@@ -127,10 +142,11 @@ static void log_check_work_fn(struct work_struct *work)
 
 static int rtk_avcpu_log_open(struct inode *inode, struct file *filp)
 {
-	struct avlog_ctl_t *av_ctl = container_of(inode->i_cdev, struct avlog_ctl_t, cdev);
+	struct avlog_ctl_t *av_ctl =
+		container_of(inode->i_cdev, struct avlog_ctl_t, cdev);
 	struct log_device_t *log_device;
 	int idx;
-	u64 log_end;
+	unsigned int log_end;
 
 	idx = iminor(inode);
 	log_device = &av_ctl->log_device[idx];
@@ -146,7 +162,8 @@ static int rtk_avcpu_log_open(struct inode *inode, struct file *filp)
 
 	log_device->tsk = current;
 	log_device->stat = L_RUNNING;
-	log_buf_check_adjust(&log_device->record_start, &log_end, log_device->syslog_p->log_buf_len);
+	log_buf_check_adjust(&log_device->record_start, &log_end,
+			     log_device->syslog_p->log_buf_len);
 	filp->private_data = log_device;
 	atomic_inc(&log_device->cnt);
 	spin_unlock(&log_device->dev_lock);
@@ -156,7 +173,8 @@ static int rtk_avcpu_log_open(struct inode *inode, struct file *filp)
 
 static int rtk_avcpu_log_release(struct inode *inode, struct file *filp)
 {
-	struct avlog_ctl_t *av_ctl = container_of(inode->i_cdev, struct avlog_ctl_t, cdev);
+	struct avlog_ctl_t *av_ctl =
+		container_of(inode->i_cdev, struct avlog_ctl_t, cdev);
 	struct log_device_t *log_device;
 	uint32_t idx;
 
@@ -178,17 +196,21 @@ static int rtk_avcpu_log_release(struct inode *inode, struct file *filp)
 }
 
 static ssize_t rtk_avcpu_log_read(struct file *filp, char __user *buf,
-		size_t count, loff_t *f_pos)
+				  size_t count, loff_t *f_pos)
 {
-	struct log_device_t *log_device = (struct log_device_t *)filp->private_data;
+	struct log_device_t *log_device =
+		(struct log_device_t *)filp->private_data;
 	struct avcpu_syslog_struct *p_syslog = log_device->syslog_p;
 	static const char drop_msg[] = "*** LOG DROP ***\n";
 	char *iter = NULL, *tmp_buf = NULL;
-	int err = 0, rcount = 0, log_count = 0, cp_count = 0;
+	int err = 0, rcount = 0, log_count = 0, cp_count = 0, tag_cnt;
 	unsigned int idx_start, idx_end;
-	unsigned long flags;
-	u64 log_start, log_end;
+	unsigned long flags, rem_nsec;
+	unsigned int log_start, log_end;
+	u64 ts_nsec;
 	bool drop = false;
+	u32 sysdbg_ts_usec;
+	char tag_buf[TAG_LINE_MAX];
 
 again:
 	/* if reader wake up by any signal under sleep stat,		*/
@@ -205,10 +227,8 @@ static ssize_t rtk_avcpu_log_read(struct file *filp, char __user *buf,
 
 	if (!tmp_buf)
 		tmp_buf = vmalloc(count);
-	if (!tmp_buf) {
-		pr_err("%s : allocate %d buf fail\n", __func__, (int)count);
+	if (!tmp_buf)
 		return -ENOMEM;
-	}
 
 	spin_lock_irqsave(&log_device->dev_lock, flags);
 
@@ -224,8 +244,9 @@ static ssize_t rtk_avcpu_log_read(struct file *filp, char __user *buf,
 	if (log_start == log_end) {
 		log_device->stat = L_WAITING;
 		reinit_completion(&log_device->completion);
-		if (!schedule_delayed_work(&log_device->log_check_work,
-			msecs_to_jiffies(log_device->work_delay))) {
+		if (!schedule_delayed_work(
+			    &log_device->log_check_work,
+			    msecs_to_jiffies(log_device->work_delay))) {
 			pr_err("%s: fail to schedule work\n", __func__);
 			log_device->stat = L_ERR;
 			err = -EFAULT;
@@ -238,12 +259,13 @@ static ssize_t rtk_avcpu_log_read(struct file *filp, char __user *buf,
 	}
 
 	/*
-	  use record_start if distance untill log_end is shortern than buf length,
-	  otherwise log drop happened.
-	*/
-	if (log_buf_check_adjust(&log_device->record_start, &log_end, p_syslog->log_buf_len)) {
-		printk_ratelimited(KERN_INFO"%s: drop start:0x%llx end:0x%llx\n",
-					__func__, log_start, log_end);
+	 * use record_start if distance untill log_end is shortern than buf length,
+	 * otherwise log drop happened.
+	 */
+	if (log_buf_check_adjust(&log_device->record_start, &log_end,
+				 p_syslog->log_buf_len)) {
+		pr_info_ratelimited("%s: drop start:0x%x end:0x%x\n", __func__,
+				    log_start, log_end);
 		log_start = log_device->record_start;
 		drop = true;
 	}
@@ -258,12 +280,32 @@ static ssize_t rtk_avcpu_log_read(struct file *filp, char __user *buf,
 	else
 		cp_count = log_count;
 
+	/* Append ktime tag */
+	if (log_device->tag_updt) {
+		/* Below two lines should NOT be separated */
+		ts_nsec = local_clock();
+		sysdbg_ts_usec = ioread32(avlog_ctl->sysdbg_p);
+		/* Prepare and output tag */
+		rem_nsec = do_div(ts_nsec, 1000000000);
+		tag_cnt = snprintf(tag_buf, TAG_LINE_MAX,
+				   "\n[%5lu.%06lu] SYSDBG:%08x\n\n",
+				   (unsigned long)ts_nsec, rem_nsec / 1000,
+				   sysdbg_ts_usec);
+		if ((tag_cnt > 0) && (count > tag_cnt)) {
+			if ((cp_count + tag_cnt) > count)
+				cp_count -= tag_cnt;
+			rcount += tag_cnt;
+			memcpy(tmp_buf, tag_buf, tag_cnt);
+			log_device->tag_updt = false;
+		}
+	}
+
 	if (drop) {
 		int drop_cp_cnt;
 
 		if (count <= strlen(drop_msg)) {
-			pr_info("%s: read buf size %d too small\n",
-				__func__, (int)count);
+			pr_info("%s: read buf size %d too small\n", __func__,
+				(int)count);
 			cp_count = 0;
 			rcount += count;
 			drop_cp_cnt = count;
@@ -273,7 +315,7 @@ static ssize_t rtk_avcpu_log_read(struct file *filp, char __user *buf,
 			drop_cp_cnt = strlen(drop_msg);
 		}
 
-		memcpy(tmp_buf, drop_msg, drop_cp_cnt);
+		memcpy(tmp_buf + rcount, drop_msg, drop_cp_cnt);
 	}
 
 	/* since log_start/end is incremental, need to figure out the	*/
@@ -285,13 +327,15 @@ static ssize_t rtk_avcpu_log_read(struct file *filp, char __user *buf,
 		int tmp_cnt;
 		bool wrap;
 
-		wrap = (cp_count + idx_start >= p_syslog->log_buf_len) ? true : false;
-		tmp_cnt = wrap ? (p_syslog->log_buf_len - idx_start) :
-				cp_count;
+		wrap = (cp_count + idx_start >= p_syslog->log_buf_len) ? true :
+									       false;
+		tmp_cnt = wrap ? (p_syslog->log_buf_len - idx_start) : cp_count;
 
 		iter = log_device->log_buf + idx_start;
-		pr_debug("%s: tmp_buf:0x%p, rcount:%d, log_buf:0x%p, log_start:0x%x, tmp_cnt:%d\n",
-			__func__, tmp_buf, rcount, log_device->log_buf, idx_start, tmp_cnt);
+		pr_debug(
+			"%s: tmp_buf:0x%p, rcount:%d, log_buf:0x%p, log_start:0x%x, tmp_cnt:%d\n",
+			__func__, tmp_buf, rcount, log_device->log_buf,
+			idx_start, tmp_cnt);
 		memcpy(tmp_buf + rcount, iter, tmp_cnt);
 		rcount += tmp_cnt;
 		log_start += tmp_cnt;
@@ -334,15 +378,9 @@ static int parse_dtb(struct log_device_t *log_dev, struct device_node *node)
 		return -EFAULT;
 	}
 
-	if (of_property_read_u32(node, "sync_lock_timeout", &val)) {
-		pr_info("%s : use default %u for hwsem_timeout\n",
-			__func__, HWSEM_DEF_TIMEOUT);
-		val = HWSEM_DEF_TIMEOUT;
-	}
-
 	if (of_property_read_u32(node, "log_check_period", &val)) {
-		pr_info("%s : use default %u for work_delay\n",
-			__func__, WORK_DEF_DELAY_TIME);
+		pr_info("%s : use default %u for work_delay\n", __func__,
+			WORK_DEF_DELAY_TIME);
 		val = WORK_DEF_DELAY_TIME;
 	}
 	log_dev->work_delay = val;
@@ -351,19 +389,23 @@ static int parse_dtb(struct log_device_t *log_dev, struct device_node *node)
 }
 
 static int rtk_avcpu_log_device_init(struct platform_device *pdev,
-			const int dev_idx, const struct log_device_info_t *dev_info)
+				     const int dev_idx,
+				     const struct log_device_info_t *dev_info)
 {
 	struct avcpu_syslog_struct *tmp_syslog_p =
 		(struct avcpu_syslog_struct *)(IPC_SHM_VIRT + dev_info->offset);
 	struct device_node *np = NULL;
 	struct device *device = NULL;
-	struct avlog_ctl_t *avlog_ctl = (struct avlog_ctl_t *)dev_get_drvdata(&pdev->dev);
-	struct log_device_t *log_dev = &avlog_ctl->log_device[dev_idx];
-	int avlog_major = MAJOR(avlog_ctl->cdev.dev);
+	struct log_device_t *log_dev;
+	int avlog_major;
 	int ret = 0;
 	int i, npages = 0;
 	struct page **pages, **tmp;
 
+	avlog_ctl = (struct avlog_ctl_t *)dev_get_drvdata(&pdev->dev);
+	log_dev = &avlog_ctl->log_device[dev_idx];
+	avlog_major = MAJOR(avlog_ctl->cdev.dev);
+
 	log_dev->name = dev_info->name;
 	log_dev->stat = L_NOTAVAIL;
 
@@ -374,8 +416,8 @@ static int rtk_avcpu_log_device_init(struct platform_device *pdev,
 		return 0;
 	}
 
-	pr_debug("%s: %s addr-0x%x, size-0x%x\n",
-		__func__, log_dev->name, tmp_syslog_p->log_buf_addr, tmp_syslog_p->log_buf_len);
+	pr_info("%s: %s addr-0x%x, size-0x%x\n", __func__, log_dev->name,
+		 tmp_syslog_p->log_buf_addr, tmp_syslog_p->log_buf_len);
 
 	/* Check the IPC_SHM part. Related info should be set by bootcode */
 	if (tmp_syslog_p->log_buf_addr == 0 || tmp_syslog_p->log_buf_len == 0)
@@ -399,16 +441,20 @@ static int rtk_avcpu_log_device_init(struct platform_device *pdev,
 	}
 
 	for (i = 0, tmp = pages; i < npages; i++)
-		*(tmp++) = phys_to_page(tmp_syslog_p->log_buf_addr + (PAGE_SIZE * i));
+		*(tmp++) = phys_to_page(tmp_syslog_p->log_buf_addr +
+					(PAGE_SIZE * i));
 
-	log_dev->log_buf = vmap(pages, npages, VM_MAP, pgprot_writecombine(PAGE_KERNEL));
+	log_dev->log_buf =
+		vmap(pages, npages, VM_MAP, pgprot_writecombine(PAGE_KERNEL));
 	if (!log_dev->log_buf) {
 		pr_err("%s: %s fail to map\n", __func__, log_dev->name);
 		ret = -ENOMEM;
 		goto out;
 	}
 
-	device = device_create(avlog_ctl->class, NULL, MKDEV(avlog_major, dev_idx), log_dev, log_dev->name);
+	device = device_create(avlog_ctl->class, NULL,
+			       MKDEV(avlog_major, dev_idx), log_dev,
+			       log_dev->name);
 	if (IS_ERR(device)) {
 		pr_err("%s: device_create with ret %d\n", __func__, ret);
 		ret = PTR_ERR(device);
@@ -420,6 +466,7 @@ static int rtk_avcpu_log_device_init(struct platform_device *pdev,
 	INIT_DELAYED_WORK(&log_dev->log_check_work, log_check_work_fn);
 	init_completion(&log_dev->completion);
 	log_dev->stat = L_PENDING;
+	log_dev->tag_updt = false;
 
 out:
 	if (pages)
@@ -430,18 +477,30 @@ static int rtk_avcpu_log_device_init(struct platform_device *pdev,
 	return ret;
 }
 
+static void syslog_tag_timer_fn(struct timer_list *timer)
+{
+	int i;
+	struct log_device_t *log_dev;
+
+	for (i = 0; i < MODULE_NUM; i++) {
+		if (avlog_ctl) {
+			log_dev = &avlog_ctl->log_device[i];
+			log_dev->tag_updt = true;
+		}
+	}
+	mod_timer(&avlog_ctl->syslog_tag_timer,
+		  jiffies + msecs_to_jiffies(tag_rfsh * 1000));
+}
+
 static int rtk_avcpu_shm_log_probe(struct platform_device *pdev)
 {
 	dev_t dev;
-	struct avlog_ctl_t *avlog_ctl = NULL;
 	struct class *class = NULL;
 	int i, tmp, ret = 0;
 
 	avlog_ctl = kzalloc(sizeof(struct avlog_ctl_t), GFP_KERNEL);
-	if (!avlog_ctl) {
-		pr_err("%s: couldn't allocate memory for alog\n", __func__);
+	if (!avlog_ctl)
 		return -ENOMEM;
-	}
 	dev_set_drvdata(&pdev->dev, avlog_ctl);
 
 	/* initialize char device part */
@@ -470,19 +529,38 @@ static int rtk_avcpu_shm_log_probe(struct platform_device *pdev)
 	avlog_ctl->cdev.owner = THIS_MODULE;
 	avlog_ctl->class = class;
 
+#ifdef MODULE
+	request_module("rtk_fw_remoteproc");
+#endif /* MODULE */
+
 	for (i = 0; i < MODULE_NUM; i++) {
-		tmp = rtk_avcpu_log_device_init(pdev, i, &log_device_info_list[i]);
+		tmp = rtk_avcpu_log_device_init(pdev, i,
+						&log_device_info_list[i]);
 		if (tmp)
 			pr_info("%s: %s log_device init fail %d\n", __func__,
 				log_device_info_list[i].name, tmp);
 	}
 
+	/* Remap SYSDBG */
+	avlog_ctl->sysdbg_p = ioremap(SYSDBG_MAP_BASE, 0x4);
+	if (!(avlog_ctl->sysdbg_p))
+		pr_err("SYSDBG ioremap failed\n");
+	else {
+		/* Init timer for tagging */
+		timer_setup(&avlog_ctl->syslog_tag_timer, syslog_tag_timer_fn,
+			    0);
+		avlog_ctl->syslog_tag_timer.expires =
+			jiffies + msecs_to_jiffies(tag_rfsh * 1000);
+		add_timer(&avlog_ctl->syslog_tag_timer);
+	}
+
 	return 0;
 
 fail_unregister_chrdev:
 	unregister_chrdev_region(dev, MODULE_NUM);
 fail:
 	kfree(avlog_ctl);
+	avlog_ctl = NULL;
 	dev_set_drvdata(&pdev->dev, NULL);
 
 	return ret;
@@ -490,12 +568,20 @@ static int rtk_avcpu_shm_log_probe(struct platform_device *pdev)
 
 static int rtk_avcpu_shm_log_remove(struct platform_device *pdev)
 {
-	struct avlog_ctl_t *ctl = (struct avlog_ctl_t *)dev_get_drvdata(&pdev->dev);
+	struct avlog_ctl_t *ctl =
+		(struct avlog_ctl_t *)dev_get_drvdata(&pdev->dev);
 	bool all_finish;
 	unsigned long timeout;
 	struct log_device_t *log_dev = NULL;
 	int i;
 
+	/* Delete tag timer */
+	del_timer_sync(&ctl->syslog_tag_timer);
+
+	/* Unmap SYSDBG */
+	if (ctl->sysdbg_p)
+		iounmap(ctl->sysdbg_p);
+
 	if (!ctl)
 		return -ENODEV;
 
@@ -522,7 +608,8 @@ static int rtk_avcpu_shm_log_remove(struct platform_device *pdev)
 		}
 
 		if (!all_finish) {
-			pr_err("%s:couldn't finish all reader, release fail\n", __func__);
+			pr_err("%s:couldn't finish all reader, release fail\n",
+			       __func__);
 			return -EBUSY;
 		}
 
-- 
2.45.2

