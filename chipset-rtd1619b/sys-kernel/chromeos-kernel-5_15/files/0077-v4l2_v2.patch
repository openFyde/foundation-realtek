From 2bef251d4ec8bb2363929002a1ab2eb3e1c03b52 Mon Sep 17 00:00:00 2001
From: Edward Wu <edwardwu@realtek.com>
Date: Wed, 5 Jun 2024 09:55:16 +0800
Subject: [PATCH 77/80] v4l2_v2

Change-Id: Ifd84ba879ab12bed334e0bb9af598b6cd69fb170
---
 .../media/platform/rtk_vdec_rtd16xxb/drv_if.c |  33 +-
 .../platform/rtk_vdec_rtd16xxb/ve1_config.h   |  29 -
 .../platform/rtk_vdec_rtd16xxb/ve1_decode.c   |  47 +-
 .../platform/rtk_vdec_rtd16xxb/ve1_mem.c      |   6 -
 .../media/platform/rtk_vdec_rtd16xxb/ve1_mm.c |   9 -
 .../platform/rtk_vdec_rtd16xxb/ve1_product.c  |   6 -
 .../platform/rtk_vdec_rtd16xxb/ve1_v4l2.c     | 107 +--
 .../platform/rtk_vdec_rtd16xxb/ve1_v4l2.h     |  22 +-
 .../platform/rtk_vdec_rtd16xxb/ve1_vdi.c      | 699 +-----------------
 .../platform/rtk_vdec_rtd16xxb/ve1_vdi_osal.c | 226 +-----
 .../platform/rtk_vdec_rtd16xxb/ve1_vdi_osal.h |   4 -
 .../platform/rtk_vdec_rtd16xxb/ve1_vpu.c      | 174 +----
 .../platform/rtk_vdec_rtd16xxb/ve1_vpuapi.c   | 276 +------
 .../platform/rtk_vdec_rtd16xxb/ve1_vpuapi.h   |  12 +-
 .../rtk_vdec_rtd16xxb/ve1_vpuapifunc.c        | 105 ---
 .../rtk_vdec_rtd16xxb/ve1_vpuapifunc.h        |  10 +-
 .../platform/rtk_vdec_rtd16xxb/ve1_wrapper.c  | 557 ++++----------
 .../platform/rtk_vdec_rtd16xxb/ve1_wrapper.h  |   1 -
 .../media/platform/rtk_vdec_rtd16xxb/ve2.c    |  86 ++-
 .../platform/rtk_vdec_rtd16xxb/ve2_frame.h    |  29 +-
 .../media/platform/rtk_vdec_rtd16xxb/ve2rpc.c | 339 +++------
 .../media/platform/rtk_vdec_rtd16xxb/ve2rpc.h |  11 +-
 .../media/platform/rtk_vdec_rtd16xxb/vpu.c    | 208 ++++--
 .../media/platform/rtk_vdec_rtd16xxb/vpu.h    |   9 +-
 24 files changed, 570 insertions(+), 2435 deletions(-)

diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c b/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c
index f1941ff7c95d..687277e2ff6b 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/drv_if.c
@@ -41,7 +41,7 @@ MODULE_PARM_DESC(
 module_param_named(debug, vpu_debug, int, 0600);
 
 #define VPU_NAME "realtek-vpu"
-
+#define ENABLE_ADAPTIVE_PLAYBACK (0)
 #define INVERT_BITVAL_1 (~1)
 
 ssize_t get_video_status(struct device *dev, struct device_attribute *attr,
@@ -115,15 +115,8 @@ EXPORT_SYMBOL(vpu_printk);
  */
 static int job_ready(void *priv)
 {
-	//struct videc_ctx *ctx = priv;
+	(void)priv;
 	vpu_input_dbg("%s\n", __func__);
-#if 0 // FIXME: shall enable?
-	if (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) < ctx->translen
-	    || v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx) < ctx->translen) {
-		dprintk(ctx->dev, "Not enough buffers available\n");
-		return 0;
-	}
-#endif
 	return 1;
 }
 
@@ -284,8 +277,7 @@ static int vpu_s_ctrl(struct v4l2_ctrl *ctrl)
 		memcpy(&ctx->params.dec_params, param,
 		       sizeof(struct rtk_dec_params));
 
-		//Only support adaptive playback now.
-		ctx->params.dec_params.is_adaptive_playback = 1;
+		ctx->params.dec_params.is_adaptive_playback = ENABLE_ADAPTIVE_PLAYBACK;
 		break;
 	}
 	case V4L2_CID_COLORIMETRY_HDR10_CLL_INFO: {
@@ -507,15 +499,6 @@ static int videc_g_selection(struct file *file, void *fh,
 	ret = op->vpu_g_crop(fh, &rsel);
 
 	switch (sel->target) {
-	case V4L2_SEL_TGT_CROP_DEFAULT:
-	case V4L2_SEL_TGT_CROP_BOUNDS:
-		//todo
-		/* fallthrough */
-	case V4L2_SEL_TGT_CROP:
-		if (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
-			return -EINVAL;
-		//todo
-		break;
 	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
 	case V4L2_SEL_TGT_COMPOSE_PADDED:
 		//todo
@@ -782,7 +765,6 @@ EXPORT_SYMBOL(cc_isCCInit);
 
 void cc_data_channel_send(char *message, int total_size, int pid)
 {
-	//void *out_payload; //message relay to user space
 	struct sk_buff *out_skb;
 	struct nlmsghdr *out_nlh;
 	int ret;
@@ -806,7 +788,6 @@ void cc_data_channel_send(char *message, int total_size, int pid)
 	ret = nlmsg_unicast(cc_data_sk, out_skb, pid);
 
 	if (ret < 0) {
-		//vpu_err("failed to send cc to pid: %d!\n", pid);
 		bcc_data_channel_bind = false;
 		return;
 	}
@@ -820,7 +801,6 @@ EXPORT_SYMBOL(cc_data_channel_send);
 static int cc_data_channel_bind(struct net *net, int group)
 {
 	bcc_data_channel_bind = true;
-	//vpu_err("cc_data_channel_bind  ok!\n");
 
 	return 0;
 }
@@ -828,7 +808,6 @@ static int cc_data_channel_bind(struct net *net, int group)
 static void cc_data_channel_unbind(struct net *net, int group)
 {
 	bcc_data_channel_bind = false;
-	//vpu_err("cc_data_channel_unbind  ok!\n");
 }
 
 static void cc_data_channel_receive(struct sk_buff *skb)
@@ -843,14 +822,12 @@ static void cc_data_channel_receive(struct sk_buff *skb)
 	case CC_DATA_LINK:
 		payload = nlmsg_data(nlh);
 		payload_len = nlmsg_len(nlh);
-		//vpu_err("CC_DATA_LINK: %s, From: %d\n", (char *)payload, nlh->nlmsg_pid);
 		ccReaderPid = nlh->nlmsg_pid;
 		bcc_data_channel_bind = true;
 		break;
 	case CC_DATA_UNLINK:
 		payload = nlmsg_data(nlh);
 		payload_len = nlmsg_len(nlh);
-		//vpu_err("CC_DATA_UNLINK: %s, From: %d\n", (char *)payload, nlh->nlmsg_pid);
 		ccReaderPid = 0;
 		bcc_data_channel_bind = false;
 		cc_data_channel_send((char *)payload, payload_len,
@@ -917,13 +894,11 @@ static int queue_init(void *priv, struct vb2_queue *src_vq,
 	int ret;
 
 	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
-	//src_vq->io_modes = VB2_MMAP;
 	src_vq->io_modes = VB2_DMABUF | VB2_MMAP;
 	src_vq->drv_priv = ctx;
 	src_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);
 	src_vq->ops = &vpu_qops;
 	src_vq->mem_ops = &vb2_vmalloc_memops;
-	//src_vq->mem_ops = &vb2_dma_contig_memops; //this could be chagned dynamic due to memory mode
 	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
 	src_vq->lock = &ctx->dev->dev_mutex;
 	src_vq->dev = ctx->dev->dev;
@@ -997,7 +972,7 @@ static int vpu_open(struct file *file)
 	v4l2_fh_add(&ctx->fh);
 
 	memset(&ctx->params, 0, sizeof(struct videc_params));
-	ctx->params.dec_params.is_adaptive_playback = 1;
+	ctx->params.dec_params.is_adaptive_playback = ENABLE_ADAPTIVE_PLAYBACK;
 
 	atomic_inc(&dev->num_inst);
 	hasVideo = 1;
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_config.h b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_config.h
index abadd14c09b1..a95a3a7340ae 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_config.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_config.h
@@ -8,17 +8,6 @@
 #define __CONFIG_H__
 
 #define PLATFORM_LINUX
-/*
-#if defined(_WIN32) || defined(__WIN32__) || defined(_WIN64) || defined(WIN32) || defined(__MINGW32__)
-#	define PLATFORM_WIN32
-#elif defined(linux) || defined(__linux) || defined(ANDROID)
-#	define PLATFORM_LINUX
-#elif defined(unix) || defined(__unix)
-#   define PLATFORM_QNX
-#else
-#	define PLATFORM_NON_OS
-#endif
-*/
 #if defined(_MSC_VER)
 #include <windows.h>
 #define inline _inline
@@ -35,13 +24,6 @@
 	((API_VERSION_MAJOR << 16) | (API_VERSION_MINOR << 8) |                \
 	 API_VERSION_PATCH)
 
-#if defined(PLATFORM_NON_OS) || defined(ANDROID) || defined(MFHMFT_EXPORTS) || \
-	defined(PLATFORM_QNX)
-//#define SUPPORT_FFMPEG_DEMUX
-#else
-//#define SUPPORT_FFMPEG_DEMUX
-#endif
-
 //------------------------------------------------------------------------------
 // COMMON
 //------------------------------------------------------------------------------
@@ -59,32 +41,21 @@
 //------------------------------------------------------------------------------
 #define SUPPORT_ENC_NV21
 
-//------------------------------------------------------------------------------
-// CODA980
-//------------------------------------------------------------------------------
-//#define SUPPORT_ROI_50
-
 //------------------------------------------------------------------------------
 // WAVE512
 //------------------------------------------------------------------------------
 #define NO_COMMAND_QUEUE
-//#define SUPPORT_SAVE_PIC_INFO_TO_XML
-//#define SUPPORT_PACKED_STREAM_FORMAT
 
 //------------------------------------------------------------------------------
 // CUSTOMER
 //------------------------------------------------------------------------------
-//#define SUPPORT_SW_UART //For F/W debug
 #define FIX_SET_GET_RD_PTR_BUG
 
 #define USE_OS_SCHEDULE_YIELD
 
 #define FIX_PEDING_INSTANCE_CHECK_BUG
-//#define FIX_BITSTREAM_ROOM_MARGIN_BUG
 #define USE_TIMESTAMP_FOR_MULTI_INSTANCE
 
 #define SUPPORT_GET_NAL_START_POS
 
-//#define SUPPORT_WATCHDOG_ERROR_HANDLE // for RTPIC-109(CHTMOD-196)
-
 #endif /* __CONFIG_H__ */
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_decode.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_decode.c
index 825f7f20a34d..ada3ce5116d0 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_decode.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_decode.c
@@ -27,14 +27,13 @@ static void ve1_set_stream_end(struct ve1_ctx *ctx)
 		ctx->streamEnd = 1;
 		ret = VE1_SetStreamEnd(ctx);
 		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
-			"tgid(%d,%d,%s).EOS.af VE1_SetStreamEnd.ret:%d.size:0.accuBsFeedBytes:%d\n",
-			current->tgid, current->pid, current->comm, ret,
-			ctx->accuBsFeedBytes);
+			"EOS.af VE1_SetStreamEnd.ret:%d.size:0.accuBsFeedBytes:%d\n",
+			ret, ctx->accuBsFeedBytes);
 	}
 }
 
 int ve1_fill_bitstream(struct ve1_ctx *ctx, uint8_t *buf, uint32_t len,
-		       uint64_t pts, uint32_t sequence)
+		       uint64_t timestamp, uint32_t sequence)
 {
 	struct ve1_meta *meta;
 	unsigned long flags;
@@ -43,13 +42,11 @@ int ve1_fill_bitstream(struct ve1_ctx *ctx, uint8_t *buf, uint32_t len,
 
 	// check if bitstream buffer has available space to put new data
 	if (ve1_get_bitstream_payload(ctx) + len >= ctx->bitstream.size) {
-		//ve1_err(VE1_LOGTAG, "bitstream data bytes will overflow.len:%d.data:%d.size:%d\n",len,ve1_get_bitstream_payload(ctx),ctx->bitstream.size);
 		return -ENOSPC;
 	}
 	if (ctx->decHandle != NULL) {
 		VE1_DecGetRdWrPtr(ctx);
 		if (ctx->vpuBsRingRoom <= len) {
-			//ve1_err(VE1_LOGTAG, "vpu bitstream ring doesn't have enough space to put data.%d.%d\n",ctx->vpuBsRingRoom,len);
 			return -ENOSPC;
 		}
 	}
@@ -72,11 +69,11 @@ int ve1_fill_bitstream(struct ve1_ctx *ctx, uint8_t *buf, uint32_t len,
 			ret, ctx, buf, len);
 		return -EFAULT;
 	} else {
-		// PTS_HANDLE_STEP_1: add a meta info (sequence/pts/start/end) of this OUTPUT buffer to ctx->buffer_meta_list
+		// PTS_HANDLE_STEP_1: add a meta info (sequence/timestamp/start/end) of this OUTPUT buffer to ctx->buffer_meta_list
 		meta = kmalloc(sizeof(*meta), GFP_KERNEL);
 		if (meta) {
 			meta->sequence = sequence;
-			meta->timestamp = pts;
+			meta->timestamp = timestamp;
 			meta->start = curBsWrPtr;
 			meta->end = ctx->bsWrPtr;
 			spin_lock_irqsave(&ctx->buffer_meta_lock, flags);
@@ -85,7 +82,7 @@ int ve1_fill_bitstream(struct ve1_ctx *ctx, uint8_t *buf, uint32_t len,
 			spin_unlock_irqrestore(&ctx->buffer_meta_lock, flags);
 			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
 				"num_metas:%d.sequence:%d.timestamp:%lld.start:0x%x.end:0x%x\n",
-				ctx->num_metas, sequence, pts, meta->start,
+				ctx->num_metas, sequence, timestamp, meta->start,
 				meta->end);
 		}
 	}
@@ -103,19 +100,16 @@ static void ve1_seq_end_work(struct work_struct *work)
 	mutex_lock(&ctx->ve1_mutex);
 
 	if (ctx->ve1DecState < VE1_STATE_DEC_OPENED) {
-		//ve1_err(VE1_LOGTAG, "[-] not seqInited\n");
 		goto out;
 	}
 
 	ret = VE1_DecClose(ctx);
 	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
-		"tgid(%d,%d,%s).af VE1_DecClose.ret:%d\n", current->tgid,
-		current->pid, current->comm, ret);
+		"af VE1_DecClose.ret:%d\n", ret);
 
 	ret = VE1_DecDeInit(ctx);
 	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
-		"tgid(%d,%d,%s).af VE1_DecDeInit.ret:%d\n", current->tgid,
-		current->pid, current->comm, ret);
+		"af VE1_DecDeInit.ret:%d\n", ret);
 
 	ctx->seqInited = 0;
 	ctx->handle_eos_by = VE1_HANDLE_EOS_BY_NONE;
@@ -250,8 +244,6 @@ static int ve1_prepare_decode(struct ve1_ctx *ctx)
 {
 	int ret = 0;
 
-	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[+]\n");
-
 	// handle EOS
 	if (ctx->handle_eos_by == VE1_HANDLE_EOS_BY_PREPARE_RUN) {
 		ctx->handle_eos_by = VE1_HANDLE_EOS_SET_END;
@@ -266,7 +258,6 @@ static int ve1_prepare_decode(struct ve1_ctx *ctx)
 		return -EINVAL;
 	}
 
-	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-]\n");
 	return 0;
 }
 
@@ -315,15 +306,15 @@ void rtkve1_add_displayble_frame_to_list(struct ve1_ctx *ctx)
 			frame->timestamp = meta->timestamp;
 			frame->timecode = meta->timecode;
 			frame->sequenceNo = ctx->currSequenceNo;
+			ctx->cntAddToList++;
 			list_add_tail(&frame->list,
 				      &ctx->displayable_frame_list);
 			ve1_dbg(VPU_DBG_VE1_DIS, VE1_LOGTAG,
-				"tgid(%d,%d,%s).add displayable_frame_list.regIndex:%d.dpb_paddr:0x%x.vb2_v4l2_buf:0x%px.size:%ld.timestamp:%lld.last_frame:%d.sequenceNo:%d\n",
-				current->tgid, current->pid, current->comm,
+				"add displayable_frame_list.regIndex:%d.dpb_paddr:0x%x.vb2_v4l2_buf:0x%px.size:%ld.timestamp:%lld.last_frame:%d.sequenceNo:%d.cnt:%u\n",
 				frameIndex, frame->dpb_paddr,
 				frame->vb2_v4l2_buf, frame->size,
 				frame->timestamp, frame->last_frame,
-				frame->sequenceNo);
+				frame->sequenceNo, ctx->cntAddToList);
 
 			// check if timestame back track
 			if ((frame->timestamp <= ctx->lastFrameTimestamp) &&
@@ -331,10 +322,10 @@ void rtkve1_add_displayble_frame_to_list(struct ve1_ctx *ctx)
 				ve1_dbg(VPU_DBG_VE1_DIS, VE1_LOGTAG,
 					"timestamp back track.curr:%lld(pts:%lld).last:%lld(pts:%lld)\n",
 					frame->timestamp,
-					div_u64((frame->timestamp * 9), 100),
+					div_u64((frame->timestamp * 9), 10000),
 					ctx->lastFrameTimestamp,
 					div_u64((ctx->lastFrameTimestamp * 9),
-						100));
+						10000));
 			}
 			ctx->lastFrameTimestamp = frame->timestamp;
 		} else {
@@ -348,8 +339,7 @@ void rtkve1_add_displayble_frame_to_list(struct ve1_ctx *ctx)
 		frame = list_last_entry(&ctx->displayable_frame_list,
 					struct ve1_displayable_frame, list);
 		ve1_dbg(VPU_DBG_VE1_DIS, VE1_LOGTAG,
-			"tgid(%d,%d,%s).last frame in displayable_frame_list.regIndex:%d.dpb_paddr:0x%x.vb2_v4l2_buf:0x%px.timestamp:%lld\n",
-			current->tgid, current->pid, current->comm,
+			"last frame in displayable_frame_list.regIndex:%d.dpb_paddr:0x%x.vb2_v4l2_buf:0x%px.timestamp:%lld\n",
 			frame->regIndex, frame->dpb_paddr, frame->vb2_v4l2_buf,
 			frame->timestamp);
 		frame->last_frame = 1;
@@ -381,8 +371,7 @@ void ve1_show_displayable_frame_list(struct ve1_ctx *ctx)
 		list_for_each_entry (frame, &ctx->displayable_frame_list,
 				     list) {
 			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
-				"tgid(%d,%d,%s).iterate displayable_frame_list.regIndex:%d.dpb_paddr:0x%x.vb2_v4l2_buf:0x%px.isDequeued:%d.timestamp:0x%llx.sequenceNo:%d\n",
-				current->tgid, current->pid, current->comm,
+				"iterate displayable_frame_list.regIndex:%d.dpb_paddr:0x%x.vb2_v4l2_buf:0x%px.isDequeued:%d.timestamp:0x%llx.sequenceNo:%d\n",
 				frame->regIndex, frame->dpb_paddr,
 				frame->vb2_v4l2_buf, frame->isDequeued,
 				frame->timestamp, frame->sequenceNo);
@@ -398,8 +387,6 @@ static int ve1_finish_decode(struct ve1_ctx *ctx)
 	struct ve1_meta *meta;
 	unsigned long flags;
 
-	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[+]\n");
-
 	ret = VE1_DecPicDone(ctx);
 	if (ret < 0) {
 		ve1_err(VE1_LOGTAG, "VE1_DecPicDone() fail\n");
@@ -416,7 +403,7 @@ static int ve1_finish_decode(struct ve1_ctx *ctx)
 			ctx->num_metas--;
 			ctx->frame_metas[ctx->lastIndexFrameDecoded] = *meta;
 			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
-				"set frame_metas[%d](%d,%lld,%d,%d).num_metas:%d\n",
+				"set frame_metas[%d](%d,%lld,%x,%x).num_metas:%d\n",
 				ctx->lastIndexFrameDecoded,
 				ctx->frame_metas[ctx->lastIndexFrameDecoded]
 					.sequence,
@@ -491,7 +478,6 @@ static int ve1_finish_decode(struct ve1_ctx *ctx)
 						}
 #endif
 					}
-					//pVpu->reciveTimestamp[nReciPtsRPtr].wPtr;
 
 					ProcessCC(
 						ctx,
@@ -593,7 +579,6 @@ static int ve1_finish_decode(struct ve1_ctx *ctx)
 		ret = 0;
 	}
 
-	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-] ret:%d\n",ret);
 	return ret;
 }
 
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_mem.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_mem.c
index c15556ac157c..af4df2b49cc3 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_mem.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_mem.c
@@ -31,12 +31,7 @@
 
 #define ve1mem_info(tag, fmt, arg...) ve1mem_printk(KERN_INFO, tag, fmt, ##arg)
 
-#if 0
-#define ve1mem_dbg(tag, fmt, arg...) \
-    ve1mem_printk(KERN_DEBUG, tag, fmt , ## arg)
-#else
 #define ve1mem_dbg(tag, fmt, arg...)
-#endif
 
 static DEFINE_MUTEX(ve1_mem_lock);
 static ve1_mem_reg_entry_t *ve1_mem_reg_head;
@@ -327,4 +322,3 @@ void ve1_mem_device_destroy(void)
 	misc_deregister(&ve1_mem_miscdev);
 }
 
-//fs_initcall(ve1_mem_device_create);
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_mm.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_mm.c
index 06af3ec419c2..0ddc5e9361ed 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_mm.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_mm.c
@@ -2,8 +2,6 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
-//#include <stdio.h>
-//#include <stdlib.h>
 #include "ve1_mm.h"
 
 #ifdef MM_DEBUG
@@ -24,9 +22,6 @@
 		while (1)                                                      \
 			;                                                      \
 	}
-//#define P_ALLOC(_x)         malloc(_x)
-//#define P_FREE(_x)          free(_x)
-//#define ASSERT(_exp)        if (!(_exp)) { printf("ASSERT at %s:%d\n", __FILE__, __LINE__); while(1); }
 #define HEIGHT(_tree) (_tree == NULL ? -1 : _tree->height)
 #define MAX(_a, _b) (_a >= _b ? _a : _b)
 
@@ -138,7 +133,6 @@ static avl_node_t *do_balance(avl_node_t *tree)
 			tree->right = rotation_right(tree->right);
 			tree = rotation_left(tree);
 		} else {
-			//fprintf(stderr, "invalid balancing factor: %d\n", child_bfactor);
 			pr_err("invalid balancing factor: %d\n", child_bfactor);
 			ASSERT(0);
 			return NULL;
@@ -151,7 +145,6 @@ static avl_node_t *do_balance(avl_node_t *tree)
 			tree->left = rotation_left(tree->left);
 			tree = rotation_right(tree);
 		} else {
-			//fprintf(stderr, "invalid balancing factor: %d\n", child_bfactor);
 			pr_err("invalid balancing factor: %d\n", child_bfactor);
 			ASSERT(0);
 			return NULL;
@@ -491,7 +484,6 @@ int vmem_free(video_mm_t *mm, unsigned long ptr, unsigned long pid)
 	}
 
 	addr = ptr;
-	//printf("FREE: 0x%08x\n", addr);
 
 	mm->alloc_tree =
 		avltree_remove(mm->alloc_tree, &found, MAKE_KEY(addr, 0));
@@ -572,7 +564,6 @@ int vmem_free(video_mm_t *mm, unsigned long ptr, unsigned long pid)
 int vmem_get_info(video_mm_t *mm, vmem_info_t *info)
 {
 	if (mm == NULL) {
-		//DPRINT("vmem_get_info: invalid handle\n");
 		return -1;
 	}
 
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_product.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_product.c
index d9ae6eb2704a..f6e824340018 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_product.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_product.c
@@ -14,7 +14,6 @@
 //--=========================================================================--
 #include "ve1_product.h"
 #include "ve1_vpu.h"
-//#include "coda9/coda9.h"
 
 VpuAttr g_VpuCoreAttributes[MAX_NUM_VPU_CORE];
 
@@ -52,7 +51,6 @@ RetCode ProductVpuInitProtect(Uint32 coreIdx, void *firmware, Uint32 size,
 #endif
 
 Uint32 ProductVpuScan(Uint32 coreIdx)
-//Uint32 ProductVpuScan(Uint32 coreIdx __unused)
 {
 	Uint32 foundProducts = 0;
 
@@ -229,7 +227,6 @@ RetCode ProductVpuSleepWake(Uint32 coreIdx, int iSleepWake, const Uint16 *code,
 }
 
 RetCode ProductVpuClearInterrupt(Uint32 coreIdx, Uint32 flags)
-//RetCode ProductVpuClearInterrupt(Uint32 coreIdx, Uint32 flags __unused)
 {
 	int productId;
 	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
@@ -288,7 +285,6 @@ PhysicalAddress ProductVpuDecGetRdPtr(CodecInst *instance) //[r]
 	Uint32 coreIdx;
 	PhysicalAddress retRdPtr;
 	DecInfo *pDecInfo;
-	//RetCode ret = RETCODE_SUCCESS;
 
 	pDecInfo = VPU_HANDLE_TO_DECINFO(instance);
 
@@ -761,7 +757,6 @@ RetCode ProductVpuRegisterFramebuffer(CodecInst *instance)
 RetCode ProductVpuDecUpdateFrameBuffer(CodecInst *instance, FrameBuffer *fbcFb,
 				       FrameBuffer *linearFb, Uint32 mvColIndex,
 				       Uint32 picWidth, Uint32 picHeight)
-//RetCode ProductVpuDecUpdateFrameBuffer(CodecInst* instance __unused, FrameBuffer* fbcFb __unused, FrameBuffer* linearFb __unused, Uint32 mvColIndex __unused, Uint32 picWidth __unused, Uint32 picHeight __unused)
 {
 	RetCode ret = RETCODE_NOT_SUPPORTED_FEATURE;
 
@@ -1128,7 +1123,6 @@ RetCode ProductVpuEncInitSeq(CodecInst *instance) //[r]
 }
 
 RetCode ProductVpuEncGetSeqInfo(CodecInst *instance, EncInitialInfo *info) //[r]
-//RetCode ProductVpuEncGetSeqInfo(CodecInst* instance, EncInitialInfo* info __unused) //[r]
 {
 	int productId;
 	RetCode ret = RETCODE_NOT_FOUND_VPU_DEVICE;
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_v4l2.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_v4l2.c
index 257a81771b1e..6766fcf273e1 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_v4l2.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_v4l2.c
@@ -7,7 +7,6 @@
 #include <linux/workqueue.h>
 #include <media/v4l2-mem2mem.h>
 #include <media/videobuf2-dma-contig.h>
-//#include <linux/delay.h>
 
 #include "drv_if.h"
 #include "vpu.h"
@@ -19,32 +18,13 @@
 
 extern const struct ve1_ctx_ops ve1_decode_ops;
 extern int ve1_fill_bitstream(struct ve1_ctx *ctx, uint8_t *buf, uint32_t len,
-			      uint64_t pts, uint32_t sequence);
+			      uint64_t timestamp, uint32_t sequence);
 extern void ve1_show_displayable_frame_list(struct ve1_ctx *ctx);
 #ifdef VPU_GET_CC
 extern void ProcessCC_Display(void *ctx, long long PTS, int display_index);
 #endif
 #define VENG_ID 1
 
-#if 0
-/*
- * Return videc_ctx structure for a given struct v4l2_fh
- */
-static struct videc_ctx *fh_to_videc(struct v4l2_fh *fh)
-{
-	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
-	return vid_ctx;
-}
-
-/*
- * Return videc_ctx structure for a given struct vb2_queue
- */
-static struct videc_ctx *vq_to_videc(struct vb2_queue *q)
-{
-	struct videc_ctx *vid_ctx = vb2_get_drv_priv(q);
-	return vid_ctx;
-}
-#endif
 /*
  * Return vpu_ctx structure for a given struct v4l2_fh
  */
@@ -72,24 +52,12 @@ static struct ve1_ctx *vq_to_ve(struct vb2_queue *q)
 	return vid_ctx->ve_ctx;
 }
 
-/*
- * Return vpu_ctx structure for a given struct vb2_queue
- */
-/*
-static struct vpu_ctx *vq_to_vpu(struct vb2_queue *q)
-{
-    struct videc_ctx *vid_ctx = vb2_get_drv_priv(q);
-    return vid_ctx->vpu_ctx;
-}
-*/
 static void ve1_pic_run_work(struct work_struct *work)
 {
 	struct ve1_ctx *ctx = container_of(work, struct ve1_ctx, pic_run_work);
 	int ret;
 	bool queueRet = false;
 
-	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[+]\n");
-
 	if (ctx == NULL) {
 		ve1_err(VE1_LOGTAG, "ctx is NULL\n");
 		return;
@@ -98,7 +66,6 @@ static void ve1_pic_run_work(struct work_struct *work)
 	mutex_lock(&ctx->ve1_mutex);
 
 	ctx->cntExecPicRunWork++;
-	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "cnt:%d\n",ctx->cntExecPicRunWork);
 
 	// RDK-1479, while entering ve1_pic_run_work(), maybe seq_end_work is already done and ve1DecState is VE1_STATE_DEC_UNINIT, it should not start to decode
 	if (ctx->ve1DecState < VE1_STATE_DEC_SEQ_INIT_DONE) {
@@ -112,7 +79,6 @@ static void ve1_pic_run_work(struct work_struct *work)
 	    (ctx->streamon_cap == 0)) {
 		ve1_info(VE1_LOGTAG, "seq int done but not streamon_cap\n");
 	}
-	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "ve1DecState:%d.streamon_cap:%d\n",ctx->ve1DecState,ctx->streamon_cap);
 	if ((ctx->ve1DecState == VE1_STATE_DEC_SEQ_INIT_DONE) &&
 	    (ctx->streamon_cap == 1)) {
 		if (ctx->cntCap2Dpb == 0) {
@@ -145,10 +111,8 @@ static void ve1_pic_run_work(struct work_struct *work)
 		goto out;
 	}
 
-	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "prepare_run\n");
 	ret = ctx->ops->prepare_run(ctx);
 	if (ret < 0) {
-		//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-]\n");
 		goto out;
 	}
 
@@ -167,11 +131,7 @@ static void ve1_pic_run_work(struct work_struct *work)
 
 	if ((ctx->ve1DecState == VE1_STATE_DEC_START_DEC_ISSUED) &&
 	    (!ctx->bBufEmptyFlag) && (!ctx->bWaitNextField)) {
-		//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "VE1_DecWaitPicDone\n");
 		ret = VE1_DecWaitPicDone(ctx);
-		//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
-		//	"af VE1_DecWaitPicDone.ret:%d.int_reason:0x%x\n", ret,
-		//	ctx->int_reason);
 		if (ret > 0) {
 			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "finish_run\n");
 			ret = ctx->ops->finish_run(ctx);
@@ -205,7 +165,6 @@ static void ve1_pic_run_work(struct work_struct *work)
 		}
 	}
 
-	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "aborting:%d.streamon_cap:%d.streamon_out:%d\n",ctx->aborting,ctx->streamon_cap,ctx->streamon_out);
 	if ((ctx->aborting || (!ctx->streamon_cap && !ctx->streamon_out)) &&
 	    ctx->ops->seq_end_work) {
 		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "queue_work seq_end_work\n");
@@ -214,8 +173,6 @@ static void ve1_pic_run_work(struct work_struct *work)
 
 out:
 	mutex_unlock(&ctx->ve1_mutex);
-
-	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-]\n");
 }
 
 static int ve1_start_streaming(struct vb2_queue *q, uint32_t count,
@@ -254,7 +211,6 @@ static int ve1_start_streaming(struct vb2_queue *q, uint32_t count,
 	{
 		// set struct ve1_ctx_ops
 		ctx->ops = &ve1_decode_ops;
-		//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "ops:0x%px\n",ctx->ops);
 		// allocate workqueue
 		ctx->workqueue = alloc_workqueue(
 			"v4l2_ve1", WQ_UNBOUND | WQ_MEM_RECLAIM, 1);
@@ -262,7 +218,6 @@ static int ve1_start_streaming(struct vb2_queue *q, uint32_t count,
 			ve1_err(VE1_LOGTAG, "[-] unable to alloc workqueue\n");
 			return -ENOMEM;
 		}
-		//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "workqueue:0x%px\n",ctx->workqueue);
 
 		// init a struct work_struct for pic_run_work
 		INIT_WORK(&ctx->pic_run_work, ve1_pic_run_work);
@@ -278,6 +233,9 @@ static int ve1_start_streaming(struct vb2_queue *q, uint32_t count,
 		// init struct mutex ve1_mutex
 		mutex_init(&ctx->ve1_mutex);
 
+		// init struct mutex ve1_dma_mutex
+		mutex_init(&ctx->ve1_dma_mutex);
+
 		// init struct list_head buffer_meta_list
 		INIT_LIST_HEAD(&ctx->buffer_meta_list);
 		// init spinlock_t buffer_meta_lock
@@ -301,7 +259,6 @@ static int ve1_start_streaming(struct vb2_queue *q, uint32_t count,
 		// ctx->ops->start_streaming(ctx) => ve1_start_decoding() => ve1_alloc_bitstream_buffer(), ve1_alloc_bitstream_buffer() needs ctx->is_svp
 		mutex_lock(&ctx->ve1_mutex);
 		ctx->is_svp = vid_ctx->params.is_secure;
-		//ctx->is_svp = 1; // for test only
 		ctx->out_vb2_q_memory = q->memory;
 		if (!ctx->is_svp &&
 		    ctx->out_vb2_q_memory == V4L2_MEMORY_DMABUF) {
@@ -321,9 +278,6 @@ static int ve1_start_streaming(struct vb2_queue *q, uint32_t count,
 
 	mutex_lock(&ctx->ve1_mutex);
 	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
-		//#if !defined(ENABLE_TEE_DRM_FLOW)
-		//        ve1_err(VE1_LOGTAG, "ENABLE_TEE_DRM_FLOW is not defined, force is_svp to 0\n");
-		//#endif
 		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
 			"ve1DecState:%d.is_svp:%d.out_vb2_q_memory:%d\n",
 			ctx->ve1DecState, ctx->is_svp, ctx->out_vb2_q_memory);
@@ -358,7 +312,7 @@ static int ve1_start_streaming(struct vb2_queue *q, uint32_t count,
 
 		ctx->streamon_out = 1;
 	} else {
-		if (ctx->ve1DecState == VE1_STATE_DEC_SEQ_INIT_DONE) {
+		if (ctx->seqInited) {
 			queueRet =
 				queue_work(ctx->workqueue, &ctx->pic_run_work);
 			if (queueRet)
@@ -447,8 +401,6 @@ static int ve1_stop_streaming(struct vb2_queue *q)
 			frame = list_first_entry(&ctx->displayable_frame_list,
 						 struct ve1_displayable_frame,
 						 list);
-			//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "tgid(%d,%d,%s).iterate displayable_frame_list.regIndex:%d.dpb_paddr:0x%x.vb2_v4l2_buf:0x%px.timestamp:0x%llx.sequenceNo:%d\n",
-			//        current->tgid,current->pid,current->comm,frame->regIndex,frame->dpb_paddr,frame->vb2_v4l2_buf,frame->timestamp,frame->sequenceNo);
 			list_del(&frame->list);
 			kfree(frame);
 		}
@@ -471,6 +423,9 @@ static int ve1_stop_streaming(struct vb2_queue *q)
 		ctx->cntFrameDq = 0;
 		ctx->cntCap2Dpb = 0;
 		ctx->bLastFrmReportedAfFrmDq = false;
+		ctx->lastInfoFrmStart = 0;
+		ctx->lastInfoFrmEnd = 0;
+		ctx->cntAddToList = 0;
 		mutex_unlock(&ctx->ve1_mutex);
 	}
 
@@ -551,7 +506,7 @@ static void ve1_start_work(void *fh, struct ve1_ctx *ctx)
 	}
 }
 
-static int ve1_out_qbuf(void *fh, uint8_t *buf, uint32_t len, uint64_t pts,
+static int ve1_out_qbuf(void *fh, uint8_t *buf, uint32_t len, uint64_t timestamp,
 			uint32_t sequence)
 {
 	int ret = 0;
@@ -569,8 +524,8 @@ static int ve1_out_qbuf(void *fh, uint8_t *buf, uint32_t len, uint64_t pts,
 	}
 
 	ve1_dbg(VPU_DBG_INPUT, VE1_LOGTAG,
-		"[+] fh:0x%px.ctx:0x%px.buf:0x%px.len:%d.pts:%lld.seq:%d.cnt:%d\n",
-		fh, ctx, buf, len, pts, sequence, ctx->cntOutQbuf);
+		"[+] fh:0x%px.ctx:0x%px.buf:0x%px.len:%d.timestamp:%lld.seq:%d.cnt:%d\n",
+		fh, ctx, buf, len, timestamp, sequence, ctx->cntOutQbuf);
 
 	if (ctx->initialInfo != NULL) {
 		initialInfo = (DecInitialInfo *)ctx->initialInfo;
@@ -582,7 +537,7 @@ static int ve1_out_qbuf(void *fh, uint8_t *buf, uint32_t len, uint64_t pts,
 
 	if (ctx->streamon_out == 1) {
 		mutex_lock(&ctx->ve1_mutex);
-		ret = ve1_fill_bitstream(ctx, buf, len, pts, sequence);
+		ret = ve1_fill_bitstream(ctx, buf, len, timestamp, sequence);
 		if (ret == -EFAULT) {
 			// real error
 			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
@@ -651,24 +606,19 @@ static int ve1_cap_qbuf(void *fh, struct vb2_buffer *vb)
 		// print displayable_frame_list for debug
 		ve1_show_displayable_frame_list(ctx);
 
-		mutex_lock(&ctx->ve1_mutex);
 		// check if there is a corresponding frame buffer need to be recycled
 		spin_lock_irqsave(&ctx->displayable_frame_lock, flags);
 		if (!list_empty(&ctx->displayable_frame_list)) {
 			list_for_each_entry_safe (frame, tmp,
 						  &ctx->displayable_frame_list,
 						  list) {
-				//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "tgid(%d,%d,%s).iterate displayable_frame_list.regIndex:%d.dpb_paddr:0x%x.vb2_v4l2_buf:0x%px.isDequeued:%d.timestamp:0x%llx.sequenceNo:%d\n",
-				//    current->tgid,current->pid,current->comm,frame->regIndex,frame->dpb_paddr,frame->vb2_v4l2_buf,frame->isDequeued,frame->timestamp,frame->sequenceNo);
 				if (frame->vb2_v4l2_buf == vb2_v4l2_buf) {
 					if (frame->isDequeued == 0) {
 						ve1_err(VE1_LOGTAG,
 							"Unexpected fatal error.queue a never-dequeued cap_buf\n");
 					}
 					ve1_dbg(VPU_DBG_OUTPUT, VE1_LOGTAG,
-						"tgid(%d,%d,%s).vb2_v4l2_buf:0x%px re-qbuf.VE1_UpdateDPBStatus(0x%x,%d,%d)\n",
-						current->tgid, current->pid,
-						current->comm,
+						"vb2_v4l2_buf:0x%px re-qbuf.VE1_UpdateDPBStatus(0x%x,%d,%d)\n",
 						frame->vb2_v4l2_buf,
 						frame->dpb_paddr,
 						frame->sequenceNo,
@@ -699,7 +649,6 @@ static int ve1_cap_qbuf(void *fh, struct vb2_buffer *vb)
 				"vb2_v4l2_buf:0x%px of cap_qbuf doesn't match any dpb\n",
 				vb2_v4l2_buf);
 		}
-		mutex_unlock(&ctx->ve1_mutex);
 
 		// CXI-3663, queue_work pic_run_work after frame buffer is recycled (VE1_UpdateDPBStatus() => VE1_SetFrameBufReusable())
 		if (ctx->dpbFull) {
@@ -741,7 +690,7 @@ static int ve1_cap_qbuf(void *fh, struct vb2_buffer *vb)
 	return 0;
 }
 
-static int ve1_cap_dqbuf(void *fh, uint8_t *buf, uint64_t *pts,
+static int ve1_cap_dqbuf(void *fh, uint8_t *buf, uint64_t *timestamp,
 			 struct vb2_v4l2_buffer **disp_buf)
 {
 	struct ve1_ctx *ctx;
@@ -754,7 +703,7 @@ static int ve1_cap_dqbuf(void *fh, uint8_t *buf, uint64_t *pts,
 	unsigned int sequenceNo;
 	int ret = -EINVAL;
 
-	if ((fh == NULL) || (pts == NULL) || (disp_buf == NULL)) {
+	if ((fh == NULL) || (timestamp == NULL) || (disp_buf == NULL)) {
 		ve1_err(VE1_LOGTAG, "invalid parameters\n");
 		return ret;
 	}
@@ -769,35 +718,28 @@ static int ve1_cap_dqbuf(void *fh, uint8_t *buf, uint64_t *pts,
 		return -EINVAL;
 	}
 
-	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[+] fh:0x%px.ctx:0x%px.buf:0x%px\n",fh,ctx,buf);
 	if (ctx->streamon_cap == 1) {
 		// print displayable_frame_list for debug
 		//ve1_show_displayable_frame_list(ctx);
 
-		mutex_lock(&ctx->ve1_mutex);
 		spin_lock_irqsave(&ctx->displayable_frame_lock, flags);
 		if (!list_empty(&ctx->displayable_frame_list)) {
 			list_for_each_entry (
 				frame, &ctx->displayable_frame_list, list) {
-				//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "tgid(%d,%d,%s).iterate displayable_frame_list.regIndex:%d.dpb_paddr:0x%lx.vb2_v4l2_buf:0x%px.isDequeued:%d.timestamp:0x%llx\n",
-				//    current->tgid,current->pid,current->comm,frame->regIndex,frame->dpb_paddr,frame->vb2_v4l2_buf,frame->isDequeued,frame->timestamp);
 				if ((frame->vb2_v4l2_buf != NULL) &&
 				    (frame->isDequeued == 0)) {
-					// PTS_HANDLE_STEP_4: fill pts to CAPTURE buffer
-					*pts = frame->timestamp * 1000;
+					// PTS_HANDLE_STEP_4: fill timestamp to CAPTURE buffer
+					*timestamp = frame->timestamp;
 
 					if (frame->last_frame) {
 						ve1_info(
 							VE1_LOGTAG,
 							"ctx->last_frame = 1\n");
 						ctx->last_frame = 1;
-						//dst_buf->flags |= V4L2_BUF_FLAG_LAST;
 					}
 					ctx->cntFrameDq++;
 					ve1_dbg(VPU_DBG_OUTPUT, VE1_LOGTAG,
-						"tgid(%d,%d,%s).dq vb2_v4l2_buf:0x%px.regIndex:%d.dpb_paddr:0x%x.isDequeued:%d.timestamp:%lld.last_frame:%d.cnt:%d\n",
-						current->tgid, current->pid,
-						current->comm,
+						"dq vb2_v4l2_buf:0x%px.regIndex:%d.dpb_paddr:0x%x.isDequeued:%d.timestamp:%lld.last_frame:%d.cnt:%d\n",
 						frame->vb2_v4l2_buf,
 						frame->regIndex,
 						frame->dpb_paddr,
@@ -836,11 +778,6 @@ static int ve1_cap_dqbuf(void *fh, uint8_t *buf, uint64_t *pts,
 			ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-]\n");
 			ret = 0;
 		}
-		//else
-		//{
-		//    ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "[-] no displayable frame\n");
-		//}
-		mutex_unlock(&ctx->ve1_mutex);
 	}
 
 	return ret;
@@ -861,8 +798,7 @@ static int ve1_abort(void *pCtx, int type)
 	mutex_lock(&ctx->ve1_mutex);
 	ctx->aborting = 1;
 	ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG,
-		"tgid(%d,%d,%s).VE1_DecCheckComplete\n", current->tgid,
-		current->pid, current->comm);
+		"VE1_DecCheckComplete\n");
 	VE1_DecCheckComplete(ctx);
 	mutex_unlock(&ctx->ve1_mutex);
 
@@ -1012,8 +948,6 @@ static int ve1_stop_cmd(void *fh, int pixelformat)
 	}
 	if (ctx->streamon_out &&
 	    (ctx->handle_eos_by == VE1_HANDLE_EOS_BY_NONE)) {
-		//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "sleep 5 seconds to test\n");
-		//msleep(5000);
 		ctx->handle_eos_by = VE1_HANDLE_EOS_BY_PREPARE_RUN;
 		ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "set handle_eos_by:%d\n",
 			ctx->handle_eos_by);
@@ -1061,8 +995,7 @@ static void ve1_get_info(void *fh, bool *eos, bool *no_frame)
 	}
 
 	*eos = (bool)ctx->last_frame;
-	*no_frame = (bool)ctx->last_frame;
-	//ve1_dbg(VPU_DBG_NONE, VE1_LOGTAG, "eos:%d\n",*eos);
+	*no_frame = 0;
 }
 
 static int ve1_get_undq_dispFrm_cnt(void *fh)
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_v4l2.h b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_v4l2.h
index ef415337493e..b0ab2d49e547 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_v4l2.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_v4l2.h
@@ -33,15 +33,12 @@ extern unsigned int vpu_debug;
 
 #define ve1_err(tag, fmt, arg...)                                              \
 	printk(KERN_ERR "%s [%d]%s." fmt, tag, __LINE__, __func__, ##arg);
-//    ve1_printk(KERN_ERR, VPU_DBG_NONE, tag, fmt , ## arg)
 
 #define ve1_warn(tag, fmt, arg...)                                             \
 	printk(KERN_WARNING "%s [%d]%s." fmt, tag, __LINE__, __func__, ##arg);
-//    ve1_printk(KERN_WARNING, VPU_DBG_NONE, tag, fmt , ## arg)
 
 #define ve1_info(tag, fmt, arg...)                                             \
 	printk(KERN_INFO "%s [%d]%s." fmt, tag, __LINE__, __func__, ##arg);
-//    ve1_printk(KERN_INFO, VPU_DBG_NONE, tag, fmt , ## arg)
 
 #define ve1_dbg(category, tag, fmt, arg...)                                    \
 	ve1_printk(KERN_DEBUG, category, tag, fmt, ##arg)
@@ -69,13 +66,16 @@ typedef enum {
 	RTKVE1_DPB_ST_VALID =
 		0x0001, // this dpb has been allocated or assigned by cap_buf
 	RTKVE1_DPB_ST_REG = 0x0002, // this dpb has beed registered to VE1
-	RTKVE1_DPB_ST_DQ = 0x0004 // this dpb has beed dqueue by cap_dqbuf
+	RTKVE1_DPB_ST_DQ = 0x0004, // this dpb has beed dqueue by cap_dqbuf
+	RTKVE1_DPB_ST_WAIT_RECYCLE =
+		0x0008 // this dpb is waiting to recycle
 } RTKVE1_DPB_STATUS;
 
 #define IS_RTKVE1_DPB_EMPTY(status) (((status) == RTKVE1_DPB_ST_EMPTY) ? 1 : 0)
 #define IS_RTKVE1_DPB_VALID(status) ((status)&RTKVE1_DPB_ST_VALID)
 #define IS_RTKVE1_DPB_REG(status) ((status)&RTKVE1_DPB_ST_REG)
 #define IS_RTKVE1_DPB_DQ(status) ((status)&RTKVE1_DPB_ST_DQ)
+#define IS_RTKVE1_DPB_WAIT_RECYCLE(status) ((status)&RTKVE1_DPB_ST_WAIT_RECYCLE)
 
 struct rtkve1_dpb_t {
 	unsigned int status; // RTKVE1_DPB_STATUS
@@ -87,6 +87,7 @@ struct rtkve1_dpb_t {
 	unsigned long attach; // struct dma_buf_attachment *
 	unsigned long table; // struct sg_table *
 	void *reg_entry;
+	unsigned int regIndex; // the index when registering dpb to VE1
 };
 
 typedef uint32_t PhysicalAddress;
@@ -164,7 +165,6 @@ struct ve1_devtype {
 
 struct ve1_buf {
 	void *vaddr;
-	//dma_addr_t                  paddr;
 	unsigned long paddr;
 	unsigned long dma_buf;
 	u32 size;
@@ -423,7 +423,6 @@ struct ve1_ctx {
 		pUserDataSrcBuf; // ve1_get_userdata() will parse header in pUserDataBufVirtAddr and copy actual user data bytes to this pUserDataSrcBuf
 	char *m_CCDecodeOrderWp
 		[MPEG2_CC_REG_FRAME_MAX]; //keeping write pointer by decoder's frame order, todo
-	//char*                     m_pUserDataBuf; //pVpu->m_pUserDataBuf => ctx->pUserDataSrcBufÂ 
 	int cc_error_count;
 #endif
 	int timeoutCount;
@@ -436,6 +435,10 @@ struct ve1_ctx {
 	bool bGotNextField;
 	PhysicalAddress fldDoneVpuRp;
 	bool bPostponeUpBs; // postpone update bs. set to true after update bitstream, set to false after get int_reason
+	struct mutex ve1_dma_mutex;
+	PhysicalAddress lastInfoFrmStart;
+	PhysicalAddress lastInfoFrmEnd;
+	unsigned int cntAddToList;
 };
 
 static inline unsigned long ve1_ring_valid_data(unsigned long ring_base,
@@ -449,12 +452,7 @@ static inline unsigned long ve1_ring_valid_data(unsigned long ring_base,
 		return ((ring_limit - ring_base) - (ring_rp - ring_wp));
 	}
 }
-/*
-static inline unsigned long ve1_ring_virt_to_phys(unsigned long virt_addr, unsigned long virt_base, unsigned long phys_base)
-{
-    return (phys_base + (virt_addr - virt_base));
-}
-*/
+
 static inline unsigned long ve1_ring_phys_to_virt(unsigned long phys_addr,
 						  unsigned long phys_base,
 						  unsigned long virt_base)
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vdi.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vdi.c
index 9b466e22bc56..460c724c01c6 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vdi.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vdi.c
@@ -11,42 +11,10 @@
 #include <linux/time.h>
 #include <linux/sched.h>
 
-//#if defined(linux) || defined(__linux) || defined(ANDROID)
-#if 0
-#include <ctype.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#ifdef _KERNEL_
-#include <linux/delay.h>
-#endif
-#include <signal.h> /* SIGIO */
-#include <fcntl.h> /* fcntl */
-#include <pthread.h>
-#include <sys/mman.h> /* mmap */
-#include <sys/ioctl.h> /* fopen/fread */
-#include <sys/errno.h> /* fopen/fread */
-#include <sys/types.h>
-#include <sys/time.h>
-#endif
 #include "ve1.h"
-//#include "driver/vpu.h"
 #include "ve1_vdi.h"
 #include "ve1_vdi_osal.h"
-//#include "../../aes/aes.h"
 #include "ve1_regdefine.h"
-//#include "coda9/coda9_regdefine.h"
-/*
-#ifdef CONFIG_RTK_RPC
-#include <RPCProxy.h>
-#include <RPCstruct.h>
-#include <AudioRPC_System.h>
-#include "SVCFunc.h"
-#include "AudioRPC_Agent.h"
-#include <time.h>
-#endif
-*/
 
 #define VPU_DEVICE_NAME "/dev/vpu"
 #define RTK_VPU_DEVICE_NAME "/rtk/vpu"
@@ -56,17 +24,6 @@ typedef struct new_pthread_mutex_t {
 	uint32_t val[10];
 } new_pthread_mutex_t;
 typedef new_pthread_mutex_t USERSPACE_MUTEX_HANDLE;
-/*
-#ifdef TEST_BINARY //RTK, workaround for 64bit android
-typedef pthread_mutex_t	MUTEX_HANDLE;
-#else
-typedef struct new_pthread_mutex_t
-{
-    uint32_t val[10];
-} new_pthread_mutex_t;
-typedef new_pthread_mutex_t MUTEX_HANDLE;
-#endif
-*/
 #ifndef ANDROID
 // for gLinux, using mmap.
 #define mmap64 mmap
@@ -95,20 +52,15 @@ typedef struct vpu_sram_info {
 typedef struct vpu_sram_device {
 	vpu_sram_info *info;
 	struct mutex *lock;
-	//pthread_mutex_t *   lock;
 	unsigned long generation;
 	vpu_instance_pool_t *pvip[MAX_NUM_VPU_CORE];
 } vpu_sram_device;
 
-//static struct mutex vdi_info_mutex_init_lock;
 static DEFINE_MUTEX(vdi_info_mutex_init_lock);
 static struct mutex vdi_info_mutex[MAX_NUM_VPU_CORE];
 static struct mutex vdi_init_release_lock[MAX_NUM_VPU_CORE];
 
-//static pthread_mutex_t  vdi_info_mutex_init_lock = PTHREAD_MUTEX_INITIALIZER;
 static int vdi_info_mutex_init = 0;
-//static pthread_mutex_t  vdi_info_mutex[MAX_NUM_VPU_CORE];
-//static pthread_mutex_t  vdi_init_release_lock[MAX_NUM_VPU_CORE];
 
 static struct mutex vpu_mutex;
 static struct mutex vpu_disp_mutex;
@@ -144,11 +96,6 @@ typedef struct {
 	struct mutex *vpu_disp_mutex;
 	struct mutex *vpu_sram_mutex;
 	struct mutex *vpu_thumb_mutex;
-	//void* vpu_mutex;
-	//void* vpu_omx_mutex;
-	//void* vpu_disp_mutex;
-	//void* vpu_sram_mutex;
-	//void* vpu_thumb_mutex;
 
 	vpu_sram_device *sram_dev;
 	int *thumb_used;
@@ -162,8 +109,6 @@ static vdi_info_t s_vdi_info[MAX_NUM_VPU_CORE];
 static int Internal_swap_endian(unsigned long core_idx, unsigned char *data,
 				int len, int endian);
 static int Internal_allocate_common_memory(unsigned long core_idx);
-//static void*        Internal_vdi_map_registers          (int dev, unsigned long base, unsigned int reg_size);
-//static void         Internal_vdi_unmap_registers        (const void *io, unsigned int reg_size);
 static int Internal_vdi_set_bit_firmware_to_pm(unsigned long core_idx,
 					       const unsigned short *code);
 static int Internal_vdi_release(unsigned long core_idx);
@@ -185,7 +130,6 @@ static void Internal_vdi_free_dma_memory(unsigned long core_idx,
 					 vpu_buffer_t *vb);
 static void Internal_vdi_free_dma_memory_no_mmap(unsigned long core_idx,
 						 vpu_buffer_t *vb);
-//static void         Internal_vdi_print_vpu_status       (unsigned long coreIdx);
 static int Internal_vdi_convert_endian(unsigned long core_idx,
 				       unsigned int endian);
 static int Internal_vdi_write_memory(unsigned long core_idx, unsigned int addr,
@@ -236,31 +180,20 @@ static vpu_sram_device *sram_device_create(vpu_sram_info *info, void *pMutex,
 	vpu_sram_device *device =
 		(vpu_sram_device *)osal_malloc(sizeof(vpu_sram_device));
 
-	//VLOG(TRACE, "[%d]%s.vpu_sram_mutex:0x%px.*pMutexState=%d\n",__LINE__,__func__,pMutex,*pMutexState);
-
 	device->info = info;
 	device->lock = (struct mutex *)pMutex;
-	//device->lock        = (pthread_mutex_t *) pMutex;
 	for (i = 0; i < MAX_NUM_VPU_CORE; i++)
 		device->pvip[i] =
 			(vpu_instance_pool_t *)((unsigned long)first_pvip +
 						(i * pvip_size));
 
 	if (*pMutexState == FALSE) {
-		//VLOG(TRACE, "[%d]%s.mutex_init vpu_sram_mutex:0x%px\n",__LINE__,__func__,device->lock);
 		mutex_init(device->lock);
-		//pthread_mutexattr_t mutexattr;
-		//pthread_mutexattr_init(&mutexattr);
-		//pthread_mutexattr_setpshared(&mutexattr, PTHREAD_PROCESS_SHARED);
-		//pthread_mutex_init((pthread_mutex_t*)device->lock, &mutexattr);
 		*pMutexState = TRUE;
 		needToInited = 1;
 	}
 
-	//restore_mutex_in_dead((MUTEX_HANDLE *) device->lock); // must_check
-	//VLOG(TRACE, "[%d]%s.mutex_lock vpu_sram_mutex:0x%px\n",__LINE__,__func__,device->lock);
 	mutex_lock(device->lock);
-	//pthread_mutex_lock(device->lock);
 
 	if (device->info->inited == FALSE)
 		needToInited = 1;
@@ -270,98 +203,33 @@ static vpu_sram_device *sram_device_create(vpu_sram_info *info, void *pMutex,
 		device->info->inited = TRUE;
 		device->info->generation++;
 	}
-	//VLOG(TRACE, "[%d]%s.mutex_unlock vpu_sram_mutex:0x%px\n",__LINE__,__func__,device->lock);
 	mutex_unlock(device->lock);
-	//pthread_mutex_unlock(device->lock);
 
 	return device;
 }
-/* mark for Hank
-static void sram_device_reset_check(vpu_sram_device * device)
-{
-    restore_mutex_in_dead((MUTEX_HANDLE *) device->lock);
-    pthread_mutex_lock(device->lock);
-    do {
-        int i;
-        int inUse = 0;
-
-        if (device->info->owner_core == -1)
-            break;
-
-        if (device->info->owner_core > MAX_NUM_VPU_CORE)
-            break;
-
-        for (i=0; i<MAX_NUM_INSTANCE; i++) {
-            int * pCodecInst = (int *) device->pvip[device->info->owner_core]->codecInstPool[i];
-            if (pCodecInst[0] != 0) { // indicate inUse of CodecInst
-                inUse = 1;
-                break;
-            }
-        }
-
-        if (inUse)
-            break;
 
-        device->info->owner_core    = -1;
-        device->info->generation++;
-    } while(0);
-    pthread_mutex_unlock(device->lock);
-}
-*/
 static void sram_device_remove(vpu_sram_device *device)
 {
 	restore_mutex_in_dead((MUTEX_HANDLE *)device->lock);
 	mutex_lock(device->lock);
 	mutex_unlock(device->lock);
-	//pthread_mutex_lock(device->lock);
-	//pthread_mutex_unlock(device->lock);
 	osal_free(device);
 }
-/* mark for Hank
-static int sram_device_used(vpu_sram_device * device, unsigned long core_idx)
-{
-    int used = 0;
-    sram_device_reset_check(device);
-    restore_mutex_in_dead((MUTEX_HANDLE *) device->lock);
-    pthread_mutex_lock(device->lock);
-    do {
-        if (device->info->owner_core == (long)core_idx) {
-            device->generation = device->info->generation;
-            used = 1;
-            break;
-        }
-
-        if (device->info->owner_core == -1) {
-            device->info->owner_core = core_idx;
-            device->generation = device->info->generation;
-            used = 1;
-            break;
-        }
-    } while (0);
-    pthread_mutex_unlock(device->lock);
-    return used;
-}
-*/
+
 static inline void vdi_info_mutex_init_check(void)
 {
 	mutex_lock(&vdi_info_mutex_init_lock);
-	//pthread_mutex_lock(&vdi_info_mutex_init_lock);
 	if (vdi_info_mutex_init == 0) {
 		Int32 i;
 		for (i = 0; i < MAX_NUM_VPU_CORE; i++) {
-			//VLOG(TRACE, "[%d]%s.mutex_init vdi_info_mutex[%d].\n",__LINE__,__func__,i);
 			mutex_init(&vdi_info_mutex[i]);
-			//VLOG(TRACE, "[%d]%s.mutex_init vdi_init_release_lock[%d].\n",__LINE__,__func__,i);
 			mutex_init(&vdi_init_release_lock[i]);
-			//pthread_mutex_init(&vdi_info_mutex[i], NULL);
-			//pthread_mutex_init(&vdi_init_release_lock[i], NULL);
 			memset(&s_vdi_info[i], 0x00, sizeof(vdi_info_t));
 			s_vdi_info[i].vpu_fd = -1;
 		}
 		vdi_info_mutex_init = 1;
 	}
 	mutex_unlock(&vdi_info_mutex_init_lock);
-	//pthread_mutex_unlock(&vdi_info_mutex_init_lock);
 }
 
 #ifdef DEBUG_VDI_INFO_LOCK
@@ -372,7 +240,6 @@ static vdi_info_t *lock_vdi_info_debug(unsigned long core_idx,
 	if (core_idx >= MAX_NUM_VPU_CORE)
 		goto err;
 	mutex_lock(&vdi_info_mutex[core_idx]);
-	//pthread_mutex_lock(&vdi_info_mutex[core_idx]);
 	VLOG(ERR, "[%s:%s] core_idx = %ld", __FUNCTION__, parent_name,
 	     core_idx);
 	return &s_vdi_info[core_idx];
@@ -385,7 +252,6 @@ static void unlock_vdi_info_debug(vdi_info_t *vdi, unsigned long core_idx,
 {
 	if (vdi) {
 		mutex_unlock(&vdi_info_mutex[core_idx]);
-		//pthread_mutex_unlock(&vdi_info_mutex[core_idx]);
 		VLOG(ERR, "[%s:%s] core_idx = %ld", __FUNCTION__, parent_name,
 		     core_idx);
 	}
@@ -398,7 +264,6 @@ static vdi_info_t *lock_vdi_info(unsigned long core_idx)
 	if (core_idx >= MAX_NUM_VPU_CORE)
 		goto err;
 	mutex_lock(&vdi_info_mutex[core_idx]);
-	//pthread_mutex_lock(&vdi_info_mutex[core_idx]);
 	return &s_vdi_info[core_idx];
 err:
 	return NULL;
@@ -408,7 +273,6 @@ static void unlock_vdi_info(vdi_info_t *vdi, unsigned long core_idx)
 {
 	if (vdi) {
 		mutex_unlock(&vdi_info_mutex[core_idx]);
-		//pthread_mutex_unlock(&vdi_info_mutex[core_idx]);
 	}
 	return;
 }
@@ -420,12 +284,9 @@ static inline int vdi_pthread_mutex_trylock(unsigned long core_idx, int delayUs,
 	int ret;
 	unlock_vdi_info(&s_vdi_info[core_idx], core_idx);
 	ret = mutex_trylock((struct mutex *)mutex);
-	//VLOG(TRACE, "[%d]%s.mutex_trylock %s:0x%px.ret:%d\n",__LINE__,__func__,((mutex==&vpu_mutex)?"vpu_mutex":"vpu_display_mutex"),mutex,ret);
 	ret = !ret; // mutex_trylock() return 1 means lock, pthread_mutex_trylock() return 0 means lock
-	//ret = pthread_mutex_trylock((pthread_mutex_t*)mutex);
 	if (ret != 0 && delayUs > 0) {
 		usleep_range(delayUs, delayUs);
-		//usleep(delayUs);
 	}
 	lock_vdi_info(core_idx);
 	return ret;
@@ -438,21 +299,12 @@ static void vdi_init_thumb_info(vdi_info_t *vdi, int *pMutexState,
 	int inUse = 0;
 	vpu_instance_pool_t *pvip;
 
-	//VLOG(TRACE, "[%d]%s.vpu_thumb_mutex:0x%x.*pMutexState=%d\n",__LINE__,__func__,vdi->vpu_thumb_mutex,*pMutexState);
-
 	if (*pMutexState == FALSE) {
-		//VLOG(TRACE, "[%d]%s.mutex_init vpu_thumb_mutex:0x%px\n",__LINE__,__func__,vdi->vpu_thumb_mutex);
 		mutex_init(vdi->vpu_thumb_mutex);
-		//pthread_mutexattr_t mutexattr;
-		//pthread_mutexattr_init(&mutexattr);
-		//pthread_mutexattr_setpshared(&mutexattr, PTHREAD_PROCESS_SHARED);
-		//pthread_mutex_init((pthread_mutex_t*)vdi->vpu_thumb_mutex, &mutexattr);
 		*pMutexState = TRUE;
 	}
 
-	//VLOG(TRACE, "[%d]%s.mutex_lock vpu_thumb_mutex:0x%px\n",__LINE__,__func__,vdi->vpu_thumb_mutex);
 	mutex_lock(vdi->vpu_thumb_mutex);
-	//pthread_mutex_lock(vdi->vpu_thumb_mutex);
 	for (i = 0; i < MAX_NUM_VPU_CORE; i++) {
 		pvip = (vpu_instance_pool_t *)((unsigned long)first_pvip +
 					       (i * pvip_size));
@@ -469,9 +321,7 @@ static void vdi_init_thumb_info(vdi_info_t *vdi, int *pMutexState,
 		*vdi->thumb_used = 0;
 		*vdi->thumb_num = 0;
 	}
-	//VLOG(TRACE, "[%d]%s.mutex_unlock vpu_thumb_mutex:0x%px\n",__LINE__,__func__,vdi->vpu_thumb_mutex);
 	mutex_unlock(vdi->vpu_thumb_mutex);
-	//pthread_mutex_unlock(vdi->vpu_thumb_mutex);
 }
 
 int vdi_probe(unsigned long core_idx)
@@ -495,12 +345,10 @@ int vdi_init(unsigned long core_idx)
 	VLOG(TRACE, "[+] [%d]%s.core_idx:%d.MAX_NUM_VPU_CORE:%d\n", __LINE__,
 	     __func__, core_idx, MAX_NUM_VPU_CORE);
 
-	//pthread_mutex_lock(&vdi_init_release_lock[core_idx]);
 	vdi = lock_vdi_info(core_idx);
 	VLOG(TRACE, "[%d]%s.tgid(%d,%d,%s).vdi:0x%x\n", __LINE__, __func__,
 	     current->tgid, current->pid, current->comm, vdi);
 	if (vdi == NULL) {
-		//pthread_mutex_unlock(&vdi_init_release_lock[core_idx]);
 		VLOG(ERR, "[-] [%d]%s.vdi == NULL\n", __LINE__, __func__);
 		return ret;
 	}
@@ -508,7 +356,6 @@ int vdi_init(unsigned long core_idx)
 	ret = Internal_vdi_init(core_idx);
 	mutex_unlock(&vdi_init_release_lock[core_idx]);
 	unlock_vdi_info(vdi, core_idx);
-	//pthread_mutex_unlock(&vdi_init_release_lock[core_idx]);
 
 	VLOG(TRACE, "[-] [%d]%s.ret:%d\n", __LINE__, __func__, ret);
 	return ret;
@@ -536,18 +383,7 @@ static int Internal_vdi_init(unsigned long core_idx)
 	}
 
 	vdi->vpu_fd = 0xabcd;
-	/*
-    vdi->vpu_fd = open(VPU_DEVICE_NAME, O_RDWR);	// if this API supports VPU parallel processing using multi VPU. the driver should be made to open multiple times.
-    if (vdi->vpu_fd < 0) {
-        VLOG(ERR, "[VDI] Can't open vpu driver. [error=%s]. \n", strerror(errno));
-        vdi->vpu_fd = open(RTK_VPU_DEVICE_NAME, O_RDWR); //workaroud for CTS
-        if (vdi->vpu_fd < 0)
-        {
-            VLOG(ERR, "[VDI] Still can't open vpu driver. [error=%s]. \n", strerror(errno));
-            return -1;
-        }
-    }
-*/
+
 	memset(&vdi->vpu_buffer_pool, 0x00,
 	       sizeof(vdi_vpudrv_buffer_pool_t) * MAX_VPU_BUFFER_POOL);
 	memset(&vdi->vdb_pvip, 0x00, sizeof(vpudrv_buffer_t)); //RTK
@@ -563,26 +399,8 @@ static int Internal_vdi_init(unsigned long core_idx)
 
 	if (vdi->pvip->instance_pool_inited == FALSE) {
 		int *pCodecInst;
-		//VLOG(TRACE, "[%d]%s.mutex_init vpu_mutex:0x%px\n",__LINE__,__func__,vdi->vpu_mutex);
 		mutex_init(vdi->vpu_mutex);
-		//VLOG(TRACE, "[%d]%s.mutex_init vpu_disp_mutex:0x%px\n",__LINE__,__func__,vdi->vpu_disp_mutex);
 		mutex_init(vdi->vpu_disp_mutex);
-		//pthread_mutexattr_t mutexattr;
-		//pthread_mutexattr_init(&mutexattr);
-		//pthread_mutexattr_setpshared(&mutexattr, PTHREAD_PROCESS_SHARED);
-		//#if defined(ANDROID) || !defined(PTHREAD_MUTEX_ROBUST_NP)
-		//#else
-		/* If a process or a thread is terminated abnormally,
-        * pthread_mutexattr_setrobust_np(attr, PTHREAD_MUTEX_ROBUST_NP) makes
-        * next onwer call pthread_mutex_lock() without deadlock.
-        */
-//        pthread_mutexattr_setrobust_np(&mutexattr, PTHREAD_MUTEX_ROBUST_NP);
-//#endif
-//pthread_mutex_init((pthread_mutex_t*)vdi->vpu_mutex, &mutexattr);
-//pthread_mutex_init((pthread_mutex_t*)vdi->vpu_disp_mutex, &mutexattr);
-#if 0
-        pthread_mutex_init((MUTEX_HANDLE *)vdi->vpu_sram_mutex, &mutexattr);
-#endif
 
 		for (i = 0; i < MAX_NUM_INSTANCE; i++) {
 			pCodecInst = (int *)vdi->pvip->codecInstPool[i];
@@ -598,27 +416,7 @@ static int Internal_vdi_init(unsigned long core_idx)
 		     __LINE__);
 		goto ERR_VDI_INIT;
 	}
-	/*
-#ifdef USE_VMALLOC_FOR_INSTANCE_POOL_MEMORY
-    if (ioctl(vdi->vpu_fd, VDI_IOCTL_GET_REGISTER_INFO, &vdi->vdb_register) < 0)
-    {
-        VLOG(ERR, "[VDI] fail to get host interface register\n");
-        goto ERR_VDI_INIT;
-    }
-#endif
-#ifdef USE_VMALLOC_FOR_INSTANCE_POOL_MEMORY
-    //vdi->vdb_register.virt_addr = (unsigned long)mmap64(NULL, vdi->vdb_register.size, PROT_READ | PROT_WRITE, MAP_SHARED, vdi->vpu_fd, vdi->vdb_register.phys_addr);
-    vdi->vdb_register.virt_addr = (unsigned long)Internal_vdi_map_registers(vdi->vpu_fd, vdi->vdb_register.phys_addr, vdi->vdb_register.size);
-#else
-    vdi->vdb_register.size = VPU_BIT_REG_SIZE;
-    vdi->vdb_register.virt_addr = (unsigned long)mmap64(NULL, vdi->vdb_register.size, PROT_READ | PROT_WRITE, MAP_SHARED, vdi->vpu_fd, 0);
-#endif
-    if ((void *)vdi->vdb_register.virt_addr == MAP_FAILED)
-    {
-        VLOG(ERR, "[VDI] fail to map vpu registers \n");
-        goto ERR_VDI_INIT;
-    }
-*/
+
 	VLOG(TRACE,
 	     "[%d][VDI] map vdb_register core_idx=%d, virtaddr=0x%lx, size=%d\n",
 	     __LINE__, core_idx, vdi->vdb_register.virt_addr,
@@ -654,8 +452,6 @@ static int Internal_vdi_init(unsigned long core_idx)
 		goto ERR_VDI_INIT;
 	}
 
-	//ioctl(vdi->vpu_fd, VDI_IOCTL_GET_RTK_ASIC_REVISION, &vdi->asic_id); //fuchun
-
 	if (Internal_allocate_common_memory(core_idx) < 0) {
 		VLOG(ERR,
 		     "[%d][VDI] fail to get vpu common buffer from driver\n",
@@ -718,13 +514,6 @@ static int Internal_vdi_set_bit_firmware_to_pm(unsigned long core_idx,
 		     __LINE__, bit_firmware_info.core_idx);
 		return -1;
 	}
-	/*
-    if (write(vdi->vpu_fd, &bit_firmware_info, bit_firmware_info.size) < 0)
-    {
-        VLOG(ERR, "[VDI] fail to vdi_set_bit_firmware core=%d\n", bit_firmware_info.core_idx);
-        return -1;
-    }
-*/
 
 	return 0;
 }
@@ -737,17 +526,14 @@ int vdi_release(unsigned long core_idx)
 	VLOG(TRACE, "[+] [%d]%s.core_idx:%d\n", __LINE__, __func__, core_idx);
 
 	mutex_lock(&vdi_init_release_lock[core_idx]);
-	//pthread_mutex_lock(&vdi_init_release_lock[core_idx]);
 	vdi = lock_vdi_info(core_idx);
 	if (vdi == NULL) {
 		mutex_unlock(&vdi_init_release_lock[core_idx]);
-		//pthread_mutex_unlock(&vdi_init_release_lock[core_idx]);
 		return ret;
 	}
 	ret = Internal_vdi_release(core_idx);
 	unlock_vdi_info(vdi, core_idx);
 	mutex_unlock(&vdi_init_release_lock[core_idx]);
-	//pthread_mutex_unlock(&vdi_init_release_lock[core_idx]);
 
 	VLOG(TRACE, "[-] [%d]%s.core_idx:%d.ret:%d\n", __LINE__, __func__,
 	     core_idx, ret);
@@ -785,17 +571,10 @@ static int Internal_vdi_release(unsigned long core_idx)
 		vdi->sram_dev = NULL;
 	}
 
-	//if (vdi->vdb_register.virt_addr)
-	//    Internal_vdi_unmap_registers((void *)vdi->vdb_register.virt_addr, vdi->vdb_register.size);
-
 	osal_memset(&vdi->vdb_register, 0x00, sizeof(vpudrv_buffer_t));
 
-	//if (vdi->dcsys_register.virt_addr)
-	//    Internal_vdi_unmap_registers((void *)vdi->dcsys_register.virt_addr, vdi->dcsys_register.size);
 	osal_memset(&vdi->dcsys_register, 0x00, sizeof(vpudrv_buffer_t));
 
-	//if (vdi->dmcsys_register.virt_addr)
-	//    Internal_vdi_unmap_registers((void *)vdi->dmcsys_register.virt_addr, vdi->dmcsys_register.size);
 	osal_memset(&vdi->dmcsys_register, 0x00, sizeof(vpudrv_buffer_t));
 
 	vdb.size = 0;
@@ -814,7 +593,6 @@ static int Internal_vdi_release(unsigned long core_idx)
 	}
 
 	if (vdb.size > 0) {
-		//munmap((void *)vdb.virt_addr, vdb.size);
 		memset(&vdi->vpu_common_memory, 0x00, sizeof(vpu_buffer_t));
 	}
 
@@ -830,16 +608,9 @@ static int Internal_vdi_release(unsigned long core_idx)
 
 	//RTK, free instance pool virtual address
 	if (vdi->vdb_pvip.size > 0) {
-		//munmap((void *)vdi->vdb_pvip.virt_addr, vdi->vdb_pvip.size);
 		vdi->vdb_pvip.size = 0;
 	}
-	/*
-    if (vdi->vpu_fd != -1 && vdi->vpu_fd != 0x00)
-    {
-        close(vdi->vpu_fd);
-        vdi->vpu_fd = -1;
-    }
-*/
+
 	memset(vdi, 0x00, sizeof(vdi_info_t));
 	vdi->vpu_fd = -1;
 
@@ -896,22 +667,7 @@ static int Internal_allocate_common_memory(unsigned long core_idx)
 		     __LINE__, vdb.size);
 		return -1;
 	}
-	/*
-    if (ioctl(vdi->vpu_fd, VDI_IOCTL_GET_COMMON_MEMORY, &vdb) < 0)
-    {
-        VLOG(ERR, "[VDI] fail to VDI_IOCTL_GET_COMMON_MEMORY size=%d\n", vdb.size);
-        return -1;
-    }
-
-    vdb.virt_addr = (unsigned long)mmap64(NULL, vdb.size, PROT_READ | PROT_WRITE, MAP_SHARED, vdi->vpu_fd, vdb.phys_addr);
-    if ((void *)vdb.virt_addr == MAP_FAILED)
-    {
-        VLOG(ERR, "[VDI] fail to map common memory phyaddr=0x%lx, size = %d\n", (int)vdb.phys_addr, (int)vdb.size);
-        return -1;
-    }
 
-    VLOG(TRACE, "[VDI] Internal_allocate_common_memory, physaddr=0x%lx, virtaddr=0x%lx\n", (int)vdb.phys_addr, (int)vdb.virt_addr);
-*/
 	// convert os driver buffer type to vpu buffer type
 	vdi->pvip->vpu_common_buffer.size = SIZE_COMMON;
 	vdi->pvip->vpu_common_buffer.phys_addr = (unsigned long)(vdb.phys_addr);
@@ -1020,8 +776,6 @@ Internal_vdi_get_instance_pool(unsigned long core_idx)
 	vpudrv_buffer_t vdb;
 	int instance_pool_size_per_core;
 
-	//VLOG(TRACE, "[+] [%d]%s\n",__LINE__,__func__);
-
 	if (core_idx >= MAX_NUM_VPU_CORE)
 		return NULL;
 
@@ -1035,7 +789,6 @@ Internal_vdi_get_instance_pool(unsigned long core_idx)
 		vdb.size =
 			sizeof(vpu_instance_pool_t) +
 			sizeof(USERSPACE_MUTEX_HANDLE) * VDI_NUM_LOCK_HANDLES;
-		//vdb.size = sizeof(vpu_instance_pool_t) + sizeof(MUTEX_HANDLE)*VDI_NUM_LOCK_HANDLES;
 		vdb.size += sizeof(int) + sizeof(vpu_sram_info);
 		vdb.size += sizeof(int) * 3;
 		VLOG(TRACE, "[%d]size:%d(%d+%d*%d+%d*4+%d)\n", __LINE__,
@@ -1053,26 +806,9 @@ Internal_vdi_get_instance_pool(unsigned long core_idx)
 		}
 		VLOG(TRACE, "[%d]vdb(0x%lx,0x%lx,%d)\n", __LINE__,
 		     vdb.virt_addr, vdb.phys_addr, vdb.size);
-		/*
-        if (ioctl(vdi->vpu_fd, VDI_IOCTL_GET_INSTANCE_POOL, &vdb) < 0)
-        {
-            VLOG(ERR, "[VDI] fail to allocate get instance pool physical space=%d\n", (int)vdb.size);
-            return NULL;
-        }
-*/
+
 		instance_pool_size_per_core = vdb.size / MAX_NUM_VPU_CORE;
-		/*
-#ifdef USE_VMALLOC_FOR_INSTANCE_POOL_MEMORY
-        vdb.virt_addr = (unsigned long)mmap64(NULL, vdb.size, PROT_READ | PROT_WRITE, MAP_SHARED, vdi->vpu_fd, 0);
-#else
-        vdb.virt_addr = (unsigned long)mmap64(NULL, vdb.size, PROT_READ | PROT_WRITE, MAP_SHARED, vdi->vpu_fd, vdb.phys_addr);
-#endif
-        if ((void *)vdb.virt_addr == MAP_FAILED)
-        {
-            VLOG(ERR, "[VDI] fail to map instance pool phyaddr=0x%lx, size = %d\n", (int)vdb.phys_addr, (int)vdb.size);
-            return NULL;
-        }
-*/
+
 		vdi->pvip =
 			(vpu_instance_pool_t
 				 *)(vdb.virt_addr +
@@ -1082,11 +818,7 @@ Internal_vdi_get_instance_pool(unsigned long core_idx)
 		     vdi->pvip);
 
 		vdi->vpu_mutex = &vpu_mutex;
-		//VLOG(TRACE, "[%d]%s.tgid(%d,%d,%s).set vdi->vpu_mutex:0x%px from global static vpu_mutex\n",__LINE__,__func__,current->tgid,current->pid,current->comm,vdi->vpu_mutex);
 		vdi->vpu_disp_mutex = &vpu_disp_mutex;
-		//VLOG(TRACE, "[%d]%s.set vdi->vpu_disp_mutex:0x%px from global static vpu_disp_mutex\n",__LINE__,__func__,vdi->vpu_disp_mutex);
-		//vdi->vpu_mutex =      (void *)((unsigned long)vdi->pvip + (instance_pool_size_per_core - sizeof(MUTEX_HANDLE)*VDI_NUM_LOCK_HANDLES)/*sizeof(vpu_instance_pool_t)*/);	//change the pointer of vpu_mutex to at end pointer of vpu_instance_pool_t to assign at allocated position.
-		//vdi->vpu_disp_mutex = (void *)((unsigned long)vdi->pvip + (instance_pool_size_per_core - sizeof(MUTEX_HANDLE)*(VDI_NUM_LOCK_HANDLES-1))/*sizeof(vpu_instance_pool_t) + sizeof(MUTEX_HANDLE)*/);
 		{
 			int *sram_mutex_init;
 			int *thumb_mutex_init;
@@ -1094,18 +826,14 @@ Internal_vdi_get_instance_pool(unsigned long core_idx)
 			vpu_instance_pool_t *first_pvip =
 				(vpu_instance_pool_t *)vdb.virt_addr;
 			vdi->vpu_sram_mutex = &vpu_sram_mutex;
-			//VLOG(TRACE, "[%d]%s.set vdi->vpu_sram_mutex:0x%px from global static vpu_sram_mutex\n",__LINE__,__func__,vdi->vpu_sram_mutex);
-			//vdi->vpu_sram_mutex         = (void *)((unsigned long)first_pvip + (instance_pool_size_per_core - sizeof(MUTEX_HANDLE)*(VDI_NUM_LOCK_HANDLES-2)));
 			sram_mutex_init =
 				(int *)((unsigned long)first_pvip +
 					(instance_pool_size_per_core -
 					 sizeof(USERSPACE_MUTEX_HANDLE) *
 						 VDI_NUM_LOCK_HANDLES -
 					 sizeof(int)));
-			//sram_mutex_init             = (int *) ((unsigned long)first_pvip + (instance_pool_size_per_core - sizeof(MUTEX_HANDLE)*VDI_NUM_LOCK_HANDLES - sizeof(int)));
 			sram_info = (void *)((unsigned long)sram_mutex_init -
 					     sizeof(vpu_sram_info));
-			//VLOG(TRACE, "[%d]pvip:0x%px.sram_mutex_init:0x%px.sram_info:0x%px\n",__LINE__,vdi->pvip,sram_mutex_init,sram_info);
 
 			if (vdi->sram_dev == NULL) {
 				vdi->sram_dev = sram_device_create(
@@ -1115,8 +843,6 @@ Internal_vdi_get_instance_pool(unsigned long core_idx)
 			}
 
 			vdi->vpu_thumb_mutex = &vpu_thumb_mutex;
-			//VLOG(TRACE, "[%d]%s.set vdi->vpu_thumb_mutex:0x%px from global static vpu_thumb_mutex\n",__LINE__,__func__,vdi->vpu_thumb_mutex);
-			//vdi->vpu_thumb_mutex         = (void *)((unsigned long)first_pvip + (instance_pool_size_per_core - sizeof(MUTEX_HANDLE)*(VDI_NUM_LOCK_HANDLES-3)));
 			vdi->thumb_used =
 				(int *)((unsigned long)sram_info - sizeof(int));
 			vdi->thumb_num =
@@ -1125,7 +851,6 @@ Internal_vdi_get_instance_pool(unsigned long core_idx)
 			thumb_mutex_init =
 				(int *)((unsigned long)vdi->thumb_num -
 					sizeof(int));
-			//VLOG(TRACE, "[%d]thumb_used:0x%px.thumb_num:0x%px.thumb_mutex_init:0x%px\n",__LINE__,vdi->thumb_used,vdi->thumb_num,thumb_mutex_init);
 			vdi_init_thumb_info(vdi, thumb_mutex_init, first_pvip,
 					    instance_pool_size_per_core);
 		}
@@ -1140,7 +865,6 @@ Internal_vdi_get_instance_pool(unsigned long core_idx)
 		vdi->vdb_pvip.virt_addr = vdb.virt_addr;
 	}
 
-	//VLOG(TRACE, "[-] [%d]%s\n",__LINE__,__func__);
 	return (vpu_instance_pool_t *)vdi->pvip;
 }
 
@@ -1179,13 +903,7 @@ static int Internal_vdi_open_instance(unsigned long core_idx,
 		     __LINE__, (int)inst_idx);
 		return -1;
 	}
-	/*
-    if (ioctl(vdi->vpu_fd, VDI_IOCTL_OPEN_INSTANCE, &inst_info) < 0)
-    {
-        VLOG(ERR, "[VDI] fail to deliver open instance num inst_idx=%d\n", (int)inst_idx);
-        return -1;
-    }
-*/
+
 	vdi->pvip->vpu_instance_num = inst_info.inst_open_count;
 
 	return 0;
@@ -1225,13 +943,7 @@ static int Internal_vdi_close_instance(unsigned long core_idx,
 		     __LINE__, (int)inst_idx);
 		return -1;
 	}
-	/*
-    if (ioctl(vdi->vpu_fd, VDI_IOCTL_CLOSE_INSTANCE, &inst_info) < 0)
-    {
-        VLOG(ERR, "[VDI] fail to deliver open instance num inst_idx=%d\n", (int)inst_idx);
-        return -1;
-    }
-*/
+
 	vdi->pvip->vpu_instance_num = inst_info.inst_open_count;
 
 	return 0;
@@ -1287,7 +999,6 @@ static int Internal_vdi_hw_reset(unsigned long core_idx)
 		return -1;
 
 	return 0;
-	//return ioctl(vdi->vpu_fd, VDI_IOCTL_RESET, &core_idx);
 }
 
 int vdi_check_protect(unsigned long core_idx)
@@ -1298,17 +1009,6 @@ int vdi_check_protect(unsigned long core_idx)
 		return 0;
 
 	if (core_idx == 1) {
-		/*
-        if ((Internal_vdi_read_register(core_idx, VE2_CTRL) & 0x2) != 0) // if BIT processor is not running.
-        {
-            value = Internal_vdi_read_register(core_idx, VE2_PROT_CTRL);
-        }
-        else
-        {
-            VLOG(ERR, "VE2 CTI didn't enable\n");
-            goto ERR_VDI_GET_PROT;
-        }
-*/
 	} else if (core_idx == 0) // CODA9XX
 	{
 		if ((Internal_vdi_read_register(core_idx, VE1_CTRL) & 0x2) !=
@@ -1359,9 +1059,7 @@ static void Internal_vdi_check_hwreset(unsigned long core_idx)
 	Internal_vdi_lock(core_idx);
 
 	if (vdi->pvip->vpu_instance_num == 0) {
-		//ioctl(vdi->vpu_fd, VDI_IOCTL_RESET, &core_idx);
 		usleep_range(1000, 1000);
-		//usleep(1000);
 	}
 
 	Internal_vdi_unlock(core_idx);
@@ -1374,20 +1072,11 @@ static int restore_mutex_in_dead(MUTEX_HANDLE *mutex)
 
 	if (!mutex)
 		return 0;
-	//#if defined(ANDROID)
-	//mutex_value = mutex->value; //RTK disable, because Android M has no member named 'value'
 	mutex_tmp = (int *)mutex;
 	mutex_value = (int)mutex_tmp[0];
-	//#else
-	//    memcpy(&mutex_value, mutex, sizeof(mutex_value));
-	//#endif
 	if (mutex_value == (int)0xdead10cc) // destroy by device driver
 	{
 		mutex_init(mutex);
-		//pthread_mutexattr_t mutexattr;
-		//pthread_mutexattr_init(&mutexattr);
-		//pthread_mutexattr_setpshared(&mutexattr, PTHREAD_PROCESS_SHARED);
-		//pthread_mutex_init((pthread_mutex_t*)mutex, &mutexattr);
 		return 0;
 	}
 
@@ -1410,7 +1099,7 @@ static int Internal_vdi_lock(unsigned long core_idx)
 	vdi_info_t *vdi;
 	const int MUTEX_TIMEOUT = 0x7fffffff;
 #if defined(ANDROID) || !defined(PTHREAD_MUTEX_ROBUST_NP)
-  int _ret = 0, j;
+	int _ret = 0, j;
 #endif
 
 	if (core_idx >= MAX_NUM_VPU_CORE)
@@ -1447,8 +1136,6 @@ static int Internal_vdi_lock(unsigned long core_idx)
 
 	if (_ret == 0)
 		return 0;
-
-		//pthread_mutex_lock((MUTEX_HANDLE*)vdi->vpu_mutex);
 #else
 	while (1) {
 		int _ret, i;
@@ -1552,9 +1239,7 @@ static void Internal_vdi_unlock(unsigned long core_idx)
 	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
 		return;
 
-	//VLOG(TRACE, "[%d]%s.mutex_unlock vpu_mutex:0x%px\n",__LINE__,__func__,vdi->vpu_mutex);
 	mutex_unlock(vdi->vpu_mutex);
-	//pthread_mutex_unlock((pthread_mutex_t*)vdi->vpu_mutex);
 }
 
 int vdi_disp_lock(unsigned long core_idx)
@@ -1562,7 +1247,7 @@ int vdi_disp_lock(unsigned long core_idx)
 	vdi_info_t *vdi;
 	const int MUTEX_TIMEOUT = 5000; // ms
 #if defined(ANDROID) || !defined(PTHREAD_MUTEX_ROBUST_NP)
-  int _ret = 0, j;
+	int _ret = 0, j;
 #endif
 
 	if (core_idx >= MAX_NUM_VPU_CORE)
@@ -1604,8 +1289,6 @@ int vdi_disp_lock(unsigned long core_idx)
 		unlock_vdi_info(vdi, core_idx);
 		return 0;
 	}
-
-	//pthread_mutex_lock((MUTEX_HANDLE*)vdi->vpu_disp_mutex);
 #else
 	while (1) {
 		int _ret, i;
@@ -1663,9 +1346,7 @@ static void Internal_vdi_disp_unlock(unsigned long core_idx)
 	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
 		return;
 
-	//VLOG(TRACE, "[%d]%s.mutex_unlock vpu_disp_mutex:0x%px\n",__LINE__,__func__,vdi->vpu_disp_mutex);
 	mutex_unlock(vdi->vpu_disp_mutex);
-	//pthread_mutex_unlock((pthread_mutex_t*)vdi->vpu_disp_mutex);
 }
 
 void vdi_write_register(unsigned long core_idx, unsigned int addr,
@@ -1740,7 +1421,6 @@ static unsigned int Internal_vdi_read_register(unsigned long core_idx,
 
 int vdi_clear_memory(unsigned long core_idx, unsigned int addr, int len,
 		     int endian)
-//int vdi_clear_memory(unsigned long core_idx, unsigned int addr, int len, int endian __unused)
 {
 	vdi_info_t *vdi;
 	vpudrv_buffer_t vdb;
@@ -1791,7 +1471,6 @@ int vdi_clear_memory(unsigned long core_idx, unsigned int addr, int len,
 
 void vdi_set_sdram(unsigned long coreIdx, unsigned int addr, int len,
 		   unsigned char data, int endian)
-//void vdi_set_sdram(unsigned long coreIdx, unsigned int addr, int len, unsigned char data __unused, int endian)
 {
 	vdi_info_t *vdi = lock_vdi_info(coreIdx);
 	unsigned char *buf;
@@ -1943,7 +1622,6 @@ int vdi_allocate_dma_memory(unsigned long core_idx, vpu_buffer_t *vb,
 	unlock_vdi_info(vdi, core_idx);
 	return ret;
 }
-//EXPORT_SYMBOL(vdi_allocate_dma_memory);
 
 static int Internal_vdi_allocate_dma_memory(unsigned long core_idx,
 					    vpu_buffer_t *vb, void *filp)
@@ -1978,7 +1656,6 @@ static int Internal_vdi_allocate_dma_memory(unsigned long core_idx,
 	//RTK
 	while (1) {
 		ret = rtd16xxb_vdi_ioctl_allocate_physical_memory(filp, &vdb);
-		//ret = ioctl(vdi->vpu_fd, VDI_IOCTL_ALLOCATE_PHYSICAL_MEMORY, &vdb);
 		if (ret >= 0)
 			break;
 		else {
@@ -1988,7 +1665,6 @@ static int Internal_vdi_allocate_dma_memory(unsigned long core_idx,
 				     "[%d][VDI] fail to rtd16xxb_vdi_ioctl_allocate_physical_memory size=%d, wait 50ms and retry count=%d\n",
 				     __LINE__, vb->size, retry);
 				msleep(50);
-				//usleep(50000);
 			} else {
 				VLOG(ERR,
 				     "[%d][VDI] fail to rtd16xxb_vdi_ioctl_allocate_physical_memory size=%d\n",
@@ -1997,16 +1673,7 @@ static int Internal_vdi_allocate_dma_memory(unsigned long core_idx,
 			}
 		}
 	}
-	/*
-    //map to virtual address
-    vdb.virt_addr = (unsigned long)mmap64(NULL, vdb.size, PROT_READ | PROT_WRITE,
-                                          MAP_SHARED, vdi->vpu_fd, vdb.phys_addr);
-    if ((void *)vdb.virt_addr == MAP_FAILED)
-    {
-        memset(vb, 0x00, sizeof(vpu_buffer_t));
-        return -1;
-    }
-*/
+
 	vb->phys_addr = (unsigned long)vdb.phys_addr;
 	vb->base = (unsigned long)vdb.base;
 	vb->virt_addr = vdb.virt_addr;
@@ -2050,7 +1717,6 @@ int vdi_allocate_dma_memory_no_mmap(unsigned long core_idx, vpu_buffer_t *vb,
 	unlock_vdi_info(vdi, core_idx);
 	return ret;
 }
-//EXPORT_SYMBOL(vdi_allocate_dma_memory_no_mmap);
 
 static int Internal_vdi_allocate_dma_memory_no_mmap(unsigned long core_idx,
 						    vpu_buffer_t *vb,
@@ -2096,7 +1762,6 @@ static int Internal_vdi_allocate_dma_memory_no_mmap(unsigned long core_idx,
 				     "[%d][VDI] fail to rtd16xxb_vdi_ioctl_allocate_physical_memory_no_mmap size=%d, wait 50ms and retry count=%d\n",
 				     __LINE__, vb->size, retry);
 				msleep(50);
-				//usleep(50000);
 			} else {
 				VLOG(ERR,
 				     "[%d][VDI] fail to rtd16xxb_vdi_ioctl_allocate_physical_memory_no_mmap size=%d\n",
@@ -2240,7 +1905,6 @@ void vdi_free_dma_memory(unsigned long core_idx, vpu_buffer_t *vb)
 	unlock_vdi_info(vdi, core_idx);
 	return;
 }
-//EXPORT_SYMBOL(vdi_free_dma_memory);
 
 static void Internal_vdi_free_dma_memory(unsigned long core_idx,
 					 vpu_buffer_t *vb)
@@ -2283,14 +1947,7 @@ static void Internal_vdi_free_dma_memory(unsigned long core_idx,
 	}
 
 	rtd16xxb_vdi_ioctl_free_physical_memory(&vdb);
-	/*
-    if (munmap((void *)vdb.virt_addr, vdb.size) != 0)
-    {
-        VLOG(ERR, "[VDI] fail to vdi_free_dma_memory virtial address = 0x%lx\n", (int)vdb.virt_addr);
-    }
-
-    ioctl(vdi->vpu_fd, VDI_IOCTL_FREE_PHYSICALMEMORY, &vdb);
-*/
+
 	VLOG(TRACE,
 	     "[%d][VDI] Internal_vdi_free_dma_memory, physaddr=0x%lx, virtaddr=0x%lx, size=%d, index=%d\n",
 	     __LINE__, vb->phys_addr, vb->virt_addr, vb->size, i);
@@ -2306,7 +1963,6 @@ void vdi_free_dma_memory_no_mmap(unsigned long core_idx, vpu_buffer_t *vb)
 	unlock_vdi_info(vdi, core_idx);
 	return;
 }
-//EXPORT_SYMBOL(vdi_free_dma_memory_no_mmap);
 
 static void Internal_vdi_free_dma_memory_no_mmap(unsigned long core_idx,
 						 vpu_buffer_t *vb)
@@ -2368,18 +2024,8 @@ int vdi_get_sram_memory(unsigned long core_idx, vpu_buffer_t *vb)
 		return -1;
 	}
 
-#if 0 // 0 for Hank due to VE1 + VE3 both use 2nd SRAM
-    if (!vdi->sram_dev || sram_device_used(vdi->sram_dev, core_idx) == 0) {
-        //VLOG(TRACE, "[VDI] core_idx:%d not used sram (%p)", core_idx, vdi->sram_dev);
-        unlock_vdi_info(vdi, core_idx);
-        return 1;
-    }
-    //VLOG(TRACE, "[VDI] core_idx:%d used sram (%p)", core_idx, vdi->sram_dev);
-#endif
-
 	osal_memset(&vdb, 0x00, sizeof(vpudrv_buffer_t));
 
-#if 1 // RTK, 1 for Hank
 	switch (vdi->product_code) {
 	case BODA950_CODE:
 	case CODA960_CODE:
@@ -2391,14 +2037,10 @@ int vdi_get_sram_memory(unsigned long core_idx, vpu_buffer_t *vb)
 		VLOG(ERR, "Check SRAM_SIZE(%d)\n", vdi->product_code);
 		break;
 	}
-#else
-	sram_size = VDI_SRAM_SIZE;
-#endif
 
 	if (sram_size >
 	    0) // if we can know the sram address directly in vdi layer, we use it first for sdram address
 	{
-		//vb->phys_addr = VDI_SRAM_BASE_ADDR;//+(core_idx*sram_size);
 		vb->size = sram_size;
 		VLOG(TRACE, "[%s:%d] core_idx:%d.phys_addr:0x%x.size:%d.\n",
 		     __FUNCTION__, __LINE__, core_idx, vb->phys_addr, vb->size);
@@ -2434,7 +2076,6 @@ static int Internal_vdi_set_clock_gate(unsigned long core_idx, int enable)
 		return -1;
 	}
 	vdi->clock_state = enable;
-	//ret = ioctl(vdi->vpu_fd, VDI_IOCTL_SET_CLOCK_GATE, &enable);
 
 	return ret;
 }
@@ -2465,18 +2106,11 @@ int vdi_wait_bus_busy(unsigned long core_idx, int timeout,
 	struct timespec64 ts_base;
 	struct timespec64 ts;
 	struct timespec64 ts_delta;
-	//Int64 elapse, cur;
-	//struct timeval tv;
 	vdi_info_t *vdi;
 
 	vdi = lock_vdi_info(core_idx);
 
 	ktime_get_ts64(&ts_base);
-	//tv.tv_sec = 0;
-	//tv.tv_usec = 0;
-	//do_gettimeofday(&tv);
-	//gettimeofday(&tv, NULL);
-	//elapse = tv.tv_sec*1000 + tv.tv_usec/1000;
 
 	while (1) {
 		if (PRODUCT_CODE_NOT_W_SERIES(vdi->product_code)) {
@@ -2493,12 +2127,8 @@ int vdi_wait_bus_busy(unsigned long core_idx, int timeout,
 		if (timeout > 0) {
 			ktime_get_ts64(&ts);
 			ts_delta = timespec64_sub(ts, ts_base);
-			//do_gettimeofday(&tv);
-			//gettimeofday(&tv, NULL);
-			//cur = tv.tv_sec * 1000 + tv.tv_usec / 1000;
 
 			if ((timespec64_to_ns(&ts_delta) / 1000000) > timeout)
-			//if ((cur - elapse) > timeout)
 			{
 				VLOG(ERR,
 				     "[VDI] vdi_wait_bus_busy timeout, PC=0x%lx\n",
@@ -2519,8 +2149,6 @@ int vdi_wait_vpu_busy(unsigned long core_idx, int timeout,
 	struct timespec64 ts_base;
 	struct timespec64 ts;
 	struct timespec64 ts_delta;
-	//Int64 elapse, cur;
-	//struct timeval tv;
 	Uint32 pc;
 	Uint32 code, normalReg = TRUE;
 
@@ -2529,11 +2157,6 @@ int vdi_wait_vpu_busy(unsigned long core_idx, int timeout,
 		return -1;
 
 	ktime_get_ts64(&ts_base);
-	//tv.tv_sec = 0;
-	//tv.tv_usec = 0;
-	//do_gettimeofday(&tv);
-	//gettimeofday(&tv, NULL);
-	//elapse = tv.tv_sec*1000 + tv.tv_usec/1000;
 
 	code = Internal_vdi_read_register(
 		core_idx, VPU_PRODUCT_CODE_REGISTER); /* read product code */
@@ -2556,12 +2179,8 @@ int vdi_wait_vpu_busy(unsigned long core_idx, int timeout,
 		if (timeout > 0) {
 			ktime_get_ts64(&ts);
 			ts_delta = timespec64_sub(ts, ts_base);
-			//do_gettimeofday(&tv);
-			//gettimeofday(&tv, NULL);
-			//cur = tv.tv_sec * 1000 + tv.tv_usec / 1000;
 
 			if ((timespec64_to_ns(&ts_delta) / 1000000) > timeout)
-			//if ((cur - elapse) > timeout)
 			{
 				Uint32 index;
 				for (index = 0; index < 50; index++) {
@@ -2585,7 +2204,6 @@ int vdi_wait_vpu_busy(unsigned long core_idx, int timeout,
 
 int vdi_wait_interrupt(unsigned long coreIdx, int timeout,
 		       unsigned int addr_bit_int_reason)
-//int vdi_wait_interrupt(unsigned long coreIdx, int timeout, unsigned int addr_bit_int_reason __unused)
 {
 	int intr_reason = 0;
 	int ret;
@@ -2607,7 +2225,6 @@ int vdi_wait_interrupt(unsigned long coreIdx, int timeout,
 	intr_info.intr_reason = 0;
 
 	ret = rtd16xxb_vdi_ioctl_wait_interrupt(&intr_info);
-	//ret = ioctl(vdi->vpu_fd, VDI_IOCTL_WAIT_INTERRUPT, (void*)&intr_info);
 	if (ret != 0) {
 		unlock_vdi_info(vdi, coreIdx);
 		return -1;
@@ -2677,7 +2294,6 @@ static int read_pinfo_buffer(int core_idx, int addr)
 
 	rdata = Internal_vdi_read_register(core_idx, VDI_LOG_GDI_PINFO_DATA);
 
-	//printf("[READ PINFO] ADDR[%x], DATA[%x]", addr, rdata);
 	return rdata;
 }
 
@@ -2789,36 +2405,12 @@ static void printf_gdi_info(int core_idx, int num, int reset)
 		}
 	}
 }
-#if 0
-void vdi_print_vpu_status(unsigned long coreIdx)
-{
-    vdi_info_t * vdi = lock_vdi_info(coreIdx);
-    if (vdi == NULL)
-        return;
-    Internal_vdi_print_vpu_status(coreIdx);
-    unlock_vdi_info(vdi, coreIdx);
-    return;
-}
-
-static void Internal_vdi_print_vpu_status(unsigned long coreIdx)
-{
-    unsigned int product_code;
-
-    product_code = Internal_vdi_read_register(coreIdx, VPU_PRODUCT_CODE_REGISTER);
 
-    if (PRODUCT_CODE_NOT_W_SERIES(product_code)) {
-    }
-    else {
-        VLOG(ERR, "Unknown product id : %08x\n", product_code);
-    }
-}
-#endif
 static void vdi_make_log(unsigned long core_idx, const char *str, int step)
 {
 	int val = 0x0;
 	(void)core_idx;
 
-	//val = Internal_vdi_read_register(core_idx, W4_INST_INDEX);
 	val &= 0xffff;
 	if (step == 1)
 		VLOG(TRACE, "\n**%s start(%d)\n", str, val);
@@ -2926,11 +2518,9 @@ void vdi_log(unsigned long core_idx, int cmd, int step)
 			     Internal_vdi_read_register(core_idx, i + 8),
 			     Internal_vdi_read_register(core_idx, i + 0xc));
 		}
-		//usleep(10000);
 	}
 
 	if (PRODUCT_CODE_NOT_W_SERIES(vdi->product_code)) {
-		//if ((cmd == PIC_RUN && step== 0) || cmd == VPU_RESET)
 		if (cmd == VPU_RESET) {
 			printf_gdi_info(core_idx, 32, 0);
 
@@ -3232,7 +2822,6 @@ static void Internal_vdi_set_rtk_clk_gating(Uint32 coreIdx, BOOL clk_en)
 #endif
 
 	rtd16xxb_vdi_ioctl_set_rtk_clk_gating(&clockInfo);
-	//ioctl(vdi->vpu_fd, VDI_IOCTL_SET_RTK_CLK_GATING, &clockInfo);
 }
 
 unsigned int vdi_get_rtk_clk_rate(Uint32 coreIdx)
@@ -3243,7 +2832,6 @@ unsigned int vdi_get_rtk_clk_rate(Uint32 coreIdx)
 	clockInfo.core_idx = coreIdx;
 	clockInfo.value = 0;
 
-	//ioctl(vdi->vpu_fd, VDI_IOCTL_GET_RTK_CLK_PLL, &clockInfo);
 	VLOG(TRACE, "[VDI]  %s, %d... coreIdx:%d, clk_rate:%d\n", __FUNCTION__,
 	     __LINE__, coreIdx, clockInfo.value);
 	unlock_vdi_info(vdi, coreIdx);
@@ -3273,122 +2861,15 @@ typedef enum {
 
 unsigned int vdi_get_support_vtype(Uint32 coreIdx)
 {
-	//unsigned int bonding_value = 0;
 	unsigned int support_vtype =
 		(1 << STD_AVC) | (1 << STD_VC1) | (1 << STD_MPEG2) |
 		(1 << STD_MPEG4) | (1 << STD_H263) | (1 << STD_AVS) |
 		(1 << STD_THO) | (1 << STD_VP8) | (1 << STD_HEVC) |
 		(1 << STD_VP9) | (1 << STD_AVS2);
-	//unsigned int bonding_value_from_rpc = 0;
 
 	return support_vtype;
-#if 0
-    vdi_info_t *vdi = lock_vdi_info(coreIdx);
-
-    if (vdi == NULL)
-        return support_vtype;
-
-#ifdef CONFIG_RTK_RPC
-    //RPC checking bonding
-#if defined(ANDROID)
-    initRPCProxy();
-#else
-    struct REG_STRUCT *rnode = NULL;
-    rnode = (struct REG_STRUCT *)AUDIO_AGENT_0_register(rnode);
-    rnode = (struct REG_STRUCT *)ReplyHandler_register(rnode);
-    initRPCProxy(rnode);
-#endif
-    CLNT_STRUCT clnt = prepareCLNT(BLOCK_MODE | USE_INTR_BUF | SEND_AUDIO_CPU, AUDIO_SYSTEM, VERSION);
-    AUDIO_RPC_PRIVATEINFO_PARAMETERS mInfo;
-    AUDIO_RPC_PRIVATEINFO_RETURNVAL* retvalue = NULL;
-    mInfo.type = ENUM_PRIVATEINFO_GET_B_VALUE;
-    mInfo.instanceID = 0;
-    uint8_t key1[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
-    uint8_t key2[16];
-    int i;
-    srand((uint32_t)time(NULL));
-    for(i=0; i<16; i++)
-        key2[i] = rand()%0xFF;
-    uint8_t key2_enc[16];
-    //uint8_t key2_enc_from_rpc[16];
-    //uint8_t b_value_enc_from_rpc[16];
-    uint8_t b_value_enc_from_rpc_from_key1[16];
-    uint8_t b_value_enc_from_rpc_from_key2[16];
-    uint8_t b_value_decrypt_key1[16];
-    uint8_t b_value_decrypt_key2[16];
-    unsigned int bonding_value_from_rpc_key1 = 0;
-    unsigned int bonding_value_from_rpc_key2 = 0;
-
-    AES128_ECB_encrypt(key2, key1, key2_enc);
-    uint8_2_uint32(key2_enc, mInfo.privateInfo);
-    retvalue = AUDIO_RPC_ToAgent_PrivateInfo_0(&mInfo, &clnt);
-    if(retvalue == NULL)
-        goto end;
-
-    uint32_2_uint8(b_value_enc_from_rpc_from_key1, &retvalue->privateInfo[0]);
-    uint32_2_uint8(b_value_enc_from_rpc_from_key2, &retvalue->privateInfo[4]);
-    free(retvalue);
-
-    AES128_ECB_decrypt(b_value_enc_from_rpc_from_key1, key1, b_value_decrypt_key1);
-    AES128_ECB_decrypt(b_value_enc_from_rpc_from_key2, key2, b_value_decrypt_key2);
-    bonding_value_from_rpc_key1 = (b_value_decrypt_key1[1] << 8) | b_value_decrypt_key1[0];
-    bonding_value_from_rpc_key2 = (b_value_decrypt_key2[1] << 8) | b_value_decrypt_key2[0];
-
-    DeInitRPCProxy();
-    if(bonding_value_from_rpc_key1 == bonding_value_from_rpc_key2)
-#endif
-    {
-        bonding_value = (bonding_value_from_rpc_key1 & 0xff);
-        if ((bonding_value & ENABLE_RM) == 0)
-            support_vtype |= (1<<STD_RV);
-        if ((bonding_value & ENABLE_DOLBY_VISION) == 0)
-            support_vtype |= (1 << STD_DOLBY_VISION);
-    }
-#ifdef CONFIG_RTK_RPC
-    else
-        VLOG(ERR, "[VDI] Fail to get support video type");
-#endif
-
-end:
-    unlock_vdi_info(vdi, coreIdx);
-    return support_vtype;
-#endif // #if 0
-}
-
-#if 0
-static void* Internal_vdi_map_registers(int dev, unsigned long base, unsigned int reg_size)
-{
-    const int page_size = getpagesize();
-    const int page_alignment = page_size - 1;
-
-    size_t map_size;
-    const char *io = MAP_FAILED;
-
-    /* increase mapping size with unaligned part */
-    map_size = reg_size + (base & page_alignment);
-
-    /* map page aligned base */
-    io = (char *)mmap64(0, map_size, PROT_READ | PROT_WRITE, MAP_SHARED, dev, base & ~page_alignment);
-
-    /* add offset from alignment to the io start address */
-    if (io != MAP_FAILED) io += (base & page_alignment);
-
-    return (void *)io;
 }
 
-static
-void Internal_vdi_unmap_registers(const void *io, unsigned int reg_size)
-{
-    const int page_size = getpagesize();
-    const int page_alignment = page_size - 1;
-#if defined(__LP64__)
-    munmap((void *)((unsigned long)io & (~page_alignment)), reg_size + ((unsigned long)io & page_alignment));
-#else
-    munmap((void *)((int)io & (~page_alignment)), reg_size + ((int)io & page_alignment));
-#endif
-}
-#endif
-
 int vdi_set_ve_prot_mode(Uint32 core_idx, BOOL enable)
 {
 	vdi_info_t *vdi;
@@ -3404,11 +2885,9 @@ int vdi_set_ve_prot_mode(Uint32 core_idx, BOOL enable)
 		    0) // if BIT processor is not running.
 		{
 			if (enable == TRUE) {
-				//VLOG(TRACE, "[%d]%s.enable pm mode\n",__LINE__,__func__);
 				Internal_vdi_write_register(core_idx,
 							    VE1_PROT_CTRL, 0x5);
 			} else {
-				//VLOG(TRACE, "[%d]%s.disable pm mode\n",__LINE__,__func__);
 				Internal_vdi_write_register(core_idx,
 							    VE1_PROT_CTRL, 0x2);
 			}
@@ -3445,8 +2924,6 @@ unsigned int vdi_set_dovi_flag(unsigned long core_idx, unsigned long inst_idx,
 	dovi_flag.inst_idx = inst_idx;
 	dovi_flag.enable = enable;
 
-	//ioctl(vdi->vpu_fd, VDI_IOCTL_SET_RTK_DOVI_FLAG, &dovi_flag);
-
 	unlock_vdi_info(vdi, core_idx);
 	return dovi_flag.enable;
 }
@@ -3475,8 +2952,6 @@ static int Internal_vdi_get_total_instance_num(unsigned long core_idx)
 	if (!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
 		return -1;
 
-	//ioctl(vdi->vpu_fd, VDI_IOCTL_GET_TOTAL_INSTANCE_NUM, &inst_info);
-
 	return inst_info.inst_open_count;
 }
 
@@ -3501,7 +2976,6 @@ static void Internal_vdi_set_thumb_num(unsigned long core_idx,
 	vdi = &s_vdi_info[core_idx];
 
 	mutex_lock(vdi->vpu_thumb_mutex);
-	//pthread_mutex_lock(vdi->vpu_thumb_mutex);
 	if (enable) {
 		*vdi->thumb_num = *vdi->thumb_num + 1;
 		;
@@ -3510,7 +2984,6 @@ static void Internal_vdi_set_thumb_num(unsigned long core_idx,
 			*vdi->thumb_num = *vdi->thumb_num - 1;
 	}
 	mutex_unlock(vdi->vpu_thumb_mutex);
-	//pthread_mutex_unlock(vdi->vpu_thumb_mutex);
 }
 
 unsigned int vdi_get_thumb_num(unsigned long core_idx)
@@ -3535,10 +3008,8 @@ static unsigned int Internal_vdi_get_thumb_num(unsigned long core_idx)
 	vdi = &s_vdi_info[core_idx];
 
 	mutex_lock(vdi->vpu_thumb_mutex);
-	//pthread_mutex_lock(vdi->vpu_thumb_mutex);
 	ret = *vdi->thumb_num;
 	mutex_unlock(vdi->vpu_thumb_mutex);
-	//pthread_mutex_unlock(vdi->vpu_thumb_mutex);
 
 	return ret;
 }
@@ -3566,7 +3037,6 @@ static unsigned int Internal_vdi_set_thumb_used(unsigned long core_idx,
 	vdi = &s_vdi_info[core_idx];
 
 	mutex_lock(vdi->vpu_thumb_mutex);
-	//pthread_mutex_lock(vdi->vpu_thumb_mutex);
 	if (enable) {
 		if (*vdi->thumb_used == 0) {
 			*vdi->thumb_used = 1;
@@ -3576,152 +3046,7 @@ static unsigned int Internal_vdi_set_thumb_used(unsigned long core_idx,
 		*vdi->thumb_used = 0;
 	}
 	mutex_unlock(vdi->vpu_thumb_mutex);
-	//pthread_mutex_unlock(vdi->vpu_thumb_mutex);
 
 	return ret;
 }
 
-#if 0
-/*
-  type: 0 is dc_sys, 1 is dmc
-*/
-void vdi_write_dcsys_register(unsigned long core_idx, unsigned int addr, unsigned int data, unsigned int type)
-{
-    vdi_info_t *vdi;
-    unsigned long *reg_addr;
-
-    if (core_idx >= MAX_NUM_VPU_CORE)
-        return;
-
-    vdi = lock_vdi_info(core_idx);
-
-    if(!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
-        goto ERR_VDI_DC;
-
-    switch(type)
-    {
-        case 0:
-        {
-            if (vdi->dcsys_register.phys_addr == 0x0)
-            {
-                vdi->dcsys_register.mem_type = 0;
-                if (ioctl(vdi->vpu_fd, VDI_IOCTL_GET_RTK_DCSYS_INFO, &vdi->dcsys_register) < 0)
-                {
-                    VLOG(ERR, "[VDI] fail to get dcsys register\n");
-                    goto ERR_VDI_DC;
-                }
-                vdi->dcsys_register.virt_addr = (unsigned long)Internal_vdi_map_registers(vdi->vpu_fd, vdi->dcsys_register.phys_addr, vdi->dcsys_register.size);
-                if ((void *)vdi->dcsys_register.virt_addr == MAP_FAILED)
-                {
-                    VLOG(ERR, "[VDI] fail to map dcsys registers \n");
-                    goto ERR_VDI_DC;
-                }
-            }
-            reg_addr = (unsigned long *)(addr + (unsigned long)vdi->dcsys_register.virt_addr);
-            *(volatile unsigned int *)reg_addr = data;
-            break;
-        }
-        case 1:
-        {
-            if (vdi->dmcsys_register.phys_addr == 0x0)
-            {
-                vdi->dmcsys_register.mem_type = 1;
-                if (ioctl(vdi->vpu_fd, VDI_IOCTL_GET_RTK_DCSYS_INFO, &vdi->dmcsys_register) < 0)
-                {
-                    VLOG(ERR, "[VDI] fail to get dcsys register\n");
-                    goto ERR_VDI_DC;
-                }
-                vdi->dmcsys_register.virt_addr = (unsigned long)Internal_vdi_map_registers(vdi->vpu_fd, vdi->dmcsys_register.phys_addr, vdi->dmcsys_register.size);
-                if ((void *)vdi->dmcsys_register.virt_addr == MAP_FAILED)
-                {
-                    VLOG(ERR, "[VDI] fail to map dcsys registers \n");
-                    goto ERR_VDI_DC;
-                }
-                VLOG(1, "In[%s][%d] phy:0x%x, size:%d, virt:0x%x\n", __func__, __LINE__, vdi->dmcsys_register.phys_addr, vdi->dmcsys_register.size, vdi->dmcsys_register.virt_addr);
-            }
-            reg_addr = (unsigned long *)(addr + (unsigned long)vdi->dmcsys_register.virt_addr);
-            *(volatile unsigned int *)reg_addr = data;
-            break;
-        }
-        default:
-            VLOG(ERR, "[VDI] not support type:%d\n", type);
-            break;
-    }
-
-ERR_VDI_DC:
-    unlock_vdi_info(vdi, core_idx);
-    return;
-}
-
-int vdi_read_dcsys_register(unsigned long core_idx, unsigned int addr, unsigned int type)
-{
-    vdi_info_t *vdi;
-    unsigned long *reg_addr = NULL;
-
-    if (core_idx >= MAX_NUM_VPU_CORE)
-        return (unsigned int)-1;
-
-    vdi = lock_vdi_info(core_idx);
-
-    if(!vdi || vdi->vpu_fd == -1 || vdi->vpu_fd == 0x00)
-        goto ERR_VDI_DC;
-
-    switch(type)
-    {
-        case 0:
-        {
-            if (vdi->dcsys_register.phys_addr == 0x0)
-            {
-                vdi->dcsys_register.mem_type = 0;
-                if (ioctl(vdi->vpu_fd, VDI_IOCTL_GET_RTK_DCSYS_INFO, &vdi->dcsys_register) < 0)
-                {
-                    VLOG(ERR, "[VDI] fail to get dcsys register\n");
-                    goto ERR_VDI_DC;
-                }
-                vdi->dcsys_register.virt_addr = (unsigned long)Internal_vdi_map_registers(vdi->vpu_fd, vdi->dcsys_register.phys_addr, vdi->dcsys_register.size);
-                if ((void *)vdi->dcsys_register.virt_addr == MAP_FAILED)
-                {
-                    VLOG(ERR, "[VDI] fail to map dcsys registers \n");
-                    goto ERR_VDI_DC;
-                }
-            }
-
-            reg_addr = (unsigned long *)(addr + (unsigned long)vdi->dcsys_register.virt_addr);
-            break;
-        }
-        case 1:
-        {
-            if (vdi->dmcsys_register.phys_addr == 0x0)
-            {
-                vdi->dmcsys_register.mem_type = 1;
-                if (ioctl(vdi->vpu_fd, VDI_IOCTL_GET_RTK_DCSYS_INFO, &vdi->dmcsys_register) < 0)
-                {
-                    VLOG(ERR, "[VDI] fail to get dcsys register\n");
-                    goto ERR_VDI_DC;
-                }
-                vdi->dmcsys_register.virt_addr = (unsigned long)Internal_vdi_map_registers(vdi->vpu_fd, vdi->dmcsys_register.phys_addr, vdi->dmcsys_register.size);
-                if ((void *)vdi->dmcsys_register.virt_addr == MAP_FAILED)
-                {
-                    VLOG(ERR, "[VDI] fail to map dcsys registers \n");
-                    goto ERR_VDI_DC;
-                }
-                VLOG(1, "In[%s][%d] phy:0x%x, size:%d, virt:0x%x\n", __func__, __LINE__, vdi->dmcsys_register.phys_addr, vdi->dmcsys_register.size, vdi->dmcsys_register.virt_addr);
-            }
-
-            reg_addr = (unsigned long *)(addr + (unsigned long)vdi->dmcsys_register.virt_addr);
-            break;
-        }
-        default:
-            VLOG(ERR, "[VDI] not support type:%d\n", type);
-            break;
-    }
-
-    unlock_vdi_info(vdi, core_idx);
-    return *(volatile unsigned int *)reg_addr;
-
-ERR_VDI_DC:
-    unlock_vdi_info(vdi, core_idx);
-    return -1;
-}
-#endif // #if 0
-//#endif	//#if defined(linux) || defined(__linux) || defined(ANDROID)
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vdi_osal.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vdi_osal.c
index 812b2ab7f0c7..71b88c562207 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vdi_osal.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vdi_osal.c
@@ -3,40 +3,13 @@
 //
 // Copyright (c) 2006, Chips & Media.  All rights reserved.
 //------------------------------------------------------------------------------
-/*
-#ifdef ANDROID
-#include <utils/Log.h>
-#undef LOG_NDEBUG
-#define LOG_NDEBUG 0
-#undef LOG_TAG
-#define LOG_TAG "VPUAPI"
-#else
-#define VLOG_TAG "VPUAPI"
-#endif
-*/
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/vmalloc.h>
 #include <linux/string.h>
 
-//#if defined(linux) || defined(__linux) || defined(ANDROID)
-
 #include "ve1config.h"
-//#include <stdio.h>
-//#include <stdlib.h>
-//#include <string.h>
-//#include <stdarg.h>
 #include "ve1_vdi_osal.h"
-/*
-#include <time.h>
-#include <sys/time.h>
-#include <termios.h>
-#ifndef USE_KERNEL_MODE
-#include <unistd.h>   // for read()
-#endif
-static struct termios initial_settings, new_settings;
-static int peek_character = -1;
-*/
 static int log_colors[MAX_LOG_LEVEL] = {
 	0,
 	TERM_COLOR_R | TERM_COLOR_G | TERM_COLOR_B | TERM_COLOR_BRIGHT, //INFO
@@ -48,7 +21,6 @@ static int log_colors[MAX_LOG_LEVEL] = {
 static unsigned log_decor = LOG_HAS_TIME | LOG_HAS_FILE | LOG_HAS_MICRO_SEC |
 			    LOG_HAS_NEWLINE | LOG_HAS_SPACE | LOG_HAS_COLOR;
 static int max_log_level = MAX_LOG_LEVEL;
-//static FILE *fpLog  = NULL;
 
 static void term_restore_color(void);
 static void term_set_color(int color);
@@ -57,7 +29,6 @@ static pthread_mutex_t s_log_mutex;
 #endif
 int InitLog(void)
 {
-	//fpLog = osal_fopen("ErrorLog.txt", "w");
 #ifdef SUPPORT_SW_UART
 	pthread_mutex_init(&s_log_mutex, NULL);
 #endif
@@ -66,13 +37,6 @@ int InitLog(void)
 
 void DeInitLog(void)
 {
-/*
-    if (fpLog)
-    {
-        osal_fclose(fpLog);
-        fpLog = NULL;
-    }
-*/
 #ifdef SUPPORT_SW_UART
 	pthread_mutex_destroy(&s_log_mutex);
 #endif
@@ -135,26 +99,16 @@ void LogMsg(int level, const char *format, ...)
 #ifdef ANDROID
 	if (level == ERR) {
 		pr_err("%s %s", VLOG_TAG, logBuf);
-		//ALOGE("%s", logBuf);
 	} else if (level == INFO) {
 		pr_info("%s %s", VLOG_TAG, logBuf);
 	} else {
 		pr_debug("%s %s", VLOG_TAG, logBuf);
-		//ALOGI("%s", logBuf);
 	}
-	//fputs(logBuf, stderr);
 #else
 	snprintf(logBuf_tag, MAX_PRINT_LENGTH, "%s %s", VLOG_TAG, logBuf);
-	//fputs(logBuf, stderr);
 	fputs(logBuf_tag, stdout);
 #endif
-	/*
-    if ((log_decor & LOG_HAS_FILE) && fpLog)
-    {
-        osal_fwrite(logBuf, strlen(logBuf), 1,fpLog);
-        osal_fflush(fpLog);
-    }
-*/
+
 	if (log_decor & LOG_HAS_COLOR)
 		term_restore_color();
 #ifdef SUPPORT_SW_UART
@@ -213,121 +167,13 @@ static void term_set_color(int color)
 		break;
 	}
 
-	//fputs(ansi_color, stdout);
 }
 
 static void term_restore_color(void)
 {
 	term_set_color(log_colors[4]);
 }
-/*
-static double timer_frequency_;
-
-struct timeval tv_start;
-struct timeval tv_end;
-
-void timer_init()
-{
-
-}
-
-void timer_start()
-{
-    timer_init();
-}
-
-void timer_stop()
-{
-    gettimeofday(&tv_end, NULL);
-}
-
-double timer_elapsed_ms()
-{
-    double ms;
-    ms = timer_elapsed_us()/1000.0;
-    return ms;
-}
-
-double timer_elapsed_us()
-{
-    double elapsed = 0;
-    double start_us = 0;
-    double end_us = 0;
-    end_us = tv_end.tv_sec*1000*1000 + tv_end.tv_usec;
-    start_us = tv_start.tv_sec*1000*1000 + tv_start.tv_usec;
-    elapsed =  end_us - start_us;
-    return elapsed;
-
-}
-
-int timer_is_valid()
-{
-    return timer_frequency_ != 0;
-}
-
-double timer_frequency()
-{
-    return timer_frequency_;
-}
-
-void osal_init_keyboard()
-{
-    tcgetattr(0,&initial_settings);
-    new_settings = initial_settings;
-    new_settings.c_lflag &= ~ICANON;
-    new_settings.c_lflag &= ~ECHO;
-    //new_settings.c_lflag &= ~ISIG;
-    new_settings.c_cc[VMIN] = 1;
-    new_settings.c_cc[VTIME] = 0;
-    tcsetattr(0, TCSANOW, &new_settings);
-    peek_character = -1;
-}
-
-void osal_close_keyboard()
-{
-    tcsetattr(0, TCSANOW, &initial_settings);
-}
-
-int osal_kbhit()
-{
-    unsigned char ch;
-    int nread;
-
-    if (peek_character != -1) return 1;
-    new_settings.c_cc[VMIN]=0;
-    tcsetattr(0, TCSANOW, &new_settings);
-    nread = read(0,&ch,1);
-    new_settings.c_cc[VMIN]=1;
-    tcsetattr(0, TCSANOW, &new_settings);
-    if(nread == 1)
-    {
-        peek_character = (int)ch;
-        return 1;
-    }
-    return 0;
-}
 
-int osal_getch()
-{
-    int val;
-    char ch;
-
-    if(peek_character != -1)
-    {
-        val = peek_character;
-        peek_character = -1;
-        return val;
-    }
-    read(0,&ch,1);
-    return ch;
-}
-
-int osal_flush_ch(void)
-{
-    fflush(stdout);
-    return 1;
-}
-*/
 #define VE1_ALIGN(value, base) (((value) + ((base)-1)) & ~((base)-1))
 #define DEVICE_ALIGN (0x8) /* for non-cacheable memory */
 void *osal_memcpy(void *dst, const void *src, int count)
@@ -405,80 +251,11 @@ void *osal_malloc(int size)
 	return vmalloc(size);
 }
 
-//void * osal_realloc(void* ptr, int size)
-//{
-//    return realloc(ptr, size);
-//}
-
 void osal_free(void *p)
 {
 	vfree(p);
 }
-/*
-int osal_fflush(osal_file_t fp)
-{
-    return fflush(fp);
-}
-
-int osal_feof(osal_file_t fp)
-{
-    return feof((FILE *)fp);
-}
-
-osal_file_t osal_fopen(const char * osal_file_tname, const char * mode)
-{
-    return fopen(osal_file_tname, mode);
-}
-size_t osal_fwrite(const void * p, int size, int count, osal_file_t fp)
-{
-    return fwrite(p, size, count, fp);
-}
-size_t osal_fread(void *p, int size, int count, osal_file_t fp)
-{
-    return fread(p, size, count, fp);
-}
-long osal_ftell(osal_file_t fp)
-{
-    return ftell(fp);
-}
-
-int osal_fseek(osal_file_t fp, long offset, int origin)
-{
-    return fseek(fp, offset, origin);
-}
-int osal_fclose(osal_file_t fp)
-{
-    return fclose(fp);
-}
-
-int osal_fscanf(osal_file_t fp, const char * _Format, ...)
-{
-    int ret;
-    extern int vfscanf(FILE*, const char*, va_list);
-
-    va_list arglist;
-    va_start(arglist, _Format);
 
-    ret = vfscanf(fp, _Format, arglist);
-
-    va_end(arglist);
-
-    return ret;
-}
-
-int osal_fprintf(osal_file_t fp, const char * _Format, ...)
-{
-    int ret;
-    va_list arglist;
-    va_start(arglist, _Format);
-
-    ret = vfprintf(fp, _Format, arglist);
-
-    va_end(arglist);
-
-    return ret;
-}
-*/
 //------------------------------------------------------------------------------
 // math related api
 //------------------------------------------------------------------------------
@@ -531,4 +308,3 @@ int math_div(int number, int denom)
 	return (c & 0xFFFF);
 }
 
-//#endif	//#if defined(linux) || defined(__linux) || defined(ANDROID)
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vdi_osal.h b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vdi_osal.h
index 3157d1c32460..2f7f2b5f4150 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vdi_osal.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vdi_osal.h
@@ -7,10 +7,6 @@
 #ifndef _VDI_OSAL_H_
 #define _VDI_OSAL_H_
 
-//#include <stdio.h>
-//#include <stdlib.h>
-//#include <ctype.h>
-
 enum { NONE = 0, ERR, WARN, INFO, TRACE, MAX_LOG_LEVEL };
 enum { LOG_HAS_DAY_NAME = 1, /**< Include day name [default: no] 	      */
        LOG_HAS_YEAR = 2, /**< Include year digit [no]		      */
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpu.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpu.c
index 7de09b99b7de..c569e1fdae77 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpu.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpu.c
@@ -27,12 +27,6 @@ struct timeval start_dec_tv;
 struct timeval start_enc_tv;
 struct timeval end_tv;
 #endif
-/*
-#ifdef ENABLE_TEE_DRM_FLOW
-#include "tee_client_api.h"
-#include "tee_api.h"
-#endif
-*/
 #ifndef __maybe_unused
 #define __maybe_unused __attribute__((unused))
 #endif
@@ -85,9 +79,7 @@ static void Coda9VpuDecSetCommonAddress(CodecInst *instance)
 
 	tempBuffer = vb.phys_addr + CODE_BUF_SIZE;
 	paraBuffer = tempBuffer + TEMP_BUF_SIZE;
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg BIT_PARA_BUF_ADDR.paraBuffer:0x%08x(tempBuffer:0x%08x + TEMP_BUF_SIZE:%d)\n",__LINE__,__func__,paraBuffer,tempBuffer,TEMP_BUF_SIZE);
 	VpuWriteReg(pCodecInst->coreIdx, BIT_PARA_BUF_ADDR, paraBuffer);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg BIT_TEMP_BUF_ADDR.tempBuffer:0x%08x(common_memory:0x%08x + CODE_BUF_SIZE:%d)\n",__LINE__,__func__,tempBuffer,vb.phys_addr,CODE_BUF_SIZE);
 	VpuWriteReg(pCodecInst->coreIdx, BIT_TEMP_BUF_ADDR, tempBuffer);
 }
 
@@ -97,7 +89,6 @@ static void LoadBitCode(Uint32 coreIdx, PhysicalAddress codeBase,
 static void Coda9VpuWriteMem(unsigned long core_idx, unsigned int addr,
 			     unsigned char *data, int len, int endian,
 			     void *teeapi_ctx, unsigned int teeapi_tee_session)
-//static void Coda9VpuWriteMem(unsigned long core_idx, unsigned int addr, unsigned char *data, int len, int endian, TEEC_Session sess, RTK_TEEC_Session rtk_sess)
 {
 	int ret;
 	unsigned char *tmpData = NULL;
@@ -115,46 +106,10 @@ static void Coda9VpuWriteMem(unsigned long core_idx, unsigned int addr,
 		VLOG(ERR, "[%d]%s.ta_TEEapi_memcpy_a7() fail.ret:%d\n",
 		     __LINE__, __func__, ret);
 	}
-	//TEE_API_va_memcpy(&sess, &rtk_sess, addr, (void *)tmpData, len);
 
 	osal_free(tmpData);
 }
 
-#if 0
-static RetCode LoadBitCodeProtect(Uint32 coreIdx, PhysicalAddress codeBase, const Uint16 *codeWord, int codeSize, void *sess, void *rtk_sess)
-{
-    int i;
-    BYTE code[8];
-    unsigned char *tmpData = NULL;
-
-    tmpData = (unsigned char *)malloc(CODE_BUF_SIZE);
-    if (tmpData == NULL)
-    {
-        VLOG(ERR, "In[%s][%d] malloc failed\n", __func__, __LINE__);
-        return RETCODE_FAILURE;
-    }
-
-    for (i=0; i<codeSize; i+=4) {
-        // 2byte little endian variable to 1byte big endian buffer
-        code[0] = (BYTE)(codeWord[i+0]>>8);
-        code[1] = (BYTE)codeWord[i+0];
-        code[2] = (BYTE)(codeWord[i+1]>>8);
-        code[3] = (BYTE)codeWord[i+1];
-        code[4] = (BYTE)(codeWord[i+2]>>8);
-        code[5] = (BYTE)codeWord[i+2];
-        code[6] = (BYTE)(codeWord[i+3]>>8);
-        code[7] = (BYTE)codeWord[i+3];
-        vdi_write_memory_va(coreIdx, tmpData+i*2, (BYTE *)code, 8, VDI_BIG_ENDIAN);
-    }
-
-    TEE_API_va_memcpy(sess, rtk_sess, codeBase, (void *)tmpData, CODE_BUF_SIZE);
-    vdi_set_bit_firmware_to_pm(coreIdx, codeWord);
-
-    free(tmpData);
-    return RETCODE_SUCCESS;
-}
-#endif
-
 RetCode Coda9VpuInitProtect(Uint32 coreIdx, void *firmware, Uint32 size,
 			    void *sess, void *rtk_sess, void *filp)
 {
@@ -179,7 +134,6 @@ RetCode Coda9VpuInitProtect(Uint32 coreIdx, void *firmware, Uint32 size,
 	{
 		int i;
 		const Uint16 *codeWord = (const Uint16 *)firmware;
-		//LoadBitCodeProtect(coreIdx, codeBuffer, codeWord, size, sess, rtk_sess);
 		vdi_get_common_memory((unsigned long)coreIdx, &vb);
 		codeBuffer = vb.phys_addr;
 		LoadBitCode(coreIdx, codeBuffer, codeWord, size);
@@ -206,11 +160,8 @@ RetCode Coda9VpuInitProtect(Uint32 coreIdx, void *firmware, Uint32 size,
 		}
 	}
 
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg BIT_PARA_BUF_ADDR.paraBuffer:0x%08x(tempBuffer:0x%08x + TEMP_BUF_SIZE:%d)\n",__LINE__,__func__,paraBuffer,tempBuffer,TEMP_BUF_SIZE);
 	VpuWriteReg(coreIdx, BIT_PARA_BUF_ADDR, paraBuffer);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg BIT_CODE_BUF_ADDR.codeBuffer:0x%08x(common_memory:0x%08x)\n",__LINE__,__func__,codeBuffer,vb.phys_addr);
 	VpuWriteReg(coreIdx, BIT_CODE_BUF_ADDR, codeBuffer);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg BIT_TEMP_BUF_ADDR.tempBuffer:0x%08x(common_memory:0x%08x + CODE_BUF_SIZE:%d)\n",__LINE__,__func__,tempBuffer,codeBufferProt,CODE_BUF_SIZE);
 	VpuWriteReg(coreIdx, BIT_TEMP_BUF_ADDR, tempBuffer);
 
 	VpuWriteReg(coreIdx, BIT_BIT_STREAM_CTRL, VPU_STREAM_ENDIAN);
@@ -251,7 +202,6 @@ static void LoadBitCode(Uint32 coreIdx, PhysicalAddress codeBase,
 	int i;
 	BYTE code[8];
 
-	//VLOG(TRACE, "[%d]%s.VpuWriteMem codeBase:0x%08x\n",__LINE__,__func__,codeBase);
 	for (i = 0; i < codeSize; i += 4) {
 		// 2byte little endian variable to 1byte big endian buffer
 		code[0] = (BYTE)(codeWord[i + 0] >> 8);
@@ -346,14 +296,12 @@ void Coda9BitIssueCommand(Uint32 coreIdx, CodecInst *inst, int cmd)
 
 	if (inst) {
 		if (inst->codecMode < AVC_ENC) {
-			//VLOG(TRACE, "[%d]%s.cmd:%d.VpuWriteReg BIT_WORK_BUF_ADDR.vbWork:0x%08x\n",__LINE__,__func__,cmd,inst->CodecInfo->decInfo.vbWork.phys_addr);
 			VpuWriteReg(coreIdx, BIT_WORK_BUF_ADDR,
 				    inst->CodecInfo->decInfo.vbWork.phys_addr);
 #ifdef ENABLE_CODA9_WRITE_PROTECT
 			SetDecWriteProtectRegions(inst);
 #endif
 		} else {
-			//VLOG(TRACE, "[%d]%s.cmd:%d.VpuWriteReg BIT_WORK_BUF_ADDR.vbWork:0x%08x\n",__LINE__,__func__,cmd,inst->CodecInfo->encInfo.vbWork.phys_addr);
 			VpuWriteReg(coreIdx, BIT_WORK_BUF_ADDR,
 				    inst->CodecInfo->encInfo.vbWork.phys_addr);
 		}
@@ -396,7 +344,6 @@ static void SetupCoda9Properties(Uint32 coreIdx, Uint32 productId)
 		(1 << STD_RV) | (1 << STD_THO) | (1 << STD_VP8);
 
 	support_vtype = vdi_get_support_vtype(coreIdx);
-	//if (support_vtype != (Uint32)-1 && support_vtype != 0)
 	pAttr->supportDecoders = (pAttr->supportDecoders & support_vtype);
 	VLOG(TRACE,
 	     "\033[0;31mpAttr->supportDecoders : 0x%08x, support_vtype : 0x%08x\033[m\n",
@@ -505,11 +452,8 @@ RetCode Coda9VpuInit(Uint32 coreIdx, void *firmware, Uint32 size)
 
 	BitLoadFirmware(coreIdx, codeBuffer, (const Uint16 *)firmware, size);
 
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg BIT_PARA_BUF_ADDR.paraBuffer:0x%08x(tempBuffer:0x%08x + TEMP_BUF_SIZE:%d)\n",__LINE__,__func__,paraBuffer,tempBuffer,TEMP_BUF_SIZE);
 	VpuWriteReg(coreIdx, BIT_PARA_BUF_ADDR, paraBuffer);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg BIT_CODE_BUF_ADDR.codeBuffer:0x%08x(common_memory:0x%08x)\n",__LINE__,__func__,codeBuffer,vb.phys_addr);
 	VpuWriteReg(coreIdx, BIT_CODE_BUF_ADDR, codeBuffer);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg BIT_TEMP_BUF_ADDR.tempBuffer:0x%08x(common_memory:0x%08x + CODE_BUF_SIZE:%d)\n",__LINE__,__func__,tempBuffer,codeBuffer,CODE_BUF_SIZE);
 	VpuWriteReg(coreIdx, BIT_TEMP_BUF_ADDR, tempBuffer);
 
 	VpuWriteReg(coreIdx, BIT_BIT_STREAM_CTRL, VPU_STREAM_ENDIAN);
@@ -565,11 +509,8 @@ RetCode Coda9VpuReInit(Uint32 coreIdx, void *firmware, Uint32 size)
 
 	oldCodeBuffer = VpuReadReg(coreIdx, BIT_CODE_BUF_ADDR);
 
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg BIT_PARA_BUF_ADDR.paraBuffer:0x%08x(tempBuffer:0x%08x + TEMP_BUF_SIZE:%d)\n",__LINE__,__func__,paraBuffer,tempBuffer,TEMP_BUF_SIZE);
 	VpuWriteReg(coreIdx, BIT_PARA_BUF_ADDR, paraBuffer);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg BIT_CODE_BUF_ADDR.tempBuffer:0x%08x(common_memory:0x%08x)\n",__LINE__,__func__,codeBuffer,vb.phys_addr);
 	VpuWriteReg(coreIdx, BIT_CODE_BUF_ADDR, codeBuffer);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg BIT_TEMP_BUF_ADDR.tempBuffer:0x%08x(common_memory:0x%08x + CODE_BUF_SIZE:%d)\n",__LINE__,__func__,tempBuffer,codeBuffer,CODE_BUF_SIZE);
 	VpuWriteReg(coreIdx, BIT_TEMP_BUF_ADDR, tempBuffer);
 
 	if (oldCodeBuffer != codeBuffer) {
@@ -609,10 +550,6 @@ Int32 Coda9VpuWaitInterrupt(CodecInst *handle, int timeout)
 	VLOG(TRACE, "[%d]%s.h:0x%x.reason:0x%x\n", __LINE__, __func__, handle,
 	     reason);
 
-	//if (reason != (Int32)INTERRUPT_TIMEOUT_VALUE) {
-	//    VpuWriteReg(handle->coreIdx, BIT_INT_CLEAR, 1);		// clear HW signal
-	//}
-
 	if (reason == -1) {
 		handle->noInterruptCnt++;
 		VLOG(TRACE, "[%d]%s.h:0x%x.interrupt -1.cnt:%d\n", __LINE__,
@@ -664,17 +601,6 @@ Int32 Coda9VpuWaitInterrupt(CodecInst *handle, int timeout)
 				     value);
 				addr += 4;
 			}
-			/* VE3 must power on for read register 0x9804BE24 ~ 0x9804BE2C
-            VLOG(TRACE, "read register 0x9804BE24 ~ 0x9804BE2C\n");
-            addr = 0x9804BE24 - 0x98040000;
-            boundary = addr + (0xBE2C - 0xBE24);
-            while (addr <= boundary)
-            {
-                value = VpuReadReg(handle->coreIdx, addr);
-                VLOG(TRACE, "[0x%08x] = 0x%08x.\n",addr,value);
-                addr += 4;
-            }
-*/
 		}
 	} else {
 		handle->noInterruptCnt = 0;
@@ -962,13 +888,7 @@ RetCode Coda9VpuBuildUpDecParam(CodecInst *pCodec, DecOpenParam *param)
 		pDecInfo->dramCfg.rasBit = EM_RAS;
 		pDecInfo->dramCfg.busBit = EM_WIDTH;
 	}
-/*
-    if (param->enableDcsysDebug)
-    {
-        vdi_write_dcsys_register(pCodec->coreIdx, REG_DC_PC_SYSH_prog_ctrl, (ID_DC_GPU << 16)|(ID_DC_SCPU << 8)|ID_DC_VE1, TYPE_DCSYS);
-        vdi_write_dcsys_register(pCodec->coreIdx, REG_DC_PC_SYSH_prog_ctrl_2, ID_DC_VO1, TYPE_DCSYS);
-    }
-*/
+
 #ifdef ENABLE_CODA9_WRITE_PROTECT
 	for (i = 0; i < WPROT_DEC_MAX; i++)
 		pDecInfo->writeMemProtectCfg.decRegion[i].enable = 0;
@@ -998,11 +918,9 @@ RetCode Coda9VpuDecInitSeq(DecHandle handle)
 		val |= (pDecInfo->userDataEnable << 5);
 		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_SEQ_USER_DATA_OPTION,
 			    val);
-		//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_DEC_SEQ_USER_DATA_BASE_ADDR.userDataBufAddr:0x%08x\n",__LINE__,__func__,pDecInfo->userDataBufAddr);
 		VpuWriteReg(pCodecInst->coreIdx,
 			    CMD_DEC_SEQ_USER_DATA_BASE_ADDR,
 			    pDecInfo->userDataBufAddr);
-		//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_DEC_SEQ_USER_DATA_BUF_SIZE.userDataBufSize:%d\n",__LINE__,__func__,pDecInfo->userDataBufSize);
 		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_SEQ_USER_DATA_BUF_SIZE,
 			    pDecInfo->userDataBufSize);
 	} else {
@@ -1088,7 +1006,6 @@ RetCode Coda9VpuDecInitSeq(DecHandle handle)
 		return RETCODE_NOT_FOUND_VPU_DEVICE;
 	}
 
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg frameDisplayFlagRegAddr:0x%08x.val:0\n",__LINE__,__func__,pDecInfo->frameDisplayFlagRegAddr);
 	VpuWriteReg(pCodecInst->coreIdx, pDecInfo->frameDisplayFlagRegAddr, 0);
 	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst, DEC_SEQ_INIT);
 
@@ -1258,11 +1175,9 @@ RetCode Coda9VpuDecode(CodecInst *instance, DecParam *param)
 		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PIC_ROT_MODE, rotMir);
 	}
 	if (pDecInfo->userDataEnable) {
-		//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_DEC_PIC_USER_DATA_BASE_ADDR.userDataBufAddr:0x%08x\n",__LINE__,__func__,pDecInfo->userDataBufAddr);
 		VpuWriteReg(pCodecInst->coreIdx,
 			    CMD_DEC_PIC_USER_DATA_BASE_ADDR,
 			    pDecInfo->userDataBufAddr);
-		//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_DEC_PIC_USER_DATA_BUF_SIZE.userDataBufSize:%d\n",__LINE__,__func__,pDecInfo->userDataBufSize);
 		VpuWriteReg(pCodecInst->coreIdx, CMD_DEC_PIC_USER_DATA_BUF_SIZE,
 			    pDecInfo->userDataBufSize);
 	} else {
@@ -1332,7 +1247,6 @@ RetCode Coda9VpuDecode(CodecInst *instance, DecParam *param)
 	       (pDecInfo->secAxiInfo.u.coda9.useOvlEnable & 0x01) << 12 |
 	       (pDecInfo->secAxiInfo.u.coda9.useBtpEnable & 0x01) << 13);
 
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg BIT_AXI_SRAM_USE.val:0x%08x\n",__LINE__,__func__,val);
 	VpuWriteReg(pCodecInst->coreIdx, BIT_AXI_SRAM_USE, val);
 
 	VpuWriteReg(pCodecInst->coreIdx, pDecInfo->streamWrPtrRegAddr,
@@ -1382,17 +1296,7 @@ RetCode Coda9VpuDecode(CodecInst *instance, DecParam *param)
 
 	val = pDecInfo->openParam.streamEndian;
 	VpuWriteReg(pCodecInst->coreIdx, BIT_BIT_STREAM_CTRL, val);
-	/*
-    if (pCodecInst->enableDcsysDebug)
-    {
-        vdi_write_dcsys_register(pCodecInst->coreIdx, REG_DC_PC_CTRL, 1, TYPE_DCSYS);
-        vdi_write_dcsys_register(pCodecInst->coreIdx, REG_DMC_PC_GO_START, DMC_PC_CTRL, TYPE_DMC);
-        vdi_write_dcsys_register(pCodecInst->coreIdx, REG_DMC_PC_GO_CTRL, 2, TYPE_DMC);
-        vdi_write_dcsys_register(pCodecInst->coreIdx, REG_DMC_PC_GO_START, DMC_PC_CTRL, TYPE_DMC);
-        vdi_write_dcsys_register(pCodecInst->coreIdx, REG_DMC_PC_GO_CTRL, 1, TYPE_DMC);
-    }
-*/
-	//VLOG(INFO, "CMD_SET_FRAME_DELAY.frameDelay:%d",pDecInfo->frameDelay);
+
 	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_DELAY,
 		    pDecInfo->frameDelay); // SA5-1256
 
@@ -1412,26 +1316,7 @@ RetCode Coda9VpuDecGetResult(CodecInst *instance, DecOutputInfo *result)
 
 	pCodecInst = instance;
 	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-	/*
-    if (pCodecInst->enableDcsysDebug)
-    {
-        vdi_write_dcsys_register(pCodecInst->coreIdx, REG_DC_PC_CTRL, 0, TYPE_DCSYS);
-        result->dcsysInfo.dcsysVeAck        = vdi_read_dcsys_register(pCodecInst->coreIdx, REG_DC_PC_SYSH_prog_0_ACK_NUM, TYPE_DCSYS);
-        result->dcsysInfo.dcsysScpuAck      = vdi_read_dcsys_register(pCodecInst->coreIdx, REG_DC_PC_SYSH_prog_1_ACK_NUM, TYPE_DCSYS);
-        result->dcsysInfo.dcsysGpuAck       = vdi_read_dcsys_register(pCodecInst->coreIdx, REG_DC_PC_SYSH_prog_2_ACK_NUM, TYPE_DCSYS);
-        result->dcsysInfo.dcsysVoAck        = vdi_read_dcsys_register(pCodecInst->coreIdx, REG_DC_PC_SYSH_prog_3_ACK_NUM, TYPE_DCSYS);
-        result->dcsysInfo.dcsysTotalAck     = vdi_read_dcsys_register(pCodecInst->coreIdx, REG_DC_PC_TOTA_ACK_NUM_0, TYPE_DCSYS);
-        result->dcsysInfo.dcsysVeLatency    = vdi_read_dcsys_register(pCodecInst->coreIdx, REG_DC_PC_SYSH_prog_0_ACC_LAT, TYPE_DCSYS);
-        result->dcsysInfo.dcsysVeReq        = vdi_read_dcsys_register(pCodecInst->coreIdx, REG_DC_PC_SYSH_prog_0_REQ_NUM, TYPE_DCSYS);
-
-        //vdi_write_dcsys_register(pCodecInst->coreIdx, REG_DMC_PC_GO_START, DMC_PC_CTRL, TYPE_DMC);
-        //vdi_write_dcsys_register(pCodecInst->coreIdx, REG_DMC_PC_GO_CTRL, 0, TYPE_DMC);
-        vdi_write_dcsys_register(pCodecInst->coreIdx, REG_DMC_PC_GO_START, DMC_PC_CPU_REQ_NUM, TYPE_DMC);
-        result->dcsysInfo.dmcCpuReq = vdi_read_dcsys_register(pCodecInst->coreIdx, REG_DMC_PC_GO_CTRL, TYPE_DMC);
-        vdi_write_dcsys_register(pCodecInst->coreIdx, REG_DMC_PC_GO_START, DMC_PC_GPU_REQ_NUM, TYPE_DMC);
-        result->dcsysInfo.dmcGpuReq = vdi_read_dcsys_register(pCodecInst->coreIdx, REG_DMC_PC_GO_CTRL, TYPE_DMC);
-    }
-*/
+
 	if (pCodecInst->loggingEnable)
 		vdi_log(pCodecInst->coreIdx, PIC_RUN, 0);
 
@@ -2158,9 +2043,7 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 	}
 	tempBuffer = vb.phys_addr + CODE_BUF_SIZE;
 	paraBuffer = tempBuffer + TEMP_BUF_SIZE;
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg BIT_PARA_BUF_ADDR.paraBuffer:0x%08x(tempBuffer:0x%08x + TEMP_BUF_SIZE:%d)\n",__LINE__,__func__,paraBuffer,tempBuffer,TEMP_BUF_SIZE);
 	VpuWriteReg(pCodecInst->coreIdx, BIT_PARA_BUF_ADDR, paraBuffer);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg BIT_TEMP_BUF_ADDR.tempBuffer:0x%08x(common_memory:0x%08x + CODE_BUF_SIZE:%d)\n",__LINE__,__func__,tempBuffer,vb.phys_addr,CODE_BUF_SIZE);
 	VpuWriteReg(pCodecInst->coreIdx, BIT_TEMP_BUF_ADDR, tempBuffer);
 
 	pDecInfo->mapCfg.productId = pCodecInst->productId;
@@ -2184,19 +2067,9 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 	if (val == 0) {
 		return RETCODE_INVALID_PARAM;
 	}
-	/*
-#ifdef ENABLE_TEE_DRM_FLOW
-    TEEC_Context        ctx;
-    TEEC_Session        sess;
-    RTK_TEEC_Session    rtk_sess;
 
-    if (pCodecInst->isUseProtectBuffer)
-        TEE_API_Initialize(&ctx, &sess, &rtk_sess);
-#endif
-*/
 	//Allocate frame buffer
 	for (i = 0; i < pDecInfo->numFbsForDecoding; i++) {
-		//VLOG(TRACE, "[%d]%s.frameBufPool[%d].bufY:0x%08x.bufCb:0x%08x.bufCr:0x%08x.size:%d\n",__LINE__,__func__,i,pDecInfo->frameBufPool[i].bufY,pDecInfo->frameBufPool[i].bufCb,pDecInfo->frameBufPool[i].bufCr,pDecInfo->frameBufPool[i].size);
 		frameAddr[i][0][0] =
 			(pDecInfo->frameBufPool[i].bufY >> 24) & 0xFF;
 		frameAddr[i][0][1] =
@@ -2206,7 +2079,6 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 		frameAddr[i][0][3] =
 			(pDecInfo->frameBufPool[i].bufY >> 0) & 0xFF;
 		if (pDecInfo->openParam.cbcrOrder == CBCR_ORDER_NORMAL) {
-			//VLOG(TRACE, "[%d]%s.frameBufPool[%d].bufCb:0x%08x.bufCr:0x%08x\n",__LINE__,__func__,i,pDecInfo->frameBufPool[i].bufCb,pDecInfo->frameBufPool[i].bufCr);
 			frameAddr[i][1][0] =
 				(pDecInfo->frameBufPool[i].bufCb >> 24) & 0xFF;
 			frameAddr[i][1][1] =
@@ -2224,7 +2096,6 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 			frameAddr[i][2][3] =
 				(pDecInfo->frameBufPool[i].bufCr >> 0) & 0xFF;
 		} else {
-			//VLOG(TRACE, "[%d]%s.frameBufPool[%d].bufCb:0x%08x.bufCr:0x%08x\n",__LINE__,__func__,i,pDecInfo->frameBufPool[i].bufCb,pDecInfo->frameBufPool[i].bufCr);
 			frameAddr[i][2][0] =
 				(pDecInfo->frameBufPool[i].bufCb >> 24) & 0xFF;
 			frameAddr[i][2][1] =
@@ -2255,7 +2126,6 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 				 (BYTE *)frameAddr, sizeof(frameAddr),
 				 VDI_BIG_ENDIAN, pCodecInst->teeapi_ctx,
 				 pCodecInst->teeapi_tee_session);
-		//Coda9VpuWriteMem(pCodecInst->coreIdx, paraBuffer, (BYTE*)frameAddr, sizeof(frameAddr), VDI_BIG_ENDIAN, sess, rtk_sess);
 #else
 		VpuWriteMem(pCodecInst->coreIdx, paraBuffer, (BYTE *)frameAddr,
 			    sizeof(frameAddr), VDI_BIG_ENDIAN);
@@ -2316,12 +2186,7 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 				if (vdi_allocate_dma_memory_no_mmap(
 					    pCodecInst->coreIdx, &vbBuffer,
 					    pCodecInst->filp) < 0) {
-					/*
-#ifdef ENABLE_TEE_DRM_FLOW
-                    if (pCodecInst->isUseProtectBuffer)
-                        TEE_API_Finalize(&ctx, &sess, &rtk_sess);
-#endif
-*/
+
 					return RETCODE_FAILURE;
 				}
 				pDecInfo->vbMV[i] = vbBuffer;
@@ -2371,7 +2236,6 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 					 (BYTE *)colMvAddr, sizeof(colMvAddr),
 					 VDI_BIG_ENDIAN, pCodecInst->teeapi_ctx,
 					 pCodecInst->teeapi_tee_session);
-			//Coda9VpuWriteMem(pCodecInst->coreIdx, paraBuffer+384, (BYTE*)colMvAddr, sizeof(colMvAddr), VDI_BIG_ENDIAN, sess, rtk_sess);
 #else
 			VpuWriteMem(pCodecInst->coreIdx, paraBuffer + 384,
 				    (BYTE *)colMvAddr, sizeof(colMvAddr),
@@ -2390,7 +2254,6 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 
 	if (pCodecInst->productId == PRODUCT_ID_980) {
 		for (i = 0; i < pDecInfo->numFbsForDecoding; i++) {
-			//VLOG(TRACE, "[%d]%s.frameBufPool[%d].bufYBot:0x%08x\n",__LINE__,__func__,i,pDecInfo->frameBufPool[i].bufYBot);
 			frameAddr[i][0][0] =
 				(pDecInfo->frameBufPool[i].bufYBot >> 24) &
 				0xFF;
@@ -2403,7 +2266,6 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 				(pDecInfo->frameBufPool[i].bufYBot >> 0) & 0xFF;
 			if (pDecInfo->openParam.cbcrOrder ==
 			    CBCR_ORDER_NORMAL) {
-				//VLOG(TRACE, "[%d]%s.frameBufPool[%d].bufCbBot:0x%08x.bufCrBot:0x%08x\n",__LINE__,__func__,i,pDecInfo->frameBufPool[i].bufCbBot,pDecInfo->frameBufPool[i].bufCrBot);
 				frameAddr[i][1][0] =
 					(pDecInfo->frameBufPool[i].bufCbBot >>
 					 24) &
@@ -2437,7 +2299,6 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 					 0) &
 					0xFF;
 			} else {
-				//VLOG(TRACE, "[%d]%s.frameBufPool[%d].bufCbBot:0x%08x.bufCrBot:0x%08x\n",__LINE__,__func__,i,pDecInfo->frameBufPool[i].bufCbBot,pDecInfo->frameBufPool[i].bufCrBot);
 				frameAddr[i][2][0] =
 					(pDecInfo->frameBufPool[i].bufCbBot >>
 					 24) &
@@ -2484,7 +2345,6 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 					 (BYTE *)frameAddr, sizeof(frameAddr),
 					 VDI_BIG_ENDIAN, pCodecInst->teeapi_ctx,
 					 pCodecInst->teeapi_tee_session);
-			//Coda9VpuWriteMem(pCodecInst->coreIdx, paraBuffer+384+128, (BYTE*)frameAddr, sizeof(frameAddr), VDI_BIG_ENDIAN, sess, rtk_sess);
 #else
 			VpuWriteMem(pCodecInst->coreIdx, paraBuffer + 384 + 128,
 				    (BYTE *)frameAddr, sizeof(frameAddr),
@@ -2617,7 +2477,6 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 					(BYTE *)frameAddr, sizeof(frameAddr),
 					VDI_BIG_ENDIAN, pCodecInst->teeapi_ctx,
 					pCodecInst->teeapi_tee_session);
-				//Coda9VpuWriteMem(pCodecInst->coreIdx, paraBuffer+384+128+384, (BYTE*)frameAddr, sizeof(frameAddr), VDI_BIG_ENDIAN, sess, rtk_sess);
 #else
 				VpuWriteMem(pCodecInst->coreIdx,
 					    paraBuffer + 384 + 128 + 384,
@@ -2763,7 +2622,6 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 						VDI_BIG_ENDIAN,
 						pCodecInst->teeapi_ctx,
 						pCodecInst->teeapi_tee_session);
-					//Coda9VpuWriteMem(pCodecInst->coreIdx, paraBuffer+384+128+384+384, (BYTE*)frameAddr, sizeof(frameAddr), VDI_BIG_ENDIAN, sess, rtk_sess);
 #else
 					VpuWriteMem(pCodecInst->coreIdx,
 						    paraBuffer + 384 + 128 +
@@ -2907,7 +2765,6 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 					(BYTE *)frameAddr, sizeof(frameAddr),
 					VDI_BIG_ENDIAN, pCodecInst->teeapi_ctx,
 					pCodecInst->teeapi_tee_session);
-				//Coda9VpuWriteMem(pCodecInst->coreIdx, paraBuffer+384+128+384, (BYTE*)frameAddr, sizeof(frameAddr), VDI_BIG_ENDIAN, sess, rtk_sess);
 #else
 				VpuWriteMem(pCodecInst->coreIdx,
 					    paraBuffer + 384 + 128 + 384,
@@ -2928,12 +2785,7 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 			}
 		}
 	}
-	/*
-#ifdef ENABLE_TEE_DRM_FLOW
-    if (pCodecInst->isUseProtectBuffer)
-        TEE_API_Finalize(&ctx, &sess, &rtk_sess);
-#endif
-*/
+
 	if (!ConfigSecAXICoda9(pCodecInst->coreIdx, pCodecInst->codecMode,
 			       &pDecInfo->secAxiInfo, pDecInfo->stride,
 			       pDecInfo->frameBufferHeight,
@@ -2973,28 +2825,20 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 	}
 
 	// Tell the decoder how much frame buffers were allocated.
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_SET_FRAME_BUF_NUM.numFrameBuffers:%d\n",__LINE__,__func__,pDecInfo->numFrameBuffers);
 	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_BUF_NUM,
 		    pDecInfo->numFrameBuffers);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_SET_FRAME_BUF_STRIDE.stride:%d\n",__LINE__,__func__,pDecInfo->stride);
 	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_BUF_STRIDE,
 		    pDecInfo->stride);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_SET_FRAME_AXI_BIT_ADDR.bufBitUse:0x%08x\n",__LINE__,__func__,pDecInfo->secAxiInfo.u.coda9.bufBitUse);
 	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_BIT_ADDR,
 		    pDecInfo->secAxiInfo.u.coda9.bufBitUse);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_SET_FRAME_AXI_IPACDC_ADDR.bufIpAcDcUse:0x%08x\n",__LINE__,__func__,pDecInfo->secAxiInfo.u.coda9.bufIpAcDcUse);
 	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_IPACDC_ADDR,
 		    pDecInfo->secAxiInfo.u.coda9.bufIpAcDcUse);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_SET_FRAME_AXI_DBKY_ADDR.bufDbkYUse:0x%08x\n",__LINE__,__func__,pDecInfo->secAxiInfo.u.coda9.bufDbkYUse);
 	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_DBKY_ADDR,
 		    pDecInfo->secAxiInfo.u.coda9.bufDbkYUse);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_SET_FRAME_AXI_DBKC_ADDR.bufDbkCUse:0x%08x\n",__LINE__,__func__,pDecInfo->secAxiInfo.u.coda9.bufDbkCUse);
 	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_DBKC_ADDR,
 		    pDecInfo->secAxiInfo.u.coda9.bufDbkCUse);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_SET_FRAME_AXI_OVL_ADDR.bufOvlUse:0x%08x\n",__LINE__,__func__,pDecInfo->secAxiInfo.u.coda9.bufOvlUse);
 	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_OVL_ADDR,
 		    pDecInfo->secAxiInfo.u.coda9.bufOvlUse);
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_SET_FRAME_AXI_BTP_ADDR.bufBtpUse:0x%08x\n",__LINE__,__func__,pDecInfo->secAxiInfo.u.coda9.bufBtpUse);
 	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_AXI_BTP_ADDR,
 		    pDecInfo->secAxiInfo.u.coda9.bufBtpUse);
 	VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_DELAY,
@@ -3043,7 +2887,6 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 		     pCgf->decRegion[WPROT_DEC_PIC_SAVE].startAddress,
 		     pCgf->decRegion[WPROT_DEC_PIC_SAVE].endAddress);
 #endif
-		//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_SET_FRAME_MB_BUF_BASE.vbSlice:0x%08x\n",__LINE__,__func__,pvbSlice->phys_addr);
 		VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_MB_BUF_BASE,
 			    pvbSlice->phys_addr);
 	}
@@ -3088,10 +2931,8 @@ RetCode Coda9VpuDecRegisterFramebuffer(CodecInst *instance)
 		     pCgf->decRegion[WPROT_DEC_PIC_SAVE].startAddress,
 		     pCgf->decRegion[WPROT_DEC_PIC_SAVE].endAddress);
 #endif
-		//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_SET_FRAME_SLICE_BB_START.vbSlice:0x%08x\n",__LINE__,__func__,pvbSlice->phys_addr);
 		VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_SLICE_BB_START,
 			    pvbSlice->phys_addr);
-		//VLOG(TRACE, "[%d]%s.VpuWriteReg CMD_SET_FRAME_SLICE_BB_SIZE.size:%d\n",__LINE__,__func__,(pvbSlice->size/1024));
 		VpuWriteReg(pCodecInst->coreIdx, CMD_SET_FRAME_SLICE_BB_SIZE,
 			    (pvbSlice->size / 1024));
 	}
@@ -3820,7 +3661,6 @@ RetCode Coda9VpuEncRegisterFramebuffer(CodecInst *instance)
 		frameAddr[i][2][3] =
 			(pEncInfo->frameBufPool[i].bufCr >> 0) & 0xFF;
 	}
-	//VLOG(TRACE, "[%d]%s.VpuWriteMem paraBuffer:0x%08x with frameAddr.numFrameBuffers:%d.sizeof(frameAddr):%d\n",__LINE__,__func__,paraBuffer,pEncInfo->numFrameBuffers,sizeof(frameAddr));
 	VpuWriteMem(pCodecInst->coreIdx, paraBuffer, (BYTE *)frameAddr,
 		    sizeof(frameAddr), VDI_BIG_ENDIAN);
 
@@ -3861,7 +3701,6 @@ RetCode Coda9VpuEncRegisterFramebuffer(CodecInst *instance)
 				(pEncInfo->frameBufPool[i].bufCrBot >> 0) &
 				0xFF;
 		}
-		//VLOG(TRACE, "[%d]%s.VpuWriteMem paraBuffer+384+128:0x%08x with frameAddr.numFrameBuffers:%d.sizeof(frameAddr):%d\n",__LINE__,__func__,(paraBuffer+384+128),pEncInfo->numFrameBuffers,sizeof(frameAddr));
 		VpuWriteMem(pCodecInst->coreIdx, paraBuffer + 384 + 128,
 			    (BYTE *)frameAddr, sizeof(frameAddr),
 			    VDI_BIG_ENDIAN);
@@ -4016,8 +3855,6 @@ RetCode Coda9VpuEncRegisterFramebuffer(CodecInst *instance)
 			    pEncInfo->vbScratch.size >> 10);
 	}
 
-	//RTK mark
-	//SetPendingInst(pCodecInst->coreIdx, pCodecInst);
 	Coda9BitIssueCommand(pCodecInst->coreIdx, pCodecInst, SET_FRAME_BUF);
 	if (vdi_wait_vpu_busy(pCodecInst->coreIdx, __VPU_BUSY_TIMEOUT,
 			      BIT_BUSY_FLAG) == -1) {
@@ -4659,7 +4496,6 @@ RetCode Coda9VpuEncGetResult(CodecInst *pCodecInst, EncOutputInfo *info)
 
 RetCode Coda9VpuEncGiveCommand(CodecInst *pCodecInst, CodecCommand cmd,
 			       void *param)
-//RetCode Coda9VpuEncGiveCommand(CodecInst* pCodecInst __unused, CodecCommand cmd, void* param)
 {
 	RetCode ret = RETCODE_SUCCESS;
 
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapi.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapi.c
index 183130d8b502..d307b2661b4e 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapi.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapi.c
@@ -18,8 +18,6 @@
 #include <linux/delay.h>
 #include <linux/string.h>
 #include <linux/tee_drv.h>
-//#include <unistd.h>
-//#include <sched.h>
 #include "ve1_vpuapifunc.h"
 #include "ve1_product.h"
 
@@ -31,8 +29,6 @@
  */
 #include "ve1_fw.h"
 #include "ve1_vpuconfig.h"
-//#include "coda980.h"
-//#include "coda9_vpuconfig.h"
 #endif
 
 #ifdef VE1_CHECKSUM
@@ -41,11 +37,6 @@
 #endif
 
 #include "ve1_fw.h"
-/*
-#if defined(__LINARO_SDK__)
-#include <pthread.h>
-#endif
-*/
 #ifdef BIT_CODE_FILE_PATH
 #include BIT_CODE_FILE_PATH
 #endif
@@ -98,29 +89,22 @@ RetCode VPU_InitWithBitcodeProtect(Uint32 coreIdx, const Uint16 *code,
 	if (vdi_init(coreIdx) < 0)
 		return RETCODE_FAILURE;
 
-	//EnterLock(coreIdx);
-
 	if (ProductVpuScan(coreIdx) == 0) {
-		//LeaveLock(coreIdx);
 		return RETCODE_NOT_FOUND_VPU_DEVICE;
 	}
 
 	InitCodecInstancePool(coreIdx);
 
-	//SetClockGate(coreIdx, 1);
 	ret = ProductVpuReset(coreIdx, SW_RESET_ON_BOOT);
 	if (ret != RETCODE_SUCCESS) {
-		//LeaveLock(coreIdx);
 		return ret;
 	}
 
 	ret = ProductVpuInitProtect(coreIdx, (void *)code, size, sess, rtk_sess,
 				    filp);
 	if (ret != RETCODE_SUCCESS) {
-		//LeaveLock(coreIdx);
 		return ret;
 	}
-	//LeaveLock(coreIdx);
 	return RETCODE_SUCCESS;
 }
 #endif
@@ -288,25 +272,6 @@ int VPU_GetProductId(int coreIdx)
 
 	INVALID_CORE_INDEX_RETURN_ERROR(coreIdx);
 
-#if 0 //RTK don't scan
-    if ((productId=ProductVpuGetId(coreIdx)) != PRODUCT_ID_NONE) {
-        return productId;
-    }
-
-    if (vdi_init(coreIdx) < 0)
-        return -1;
-
-    EnterLock(coreIdx);
-    if (ProductVpuScan(coreIdx) == FALSE)
-        productId = -1;
-    else
-        productId = ProductVpuGetId(coreIdx);
-    LeaveLock((coreIdx));
-
-    vdi_release(coreIdx);
-
-    return productId;
-#else
 	if (ProductVpuScan(coreIdx) == FALSE) {
 		VLOG(ERR, "[-] [%d]%s.ProductVpuScan() fail.coreIdx:%d\n",
 		     __LINE__, __func__, coreIdx);
@@ -315,7 +280,6 @@ int VPU_GetProductId(int coreIdx)
 	productId = ProductVpuGetId(coreIdx);
 	VLOG(TRACE, "[-] [%d]%s.productId:%d\n", __LINE__, __func__, productId);
 	return productId;
-#endif
 }
 
 int VPU_GetOpenInstanceNum(Uint32 coreIdx)
@@ -338,19 +302,16 @@ static RetCode InitializeVPU(Uint32 coreIdx, const Uint16 *code, Uint32 size)
 
 	EnterLock(coreIdx);
 
-	//if (vdi_get_instance_num(coreIdx) > 0) { //disable by RTK
 	if (ProductVpuScan(coreIdx) == 0) {
 		LeaveLock(coreIdx);
 		VLOG(ERR, "[-] [%d]%s.RETCODE_NOT_FOUND_VPU_DEVICE\n", __LINE__,
 		     __func__);
 		return RETCODE_NOT_FOUND_VPU_DEVICE;
 	}
-	//} //disable by RTK
 
 	if (VPU_IsInit(coreIdx) != 0) {
 		SetClockGate(coreIdx, 1);
 		ProductVpuGetProductId(coreIdx);
-		//ProductVpuReInit(coreIdx, (void *)code, size);
 		LeaveLock(coreIdx);
 		VLOG(INFO, "[-] [%d]%s.RETCODE_CALLED_BEFORE\n", __LINE__,
 		     __func__);
@@ -399,16 +360,11 @@ RetCode VPU_Init(Uint32 coreIdx)
 		     __LINE__, __func__, coreIdx);
 		return RETCODE_INVALID_PARAM;
 	}
-#if 0 //RTK disable
-    if (s_bitCodeSize[coreIdx] == 0)
-        return RETCODE_NOT_FOUND_BITCODE_PATH;
 
-#else
 	ret = InitializeVPU(coreIdx, NULL, 0);
 	VLOG(TRACE, "[-] [%d]%s.coreIdx:%d.ret:%d\n", __LINE__, __func__,
 	     coreIdx, ret);
 	return ret;
-#endif
 }
 
 RetCode VPU_InitWithBitcode(Uint32 coreIdx, const Uint16 *code, Uint32 size)
@@ -485,8 +441,6 @@ RetCode VPU_DecOpen(DecHandle *pHandle, DecOpenParam *pop)
 	CodecInst *pCodecInst = 0;
 	DecInfo *pDecInfo;
 	RetCode ret;
-	//Uint32      versionInfo;
-	//Uint32      revision;
 #if defined(ENABLE_TEE_DRM_FLOW)
 	int ret_teeapi;
 #endif
@@ -757,13 +711,6 @@ RetCode VPU_DecOpen(DecHandle *pHandle, DecOpenParam *pop)
 	}
 #endif // #ifdef DAH_222_PREALLOC_MV_SLICE_BUFFER
 
-	/*ret = ProductVpuGetVersion(pop->coreIdx, &versionInfo, &revision);
-    if (ret == RETCODE_SUCCESS)
-    {
-        VLOG(TRACE, "[%d]%s.h:0x%x.Firmware : CustomerCode: %04x | version : %d.%d.%d rev.%d\n",__LINE__,__func__,*pHandle,
-            (unsigned int)(versionInfo>>16), (unsigned int)((versionInfo>>(12))&0x0f), (unsigned int)((versionInfo>>(8))&0x0f), (unsigned int)((versionInfo)&0xff), revision);
-    }*/
-
 	// for debug, enable logging by vpuapi self
 	//pCodecInst->loggingEnable = 1;
 
@@ -1038,7 +985,6 @@ RetCode VPU_DecGetInitialInfo(DecHandle handle, DecInitialInfo *info)
 			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
 			     __func__, __LINE__);
 			msleep(50);
-			//usleep(50000);
 			if (GetPendingInst(pCodecInst->coreIdx)) {
 				LeaveLock(pCodecInst->coreIdx);
 				return RETCODE_FRAME_NOT_COMPLETE;
@@ -1130,7 +1076,6 @@ RetCode VPU_DecIssueSeqInit(DecHandle handle)
 			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
 			     __func__, __LINE__);
 			msleep(50);
-			//usleep(50000);
 			if (GetPendingInst(pCodecInst->coreIdx)) {
 				LeaveLock(pCodecInst->coreIdx);
 				VLOG(ERR,
@@ -1335,7 +1280,6 @@ static RetCode DecRegisterFrameBuffer(DecHandle handle, FrameBuffer *bufArray,
 			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
 			     __func__, __LINE__);
 			msleep(50);
-			//usleep(50000);
 			if (GetPendingInst(pCodecInst->coreIdx)) {
 				LeaveLock(pCodecInst->coreIdx);
 				return RETCODE_FRAME_NOT_COMPLETE;
@@ -1674,13 +1618,12 @@ RetCode VPU_DecSetDispFlag(DecHandle handle, int dispFlag) // [r] unused
 		LeaveDispFlagLock(pCodecInst->coreIdx);
 	} else {
 		EnterLock(pCodecInst->coreIdx);
-		//Wave5DecSetDispFlagEx(pCodecInst, dispFlag);
 		LeaveLock(pCodecInst->coreIdx);
 	}
 
 	return RETCODE_SUCCESS;
 }
-#if 1 // #ifdef FIX_PEDING_INSTANCE_CHECK_BUG
+
 RetCode VPU_DecGetBitstreamBuffer(DecHandle handle, PhysicalAddress *prdPtr,
 				  PhysicalAddress *pwrPtr, Uint32 *size)
 {
@@ -1849,7 +1792,6 @@ RetCode VPU_DecUpdateBitstreamBuffer(DecHandle handle, int size)
 	BOOL running;
 	VpuAttr *pAttr;
 
-	//VLOG(TRACE, "[+] [%d]%s.h:0x%x.size:%d\n",__LINE__,__func__,handle,size);
 	ret = CheckDecInstanceValidity(handle);
 	if (ret != RETCODE_SUCCESS) {
 		VLOG(ERR, "[-] [%d]%s.h:0x%x.size:%d.ret:%d\n", __LINE__,
@@ -1895,7 +1837,6 @@ RetCode VPU_DecUpdateBitstreamBuffer(DecHandle handle, int size)
 		// Discuss with FuChun, vpuapi can't know BS buffer is ring buffer or line buffer.
 		// Gregory use "bitstreamMode != BS_MODE_PIC_END" to determine BS buffer is ring buffer is not correct due to we have PIC_END + ring buffer case.
 		// If line buffer, wrPts won't be bigger than pDecInfo->streamBufEndAddr, so mark this condition is also ok for line buffer.
-		//if (pDecInfo->openParam.bitstreamMode != BS_MODE_PIC_END) {
 		if (wrPtr > pDecInfo->streamBufEndAddr) {
 			room = wrPtr - pDecInfo->streamBufEndAddr;
 			wrPtr = pDecInfo->streamBufStartAddr;
@@ -1903,7 +1844,6 @@ RetCode VPU_DecUpdateBitstreamBuffer(DecHandle handle, int size)
 		} else if (wrPtr == pDecInfo->streamBufEndAddr) {
 			wrPtr = pDecInfo->streamBufStartAddr;
 		}
-		//}
 
 		pDecInfo->streamWrPtr = wrPtr;
 		pDecInfo->streamRdPtr = rdPtr;
@@ -1917,165 +1857,11 @@ RetCode VPU_DecUpdateBitstreamBuffer(DecHandle handle, int size)
 	ret = ProductVpuDecSetBitstreamFlag(pCodecInst, running, size);
 
 	SetClockGate(pCodecInst->coreIdx, 0);
-	//VLOG(TRACE, "[-] [%d]%s.h:0x%x.size:%d.ret:%d\n",__LINE__,__func__,handle,size,ret);
 	VLOG(TRACE, "[%d]%s.h:0x%x.size:%d.ret:%d\n", __LINE__, __func__,
 	     handle, size, ret);
 	return ret;
 }
 
-#else
-
-RetCode VPU_DecGetBitstreamBuffer(DecHandle handle, PhysicalAddress *prdPtr,
-				  PhysicalAddress *pwrPtr, Uint32 *size)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	PhysicalAddress rdPtr;
-	PhysicalAddress wrPtr;
-	PhysicalAddress tempPtr;
-	int room;
-	Int32 coreIdx;
-	VpuAttr *pAttr;
-
-	coreIdx = handle->coreIdx;
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-
-	SetClockGate(coreIdx, TRUE);
-
-	if (GetPendingInst(coreIdx) == pCodecInst) {
-		if (pCodecInst->codecMode == AVC_DEC &&
-		    pCodecInst->codecModeAux == AVC_AUX_MVC) {
-			rdPtr = pDecInfo->streamRdPtr;
-		} else {
-			rdPtr = VpuReadReg(coreIdx,
-					   pDecInfo->streamRdPtrRegAddr);
-		}
-	} else {
-		if (handle->productId == PRODUCT_ID_512) {
-#ifdef FIX_SET_GET_RD_PTR_BUG
-			EnterLock(pCodecInst->coreIdx);
-			rdPtr = ProductVpuDecGetRdPtr(pCodecInst);
-			LeaveLock(pCodecInst->coreIdx);
-#else
-			if (pDecInfo->rdPtrValidFlag ==
-			    TRUE) { // when RdPtr has been updated by calling SetRdPtr.
-				rdPtr = pDecInfo->streamRdPtr;
-			} else {
-				EnterLock(pCodecInst->coreIdx);
-				rdPtr = ProductVpuDecGetRdPtr(pCodecInst);
-				LeaveLock(pCodecInst->coreIdx);
-			}
-#endif
-
-		} else
-			rdPtr = pDecInfo->streamRdPtr;
-	}
-
-	SetClockGate(coreIdx, FALSE);
-
-	wrPtr = pDecInfo->streamWrPtr;
-
-	pAttr = &g_VpuCoreAttributes[coreIdx];
-
-	tempPtr = rdPtr;
-
-	if (pDecInfo->openParam.bitstreamMode != BS_MODE_PIC_END) {
-		if (wrPtr < tempPtr) {
-			room = tempPtr - wrPtr -
-			       pAttr->bitstreamBufferMargin * 2;
-		} else {
-			room = (pDecInfo->streamBufEndAddr - wrPtr) +
-			       (tempPtr - pDecInfo->streamBufStartAddr) -
-			       pAttr->bitstreamBufferMargin * 2;
-		}
-		room--;
-	} else {
-		room = (pDecInfo->streamBufEndAddr - wrPtr);
-	}
-
-	if (prdPtr)
-		*prdPtr = tempPtr;
-	if (pwrPtr)
-		*pwrPtr = wrPtr;
-	if (size)
-		*size = room;
-
-	return RETCODE_SUCCESS;
-}
-
-RetCode VPU_DecUpdateBitstreamBuffer(DecHandle handle, int size)
-{
-	CodecInst *pCodecInst;
-	DecInfo *pDecInfo;
-	PhysicalAddress wrPtr;
-	PhysicalAddress rdPtr;
-	RetCode ret;
-	BOOL running;
-
-	ret = CheckDecInstanceValidity(handle);
-	if (ret != RETCODE_SUCCESS)
-		return ret;
-
-	pCodecInst = handle;
-	pDecInfo = &pCodecInst->CodecInfo->decInfo;
-	wrPtr = pDecInfo->streamWrPtr;
-
-	SetClockGate(pCodecInst->coreIdx, 1);
-
-	running = (BOOL)(GetPendingInst(pCodecInst->coreIdx) == pCodecInst);
-
-	if (size > 0) {
-		Uint32 room = 0;
-
-		if (running == TRUE)
-			rdPtr = VpuReadReg(pCodecInst->coreIdx,
-					   pDecInfo->streamRdPtrRegAddr);
-		else
-			rdPtr = pDecInfo->streamRdPtr;
-
-		if (wrPtr < rdPtr) {
-			if (rdPtr <= wrPtr + size) {
-				SetClockGate(pCodecInst->coreIdx, 0);
-				return RETCODE_INVALID_PARAM;
-			}
-		}
-
-		wrPtr += size;
-
-		if (pDecInfo->openParam.bitstreamMode != BS_MODE_PIC_END) {
-			if (wrPtr > pDecInfo->streamBufEndAddr) {
-				room = wrPtr - pDecInfo->streamBufEndAddr;
-				wrPtr = pDecInfo->streamBufStartAddr;
-				wrPtr += room;
-			} else if (wrPtr == pDecInfo->streamBufEndAddr) {
-				wrPtr = pDecInfo->streamBufStartAddr;
-			}
-		}
-
-		pDecInfo->streamWrPtr = wrPtr;
-		pDecInfo->streamRdPtr = rdPtr;
-
-		if (running == TRUE) {
-			VpuAttr *pAttr =
-				&g_VpuCoreAttributes[pCodecInst->coreIdx];
-			if (pAttr->supportCommandQueue == FALSE) {
-				VpuWriteReg(pCodecInst->coreIdx,
-					    pDecInfo->streamWrPtrRegAddr,
-					    wrPtr);
-			}
-		}
-	}
-
-	ret = ProductVpuDecSetBitstreamFlag(pCodecInst, running, size);
-
-	SetClockGate(pCodecInst->coreIdx, 0);
-	return ret;
-}
-
-#endif
-
 RetCode VPU_HWReset(Uint32 coreIdx)
 {
 	if (vdi_hw_reset(coreIdx) < 0)
@@ -2101,15 +1887,11 @@ RetCode VPU_HWReset(Uint32 coreIdx)
 RetCode VPU_SWReset(Uint32 coreIdx, SWResetMode resetMode, void *pendingInst)
 {
 	RetCode ret = RETCODE_SUCCESS;
-//#define DEMO
-#ifndef DEMO
 	CodecInst *pCodecInst = (CodecInst *)pendingInst;
-#endif
 
 	VLOG(TRACE, "[+] [%d]%s.coreIdx:%d.resetMode:%d.pendingInst:%p\n",
 	     __LINE__, __func__, coreIdx, resetMode, pendingInst);
 	SetClockGate(coreIdx, 1);
-#ifndef DEMO //Disable for DEMO
 	ret = ProductVpuReset(coreIdx, resetMode);
 
 	if (ret != RETCODE_SUCCESS) //RTK
@@ -2145,10 +1927,7 @@ RetCode VPU_SWReset(Uint32 coreIdx, SWResetMode resetMode, void *pendingInst)
 			}
 		}
 	}
-#else
-	VLOG(ERR, "start VPU_HWReset !!");
-	ret = VPU_HWReset(coreIdx);
-#endif
+
 	SetClockGate(coreIdx, 0);
 
 	VLOG(TRACE, "[-] [%d]%s.coreIdx:%d.ret:%d\n", __LINE__, __func__,
@@ -2158,7 +1937,6 @@ RetCode VPU_SWReset(Uint32 coreIdx, SWResetMode resetMode, void *pendingInst)
 
 //---- VPU_SLEEP/WAKE
 RetCode VPU_SleepWake(Uint32 coreIdx, int iSleepWake)
-//RetCode VPU_SleepWake(Uint32 coreIdx, int iSleepWake __unused)
 {
 	SetClockGate(coreIdx, TRUE);
 	SetClockGate(coreIdx, FALSE);
@@ -2173,15 +1951,7 @@ RetCode VPU_DecStartOneFrame(DecHandle handle, DecParam *param)
 	Uint32 val = 0;
 	RetCode ret = RETCODE_SUCCESS;
 	VpuAttr *pAttr = NULL;
-	/*
-#ifdef USE_OS_SCHEDULE_YIELD
-#ifdef ANDROID
-    sched_yield();
-#else
-    pthread_yield();
-#endif
-#endif
-*/
+
 	VLOG(TRACE, "[+] [%d]%s.h:0x%x.DecParam(%d,%d,%d)\n", __LINE__,
 	     __func__, handle, param->iframeSearchEnable, param->skipframeMode,
 	     param->craAsBlaFlag);
@@ -2212,7 +1982,6 @@ RetCode VPU_DecStartOneFrame(DecHandle handle, DecParam *param)
 			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
 			     __func__, __LINE__);
 			msleep(50);
-			//usleep(50000);
 			if (GetPendingInst(pCodecInst->coreIdx)) {
 				LeaveLock(pCodecInst->coreIdx);
 				VLOG(ERR,
@@ -2234,7 +2003,6 @@ RetCode VPU_DecStartOneFrame(DecHandle handle, DecParam *param)
 		val = pDecInfo->frameDisplayFlag;
 		val |= pDecInfo->setDisplayIndexes;
 		val &= ~(Uint32)(pDecInfo->clearDisplayIndexes);
-		//VLOG(TRACE, "[%d]%s.VpuWriteReg frameDisplayFlagRegAddr:0x%08x.val:0x%08x\n",__LINE__,__func__,pDecInfo->frameDisplayFlagRegAddr,val);
 		VpuWriteReg(pCodecInst->coreIdx,
 			    pDecInfo->frameDisplayFlagRegAddr, val);
 		pDecInfo->clearDisplayIndexes = 0;
@@ -2513,11 +2281,6 @@ RetCode VPU_DecGetOutputInfo(DecHandle handle, DecOutputInfo *info)
 			info->dispPicWidth = info->decPicWidth;
 			info->dispPicHeight = info->decPicHeight;
 		} else {
-			/*
-                When indexFrameDecoded < 0, and indexFrameDisplay >= 0
-                info->decPicWidth and info->decPicHeight are still valid
-                But those of pDecInfo->decOutInfo[displayIndex] are invalid in VP9
-            */
 			info->dispPicWidth =
 				pDecInfo->decOutInfo[displayIndex].decPicWidth;
 			info->dispPicHeight =
@@ -2748,7 +2511,6 @@ RetCode VPU_DecFrameBufferFlush(DecHandle handle, DecOutputInfo *pRemainings,
 			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
 			     __func__, __LINE__);
 			msleep(50);
-			//usleep(50000);
 			if (GetPendingInst(pCodecInst->coreIdx)) {
 				LeaveLock(pCodecInst->coreIdx);
 				VLOG(ERR,
@@ -2773,7 +2535,6 @@ RetCode VPU_DecFrameBufferFlush(DecHandle handle, DecOutputInfo *pRemainings,
 		val = pDecInfo->frameDisplayFlag;
 		val |= pDecInfo->setDisplayIndexes;
 		val &= ~(Uint32)(pDecInfo->clearDisplayIndexes);
-		//VLOG(TRACE, "[%d]%s.VpuWriteReg frameDisplayFlagRegAddr:0x%08x.val:0x%08x\n",__LINE__,__func__,pDecInfo->frameDisplayFlagRegAddr,val);
 		VpuWriteReg(pCodecInst->coreIdx,
 			    pDecInfo->frameDisplayFlagRegAddr, val);
 		pDecInfo->clearDisplayIndexes = 0;
@@ -3013,7 +2774,6 @@ RetCode VPU_DecClrDispFlag(DecHandle handle, int index)
 	supportCommandQueue = (pAttr->supportCommandQueue == TRUE);
 	if (supportCommandQueue == TRUE) {
 		EnterLock(pCodecInst->coreIdx);
-		//ret = ProductClrDispFlag(pCodecInst, index); for wave5
 		LeaveLock(pCodecInst->coreIdx);
 	} else {
 		EnterDispFlagLock(pCodecInst->coreIdx);
@@ -3695,7 +3455,6 @@ RetCode VPU_DecGiveCommand(DecHandle handle, CodecCommand cmd, void *param)
 		supportCommandQueue = (pAttr->supportCommandQueue == TRUE);
 		if (supportCommandQueue == TRUE) {
 			EnterLock(pCodecInst->coreIdx);
-			//ProductSetDispFlag(pCodecInst, index); for wave5
 			LeaveLock(pCodecInst->coreIdx);
 		} else {
 			EnterDispFlagLock(pCodecInst->coreIdx);
@@ -3773,7 +3532,7 @@ RetCode VPU_DecGiveCommand(DecHandle handle, CodecCommand cmd, void *param)
 		if (pCodecInst->codecMode != HEVC_DEC) {
 			return RETCODE_NOT_SUPPORTED_FEATURE;
 		}
-    fallthrough;
+		break;
 	case DEC_SET_BWB_CUR_FRAME_IDX:
 		pDecInfo->chBwbFrameIdx = *(Uint32 *)param;
 		break;
@@ -3995,7 +3754,6 @@ RetCode VPU_EncOpen(EncHandle *pHandle, EncOpenParam *pop)
 		LeaveLock(pop->coreIdx);
 		return RETCODE_NOT_INITIALIZED;
 	}
-	//EncMBISR_Init(pop->coreIdx); //remove for thor
 	ret = GetCodecInstance(pop->coreIdx, &pCodecInst, pop->filp);
 	if (ret == RETCODE_FAILURE) {
 		*pHandle = 0;
@@ -4185,7 +3943,6 @@ RetCode VPU_EncGetInitialInfo(EncHandle handle, EncInitialInfo *info)
 			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
 			     __func__, __LINE__);
 			msleep(50);
-			//usleep(50000);
 			if (GetPendingInst(pCodecInst->coreIdx)) {
 				LeaveLock(pCodecInst->coreIdx);
 				return RETCODE_FRAME_NOT_COMPLETE;
@@ -4263,7 +4020,6 @@ RetCode VPU_EncRegisterFrameBuffer(EncHandle handle, FrameBuffer *bufArray,
 			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
 			     __func__, __LINE__);
 			msleep(50);
-			//usleep(50000);
 			if (GetPendingInst(pCodecInst->coreIdx)) {
 				LeaveLock(pCodecInst->coreIdx);
 				return RETCODE_FRAME_NOT_COMPLETE;
@@ -4311,15 +4067,12 @@ RetCode VPU_EncRegisterFrameBuffer(EncHandle handle, FrameBuffer *bufArray,
 			openParam->frameEndian, &pEncInfo->vbFrame, 0,
 			FB_TYPE_CODEC);
 		if (ret != RETCODE_SUCCESS) {
-			//SetPendingInst(pCodecInst->coreIdx, 0); //RTK mark
 			LeaveLock(pCodecInst->coreIdx);
 			return ret;
 		}
 	}
 	ret = ProductVpuRegisterFramebuffer(pCodecInst);
 
-	//SetPendingInst(pCodecInst->coreIdx, 0); //RTK mark
-
 	LeaveLock(pCodecInst->coreIdx);
 
 	return ret;
@@ -4511,7 +4264,6 @@ RetCode VPU_EncStartOneFrame(EncHandle handle, EncParam *param)
 			VLOG(WARN, "In[%s][%d] usleep 50ms and try again\n",
 			     __func__, __LINE__);
 			msleep(50);
-			//usleep(50000);
 			if (GetPendingInst(pCodecInst->coreIdx)) {
 				LeaveLock(pCodecInst->coreIdx);
 				return RETCODE_FRAME_NOT_COMPLETE;
@@ -4984,11 +4736,6 @@ RetCode VPU_EncCompleteSeqInit(EncHandle handle, EncInitialInfo *info)
 		pEncInfo->initialInfoObtained = 1;
 	}
 
-	//info->rdPtr = VpuReadReg(pCodecInst->coreIdx, pEncInfo->streamRdPtrRegAddr);
-	//info->wrPtr = VpuReadReg(pCodecInst->coreIdx, pEncInfo->streamWrPtrRegAddr);
-
-	//pEncInfo->prevFrameEndPos = info->rdPtr;
-
 	pEncInfo->initialInfo = *info;
 
 	SetPendingInst(pCodecInst->coreIdx, NULL);
@@ -5190,12 +4937,6 @@ RetCode RTK_VPU_InitWithBitcode(Uint32 coreIdx, BOOL protect)
 	}
 
 	if (coreIdx == 0) {
-		/*
-#if !defined(__LINARO_SDK__)
-// too large in run-time heap
-#include "coda980.h"
-#endif
-*/
 		firmware = (Uint8 *)osal_malloc(VPU_FIRMWARE_SIZE);
 		VLOG(TRACE, "[%d]firmware:0x%px\n", __LINE__, firmware);
 		VLOG(TRACE, "[%d]size:%d\n", __LINE__, VPU_FIRMWARE_SIZE);
@@ -5222,7 +4963,6 @@ RetCode RTK_VPU_InitWithBitcode(Uint32 coreIdx, BOOL protect)
 
 RetCode RTK_VPU_InitWithBitcodeExt(Uint32 coreIdx, BOOL protect, void *sess,
 				   void *rtk_sess, void *filp)
-//RetCode RTK_VPU_InitWithBitcodeExt(Uint32 coreIdx, BOOL protect __unused, void *sess __unused, void *rtk_sess __unused)
 {
 	RetCode ret = RETCODE_SUCCESS;
 	Uint8 *firmware = NULL;
@@ -5237,12 +4977,6 @@ RetCode RTK_VPU_InitWithBitcodeExt(Uint32 coreIdx, BOOL protect, void *sess,
 	}
 
 	if (coreIdx == 0) {
-		/*
-#if !defined(__LINARO_SDK__)
-// too large in run-time heap
-#include "coda980.h"
-#endif
-*/
 		firmware = (Uint8 *)osal_malloc(VPU_FIRMWARE_SIZE);
 		if (firmware != NULL) {
 			osal_memcpy((void *)firmware, bit_code,
@@ -5356,4 +5090,4 @@ RetCode VPU_DBG_DUMP_SDATA(DecHandle handle, unsigned int phy_addr,
 	ret = RETCODE_FAILURE;
 #endif // #ifdef ENABLE_TEE_DRM_FLOW
 	return ret;
-}
+}
\ No newline at end of file
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapi.h b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapi.h
index d1950f035244..cf030f789049 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapi.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapi.h
@@ -23,10 +23,6 @@
 #include "ve1_vdi_osal.h"
 #include "ve1_vpuerror.h"
 
-// RTK feature define
-//#define DAH_222_PREALLOC_MV_SLICE_BUFFER // https://dhc.sdlc.rd.realtek.com/gerrit/#/c/android/hardware/realtek/VideoEngine2/stark/+/196642/
-//#define ENABLE_CODA9_WRITE_PROTECT
-
 #define MAX_GDI_IDX                                                            \
 	30 //31 //RTK, because 31 will causes memory overwrite when endian swap
 #define MAX_REG_FRAME MAX_GDI_IDX * 2 // 2 for WTL
@@ -2408,7 +2404,7 @@ typedef struct {
 	/**
 @verbatim
 
-@* 0 : changes the COMMON parameters.
+@* 0 : changes the COMMON parameters. 
 @* 1 : Reserved
 @endverbatim
 */
@@ -2477,7 +2473,7 @@ An intra refresh mode
 
 @* 0 : No intra refresh
 @* 1 : Row
-@* 2 : Column
+@* 2 : Column 
 @* 3 : Step size in CTU
 @endverbatim
 */
@@ -2528,7 +2524,7 @@ An intra refresh mode
 	// ENC_SET_RC_PARAM_CHANGE
 	/**
     @verbatim
-    @* WAVE420
+    @* WAVE420 
     @** 0 : Rate control is off.
     @** 1 : Rate control is on.
 
@@ -3141,7 +3137,7 @@ typedef struct {
 	int initialDelay;
 	/**
     @verbatim
-    @* WAVE420
+    @* WAVE420 
     @** 0 : Rate control is off.
     @** 1 : Rate control is on.
 
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapifunc.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapifunc.c
index 30f95458d2c6..050cc7096777 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapifunc.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapifunc.c
@@ -29,7 +29,6 @@
 #endif
 #define MAX_LAVEL_IDX 16
 static const int g_anLevel[MAX_LAVEL_IDX] = { 10, 11, 11, 12, 13,
-					      //10, 16, 11, 12, 13,
 					      20, 21, 22, 30, 31, 32, 40, 41,
 					      42, 50, 51 };
 
@@ -362,7 +361,6 @@ void DecSetHostParaAddr(Uint32 coreIdx, PhysicalAddress baseAddr,
 	tempBuf[5] = (val >> 16) & 0xff;
 	tempBuf[6] = (val >> 8) & 0xff;
 	tempBuf[7] = (val >> 0) & 0xff;
-	//VLOG(TRACE, "[%d]%s.VpuWriteMem baseAddr:0x%08x\n",__LINE__,__func__,baseAddr);
 	VpuWriteMem(coreIdx, baseAddr, (BYTE *)tempBuf, 8, VDI_BIG_ENDIAN);
 }
 
@@ -675,7 +673,6 @@ RetCode GetEncHeader(EncHandle handle, EncHeaderParam *encHeaderParam)
 				   &pps_temp[ppsCopySize], size,
 				   pEncInfo->openParam.streamEndian);
 			ppsCopySize += size;
-			//VLOG(TRACE, "[%d]%s.VpuWriteMem rdPtr:0x%08x\n",__LINE__,__func__,rdPtr);
 			VpuWriteMem(pCodecInst->coreIdx, rdPtr, &pps_temp[0],
 				    ppsCopySize,
 				    pEncInfo->openParam.streamEndian);
@@ -784,7 +781,6 @@ RetCode EncParaSet(EncHandle handle, int paraSetType)
 			VpuWriteReg(pCodecInst->coreIdx,
 				    CMD_ENC_HEADER_TRANSFORM_8X8,
 				    ActvePPS->transform8x8Mode);
-			//encHeaderCode |= (0<<16); // ppsId=0
 
 			VpuWriteReg(pCodecInst->coreIdx, CMD_ENC_PARA_SET_TYPE,
 				    encHeaderCode);
@@ -1063,7 +1059,6 @@ void EncSetHostParaAddr(Uint32 coreIdx, PhysicalAddress baseAddr,
 	tempBuf[5] = (val >> 16) & 0xff;
 	tempBuf[6] = (val >> 8) & 0xff;
 	tempBuf[7] = (val >> 0) & 0xff;
-	//VLOG(TRACE, "[%d]%s.VpuWriteMem baseAddr:0x%08x\n",__LINE__,__func__,baseAddr);
 	VpuWriteMem(coreIdx, baseAddr, (BYTE *)tempBuf, 8, VDI_BIG_ENDIAN);
 }
 
@@ -1724,7 +1719,6 @@ int SetDecWriteProtectRegions(CodecInst *inst)
 
 	for (i = 0; i < pCfg->numOfRegion; i++) {
 		WriteMemProtectRegion *p = &pCfg->decRegion[i];
-		//int enable               = (p->enable != 0 && pDecInfo->frameAllocExt == FALSE);
 		int enable = p->enable != 0;
 		int isSecondary = p->isSecondary != 0;
 
@@ -1738,8 +1732,6 @@ int SetDecWriteProtectRegions(CodecInst *inst)
 			    p->startAddress >> 12); // round down
 		VpuWriteReg(inst->coreIdx, wprotEnd,
 			    (p->endAddress + 0xFFF) >> 12); // round up
-		//VLOG(TRACE, "core=%d, inst=%d, region=%d, enable=%d, start=0x%x, end=0x%x\n",
-		//inst->coreIdx, inst->instIndex, i, enable, p->startAddress, p->endAddress);
 		wprotStart += 8;
 		wprotEnd += 8;
 	}
@@ -2034,13 +2026,6 @@ Int32 ConfigSecAXICoda9(Uint32 coreIdx, Int32 codecMode, SecAxiInfo *sa,
 			return 0;
 	}
 
-#if 1 //Fuchun 20140415 workaround for H264 4K2K
-	//if (codecMode == AVC_DEC && MbNumX > 240) //width > 3840
-	//{
-	//    VLOG(TRACE, "== In[%s][%d]  workaround for H264 4096x2304, fix later ==\n", __FUNCTION__, __LINE__);
-	//    sa->u.coda9.useIpEnable = 0;
-	//}
-	// for Hank
 	if (codecMode == AVC_DEC && MbNumX >= 240) // width >= 3840
 	{
 		sa->u.coda9.useBitEnable = 1;
@@ -2061,7 +2046,6 @@ Int32 ConfigSecAXICoda9(Uint32 coreIdx, Int32 codecMode, SecAxiInfo *sa,
 		sa->u.coda9.useDbkCEnable = 0;
 		sa->u.coda9.useIpEnable = 0;
 	}
-#endif
 
 	sa->bufBase = vb.phys_addr;
 	offset = 0;
@@ -2344,7 +2328,6 @@ Int32 ConfigSecAXIWave(Uint32 coreIdx, Int32 codecMode, SecAxiInfo *sa,
 {
 	vpu_buffer_t vb;
 	int offset;
-	//Uint32 size = 0;
 	Uint32 lumaSize;
 	Uint32 chromaSize;
 	Uint32 productId;
@@ -2399,88 +2382,6 @@ Int32 ConfigSecAXIWave(Uint32 coreIdx, Int32 codecMode, SecAxiInfo *sa,
 
 	sa->bufBase = vb.phys_addr;
 	offset = 0;
-#if 0
-    /* Intra Prediction */
-    if (sa->u.wave4.useIpEnable == TRUE) {
-        sa->u.wave4.bufIp = sa->bufBase + offset;
-
-        switch (productId) {
-        case PRODUCT_ID_420L:
-                lumaSize   = (VPU_ALIGN16(width)*10+127)/128*128/8;
-                chromaSize = (VPU_ALIGN16(width)*10+127)/128*128/8;
-            break;
-        default:
-            return 0;
-        }
-
-        offset     = lumaSize + chromaSize;
-        if (offset > vb.size) {
-            sa->bufSize = 0;
-            return 0;
-        }
-    }
-
-    /* Loopfilter row */
-    if (sa->u.wave4.useLfRowEnable == TRUE) {
-        sa->u.wave4.bufLfRow = sa->bufBase + offset;
-        if ( codecMode == W_VP9_DEC ) {
-            if ( profile == VP9_PROFILE_2)
-            {
-                lumaSize   = VPU_ALIGN64(width) * 8 * 10/8; /* lumaLIne   : 8 */
-                chromaSize = VPU_ALIGN64(width) * 8 * 10/8; /* chromaLine : 8 */
-                //lumaSize *= 2; /* This one is for AFBC */
-            }
-            else
-            {
-                lumaSize   = VPU_ALIGN64(width) * 8; /* lumaLIne   : 8 */
-                chromaSize = VPU_ALIGN64(width) * 8; /* chromaLine : 8 */
-                //lumaSize *= 2; /* This one is for AFBC */
-            }
-            offset += lumaSize+chromaSize;
-        }
-        else {
-            Uint32 level = levelIdc/30;
-            if (level >= 5) {
-                size = VPU_ALIGN32(width)/2 * 13 + VPU_ALIGN64(width)*4;
-            }
-            else {
-                size = VPU_ALIGN64(width)*13;
-            }
-            offset += size;
-        }
-        if (offset > vb.size) {
-            sa->bufSize = 0;
-            return 0;
-        }
-    }
-
-    if (sa->u.wave4.useBitEnable == TRUE) {
-        sa->u.wave4.bufBit = sa->bufBase + offset;
-        if (codecMode == W_VP9_DEC) {
-            size = VPU_ALIGN64(width)/64 * (70*8);
-        }
-        else {
-            size = 34*1024; /* Fixed size */
-        }
-        offset += size;
-        if (offset > vb.size) {
-            sa->bufSize = 0;
-            return 0;
-        }
-    }
-
-    if (sa->u.wave4.useEncImdEnable == TRUE) {
-        /* Main   profile(8bit) : Align32(picWidth)
-         * Main10 profile(10bit): Align32(picWidth)
-         */
-        sa->u.wave4.bufImd = sa->bufBase + offset;
-        offset    += VPU_ALIGN32(width);
-        if (offset > vb.size) {
-            sa->bufSize = 0;
-            return 0;
-        }
-    }
-#endif
 	if (sa->u.wave4.useEncLfEnable == TRUE) {
 		/* Main   profile(8bit) :
          *              Luma   = Align64(picWidth) * 5
@@ -2512,10 +2413,6 @@ Int32 ConfigSecAXIWave(Uint32 coreIdx, Int32 codecMode, SecAxiInfo *sa,
 
 	if (sa->u.wave4.useEncRdoEnable == TRUE) {
 		switch (productId) {
-		/*case PRODUCT_ID_520:
-            sa->u.wave4.bufRdo = sa->bufBase + offset;
-            offset += 288* VPU_ALIGN64(width)/64;
-            break;*/
 		default:
 			/* Main   profile(8bit) : (Align64(picWidth)/64) * 336
             * Main10 profile(10bit): (Align64(picWidth)/64) * 336
@@ -3693,7 +3590,6 @@ PhysicalAddress GetTiledFrameBase(Uint32 coreIdx, FrameBuffer *frame, int num)
 
 void SetTiledFrameBase(Uint32 coreIdx, PhysicalAddress baseAddr)
 {
-	//VLOG(TRACE, "[%d]%s.VpuWriteReg GDI_TILEDBUF_BASE.baseAddr:0x%08x\n",__LINE__,__func__,baseAddr);
 	VpuWriteReg(coreIdx, GDI_TILEDBUF_BASE, baseAddr);
 }
 
@@ -3721,7 +3617,6 @@ static int SetTiledMapTypeV10(Uint32 coreIdx, TiledMapConfig *pMapCfg,
 
 	UNREFERENCED_PARAMETER(stride);
 	pMapCfg->mapType = mapType;
-	//         inv = 1'b0, zero = 1'b1 , tbxor = 1'b0, xy = 1'b0, bit = 4'd0
 	luma_map = 64;
 	chro_map = 64;
 
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapifunc.h b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapifunc.h
index 2d2071b991bb..2d6837b151d2 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapifunc.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_vpuapifunc.h
@@ -243,10 +243,7 @@ typedef struct {
 	DRAMConfig dramCfg; //coda960 only
 	int thumbnailMode;
 	int seqChangeMask; // WAVE410
-	//#ifdef FIX_SET_GET_RD_PTR_BUG
-	//#else
 	Uint32 prevFrameEndPos; //!<< WAVE410v2: end position of previous frame
-	//#endif
 	BOOL scalerEnable;
 	Uint32 scaleWidth;
 	Uint32 scaleHeight;
@@ -254,10 +251,7 @@ typedef struct {
 
 	BOOL enableAfbce;
 	Int32 afbceFormat;
-	//#ifdef FIX_SET_GET_RD_PTR_BUG
-	//#else
 	int rdPtrValidFlag;
-	//#endif
 
 	Int32 instanceQueueCount;
 	Int32 totalQueueCount;
@@ -643,9 +637,7 @@ void FreeCodecInstance(CodecInst *pCodecInst);
 
 RetCode CheckDecOpenParam(DecOpenParam *pop);
 int DecBitstreamBufEmpty(DecInfo *pDecInfo);
-/*#ifdef DRAM_TEST  [r] Is this necessary?
-RetCode ExecDRAMReadWriteTest(Uint32 coreIdx, Uint32* dram_source_addr, Uint32* dram_destination_addr, Uint32* dram_data_size);
-#endif*/
+
 RetCode SetParaSet(DecHandle handle, int paraSetType, DecParamSet *para);
 void DecSetHostParaAddr(Uint32 coreIdx, PhysicalAddress baseAddr,
 			PhysicalAddress paraAddr);
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_wrapper.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_wrapper.c
index 58cc47284930..b60b802e7a9f 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_wrapper.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_wrapper.c
@@ -10,7 +10,6 @@
 #include "ve1_vpuapifunc.h"
 #include "ve1_wrapper.h"
 #include "ve1_v4l2.h"
-//#include "../puwrap.h"
 #include "ve1_mem.h"
 #include "drv_if.h"
 #include "vpu.h"
@@ -36,7 +35,6 @@ static unsigned char ve1_md5_digest[VE1_MD5_DIGEST_SIZE];
 
 #include <linux/dma-map-ops.h>
 #include <soc/realtek/memory.h>
-#include <soc/realtek/rtk_media_heap.h>
 
 #define IS_4K(w, h) (((w) * (h)) > (3200 * 1800))
 #define MAX_CHUNK_HEADER_SIZE                                                  \
@@ -64,7 +62,6 @@ extern int ta_TEEapi_OMX_CC_API(struct tee_context *teeapi_ctx,
 				unsigned int src_addr, unsigned char *dst_addr,
 				unsigned int size, unsigned int codec_type,
 				unsigned int mode);
-static DEFINE_MUTEX(ve1_dma_mutex);
 
 extern unsigned int vpu_debug;
 
@@ -106,47 +103,7 @@ int ParseUserDataInfo(USER_DATA_INFO *pUserDataInfo, char *pUserDataBuf)
 		pUserDataInfo->nUserDataSize[i] =
 			(short)((pTmpBuf[2] << 8) | (pTmpBuf[3] << 0));
 		pUserDataInfo->nUserDataOffset[i] = offset;
-		//TRACE_CC("user_data[%d]: type %d size %d\n", i, pUserDataInfo->nUserDataType[i], pUserDataInfo->nUserDataSize[i]);
-#if 0 //def DBG_MPEG2_DUMP_ORIGINAL_USER_DATA, TODO:
-        {
-            char temp_str[128];
-            FILE* fp = fopen("/tmp/UserData_omx.txt", "a+");
-            memset(temp_str,0,128);
-            if(pUserDataBuf[offset+3] == 'G' && pUserDataBuf[offset+4] == 'A' && pUserDataBuf[offset+5] == '9' && pUserDataBuf[offset+6] == '4')
-            {
-                sprintf(temp_str,"user_data[%d]: type %d size %d serial %d\n",i, pUserDataInfo->nUserDataType[i], pUserDataInfo->nUserDataSize[i], pUserDataBuf[offset+8]);
-                //pUserDataBuf[offset+8] = 0xD4;
-            }
-            else
-            {
-                sprintf(temp_str,"user_data[%d]: type %d size %d\n",i, pUserDataInfo->nUserDataType[i], pUserDataInfo->nUserDataSize[i]);
-            }
-            fwrite(temp_str, strlen(temp_str), 1, fp);
-            //fwrite(pUserDataBuf+offset, pUserDataInfo->nUserDataSize[i], 1, fp);
-            for(int j=0 ; j<pUserDataInfo->nUserDataSize[i] ; j++)
-            {
-                memset(temp_str,0,128);
-                sprintf(temp_str,"%x ",pUserDataBuf[offset+j]);
-                fwrite(temp_str, strlen(temp_str), 1, fp);
-            }
-            temp_str[0] = '\n';
-            temp_str[1] = 0;
-            fwrite(temp_str, strlen(temp_str), 1, fp);
-            fclose(fp);
-        }
-#endif
 
-#if 0
-        {
-            int word, j;
-            for(j=0 ; j<pUserDataInfo->nUserDataSize[i] ; j += 4)
-            {
-                memcpy(&word, pUserDataBuf + offset + j, 4);
-                word = ENDIAN_CHANGE(word);
-                ALOGD("[%d]: %08x\n", j, word);
-            }
-        }
-#endif
 		offset += (pUserDataInfo->nUserDataSize[i] + 7) / 8 * 8;
 		ret++;
 	}
@@ -176,14 +133,14 @@ void FindH264CCInUserData(USER_DATA_INFO *pUserDataInfo, char *pUserDataBuf,
 			pCCdata = (pUserDataBuf +
 				   pUserDataInfo->nUserDataOffset[i]);
 			if (pCCdata[0] != itu_t_t35_country_code) {
-				ve1_err(VE1_WRAPPER_TAG, "[H264 CC] ERR @ %s %d\n",
-					__func__, __LINE__);
+				ve1_err(VE1_WRAPPER_TAG,
+					"[H264 CC] ERR @ %s %d\n", __func__,
+					__LINE__);
 				continue;
 			}
 			itu_t_t35_provider_code =
 				(short)((pCCdata[1] << 8) |
 					(pCCdata[2])); // ARM is little-endian
-			//TRACE_CC("[%s] itu_t_t35_provider_code %d pCCdata: %x %x %x %x %x\n", __FUNCTION__, itu_t_t35_provider_code, pCCdata[3], pCCdata[4], pCCdata[5], pCCdata[6], pCCdata[7]);
 
 			switch (itu_t_t35_provider_code) {
 			case 47: // Direct TV
@@ -272,7 +229,6 @@ void FindMpeg2CCInUserData(USER_DATA_INFO *pUserDataInfo, char *pUserDataBuf,
 
 	for (i = 0; i < pUserDataInfo->nUserDataNum; ++i) {
 		p = pUserDataBuf + pUserDataInfo->nUserDataOffset[i];
-		//TRACE_CC("[%s] p: %x %x %x %x\n", __FUNCTION__, *(char *)(p), *(char *)(p +1), *(char *)(p +2), *(char *)(p +3));
 
 		if (p[0] == 'G' && p[1] == 'A' && p[2] == '9' && p[3] == '4') {
 			int *packet_start = (int *)dst;
@@ -390,25 +346,18 @@ void ProcessCC_Display(void *pCtx, long long PTS,
 	if (display_index >= 0 &&
 	    ctx->m_CCDecodeOrderWp[display_index] != NULL) {
 		int *header = (int *)ctx->m_CCDecodeOrderWp[display_index];
-		//if (cc_control_sk == NULL) {
-		//printk("err, cc_control_sk =NULL/n");
-		//cc_control_channel_init();
-		//}
 
 		if (cc_isCCInit()) {
 			ve1_err(VE1_WRAPPER_TAG, " cc_isCCInit = false/n");
 			cc_data_channel_init();
 		}
-		//ve1_err(VE1_WRAPPER_TAG, " header %x %x\n", header, ctx->m_CCDecodeOrderWp[display_index]);
 		// send data back to AP via fifo
 		if (cc_isCCReaderReady()) {
 			int total_size;
 			long long *pRTKHeader;
 			char *check;
 
-			//ve1_err(VE1_WRAPPER_TAG, "\n");
 			if (header[0] != CC_MAGIC_NUMBER) {
-				//ve1_err(VE1_WRAPPER_TAG, "Not CC_MAGIC_NUMBER\n");
 				return;
 			}
 
@@ -452,7 +401,6 @@ void ProcessCC_Display(void *pCtx, long long PTS,
 			}
 		}
 		// reset rtk header
-		//ve1_err(VE1_WRAPPER_TAG, "reset rtk header\n");
 		for (i = 0; i < RTK_CC_HEADER_SIZE + 72; i++)
 			ctx->m_CCDecodeOrderWp[display_index][i] = 0;
 	}
@@ -465,7 +413,6 @@ int ve1_md5_hash(unsigned char *result, int resultLen, char *data, int dataLen)
 	int ret = 0;
 	struct crypto_shash *tfm = NULL;
 	struct shash_desc *desc = NULL;
-	//unsigned int digest_size;
 
 	if ((result == NULL) || (resultLen <= 0) || (data == NULL) ||
 	    (dataLen <= 0)) {
@@ -491,17 +438,7 @@ int ve1_md5_hash(unsigned char *result, int resultLen, char *data, int dataLen)
 	}
 
 	desc->tfm = tfm;
-	//desc->flags = 0;
-
-	/*
-    digest_size = crypto_shash_digestsize(desc->tfm);
-    ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "resultLen:%d.digest_size:%d\n",resultLen,digest_size);
-    if (resultLen < digest_size)
-    {
-        ve1_err(VE1_WRAPPER_TAG, "resultLen:%d < digest_size:%d\n",resultLen,digest_size);
-        return -1;
-    }
-*/
+
 	if (crypto_shash_init(desc) < 0) {
 		ve1_err(VE1_WRAPPER_TAG, "crypto_shash_init() fail\n");
 		ret = -1;
@@ -541,6 +478,43 @@ int ve1_md5_hash(unsigned char *result, int resultLen, char *data, int dataLen)
 }
 #endif // #if defined(VE1_CHECK_DFB_MD5_EN)
 
+void rtkve1_recycle_dpb(struct ve1_ctx *ctx)
+{
+	int i = 0;
+	struct rtkve1_dpb_t *dpb = NULL;
+
+	if (ctx == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx == NULL\n");
+		return;
+	}
+
+	if (ctx->decHandle == NULL) {
+		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
+		return;
+	}
+
+	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
+		dpb = &(ctx->dpb[i]);
+		if (IS_RTKVE1_DPB_VALID(dpb->status) && IS_RTKVE1_DPB_WAIT_RECYCLE(dpb->status)) {
+			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+				"i:%d.status:0x%x\n",
+				i,dpb->status);
+			dpb->status &= ~RTKVE1_DPB_ST_WAIT_RECYCLE;
+			if (dpb->regIndex < ctx->regFbCount) {
+				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
+					"VPU_DecClrDispFlag(%d).phys_addr:0x%lx\n",
+					dpb->regIndex, dpb->phys_addr);
+				VPU_DecClrDispFlag((DecHandle)ctx->decHandle, dpb->regIndex);
+			}
+			else {
+				ve1_err(VE1_WRAPPER_TAG,
+					"invalid dpb regIndex:%d, not recycle.phys_addr:0x%lx\n",
+					dpb->regIndex, dpb->phys_addr);
+			}
+		}
+	}
+}
+
 int rtkve1_add_capbuf_to_dpb(void *pCtx, unsigned long size,
 			     unsigned long phys_addr, void *vb2_v4l2_buf)
 {
@@ -558,14 +532,15 @@ int rtkve1_add_capbuf_to_dpb(void *pCtx, unsigned long size,
 	}
 	ctx = (struct ve1_ctx *)pCtx;
 
-	mutex_lock(&ve1_dma_mutex);
+	mutex_lock(&ctx->ve1_dma_mutex);
 	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
 		if (IS_RTKVE1_DPB_EMPTY(ctx->dpb[i].status)) {
 			break;
 		}
 	}
 	if (i == VE1_ION_STRUCT_NUM) {
-		ve1_err(VE1_WRAPPER_TAG, "all ve1_ion_buffer[] are used\n");
+		ve1_err(VE1_WRAPPER_TAG, "all ctx->dpb[] are used\n");
+		mutex_unlock(&ctx->ve1_dma_mutex);
 		return ret;
 	}
 	ctx->dpb[i].size = size;
@@ -578,7 +553,7 @@ int rtkve1_add_capbuf_to_dpb(void *pCtx, unsigned long size,
 		i, ctx->dpb[i].phys_addr, ctx->dpb[i].size,
 		ctx->dpb[i].vb2_v4l2_buf, ctx->cntCap2Dpb);
 	ret = i;
-	mutex_unlock(&ve1_dma_mutex);
+	mutex_unlock(&ctx->ve1_dma_mutex);
 
 	return ret;
 }
@@ -595,7 +570,7 @@ void rtkve1_make_undq_capbuf_done(void *pCtx)
 	}
 	ctx = (struct ve1_ctx *)pCtx;
 
-	mutex_lock(&ve1_dma_mutex);
+	mutex_lock(&ctx->ve1_dma_mutex);
 	for (i = 0; i < ctx->cntCap2Dpb; i++) {
 		if (!IS_RTKVE1_DPB_DQ(ctx->dpb[i].status) &&
 		    IS_RTKVE1_DPB_VALID(ctx->dpb[i].status)) {
@@ -608,7 +583,7 @@ void rtkve1_make_undq_capbuf_done(void *pCtx)
 					  VB2_BUF_STATE_ERROR);
 		}
 	}
-	mutex_unlock(&ve1_dma_mutex);
+	mutex_unlock(&ctx->ve1_dma_mutex);
 }
 
 int ve1_alloc_frame_buffer(void *pCtx, unsigned int size,
@@ -625,7 +600,7 @@ int ve1_alloc_frame_buffer(void *pCtx, unsigned int size,
 	}
 	ctx = (struct ve1_ctx *)pCtx;
 
-	mutex_lock(&ve1_dma_mutex);
+	mutex_lock(&ctx->ve1_dma_mutex);
 	do {
 		int i = 0;
 		unsigned int flags = 0;
@@ -636,11 +611,9 @@ int ve1_alloc_frame_buffer(void *pCtx, unsigned int size,
 		if (ctx->is_svp) {
 			flags = RTK_FLAG_NONCACHED | RTK_FLAG_HWIPACC |
 				RTK_FLAG_PROTECTED_V2_VO_POOL;
-			//ve1_dbg(VE1_WRAPPER_TAG, "svp.flags:0x%x\n",flags);
 		} else {
 			flags = RTK_FLAG_NONCACHED | RTK_FLAG_HWIPACC |
 				RTK_FLAG_SCPUACC;
-			//ve1_dbg(VE1_WRAPPER_TAG, "nonsvp.flags:0x%x\n",flags);
 		}
 
 		for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
@@ -654,8 +627,10 @@ int ve1_alloc_frame_buffer(void *pCtx, unsigned int size,
 			break;
 		}
 
-		rheap_setup_dma_pools(ctx->pdev, "rtk_media_heap", flags,
-				      __func__);
+		/* We can't limit the address from dma_alloc_coherent when size <= 4096 */
+		if (size < SZ_8K)
+			size = SZ_8K;
+
 		virt_addr = dma_alloc_coherent(ctx->pdev, PAGE_ALIGN(size),
 					       &dma_phys_addr,
 					       (GFP_DMA | GFP_KERNEL));
@@ -674,9 +649,6 @@ int ve1_alloc_frame_buffer(void *pCtx, unsigned int size,
 		ctx->dpb[i].phys_addr = (unsigned long)*phys_addr;
 		ctx->dpb[i].virt_addr = (unsigned long)virt_addr;
 
-		//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "slot_i:%d.phys_addr:0x%lx.virt_addr:0x%lx.size:%d(%d).tot:%d\n",i
-		//    ,ctx->dpb[i].phys_addr,ctx->dpb[i].virt_addr,PAGE_ALIGN(size),size,ctx->totIonAllocatedBytes);
-
 		// register dpb[i] to ve1_mem
 		entry = kzalloc(sizeof(ve1_mem_reg_entry_t), GFP_KERNEL);
 		if (entry) {
@@ -684,7 +656,6 @@ int ve1_alloc_frame_buffer(void *pCtx, unsigned int size,
 			entry->phys_addr = ctx->dpb[i].phys_addr;
 			entry->addr = (void *) ctx->dpb[i].virt_addr;
 			entry->size = ctx->dpb[i].size;
-			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "ve1_mem_reg_add.slot_i:%d.dev:0x%px.phys_addr:0x%lx.virt_addr:0x%px.size:%ld\n",i,entry->dev,entry->phys_addr,entry->addr,entry->size);
 			ve1_mem_reg_add(entry);
 			ctx->dpb[i].reg_entry = (void *)entry;
 		}
@@ -692,7 +663,7 @@ int ve1_alloc_frame_buffer(void *pCtx, unsigned int size,
 		ret = i;
 		break;
 	} while (0);
-	mutex_unlock(&ve1_dma_mutex);
+	mutex_unlock(&ctx->ve1_dma_mutex);
 
 	return ret;
 }
@@ -700,7 +671,6 @@ int ve1_alloc_frame_buffer(void *pCtx, unsigned int size,
 void ve1_free_frame_buffer(void *pCtx, unsigned long phys_addr)
 {
 	struct ve1_ctx *ctx;
-//	struct ion_client *ve1_client;
 
 	if ((pCtx == NULL) || (phys_addr == 0)) {
 		ve1_err(VE1_WRAPPER_TAG,
@@ -710,7 +680,7 @@ void ve1_free_frame_buffer(void *pCtx, unsigned long phys_addr)
 	}
 	ctx = (struct ve1_ctx *)pCtx;
 
-	mutex_lock(&ve1_dma_mutex);
+	mutex_lock(&ctx->ve1_dma_mutex);
 	do {
 		int i = 0;
 
@@ -726,8 +696,6 @@ void ve1_free_frame_buffer(void *pCtx, unsigned long phys_addr)
 		}
 
 		if (ctx->dpb[i].reg_entry) {
-			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "ve1_mem_reg_remove.slot_i:%d.phys_addr:0x%lx.virt_addr:0x%lx.size:%ld\n",i,
-			//    ctx->dpb[i].phys_addr,ctx->dpb[i].virt_addr,ctx->dpb[i].size);
 			ve1_mem_reg_remove(phys_addr);
 			kfree(ctx->dpb[i].reg_entry);
 		}
@@ -739,11 +707,9 @@ void ve1_free_frame_buffer(void *pCtx, unsigned long phys_addr)
 			ctx->totIonAllocatedBytes -= ctx->dpb[i].size;
 		}
 
-		//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "slot_i:%d.phys_addr:0x%lx.virt_addr:0x%lx.size:%d.tot:%d\n",i,
-		//    ctx->dpb[i].phys_addr,ctx->dpb[i].virt_addr,ctx->dpb[i].size,ctx->totIonAllocatedBytes);
 		memset(&ctx->dpb[i], 0, sizeof(struct rtkve1_dpb_t));
 	} while (0);
-	mutex_unlock(&ve1_dma_mutex);
+	mutex_unlock(&ctx->ve1_dma_mutex);
 }
 
 #ifdef VPU_GET_CC
@@ -914,7 +880,6 @@ int VE1_DecInit(void *pCtx)
 
 	return ret;
 }
-//EXPORT_SYMBOL(VE1_DecInit);
 
 int VE1_DecOpen(void *pCtx, void *pParam)
 {
@@ -960,6 +925,12 @@ int VE1_DecOpen(void *pCtx, void *pParam)
 	case V4L2_PIX_FMT_VP8:
 		codec_type = STD_VP8;
 		break;
+	case V4L2_PIX_FMT_VC1_ANNEX_G:
+		codec_type = STD_VC1;
+		break;
+	case V4L2_PIX_FMT_VC1_ANNEX_L:
+		codec_type = STD_VC1;
+		break;
 	case V4L2_PIX_FMT_H264:
 	default:
 		codec_type = STD_AVC;
@@ -975,7 +946,6 @@ int VE1_DecOpen(void *pCtx, void *pParam)
 		 "bitstreamBuffer:0x%x.bitstreamBufferSize:%d\n",
 		 pDecOp->bitstreamBuffer, pDecOp->bitstreamBufferSize);
 	pDecOp->avcExtension = 0;
-	//pDecOp->bitstreamMode = BS_MODE_INTERRUPT;
 	pDecOp->bitstreamMode = BS_MODE_PIC_END;
 
 	if (param->dst_fmt_fourcc == V4L2_PIX_FMT_NV21 ||
@@ -990,8 +960,6 @@ int VE1_DecOpen(void *pCtx, void *pParam)
 		(char *)&param->src_fmt_fourcc, (char *)&param->dst_fmt_fourcc,
 		pDecOp->cbcrInterleave, pDecOp->nv21);
 
-	//pDecOp->cbcrInterleave = 1;
-	//pDecOp->nv21 = 1;
 	pDecOp->cbcrOrder = CBCR_ORDER_NORMAL;
 	pDecOp->frameEndian = VPU_FRAME_ENDIAN;
 	pDecOp->streamEndian = VPU_STREAM_ENDIAN;
@@ -1107,7 +1075,6 @@ int VE1_DecOpen(void *pCtx, void *pParam)
 #endif
 	return ret;
 }
-//EXPORT_SYMBOL(VE1_DecOpen);
 
 int VE1_DecGetRdWrPtr(void *pCtx)
 {
@@ -1131,14 +1098,10 @@ int VE1_DecGetRdWrPtr(void *pCtx)
 				(DecHandle)ctx->decHandle, &ctx->vpuRdPtr,
 				&ctx->vpuWrPtr, &ctx->vpuBsRingRoom);
 		}
-		//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-		//	"af VPU_DecGetBitstreamBuffer.ret:%d.r:0x%x.w:0x%x.z:%d\n",
-		//	ret, ctx->vpuRdPtr, ctx->vpuWrPtr, ctx->vpuBsRingRoom);
 	}
 
 	return ret;
 }
-//EXPORT_SYMBOL(VE1_DecGetRdWrPtr);
 
 int VE1_SetStreamEnd(void *pCtx)
 {
@@ -1159,18 +1122,15 @@ int VE1_SetStreamEnd(void *pCtx)
 	ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
 					   STREAM_END_SIZE);
 	ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-		"tgid(%d,%d,%s).af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-		current->tgid, current->pid, current->comm, ret,
-		STREAM_END_SIZE, ctx->accuBsFeedBytes);
+		"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+		ret, STREAM_END_SIZE, ctx->accuBsFeedBytes);
 	return ret;
 }
-//EXPORT_SYMBOL(VE1_SetStreamEnd);
 
 int VE1_DecSeqInit(void *pCtx)
 {
 	RetCode ret = RETCODE_SUCCESS;
 	struct ve1_ctx *ctx;
-	//BOOL seqInitEscape = TRUE;
 	BOOL seqInitEscape = FALSE;
 	int int_reason;
 	int bSeqInited = 0;
@@ -1192,7 +1152,6 @@ int VE1_DecSeqInit(void *pCtx)
 
 	VE1_DecGetRdWrPtr(ctx);
 	if (((DecOpenParam *)ctx->decOP)->bitstreamMode == BS_MODE_INTERRUPT) {
-		//VE1_DecGetRdWrPtr(ctx);
 		valid_data = ve1_ring_valid_data(ctx->bitstream.paddr,
 						 ctx->bitstream.paddr +
 							 ctx->bitstream.size,
@@ -1296,7 +1255,6 @@ int VE1_DecSeqInit(void *pCtx)
 	waitSeqInitDone:
 		while (1) {
 			int_reason = VPU_WaitInterrupt(VE1_COREIDX, 10);
-			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "af VPU_WaitInterrupt.int_reason:%d\n",int_reason);
 			if (int_reason == -1) {
 				int_reason = 0;
 			}
@@ -1373,7 +1331,6 @@ int VE1_DecSeqInit(void *pCtx)
 
 	return ret;
 }
-//EXPORT_SYMBOL(VE1_DecSeqInit);
 
 int VE1_DecAllocateFrameBuffers(void *pCtx)
 {
@@ -1389,7 +1346,6 @@ int VE1_DecAllocateFrameBuffers(void *pCtx)
 	FrameBufferAllocInfo *fbAllocInfo;
 	FrameBuffer *fbUser;
 	int i;
-//	bool bWtlEnable = true;
 	SecAxiUse *secAxiUse;
 	MaverickCacheConfig *decCacheConfig;
 
@@ -1425,22 +1381,7 @@ int VE1_DecAllocateFrameBuffers(void *pCtx)
 	decOP = (DecOpenParam *)ctx->decOP;
 	initialInfo = (DecInitialInfo *)ctx->initialInfo;
 	fbAllocInfo = (FrameBufferAllocInfo *)ctx->fbAllocInfo;
-/*
-	if ((decOP->bitstreamFormat == STD_AVC) &&
-	    IS_4K(initialInfo->picWidth, initialInfo->picHeight))
-	{
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			"H264 4K(%dx%d).use TILED_FRAME_V_MAP\n",
-			initialInfo->picWidth, initialInfo->picHeight);
-		mapType = TILED_FRAME_V_MAP;
-		if (bWtlEnable) {
-			decOP->wtlEnable = 1;
-			decOP->wtlMode = FF_FRAME;
-			VPU_DecGiveCommand((DecHandle)ctx->decHandle,
-					   DEC_SET_WTL_MODE, decOP);
-		}
-	}
-*/
+
 	fbFormat = FORMAT_420;
 	wtlFormat = FORMAT_420;
 
@@ -1471,7 +1412,8 @@ int VE1_DecAllocateFrameBuffers(void *pCtx)
 		return -1;
 	}
 
-	if (ctx->cntCap2Dpb < (initialInfo->minFrameBufferCount + EXTRA_DEC_PIC_BUF)) {
+	if (ctx->cntCap2Dpb <
+	    (initialInfo->minFrameBufferCount + EXTRA_DEC_PIC_BUF)) {
 		ve1_err(VE1_WRAPPER_TAG,
 			"cap_qbuf count:%d < expected dpb count:%d\n",
 			ctx->cntCap2Dpb,
@@ -1493,7 +1435,6 @@ int VE1_DecAllocateFrameBuffers(void *pCtx)
 
 	fbAllocInfo->format = fbFormat;
 	fbAllocInfo->cbcrInterleave = decOP->cbcrInterleave;
-	//fbAllocInfo->nv21               = decOP->nv21;
 	fbAllocInfo->mapType = mapType;
 	fbAllocInfo->stride = fbStride;
 	fbAllocInfo->height = fbHeight;
@@ -1505,12 +1446,12 @@ int VE1_DecAllocateFrameBuffers(void *pCtx)
 
 	for (i = 0; i < ctx->regFbCount; i++) {
 		fbUser = ((FrameBuffer *)ctx->fbUser) + i;
+		ctx->dpb[i].regIndex = i;
 		fbUser->size = ctx->dpb[i].size;
 		fbUser->bufY = ctx->dpb[i].phys_addr;
 		fbUser->bufCb = -1;
 		fbUser->bufCr = -1;
 		fbUser->updateFbInfo = TRUE;
-		//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "fbUser[%d].bufY:0x%x.size:%d.myIndex:%d.stride:%d.h:%d.seqNo:%d.tot:%d\n",i,fbUser->bufY,fbUser->size,fbUser->myIndex,fbUser->stride,fbUser->height,ctx->currSequenceNo,ctx->totIonAllocatedBytes);
 	}
 
 	ret = VPU_DecAllocateFrameBuffer((DecHandle)ctx->decHandle,
@@ -1595,14 +1536,12 @@ int VE1_DecAllocateFrameBuffers(void *pCtx)
 
 	return ret;
 }
-//EXPORT_SYMBOL(VE1_DecAllocateFrameBuffers);
 
 int VE1_DecStartDecode(void *pCtx)
 {
 	RetCode ret = RETCODE_SUCCESS;
 	struct ve1_ctx *ctx;
 	unsigned long valid_data = 0;
-//	bool queueRet = false;
 
 	if (pCtx == NULL) {
 		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
@@ -1627,33 +1566,34 @@ int VE1_DecStartDecode(void *pCtx)
 			       ctx->ve1DecState == VE1_STATE_DEC_PIC_DONE)) {
 		VE1_DecGetRdWrPtr(ctx);
 		if ((((DecOpenParam *)ctx->decOP)->bitstreamMode ==
-				BS_MODE_INTERRUPT) &&
-			(!ctx->streamEnd)) {
-			valid_data = ve1_ring_valid_data(ctx->bitstream.paddr,
-							ctx->bitstream.paddr +
-								ctx->bitstream.size,
-							ctx->vpuRdPtr, ctx->vpuWrPtr);
+		     BS_MODE_INTERRUPT) &&
+		    (!ctx->streamEnd)) {
+			valid_data = ve1_ring_valid_data(
+				ctx->bitstream.paddr,
+				ctx->bitstream.paddr + ctx->bitstream.size,
+				ctx->vpuRdPtr, ctx->vpuWrPtr);
 			if (valid_data < 1024) {
 				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
 					"valid data size:%ld < 1024.vpuRdPtr:0x%x.vpuWrPtr:0x%x\n",
-					valid_data, ctx->vpuRdPtr, ctx->vpuWrPtr);
+					valid_data, ctx->vpuRdPtr,
+					ctx->vpuWrPtr);
 				ctx->bBufEmptyFlag = true;
 				return ret;
 			}
 		} else if (((DecOpenParam *)ctx->decOP)->bitstreamMode ==
-			BS_MODE_PIC_END) {
-			if ((ctx->vpuRdPtr == ctx->vpuWrPtr) && (!ctx->streamEnd)) {
-				//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "no data for decoding.rp==wp:0x%x.streamEnd:%d\n",ctx->vpuWrPtr,ctx->streamEnd);
+			   BS_MODE_PIC_END) {
+			if ((ctx->vpuRdPtr == ctx->vpuWrPtr) &&
+			    (!ctx->streamEnd)) {
 				ctx->bBufEmptyFlag = true;
 				return ret;
 			}
 		}
 
+		rtkve1_recycle_dpb(ctx);
 		ret = VPU_DecStartOneFrame((DecHandle)ctx->decHandle,
 					   (DecParam *)ctx->decParam);
 		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			"tgid(%d,%d,%s).af VPU_DecStartOneFrame.ret:%d\n",
-			current->tgid, current->pid, current->comm, ret);
+			"af VPU_DecStartOneFrame.ret:%d\n", ret);
 		if (ret != RETCODE_SUCCESS) {
 			ve1_err(VE1_WRAPPER_TAG,
 				"VPU_DecStartOneFrame fail.ret:%d\n", ret);
@@ -1666,7 +1606,6 @@ int VE1_DecStartDecode(void *pCtx)
 
 	return ret;
 }
-//EXPORT_SYMBOL(VE1_DecStartDecode);
 
 int VE1_DecWaitPicDone(void *pCtx)
 {
@@ -1682,7 +1621,6 @@ int VE1_DecWaitPicDone(void *pCtx)
 
 	while (1) {
 		ctx->int_reason = VPU_WaitInterrupt(VE1_COREIDX, 10);
-		//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "af VPU_WaitInterrupt.int_reason:%d\n",ctx->int_reason);
 		if (ctx->int_reason == -1) {
 			ctx->int_reason = 0;
 			ctx->timeoutCount++;
@@ -1719,9 +1657,8 @@ int VE1_DecWaitPicDone(void *pCtx)
 			if (ctx->int_reason & (1 << INT_BIT_PIC_RUN)) {
 				VPU_ClearInterrupt(VE1_COREIDX);
 				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"tgid(%d,%d,%s).INT_BIT_PIC_RUN(0x%x)\n",
-					current->tgid, current->pid,
-					current->comm, ctx->int_reason);
+					"INT_BIT_PIC_RUN(0x%x)\n",
+					ctx->int_reason);
 				ctx->int_reason = 0;
 				bPicDone = 1;
 			} else if (ctx->int_reason &
@@ -1731,22 +1668,18 @@ int VE1_DecWaitPicDone(void *pCtx)
 				ctx->bufEmptyVpuWrPtr = ctx->vpuWrPtr;
 				ctx->bBufEmptyFlag = true;
 				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"tgid(%d,%d,%s).INT_BIT_BIT_BUF_EMPTYY(0x%x).bufEmptyVpuWrPtr:0x%x\n",
-					current->tgid, current->pid,
-					current->comm, ctx->int_reason,
-					ctx->bufEmptyVpuWrPtr);
+					"INT_BIT_BIT_BUF_EMPTYY(0x%x).bufEmptyVpuWrPtr:0x%x\n",
+					ctx->int_reason, ctx->bufEmptyVpuWrPtr);
 			} else if (ctx->int_reason & (1 << INT_BIT_DEC_FIELD)) {
 				VE1_DecGetRdWrPtr(ctx);
 				ctx->bWaitNextField = true;
 				ctx->bGotNextField = false;
 				ctx->fldDoneVpuRp = ctx->vpuRdPtr;
 				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-					"tgid(%d,%d,%s).INT_BIT_DEC_FIELD(0x%x).bWaitNextField.frmNum:%u.fld_rp:0x%x.vpu(0x%x,0x%x)\n",
-					current->tgid, current->pid,
-					current->comm, ctx->int_reason,
-					ctx->decodedFrmNum, ctx->fldDoneVpuRp,
-					ctx->vpuRdPtr, ctx->vpuWrPtr);
-
+					"INT_BIT_DEC_FIELD(0x%x).bWaitNextField.frmNum:%u.fld_rp:0x%x.vpu(0x%x,0x%x)\n",
+					ctx->int_reason, ctx->decodedFrmNum,
+					ctx->fldDoneVpuRp, ctx->vpuRdPtr,
+					ctx->vpuWrPtr);
 			}
 			break;
 		}
@@ -1754,7 +1687,6 @@ int VE1_DecWaitPicDone(void *pCtx)
 
 	return bPicDone;
 }
-//EXPORT_SYMBOL(VE1_DecWaitPicDone);
 
 void *rtkve1_find_dpb(void *pCtx, unsigned long dpb_paddr)
 {
@@ -1768,7 +1700,6 @@ void *rtkve1_find_dpb(void *pCtx, unsigned long dpb_paddr)
 	ctx = (struct ve1_ctx *)pCtx;
 
 	for (i = 0; i < VE1_ION_STRUCT_NUM; i++) {
-		//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "dpb_paddr:0x%lx.dpb[%d].status:0x%x.phys_addr:0x%lx\n",dpb_paddr,i,ctx->dpb[i].status,ctx->dpb[i].phys_addr);
 		if (IS_RTKVE1_DPB_VALID(ctx->dpb[i].status) &&
 		    (ctx->dpb[i].phys_addr == dpb_paddr)) {
 			return (void *)&(ctx->dpb[i]);
@@ -1809,6 +1740,7 @@ void VE1_UpdateDPBStatus(void *pCtx, unsigned int dpb_paddr,
 	}
 	dpb = (struct rtkve1_dpb_t *)tmp_dpb;
 
+	mutex_lock(&ctx->ve1_dma_mutex);
 	// recycle the frame buffer
 	if (IS_RTKVE1_DPB_VALID(status)) {
 		dpb->status &= ~RTKVE1_DPB_ST_DQ;
@@ -1830,7 +1762,7 @@ void VE1_UpdateDPBStatus(void *pCtx, unsigned int dpb_paddr,
 					ctx->totIonAllocatedBytes);
 			} else {
 				// normal case, call VPU_DecClrDispFlag() to recyle the frame buffer
-				VE1_SetFrameBufReusable(ctx, regIndex);
+				dpb->status |= RTKVE1_DPB_ST_WAIT_RECYCLE;
 				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
 					"dpb_paddr:0x%x.set status:0x%x.seq(%d,%d).regIndex:%d\n",
 					dpb_paddr, dpb->status, sequenceNo,
@@ -1858,6 +1790,7 @@ void VE1_UpdateDPBStatus(void *pCtx, unsigned int dpb_paddr,
 	} else {
 		ve1_err(VE1_WRAPPER_TAG, "invalid status:0x%x\n", status);
 	}
+	mutex_unlock(&ctx->ve1_dma_mutex);
 }
 
 void ve1_seq_change_free_fb(struct ve1_ctx *ctx)
@@ -1945,7 +1878,6 @@ int ve1_prepare_seq_change(void *pCtx)
 	outputInfo = (DecOutputInfo *)ctx->outputInfo;
 
 	ctx->seqChangeRequest = 1;
-	//seqChangedRdPtr = outputInfo->rdPtr;
 	seqChangedRdPtr = outputInfo->bytePosFrameEnd;
 	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
 		"use bytePosFrameEnd:0x%x instead of rdPtr:0x%x\n",
@@ -1963,28 +1895,25 @@ int ve1_prepare_seq_change(void *pCtx)
 	}
 	ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle, 1);
 	ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-		"tgid(%d,%d,%s).af VPU_DecUpdateBitstreamBuffer.ret:%d.size:1.accuBsFeedBytes:%d\n",
-		current->tgid, current->pid, current->comm, ret,
-		ctx->accuBsFeedBytes);
+		"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:1.accuBsFeedBytes:%d\n",
+		ret, ctx->accuBsFeedBytes);
 	VE1_DecGetRdWrPtr(pCtx);
 	ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
 					   STREAM_END_SET_FLAG);
 	ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-		"tgid(%d,%d,%s).af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-		current->tgid, current->pid, current->comm, ret,
-		STREAM_END_SET_FLAG, ctx->accuBsFeedBytes);
+		"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+		ret, STREAM_END_SET_FLAG, ctx->accuBsFeedBytes);
 	VE1_DecGetRdWrPtr(pCtx);
 
 	while (outputInfo->indexFrameDisplay != -1) {
 		if (ctx->seqInited &&
 		    (ctx->ve1DecState == VE1_STATE_DEC_SET_DPB ||
 		     ctx->ve1DecState == VE1_STATE_DEC_PIC_DONE)) {
+			rtkve1_recycle_dpb(ctx);
 			ret = VPU_DecStartOneFrame((DecHandle)ctx->decHandle,
 						   (DecParam *)ctx->decParam);
 			ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-				"tgid(%d,%d,%s).af VPU_DecStartOneFrame.ret:%d\n",
-				current->tgid, current->pid, current->comm,
-				ret);
+				"af VPU_DecStartOneFrame.ret:%d\n", ret);
 			if (ret != RETCODE_SUCCESS) {
 				ve1_err(VE1_WRAPPER_TAG,
 					"VPU_DecStartOneFrame fail.ret:%d\n",
@@ -1998,7 +1927,6 @@ int ve1_prepare_seq_change(void *pCtx)
 			while (1) {
 				ctx->int_reason =
 					VPU_WaitInterrupt(VE1_COREIDX, 10);
-				//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "af VPU_WaitInterrupt.int_reason:%d\n",ctx->int_reason);
 				if (ctx->int_reason == -1) {
 					ctx->int_reason = 0;
 				}
@@ -2008,10 +1936,7 @@ int ve1_prepare_seq_change(void *pCtx)
 					    (1 << INT_BIT_PIC_RUN)) {
 						ve1_dbg(VPU_DBG_NONE,
 							VE1_WRAPPER_TAG,
-							"tgid(%d,%d,%s).INT_BIT_PIC_RUN\n",
-							current->tgid,
-							current->pid,
-							current->comm);
+							"INT_BIT_PIC_RUN\n");
 						ctx->int_reason = 0;
 						bPicDone = 1;
 					} else if (ctx->int_reason &
@@ -2022,10 +1947,7 @@ int ve1_prepare_seq_change(void *pCtx)
 							ctx->vpuWrPtr;
 						ve1_dbg(VPU_DBG_NONE,
 							VE1_WRAPPER_TAG,
-							"tgid(%d,%d,%s).INT_BIT_BIT_BUF_EMPTY.bufEmptyVpuWrPtr:0x%x\n",
-							current->tgid,
-							current->pid,
-							current->comm,
+							"INT_BIT_BIT_BUF_EMPTY.bufEmptyVpuWrPtr:0x%x\n",
 							ctx->bufEmptyVpuWrPtr);
 					}
 					break;
@@ -2062,10 +1984,9 @@ int ve1_prepare_seq_change(void *pCtx)
 				}
 
 				ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
-					"tgid(%d,%d,%s).%d.%d.%d.h:0x%px.seq:%d.dec:%d.dis:%d.POC:%d(%d,%d).type:%d(%d).pos(0x%x 0x%x 0x%x).size:%ld.suc:0x%x.err:%d.frmDisFlg:0x%x.warn:%d.nalRefIdc:%d.decFrameInfo:%d.\n",
-					current->tgid, current->pid,
-					current->comm, ctx->outputinfoSN,
-					ctx->decodedFrmNum, ctx->displayFrmNum,
+					"%d.%d.%d.h:0x%px.seq:%d.dec:%d.dis:%d.POC:%d(%d,%d).type:%d(%d).pos(0x%x 0x%x 0x%x).size:%ld.suc:0x%x.err:%d.frmDisFlg:0x%x.warn:%d.nalRefIdc:%d.decFrameInfo:%d.\n",
+					ctx->outputinfoSN, ctx->decodedFrmNum,
+					ctx->displayFrmNum,
 					ctx->decHandle, ctx->currSequenceNo,
 					outputInfo->indexFrameDecoded,
 					outputInfo->indexFrameDisplay,
@@ -2105,14 +2026,6 @@ int ve1_prepare_seq_change(void *pCtx)
 
 		msleep(5);
 	}
-	/* set last_frame flag => threadcap() get eos 1 and add V4L2_BUF_FLAG_LAST in vpu_cap_buf_done(),
-    // this wil cause "westeros-sink-soc.c:3994:wstGetOutputBuffer: failed to de-queu USe output buffer: rc -1 errno 32"
-    if (outputInfo->indexFrameDisplay == -1)
-    {
-        ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "mark last_frame flag to the last frame of this sequence\n");
-        rtkve1_add_displayble_frame_to_list(ctx);
-    }
-    */
 
 	for (i = 0; i < ctx->regFbCount; i++) {
 		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
@@ -2144,16 +2057,14 @@ int ve1_prepare_seq_change(void *pCtx)
 		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
 						   STREAM_END_SET_FLAG);
 		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"tgid(%d,%d,%s).af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-			current->tgid, current->pid, current->comm, ret,
-			STREAM_END_SET_FLAG, ctx->accuBsFeedBytes);
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+			ret, STREAM_END_SET_FLAG, ctx->accuBsFeedBytes);
 	} else {
 		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
 						   STREAM_END_CLEAR_FLAG);
 		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"tgid(%d,%d,%s).af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-			current->tgid, current->pid, current->comm, ret,
-			STREAM_END_CLEAR_FLAG, ctx->accuBsFeedBytes);
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+			ret, STREAM_END_CLEAR_FLAG, ctx->accuBsFeedBytes);
 	}
 	VE1_DecGetRdWrPtr(pCtx);
 
@@ -2162,9 +2073,8 @@ int ve1_prepare_seq_change(void *pCtx)
 						   seqChangedWrPtr -
 							   seqChangedRdPtr);
 		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"tgid(%d,%d,%s).af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-			current->tgid, current->pid, current->comm, ret,
-			(seqChangedWrPtr - seqChangedRdPtr),
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+			ret, (seqChangedWrPtr - seqChangedRdPtr),
 			ctx->accuBsFeedBytes);
 	} else {
 		ret = VPU_DecUpdateBitstreamBuffer(
@@ -2175,8 +2085,8 @@ int ve1_prepare_seq_change(void *pCtx)
 				(seqChangedWrPtr -
 				 ((DecOpenParam *)ctx->decOP)->bitstreamBuffer));
 		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"tgid(%d,%d,%s).af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-			current->tgid, current->pid, current->comm, ret,
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+			ret,
 			((((DecOpenParam *)ctx->decOP)->bitstreamBuffer +
 			  ((DecOpenParam *)ctx->decOP)->bitstreamBufferSize) -
 			 seqChangedRdPtr +
@@ -2217,18 +2127,12 @@ int VE1_DecPicDone(void *pCtx)
 	struct rtkve1_dpb_t *dpb = NULL;
 	struct vb2_v4l2_buffer *vb2_v4l2_buf = NULL;
 	struct vb2_buffer *vb2_buf = NULL;
-	//unsigned char *pYuv = NULL;
 #endif
 #if defined(VE1_TEST_DUMP_YUV_EN)
 	mm_segment_t old_fs;
 	loff_t pos = 0;
 	ssize_t bytes = 0;
 	int filp_open_flags;
-	//VpuRect rcDisplay;
-	//uint32_t width;
-	//uint32_t height;
-	//uint32_t bpp;
-	//size_t sizeYuv;
 #endif
 
 	if (pCtx == NULL) {
@@ -2265,8 +2169,6 @@ int VE1_DecPicDone(void *pCtx)
 	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "set ve1DecState:%d\n",
 		ctx->ve1DecState);
 
-	ctx->outputinfoSN++;
-
 	if (outputInfo->indexFrameDecoded >= 0) {
 		ctx->decodedFrmNum++;
 	}
@@ -2274,38 +2176,44 @@ int VE1_DecPicDone(void *pCtx)
 		ctx->displayFrmNum++;
 	}
 
+	if (!((ctx->lastInfoFrmStart == outputInfo->bytePosFrameStart) &&
+	      (ctx->lastInfoFrmEnd == outputInfo->bytePosFrameEnd) &&
+	      (outputInfo->indexFrameDecoded == -2) &&
+	      (outputInfo->indexFrameDisplay == -3))) {
+		ctx->outputinfoSN++;
 	ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
-		"tgid(%d,%d,%s).%d.%d.%d.h:0x%px.seq:%d.dec:%d.dis:%d.POC:%d(%d,%d).type:%d(%d).pos(0x%x 0x%x 0x%x).size:%ld.suc:0x%x.err:%d.frmDisFlg:0x%x.warn:%d.nalRefIdc:%d.decFrameInfo:%d.vpu_debug:0x%x\n",
-		current->tgid, current->pid, current->comm, ctx->outputinfoSN,
-		ctx->decodedFrmNum, ctx->displayFrmNum, ctx->decHandle,
+		"%d.%d.%d.h:0x%px.seq:%d.dec:%d.dis:%d.POC:%d(%d,%d).type:%d(%d).pos(0x%x 0x%x 0x%x).size:%ld.suc:0x%x.err:%d.frmDisFlg:0x%x.warn:%d.nalRefIdc:%d.decFrameInfo:%d.vpu_debug:0x%x\n",
+		ctx->outputinfoSN, ctx->decodedFrmNum,
+		ctx->displayFrmNum, ctx->decHandle,
 		ctx->currSequenceNo, outputInfo->indexFrameDecoded,
 		outputInfo->indexFrameDisplay, outputInfo->avcPocPic,
 		outputInfo->avcPocTop, outputInfo->avcPocBot,
 		outputInfo->picType, outputInfo->picTypeFirst,
-		outputInfo->bytePosFrameStart, outputInfo->bytePosFrameEnd,
-		outputInfo->rdPtr,
+		outputInfo->bytePosFrameStart,
+		outputInfo->bytePosFrameEnd, outputInfo->rdPtr,
 		ve1_ring_valid_data(ctx->bitstream.paddr,
-				    ctx->bitstream.paddr + ctx->bitstream.size,
-				    outputInfo->bytePosFrameStart,
-				    outputInfo->bytePosFrameEnd),
+			ctx->bitstream.paddr +
+			ctx->bitstream.size,
+			outputInfo->bytePosFrameStart,
+			outputInfo->bytePosFrameEnd),
 		outputInfo->decodingSuccess, outputInfo->numOfErrMBs,
 		outputInfo->frameDisplayFlag, outputInfo->warnInfo,
-		outputInfo->nalRefIdc, outputInfo->decFrameInfo, vpu_debug);
+		outputInfo->nalRefIdc, outputInfo->decFrameInfo,
+		vpu_debug);
+	}
+	ctx->lastInfoFrmStart = outputInfo->bytePosFrameStart;
+	ctx->lastInfoFrmEnd = outputInfo->bytePosFrameEnd;
 
 	if ((((DecOpenParam *)ctx->decOP)->bitstreamFormat == STD_AVC) &&
 	    (outputInfo->indexFrameDecoded >= 0)) {
-		//bool isH264MissingReference = false;
-		//bool isMissingField = false;
 
 		if ((outputInfo->decodingSuccess & 0x00200000) &&
 		    (outputInfo->nalRefIdc != 0)) {
-			//isH264MissingReference = true;
 			ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
 				"dec:%d.AVC missing reference\n",
 				outputInfo->indexFrameDecoded);
 		}
 		if (outputInfo->decFrameInfo != 0) {
-			//isMissingField = true;
 			ve1_dbg(VPU_DBG_VE1_DEC, VE1_WRAPPER_TAG,
 				"dec:%d.AVC missing field\n",
 				outputInfo->indexFrameDecoded);
@@ -2341,75 +2249,13 @@ int VE1_DecPicDone(void *pCtx)
 
 #if defined(VE1_CHECK_DFB_MD5_EN)
 	fbIndex = outputInfo->indexFrameDecoded;
-	//if ((!ctx->is_svp) && (outputInfo->indexFrameDisplay >= 0) && (ctx->displayFrmNum == 300))
-	//if (fbIndex >= 0)
-	if (0) {
-		//int i;
-		//unsigned char *temp;
-		fbUser = ((FrameBuffer *)ctx->fbUser) + fbIndex;
-		fb_phys_addr = fbUser->bufY;
-		tmp_dpb = rtkve1_find_dpb((void *)ctx, fb_phys_addr);
-		if (!tmp_dpb) {
-			ve1_err(VE1_WRAPPER_TAG,
-				"can't find framePhysAddr:0x%x in dpb[]\n",
-				fb_phys_addr);
-			return VE1_DEC_RETURN_INVALID;
-		}
-		dpb = (struct rtkve1_dpb_t *)tmp_dpb;
-		vb2_v4l2_buf = (struct vb2_v4l2_buffer *)(dpb->vb2_v4l2_buf);
-		vb2_buf = &(vb2_v4l2_buf->vb2_buf);
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			"dpb.index:%d.phys:0x%x.vb2_v4l2_buf:0x%px.vb2_buf:0x%px.size:%u\n",
-			fbIndex, fb_phys_addr, (void *)vb2_v4l2_buf,
-			(void *)vb2_buf, dpb->size);
-		fb_virt_addr = vb2_plane_vaddr(vb2_buf, 0);
-		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
-			"dpb.index:%d.virt:0x%px.phys:0x%x.vb2_v4l2_buf:0x%px.vb2_buf:0x%px.size:%u\n",
-			fbIndex, fb_virt_addr, fb_phys_addr,
-			(void *)vb2_v4l2_buf, (void *)vb2_buf, dpb->size);
-		ve1_md5_hash(ve1_md5_digest, VE1_MD5_DIGEST_SIZE,
-			     (char *)fb_virt_addr, dpb->size);
-		/*
-        pYuv = (unsigned char *)kmalloc(fbUser->size, GFP_KERNEL);
-        if (fb_virt_addr && fbUser && pYuv)
-        {
-            osal_memcpy((void *)pYuv, (void *)fb_virt_addr, fbUser->size);
-            ve1_md5_hash(ve1_md5_digest, VE1_MD5_DIGEST_SIZE, (char *)pYuv, fbUser->size);
-        }
-        if (pYuv)
-        {
-            kfree(pYuv);
-            pYuv = NULL;
-        }
-        if (fb_virt_addr)
-        {
-            temp = (unsigned char *)fb_virt_addr;
-            for (i=0;i<48;i+=16)
-            {
-                ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
-                    temp[i],temp[i+1],temp[i+2],temp[i+3],temp[i+4],temp[i+5],temp[i+6],temp[i+7],
-                    temp[i+8],temp[i+9],temp[i+10],temp[i+11],temp[i+12],temp[i+13],temp[i+14],temp[i+15]);
-            }
-            fb_virt_addr = NULL;
-        }
-*/
-	}
 #endif
 
 #if defined(VE1_TEST_DUMP_YUV_EN)
-	//if ((!ctx->is_svp) && (ctx->displayFrmNum >= 300 && ctx->displayFrmNum <= 330) && outputInfo->indexFrameDisplay >= 0)
-	//if (ctx->displayFrmNum <= VE1_TEST_DUMP_YUV_FRAME_NUM && outputInfo->indexFrameDisplay >= 0)
-	//if ((!ctx->is_svp) && (outputInfo->indexFrameDisplay >= 0) && (ctx->displayFrmNum == 300))
 	if ((outputInfo->indexFrameDisplay >= 0) &&
 	    (ctx->displayFrmNum == 300)) {
 		fbUser = ((FrameBuffer *)ctx->fbUser) +
 			 outputInfo->indexFrameDisplay;
-		// kernel 5.15, need to fix fb_virt_addr later
-		//#if defined(VE1_ALLOC_FRAME_BUFFER_BY_VDI)
-		//        fb_virt_addr = pu_mmap_kernel_buffer(outputInfo->dispFrame.bufY, fbUser->size);
-		//#else
-		//        fb_virt_addr = ve1_mmap_kernel_buffer((void *)ctx, outputInfo->dispFrame.bufY);
-		//#endif
 		ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
 			"mmap virt_addr:0x%px.phys_addr:0x%x\n", fb_virt_addr,
 			outputInfo->dispFrame.bufY);
@@ -2427,11 +2273,6 @@ int VE1_DecPicDone(void *pCtx)
 			if (IS_ERR((struct file *)ctx->yuvDumpFile)) {
 				kfree(pYuv);
 				pYuv = NULL;
-				//#if defined(VE1_ALLOC_FRAME_BUFFER_BY_VDI)
-				//                pu_unmap_kernel_buffer(fb_virt_addr, outputInfo->dispFrame.bufY);
-				//#else
-				//                ve1_unmap_kernel_buffer((void *)ctx, fb_virt_addr, outputInfo->dispFrame.bufY);
-				//#endif
 				fb_virt_addr = NULL;
 				ve1_err(VE1_WRAPPER_TAG, "filp_open %s fail\n",
 					VE1_TEST_DUMP_YUV_FILENAME);
@@ -2457,17 +2298,7 @@ int VE1_DecPicDone(void *pCtx)
 				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
 					"vfs_write bytes:%d.pos:%lld\n", bytes,
 					pos);
-				/*
-                rcDisplay.left   = outputInfo->rcDisplay.left;
-                rcDisplay.top    = outputInfo->rcDisplay.top;
-                rcDisplay.right  = outputInfo->rcDisplay.right;
-                rcDisplay.bottom = outputInfo->rcDisplay.bottom;
-                pYuv = GetYUVFromFrameBuffer((DecHandle)ctx->decHandle, &(outputInfo->dispFrame), rcDisplay, &width, &height, &bpp, &sizeYuv);
-                ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "af GetYUVFromFrameBuffer.w:%d.h:%d.bpp:%d.sizeYuv:%d.pYuv:0x%px\n",width,height,bpp,sizeYuv,pYuv);
-                pos = ((struct file *)ctx->yuvDumpFile)->f_pos;
-                bytes = vfs_write((struct file *)ctx->yuvDumpFile, pYuv, sizeYuv, &pos);
-                ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "vfs_write bytes:%d.pos:%lld\n",bytes,pos);
-*/
+
 				set_fs(old_fs);
 				filp_close(ctx->yuvDumpFile, NULL);
 				ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG,
@@ -2476,11 +2307,6 @@ int VE1_DecPicDone(void *pCtx)
 				ctx->yuvDumpFile = NULL;
 				kfree(pYuv);
 				pYuv = NULL;
-				//#if defined(VE1_ALLOC_FRAME_BUFFER_BY_VDI)
-				//                pu_unmap_kernel_buffer(fb_virt_addr, outputInfo->dispFrame.bufY);
-				//#else
-				//                ve1_unmap_kernel_buffer((void *)ctx, fb_virt_addr, outputInfo->dispFrame.bufY);
-				//#endif
 				fb_virt_addr = NULL;
 			}
 		}
@@ -2489,11 +2315,6 @@ int VE1_DecPicDone(void *pCtx)
 			pYuv = NULL;
 		}
 		if (fb_virt_addr) {
-			//#if defined(VE1_ALLOC_FRAME_BUFFER_BY_VDI)
-			//            pu_unmap_kernel_buffer(fb_virt_addr, outputInfo->dispFrame.bufY);
-			//#else
-			//            ve1_unmap_kernel_buffer((void *)ctx, fb_virt_addr, outputInfo->dispFrame.bufY);
-			//#endif
 			fb_virt_addr = NULL;
 		}
 	}
@@ -2511,7 +2332,6 @@ int VE1_DecPicDone(void *pCtx)
 
 	return VE1_DEC_RETURN_OK;
 }
-//EXPORT_SYMBOL(VE1_DecPicDone);
 
 int VE1_DecCheckComplete(void *pCtx)
 {
@@ -2536,9 +2356,8 @@ int VE1_DecCheckComplete(void *pCtx)
 		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
 						   STREAM_END_SET_FLAG);
 		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"tgid(%d,%d,%s).af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-			current->tgid, current->pid, current->comm, ret,
-			STREAM_END_SET_FLAG, ctx->accuBsFeedBytes);
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+			ret, STREAM_END_SET_FLAG, ctx->accuBsFeedBytes);
 		VE1_DecGetRdWrPtr(ctx);
 
 		int_reason = 1 << INT_BIT_BIT_BUF_EMPTY;
@@ -2562,9 +2381,8 @@ int VE1_DecCheckComplete(void *pCtx)
 		ret = VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
 						   STREAM_END_CLEAR_FLAG);
 		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"tgid(%d,%d,%s).af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-			current->tgid, current->pid, current->comm, ret,
-			STREAM_END_CLEAR_FLAG, ctx->accuBsFeedBytes);
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+			ret, STREAM_END_CLEAR_FLAG, ctx->accuBsFeedBytes);
 		VE1_DecGetRdWrPtr(ctx);
 		ctx->ve1DecState = VE1_STATE_DEC_PIC_DONE;
 	}
@@ -2573,35 +2391,6 @@ int VE1_DecCheckComplete(void *pCtx)
 }
 //EXPORT_SYMBOL(VE1_DecCheckComplete);
 
-int VE1_SetFrameBufReusable(void *pCtx, unsigned int index)
-{
-	RetCode ret = RETCODE_SUCCESS;
-	struct ve1_ctx *ctx;
-
-	if (pCtx == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "pCtx == NULL\n");
-		return -1;
-	}
-	ctx = (struct ve1_ctx *)pCtx;
-
-	if (ctx->decHandle == NULL) {
-		ve1_err(VE1_WRAPPER_TAG, "ctx->decHandle == NULL\n");
-		return -1;
-	}
-
-	if (index >= ctx->regFbCount) {
-		ve1_err(VE1_WRAPPER_TAG, "index:%d >= regFbCount:%d\n", index,
-			ctx->regFbCount);
-		return -1;
-	}
-
-	ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "VPU_DecClrDispFlag(%d)\n",
-		index);
-	ret = VPU_DecClrDispFlag((DecHandle)ctx->decHandle, index);
-	return ret;
-}
-//EXPORT_SYMBOL(VE1_SetFrameBufReusable);
-
 int VE1_DecClose(void *pCtx)
 {
 	RetCode ret = RETCODE_SUCCESS;
@@ -2634,12 +2423,17 @@ int VE1_DecClose(void *pCtx)
 	 * EnterLock and doesn't LeaveLock, during this moment the system stops streaming.
 	 * The next start will be deadlock at EnterLock().
 	 */
-	if (ctx->ve1DecState != VE1_STATE_DEC_OPENED && ctx->ve1DecState != VE1_STATE_DEC_PIC_DONE) {
-		ve1_info(VE1_WRAPPER_TAG, "%s: ve1DecState=%d, VPU_SWReset for corner case\n",
-				__func__, ctx->ve1DecState);
-		VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle, STREAM_END_SIZE);
-		VPU_SWReset(VE1_COREIDX, SW_RESET_SAFETY, (DecHandle)ctx->decHandle);
-		VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle, STREAM_END_CLEAR_FLAG);
+	if (ctx->ve1DecState != VE1_STATE_DEC_OPENED &&
+	    ctx->ve1DecState != VE1_STATE_DEC_PIC_DONE) {
+		ve1_info(VE1_WRAPPER_TAG,
+			"%s: ve1DecState=%d, VPU_SWReset for corner case\n",
+			__func__, ctx->ve1DecState);
+		VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
+			STREAM_END_SIZE);
+		VPU_SWReset(VE1_COREIDX, SW_RESET_SAFETY,
+			(DecHandle)ctx->decHandle);
+		VPU_DecUpdateBitstreamBuffer((DecHandle)ctx->decHandle,
+			STREAM_END_CLEAR_FLAG);
 		ve1_info(VE1_WRAPPER_TAG, "%s: VPU_SWReset done\n", __func__);
 	}
 
@@ -2719,7 +2513,6 @@ int VE1_DecClose(void *pCtx)
 
 	return ret;
 }
-//EXPORT_SYMBOL(VE1_DecClose);
 
 int VE1_DecDeInit(void *pCtx)
 {
@@ -2747,7 +2540,6 @@ int VE1_DecDeInit(void *pCtx)
 
 	return ret;
 }
-//EXPORT_SYMBOL(VE1_DecDeInit);
 
 void VE1_GetParsedInfo(void *pCtx, void *pInfo)
 {
@@ -2777,9 +2569,9 @@ void VE1_GetParsedInfo(void *pCtx, void *pInfo)
 		initialInfo->picCropRect.right - initialInfo->picCropRect.left;
 	info->visible_rect_h =
 		initialInfo->picCropRect.bottom - initialInfo->picCropRect.top;
-	info->minDpbCount = initialInfo->minFrameBufferCount + EXTRA_DEC_PIC_BUF;
+	info->minDpbCount =
+		initialInfo->minFrameBufferCount + EXTRA_DEC_PIC_BUF;
 }
-//EXPORT_SYMBOL(VE1_GetParsedInfo);
 
 void VE1_GetDisplayFrameInfo(void *pCtx, void *displayFrameInfo)
 {
@@ -2849,14 +2641,12 @@ void VE1_GetDisplayFrameInfo(void *pCtx, void *displayFrameInfo)
 		frame->mode, frame->timeTick, frame->video_full_range_flag,
 		frame->transfer_characteristics, frame->matrix_coefficients);
 }
-//EXPORT_SYMBOL(VE1_GetDisplayFrameInfo);
 
 int VE1_AllocateBitstreamBuffer(struct device *dev, unsigned long *phys_addr,
 				unsigned long *virt_addr, unsigned long size,
 				unsigned int is_svp)
 {
 	int ret = 0;
-//	unsigned int mem_type = 0;
 	unsigned int flags = 0;
 	dma_addr_t dma_phys_addr = 0;
 	void *dma_virt_addr = NULL;
@@ -2876,7 +2666,10 @@ int VE1_AllocateBitstreamBuffer(struct device *dev, unsigned long *phys_addr,
 			RTK_FLAG_SCPUACC;
 	}
 
-	rheap_setup_dma_pools(dev, "rtk_media_heap", flags, __func__);
+	/* We can't limit the address from dma_alloc_coherent when size <= 4096 */
+	if (size < SZ_8K)
+		size = SZ_8K;
+
 	dma_virt_addr = dma_alloc_coherent(
 		dev, PAGE_ALIGN(size), &dma_phys_addr, (GFP_DMA | GFP_KERNEL));
 	if (dma_virt_addr == NULL) {
@@ -2894,7 +2687,6 @@ int VE1_AllocateBitstreamBuffer(struct device *dev, unsigned long *phys_addr,
 
 	return ret;
 }
-//EXPORT_SYMBOL(VE1_AllocateBitstreamBuffer);
 
 int VE1_FreeBitstreamBuffer(struct device *dev, unsigned long virt_addr,
 			    unsigned long phys_addr, unsigned int size)
@@ -2917,7 +2709,6 @@ int VE1_FreeBitstreamBuffer(struct device *dev, unsigned long virt_addr,
 
 	return ret;
 }
-//EXPORT_SYMBOL(VE1_FreeBitstreamBuffer);
 
 static VE1_PICTURE_MODE ve1_get_picture_mode(struct ve1_ctx *ctx)
 {
@@ -2943,7 +2734,6 @@ static VE1_PICTURE_MODE ve1_get_picture_mode(struct ve1_ctx *ctx)
 			// ref 1185 MpegDec_SetupLinks()
 			is_prog =
 				(info->progressiveSequence /* progressive sequence */
-				 //|| info->repeatFirstField             /* a 3-field picture    */
 				 ||
 				 frame->stillVOBU); /* progressive I-picture in a DVD still-VOBU */
 
@@ -2999,20 +2789,7 @@ static VE1_PICTURE_MODE ve1_get_picture_mode(struct ve1_ctx *ctx)
 					} else {
 						mode = INTERLEAVED_TOP_FIELD;
 					}
-				}
-				/* Below is for customer branch only.
-                // Because the content of the customer streaming playback mostly are interleaved, but the fields of the header related to picMode are all 0.
-                // We need to provide top field first or bottom field first for this kind of the stream, or video presentation will be wrong.
-                else if(info->avcPocBot < info->avcPocTop)
-                {//if pocPic = pocTop = pocBot, still assume top fld first
-                    mode = INTERLEAVED_BOT_FIELD;
-                }
-                else if(info->avcPocBot > info->avcPocTop)
-                {
-                    mode = INTERLEAVED_TOP_FIELD;
-                }
-                */
-				else {
+				} else {
 					mode = CONSECUTIVE_FRAME;
 				}
 			} else if (info->picStrPresent == 1) {
@@ -3232,7 +3009,6 @@ void rtkve1_copy_to_bitstream_buffer(struct ve1_ctx *ctx, uint8_t *buf,
 						ctx->bsWrPtr, buf, size0);
 					return -1;
 				}
-				//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "copied bs.phys(0x%lx to 0x%lx).size0:%d\n",ctx->bsWrPtr,bsEndAddr,size0);
 
 				ret = ta_TEEapi_memcpy_a7(
 					(struct tee_context *)
@@ -3247,7 +3023,6 @@ void rtkve1_copy_to_bitstream_buffer(struct ve1_ctx *ctx, uint8_t *buf,
 						buf + size0, size1);
 					return -1;
 				}
-				//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "copied bs.phys(0x%lx to 0x%lx).size1:%d\n",ctx->bitstream.paddr,(ctx->bitstream.paddr+size1),size1);
 			} else if (ctx->out_vb2_q_memory ==
 				   V4L2_MEMORY_DMABUF) {
 				ret = ta_TEEapi_memcpy(
@@ -3261,7 +3036,6 @@ void rtkve1_copy_to_bitstream_buffer(struct ve1_ctx *ctx, uint8_t *buf,
 						ctx->bsWrPtr, buf, size0);
 					return -1;
 				}
-				//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "copied bs.phys(0x%lx to 0x%lx).size0:%d\n",ctx->bsWrPtr,bsEndAddr,size0);
 
 				ret = ta_TEEapi_memcpy(
 					(struct tee_context *)
@@ -3276,15 +3050,12 @@ void rtkve1_copy_to_bitstream_buffer(struct ve1_ctx *ctx, uint8_t *buf,
 						buf + size0, size1);
 					return -1;
 				}
-				//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "copied bs.phys(0x%lx to 0x%lx).size1:%d\n",ctx->bitstream.paddr,(ctx->bitstream.paddr+size1),size1);
 			}
 #endif // #if defined(ENABLE_TEE_DRM_FLOW)
 		} else {
 			osal_memcpy((void *)virtBsWrPtr, (void *)buf, size0);
-			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "copied bs.virt(0x%lx to 0x%lx).size0:%d\n",virtBsWrPtr,(ctx->bitstream.vaddr+ctx->bitstream.size),size0);
 			osal_memcpy((void *)ctx->bitstream.vaddr,
 				    (void *)(buf + size0), size1);
-			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "copied bs.virt(0x%lx to 0x%lx).size1:%d\n",ctx->bitstream.vaddr,(ctx->bitstream.vaddr+size1),size1);
 		}
 		ctx->bsWrPtr = ctx->bitstream.paddr + size1;
 	} else {
@@ -3302,7 +3073,6 @@ void rtkve1_copy_to_bitstream_buffer(struct ve1_ctx *ctx, uint8_t *buf,
 						ctx->bsWrPtr, buf, size);
 					return -1;
 				}
-				//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "copied bs.phys(0x%lx to 0x%lx).size:%d\n",ctx->bsWrPtr,newBsWrPtr,size);
 			} else if (ctx->out_vb2_q_memory ==
 				   V4L2_MEMORY_DMABUF) {
 				ret = ta_TEEapi_memcpy(
@@ -3316,12 +3086,10 @@ void rtkve1_copy_to_bitstream_buffer(struct ve1_ctx *ctx, uint8_t *buf,
 						ctx->bsWrPtr, buf, size);
 					return -1;
 				}
-				//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "copied bs.phys(0x%lx to 0x%lx).size:%d\n",ctx->bsWrPtr,newBsWrPtr,size);
 			}
 #endif // #if defined(ENABLE_TEE_DRM_FLOW)
 		} else {
 			osal_memcpy((void *)virtBsWrPtr, (void *)buf, size);
-			//ve1_dbg(VPU_DBG_NONE, VE1_WRAPPER_TAG, "copied bs.virt(0x%lx to 0x%lx).size:%d\n",virtBsWrPtr,(virtBsWrPtr+size),size);
 		}
 		ctx->bsWrPtr = newBsWrPtr;
 	}
@@ -3335,8 +3103,8 @@ int32_t BuildSeqHeader(void *pCtx, uint8_t *buf, uint32_t buf_size)
 	uint8_t *p = pbMetaData;
 	int32_t size = 0; // metadata header size
 	uint32_t codingType = 0;
-  uint32_t nFrameWidth, nFrameHeight, picWidth, picHeight;
-  uint32_t width_in_pixels, height_in_pixels;
+	uint32_t nFrameWidth, nFrameHeight, picWidth, picHeight;
+	uint32_t width_in_pixels, height_in_pixels;
 	uint32_t signature = MAKE_FOURCC('D', 'K', 'I', 'F');
 	uint32_t version = 0x00;
 	uint32_t length_of_header_in_bytes = 0x20;
@@ -3381,8 +3149,8 @@ int32_t BuildSeqHeader(void *pCtx, uint8_t *buf, uint32_t buf_size)
 					nFrameHeight = picHeight;
 				}
 			}
-      width_in_pixels = nFrameWidth;
-      height_in_pixels = nFrameHeight;
+			width_in_pixels = nFrameWidth;
+			height_in_pixels = nFrameHeight;
 
 			//signature 'DKIF'
 			ctx->seqHeader[0] = (unsigned char)(signature >> 0);
@@ -3539,8 +3307,6 @@ int VE1_DecUpdateBS(void *pCtx, uint8_t *buf, uint32_t size)
 	}
 	decOP = (DecOpenParam *)ctx->decOP;
 
-	//ve1_md5_hash(ve1_md5_digest, VE1_MD5_DIGEST_SIZE, (char *)buf, size);
-
 	if (decOP->bitstreamFormat == STD_VP8) {
 		seqHdrSize = BuildSeqHeader((void *)ctx, buf, size);
 		if (seqHdrSize > 0) {
@@ -3554,7 +3320,6 @@ int VE1_DecUpdateBS(void *pCtx, uint8_t *buf, uint32_t size)
 					  (ctx->picHeader[1] << 8) |
 					  (ctx->picHeader[2] << 16) |
 					  (ctx->picHeader[3] << 24);
-			//ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG, "picHdrSize:%u.frame_chunk_len:%u.bssize:%u\n",picHdrSize,frame_chunk_len,size);
 			rtkve1_copy_to_bitstream_buffer(ctx, ctx->picHeader,
 							picHdrSize);
 			totalUpBsSize += picHdrSize;
@@ -3571,14 +3336,16 @@ int VE1_DecUpdateBS(void *pCtx, uint8_t *buf, uint32_t size)
 			ret, totalUpBsSize);
 		return -1;
 	} else {
-		if ((decOP->bitstreamMode == BS_MODE_PIC_END) && (decOP->bitstreamFormat == STD_AVC || decOP->bitstreamFormat == STD_MPEG2)) {
+		if ((ctx->seqInited) &&
+			(decOP->bitstreamMode == BS_MODE_PIC_END) &&
+		    (decOP->bitstreamFormat == STD_AVC ||
+		     decOP->bitstreamFormat == STD_MPEG2)) {
 			ctx->bPostponeUpBs = true;
 		}
 		ctx->accuBsFeedBytes += totalUpBsSize;
 		ve1_dbg(VPU_DBG_VE1_UP_BS, VE1_WRAPPER_TAG,
-			"tgid(%d,%d,%s).af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
-			current->tgid, current->pid, current->comm, ret,
-			totalUpBsSize, ctx->accuBsFeedBytes);
+			"af VPU_DecUpdateBitstreamBuffer.ret:%d.size:%d.accuBsFeedBytes:%d\n",
+			ret, totalUpBsSize, ctx->accuBsFeedBytes);
 
 		VE1_DecGetRdWrPtr(ctx);
 		// handle priority of bWaitNextField is higher than bBufEmptyFlag
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_wrapper.h b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_wrapper.h
index 50acb8069978..446b8c0e19cb 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_wrapper.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve1_wrapper.h
@@ -60,7 +60,6 @@ int ve1_prepare_seq_change(void *pCtx);
 */
 int VE1_DecPicDone(void *pCtx);
 int VE1_DecCheckComplete(void *pCtx);
-int VE1_SetFrameBufReusable(void *pCtx, unsigned int index);
 int VE1_DecClose(void *pCtx);
 int VE1_DecDeInit(void *pCtx);
 void VE1_GetParsedInfo(void *pCtx, void *pInfo);
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c
index a500edab0461..785596f2ae6d 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2.c
@@ -100,6 +100,11 @@ int ve2_start_streaming(struct vb2_queue *q, uint32_t count, int pixelformat)
 	int type = q->type;
 	VIDEO_STREAM_TYPE eStreamType;
 
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		return -EINVAL;
+	}
+
 	pr_err("ve2_start_streaming(%d), codec %s\n", V4L2_TYPE_IS_OUTPUT(type),
 	       (pixelformat == V4L2_PIX_FMT_HEVC) ?
 		       "HEVC" :
@@ -142,6 +147,11 @@ int ve2_start_streaming(struct vb2_queue *q, uint32_t count, int pixelformat)
 			return ret;
 		}
 
+		ctx->cap_hndl->is_adaptive_playback =
+			vid_ctx->params.dec_params.is_adaptive_playback;
+		ctx->out_hndl->is_adaptive_playback =
+			vid_ctx->params.dec_params.is_adaptive_playback;
+
 		INIT_LIST_HEAD(&ctx->pts_list);
 		ctx->cap_hndl->pts_queue = &ctx->pts_list;
 		ctx->out_hndl->pts_queue = &ctx->pts_list;
@@ -242,8 +252,8 @@ int ve2_start_streaming(struct vb2_queue *q, uint32_t count, int pixelformat)
 				htonl(0 /*width*/ << 16 | 0 /*height*/);
 		else
 			ctx->cap_hndl->main_rb.pRBH->reserve3 = htonl(
-				v_ctx->cap_fmt.spec.fmt.pix.width /*width*/ << 16 |
-				v_ctx->cap_fmt.spec.fmt.pix.height /*height*/);
+				v_ctx->cap_fmt.misc.ori_width << 16 |
+				v_ctx->cap_fmt.misc.ori_height);
 	}
 
 	if (V4L2_TYPE_IS_OUTPUT(type)) {
@@ -294,6 +304,11 @@ int ve2_stop_streaming(struct vb2_queue *q)
 	int type = q->type;
 	struct ve2rpc *hndl;
 
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		return 0;
+	}
+
 	if (V4L2_TYPE_IS_OUTPUT(type)) {
 		if (!ctx->streamon_out) {
 			vpu_err("No out stream on !!!\n");
@@ -445,12 +460,27 @@ static int ve2_out_qbuf(void *fh, uint8_t *buf, uint32_t len, uint64_t pts,
 			uint32_t sequence)
 {
 	struct ve2_ctx *ctx = fh_to_ve(fh);
-	struct ve2rpc *out_hdl = ctx->out_hndl;
-//	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	struct ve2rpc *out_hdl = NULL;
+	struct ve2rpc *cap_hdl = NULL;
+	struct videc_ctx *vid_ctx = container_of(fh, struct videc_ctx, fh);
+	struct vpu_ctx *v_ctx = (struct vpu_ctx *)vid_ctx->vpu_ctx;
 	int ret;
 
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		return -EINVAL;
+	}
+	out_hdl = ctx->out_hndl;
+	cap_hdl = ctx->cap_hndl;
+
 	vpu_input_dbg("ve2_out_qbuf seq %d, pts %lld, len %x\n", sequence, pts,
 		      len);
+
+	if (v_ctx->is_error || cap_hdl->is_error) {
+		vpu_err("%s decode error %d, %d", __func__, v_ctx->is_error, cap_hdl->is_error);
+		return -EINVAL;
+	}
+
 	ret = ve2rpc_write_bs(out_hdl, buf, len, pts, sequence);
 	if (ret) {
 		vpu_input_dbg("ve2rpc_write_bs fail, ret %d\n", ret);
@@ -484,6 +514,12 @@ static int ve2_cap_qbuf(void *fh, struct vb2_buffer *vb)
 	struct vb2_v4l2_buffer *rm_vb2_v4l2_buf = NULL;
 	int ret = 0;
 
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		ret = -EINVAL;
+		goto exit;
+	}
+
 	if (!ctx->cap_hndl) {
 		vpu_err("cap is uninited\n");
 		ret = -EINVAL;
@@ -612,6 +648,11 @@ static void update_color_matrix(void *fh)
 	struct v4l2_ctrl_hdr10_mastering_display *mastering =
 		&vid_ctx->params.mastering;
 
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		return;
+	}
+
 	if (dec_param->matrix_coefficients != COLOR_MATRIX_COEF_DEFAULT) {
 		ctx->cap_hndl->col_matrix.matrix_coefficients =
 			dec_param->matrix_coefficients;
@@ -651,6 +692,11 @@ int ve2_cap_dqbuf(void *fh, uint8_t *buf, uint64_t *pts,
 	int cc_len;
 #endif
 
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		return -EINVAL;
+	}
+
 	if (!ctx->cap_hndl) {
 		vpu_err("cap is uninited\n");
 		return -EINVAL;
@@ -666,7 +712,6 @@ int ve2_cap_dqbuf(void *fh, uint8_t *buf, uint64_t *pts,
 			     &ctx->no_frame);
 	if (ret) {
 		//ve2_cap_dqbuf fail is normal
-		//vpu_output_dbg("ve2rpc_dqframe fail, ret %d\n", ret);
 		return ret;
 	}
 
@@ -752,6 +797,11 @@ static void ve2_get_info(void *fh, bool *eos, bool *no_frame)
 {
 	struct ve2_ctx *ctx = fh_to_ve(fh);
 
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		return;
+	}
+
 	*eos = ctx->eos;
 	*no_frame = ctx->no_frame;
 }
@@ -760,6 +810,11 @@ static int ve2_get_undq_dispFrm_cnt(void *fh)
 {
 	struct ve2_ctx *ctx = fh_to_ve(fh);
 
+	if(!ctx) {
+		vpu_err("%s ctx is NULL\n", __func__);
+		return -EINVAL;
+	}
+
 	return ve2rpc_get_decoded_frm_cnt(ctx->cap_hndl);
 }
 
@@ -772,6 +827,8 @@ static int ve2_pasre_header(void *fh, struct vb2_buffer *vb, uint32_t *width,
 	struct vb2_v4l2_buffer *v4l2_buf;
 	struct vpu_fmt vpu_fmt;
 	uint32_t size = 0;
+	uint32_t ddr_width = 0;
+	uint32_t ddr_height = 0;
 	void *buf = NULL;
 	int ret;
 
@@ -781,10 +838,20 @@ static int ve2_pasre_header(void *fh, struct vb2_buffer *vb, uint32_t *width,
 
 	ret = ve2rpc_get_bs_info(vb->vb2_queue->dev, fh,
 				 v_ctx->out_fmt.spec.fmt.pix.pixelformat, size,
-				 buf, width, height, min_reqbuf, bit_depth);
-	if (ret) {
+				 buf, width, height, &ddr_width, &ddr_height,
+				 min_reqbuf, bit_depth);
+
+	if (!ret && *bit_depth == 0x80000000 && *min_reqbuf == 0) {
+		v_ctx->is_error = true;
+		vpu_err("ve2_pasre_header: Codec not support!\n");
+		ret = -EFAULT;
+		goto exit;
+	} else if (ret ||
+		(*width == 0 && *height == 0 &&
+		ddr_width == 0 && ddr_height == 0)) {
 		vpu_err("ve2_pasre_header ve2rpc_get_bs_info fail %d\n", ret);
-		return -EFAULT;
+		ret = -EFAULT;
+		goto exit;
 	}
 
 #if 1
@@ -794,11 +861,14 @@ static int ve2_pasre_header(void *fh, struct vb2_buffer *vb, uint32_t *width,
 	vpu_fmt.spec.fmt.pix.bytesperline = *width;
 	vpu_fmt.misc.bufcnt = *min_reqbuf;
 	v_ctx->bit_depth = (*bit_depth == 0)?8:10;
+	v_ctx->ddr_width = ddr_width;
+	v_ctx->ddr_height = ddr_height;
 
 	vpu_update_cap_fmt(fh, (void *)&vpu_fmt);
 	vpu_notify_event_resolution_change(fh);
 #endif
 
+exit:
 	return ret;
 }
 
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2_frame.h b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2_frame.h
index 7d8e9c312744..fc7af1a0e72a 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2_frame.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2_frame.h
@@ -141,22 +141,6 @@ typedef struct {
 	unsigned int nFramerateN;
 	unsigned int eScanType; /* 0: progressive, 1: interlaced */
 	/* nInterlaceMode define  */
-	//typedef enum
-	//{
-	//  INTERLEAVED_TOP_FIELD = 0,  /* top    field data stored in even lines of a frame buffer */
-	//  INTERLEAVED_BOT_FIELD,      /* bottom field data stored in odd  lines of a frame buffer */
-	//  CONSECUTIVE_TOP_FIELD,      /* top    field data stored consecutlively in all lines of a field buffer */
-	//  CONSECUTIVE_BOT_FIELD,      /* bottom field data stored consecutlively in all lines of a field buffer */
-	//  CONSECUTIVE_FRAME,           /* progressive frame data stored consecutlively in all lines of a frame buffer */
-	//  INTERLEAVED_TOP_FIELD_422,  /* top    field data stored in even lines of a frame buffer */
-	//  INTERLEAVED_BOT_FIELD_422,      /* bottom field data stored in odd  lines of a frame buffer */
-	//  CONSECUTIVE_TOP_FIELD_422,      /* top    field data stored consecutlively in all lines of a field buffer */
-	//  CONSECUTIVE_BOT_FIELD_422,      /* bottom field data stored consecutlively in all lines of a field buffer */
-	//  CONSECUTIVE_FRAME_422,        /* progressive frame with 4:2:2 chroma */
-	//  TOP_BOTTOM_FRAME,            /* top field in the 0~height/2-1, bottom field in the height/2~height-1 in the frame */
-	//  UNPAIRED_INTERLEAVED_TOP_FIELD,
-	//  UNPAIRED_INTERLEAVED_BOT_FIELD,
-	//} VP_PICTURE_MODE ;
 	unsigned int nInterlaceMode;
 	unsigned int nSeiPtsHigh; /* SEI PTS High */
 	unsigned int nSeiPtsSLow; /* SEI PTS Low */
@@ -166,18 +150,7 @@ typedef struct {
 	unsigned int nSampleHeight;
 	unsigned int qlevel_sel_y;
 	unsigned int qlevel_sel_c;
-	/* nHDR_Type define
-  typedef enum
-  {
-      VP_HDR_FORMAT_INVALID = -1,
-      VP_HDR_FORMAT_SDR = 0,
-      VP_HDR_FORMAT_SDR_2020 = 1,
-      VP_HDR_FORMAT_DOLBY = 2,
-      VP_HDR_FORMAT_HDR10_PLUS = 3,
-      VP_HDR_FORMAT_TC = 4,
-      VP_HDR_FORMAT_HDR10 = 5,
-      VP_HDR_FORMAT_HLG = 6,
-  } VP_HDR_FORMAT ; */
+	/* nHDR_Type define */
 	unsigned int nHDR_Type;
 	unsigned int nDisplayPrimaries_X[3];
 	unsigned int nDisplayPrimaries_Y[3];
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.c b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.c
index c39d2f08a165..1aefa7ea9b0c 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.c
@@ -28,9 +28,6 @@
 #include "ve2_frame.h"
 
 #include <soc/realtek/memory.h>
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 116)
-#include <soc/realtek/rtk_media_heap.h>
-#endif
 
 #define RES_4K_SIZE (5570560) //2560*2176
 
@@ -205,12 +202,6 @@ static void __maybe_unused dump_frame(volatile ve2rpc_flash_frame_info_t *frame)
 		       htonl(frame->nPixelAR_hor));
 	vpu_output_dbg("frame->nPixelAR_ver = %x\n",
 		       htonl(frame->nPixelAR_ver));
-
-	//for (i=0; i<22; i++)
-	//{
-	//    vpu_dbg("frame->reserved[%d] = %x\n", i, frame->reserved[i]);
-	//}
-	//sleep(1);
 }
 
 static void __maybe_unused _dump_ringbuf(struct ve2rpc_ringbuf_t *prb)
@@ -258,11 +249,10 @@ static struct ve2rpc_ion_object *_ve2rpc_ion_create(struct ve2rpc *hndl,
 						    unsigned int flags)
 {
 	struct ve2rpc_ion_object *ion_obj;
-	struct dma_buf_attachment *attachment;
-	struct sg_table *sgt;
+	struct dma_buf_attachment *attachment __maybe_unused;
+	struct sg_table *sgt __maybe_unused;
 	dma_addr_t dma_addr;
-
-	int ret = 0;
+	void *vaddr;
 
 	if (!hndl) {
 		vpu_err("allocate ion_obj fail, No initital\n");
@@ -275,77 +265,27 @@ static struct ve2rpc_ion_object *_ve2rpc_ion_create(struct ve2rpc *hndl,
 		return ERR_PTR(-ENOMEM);
 	}
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 10, 116)
-	ion_obj->dmabuf = rheap_alloc(name, size, flags);
-#else
-	ion_obj->dmabuf = ion_alloc(size, mask, flags);
-#endif
-	if (IS_ERR(ion_obj->dmabuf)) {
+	/* We can't limit the address from dma_alloc_coherent when size <= 4096 */
+	if (size < SZ_8K)
+		size = SZ_8K;
+
+	vaddr = dma_alloc_coherent(hndl->dev, size, &dma_addr, GFP_KERNEL);
+	if (!vaddr) {
+		vpu_err("%s dma_alloc fail \n", __func__);
 		kfree(ion_obj);
-		vpu_err("%s ion_alloc fail, No Memory\n", __func__);
 		return ERR_PTR(-ENOMEM);
 	}
-
-	attachment = dma_buf_attach(ion_obj->dmabuf, hndl->dev);
-	if (IS_ERR(attachment)) {
-		ret = PTR_ERR(attachment);
-		goto put_dma_buf;
-	}
-	ion_obj->attach = attachment;
-
-	sgt = dma_buf_map_attachment(attachment, DMA_BIDIRECTIONAL);
-	if (IS_ERR(sgt)) {
-		ret = PTR_ERR(sgt);
-		goto detach_dma_buf;
-	}
-	ion_obj->sgt = sgt;
-
-	if (sgt->nents != 1) {
-		ret = -EINVAL;
-		goto unmap_attachment;
-	}
-
-	dma_addr = sg_dma_address(sgt->sgl);
-	if (!dma_addr) {
-		ret = -ENOMEM;
-		goto unmap_attachment;
-	}
+	ion_obj->vaddr = vaddr;
 	ion_obj->paddr = dma_addr;
-
-	if (flags & (RTK_FLAG_PROTECTED_MASK | RTK_FLAG_PROTECTED_EXT_MASK)) {
-		ion_obj->vaddr = 0;
-	} else {
-		dma_buf_begin_cpu_access(ion_obj->dmabuf, DMA_BIDIRECTIONAL);
-
-		ret = dma_buf_vmap(ion_obj->dmabuf, &ion_obj->map);
-		ion_obj->vaddr = ion_obj->map.vaddr;
-		if (!ion_obj->vaddr) {
-			ret = -ENOMEM;
-			goto end_cpu_access;
-		}
-		memset(ion_obj->vaddr, 0, size);
-	}
 	ion_obj->size = size;
 
 	memset(ion_obj->vaddr, 0, size);
 
 	return ion_obj;
-
-end_cpu_access:
-	dma_buf_end_cpu_access(ion_obj->dmabuf, DMA_BIDIRECTIONAL);
-unmap_attachment:
-	dma_buf_unmap_attachment(attachment, sgt, DMA_TO_DEVICE);
-detach_dma_buf:
-	dma_buf_detach(ion_obj->dmabuf, attachment);
-put_dma_buf:
-	dma_buf_put(ion_obj->dmabuf);
-
-	kfree(ion_obj);
-
-	return ERR_PTR(ret);
 }
 
-static void _ve2rpc_ion_free(struct ve2rpc_ion_object *ion_obj)
+static void _ve2rpc_ion_free(struct ve2rpc *hndl,
+								struct ve2rpc_ion_object *ion_obj)
 {
 	if (!ion_obj) {
 		vpu_err("_ve2rpc_ion_free ion_obj is NULL\n");
@@ -360,6 +300,12 @@ static void _ve2rpc_ion_free(struct ve2rpc_ion_object *ion_obj)
 		dma_buf_detach(ion_obj->dmabuf, ion_obj->attach);
 		dma_buf_put(ion_obj->dmabuf);
 	}
+	else
+	{
+		if (ion_obj->vaddr) {
+			dma_free_coherent(hndl->dev, ion_obj->size, ion_obj->vaddr, ion_obj->paddr);
+		}
+	}
 
 	kfree(ion_obj);
 }
@@ -472,9 +418,11 @@ static int handle_rpc_command(struct rtk_krpc_ept_info *krpc_ept_info,
 	int cmd;
 	char *event;
 	HRESULT retval = S_OK;
-	struct v4l2_pix_format pix;
+	struct vpu_fmt vpu_fmt;
 	ssize_t size = 0;
 	struct rpc_struct *rpc_head = (struct rpc_struct *)buf;
+	uint32_t width = 0;
+	uint32_t height = 0;
 
 	vpu_input_dbg("rpc_kern_ve2_read, cmd %d, count %lu, size %d\n",
 		      rpc_head->procedureID, sizeof(rpc_head),
@@ -497,7 +445,8 @@ static int handle_rpc_command(struct rtk_krpc_ept_info *krpc_ept_info,
 		}
 		memcpy(event, buf + sizeof(struct rpc_struct),
 		       rpc_head->parameterSize);
-		vpu_err("ve2 fatal error!!\n");
+		hndl->is_error = true;
+		vpu_err("ve2 decode error!!\n");
 		kfree(event);
 		break;
 	case VIDEO_RPC_DEC_ToSystem_Deliver_MediaInfo:
@@ -548,12 +497,18 @@ static int handle_rpc_command(struct rtk_krpc_ept_info *krpc_ept_info,
 			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)
 				      ->reserved4));
 
-		vpu_get_cap_fmt(fh, (void *)&pix);
-		pix.width = ((struct VIDEO_RPC_VOUT_MESSAGE *)event)->reserved1;
-		pix.height =
-			((struct VIDEO_RPC_VOUT_MESSAGE *)event)->reserved2;
-		pix.bytesperline = pix.width;
-		vpu_update_cap_fmt(fh, (void *)&pix);
+		width = ((struct VIDEO_RPC_VOUT_MESSAGE *)event)->reserved1;
+		height = ((struct VIDEO_RPC_VOUT_MESSAGE *)event)->reserved2;
+
+		if (!hndl->is_adaptive_playback)
+			hndl->main_rb.pRBH->reserve3 = htonl(width << 16 | height);
+
+		vpu_get_cap_fmt(fh, (void *)&vpu_fmt);
+		vpu_fmt.spec.fmt.pix.width = width;
+		vpu_fmt.spec.fmt.pix.height = height;
+		vpu_fmt.spec.fmt.pix.bytesperline = width;
+		vpu_update_cap_fmt(fh, (void *)&vpu_fmt);
+
 		vpu_notify_event_resolution_change(fh);
 		kfree(event);
 		break;
@@ -688,14 +643,10 @@ static int _ve2rpc_shuttle(struct ve2rpc *hndl, int cmd, void *data, int size,
 	dsb(sy);
 	offset = get_rpc_alignment_offset(size);
 	dat = ion_obj->paddr;
-#if IS_ENABLED(CONFIG_KERN_RPC_HANDLE_COMMAND)
-	if (send_rpc_command_with_pid(RPC_VIDEO, hndl->rpc_id, cmd, dat,
-				      dat + offset, &RPC_ret))
-#else
+
 	if (send_rpc(hndl, RPC_VIDEO, cmd, dat, dat + offset, &RPC_ret))
-#endif
 	{
-		_ve2rpc_ion_free(ion_obj);
+		_ve2rpc_ion_free(hndl, ion_obj);
 		vpu_err("ve2rpc fail, cmd %d\n", cmd);
 		return -EPERM;
 	} else {
@@ -703,11 +654,10 @@ static int _ve2rpc_shuttle(struct ve2rpc *hndl, int cmd, void *data, int size,
 			if (rpc_ret)
 				memcpy_toio(rpc_ret, ion_obj->vaddr + offset,
 					    rpc_ret_size);
-			_ve2rpc_ion_free(ion_obj);
-			//vpu_err("\t\t\t\t\t\t%s exit\n",__func__);
+			_ve2rpc_ion_free(hndl, ion_obj);
 			return 0;
 		} else {
-			_ve2rpc_ion_free(ion_obj);
+			_ve2rpc_ion_free(hndl, ion_obj);
 			vpu_err("ve2rpc return fail, cmd %d\n", cmd);
 			return -EPERM;
 		}
@@ -725,14 +675,14 @@ static int _ve2rpc_ringbuf_release(struct ve2rpc *hndl,
 
 	if (ringbuf->rbinfo.hdr_hdl) {
 		mutex_lock(&ringbuf->lock);
-		_ve2rpc_ion_free(ringbuf->rbinfo.hdr_hdl);
+		_ve2rpc_ion_free(hndl, ringbuf->rbinfo.hdr_hdl);
 		ringbuf->rbinfo.hdr_hdl = NULL;
 		mutex_unlock(&ringbuf->lock);
 	}
 
 	if (ringbuf->rbinfo.buf_hdl) {
 		mutex_lock(&ringbuf->lock);
-		_ve2rpc_ion_free(ringbuf->rbinfo.buf_hdl);
+		_ve2rpc_ion_free(hndl, ringbuf->rbinfo.buf_hdl);
 		ringbuf->rbinfo.buf_hdl = NULL;
 		mutex_unlock(&ringbuf->lock);
 	}
@@ -766,7 +716,7 @@ int ve2rpc_SetRingBuffer(struct ve2rpc *hndl, struct ve2rpc_ringbuf_t *prb,
 	head = _ve2rpc_media_ion_create(hndl,
 					sizeof(struct _tagRingBufferHeader));
 	if (IS_ERR(head)) {
-		_ve2rpc_ion_free(body);
+		_ve2rpc_ion_free(hndl, body);
 		vpu_err("allocate head fail, No Memory\n");
 		return -ENOMEM;
 	}
@@ -838,89 +788,15 @@ int ve2rpc_SetRingBuffer(struct ve2rpc *hndl, struct ve2rpc_ringbuf_t *prb,
 	return 0;
 }
 
-#if IS_ENABLED(CONFIG_KERN_RPC_HANDLE_COMMAND)
-static void ve2_handle_acpu_rpc(RPC_STRUCT *rpc, char *buf, void *data)
-{
-	struct ve2rpc *hndl = (struct ve2rpc *)data;
-	struct v4l2_fh *fh = hndl->fh;
-	int cmd;
-	char *event;
-	struct v4l2_pix_format pix;
-	uint32_t size = rpc->parameterSize;
-
-	vpu_input_dbg("%s, cmd %d\n", __func__, rpc->procedureID);
-	cmd = rpc->procedureID;
-	switch (cmd) {
-	case VIDEO_RPC_DEC_ToSystem_FatalError:
-		event = buf;
-		if (size != sizeof(struct VIDEO_RPC_DEC_ERROR_INFO)) {
-			pr_err("%s: VIDEO_RPC_DEC_ToSystem_FatalError: rpc data size not match(expect:%ld real:%d)\n",
-			       __func__,
-			       sizeof(struct VIDEO_RPC_DEC_ERROR_INFO), size);
-		}
-		vpu_err("ve2 fatal error!!\n");
-		break;
-	case VIDEO_RPC_DEC_ToSystem_Deliver_MediaInfo:
-		event = buf;
-		if (size != sizeof(struct VIDEO_RPC_DEC_MEDIA_INFO)) {
-			pr_err("%s: VIDEO_RPC_DEC_MEDIA_INFO: rpc data size not match(expect:%ld real:%d)\n",
-			       __func__,
-			       sizeof(struct VIDEO_RPC_DEC_MEDIA_INFO), size);
-		}
-		break;
-	case VIDEO_RPC_ToSystem_VoutMessage:
-		event = buf;
-		if (size != sizeof(struct VIDEO_RPC_VOUT_MESSAGE)) {
-			pr_err("%s: VIDEO_RPC_VOUT_MESSAGE: rpc data size not match(expect:%ld real:%d)\n",
-			       __func__, sizeof(struct VIDEO_RPC_VOUT_MESSAGE),
-			       size);
-		}
-		vpu_input_dbg(
-			"instanceID %x, message %x, PTShigh %x, PTSlow %x, reserved %x %x %x %x\n",
-			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)
-				      ->instanceID),
-			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)->message),
-			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)->PTShigh),
-			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)->PTSlow),
-			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)
-				      ->reserved1),
-			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)
-				      ->reserved2),
-			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)
-				      ->reserved3),
-			htonl(((struct VIDEO_RPC_VOUT_MESSAGE *)event)
-				      ->reserved4));
-		vpu_get_cap_fmt(fh, (void *)&pix);
-		pix.width = htonl(
-			((struct VIDEO_RPC_VOUT_MESSAGE *)event)->reserved1);
-		pix.height = htonl(
-			((struct VIDEO_RPC_VOUT_MESSAGE *)event)->reserved2);
-		pix.bytesperline = pix.width;
-		vpu_update_cap_fmt(fh, (void *)&pix);
-		vpu_notify_event_resolution_change(fh);
-		break;
-	default:
-		break;
-	}
-
-	return;
-}
-#endif
-
 static int _ve2rpc_open(struct ve2rpc *hndl, int type, struct v4l2_fh *fh)
 {
 	VIDEO_RPC_INSTANCE instance;
 	unsigned int ret;
 	RPCRES_LONG retval;
 	hndl->fh = fh;
-#if IS_ENABLED(CONFIG_KERN_RPC_HANDLE_COMMAND)
-	hndl->rpc_id = register_kernel_rpc("ve2rpc", RPC_VIDEO,
-					   &ve2_handle_acpu_rpc, hndl);
-#else
 	hndl->vcpu_ept_info = get_ve2_krpc_info();
 	ret = krpc_info_init(hndl->vcpu_ept_info, "ve2rpc", krpc_vcpu_cb);
 	hndl->vcpu_ept_info->priv = (void *)hndl;
-#endif
 
 	instance.type = htonl(type);
 	ret = _ve2rpc_shuttle(hndl, VIDEO_RPC_COMMON_ToAgent_Create, &instance,
@@ -968,11 +844,8 @@ int ve2rpc_close(struct ve2rpc *hndl)
 		}
 	}
 
-#if IS_ENABLED(CONFIG_KERN_RPC_HANDLE_COMMAND)
-	unregister_kernel_rpc(RPC_VIDEO, hndl->rpc_id);
-#else
 	krpc_info_deinit(hndl->vcpu_ept_info);
-#endif
+	krpc_ept_info_put(hndl->vcpu_ept_info);
 
 	hndl->instanceType = -1;
 	hndl->instanceID = -1;
@@ -1080,7 +953,8 @@ int ve2rpc_set_cmprs(struct ve2rpc *hndl, uint8_t enable)
 
 int ve2rpc_get_bs_info(struct device *dev, void *fh, uint32_t codec,
 		       uint32_t size, void *buf, uint32_t *width,
-		       uint32_t *height, uint32_t *min_reqbuf,
+		       uint32_t *height, uint32_t *ddr_width,
+		       uint32_t *ddr_height, uint32_t *min_reqbuf,
 		       uint32_t *bit_depth)
 {
 	struct ve2rpc *hndl;
@@ -1125,13 +999,16 @@ int ve2rpc_get_bs_info(struct device *dev, void *fh, uint32_t codec,
 			VIDEO_RPC_DEC_ToAgent_BitstreamValidation);
 	}
 
-	*width = htonl(output.width);
-	*height = htonl(output.height);
+	*width = htonl(output.width) >> 16;
+	*height = htonl(output.height) >> 16;
+	*ddr_width = htonl(output.width) & 0xffff;
+	*ddr_height = htonl(output.height) & 0xffff;
 	*bit_depth = htonl(output.bit_depth);
 	*min_reqbuf = htonl(output.DPB_size);
 
-	_ve2rpc_ion_free(bs_buf);
+	_ve2rpc_ion_free(hndl, bs_buf);
 	krpc_info_deinit(hndl->vcpu_ept_info);
+	krpc_ept_info_put(hndl->vcpu_ept_info);
 	kfree(hndl);
 
 	return ret;
@@ -1624,42 +1501,6 @@ int ve2rpc_write_bs(struct ve2rpc *hndl, uint8_t *buf, uint32_t len,
 		vpu_input_dbg("command buffer is too small %d\n", space);
 		return -ENOSPC;
 	}
-#if 0
-    for (i=0;i<len-3;i++)
-    {
-        if ((buf[i]==0)&&(buf[i+1]==0)&&(buf[i+2]==0)&&(buf[i+3]==1))
-        {//Separating the extra data and bs data to different buffer shall handled by application
-            if ((buf[i+4]==0x40) || (buf[i+4]==0x42) || (buf[i+4]==0x44))
-            {
-                //vpu_err("seq %d hit 0x00000001%x @%d\n", sequence, buf[i+4], i);
-                i+=4;
-                continue;
-            }
-            else
-            {
-                if (i != 0)
-                {
-                    //vpu_err("seq %x hit 0x00000001%x @%d\n", sequence, buf[i+4], i);
-                    writePtrforPTS = htonl(hndl->main_rb.pRBH->writePtr);
-                    ret = ve2rpc_inband_pts2(&hndl->sub_rb, writePtrforPTS, (uint64_t)sequence<<32, pts, len, 0);
-                    if (ret)
-                    {
-                        vpu_err("ve2rpc_inband_pts2 fail %d\n", ret);
-                        return -EFAULT;
-                    }
-                    ret = _ve2rpc_write(&hndl->main_rb, RINGBUFFER_STREAM, buf, i);
-                    if (ret)
-                    {
-                        vpu_err("_ve2rpc_write RINGBUFFER_STREAM fail %d\n", ret);
-                        return -EFAULT;
-                    }
-                    buf += i;
-                }
-                break;
-            }
-        }
-    }
-#endif
 
 	writePtrforPTS = htonl(hndl->main_rb.pRBH->writePtr);
 	ret = ve2rpc_inband_pts2(&hndl->sub_rb, writePtrforPTS,
@@ -1811,9 +1652,9 @@ int ve2rpc_add_capbuf_to_dpb(struct ve2rpc *out_hndl, struct ve2rpc *cap_hndl,
 
 	if (i == VE2_MAX_DPB_NUM) {
 		if (cmprs)
-			_ve2rpc_ion_free(cmprs);
+			_ve2rpc_ion_free(cap_hndl, cmprs);
 		vpu_err("all dpb buffers are used\n");
-		mutex_unlock(&out_hndl->dpb_mutex);
+		mutex_unlock(&cap_hndl->dpb_mutex);
 		ret = -ENOMEM;
 		goto exit;
 	}
@@ -1827,7 +1668,6 @@ int ve2rpc_add_capbuf_to_dpb(struct ve2rpc *out_hndl, struct ve2rpc *cap_hndl,
 	cap_hndl->dpb[i].buflock_phy_addr = cap_hndl->buflockPhy[i];
 	cap_hndl->dpb[i].idx = idx;
 	cap_hndl->dpb_cnt++;
-	ret = i;
 	mutex_unlock(&cap_hndl->dpb_mutex);
 
 	ret = ve2rpc_inband_add_buf(&out_hndl->dpb_rb, width, height,
@@ -1857,7 +1697,7 @@ int ve2rpc_del_capbuf_from_dpb(struct ve2rpc *out_hndl, struct ve2rpc *cap_hndl)
 			ret = ve2rpc_inband_del_buf(
 				&out_hndl->dpb_rb, cap_hndl->dpb[i].y_phy_addr);
 			if (cap_hndl->dpb[i].cmprs != 0)
-				_ve2rpc_ion_free(cap_hndl->dpb[i].cmprs);
+				_ve2rpc_ion_free(cap_hndl, cap_hndl->dpb[i].cmprs);
 			cap_hndl->dpb[i].y_phy_addr = 0;
 			cap_hndl->dpb[i].status = RTKVE2_DPB_ST_EMPTY;
 		}
@@ -1948,7 +1788,6 @@ int ve2rpc_qframe(struct ve2rpc *cap_hndl, dma_addr_t phy_addr,
 
 	frame = (volatile ve2rpc_flash_frame_info_t *)cap_hndl->frame[frm_idx];
 
-	//vpu_err("queue frame %p(%d), Userdata %p buflock_va %x (%p)(%x) unlock\n", frame, work_idx, vaddr, *buflock_va, buflock_va, buflock_pa);
 	if (isInitial) {
 		mutex_lock(&prb->lock);
 		memset_volatile(frame, 0, sizeof(ve2rpc_flash_frame_info_t));
@@ -1992,10 +1831,8 @@ int ve2rpc_qframe(struct ve2rpc *cap_hndl, dma_addr_t phy_addr,
 
 		queue_delayed_work(cap_hndl->qframe.wq, &cap_hndl->qframe.work,
 				   delay);
-		//flush_workqueue(qframe.wq);
 	}
 
-	//vpu_err("will queue new frame %p(%d), Userdata %p buflock_va[%d] %x (%p)(%x) \n", frame, work_idx, vaddr, i, buflock_va[i], &buflock_va[i], buflock_pa + i);
 	return 0;
 }
 
@@ -2091,7 +1928,6 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 	volatile ve2rpc_flash_frame_info_t *frame;
 	struct ve2rpc_ion_object *buflock;
 	volatile uint8_t *buflock_va;
-	//struct ve_frame_info *ve2frame_info;
 	uint32_t flags;
 	struct traveling_frame_st *tframe;
 
@@ -2105,14 +1941,14 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 
 	uint64_t estPTS = ULLONG_MAX;
 	uint32_t estIdx = UINT_MAX;
-#if 0
-	uint32_t matrix_coefficients;
-	uint32_t transferCharacteristics;
-#endif
-	uint64_t y_phy_addr = 0;
-	uint64_t c_phy_addr = 0;
+	uint32_t y_phy_addr = 0;
+	uint32_t c_phy_addr = 0;
+	uint32_t buflock_phy_addr = 0;
 	uint32_t idx = 0xFFFFFFFF;
+	struct traveling_frame_st *tentry;
+	struct traveling_frame_st *tmp_tentry = NULL;
 	int i = 0;
+	int ret = 0;
 
 	frame = (volatile ve2rpc_flash_frame_info_t *)cap_hndl->frame[frm_idx];
 
@@ -2120,6 +1956,7 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 	dsb(sy);
 	y_phy_addr = htonl(frame->nPicPhysicalAddr);
 	c_phy_addr = htonl(frame->nPicCPhysicalAddr);
+	buflock_phy_addr =  htonl(frame->nBufLockPhysicalAddr);
 
 	ptsLow = htonl(frame->nPtsLow);
 	ptsHigh = htonl(frame->nPtsHigh);
@@ -2132,6 +1969,18 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 
 	dsb(sy);
 
+	mutex_lock(&cap_hndl->travel_mutex);
+	list_for_each_entry_safe (tentry, tmp_tentry, &cap_hndl->qframe.tlist,
+		list) {
+		if (tentry->phy_addr == y_phy_addr) {
+			vpu_output_dbg("Show existing frame!!!!");
+			ret = -EBUSY;
+			mutex_unlock(&cap_hndl->travel_mutex);
+			return ret;
+		}
+	}
+	mutex_unlock(&cap_hndl->travel_mutex);
+
 	mutex_lock(&cap_hndl->pts_mutex);
 	//find the smallest pts
 	if (cap_hndl->pts_queue) {
@@ -2158,7 +2007,7 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 
 	frmPTS = estPTS;
 	if (ptsHigh != estIdx)
-		vpu_warn("Refine PTS\n");
+		vpu_output_dbg("Refine PTS\n");
 
 	if (cap_hndl->pre_pts > frmPTS)
 		vpu_warn("PTS roll back %lld => %lld\n", cap_hndl->pre_pts,
@@ -2177,7 +2026,7 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 	}
 
 	if (pts)
-		*pts = frmPTS * 1000;
+		*pts = frmPTS;
 
 
 	*eos = false;
@@ -2198,10 +2047,10 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 	mutex_lock(&cap_hndl->buflock_mutex);
 	buflock = (struct ve2rpc_ion_object *)cap_hndl->buflock;
 	buflock_va =
-		_get_buflock_va(buflock, htonl(frame->nBufLockPhysicalAddr));
+		_get_buflock_va(buflock, buflock_phy_addr);
 	if (!buflock_va)
 		vpu_err("can't find buflock_va by buflock_pa 0x%x, buflock %p\n",
-			htonl(frame->nBufLockPhysicalAddr), buflock);
+			buflock_phy_addr, buflock);
 
 	if (*buflock_va == E_BUFLOCK_ST_TOUCH) {
 		*buflock_va = E_BUFLOCK_ST_LOCK;
@@ -2214,15 +2063,14 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 		for (i = 0; i < VE2_MAX_DPB_NUM; i++) {
 			if (cap_hndl->dpb[i].y_phy_addr == y_phy_addr) {
 				*disp_buf = cap_hndl->dpb[i].vb2_v4l2_buf;
-				cap_hndl->dpb[i].buflock_phy_addr =
-					htonl(frame->nBufLockPhysicalAddr);
+				cap_hndl->dpb[i].buflock_phy_addr = buflock_phy_addr;
 				idx = cap_hndl->dpb[i].idx;
 				break;
 			}
 		}
 
 		if (i == VE2_MAX_DPB_NUM) {
-			vpu_err("Can't find vb2_v4l2_buf for 0x%llx\n",
+			vpu_err("Can't find vb2_v4l2_buf for 0x%x\n",
 				y_phy_addr);
 			mutex_unlock(&cap_hndl->dpb_mutex);
 			return -ENODATA;
@@ -2232,8 +2080,7 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 			if (cap_hndl->dpb[i].status != RTKVE2_DPB_ST_EMPTY &&
 				cap_hndl->dpb[i].buflock_phy_addr == 0) {
 				*disp_buf = cap_hndl->dpb[i].vb2_v4l2_buf;
-				cap_hndl->dpb[i].buflock_phy_addr =
-					htonl(frame->nBufLockPhysicalAddr);
+				cap_hndl->dpb[i].buflock_phy_addr = buflock_phy_addr;
 				idx = cap_hndl->dpb[i].idx;
 				break;
 			}
@@ -2259,7 +2106,7 @@ static int _ve2rpc_get_frame(struct ve2rpc *cap_hndl, void **disp_buf,
 	mutex_lock(&cap_hndl->travel_mutex);
 	list_add_tail(&tframe->list, &cap_hndl->qframe.tlist);
 	mutex_unlock(&cap_hndl->travel_mutex);
-	return 0;
+	return ret;
 }
 
 int ve2rpc_dqframe(struct ve2rpc *cap_hndl, void *disp_buf, uint64_t *pts,
@@ -2292,14 +2139,14 @@ int ve2rpc_dqframe(struct ve2rpc *cap_hndl, void *disp_buf, uint64_t *pts,
 			next_rp = htonl(prb->pRBH->beginAddr) +
 				  ((rp_idx + 1) % VE2_MAX_DPB_NUM) *
 					  sizeof(ve2rpc_flash_frame_info_t);
-			//vpu_err("prb->pRBH->readPtr[0] %x prb->pRBH->writePtr %x next_rp %x, size %x idx %d\n", htonl(prb->pRBH->readPtr[0]), htonl(prb->pRBH->writePtr), next_rp, sizeof(ve2rpc_flash_frame_info_t), rp_idx);
 
 			ret = _ve2rpc_get_frame(cap_hndl, disp_buf, pts, rp_idx,
 						eos, no_frame, prb->secure);
 			if (ret) {
-				vpu_err("fail to get a frame, try again ret %d\n",
-					ret);
 				mutex_unlock(&prb->lock);
+				if (ret != -EBUSY)
+					vpu_err("fail to get a frame, try again ret %d\n",
+						ret);
 				return -EAGAIN;
 			}
 			prb->pRBH->readPtr[0] = htonl(next_rp);
@@ -2309,9 +2156,6 @@ int ve2rpc_dqframe(struct ve2rpc *cap_hndl, void *disp_buf, uint64_t *pts,
 		vpu_err("wrong ringbuffer header\n");
 	}
 	mutex_unlock(&prb->lock);
-	//vpu_err("prb->pRBH->readPtr[0] %x prb->pRBH->writePtr %x pts %lld ret %d\n", htonl(prb->pRBH->readPtr[0]), htonl(prb->pRBH->writePtr), *pts, ret);
-	//_dump_ringbuf(prb);
-	//_dump_buflock(cap_hndl);
 
 	return ret;
 }
@@ -2351,8 +2195,7 @@ int ve2rpc_free_travel_frame(struct ve2rpc *cap_hndl)
 	list_for_each_entry_safe (tentry, tmp_tentry, &cap_hndl->qframe.tlist,
 				  list) {
 		if (tentry) {
-			if ((tentry->phy_addr != 0) &&
-			    (tentry->vb2_q_idx >= 0)) {
+			if (tentry->vb2_q_idx >= 0) {
 				int ret;
 				vpu_output_dbg(
 					"free the traveling frame tentry = %p, work_idx = %d\n",
@@ -2595,7 +2438,7 @@ int ve2rpc_uninit_handle(struct ve2rpc *hndl)
 	}
 
 	if (hndl->buflock) {
-		_ve2rpc_ion_free(hndl->buflock);
+		_ve2rpc_ion_free(hndl, hndl->buflock);
 		hndl->buflock = NULL;
 		mutex_destroy(&hndl->buflock_mutex);
 	}
@@ -2625,8 +2468,6 @@ int ve2rpc_setDecoderCCBypass(struct ve2rpc *hndl, int mode)
 
 	info.instanceID = htonl(hndl->instanceID);
 	info.cc_mode = htonl(mode);
-	//vpu_err("ve2rpc_setDecoderCCBypass instanceID %x cc_mode %x size %d\n", hndl->instanceID, mode, sizeof(info));
-	//vpu_err("ve2rpc_setDecoderCCBypass instanceID %x cc_mode %x size %d afeter htonl\n", (info.instanceID), info.cc_mode, sizeof(info));
 
 	ret = _ve2rpc_shuttle(hndl, VIDEO_RPC_DEC_ToAgent_SetDecoderCCBypass,
 			      &info, sizeof(info), NULL, 0);
@@ -2665,8 +2506,6 @@ int ve2rpc_readCcRingBuf(struct ve2rpc_ringbuf_t *prb, uint32_t length,
 				pcDst);
 			break;
 		}
-		//vpu_err("CC ringbuffer base=%08x limit=%08x wp=%08x rp=%08x (space=%d length=%d)\n", base, base+size, wp, rp, space, length);
-		//vpu_err("CC %08x %08x \n", prb->buf_cached, prb->rbinfo.buf_uncached);
 
 		rp_offset = rp - base;
 		if (wp >= rp) {
@@ -2674,20 +2513,17 @@ int ve2rpc_readCcRingBuf(struct ve2rpc_ringbuf_t *prb, uint32_t length,
 				read_len = length;
 			else
 				read_len = wp - rp;
-			//vpu_err("CC %s %d %08x %08x %08x \n", __FUNCTION__, __LINE__, pcDst, pcSrc + rp_offset, read_len);
 			memcpy(pcDst, pcSrc + rp_offset, read_len);
 		} else {
 			uint32_t top = base + size;
 			uint32_t top_space = top - rp;
 			if (top_space >= length) {
 				read_len = length;
-				//vpu_err("CC %s %d", __FUNCTION__, __LINE__);
 				memcpy(pcDst, pcSrc + rp_offset, read_len);
 			} else {
 				uint32_t data_bytes_in_buff =
 					top_space + (wp - base);
 				read_len = top_space;
-				//vpu_err("CC %s %d", __FUNCTION__, __LINE__);
 				memcpy(pcDst, pcSrc + rp_offset, top_space);
 				data_bytes_in_buff -= read_len;
 				rp_offset += read_len;
@@ -2697,7 +2533,6 @@ int ve2rpc_readCcRingBuf(struct ve2rpc_ringbuf_t *prb, uint32_t length,
 					remind_len = data_bytes_in_buff;
 				}
 				read_len += remind_len;
-				//vpu_err("CC %s %d", __FUNCTION__, __LINE__);
 				memcpy(pcDst + top_space, pcSrc + rp_offset,
 				       remind_len);
 			}
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.h b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.h
index 06cb7a160c92..41e8a46a3461 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/ve2rpc.h
@@ -16,7 +16,6 @@
 #include <linux/types.h>
 #include <linux/mutex.h>
 #include <linux/version.h>
-#include <linux/iosys-map.h>
 #include <soc/realtek/rtk-krpc-agent.h>
 #include "ve2rpc_cmd.h"
 
@@ -174,7 +173,6 @@ struct ve2rpc {
 	void *buflock;
 	uintptr_t *frame;
 	struct ve2rpc_qframe_wq qframe;
-	//void  *dvo;
 	struct mutex lock;
 	struct mutex pts_mutex;
 	struct list_head *pts_queue;
@@ -198,6 +196,8 @@ struct ve2rpc {
 	struct mutex dpb_mutex;
 	uint32_t dpb_cnt;
 	uint8_t is_secure;
+	uint8_t is_adaptive_playback;
+	uint8_t is_error;
 };
 
 struct pts_queue {
@@ -259,7 +259,8 @@ int ve2rpc_inband_del_buf(struct ve2rpc_ringbuf_t *ringbuf,
 			   uint32_t y_phy_addr);
 int ve2rpc_set_cmprs(struct ve2rpc *hndl, uint8_t enable);
 int ve2rpc_get_bs_info(struct device *dev, void *fh, uint32_t codec,
-			   uint32_t size, void *buf, uint32_t *width,
-			   uint32_t *height, uint32_t *min_reqbuf,
-			   uint32_t *bit_depth);
+		       uint32_t size, void *buf, uint32_t *width,
+		       uint32_t *height, uint32_t *ddr_width,
+		       uint32_t *ddr_height, uint32_t *min_reqbuf,
+		       uint32_t *bit_depth);
 #endif
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c b/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c
index 52217fe9288e..aed5191d6e82 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.c
@@ -40,8 +40,11 @@ static uint32_t pixfmt = 0;
 
 #define RTK_DPB_WIDTH_ALIGN 32
 #define RTK_DPB_HEIGHT_ALIGN 32
-#define RTK_DPB_VE2_WIDTH_ALIGN 64
-#define RTK_DPB_VE2_HEIGHT_ALIGN 128
+
+#define RTK_VPU_DEC_4K_CODED_MAX_WIDTH 4096
+#define RTK_VPU_DEC_4K_CODED_MAX_HEIGHT 2304
+#define RTK_VPU_DEC_2K_CODED_MAX_WIDTH 1920
+#define RTK_VPU_DEC_2K_CODED_MAX_HEIGHT 1088
 
 void vpu_cap_buf_done(struct v4l2_fh *fh, struct vb2_v4l2_buffer *buf, bool eos,
 		      enum vb2_buffer_state state);
@@ -67,10 +70,10 @@ const static struct vpu_fmt out_fmt[] = {
 
 		/* struct v4l2_frmsize_stepwise */
 		.frmsize.min_width = 64,
-		.frmsize.max_width = 4096,
+		.frmsize.max_width = RTK_VPU_DEC_4K_CODED_MAX_WIDTH,
 		.frmsize.step_width = 1,
 		.frmsize.min_height = 64,
-		.frmsize.max_height = 2160,
+		.frmsize.max_height = RTK_VPU_DEC_4K_CODED_MAX_HEIGHT,
 		.frmsize.step_height = 1,
 
 		/* struct vpu_misc */
@@ -94,10 +97,10 @@ const static struct vpu_fmt out_fmt[] = {
 
 		/* struct v4l2_frmsize_stepwise */
 		.frmsize.min_width = 64,
-		.frmsize.max_width = 4096,
+		.frmsize.max_width = RTK_VPU_DEC_2K_CODED_MAX_WIDTH,
 		.frmsize.step_width = 1,
 		.frmsize.min_height = 64,
-		.frmsize.max_height = 2160,
+		.frmsize.max_height = RTK_VPU_DEC_2K_CODED_MAX_HEIGHT,
 		.frmsize.step_height = 1,
 
 		/* struct vpu_misc */
@@ -121,10 +124,10 @@ const static struct vpu_fmt out_fmt[] = {
 
 		/* struct v4l2_frmsize_stepwise */
 		.frmsize.min_width = 64,
-		.frmsize.max_width = 4096,
+		.frmsize.max_width = RTK_VPU_DEC_2K_CODED_MAX_WIDTH,
 		.frmsize.step_width = 1,
 		.frmsize.min_height = 64,
-		.frmsize.max_height = 2160,
+		.frmsize.max_height = RTK_VPU_DEC_2K_CODED_MAX_HEIGHT,
 		.frmsize.step_height = 1,
 
 		/* struct vpu_misc */
@@ -148,10 +151,64 @@ const static struct vpu_fmt out_fmt[] = {
 
 		/* struct v4l2_frmsize_stepwise */
 		.frmsize.min_width = 64,
-		.frmsize.max_width = 4096,
+		.frmsize.max_width = RTK_VPU_DEC_2K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VPU_DEC_2K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 4,
+		.misc.VideoEngine = VIDEO_ENGINE_1,
+	},
+	{
+		.spec.fmt.pix.width = 1920,
+		.spec.fmt.pix.height = 1088,
+		.spec.fmt.pix.pixelformat = V4L2_PIX_FMT_VC1_ANNEX_G,
+		.spec.fmt.pix.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix.bytesperline = 0,
+		.spec.fmt.pix.sizeimage = 3 * 1024 * 1024, // FIXME: 1024*1024
+		.spec.fmt.pix.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix.priv = 0,
+		.spec.fmt.pix.flags = 0,
+		.spec.fmt.pix.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		.spec.type = V4L2_BUF_TYPE_VIDEO_OUTPUT,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VPU_DEC_2K_CODED_MAX_WIDTH,
+		.frmsize.step_width = 1,
+		.frmsize.min_height = 64,
+		.frmsize.max_height = RTK_VPU_DEC_2K_CODED_MAX_HEIGHT,
+		.frmsize.step_height = 1,
+
+		/* struct vpu_misc */
+		.misc.bufcnt = 4,
+		.misc.VideoEngine = VIDEO_ENGINE_1,
+	},
+	{
+		.spec.fmt.pix.width = 1920,
+		.spec.fmt.pix.height = 1088,
+		.spec.fmt.pix.pixelformat = V4L2_PIX_FMT_VC1_ANNEX_L,
+		.spec.fmt.pix.field = V4L2_FIELD_NONE,
+		.spec.fmt.pix.bytesperline = 0,
+		.spec.fmt.pix.sizeimage = 3 * 1024 * 1024, // FIXME: 1024*1024
+		.spec.fmt.pix.colorspace = V4L2_COLORSPACE_REC709,
+		.spec.fmt.pix.priv = 0,
+		.spec.fmt.pix.flags = 0,
+		.spec.fmt.pix.quantization = V4L2_QUANTIZATION_DEFAULT,
+		.spec.fmt.pix.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+		.spec.fmt.pix.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+		.spec.type = V4L2_BUF_TYPE_VIDEO_OUTPUT,
+
+		/* struct v4l2_frmsize_stepwise */
+		.frmsize.min_width = 64,
+		.frmsize.max_width = RTK_VPU_DEC_2K_CODED_MAX_WIDTH,
 		.frmsize.step_width = 1,
 		.frmsize.min_height = 64,
-		.frmsize.max_height = 2160,
+		.frmsize.max_height = RTK_VPU_DEC_2K_CODED_MAX_HEIGHT,
 		.frmsize.step_height = 1,
 
 		/* struct vpu_misc */
@@ -178,10 +235,10 @@ const static struct vpu_fmt out_fmt[] = {
 
 		/* struct v4l2_frmsize_stepwise */
 		.frmsize.min_width = 64,
-		.frmsize.max_width = 4096,
+		.frmsize.max_width = RTK_VPU_DEC_4K_CODED_MAX_WIDTH,
 		.frmsize.step_width = 1,
 		.frmsize.min_height = 64,
-		.frmsize.max_height = 2160,
+		.frmsize.max_height = RTK_VPU_DEC_4K_CODED_MAX_HEIGHT,
 		.frmsize.step_height = 1,
 
 		/* struct vpu_misc */
@@ -205,10 +262,10 @@ const static struct vpu_fmt out_fmt[] = {
 
 		/* struct v4l2_frmsize_stepwise */
 		.frmsize.min_width = 64,
-		.frmsize.max_width = 4096,
+		.frmsize.max_width = RTK_VPU_DEC_4K_CODED_MAX_WIDTH,
 		.frmsize.step_width = 1,
 		.frmsize.min_height = 64,
-		.frmsize.max_height = 2160,
+		.frmsize.max_height = RTK_VPU_DEC_4K_CODED_MAX_HEIGHT,
 		.frmsize.step_height = 1,
 
 		/* struct vpu_misc */
@@ -232,10 +289,10 @@ const static struct vpu_fmt out_fmt[] = {
 
 		/* struct v4l2_frmsize_stepwise */
 		.frmsize.min_width = 64,
-		.frmsize.max_width = 4096,
+		.frmsize.max_width = RTK_VPU_DEC_4K_CODED_MAX_WIDTH,
 		.frmsize.step_width = 1,
 		.frmsize.min_height = 64,
-		.frmsize.max_height = 2160,
+		.frmsize.max_height = RTK_VPU_DEC_4K_CODED_MAX_HEIGHT,
 		.frmsize.step_height = 1,
 
 		/* struct vpu_misc */
@@ -262,10 +319,10 @@ static const struct vpu_fmt cap_fmt[] = {
 
 		/* struct v4l2_frmsize_stepwise */
 		.frmsize.min_width = 64,
-		.frmsize.max_width = 4096,
+		.frmsize.max_width = RTK_VPU_DEC_4K_CODED_MAX_WIDTH,
 		.frmsize.step_width = 1,
 		.frmsize.min_height = 64,
-		.frmsize.max_height = 2160,
+		.frmsize.max_height = RTK_VPU_DEC_4K_CODED_MAX_HEIGHT,
 		.frmsize.step_height = 1,
 
 		/* struct vpu_misc */
@@ -296,7 +353,7 @@ static struct vpu_ctx *vq_to_vpu(struct vb2_queue *q)
 }
 
 static int vpu_buf_done(struct v4l2_fh *fh, struct vb2_v4l2_buffer *v4l2_buf,
-			uint64_t pts, uint32_t sizeimage, uint32_t sequence,
+			uint64_t timestamp, uint32_t sizeimage, uint32_t sequence,
 			bool eos, bool no_frame)
 {
 	struct vpu_ctx *ctx = fh_to_vpu(fh);
@@ -304,7 +361,7 @@ static int vpu_buf_done(struct v4l2_fh *fh, struct vb2_v4l2_buffer *v4l2_buf,
 
 	v4l2_buf->field = V4L2_FIELD_NONE;
 	v4l2_buf->flags = V4L2_BUF_FLAG_KEYFRAME;
-	v4l2_buf->vb2_buf.timestamp = pts;
+	v4l2_buf->vb2_buf.timestamp = timestamp;
 	v4l2_buf->sequence = sequence++;
 	mutex_lock(&ctx->vpu_mutex);
 	ctx->seq_cap = sequence;
@@ -312,11 +369,19 @@ static int vpu_buf_done(struct v4l2_fh *fh, struct vb2_v4l2_buffer *v4l2_buf,
 
 	spin_lock_irqsave(&ctx->vpu_spin_lock, flags);
 
-	v4l2_m2m_buf_done(v4l2_buf, VB2_BUF_STATE_DONE);
-	if (eos) {
-		vpu_info("%d.%s.ctx->last_buf_done = true\n", __LINE__,
-			 __func__);
-		ctx->last_buf_done = true;
+	if (eos && no_frame) {
+		const struct v4l2_event eos_event = { .type = V4L2_EVENT_EOS };
+
+		vb2_set_plane_payload(&v4l2_buf->vb2_buf, 0, 0);
+		v4l2_m2m_last_buffer_done(fh->m2m_ctx, v4l2_buf);
+		v4l2_event_queue_fh(fh, &eos_event);
+	} else {
+		v4l2_m2m_buf_done(v4l2_buf, VB2_BUF_STATE_DONE);
+		if (eos) {
+			vpu_info("%d.%s.ctx->last_buf_done = true\n", __LINE__,
+				 __func__);
+			ctx->last_buf_done = true;
+		}
 	}
 
 	spin_unlock_irqrestore(&ctx->vpu_spin_lock, flags);
@@ -355,7 +420,7 @@ static int threadcap(void *data)
 
 		ret = 0;
 		for (; !ret;) {
-			uint64_t pts = 0;
+			uint64_t timestamp = 0;
 			bool eos = 0;
 			bool no_frame = 0;
 
@@ -364,14 +429,14 @@ static int threadcap(void *data)
 			sequence = ctx->seq_cap;
 			mutex_unlock(&ctx->vpu_mutex);
 
-			ret = ctx->veng_ops->ve_cap_dqbuf(fh, NULL, &pts,
+			ret = ctx->veng_ops->ve_cap_dqbuf(fh, NULL, &timestamp,
 							  &disp_buf);
 			if (!ret) {
 				if (ctx->veng_ops->ve_get_info)
 					ctx->veng_ops->ve_get_info(fh, &eos,
 								   &no_frame);
 
-				if (vpu_buf_done(fh, disp_buf, pts, sizeimage,
+				if (vpu_buf_done(fh, disp_buf, timestamp, sizeimage,
 						 sequence, eos, no_frame))
 					break;
 
@@ -435,8 +500,6 @@ static int threadout(void *data)
 		if (ctx->stop_cmd &&
 		    !v4l2_m2m_num_src_bufs_ready(fh->m2m_ctx) &&
 		    !ctx->last_buf_done) {
-			//vpu_info("%d.%s.call vpu_stop_cmd()\n", __LINE__,
-			//	 __func__);
 			ret = op->vpu_stop_cmd(fh);
 			if (((ret < 0) && (!bForceEscapeDone)) || ctx->miss_last_buf_done) {
 				dst_vq = v4l2_m2m_get_vq(
@@ -461,7 +524,6 @@ static int threadout(void *data)
 		if (v4l2_m2m_num_src_bufs_ready(fh->m2m_ctx)) {
 			uint8_t *p;
 			uint32_t offset, len;
-			uint64_t pts;
 			for (;;) {
 				v4l2_buf = v4l2_m2m_next_src_buf(fh->m2m_ctx);
 				if (!v4l2_buf)
@@ -479,14 +541,12 @@ static int threadout(void *data)
 							     0)) :
 					    (vb2_plane_vaddr(&v4l2_buf->vb2_buf,
 							     0));
-				pts = div_u64(v4l2_buf->vb2_buf.timestamp,
-					      1000);
 				len = v4l2_buf->vb2_buf.planes[0].bytesused;
 				offset =
 					v4l2_buf->vb2_buf.planes[0].data_offset;
 
 				qbuf_ret = ctx->veng_ops->ve_out_qbuf(fh, p + offset,
-						len, pts,
+						len, v4l2_buf->vb2_buf.timestamp,
 						sequence);
 				if (!qbuf_ret) {
 					v4l2_buf = v4l2_m2m_src_buf_remove(
@@ -626,22 +686,23 @@ static int vpu_try_fmt(struct v4l2_fh *fh, struct v4l2_format *f)
 	height = clamp(f->fmt.pix.height, fmt->frmsize.min_height,
 		fmt->frmsize.max_height);
 
-	width = ALIGN(width, RTK_DPB_WIDTH_ALIGN);
-	height = ALIGN(height, RTK_DPB_HEIGHT_ALIGN);
-
 	if (V4L2_TYPE_IS_CAPTURE(f->type)) {
-		if (ctx->out_fmt.misc.VideoEngine == VIDEO_ENGINE_2)
-		{
-			if (ctx->bit_depth == 10)
-				f->fmt.pix.width = f->fmt.pix.width * 10 / 8;
-
-			width = ALIGN(f->fmt.pix.width, RTK_DPB_VE2_WIDTH_ALIGN);
-			height = ALIGN(f->fmt.pix.height, RTK_DPB_VE2_HEIGHT_ALIGN);
+		if (ctx->out_fmt.misc.VideoEngine == VIDEO_ENGINE_2 &&
+			ctx->ddr_width && ctx->ddr_height) {
+			width = ctx->ddr_width;
+			height = ctx->ddr_height;
+			bytesperline = width;
+		} else {
+			width = ALIGN(width, RTK_DPB_WIDTH_ALIGN);
+			height = ALIGN(height, RTK_DPB_HEIGHT_ALIGN);
 		}
 
 		bytesperline = width;
 		sizeimage = bytesperline * height * 3 / 2;
 	} else {
+		width = ALIGN(width, RTK_DPB_WIDTH_ALIGN);
+		height = ALIGN(height, RTK_DPB_HEIGHT_ALIGN);
+
 		bytesperline = 0;
 		sizeimage = fmt->spec.fmt.pix.sizeimage;
 	}
@@ -659,16 +720,22 @@ static int vpu_s_fmt_cap(struct v4l2_fh *fh, struct v4l2_format *f)
 {
 	const struct vpu_fmt *fmt;
 	struct vpu_ctx *ctx = fh_to_vpu(fh);
+	unsigned int width = 0;
+	unsigned int height = 0;
 
 	fmt = find_format(f);
 	if (!fmt)
 		memcpy(f, &cap_fmt[0], sizeof(struct v4l2_format));
 
+	width = f->fmt.pix.width;
+	height = f->fmt.pix.height;
+
 	vpu_try_fmt(fh, f);
 
 	mutex_lock(&ctx->vpu_mutex);
 	memcpy(&ctx->cap_fmt.spec, f, sizeof(struct v4l2_format));
-
+	ctx->cap_fmt.misc.ori_width = (width > 0) ? width : f->fmt.pix.width;
+	ctx->cap_fmt.misc.ori_height = (height > 0) ? height : f->fmt.pix.height;
 	ctx->out_fmt.spec.fmt.pix.colorspace = f->fmt.pix.colorspace;
 	ctx->out_fmt.spec.fmt.pix.ycbcr_enc = f->fmt.pix.ycbcr_enc;
 	ctx->out_fmt.spec.fmt.pix.quantization = f->fmt.pix.quantization;
@@ -682,12 +749,14 @@ static int vpu_s_fmt_cap(struct v4l2_fh *fh, struct v4l2_format *f)
 static int vpu_s_fmt_out(struct v4l2_fh *fh, struct v4l2_format *f)
 {
 	struct vpu_ctx *ctx = fh_to_vpu(fh);
-	const struct vpu_fmt *fmt;
+	const struct vpu_fmt *fmt = NULL;
 	int pixelformat = 0;
 
 	fmt = find_format(f);
-	if (!fmt)
-		memcpy(f, &out_fmt[0], sizeof(struct v4l2_format));
+	if (!fmt) {
+		fmt = &out_fmt[0];
+		memcpy(f, &fmt->spec, sizeof(struct v4l2_format));
+	}
 
 	mutex_lock(&ctx->vpu_mutex);
 	ctx->rect.width = f->fmt.pix.width;
@@ -703,6 +772,8 @@ static int vpu_s_fmt_out(struct v4l2_fh *fh, struct v4l2_format *f)
 	case V4L2_PIX_FMT_MPEG2:
 	case V4L2_PIX_FMT_MPEG4:
 	case V4L2_PIX_FMT_VP8:
+	case V4L2_PIX_FMT_VC1_ANNEX_G:
+	case V4L2_PIX_FMT_VC1_ANNEX_L:
 		/* Set VE1 ops */
 		if (!ctx->ve1_ops) {
 			mutex_unlock(&ctx->vpu_mutex);
@@ -728,6 +799,8 @@ static int vpu_s_fmt_out(struct v4l2_fh *fh, struct v4l2_format *f)
 	}
 
 	memcpy(&ctx->out_fmt.spec, f, sizeof(struct v4l2_format));
+	memcpy(&ctx->out_fmt.frmsize, &fmt->frmsize, sizeof(struct v4l2_frmsize_stepwise));
+	memcpy(&ctx->out_fmt.misc, &fmt->misc, sizeof(struct vpu_misc));
 	ctx->cap_fmt.spec.fmt.pix.colorspace = f->fmt.pix.colorspace;
 	ctx->cap_fmt.spec.fmt.pix.ycbcr_enc = f->fmt.pix.ycbcr_enc;
 	ctx->cap_fmt.spec.fmt.pix.quantization = f->fmt.pix.quantization;
@@ -788,11 +861,13 @@ int vpu_start_streaming(struct vb2_queue *q, uint32_t count)
 	struct videc_ctx *vid_ctx = vb2_get_drv_priv(q);
 	struct vpu_ctx *ctx = vid_ctx->vpu_ctx;
 	struct v4l2_fh *fh = &vid_ctx->fh;
-	int ret;
+	int ret,i;
 	int pixelformat = ctx->out_fmt.spec.fmt.pix.pixelformat;
 
-	if (!ctx->veng_ops)
-		return -EINVAL;
+	if (!ctx->veng_ops){
+		ret = -EINVAL;
+		goto exit;
+	}
 
 	mutex_lock(&ctx->vpu_mutex);
 	/* Allocate video engine context */
@@ -801,15 +876,20 @@ int vpu_start_streaming(struct vb2_queue *q, uint32_t count)
 			ctx->veng_ops->ve_alloc_context(vid_ctx->file);
 		if (!vid_ctx->ve_ctx) {
 			mutex_unlock(&ctx->vpu_mutex);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto exit;
 		}
 	}
 
 	ret = ctx->veng_ops->ve_start_streaming(q, count, pixelformat);
 	if (ret) {
 		vpu_err("Failed to start streaming %d\n", ret);
+		if (vid_ctx->ve_ctx) {
+			ctx->veng_ops->ve_free_context(vid_ctx->ve_ctx);
+			vid_ctx->ve_ctx = NULL;
+		}
 		mutex_unlock(&ctx->vpu_mutex);
-		return ret;
+		goto exit;
 	}
 
 	if (V4L2_TYPE_IS_OUTPUT(q->type)) {
@@ -837,6 +917,19 @@ int vpu_start_streaming(struct vb2_queue *q, uint32_t count)
 					    msecs_to_jiffies(1000));
 	}
 
+	return ret;
+
+exit:
+	for (i = 0; i < q->num_buffers; ++i) {
+		struct vb2_buffer *buf = vb2_get_buffer(q, i);
+		if (buf->state == VB2_BUF_STATE_ACTIVE) {
+			vpu_err("id=%d, type=%d, %d -> VB2_BUF_STATE_QUEUED",
+					i, q->type,(int)buf->state);
+			v4l2_m2m_buf_done(to_vb2_v4l2_buffer(buf),
+					  VB2_BUF_STATE_QUEUED);
+		}
+	}
+
 	return ret;
 }
 
@@ -871,8 +964,10 @@ int vpu_stop_streaming(struct vb2_queue *q)
 	else
 		ctx->is_cap_started = 0;
 	if (!ctx->is_cap_started && !ctx->is_out_started) {
-		ctx->veng_ops->ve_free_context(vid_ctx->ve_ctx);
-		vid_ctx->ve_ctx = NULL;
+		if(vid_ctx->ve_ctx) {
+			ctx->veng_ops->ve_free_context(vid_ctx->ve_ctx);
+			vid_ctx->ve_ctx = NULL;
+		}
 		ctx->veng_ops = NULL;
 
 		// reset other variables of struct videc_ctx
@@ -920,8 +1015,7 @@ static int vpu_qbuf(struct v4l2_fh *fh, struct vb2_buffer *vb)
 		    ctx->veng_ops->ve_out_pre_parse) {
 			ret = ctx->veng_ops->ve_out_pre_parse(
 				fh, vb, &width, &height, &min_reqbuf, &bit_depth);
-			if (ret == 0 &&
-			    (width || height || min_reqbuf || bit_depth))
+			if (ret == 0 && (width && height && min_reqbuf))
 				ctx->parse_header_done = true;
 		}
 
diff --git a/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.h b/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.h
index 091751b23b8f..d7a884794526 100644
--- a/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.h
+++ b/drivers/media/platform/rtk_vdec_rtd16xxb/vpu.h
@@ -56,6 +56,9 @@ struct vpu_ctx {
 	struct completion bs_parsing_comp; // init in vpu_alloc_context(), it should reinit_completion() when vpu_stop_streaming
 	bool parse_header_done;
 	uint32_t bit_depth;
+	unsigned int ddr_width;
+	unsigned int ddr_height;
+	bool is_error;
 };
 
 struct vpu_fmt_ops {
@@ -86,10 +89,10 @@ struct veng_ops {
 	int (*ve_start_streaming)(struct vb2_queue *q, uint32_t count,
 				  int pixelformat);
 	int (*ve_stop_streaming)(struct vb2_queue *q);
-	int (*ve_out_qbuf)(void *fh, uint8_t *buf, uint32_t len, uint64_t pts,
+	int (*ve_out_qbuf)(void *fh, uint8_t *buf, uint32_t len, uint64_t timestamp,
 			   uint32_t sequence);
 	int (*ve_cap_qbuf)(void *fh, struct vb2_buffer *vb);
-	int (*ve_cap_dqbuf)(void *fh, uint8_t *buf, uint64_t *pts,
+	int (*ve_cap_dqbuf)(void *fh, uint8_t *buf, uint64_t *timestamp,
 			    struct vb2_v4l2_buffer **disp_buf);
 	int (*ve_abort)(void *ctx, int type);
 	void *(*ve_alloc_context)(struct file *file);
@@ -100,6 +103,8 @@ struct veng_ops {
 	int (*ve_out_pre_parse)(void *fh, struct vb2_buffer *vb,
 				uint32_t *width, uint32_t *height,
 				uint32_t *minBufCnt, uint32_t *bitrate);
+	int (*ve_get_request_buf_info)(void *fh,
+				uint32_t *ddr_width, uint32_t *ddr_height);
 };
 
 /**
-- 
2.45.2

