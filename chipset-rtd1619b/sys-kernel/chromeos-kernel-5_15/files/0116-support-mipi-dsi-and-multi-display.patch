From 0b6d608d2288a59f78ac65b179ff3e6a7a297812 Mon Sep 17 00:00:00 2001
From: yaozenhu <yaozenhu@realtek.com>
Date: Mon, 7 Oct 2024 13:49:42 +0800
Subject: [PATCH] support mipi dsi and multi display

---
 .../dts/realtek/rtd1619b-backinblack.dtsi     |  56 ++
 .../dts/realtek/rtd1619b-bleedingedge.dtsi    |  50 ++
 arch/arm64/boot/dts/realtek/rtd16xxb-drm.dtsi |  58 +-
 arch/arm64/boot/dts/realtek/rtd16xxb.dtsi     |  13 +-
 drivers/gpu/drm/realtek/Kconfig               |   1 +
 drivers/gpu/drm/realtek/Makefile              |   1 +
 drivers/gpu/drm/realtek/rtk_drm_crtc.c        | 204 +++---
 drivers/gpu/drm/realtek/rtk_drm_crtc.h        |  19 +-
 drivers/gpu/drm/realtek/rtk_drm_drv.c         |   1 +
 drivers/gpu/drm/realtek/rtk_drm_drv.h         |   1 +
 drivers/gpu/drm/realtek/rtk_drm_plane.c       |   7 +-
 drivers/gpu/drm/realtek/rtk_drm_rpc.c         |  76 ++
 drivers/gpu/drm/realtek/rtk_drm_rpc.h         |  37 +-
 drivers/gpu/drm/realtek/rtk_dsi.c             | 653 ++++++++++++++++++
 drivers/gpu/drm/realtek/rtk_dsi.h             |  33 +
 drivers/gpu/drm/realtek/rtk_dsi_reg.h         |  52 ++
 16 files changed, 1152 insertions(+), 110 deletions(-)
 create mode 100644 drivers/gpu/drm/realtek/rtk_dsi.c
 create mode 100644 drivers/gpu/drm/realtek/rtk_dsi.h
 create mode 100644 drivers/gpu/drm/realtek/rtk_dsi_reg.h

Index: kernel-5_15/arch/arm64/boot/dts/realtek/rtd1619b-backinblack.dtsi
===================================================================
--- kernel-5_15.orig/arch/arm64/boot/dts/realtek/rtd1619b-backinblack.dtsi
+++ kernel-5_15/arch/arm64/boot/dts/realtek/rtd1619b-backinblack.dtsi
@@ -272,13 +272,57 @@
 };

 &display_subsystem {
+	ports = <&vo1_out>, <&vo0_out>;
 	status = "okay";
 };

+&vo0 {
+	status = "okay";
+};
+
+&vo1 {
+	status = "disabled";
+	vo1_out: port {
+		vo1_out_dsi: endpoint {
+			remote-endpoint = <&dsi_in_vo1>;
+		};
+	};
+};
+
+&vo2 {
+	status = "disabled";
+};
+
 &hdmi {
 	hdmi5v-gpios = <&gpio 5 GPIO_ACTIVE_LOW>;
 };

+&dsi {
+	status = "okay";
+
+	ports {
+		dsi_in: port@0 {
+			reg = <0>;
+			dsi_in_vo1: endpoint@0 {
+        #address-cells = <1>;
+        #size-cells = <0>;
+				reg = <0>;
+				remote-endpoint = <&vo1_out_dsi>;
+			};
+		};
+
+		dsi_out: port@1 {
+			reg = <1>;
+			dsi_out_panel: endpoint@0 {
+        #address-cells = <1>;
+        #size-cells = <0>;
+				reg = <0>;
+				remote-endpoint = <&panel_in_dsi>;
+			};
+		};
+	};
+};
+
 &hse {
 	status = "okay";
 };
@@ -301,6 +345,22 @@

 &i2c_5 {
 	status = "okay";
+
+	dfr0550_ts@38 {
+		compatible = "realtek,dfr0550_ts";
+		reg = <0x38>;
+		rotate = <0>;
+	};
+
+	dsi_panel@45 {
+		compatible = "raspberrypi,7inch-touchscreen-panel";
+		reg = <0x45>;
+		port {
+			panel_in_dsi: endpoint {
+				remote-endpoint = <&dsi_out_panel>;
+			};
+		};
+	};
 };

 &irda {
Index: kernel-5_15/arch/arm64/boot/dts/realtek/rtd1619b-bleedingedge.dtsi
===================================================================
--- kernel-5_15.orig/arch/arm64/boot/dts/realtek/rtd1619b-bleedingedge.dtsi
+++ kernel-5_15/arch/arm64/boot/dts/realtek/rtd1619b-bleedingedge.dtsi
@@ -277,13 +277,65 @@
 };

 &display_subsystem {
+	ports = <&vo1_out>, <&vo0_out>;
 	status = "okay";
 };

+&vo0 {
+	status = "okay";
+};
+
+&vo1 {
+	status = "disabled";
+	vo1_out: port {
+		vo1_out_dsi: endpoint {
+			remote-endpoint = <&dsi_in_vo1>;
+		};
+	};
+};
+
+&vo2 {
+	status = "disabled";
+};
+
 &hdmi {
 	hdmi5v-gpios = <&gpio 5 GPIO_ACTIVE_LOW>;
 };

+&dsi {
+	status = "okay";
+
+	dsi_panel: dsi-panel@0 {
+		compatible = "realtek,10inch-mipi-dsi-panel";
+		port {
+      #address-cells = <1>;
+      #size-cells = <0>;
+			panel_in_dsi: endpoint@0 {
+        reg = <0>;
+				remote-endpoint = <&dsi_out_panel>;
+			};
+		};
+	};
+};
+
+&dsi_in {
+  #address-cells = <1>;
+  #size-cells = <0>;
+  dsi_in_vo1: endpoint@0 {
+    reg = <0>;
+    remote-endpoint = <&vo1_out_dsi>;
+  };
+};
+
+&dsi_out {
+  #address-cells = <1>;
+  #size-cells = <0>;
+  dsi_out_panel: endpoint@0 {
+    reg = <0>;
+    remote-endpoint = <&panel_in_dsi>;
+  };
+};
+
 &hse {
 	status = "okay";
 };
Index: kernel-5_15/arch/arm64/boot/dts/realtek/rtd16xxb-drm.dtsi
===================================================================
--- kernel-5_15.orig/arch/arm64/boot/dts/realtek/rtd16xxb-drm.dtsi
+++ kernel-5_15/arch/arm64/boot/dts/realtek/rtd16xxb-drm.dtsi
@@ -2,32 +2,46 @@
 / {
 	display_subsystem: display-subsystem {
 		compatible = "realtek,display-subsystem";
-		ports = <&vo_out>;
+		ports = <&vo0_out>;
 		realtek,krpc-agent = <&acpu_kernel_agent>, <&hifi_kernel_agent>;
 		status = "disabled";
 		memory-region = <&cma_reserved_0>;
 	};

-	vo: vo@98080000 {
-		compatible = "realtek,crtc";
+	vo0: vo0@98080000 {
+		compatible = "realtek,rtd-crtc-main";
 		reg = <0x98080000 0x2000>;
 		interrupts = <0 33 4>;
 		hwlocks = <&sb2_lock5 1>;
 		memory-region = <&cma_reserved_0>;
-		vo_out: port {
+		vo0_out: port {
 			#address-cells = <1>;
 			#size-cells = <0>;
-			vo_hdmi: endpoint@0 {
+			vo0_out_hdmi: endpoint@0 {
 				reg = <0>;
-				remote-endpoint = <&hdmi_vo>;
+				remote-endpoint = <&hdmi_in_vo0>;
 			};
-			vo_cvbs: endpoint@1 {
+			vo0_out_cvbs: endpoint@1 {
 				reg = <1>;
-				remote-endpoint = <&cvbs_vo>;
+				remote-endpoint = <&cvbs_in_vo0>;
 			};
 		};
 	};

+	vo1: vo1 {
+		compatible = "realtek,rtd-crtc-second";
+		interrupts = <0 33 4>;
+		hwlocks = <&sb2_lock5 1>;
+		status = "disabled";
+	};
+
+	vo2: vo2 {
+		compatible = "realtek,rtd-crtc-extend";
+		interrupts = <0 33 4>;
+		hwlocks = <&sb2_lock5 1>;
+		status = "disabled";
+	};
+
 	hdmi: hdmi {
 		compatible = "realtek,rtk-hdmi";
 		syscon = <&hdmi_tx>, <&crt>, <&hdmi_top>;
@@ -42,8 +56,8 @@
 		realtek,krpc-agent = <&acpu_kernel_agent>;
 		memory-region = <&cma_reserved_0>;
 		hdmi_in: port {
-			hdmi_vo: endpoint {
-				remote-endpoint = <&vo_hdmi>;
+			hdmi_in_vo0: endpoint {
+				remote-endpoint = <&vo0_out_hdmi>;
 			};
 		};
 	};
@@ -53,8 +67,28 @@
 		status = "disabled";
 		memory-region = <&cma_reserved_0>;
 		cvbs_in: port {
-			cvbs_vo: endpoint {
-				remote-endpoint = <&vo_cvbs>;
+			cvbs_in_vo0: endpoint {
+				remote-endpoint = <&vo0_out_cvbs>;
+			};
+		};
+	};
+
+	dsi: dsi {
+		compatible = "realtek,rtk-dsi";
+		syscon = <&mipi_dsi>;
+		clocks = <&cc RTD1619B_CRT_CLK_EN_MIPI_DSI>;
+		clock-names = "clk_en_dsi";
+		resets = <&cc RTD1619B_CRT_RSTN_MIPI_DSI>;
+		reset-names = "dsi";
+		status = "disabled";
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dsi_in: port@0 {
+				reg = <0>;
+			};
+			dsi_out: port@1 {
+				reg = <1>;
 			};
 		};
 	};
Index: kernel-5_15/arch/arm64/boot/dts/realtek/rtd16xxb.dtsi
===================================================================
--- kernel-5_15.orig/arch/arm64/boot/dts/realtek/rtd16xxb.dtsi
+++ kernel-5_15/arch/arm64/boot/dts/realtek/rtd16xxb.dtsi
@@ -501,16 +501,13 @@
 				status = "disabled";
 			};

-			mipi_dsi: mipi_dsi@33000 {
-				compatible = "realtek,rtk-dsi";
+			mipi_dsi: syscon@33000 {
+				compatible = "syscon", "simple-mfd";
 				reg = <0x33000 0x1000>;
-				clocks = <&cc RTD1619B_CRT_CLK_EN_MIPI_DSI>;
-				clock-names = "clk_en_dsi";
-				resets = <&cc RTD1619B_CRT_RSTN_MIPI_DSI>;
-				reset-names = "dsi";
+				reg-io-width = <4>;
 				#address-cells = <1>;
-				#size-cells = <0>;
-				status = "disabled";
+				#size-cells = <1>;
+				ranges = <0x0 0x33000 0x1000>;
 			};

 			sata_phy: sata_phy@3ff00 {
Index: kernel-5_15/drivers/gpu/drm/realtek/Kconfig
===================================================================
--- kernel-5_15.orig/drivers/gpu/drm/realtek/Kconfig
+++ kernel-5_15/drivers/gpu/drm/realtek/Kconfig
@@ -7,6 +7,7 @@ config DRM_RTK
 	select DRM_DISPLAY_HDMI_HELPER
 	select DRM_DISPLAY_HELPER
 	select DRM_KMS_HELPER
+	select DRM_MIPI_DSI
 	help
 	  Choose this option if you have a Realtek SoCs.
 	  The module will be called realtek-drm
Index: kernel-5_15/drivers/gpu/drm/realtek/Makefile
===================================================================
--- kernel-5_15.orig/drivers/gpu/drm/realtek/Makefile
+++ kernel-5_15/drivers/gpu/drm/realtek/Makefile
@@ -15,6 +15,7 @@ rtk_drm-y := rtk_drm_rpc.o \
              rtk_cvbs.o \
 	     rtk_dptx_core.o \
 	     rtk_dptx_reg.o \
+	     rtk_dsi.o \
 	     rtk_hdcp.o

 ifdef CONFIG_REALTEK_TEE
Index: kernel-5_15/drivers/gpu/drm/realtek/rtk_drm_crtc.c
===================================================================
--- kernel-5_15.orig/drivers/gpu/drm/realtek/rtk_drm_crtc.c
+++ kernel-5_15/drivers/gpu/drm/realtek/rtk_drm_crtc.c
@@ -31,18 +31,43 @@
 #define to_rtk_crtc(s) container_of(s, struct rtk_drm_crtc, crtc)
 #define to_rtk_crtc_state(s) container_of(s, struct rtk_crtc_state, base)

-// static int rtk_crtc_get_mixer_order(struct rtk_rpc_info *rpc_info,
-// 				struct rpc_disp_mixer_order *mixer_order)
-// {
-// 	int ret = 0;
+static const struct crtc_plane_data rtd_crtc_plane_main[] = {
+	{ .layer_nr = VO_VIDEO_PLANE_OSD1,
+	  .type = DRM_PLANE_TYPE_PRIMARY },
+	{ .layer_nr = VO_VIDEO_PLANE_SUB1,
+	  .type = DRM_PLANE_TYPE_CURSOR },
+};
+
+static const struct crtc_plane_data rtd_crtc_plane_second[] = {
+	{ .layer_nr = VO_VIDEO_PLANE_SUB1,
+	  .type = DRM_PLANE_TYPE_PRIMARY },
+};

-// 	if(!rpc_info)
-// 		return -1;
+static const struct crtc_plane_data rtd_crtc_plane_extend[] = {
+	{ .layer_nr = VO_VIDEO_PLANE_OSD2,
+	  .type = DRM_PLANE_TYPE_PRIMARY },
+};
+
+static const struct crtc_data rtd_crtc_main = {
+	.version = 0,
+	.plane = rtd_crtc_plane_main,
+	.plane_size = ARRAY_SIZE(rtd_crtc_plane_main),
+	.mixer = 0,
+};

-// 	ret = rpc_get_mixer_order(rpc_info, mixer_order);
+static const struct crtc_data rtd_crtc_second = {
+	.version = 0,
+	.plane = rtd_crtc_plane_second,
+	.plane_size = ARRAY_SIZE(rtd_crtc_plane_second),
+	.mixer = 1,
+};

-// 	return ret;
-// }
+static const struct crtc_data rtd_crtc_extend = {
+	.version = 0,
+	.plane = rtd_crtc_plane_extend,
+	.plane_size = ARRAY_SIZE(rtd_crtc_plane_extend),
+	.mixer = 2,
+};

 static int rtk_crtc_set_mixer_order(struct rtk_rpc_info *rpc_info,
 				struct rpc_disp_mixer_order *mixer_order)
@@ -121,14 +146,20 @@ static int rtk_crtc_enable_vblank(struct
 	struct rtk_rpc_info *rpc_info = rtk_crtc->rpc_info;
 	unsigned long flags;
 	unsigned int val;
+	unsigned int notify;

 	DRM_DEBUG_KMS("%d\n", __LINE__);

 	if (rtk_crtc->hwlock)
 		hwspin_lock_timeout_irqsave(rtk_crtc->hwlock, UINT_MAX, &flags);
+
+	notify = DC_VO_SET_NOTIFY << (rtk_crtc->mixer * 2);
+
 	val = readl(rpc_info->vo_sync_flag);
-	val |= DC_VO_SET_NOTIFY;
+	val |= __cpu_to_be32(notify);
+
 	writel(val, rpc_info->vo_sync_flag);
+
 	if (rtk_crtc->hwlock)
 		hwspin_unlock_irqrestore(rtk_crtc->hwlock, &flags);

@@ -141,14 +172,20 @@ static void rtk_crtc_disable_vblank(stru
 	struct rtk_rpc_info *rpc_info = rtk_crtc->rpc_info;
 	unsigned long flags;
 	unsigned int val;
+	unsigned int notify;

 	DRM_DEBUG_KMS("%d\n", __LINE__);

 	if (rtk_crtc->hwlock)
 		hwspin_lock_timeout_irqsave(rtk_crtc->hwlock, UINT_MAX, &flags);
+
+	notify = DC_VO_SET_NOTIFY << (rtk_crtc->mixer * 2);
+
 	val = readl(rpc_info->vo_sync_flag);
-	val &= ~DC_VO_SET_NOTIFY;
+	val &= ~(__cpu_to_be32(notify));
+
 	writel(val, rpc_info->vo_sync_flag);
+
 	if (rtk_crtc->hwlock)
 		hwspin_unlock_irqrestore(rtk_crtc->hwlock, &flags);
 }
@@ -165,11 +202,12 @@ void rtk_crtc_finish_page_flip(struct dr
 	unsigned long flags;

 	spin_lock_irqsave(&drm->event_lock, flags);
-	if (rtk_crtc->event) {
+	if (rtk_crtc->pending_needs_vblank) {
 		drm_crtc_send_vblank_event(crtc, rtk_crtc->event);
 		drm_crtc_vblank_put(crtc);
 		rtk_crtc->event = NULL;
-		rtk_plane_clear_buflock(&rtk_crtc->planes[0], 0);
+		rtk_crtc->pending_needs_vblank = false;
+		rtk_plane_clear_buflock(&rtk_crtc->nplanes[0], 0);
 	}
 	spin_unlock_irqrestore(&drm->event_lock, flags);
 }
@@ -198,7 +236,12 @@ static bool rtk_crtc_mode_fixup(struct d
 static void rtk_crtc_atomic_flush(struct drm_crtc *crtc,
 				struct drm_atomic_state *old_crtc_state)
 {
+	struct rtk_drm_crtc *rtk_crtc = to_rtk_crtc(crtc);
+
 	DRM_DEBUG_KMS("%d\n", __LINE__);
+
+	if (rtk_crtc->event)
+		rtk_crtc->pending_needs_vblank = true;
 }

 static void rtk_crtc_atomic_begin(struct drm_crtc *crtc,
@@ -231,7 +274,6 @@ static void rtk_crtc_atomic_disable(stru
 {
 	DRM_DEBUG_KMS("%d\n", __LINE__);

-	drm_crtc_wait_one_vblank(crtc);
 	drm_crtc_vblank_off(crtc);

 	if (crtc->state->event) {
@@ -256,13 +298,18 @@ irqreturn_t rtk_crtc_isr(int irq, void *
 	struct rtk_rpc_info *rpc_info = rtk_crtc->rpc_info;
 	struct drm_crtc *crtc = &rtk_crtc->crtc;
 	unsigned long flags;
+	unsigned int feedback_notify;
+
+	feedback_notify = __cpu_to_be32(1U << (rtk_crtc->mixer * 2 + 1));

-	if (!DC_HAS_BIT(rpc_info->vo_sync_flag, DC_VO_FEEDBACK_NOTIFY))
+	if (!DC_HAS_BIT(rpc_info->vo_sync_flag, feedback_notify))
 		return IRQ_HANDLED;

 	if (rtk_crtc->hwlock)
 		hwspin_lock_timeout_irqsave(rtk_crtc->hwlock, UINT_MAX, &flags);
-	DC_RESET_BIT(rpc_info->vo_sync_flag, DC_VO_FEEDBACK_NOTIFY);
+
+	DC_RESET_BIT(rpc_info->vo_sync_flag, feedback_notify);
+
 	if (rtk_crtc->hwlock)
 		hwspin_unlock_irqrestore(rtk_crtc->hwlock, &flags);

@@ -278,57 +325,30 @@ irqreturn_t rtk_crtc_isr(int irq, void *
 	return IRQ_HANDLED;
 }

-static int rtk_crtc_get_layer_nr(struct rtk_drm_crtc *rtk_crtc, enum drm_plane_type type)
-{
-	enum VO_VIDEO_PLANE layer_nr = VO_VIDEO_PLANE_NONE;
-	int i;
-
-	if (type == DRM_PLANE_TYPE_PRIMARY) {
-		if (rtk_crtc->layer_nr[VO_VIDEO_PLANE_OSD1] != 1) {
-			rtk_crtc->layer_nr[VO_VIDEO_PLANE_OSD1] = 1;
-			layer_nr = VO_VIDEO_PLANE_OSD1;
-		} else {
-			DRM_ERROR("can't find proper layer for primary\n");
-			layer_nr = VO_VIDEO_PLANE_NONE;
-		}
-	} else if (type == DRM_PLANE_TYPE_CURSOR) {
-		if (rtk_crtc->layer_nr[VO_VIDEO_PLANE_SUB1] != 1) {
-			rtk_crtc->layer_nr[VO_VIDEO_PLANE_SUB1] = 1;
-			layer_nr = VO_VIDEO_PLANE_SUB1;
-		} else {
-			DRM_ERROR("can't find proper layer for cursor\n");
-			layer_nr = VO_VIDEO_PLANE_NONE;
-		}
-	} else {
-		for (i = 0; i < VO_VIDEO_PLANE_NONE; i++) {
-			if (i == VO_VIDEO_PLANE_SUB1 || i == VO_VIDEO_PLANE_OSD1)
-				continue;
-			if (rtk_crtc->layer_nr[i] != 1) {
-				rtk_crtc->layer_nr[i] = 1;
-				layer_nr = i;
-				break;
-			}
-		}
-		if (i == VO_VIDEO_PLANE_NONE)
-			layer_nr = VO_VIDEO_PLANE_NONE;
-	}
-	return layer_nr;
-}
-
 static int rtk_crtc_bind(struct device *dev, struct device *master, void *data)
 {
 	struct device_node *np = dev->of_node;
 	struct drm_device *drm = data;
 	struct rtk_drm_private *priv = drm->dev_private;
 	struct device_node *port;
-	enum drm_plane_type type;
-	enum VO_VIDEO_PLANE layer_nr;
 	struct rtk_drm_crtc *rtk_crtc;
+	const struct crtc_data *crtc_data;
+	struct drm_plane *primary = NULL, *cursor = NULL;
 	int lock_id;
 	int i, ret;

+	crtc_data = of_device_get_match_data(dev);
+	if (!crtc_data)
+		return -ENODEV;
+
 	rtk_crtc = devm_kzalloc(dev, sizeof(*rtk_crtc), GFP_KERNEL);

+	rtk_crtc->nplanes = devm_kcalloc(dev, crtc_data->plane_size,
+					sizeof(struct rtk_drm_plane), GFP_KERNEL);
+
+	if (!rtk_crtc->nplanes)
+		return -ENOMEM;
+
 	ret = of_reserved_mem_device_init(dev);
 	if (ret)
 		dev_warn(dev, "init reserved memory failed");
@@ -338,44 +358,51 @@ static int rtk_crtc_bind(struct device *

 	memset(&rtk_crtc->mixer_order, 0, sizeof(struct rpc_disp_mixer_order));

-	for (i = 0; i < VO_LAYER_NR; i++) {
-		type = (i == 0) ? DRM_PLANE_TYPE_PRIMARY :
-				(i == 1) ? DRM_PLANE_TYPE_CURSOR :
-						DRM_PLANE_TYPE_OVERLAY;
-		if (type != DRM_PLANE_TYPE_OVERLAY) {
-			layer_nr = rtk_crtc_get_layer_nr(rtk_crtc, type);
-			rtk_plane_init(drm, &rtk_crtc->planes[i], 0, type, layer_nr);
-
-			if (type == DRM_PLANE_TYPE_PRIMARY)
-				rtk_crtc->mixer_order.osd1 = 2;
-			else
-				rtk_crtc->mixer_order.sub1 = 3;
+	for (i = 0; i < crtc_data->plane_size; i++) {
+		const struct crtc_plane_data *plane = &crtc_data->plane[i];
+
+		if (plane->type != DRM_PLANE_TYPE_PRIMARY &&
+		    plane->type != DRM_PLANE_TYPE_CURSOR)
+			continue;
+
+		rtk_crtc->mixer = crtc_data->mixer;
+		rtk_crtc->nplanes[i].mixer = rtk_crtc->mixer;
+
+		rtk_plane_init(drm, &rtk_crtc->nplanes[i], 0, plane->type, plane->layer_nr);
+
+		if (plane->type == DRM_PLANE_TYPE_PRIMARY) {
+			rtk_crtc->mixer_order.osd1 = 2;
+			primary = &rtk_crtc->nplanes[i].plane;
+		} else {
+			rtk_crtc->mixer_order.sub1 = 3;
+			cursor = &rtk_crtc->nplanes[i].plane;
 		}
 	}

 	drm_crtc_init_with_planes(drm, &rtk_crtc->crtc,
-				  &rtk_crtc->planes[0].plane,
-				  &rtk_crtc->planes[1].plane,
+				  primary,
+				  cursor,
 				  &rtk_crtc_funcs, NULL);

 	drm_crtc_helper_add(&rtk_crtc->crtc, &rtk_crtc_helper_funcs);

-	for (i = 0; i < VO_LAYER_NR; i++) {
-		type = (i == 0) ? DRM_PLANE_TYPE_PRIMARY :
-				(i == 1) ? DRM_PLANE_TYPE_CURSOR :
-						DRM_PLANE_TYPE_OVERLAY;
-		if (type == DRM_PLANE_TYPE_OVERLAY) {
-			layer_nr = rtk_crtc_get_layer_nr(rtk_crtc, type);
-
-			rtk_plane_init(drm, &rtk_crtc->planes[i],
-					1 << drm_crtc_index(&rtk_crtc->crtc),
-					type, layer_nr);
-
-			if (i == 2)
-				rtk_crtc->mixer_order.v1 = 1;
-			else
-				rtk_crtc->mixer_order.v2 = 0;
-		}
+	for (i = 0; i < crtc_data->plane_size; i++) {
+		const struct crtc_plane_data *plane = &crtc_data->plane[i];
+
+		if (plane->type != DRM_PLANE_TYPE_OVERLAY)
+			continue;
+
+		rtk_crtc->mixer = crtc_data->mixer;
+		rtk_crtc->nplanes[i].mixer = rtk_crtc->mixer;
+
+		rtk_plane_init(drm, &rtk_crtc->nplanes[i],
+				1 << drm_crtc_index(&rtk_crtc->crtc),
+				plane->type, plane->layer_nr);
+
+		if (i == 2)
+			rtk_crtc->mixer_order.v1 = 1;
+		else
+			rtk_crtc->mixer_order.v2 = 0;
 	}

 	if (rtk_crtc_set_mixer_order(rtk_crtc->rpc_info, &rtk_crtc->mixer_order)) {
@@ -453,7 +480,12 @@ static int rtk_crtc_remove(struct platfo
 }

 static const struct of_device_id rtk_crtc_of_ids[] = {
-	{ .compatible = "realtek,crtc" },
+	{ .compatible = "realtek,rtd-crtc-main",
+	  .data = &rtd_crtc_main },
+	{ .compatible = "realtek,rtd-crtc-second",
+	  .data = &rtd_crtc_second },
+	{ .compatible = "realtek,rtd-crtc-extend",
+	  .data = &rtd_crtc_extend },
 	{},
 };

Index: kernel-5_15/drivers/gpu/drm/realtek/rtk_drm_crtc.h
===================================================================
--- kernel-5_15.orig/drivers/gpu/drm/realtek/rtk_drm_crtc.h
+++ kernel-5_15/drivers/gpu/drm/realtek/rtk_drm_crtc.h
@@ -28,6 +28,18 @@ struct plane_buf_lock {
 	struct dma_buf *dmabuf;
 };

+struct crtc_plane_data {
+	enum VO_VIDEO_PLANE layer_nr;
+	enum drm_plane_type type;
+};
+
+struct crtc_data {
+	unsigned int version;
+	const struct crtc_plane_data *plane;
+	unsigned int plane_size;
+	unsigned int mixer;
+};
+
 struct rtk_drm_plane {
 	struct drm_plane plane;

@@ -58,6 +70,7 @@ struct rtk_drm_plane {
 	struct drm_property *vo_plane_name_prop;

 	enum VO_VIDEO_PLANE layer_nr;
+	unsigned int mixer;

 	unsigned int buflock_idx;
 	struct plane_buf_lock buflock[BUFLOCK_MAX];
@@ -68,7 +81,7 @@ struct rtk_drm_crtc {
 	struct drm_crtc crtc;
 	struct drm_pending_vblank_event *event;

-	struct rtk_drm_plane planes[VO_LAYER_NR];
+	struct rtk_drm_plane *nplanes;
 	struct rtk_rpc_info *rpc_info;

 	struct rpc_disp_mixer_order mixer_order;
@@ -81,6 +94,10 @@ struct rtk_drm_crtc {
 	struct drm_property *present_time_prop;
 	int present_time_en;
 	long long present_time;
+
+	unsigned int mixer;
+
+	bool pending_needs_vblank;
 };

 struct rtk_crtc_state {
Index: kernel-5_15/drivers/gpu/drm/realtek/rtk_drm_drv.c
===================================================================
--- kernel-5_15.orig/drivers/gpu/drm/realtek/rtk_drm_drv.c
+++ kernel-5_15/drivers/gpu/drm/realtek/rtk_drm_drv.c
@@ -74,7 +74,7 @@ static int rtk_drm_bind(struct device *d
 	struct drm_device *drm;
 	struct rtk_drm_private *priv;
 	int ret;
-
+  pr_info("%s \n", __func__);
 	drm = drm_dev_alloc(&rtk_drm_driver, dev);
 	if (IS_ERR(drm))
 		return PTR_ERR(drm);
@@ -218,13 +218,17 @@ static int compare_dev(struct device *de
 {
 	struct device_node *np = data;

-	if (dev->of_node != np && dev->of_node != np->parent)
+	if (dev->of_node != np && dev->of_node != np->parent){
+    dev_info(dev, "no drv.\n");
 		return 0;
+  }
+  dev_info(dev, "find drv.\n");
 	return 1;
 }

 static int rtk_drm_probe(struct platform_device *pdev)
 {
+  pr_info("%s\n", __func__);
 	return drm_of_component_probe(&pdev->dev, compare_dev, &rtk_drm_ops);
 }

@@ -295,12 +299,15 @@ static int __init rtk_drm_init(void)
 	ADD_RTK_SUB_DRIVER(rtk_hdmi_driver, CONFIG_DRM_RTK);
 	ADD_RTK_SUB_DRIVER(rtk_dptx_driver, CONFIG_DRM_RTK);
 	ADD_RTK_SUB_DRIVER(rtk_cvbs_driver, CONFIG_DRM_RTK);
+	ADD_RTK_SUB_DRIVER(rtk_dsi_driver, CONFIG_DRM_RTK);

+  pr_info("%s, register drivers:%d\n", __func__, num_sub_drivers);
 	ret = platform_register_drivers(rtk_drm_sub_drivers, num_sub_drivers);
 	if (ret)
 		return ret;

 	ret = platform_driver_register(&rtk_drm_platform_driver);
+  pr_info("%s register drm driver ret:%d \n", __func__, ret);
 	if (ret)
 		goto err_register_drm;

Index: kernel-5_15/drivers/gpu/drm/realtek/rtk_drm_drv.h
===================================================================
--- kernel-5_15.orig/drivers/gpu/drm/realtek/rtk_drm_drv.h
+++ kernel-5_15/drivers/gpu/drm/realtek/rtk_drm_drv.h
@@ -115,5 +115,6 @@ extern struct platform_driver rtk_crtc_p
 extern struct platform_driver rtk_hdmi_driver;
 extern struct platform_driver rtk_dptx_driver;
 extern struct platform_driver rtk_cvbs_driver;
+extern struct platform_driver rtk_dsi_driver;

 #endif /* _RTK_DRM_DRV_H_ */
Index: kernel-5_15/drivers/gpu/drm/realtek/rtk_drm_plane.c
===================================================================
--- kernel-5_15.orig/drivers/gpu/drm/realtek/rtk_drm_plane.c
+++ kernel-5_15/drivers/gpu/drm/realtek/rtk_drm_plane.c
@@ -405,7 +405,10 @@ static int rtk_plane_update_scaling(stru
 		DRM_DEBUG_DRIVER("[type] : %d] [old] disp_win->width : %d, disp_win->height : %d\n",
 		    plane->type, old_disp_win->width, old_disp_win->height);

-		rtk_plane->disp_win.videoPlane       = rtk_plane->info.videoPlane;
+		DRM_DEBUG_DRIVER("[\x1b[33mvideoplane %d on mixer %d\033[0m]\n",
+			rtk_plane->info.videoPlane, rtk_plane->mixer);
+
+		rtk_plane->disp_win.videoPlane       = rtk_plane->info.videoPlane | (rtk_plane->mixer << 16);
 		rtk_plane->disp_win.videoWin.x       = plane->state->crtc_x;
 		rtk_plane->disp_win.videoWin.y       = plane->state->crtc_y;
 		rtk_plane->disp_win.videoWin.width   = plane->state->crtc_w;
@@ -643,7 +646,7 @@ static int rtk_plane_rpc_init(struct rtk
 	rect.width = 0;
 	rect.height = 0;

-	rtk_plane->disp_win.videoPlane = videoplane;
+	rtk_plane->disp_win.videoPlane = videoplane | (rtk_plane->mixer << 16);
 	rtk_plane->disp_win.videoWin = rect;
 	rtk_plane->disp_win.borderWin = rect;
 	rtk_plane->disp_win.borderColor = blueBorder;
Index: kernel-5_15/drivers/gpu/drm/realtek/rtk_drm_rpc.c
===================================================================
--- kernel-5_15.orig/drivers/gpu/drm/realtek/rtk_drm_rpc.c
+++ kernel-5_15/drivers/gpu/drm/realtek/rtk_drm_rpc.c
@@ -1538,6 +1538,82 @@ exit:
 	return ret;
 }

+int rpc_query_out_interface(struct rtk_rpc_info *rpc_info,
+			    struct rpc_set_display_out_interface *arg)
+{
+	struct rpc_set_display_out_interface *i_rpc = NULL;
+	struct rpc_set_display_out_interface *o_rpc = NULL;
+	unsigned int offset;
+	unsigned int rpc_ret;
+	int ret = -EIO;
+	int opt;
+
+	mutex_lock(&rpc_info->lock);
+
+	i_rpc = (struct rpc_set_display_out_interface *)rpc_info->vaddr;
+	offset = ALIGN(sizeof(*arg), RPC_ALIGN_SZ);
+	o_rpc = (struct rpc_set_display_out_interface *)((unsigned long)i_rpc + offset);
+
+	opt = RPC_AUDIO;
+	i_rpc->display_interface = htonl(arg->display_interface);
+
+	if (send_rpc(rpc_info, opt,
+			     ENUM_VIDEO_KERNEL_RPC_GET_DISPLAY_OUTPUT_INTERFACE,
+			     rpc_info->paddr, rpc_info->paddr + offset,
+			     &rpc_ret)) {
+		goto exit;
+	}
+
+	arg->cmd_version = htonl(o_rpc->cmd_version);
+	arg->display_interface = htonl(o_rpc->display_interface);
+	arg->width = htonl(o_rpc->width);
+	arg->height = htonl(o_rpc->height);
+	arg->frame_rate = htonl(o_rpc->frame_rate);
+	arg->hdr_mode = htonl(o_rpc->hdr_mode);
+	arg->display_interface_mixer = htonl(o_rpc->display_interface_mixer);
+
+	ret = 0;
+exit:
+	mutex_unlock(&rpc_info->lock);
+	return ret;
+}
+
+int rpc_set_out_interface(struct rtk_rpc_info *rpc_info,
+			    struct rpc_set_display_out_interface *arg)
+{
+	struct rpc_set_display_out_interface *rpc = NULL;
+	unsigned int offset;
+	unsigned int rpc_ret;
+	int ret = -EIO;
+	int opt;
+
+	mutex_lock(&rpc_info->lock);
+
+	rpc = (struct rpc_set_display_out_interface *)rpc_info->vaddr;
+	offset = ALIGN(sizeof(*arg), RPC_ALIGN_SZ);
+
+	opt = RPC_AUDIO;
+	rpc->display_interface       = htonl(arg->display_interface);
+	rpc->width                   = htonl(arg->width);
+	rpc->height                  = htonl(arg->height);
+	rpc->frame_rate              = htonl(arg->frame_rate);
+	rpc->display_interface_mixer = htonl(arg->display_interface_mixer);
+
+	if (send_rpc(rpc_info, opt,
+			     ENUM_VIDEO_KERNEL_RPC_SET_DISPLAY_OUTPUT_INTERFACE,
+			     rpc_info->paddr, rpc_info->paddr + offset,
+			     &rpc_ret)) {
+		goto exit;
+	}
+
+	ret = 0;
+exit:
+	mutex_unlock(&rpc_info->lock);
+	return ret;
+}
+
+
+
 int rpc_query_tv_system(struct rtk_rpc_info *rpc_info,
 			struct rpc_config_tv_system *arg)
 {
Index: kernel-5_15/drivers/gpu/drm/realtek/rtk_drm_rpc.h
===================================================================
--- kernel-5_15.orig/drivers/gpu/drm/realtek/rtk_drm_rpc.h
+++ kernel-5_15/drivers/gpu/drm/realtek/rtk_drm_rpc.h
@@ -14,7 +14,7 @@
 #define S_OK 0x10000000

 #define RPC_CMD_BUFFER_SIZE 4096
-#define DC_VO_SET_NOTIFY 	(__cpu_to_be32(1U << 0))
+#define DC_VO_SET_NOTIFY 	(1U << 0)
 #define DC_VO_FEEDBACK_NOTIFY	(__cpu_to_be32(1U << 1))
 #define DC_HAS_BIT(addr, bit)           (readl(addr) & bit)
 #define DC_SET_BIT(addr,bit)            (writel((readl(addr)|bit), addr))
@@ -143,6 +143,8 @@ enum {
 	ENUM_KERNEL_RPC_GET_AFW_DEBUGLEVEL,
 	ENUM_KERNEL_RPC_ConfigureDisplayWindowDispZoomWinRatio,
 	ENUM_VIDEO_KERNEL_RPC_GET_MIXER_ORDER,
+	ENUM_VIDEO_KERNEL_RPC_SET_DISPLAY_OUTPUT_INTERFACE,
+	ENUM_VIDEO_KERNEL_RPC_GET_DISPLAY_OUTPUT_INTERFACE,
 };

 enum VO_VIDEO_PLANE {
@@ -1002,6 +1004,35 @@ struct rpc_config_video_standard {
 #define HDMI2PX_FRL_6G3L      0x8
 #define HDMI2PX_FRL_6G4L      0xC

+enum rtk_display_interface {
+	DISPLAY_INTERFACE_DP,
+	DISPLAY_INTERFACE_eDP,
+	DISPLAY_INTERFACE_MIPI,
+	DISPLAY_INTERFACE_LVDS1,
+	DISPLAY_INTERFACE_LVDS2,
+	DISPLAY_INTERFACE_CVBS
+};
+
+enum rtk_display_interface_mixer {
+	DISPLAY_INTERFACE_MIXER1        = 0,
+	DISPLAY_INTERFACE_MIXER2        = 1,
+	DISPLAY_INTERFACE_MIXER3        = 2,
+	DISPLAY_INTERFACE_MIXER_NONE    = 3,
+	DISPLAY_INTERFACE_MIXER_INVALID = 4,
+};
+
+struct rpc_set_display_out_interface
+{
+	unsigned int cmd_version;
+	enum rtk_display_interface display_interface;
+	unsigned int width;
+	unsigned int height;
+	unsigned int frame_rate;
+	enum rtk_hdr_mode hdr_mode;
+	enum rtk_display_interface_mixer display_interface_mixer;
+	unsigned int reserved[20];
+};
+
 struct rpc_config_info_frame {
 	enum VO_HDMI_MODE hdmiMode;
 	enum VO_HDMI_AUDIO_SAMPLE_FREQ audioSampleFreq;
@@ -1750,5 +1781,9 @@ int rpc_video_delete_graphic_win(struct
 int rpc_video_config_osd_palette(struct rtk_rpc_info *rpc_info, struct rpc_config_osd_palette *arg);
 int rpc_video_config_plane_mixer(struct rtk_rpc_info *rpc_info, struct rpc_config_plane_mixer *arg);
 int rpc_video_set_sdrflag(struct rtk_rpc_info *rpc_info, struct rpc_set_sdrflag *arg);
+int rpc_query_out_interface(struct rtk_rpc_info *rpc_info,
+			    struct rpc_set_display_out_interface *arg);
+int rpc_set_out_interface(struct rtk_rpc_info *rpc_info,
+			    struct rpc_set_display_out_interface *arg);

 #endif
Index: kernel-5_15/drivers/gpu/drm/realtek/rtk_dsi.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/gpu/drm/realtek/rtk_dsi.c
@@ -0,0 +1,653 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2019 Realtek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <drm/drm_of.h>
+#include <drm/drm_print.h>
+
+#include <linux/component.h>
+#include <linux/platform_device.h>
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/reset.h>
+#include <linux/delay.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+
+#include <linux/module.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_modes.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_probe_helper.h>
+
+#include "rtk_drm_drv.h"
+#include "rtk_dsi_reg.h"
+#include "rtk_dsi.h"
+
+ssize_t rtk_dsi_enable_pattern_gen(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
+static DEVICE_ATTR(enable_dsi_pattern_gen, S_IWUSR, NULL, rtk_dsi_enable_pattern_gen);
+
+#define to_rtk_dsi(x) container_of(x, struct rtk_dsi, x)
+
+static const char *mixer_names[] = {
+	"MIXER1",
+	"MIXER2",
+	"MIXER3",
+	"MIXER_NONE",
+	"MIXER_INVALID",
+};
+
+static const char *interface_names[] = {
+	"DisplayPort",
+	"e DisplayPort",
+	"MIPI DSI",
+	"LVDS1",
+	"LVDS2",
+	"CVBS",
+};
+
+struct interface_info {
+	unsigned int display_interface;
+	unsigned int width;
+	unsigned int height;
+	unsigned int frame_rate;
+	unsigned int mixer;
+};
+
+struct rtk_dsi {
+	struct drm_device *drm_dev;
+	struct drm_panel *panel;
+
+	struct drm_connector connector;
+	struct drm_encoder encoder;
+	struct mipi_dsi_host host;
+	struct regmap *reg;
+	struct clk *clk;
+	struct reset_control *rstc;
+	struct rtk_rpc_info *rpc_info;
+	enum dsi_fmt fmt;
+};
+
+static void rtk_dsi_init(struct rtk_dsi *dsi)
+{
+	unsigned int reg;
+
+	regmap_write(dsi->reg, PAT_GEN, 0xf000000);
+
+	if (dsi->fmt == DSI_FMT_720P_60 ||
+		dsi->fmt == DSI_FMT_1080P_60 ||
+		dsi->fmt == DSI_FMT_600_1024P_60 ||
+		dsi->fmt == DSI_FMT_800_480P_60) {
+		regmap_write(dsi->reg, CLOCK_GEN, 0x3f4000);
+	} else
+		regmap_write(dsi->reg, CLOCK_GEN, 0x7f4000);
+
+	regmap_write(dsi->reg, WATCHDOG, 0x1632);
+	regmap_write(dsi->reg, CTRL_REG, 0x7000000);
+	regmap_write(dsi->reg, DF, 0x1927c20);
+
+	if (dsi->fmt == DSI_FMT_720P_60 ||
+		dsi->fmt == DSI_FMT_600_1024P_60) {
+		regmap_write(dsi->reg, SSC2, 0x4260426);
+		regmap_write(dsi->reg, SSC3, 0x280F0F);
+	} else if (dsi->fmt == DSI_FMT_800_480P_60) {
+		regmap_write(dsi->reg, SSC2, 0x5870587);
+		regmap_write(dsi->reg, SSC3, 0x281515);
+	} else {
+		regmap_write(dsi->reg, SSC2, 0x4c05ed);
+		regmap_write(dsi->reg, SSC3, 0x282219);
+	}
+
+	regmap_write(dsi->reg, MPLL, 0x403592b);
+
+	if (dsi->fmt == DSI_FMT_600_1024P_60) {
+		regmap_write(dsi->reg, TX_DATA1, 0x20d0100);
+		regmap_write(dsi->reg, TX_DATA2, 0x81d020f);
+		regmap_write(dsi->reg, TX_DATA3, 0x5091402);
+	} else {
+		regmap_write(dsi->reg, TX_DATA1, 0x70d0100);
+		regmap_write(dsi->reg, TX_DATA2, 0x81d090f);
+		regmap_write(dsi->reg, TX_DATA3, 0x5091408);
+	}
+
+	regmap_read(dsi->reg, CLOCK_GEN, &reg);
+
+	if (dsi->fmt == DSI_FMT_800_480P_60)
+		reg |= 0x710;
+	else
+		reg |= 0x7f0;
+	regmap_write(dsi->reg, CLOCK_GEN, reg);
+
+	regmap_write(dsi->reg, DF, 0x1927c3c);
+	regmap_write(dsi->reg, WATCHDOG, 0x161a);
+
+	regmap_write(dsi->reg, CLK_CONTINUE, 0x80);
+
+	if (dsi->fmt == DSI_FMT_720P_60) {
+		regmap_write(dsi->reg, TC0, 0x280f00);
+		regmap_write(dsi->reg, TC2, 0x502d0);
+		regmap_write(dsi->reg, TC5, 0x500056d);
+		regmap_write(dsi->reg, TC1, 0x294014a);
+		regmap_write(dsi->reg, TC3, 0x140005);
+		regmap_write(dsi->reg, TC4, 0x241032b);
+	} else if (dsi->fmt == DSI_FMT_600_1024P_60) {
+		regmap_write(dsi->reg, TC0, 0x3c0708);
+		regmap_write(dsi->reg, TC2, 0x40400);
+		regmap_write(dsi->reg, TC5, 0x258037f);
+		regmap_write(dsi->reg, TC1, 0x8c008c);
+		regmap_write(dsi->reg, TC3, 0xe0010);
+		regmap_write(dsi->reg, TC4, 0x24101bf);
+
+		regmap_write(dsi->reg, TO1, 0xffff);
+		regmap_write(dsi->reg, TO2, 0xffff);
+	} else if (dsi->fmt == DSI_FMT_800_480P_60) {
+		regmap_write(dsi->reg, TC0, 0x2e0960);
+		regmap_write(dsi->reg, TC2, 0x1501e0);
+		regmap_write(dsi->reg, TC5, 0x3200a90);
+		regmap_write(dsi->reg, TC1, 0x20001);
+		regmap_write(dsi->reg, TC3, 0x20007);
+		regmap_write(dsi->reg, TC4, 0x2410552);
+
+		regmap_write(dsi->reg, TO1, 0xffff);
+		regmap_write(dsi->reg, TO2, 0xffff);
+
+		regmap_write(dsi->reg, CTRL_REG, 0x7010000);
+	} else if (dsi->fmt == DSI_FMT_1080P_60) {
+		regmap_write(dsi->reg, TC0, 0x2c1680);
+		regmap_write(dsi->reg, TC2, 0x50438);
+		regmap_write(dsi->reg, TC5, 0x780073c);
+		regmap_write(dsi->reg, TC1, 0x940058);
+		regmap_write(dsi->reg, TC3, 0x240004);
+		regmap_write(dsi->reg, TC4, 0x241032b);
+	} else {
+		regmap_write(dsi->reg, TC0, 0x40e10);
+		regmap_write(dsi->reg, TC2, 0x10780);
+		regmap_write(dsi->reg, TC5, 0x4b0041b);
+		regmap_write(dsi->reg, TC1, 0x7a00a2);
+		regmap_write(dsi->reg, TC3, 0x190023);
+		regmap_write(dsi->reg, TC4, 0x241032b);
+	}
+}
+
+static void rtk_dsi_enc_mode_set(struct drm_encoder *encoder,
+				 struct drm_display_mode *mode,
+				 struct drm_display_mode *adj_mode)
+{
+	struct rtk_dsi *dsi = to_rtk_dsi(encoder);
+
+	if (adj_mode->hdisplay == 1280 &&
+		adj_mode->vdisplay == 720 &&
+		drm_mode_vrefresh(adj_mode) == 60) {
+		dsi->fmt = DSI_FMT_720P_60;
+	} else if (adj_mode->hdisplay == 1920 &&
+		adj_mode->vdisplay == 1080 &&
+		drm_mode_vrefresh(adj_mode) == 60) {
+		dsi->fmt = DSI_FMT_1080P_60;
+	} else if (adj_mode->hdisplay == 1200 &&
+		adj_mode->vdisplay == 1920 &&
+		drm_mode_vrefresh(adj_mode) == 60) {
+		dsi->fmt = DSI_FMT_1200_1920P_60;
+	} else if (adj_mode->hdisplay == 800 &&
+		adj_mode->vdisplay == 1280 &&
+		drm_mode_vrefresh(adj_mode) == 60) {
+		dsi->fmt = DSI_FMT_800_1280P_60;
+	} else if (adj_mode->hdisplay == 600 &&
+		adj_mode->vdisplay == 1024 &&
+		drm_mode_vrefresh(adj_mode) == 60) {
+		dsi->fmt = DSI_FMT_600_1024P_60;
+	} else if (adj_mode->hdisplay == 1920 &&
+		adj_mode->vdisplay == 720 &&
+		drm_mode_vrefresh(adj_mode) == 60) {
+		dsi->fmt = DSI_FMT_1920_720P_60;
+	} else if (adj_mode->hdisplay == 1920 &&
+		adj_mode->vdisplay == 720 &&
+		drm_mode_vrefresh(adj_mode) == 30) {
+		dsi->fmt = DSI_FMT_1920_720P_30;
+	} else if (adj_mode->hdisplay == 600 &&
+		adj_mode->vdisplay == 1024 &&
+		drm_mode_vrefresh(adj_mode) == 30) {
+		dsi->fmt = DSI_FMT_600_1024P_30;
+	} else if (adj_mode->hdisplay == 800 &&
+		adj_mode->vdisplay == 480 &&
+		drm_mode_vrefresh(adj_mode) == 60) {
+		dsi->fmt = DSI_FMT_800_480P_60;
+	}
+
+	return;
+}
+
+static void rtk_dsi_enc_enable(struct drm_encoder *encoder)
+{
+	struct drm_display_mode *mode = &encoder->crtc->state->adjusted_mode;
+	struct rtk_dsi *dsi = to_rtk_dsi(encoder);
+	struct rtk_rpc_info *rpc_info = dsi->rpc_info;
+	struct rpc_set_display_out_interface interface;
+	int ret;
+
+	ret = clk_prepare_enable(dsi->clk);
+	if (ret) {
+		DRM_ERROR("Failed to enable clk: %d\n", ret);
+	}
+
+	reset_control_deassert(dsi->rstc);
+
+	rtk_dsi_init(dsi);
+
+	if (dsi->panel)
+		drm_panel_prepare(dsi->panel);
+
+	if (dsi->fmt == DSI_FMT_800_480P_60)
+		regmap_write(dsi->reg, CTRL_REG, 0x7610001);
+	else
+		regmap_write(dsi->reg, CTRL_REG, 0x7610031);
+
+	regmap_write(dsi->reg, PAT_GEN, 0x9000000);
+
+	interface.display_interface       = DISPLAY_INTERFACE_MIPI;
+	interface.width                   = mode->hdisplay;
+	interface.height                  = mode->vdisplay;
+	interface.frame_rate              = drm_mode_vrefresh(mode);
+	interface.display_interface_mixer = DISPLAY_INTERFACE_MIXER2;
+
+	printk(KERN_ALERT"mode->hdisplay : %d, mode->vdisplay : %d, frame_rate : %d\n",
+		mode->hdisplay, mode->vdisplay, drm_mode_vrefresh(mode));
+
+	printk(KERN_ALERT"enable %s on %s\n",
+		interface_names[interface.display_interface], mixer_names[interface.display_interface_mixer]);
+
+	ret = rpc_set_out_interface(rpc_info, &interface);
+	if (ret) {
+		DRM_ERROR("rpc_set_out_interface rpc fail\n");
+	}
+
+	if (dsi->panel)
+		drm_panel_enable(dsi->panel);
+}
+
+static void rtk_dsi_enc_disable(struct drm_encoder *encoder)
+{
+	struct drm_display_mode *mode = &encoder->crtc->state->adjusted_mode;
+	struct rtk_dsi *dsi = to_rtk_dsi(encoder);
+	struct rtk_rpc_info *rpc_info = dsi->rpc_info;
+	struct rpc_set_display_out_interface interface;
+	int ret;
+
+	interface.display_interface       = DISPLAY_INTERFACE_MIPI;
+	interface.width                   = mode->hdisplay;
+	interface.height                  = mode->vdisplay;
+	interface.frame_rate              = drm_mode_vrefresh(mode);
+	interface.display_interface_mixer = DISPLAY_INTERFACE_MIXER_NONE;
+
+	regmap_write(dsi->reg, PAT_GEN, 0x9000000);
+
+	printk(KERN_ALERT"disable %s\n",
+		interface_names[interface.display_interface]);
+
+	ret = rpc_set_out_interface(rpc_info, &interface);
+	if (ret) {
+		DRM_ERROR("rpc_set_out_interface rpc fail\n");
+	}
+
+	clk_disable_unprepare(dsi->clk);
+	reset_control_assert(dsi->rstc);
+}
+
+static int rtk_dsi_enc_atomic_check(struct drm_encoder *encoder,
+				struct drm_crtc_state *crtc_state,
+				struct drm_connector_state *conn_state)
+{
+	return 0;
+}
+
+struct regmap *dsi_reg = NULL;
+
+ssize_t rtk_dsi_enable_pattern_gen(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long state;
+	int ret, enable, pat_gen;
+
+	ret = kstrtol(buf, 0, &state);
+	/* valid input value: 0x8-0xf */
+	enable = state & (DSI_PAT_GEN_MAX);
+
+	if (!enable) {
+		regmap_write(dsi_reg, PAT_GEN, 0x0);
+		return count;
+	}
+
+	pat_gen = state & (0x7);
+
+	switch (pat_gen) {
+	case DSI_PAT_GEN_COLORBAR:
+		regmap_write(dsi_reg, PAT_GEN, 0x8000000);
+		break;
+	case DSI_PAT_GEN_BLACK:
+		regmap_write(dsi_reg, PAT_GEN, 0x9000000);
+		break;
+	case DSI_PAT_GEN_WHITE:
+		regmap_write(dsi_reg, PAT_GEN, 0xa000000);
+		break;
+	case DSI_PAT_GEN_RED:
+		regmap_write(dsi_reg, PAT_GEN, 0xb000000);
+		break;
+	case DSI_PAT_GEN_BLUE:
+		regmap_write(dsi_reg, PAT_GEN, 0xc000000);
+		break;
+	case DSI_PAT_GEN_YELLOW:
+		regmap_write(dsi_reg, PAT_GEN, 0xd000000);
+		break;
+	case DSI_PAT_GEN_MAGENTA:
+		regmap_write(dsi_reg, PAT_GEN, 0xe000000);
+		break;
+	case DSI_PAT_GEN_USER_DEFINE:
+		regmap_write(dsi_reg, PAT_GEN, 0xf000000);
+		break;
+	default:
+		DRM_ERROR("Invalid argument\n");
+		break;
+	}
+
+	return count;
+}
+
+static const struct drm_encoder_funcs rtk_dsi_encoder_funcs = {
+	.destroy = drm_encoder_cleanup,
+};
+
+static const struct drm_encoder_helper_funcs rtk_dsi_encoder_helper_funcs = {
+	.mode_set   = rtk_dsi_enc_mode_set,
+	.enable     = rtk_dsi_enc_enable,
+	.disable    = rtk_dsi_enc_disable,
+	.atomic_check = rtk_dsi_enc_atomic_check,
+};
+
+static enum drm_connector_status rtk_dsi_conn_detect(
+	struct drm_connector *connector, bool force)
+{
+	DRM_DEBUG_KMS("%s\n", __func__);
+
+	return connector_status_connected;
+}
+
+static void rtk_dsi_conn_destroy(struct drm_connector *connector)
+{
+	DRM_DEBUG_KMS("%s\n", __func__);
+
+	drm_connector_cleanup(connector);
+}
+
+static int rtk_dsi_conn_get_modes(struct drm_connector *connector)
+{
+	struct rtk_dsi *dsi = to_rtk_dsi(connector);
+
+	return drm_panel_get_modes(dsi->panel, connector);
+}
+
+static enum drm_mode_status rtk_dsi_conn_mode_valid(
+	struct drm_connector *connector, struct drm_display_mode *mode)
+{
+	DRM_DEBUG_KMS("%s\n", __func__);
+
+	return MODE_OK;
+}
+
+static const struct drm_connector_funcs rtk_dsi_connector_funcs = {
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.detect = rtk_dsi_conn_detect,
+	.destroy = rtk_dsi_conn_destroy,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static struct drm_connector_helper_funcs rtk_dsi_connector_helper_funcs = {
+	.get_modes = rtk_dsi_conn_get_modes,
+	.mode_valid = rtk_dsi_conn_mode_valid,
+};
+
+static int rtk_dsi_bind(struct device *dev, struct device *master,
+				 void *data)
+{
+	struct drm_device *drm = data;
+	struct drm_encoder *encoder;
+	struct drm_connector *connector;
+	struct rtk_drm_private *priv = drm->dev_private;
+	struct rtk_dsi *dsi = dev_get_drvdata(dev);
+	int ret;
+	int err = 0;
+
+	dsi->clk = devm_clk_get(dev, "clk_en_dsi");
+
+	if (IS_ERR(dsi->clk)) {
+		dev_err(dev, "failed to get clock\n");
+		return PTR_ERR(dsi->clk);
+	}
+
+	ret = clk_prepare_enable(dsi->clk);
+	if (ret) {
+		DRM_ERROR("Failed to enable clk: %d\n", ret);
+		return ret;
+	}
+
+	dsi->rstc = devm_reset_control_get(dev, "dsi");
+	if (IS_ERR(dsi->rstc)) {
+		dev_err(dev, "failed to get reset controller\n");
+		return PTR_ERR(dsi->rstc);
+	}
+	reset_control_deassert(dsi->rstc);
+
+	dsi->reg = syscon_regmap_lookup_by_phandle(dev->of_node, "syscon");
+
+	if (IS_ERR(dsi->reg)) {
+		return PTR_ERR(dsi->reg);
+	}
+
+	dsi_reg = dsi->reg;
+	encoder = &dsi->encoder;
+	encoder->possible_crtcs = drm_of_find_possible_crtcs(drm, dev->of_node);
+	if (encoder->possible_crtcs == 0)
+		return -EPROBE_DEFER;
+
+	drm_encoder_init(drm, encoder, &rtk_dsi_encoder_funcs,
+			 DRM_MODE_ENCODER_DSI, "rtk_dsi0");
+
+	drm_encoder_helper_add(encoder, &rtk_dsi_encoder_helper_funcs);
+
+	connector = &dsi->connector;
+	drm_connector_init(drm, connector, &rtk_dsi_connector_funcs,
+			   DRM_MODE_CONNECTOR_DSI);
+	drm_connector_helper_add(connector, &rtk_dsi_connector_helper_funcs);
+
+	drm_connector_attach_encoder(connector, encoder);
+
+	dsi->rpc_info = &priv->rpc_info;
+
+	err = device_create_file(drm->dev, &dev_attr_enable_dsi_pattern_gen);
+	if (err < 0)
+		DRM_ERROR("failed to create dsi pattern gen\n");
+
+	return 0;
+}
+
+static void rtk_dsi_unbind(struct device *dev, struct device *master,
+			     void *data)
+{
+	struct drm_device *drm = data;
+
+	dsi_reg = NULL;
+
+	device_remove_file(drm->dev, &dev_attr_enable_dsi_pattern_gen);
+}
+
+static const struct component_ops rtk_dsi_ops = {
+	.bind	= rtk_dsi_bind,
+	.unbind	= rtk_dsi_unbind,
+};
+
+static int rtk_dsi_host_attach(struct mipi_dsi_host *host,
+			       struct mipi_dsi_device *device)
+{
+	struct rtk_dsi *dsi = to_rtk_dsi(host);
+	struct drm_panel *panel;
+	struct device *dev = host->dev;
+	int ret;
+
+	ret = drm_of_find_panel_or_bridge(dev->of_node, 1, 0, &panel, NULL);
+	if (ret) {
+		DRM_ERROR("Failed to find panel\n");
+		return ret;
+	}
+
+	dsi->panel = panel;
+
+	return ret;
+}
+
+static int rtk_dsi_host_detach(struct mipi_dsi_host *host,
+			       struct mipi_dsi_device *device)
+{
+	struct rtk_dsi *dsi = to_rtk_dsi(host);
+
+	dsi->panel = NULL;
+
+	return 0;
+}
+
+static ssize_t rtk_dsi_host_transfer(struct mipi_dsi_host *host,
+				     const struct mipi_dsi_msg *msg)
+{
+	struct rtk_dsi *dsi = to_rtk_dsi(host);
+	unsigned char *buf;
+	unsigned int len;
+	unsigned int cnt, data[2], lastbyte;
+	int i, j, tmp, ret = -1;
+	unsigned int cmd;
+
+	buf = (unsigned char *)msg->tx_buf;
+	len = msg->tx_len;
+
+	regmap_write(dsi->reg, CTRL_REG, 0x7010000);
+
+	cmd = msg->type;
+	switch (msg->type) {
+	case MIPI_DSI_DCS_SHORT_WRITE:
+	case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
+	case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
+		tmp = (*(unsigned int *)buf << 8) | cmd;
+		regmap_write(dsi->reg, CMD0, tmp);
+		break;
+	case MIPI_DSI_GENERIC_LONG_WRITE:
+	case MIPI_DSI_DCS_LONG_WRITE:
+		DRM_DEBUG_DRIVER("cmd : %d, len : %d\n", cmd, len);
+
+		cnt = (len>>3) + ((len%8)?1:0);
+		for (i = 0; i < cnt; i++) {
+			data[0] = data[1] = 0;
+			if (i == cnt-1)
+				lastbyte = len % 8;
+			else
+				lastbyte = 8;
+
+			for (j = 0; j < lastbyte; j++)
+				*((unsigned char *)(data) + j) = buf[i*8+j];
+
+			DRM_DEBUG_DRIVER("write IDMA1 0x%x\n", data[0]);
+			DRM_DEBUG_DRIVER("write IDMA2 0x%x\n", data[1]);
+			DRM_DEBUG_DRIVER("write IDMA0 0x%x\n", 0x10000 | i);
+
+			regmap_write(dsi->reg, IDMA1, data[0]);
+			regmap_write(dsi->reg, IDMA2, data[1]);
+			regmap_write(dsi->reg, IDMA0, (0x10000 | i));
+		}
+
+		DRM_DEBUG_DRIVER("write CMD0 0x%x\n", (cmd | len << 8));
+		regmap_write(dsi->reg, CMD0, (cmd | len << 8));
+
+		break;
+	default:
+		pr_err("not support yet\n");
+		break;
+	}
+
+	cnt = 0;
+	regmap_write(dsi->reg, CMD_GO, 0x1);
+	while(1) {
+		regmap_read(dsi->reg, INTS, &tmp);
+		tmp = tmp & 0x4;
+		if (tmp || cnt >= 10)
+			break;
+		msleep(10);
+		cnt++;
+	}
+	if (cnt >= 10)
+		dev_err(dsi->host.dev, "command fail\n");
+	else
+		ret = 0;
+
+	regmap_write(dsi->reg, INTS, 0x4);
+
+	return ret;
+}
+
+static const struct mipi_dsi_host_ops rtk_dsi_host_ops = {
+	.attach = rtk_dsi_host_attach,
+	.detach = rtk_dsi_host_detach,
+	.transfer = rtk_dsi_host_transfer,
+};
+
+static int rtk_dsi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rtk_dsi *dsi;
+
+	dsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);
+	if (!dsi)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, dsi);
+
+	dsi->host.ops = &rtk_dsi_host_ops;
+	dsi->host.dev = dev;
+	mipi_dsi_host_register(&dsi->host);
+
+	return component_add(&pdev->dev, &rtk_dsi_ops);
+}
+
+static int rtk_dsi_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &rtk_dsi_ops);
+	return 0;
+}
+
+static const struct of_device_id rtk_dsi_dt_ids[] = {
+	{ .compatible = "realtek,rtk-dsi",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, rtk_dsi_dt_ids);
+
+struct platform_driver rtk_dsi_driver = {
+	.probe  = rtk_dsi_probe,
+	.remove = rtk_dsi_remove,
+	.driver = {
+		.name = "rtk-dsi",
+		.of_match_table = rtk_dsi_dt_ids,
+	},
+};
Index: kernel-5_15/drivers/gpu/drm/realtek/rtk_dsi.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/gpu/drm/realtek/rtk_dsi.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2019 RealTek Inc.
+ */
+
+#ifndef _RTK_DSI_H
+#define _RTK_DSI_H
+
+enum dsi_fmt {
+	DSI_FMT_720P_60 = 0,
+	DSI_FMT_1080P_60,
+	DSI_FMT_1200_1920P_60,
+	DSI_FMT_800_1280P_60,
+	DSI_FMT_600_1024P_60,
+	DSI_FMT_1920_720P_60,
+	DSI_FMT_1920_720P_30,
+	DSI_FMT_600_1024P_30,
+	DSI_FMT_800_480P_60,
+};
+
+enum dsi_pat_gen {
+	DSI_PAT_GEN_COLORBAR = 0,
+	DSI_PAT_GEN_BLACK = 1,
+	DSI_PAT_GEN_WHITE = 2,
+	DSI_PAT_GEN_RED = 3,
+	DSI_PAT_GEN_BLUE = 4,
+	DSI_PAT_GEN_YELLOW = 5,
+	DSI_PAT_GEN_MAGENTA = 6,
+	DSI_PAT_GEN_USER_DEFINE = 7,
+	DSI_PAT_GEN_MAX,
+};
+
+#endif /* _RTK_DSI_H */
Index: kernel-5_15/drivers/gpu/drm/realtek/rtk_dsi_reg.h
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/gpu/drm/realtek/rtk_dsi_reg.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2019 RealTek Inc.
+ */
+
+#ifndef _RTK_DSI_REG_H
+#define _RTK_DSI_REG_H
+
+//-------------------------------------
+//	DSI Control Register
+//-------------------------------------
+#define CTRL_REG	0x000
+#define INTE		0x010
+#define INTS		0x014
+#define TC0		0x100
+#define TC1		0x104
+#define	TC2		0x108
+#define	TC3		0x10C
+#define	TC4		0x110
+#define	TC5		0x114
+#define IDMA0		0x200
+#define IDMA1		0x204
+#define IDMA2		0x208
+#define IDMA3		0x20C
+#define TO0		0x300
+#define TO1		0x304
+#define TO2		0x308
+#define TO3		0x30C
+#define CMD_GO		0x400
+#define CMD0		0x404
+#define PAT_GEN		0x610
+#define CLK_CONTINUE	0x708
+
+//-------------------------------------
+//	MIPI_DPHY_REG
+//-------------------------------------
+#define CLOCK_GEN	0x800
+#define TX_DATA0	0x808
+#define TX_DATA1	0x80C
+#define TX_DATA2	0x810
+#define TX_DATA3	0x814
+#define SSC0		0x840
+#define SSC1		0x844
+#define SSC2		0x848
+#define SSC3		0x84C
+#define WATCHDOG	0x850
+#define TX_SWAP		0x868
+#define RX_SWAP		0x86C
+#define MPLL		0xC00
+#define DF		0xC0C
+
+#endif /* _RTK_DSI_REG_H */
