From 86908deac65ed3d47f2a8648de0e40ac8d996dce Mon Sep 17 00:00:00 2001
From: yaozenhu <yaozenhu@realtek.com>
Date: Wed, 5 Jun 2024 18:36:09 +0800
Subject: [PATCH] update mixer order from driver

---
 drivers/gpu/drm/realtek/rtk_drm_crtc.c | 44 +++++++++++++
 drivers/gpu/drm/realtek/rtk_drm_crtc.h |  2 +
 drivers/gpu/drm/realtek/rtk_drm_rpc.c  | 86 +++++++++++++++++++++++++-
 drivers/gpu/drm/realtek/rtk_drm_rpc.h  | 32 +++++++++-
 4 files changed, 162 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/realtek/rtk_drm_crtc.c b/drivers/gpu/drm/realtek/rtk_drm_crtc.c
index 18b73da8b..b15ede162 100644
--- a/drivers/gpu/drm/realtek/rtk_drm_crtc.c
+++ b/drivers/gpu/drm/realtek/rtk_drm_crtc.c
@@ -30,6 +30,32 @@
 #define to_rtk_crtc(s) container_of(s, struct rtk_drm_crtc, crtc)
 #define to_rtk_crtc_state(s) container_of(s, struct rtk_crtc_state, base)
 
+// static int rtk_crtc_get_mixer_order(struct rtk_rpc_info *rpc_info,
+// 				struct rpc_disp_mixer_order *mixer_order)
+// {
+// 	int ret = 0;
+
+// 	if(!rpc_info)
+// 		return -1;
+
+// 	ret = rpc_get_mixer_order(rpc_info, mixer_order);
+
+// 	return ret;
+// }
+
+static int rtk_crtc_set_mixer_order(struct rtk_rpc_info *rpc_info,
+				struct rpc_disp_mixer_order *mixer_order)
+{
+	int ret = 0;
+
+	if(!rpc_info)
+		return -1;
+
+	ret = rpc_set_mixer_order(rpc_info, mixer_order);
+
+	return ret;
+}
+
 static struct drm_crtc_state *rtk_crtc_duplicate_state(struct drm_crtc *crtc)
 {
 	struct rtk_crtc_state *state;
@@ -305,6 +331,8 @@ static int rtk_crtc_bind(struct device *dev, struct device *master, void *data)
 	rtk_crtc->rpc_info = &priv->rpc_info;
 	dev_set_drvdata(dev, rtk_crtc);
 
+	memset(&rtk_crtc->mixer_order, 0, sizeof(struct rpc_disp_mixer_order));
+
 	for (i = 0; i < VO_LAYER_NR; i++) {
 		type = (i == 0) ? DRM_PLANE_TYPE_PRIMARY :
 				(i == 1) ? DRM_PLANE_TYPE_CURSOR :
@@ -312,6 +340,11 @@ static int rtk_crtc_bind(struct device *dev, struct device *master, void *data)
 		if (type != DRM_PLANE_TYPE_OVERLAY) {
 			layer_nr = rtk_crtc_get_layer_nr(rtk_crtc, type);
 			rtk_plane_init(drm, &rtk_crtc->planes[i], 0, type, layer_nr);
+
+			if (type == DRM_PLANE_TYPE_PRIMARY)
+				rtk_crtc->mixer_order.osd1 = 2;
+			else
+				rtk_crtc->mixer_order.sub1 = 3;
 		}
 	}
 
@@ -328,12 +361,23 @@ static int rtk_crtc_bind(struct device *dev, struct device *master, void *data)
 						DRM_PLANE_TYPE_OVERLAY;
 		if (type == DRM_PLANE_TYPE_OVERLAY) {
 			layer_nr = rtk_crtc_get_layer_nr(rtk_crtc, type);
+
 			rtk_plane_init(drm, &rtk_crtc->planes[i],
 					1 << drm_crtc_index(&rtk_crtc->crtc),
 					type, layer_nr);
+
+			if (i == 2)
+				rtk_crtc->mixer_order.v1 = 1;
+			else
+				rtk_crtc->mixer_order.v2 = 0;
 		}
 	}
 
+	if (rtk_crtc_set_mixer_order(rtk_crtc->rpc_info, &rtk_crtc->mixer_order)) {
+		DRM_ERROR("rtk crtc set mixer order fail\n");
+		return -1;
+	}
+
 	port = of_get_child_by_name(dev->of_node, "port");
 	if (!port)
 		DRM_ERROR("no connect port node found\n");
diff --git a/drivers/gpu/drm/realtek/rtk_drm_crtc.h b/drivers/gpu/drm/realtek/rtk_drm_crtc.h
index 8fbc71b5f..5f953044b 100644
--- a/drivers/gpu/drm/realtek/rtk_drm_crtc.h
+++ b/drivers/gpu/drm/realtek/rtk_drm_crtc.h
@@ -70,6 +70,8 @@ struct rtk_drm_crtc {
 	struct rtk_drm_plane planes[VO_LAYER_NR];
 	struct rtk_rpc_info *rpc_info;
 
+	struct rpc_disp_mixer_order mixer_order;
+
 	void *vo_vsync_flag; /* VSync enable and notify. */
 	unsigned int irq;
 	struct hwspinlock *hwlock;
diff --git a/drivers/gpu/drm/realtek/rtk_drm_rpc.c b/drivers/gpu/drm/realtek/rtk_drm_rpc.c
index 8c68e4d24..fcc498570 100644
--- a/drivers/gpu/drm/realtek/rtk_drm_rpc.c
+++ b/drivers/gpu/drm/realtek/rtk_drm_rpc.c
@@ -1463,7 +1463,7 @@ int rpc_set_hdmi_audio_onoff(struct rtk_rpc_info *rpc_info,
 		rpc->hdmi_en_state = htonl(arg->hdmi_en_state);
 	}
 
-	ret = send_rpc(rpc_info, opt, ENUM_KERNEL_RPC_HDMI_AO_ONOFF,
+	ret = send_rpc(rpc_info, opt, ENUM_KERNEL_RPC_HDMI_OUT_EDID2,
 			rpc_info->paddr, rpc_info->paddr + offset,
 			&rpc_ret);
 	if (ret)
@@ -1878,6 +1878,90 @@ int rpc_set_cvbs_format(struct rtk_rpc_info *rpc_info,
 	return ret;
 }
 
+int rpc_set_mixer_order(struct rtk_rpc_info *rpc_info,
+			struct rpc_disp_mixer_order *arg)
+{
+	struct rpc_disp_mixer_order *rpc;
+	unsigned int offset;
+	unsigned int rpc_ret;
+	int ret = 0;
+
+	mutex_lock(&rpc_info->lock);
+
+	rpc = (struct rpc_disp_mixer_order *)rpc_info->vaddr;
+	offset = get_rpc_alignment_offset(sizeof(struct rpc_disp_mixer_order));
+
+	memset_io(rpc, 0, RPC_CMD_BUFFER_SIZE);
+
+	memcpy((unsigned char *)rpc, (unsigned char *)arg,
+			sizeof(struct rpc_disp_mixer_order));
+
+	if (send_rpc(rpc_info, RPC_AUDIO,
+			ENUM_VIDEO_KERNEL_RPC_SET_MIXER_ORDER,
+			rpc_info->paddr, rpc_info->paddr + offset,
+			&rpc_ret)) {
+		ret = -EIO;
+		goto exit;
+	}
+
+	if (rpc_ret != FW_RETURN_SUCCESS) {
+		ret = -ENOEXEC;
+		goto exit;
+	}
+
+exit:
+	mutex_unlock(&rpc_info->lock);
+	return ret;
+}
+
+
+int rpc_get_mixer_order(struct rtk_rpc_info *rpc_info,
+			struct rpc_disp_mixer_order *mixer_order)
+{
+	struct rpc_disp_mixer_order *i_rpc;
+	struct rpc_disp_mixer_order *o_rpc;
+	unsigned int offset;
+	unsigned int rpc_ret;
+	int ret = 0;
+
+	mutex_lock(&rpc_info->lock);
+
+	i_rpc = (struct rpc_disp_mixer_order *)rpc_info->vaddr;
+	offset = get_rpc_alignment_offset(sizeof(struct rpc_disp_mixer_order));
+	o_rpc = (struct rpc_disp_mixer_order *)((unsigned long)i_rpc + offset);
+
+	if (send_rpc(rpc_info, RPC_AUDIO,
+			ENUM_VIDEO_KERNEL_RPC_GET_MIXER_ORDER,
+			rpc_info->paddr, rpc_info->paddr + offset,
+			&rpc_ret)) {
+		ret = -EIO;
+		goto exit;
+	}
+
+	if (rpc_ret != FW_RETURN_SUCCESS) {
+		ret = -ENOEXEC;
+		goto exit;
+	}
+
+	mixer_order->pic  = o_rpc->pic;
+	mixer_order->dd   = o_rpc->dd;
+	mixer_order->v1   = o_rpc->v1;
+	mixer_order->sub1 = o_rpc->sub1;
+	mixer_order->v2   = o_rpc->v2;
+	mixer_order->osd1 = o_rpc->osd1;
+	mixer_order->osd2 = o_rpc->osd2;
+	mixer_order->csr  = o_rpc->csr;
+	mixer_order->sub2 = o_rpc->sub2;
+	mixer_order->v3   = o_rpc->v3;
+	mixer_order->v4   = o_rpc->v4;
+	mixer_order->osd3 = o_rpc->osd3;
+	mixer_order->osd4 = o_rpc->osd4;
+
+exit:
+	mutex_unlock(&rpc_info->lock);
+	return ret;
+}
+
 int rpc_get_cvbs_connection_status(struct rtk_rpc_info *rpc_info,
 		unsigned int *status)
 {
diff --git a/drivers/gpu/drm/realtek/rtk_drm_rpc.h b/drivers/gpu/drm/realtek/rtk_drm_rpc.h
index 5fcc87110..df4c683e4 100644
--- a/drivers/gpu/drm/realtek/rtk_drm_rpc.h
+++ b/drivers/gpu/drm/realtek/rtk_drm_rpc.h
@@ -72,7 +72,7 @@ enum {
 	ENUM_KERNEL_RPC_DAC_I2S_CONFIG,
 	ENUM_KERNEL_RPC_DAC_SPDIF_CONFIG,
 	ENUM_KERNEL_RPC_HDMI_OUT_EDID,
-	ENUM_KERNEL_RPC_HDMI_AO_ONOFF, /* rename ENUM_KERNEL_RPC_HDMI_OUT_EDID2 */
+	ENUM_KERNEL_RPC_HDMI_OUT_EDID2,
 	ENUM_KERNEL_RPC_HDMI_SET,
 	ENUM_KERNEL_RPC_HDMI_MUTE,
 	ENUM_KERNEL_RPC_ASK_DBG_MEM_ADDR,
@@ -135,6 +135,14 @@ enum {
 	ENUM_VIDEO_KERNEL_RPC_GET_DISPLAY_OUTPUT_FORMAT,
 	ENUM_VIDEO_KERNEL_RPC_SET_ENHANCEDSDR,
 	ENUM_KERNEL_RPC_HDMI_EDID_RAW_DATA,
+	ENUM_VIDEO_KERNEL_RPC_ConfigWriteBackFlow,
+	ENUM_VIDEO_KERNEL_RPC_NPP_Init,
+	ENUM_VIDEO_KERNEL_RPC_NPP_Destroy,
+	ENUM_KERNEL_RPC_AFW_DEBUGLEVEL,
+	ENUM_KERNEL_RPC_DV_ControlPath_Info,
+	ENUM_KERNEL_RPC_GET_AFW_DEBUGLEVEL,
+	ENUM_KERNEL_RPC_ConfigureDisplayWindowDispZoomWinRatio,
+	ENUM_VIDEO_KERNEL_RPC_GET_MIXER_ORDER,
 };
 
 enum VO_VIDEO_PLANE {
@@ -1224,6 +1232,24 @@ struct rpc_set_sdrflag
 	int VideoHDRtoSDRgma;
 };
 
+// struct VIDEO_RPC_VOUT_SET_MIXER_ORDER
+struct rpc_disp_mixer_order {
+	unsigned char pic ;
+	unsigned char dd ;
+	unsigned char v1 ;
+	unsigned char sub1 ;
+	unsigned char v2 ;
+	unsigned char osd1 ;
+	unsigned char osd2 ;
+	unsigned char csr ;
+	unsigned char sub2 ;
+	unsigned char v3;
+	unsigned char v4;
+	unsigned char osd3;
+	unsigned char osd4;
+	unsigned char reserved[3] ;
+} ;
+
 /**
  * struct rpc_vout_edid_raw_data -
  *   Parameter of RPC ENUM_KERNEL_RPC_HDMI_EDID_RAW_DATA
@@ -1651,6 +1677,10 @@ int rpc_get_cvbs_format(struct rtk_rpc_info *rpc_info,
 		unsigned int *p_cvbs_fmt);
 int rpc_set_cvbs_format(struct rtk_rpc_info *rpc_info,
 		unsigned int cvbs_fmt);
+int rpc_set_mixer_order(struct rtk_rpc_info *rpc_info,
+			struct rpc_disp_mixer_order *arg);
+int rpc_get_mixer_order(struct rtk_rpc_info *rpc_info,
+			struct rpc_disp_mixer_order *arg);
 int rpc_get_cvbs_connection_status(struct rtk_rpc_info *rpc_info,
 		unsigned int *status);
 int rpc_video_set_q_param(struct rtk_rpc_info *rpc_info,
-- 
2.34.1

