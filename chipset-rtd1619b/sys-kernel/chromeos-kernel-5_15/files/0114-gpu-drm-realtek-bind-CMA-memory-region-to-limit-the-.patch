From 7de0da548a725d4ef50886897e8ebcc6815ef60d Mon Sep 17 00:00:00 2001
From: Edward Wu <edwardwu@realtek.com>
Date: Thu, 8 Aug 2024 09:42:35 +0800
Subject: [PATCH] gpu: drm: realtek: bind CMA memory-region to limit the range
 of address

jira: CHROME-113, SW-7823

Chromium/AIOT don't need Secure Media Path
No need to use RTK media/dma heap driver.

Calling dma_alloc_coherent() could use system default CMA directly.
The range of address could be limited by CMA reserved memory.

However, Linux upstream will use alloc_page instead of cma_alloc if your
requesting size is less than or equal 4K

dma_alloc_contiguous()
{
...
	if (dev->cma_area)
		return cma_alloc_aligned(dev->cma_area, size, gfp);
	if (size <= PAGE_SIZE)
		return NULL;
...
	return cma_alloc_aligned(dma_contiguous_default_area, size, gfp);
}

alloc_page can't limit address and causes unlimited address returned.
RTK a/v/hifi fw can use limit address range, it causes fw misbehavior then.

Use dts and of_reserved_mem_device_init() to binding CMA. Our device has cma_area member.
So could go into the first condition cma_alloc_aligned() even size is less than or equal 4K.
Problem solved.

Change-Id: I4c83f8268d904998b4bb34cdc7167b6e200199dd
---
 arch/arm64/boot/dts/realtek/rtd16xxb-drm.dtsi | 4 ++++
 drivers/gpu/drm/realtek/rtk_cvbs.c            | 5 +++++
 drivers/gpu/drm/realtek/rtk_dptx_core.c       | 5 +++++
 drivers/gpu/drm/realtek/rtk_drm_crtc.c        | 7 ++++++-
 drivers/gpu/drm/realtek/rtk_drm_drv.c         | 6 ++++++
 drivers/gpu/drm/realtek/rtk_hdmi.c            | 5 +++++
 6 files changed, 31 insertions(+), 1 deletion(-)

diff --git a/arch/arm64/boot/dts/realtek/rtd16xxb-drm.dtsi b/arch/arm64/boot/dts/realtek/rtd16xxb-drm.dtsi
index 37468b4e40de..af19199387b0 100644
--- a/arch/arm64/boot/dts/realtek/rtd16xxb-drm.dtsi
+++ b/arch/arm64/boot/dts/realtek/rtd16xxb-drm.dtsi
@@ -5,6 +5,7 @@ display_subsystem: display-subsystem {
 		ports = <&vo_out>;
 		realtek,krpc-agent = <&acpu_kernel_agent>, <&hifi_kernel_agent>;
 		status = "disabled";
+		memory-region = <&cma_reserved_0>;
 	};
 
 	vo: vo@98080000 {
@@ -12,6 +13,7 @@ vo: vo@98080000 {
 		reg = <0x98080000 0x2000>;
 		interrupts = <0 33 4>;
 		hwlocks = <&sb2_lock5 1>;
+		memory-region = <&cma_reserved_0>;
 		vo_out: port {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -38,6 +40,7 @@ hdmi: hdmi {
 		rxsense-mode = <1>;
 		hdcp = <2>;
 		realtek,krpc-agent = <&acpu_kernel_agent>;
+		memory-region = <&cma_reserved_0>;
 		hdmi_in: port {
 			hdmi_vo: endpoint {
 				remote-endpoint = <&vo_hdmi>;
@@ -48,6 +51,7 @@ hdmi_vo: endpoint {
 	cvbs: cvbs {
 		compatible = "realtek,rtk-cvbs";
 		status = "disabled";
+		memory-region = <&cma_reserved_0>;
 		cvbs_in: port {
 			cvbs_vo: endpoint {
 				remote-endpoint = <&vo_cvbs>;
diff --git a/drivers/gpu/drm/realtek/rtk_cvbs.c b/drivers/gpu/drm/realtek/rtk_cvbs.c
index 7221194abf8d..73355bfdef12 100644
--- a/drivers/gpu/drm/realtek/rtk_cvbs.c
+++ b/drivers/gpu/drm/realtek/rtk_cvbs.c
@@ -7,6 +7,7 @@
 
 #include <linux/platform_device.h>
 #include <linux/component.h>
+#include <linux/of_reserved_mem.h>
 
 #include "rtk_drm_drv.h"
 
@@ -211,6 +212,10 @@ static int rtk_cvbs_bind(struct device *dev, struct device *master,
 	cvbs->drm_dev = drm;
 	cvbs->dev = dev;
 
+	ret = of_reserved_mem_device_init(dev);
+	if (ret)
+		dev_warn(dev, "init reserved memory failed");
+
 	encoder = &cvbs->encoder;
 	encoder->possible_crtcs = drm_of_find_possible_crtcs(drm, dev->of_node);
 	if (encoder->possible_crtcs == 0) {
diff --git a/drivers/gpu/drm/realtek/rtk_dptx_core.c b/drivers/gpu/drm/realtek/rtk_dptx_core.c
index 2c48ff2d0115..f6f328e88a98 100644
--- a/drivers/gpu/drm/realtek/rtk_dptx_core.c
+++ b/drivers/gpu/drm/realtek/rtk_dptx_core.c
@@ -18,6 +18,7 @@
 
 #include <linux/of_irq.h>
 #include <linux/of_gpio.h>
+#include <linux/of_reserved_mem.h>
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
 
@@ -536,6 +537,10 @@ static int rtk_dptx_bind(struct device *dev, struct device *master,
 	dptx->drm_dev = drm;
 	dptx->dev = dev;
 
+	ret = of_reserved_mem_device_init(dev);
+	if (ret)
+		dev_warn(dev, "init reserved memory failed");
+
 	clk = devm_clk_get(dev, "clk_en_edp");
 	if (IS_ERR(clk)) {
 		dev_err(dev, "failed to get clock\n");
diff --git a/drivers/gpu/drm/realtek/rtk_drm_crtc.c b/drivers/gpu/drm/realtek/rtk_drm_crtc.c
index b15ede1620fe..380c735ed400 100644
--- a/drivers/gpu/drm/realtek/rtk_drm_crtc.c
+++ b/drivers/gpu/drm/realtek/rtk_drm_crtc.c
@@ -23,6 +23,7 @@
 #include <linux/interrupt.h>
 #include <linux/of_irq.h>
 #include <linux/hwspinlock.h>
+#include <linux/of_reserved_mem.h>
 
 #include "rtk_drm_drv.h"
 #include "rtk_drm_crtc.h"
@@ -324,10 +325,14 @@ static int rtk_crtc_bind(struct device *dev, struct device *master, void *data)
 	enum VO_VIDEO_PLANE layer_nr;
 	struct rtk_drm_crtc *rtk_crtc;
 	int lock_id;
-	int i;
+	int i, ret;
 
 	rtk_crtc = devm_kzalloc(dev, sizeof(*rtk_crtc), GFP_KERNEL);
 
+	ret = of_reserved_mem_device_init(dev);
+	if (ret)
+		dev_warn(dev, "init reserved memory failed");
+
 	rtk_crtc->rpc_info = &priv->rpc_info;
 	dev_set_drvdata(dev, rtk_crtc);
 
diff --git a/drivers/gpu/drm/realtek/rtk_drm_drv.c b/drivers/gpu/drm/realtek/rtk_drm_drv.c
index 618bebb16604..409d22206e11 100644
--- a/drivers/gpu/drm/realtek/rtk_drm_drv.c
+++ b/drivers/gpu/drm/realtek/rtk_drm_drv.c
@@ -24,6 +24,7 @@
 #include <drm/drm_vblank.h>
 #include <linux/component.h>
 #include <linux/platform_device.h>
+#include <linux/of_reserved_mem.h>
 
 #include "../drm_internal.h"
 #include <drm/realtek_drm.h>
@@ -88,6 +89,11 @@ static int rtk_drm_bind(struct device *dev)
 		ret = -ENOMEM;
 		goto err_free_drm;
 	}
+
+	ret = of_reserved_mem_device_init(dev);
+	if (ret)
+		dev_warn(dev, "init reserved memory failed");
+
 	drm->dev_private = priv;
 	mutex_init(&priv->obj_lock);
 	ret = rtk_rpc_init(dev, &priv->rpc_info);
diff --git a/drivers/gpu/drm/realtek/rtk_hdmi.c b/drivers/gpu/drm/realtek/rtk_hdmi.c
index 8f2f70260c0a..7d27d5b0bdff 100644
--- a/drivers/gpu/drm/realtek/rtk_hdmi.c
+++ b/drivers/gpu/drm/realtek/rtk_hdmi.c
@@ -20,6 +20,7 @@
 #include <linux/regmap.h>
 #include <linux/delay.h>
 #include <linux/extcon-provider.h>
+#include <linux/of_reserved_mem.h>
 
 #include "rtk_hdmi.h"
 #include "rtk_hdmi_reg.h"
@@ -1565,6 +1566,10 @@ static int rtk_hdmi_bind(struct device *dev, struct device *master,
 	if (!hdmi)
 		return -ENOMEM;
 
+	ret = of_reserved_mem_device_init(dev);
+	if (ret)
+		dev_warn(dev, "init reserved memory failed");
+
 	hdmi->drm_dev = drm;
 	hdmi->dev = dev;
 	dev_set_drvdata(dev, hdmi);
-- 
2.45.2

