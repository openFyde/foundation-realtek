From 739a46ec6f8c498e5af1bc4688b56a1e0bd4c1fa Mon Sep 17 00:00:00 2001
From: James Tai <james.tai@realtek.com>
Date: Mon, 14 Nov 2022 15:38:40 +0800
Subject: [PATCH 37/98] usb: add usb patch for Realtek DHC SoCs

Change-Id: I042c40866e4b2bc34e4df2127c0deecce589afb2
---
 drivers/usb/host/ehci-dbg.c   |  22 +++++
 drivers/usb/host/ehci-q.c     |  59 ++++++++++++
 drivers/usb/host/ehci-sched.c |  13 +++
 drivers/usb/host/ehci.h       |   3 +
 drivers/usb/host/ohci-hub.c   |  38 ++++++++
 drivers/usb/host/ohci.h       |  35 +++++++
 drivers/usb/host/xhci-plat.c  |  28 ++++++
 drivers/usb/host/xhci-ring.c  | 172 ++++++++++++++++++++++++++++++++++
 drivers/usb/host/xhci.h       |  21 +++++
 9 files changed, 391 insertions(+)

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 0b7f1edd9eec..f3b5bb933077 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -867,6 +867,28 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 	size -= temp;
 	next += temp;
 
+#if 1 /* USB_PATCH_BY_RTK */
+	temp = scnprintf (next, size, "CTRLDSSEGMENT %08x\n",
+			ehci_readl(ehci, &ehci->regs->segment));
+	size -= temp;
+	next += temp;
+
+	temp = scnprintf (next, size, "PERIODIC_LIST_BASE %08x\n",
+			ehci_readl(ehci, &ehci->regs->frame_list));
+	size -= temp;
+	next += temp;
+
+	temp = scnprintf (next, size, "ASYNC_LIST_ADDR %08x\n",
+			ehci_readl(ehci, &ehci->regs->async_next));
+	size -= temp;
+	next += temp;
+
+	temp = scnprintf (next, size, "CONFIG_FLAG %08x\n",
+			ehci_readl(ehci, &ehci->regs->configured_flag));
+	size -= temp;
+	next += temp;
+#endif /* USB_PATCH_BY_RTK */
+
 	for (i = 1; i <= HCS_N_PORTS(ehci->hcs_params); i++) {
 		temp = dbg_port_buf(scratch, sizeof(scratch), label, i,
 				ehci_readl(ehci,
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 2cbf4f85bff3..1d121346f0b1 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -33,6 +33,33 @@
 
 /* fill a qtd, returning how much of the buffer we were able to queue up */
 
+#if 1 /* USB_PATCH_BY_RTK */
+extern int RTK_ohci_force_suspend(const char *func);
+
+/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+int check_and_restore_async_list(struct ehci_hcd *ehci, const char *func, int line) {
+
+	int retry = 0;
+	if (ehci->fixed_async_list_addr_bug) {
+		for (retry = 0; retry < 5; retry++) {
+			u32 async_next = ehci_readl(ehci, &ehci->regs->async_next);
+			if (async_next == 0) {
+				ehci_err(ehci, "%s:%d #%d async_next is NULL ==> fixed async_next to HEAD=%x\n",
+					func, line, retry, (unsigned int) ehci->async->qh_dma);
+				ehci_writel(ehci, (u32) ehci->async->qh_dma,
+					&ehci->regs->async_next);
+				wmb();
+				mdelay(2);
+			} else {
+				break;
+			}
+		}
+	}
+	return 0;
+}
+#endif /* USB_PATCH_BY_RTK */
+
+
 static int
 qtd_fill(struct ehci_hcd *ehci, struct ehci_qtd *qtd, dma_addr_t buf,
 		  size_t len, int token, int maxpacket)
@@ -952,6 +979,11 @@ qh_make (
 
 static void enable_async(struct ehci_hcd *ehci)
 {
+#if 1 /* USB_PATCH_BY_RTK */
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	check_and_restore_async_list(ehci, __func__, __LINE__);
+#endif /* USB_PATCH_BY_RTK */
+
 	if (ehci->async_count++)
 		return;
 
@@ -965,6 +997,11 @@ static void enable_async(struct ehci_hcd *ehci)
 
 static void disable_async(struct ehci_hcd *ehci)
 {
+#if 1 /* USB_PATCH_BY_RTK */
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	check_and_restore_async_list(ehci, __func__, __LINE__);
+#endif /* USB_PATCH_BY_RTK */
+
 	if (--ehci->async_count)
 		return;
 
@@ -983,6 +1020,12 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	__hc32		dma = QH_NEXT(ehci, qh->qh_dma);
 	struct ehci_qh	*head;
 
+#if 1 /* USB_PATCH_BY_RTK */
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	/* When EHCI schedule actived, force suspend OHCI*/
+	check_and_restore_async_list(ehci, __func__, __LINE__);
+#endif /* USB_PATCH_BY_RTK */
+
 	/* Don't link a QH if there's a Clear-TT-Buffer pending */
 	if (unlikely(qh->clearing_tt))
 		return;
@@ -1111,6 +1154,12 @@ submit_async (
 	int			rc;
 
 	epnum = urb->ep->desc.bEndpointAddress;
+#if 1 /* USB_PATCH_BY_RTK */
+#ifdef CONFIG_USB_OHCI_RTK
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	RTK_ohci_force_suspend(__func__);
+#endif
+#endif /* USB_PATCH_BY_RTK */
 
 #ifdef EHCI_URB_TRACE
 	{
@@ -1271,6 +1320,11 @@ static void single_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	prev->qh_next = qh->qh_next;
 	if (ehci->qh_scan_next == qh)
 		ehci->qh_scan_next = qh->qh_next.qh;
+
+#if 1 /* USB_PATCH_BY_RTK */
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	check_and_restore_async_list(ehci, __func__, __LINE__);
+#endif /* USB_PATCH_BY_RTK */
 }
 
 static void start_iaa_cycle(struct ehci_hcd *ehci)
@@ -1300,6 +1354,11 @@ static void end_iaa_cycle(struct ehci_hcd *ehci)
 		ehci_writel(ehci, (u32) ehci->async->qh_dma,
 			    &ehci->regs->async_next);
 
+#if 1 /* USB_PATCH_BY_RTK */
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	check_and_restore_async_list(ehci, __func__, __LINE__);
+#endif /* USB_PATCH_BY_RTK */
+
 	/* The current IAA cycle has ended */
 	ehci->iaa_in_progress = false;
 
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 0f85aa9b2fb1..0b7b07a322d1 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -6,6 +6,11 @@
 
 /* this file is part of ehci-hcd.c */
 
+#if 1 /* USB_PATCH_BY_RTK */
+/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+extern int RTK_ohci_force_suspend(const char *func);
+#endif /* USB_PATCH_BY_RTK */
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -915,6 +920,14 @@ static int intr_submit(
 	/* get endpoint and transfer/schedule data */
 	epnum = urb->ep->desc.bEndpointAddress;
 
+#if 1 /* USB_PATCH_BY_RTK */
+#ifdef CONFIG_USB_OHCI_RTK
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	/* When EHCI schedule actived, force suspend OHCI*/
+	RTK_ohci_force_suspend(__func__);
+#endif
+#endif /* USB_PATCH_BY_RTK */
+
 	spin_lock_irqsave(&ehci->lock, flags);
 
 	if (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 9888ca5f5f36..cbe2369cead4 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -220,6 +220,9 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		need_oc_pp_cycle:1; /* MPC834X port power */
 	unsigned		imx28_write_fix:1; /* For Freescale i.MX28 */
 	unsigned		spurious_oc:1;
+#if 1 /* USB_PATCH_BY_RTK */
+	unsigned		fixed_async_list_addr_bug:1;
+#endif /* USB_PATCH_BY_RTK */
 	unsigned		is_aspeed:1;
 
 	/* required for usb32 quirk */
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index f474f2f9c1e4..dd93b20dbb74 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -43,6 +43,13 @@
 static void update_done_list(struct ohci_hcd *);
 static void ohci_work(struct ohci_hcd *);
 
+#if 1 /* USB_PATCH_BY_RTK */
+#ifdef CONFIG_USB_EHCI_RTK
+/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+extern bool RTK_ehci_check_schedule_actived(const char *func);
+#endif
+#endif /* USB_PATCH_BY_RTK */
+
 #ifdef	CONFIG_PM
 static int ohci_rh_suspend (struct ohci_hcd *ohci, int autostop)
 __releases(ohci->lock)
@@ -155,6 +162,20 @@ __acquires(ohci->lock)
 	int			status = -EINPROGRESS;
 	int			autostopped = ohci->autostop;
 
+#if 1 /* USB_PATCH_BY_RTK */
+#ifdef CONFIG_USB_EHCI_RTK
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	/* When EHCI schedule actived, don't resume OHCI*/
+	if (RTK_ehci_check_schedule_actived(__func__)) {
+		ohci_info (ohci, "[Workaround] %s EHCI schedule actived, skip resume OHCI\n", __func__);
+		return 0;
+	} else {
+		ohci->resuming = 1;
+		init_completion(&ohci->resuming_done);
+	}
+#endif
+#endif /* USB_PATCH_BY_RTK */
+
 	ohci->autostop = 0;
 	ohci->hc_control = ohci_readl (ohci, &ohci->regs->control);
 
@@ -295,6 +316,12 @@ __acquires(ohci->lock)
 	}
 
 	ohci->rh_state = OHCI_RH_RUNNING;
+#if 1 /* USB_PATCH_BY_RTK */
+	if (ohci->resuming) {
+		complete(&ohci->resuming_done);
+		ohci->resuming = 0;
+	}
+#endif /* USB_PATCH_BY_RTK */
 	return 0;
 }
 
@@ -521,6 +548,17 @@ int ohci_hub_status_data(struct usb_hcd *hcd, char *buf)
 	else
 		clear_bit(HCD_FLAG_POLL_RH, &hcd->flags);
 
+#if 1 /* USB_PATCH_BY_RTK */
+	/* add to check OHCI register deadbeef */
+	if (true) {
+		u32 status = roothub_portstatus (ohci, 0);
+		if (status == 0xdeadbeef) {
+			ohci_err(ohci, "OHCI register is 0x%x"
+					" to clear HCD_FLAG_POLL_RH", status);
+			clear_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+		}
+	}
+#endif /* USB_PATCH_BY_RTK */
 
 done:
 	spin_unlock_irqrestore (&ohci->lock, flags);
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index aac6285b37f8..88a3e45f2f2f 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -8,6 +8,10 @@
  * This file is licenced under the GPL.
  */
 
+#if 0 /* USB_PATCH_BY_RTK */
+#include <soc/realtek/rtd129x_lockapi.h>
+#endif /* USB_PATCH_BY_RTK */
+
 /*
  * __hc32 and __hc16 are "Host Controller" types, they may be equivalent to
  * __leXX (normally) or __beXX (given OHCI_BIG_ENDIAN), depending on the
@@ -362,6 +366,10 @@ enum ohci_rh_state {
 struct ohci_hcd {
 	spinlock_t		lock;
 
+#if 1 /* USB_PATCH_BY_RTK */
+	void __iomem *wrap_reg;
+#endif /* USB_PATCH_BY_RTK */
+
 	/*
 	 * I/O memory used to communicate with the HC (dma-consistent)
 	 */
@@ -399,6 +407,10 @@ struct ohci_hcd {
 	 * driver state
 	 */
 	enum ohci_rh_state	rh_state;
+#if 1 /* USB_PATCH_BY_RTK */
+	int 		resuming;
+	struct completion resuming_done;
+#endif /* USB_PATCH_BY_RTK */
 	int			num_ports;
 	int			load [NUM_INTS];
 	u32			hc_control;	/* copy of hc control reg */
@@ -561,6 +573,18 @@ static inline struct usb_hcd *ohci_to_hcd (const struct ohci_hcd *ohci)
 static inline unsigned int _ohci_readl (const struct ohci_hcd *ohci,
 					__hc32 __iomem * regs)
 {
+#if 1 /* USB_PATCH_BY_RTK */
+	//unsigned long flags;
+	//rtk_lockapi_lock(flags, __FUNCTION__); /* Add global lock for emmc issue*/
+	if (ohci->wrap_reg && readl(ohci->wrap_reg) == 0x0) {
+		ohci_err(ohci, "%s [USB Workaround] fixed force to enable "
+			    "ohci clock \n", __func__);
+		writel(0x40, ohci->wrap_reg);
+		mdelay(1);
+	}
+	//rtk_lockapi_unlock(flags,__FUNCTION__); /* Add global lock for emmc issue*/
+#endif /* USB_PATCH_BY_RTK */
+
 #ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
 	return big_endian_mmio(ohci) ?
 		readl_be (regs) :
@@ -573,6 +597,17 @@ static inline unsigned int _ohci_readl (const struct ohci_hcd *ohci,
 static inline void _ohci_writel (const struct ohci_hcd *ohci,
 				 const unsigned int val, __hc32 __iomem *regs)
 {
+#if 1 /* USB_PATCH_BY_RTK */
+	//unsigned long flags;
+	//rtk_lockapi_lock(flags, __FUNCTION__); /* Add global lock for emmc issue*/
+	if (ohci->wrap_reg && readl(ohci->wrap_reg) == 0x0) {
+		ohci_err(ohci, "%s [USB Workaround] fixed force to enable ohci clock \n", __func__);
+		writel(0x40, ohci->wrap_reg);
+		mdelay(1);
+	}
+	//rtk_lockapi_unlock(flags,__FUNCTION__); /* Add global lock for emmc issue*/
+#endif /* USB_PATCH_BY_RTK */
+
 #ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
 	big_endian_mmio(ohci) ?
 		writel_be (val, regs) :
diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index ff193819ec3c..88de2f8bd5cb 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -311,6 +311,11 @@ static int xhci_plat_probe(struct platform_device *pdev)
 	/* imod_interval is the interrupt moderation value in nanoseconds. */
 	xhci->imod_interval = 40000;
 
+#if 1 /* USB_PATCH_BY_RTK */
+	xhci->usb3_trb_cache_size = DEFAULT_USB3_TRB_CACHE_SZIE;
+	xhci->usb2_trb_cache_size = DEFAULT_USB2_TRB_CACHE_SZIE;
+#endif /* USB_PATCH_BY_RTK */
+
 	/* Iterate over all parent nodes for finding quirks */
 	for (tmpdev = &pdev->dev; tmpdev; tmpdev = tmpdev->parent) {
 
@@ -325,6 +330,18 @@ static int xhci_plat_probe(struct platform_device *pdev)
 
 		device_property_read_u32(tmpdev, "imod-interval-ns",
 					 &xhci->imod_interval);
+
+#if 1 /* USB_PATCH_BY_RTK */
+		if (!device_property_read_u32(tmpdev, "usb3-trb-cache-size",
+					 &xhci->usb3_trb_cache_size))
+			dev_info(&pdev->dev, "set usb3_trb_cache_size=%d\n",
+				    xhci->usb3_trb_cache_size);
+
+		if (!device_property_read_u32(tmpdev, "usb2-trb-cache-size",
+					 &xhci->usb2_trb_cache_size))
+			dev_info(&pdev->dev, "set usb2_trb_cache_size=%d\n",
+				    xhci->usb2_trb_cache_size);
+#endif /* USB_PATCH_BY_RTK */
 	}
 
 	hcd->usb_phy = devm_usb_get_phy_by_phandle(sysdev, "usb-phy", 0);
@@ -339,6 +356,17 @@ static int xhci_plat_probe(struct platform_device *pdev)
 			goto put_usb3_hcd;
 	}
 
+	xhci->shared_hcd->usb_phy = devm_usb_get_phy_by_phandle(sysdev,
+		    "usb-phy", 1);
+	if (IS_ERR(xhci->shared_hcd->usb_phy)) {
+		xhci->shared_hcd->usb_phy = NULL;
+	} else {
+		ret = usb_phy_init(xhci->shared_hcd->usb_phy);
+		if (ret)
+			dev_err(sysdev, "%s init usb3phy fail (ret=%d)\n",
+				    __func__, ret);
+	}
+
 	hcd->tpl_support = of_usb_host_tpl_support(sysdev->of_node);
 	xhci->shared_hcd->tpl_support = hcd->tpl_support;
 
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 7969492b7bc5..ca6ea65e535e 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -761,6 +761,68 @@ static void xhci_giveback_urb_in_irq(struct xhci_hcd *xhci,
 	usb_hcd_giveback_urb(hcd, urb, status);
 }
 
+#if 1 /* USB_PATCH_BY_RTK */
+static void xhci_unmap_td_cache_buf(struct xhci_hcd *xhci,
+		struct xhci_ring *ring, struct xhci_td *td)
+{
+	struct device *dev = xhci_to_hcd(xhci)->self.controller;
+	struct urb *urb = td->urb;
+	size_t len;
+	struct xhci_cache_buf *cache_buf, *tmp;
+
+	if (usb_urb_dir_out(urb)) {
+		list_for_each_entry_safe(cache_buf, tmp, &td->cache_buf_list,
+			    list) {
+			if (!cache_buf)
+				continue;
+
+			list_del_init(&cache_buf->list);
+
+			if (!cache_buf->buf) {
+				xhci_err(xhci, "%s cache_buf buf is NULL\n",
+					    __func__);
+				kfree(cache_buf);
+				continue;
+			}
+
+			dma_unmap_single(dev, cache_buf->dma, cache_buf->len,
+				 DMA_TO_DEVICE);
+
+			kfree(cache_buf->buf);
+			kfree(cache_buf);
+		}
+		return;
+	}
+
+	list_for_each_entry_safe(cache_buf, tmp, &td->cache_buf_list,
+		    list) {
+		if (!cache_buf)
+			continue;
+
+		list_del_init(&cache_buf->list);
+
+		if (!cache_buf->buf) {
+			xhci_err(xhci, "%s cache_buf buf is NULL\n", __func__);
+			kfree(cache_buf);
+			continue;
+		}
+
+		dma_unmap_single(dev, cache_buf->dma, cache_buf->len,
+			 DMA_FROM_DEVICE);
+		/* for in tranfers we need to copy the data from cache to sg */
+		len = sg_pcopy_from_buffer(urb->sg, urb->num_sgs,
+			     cache_buf->buf,
+			     cache_buf->len, cache_buf->offs);
+		if (len != cache_buf->len)
+			xhci_warn(xhci, "WARN Wrong cache buffer read length: %zu != %d\n",
+				    len, cache_buf->len);
+
+		kfree(cache_buf->buf);
+		kfree(cache_buf);
+	}
+}
+#endif /* USB_PATCH_BY_RTK */
+
 static void xhci_unmap_td_bounce_buffer(struct xhci_hcd *xhci,
 		struct xhci_ring *ring, struct xhci_td *td)
 {
@@ -769,6 +831,10 @@ static void xhci_unmap_td_bounce_buffer(struct xhci_hcd *xhci,
 	struct urb *urb = td->urb;
 	size_t len;
 
+#if 1 /* USB_PATCH_BY_RTK */
+	xhci_unmap_td_cache_buf(xhci, ring, td);
+#endif /* USB_PATCH_BY_RTK */
+
 	if (!ring || !seg || !urb)
 		return;
 
@@ -3325,6 +3391,9 @@ static int prepare_transfer(struct xhci_hcd *xhci,
 
 	INIT_LIST_HEAD(&td->td_list);
 	INIT_LIST_HEAD(&td->cancelled_td_list);
+#if 1 /* USB_PATCH_BY_RTK */
+	INIT_LIST_HEAD(&td->cache_buf_list);
+#endif /* USB_PATCH_BY_RTK */
 
 	if (td_index == 0) {
 		ret = usb_hcd_link_urb_to_ep(bus_to_hcd(urb->dev->bus), urb);
@@ -3508,6 +3577,63 @@ static u32 xhci_td_remainder(struct xhci_hcd *xhci, int transferred,
 	return (total_packet_count - ((transferred + trb_buff_len) / maxp));
 }
 
+#if 1 /* USB_PATCH_BY_RTK */
+static u64 xhci_align_cache_buf(struct xhci_hcd *xhci,
+	    struct urb *urb, u32 enqd_len, u32 hw_limit_buf_len,
+	    u32 *trb_buff_len, struct xhci_td *td)
+{
+	struct device *dev = xhci_to_hcd(xhci)->self.controller;
+	struct xhci_cache_buf *cache_buf;
+	unsigned int max_pkt;
+	u32 new_buff_len;
+	size_t len;
+
+	max_pkt = usb_endpoint_maxp(&urb->ep->desc);
+
+	cache_buf = kzalloc(sizeof(struct xhci_cache_buf), GFP_KERNEL);
+	if (!cache_buf)
+		return -ENOMEM;
+	list_add(&cache_buf->list, &td->cache_buf_list);
+
+	cache_buf->buf = kzalloc(max_pkt, GFP_DMA | GFP_ATOMIC);
+	if (!cache_buf->buf)
+		return -ENOMEM;
+
+	new_buff_len = max_pkt - (enqd_len % max_pkt);
+
+	if (new_buff_len > (urb->transfer_buffer_length - enqd_len))
+		new_buff_len = (urb->transfer_buffer_length - enqd_len);
+
+	/* create a max max_pkt sized cache buffer pointed to by last trb */
+	if (usb_urb_dir_out(urb)) {
+		len = sg_pcopy_to_buffer(urb->sg, urb->num_sgs,
+				   cache_buf->buf, new_buff_len, enqd_len);
+		if (len != new_buff_len)
+			xhci_warn(xhci,
+				"WARN Wrong cache buffer write length: %zu != %d\n",
+				len, new_buff_len);
+		cache_buf->dma = dma_map_single(dev, cache_buf->buf,
+						 max_pkt, DMA_TO_DEVICE);
+	} else {
+		cache_buf->dma = dma_map_single(dev, cache_buf->buf,
+						 max_pkt, DMA_FROM_DEVICE);
+	}
+
+	if (dma_mapping_error(dev, cache_buf->dma)) {
+		/* try without aligning. Some host controllers survive */
+		xhci_warn(xhci, "Failed mapping cache buffer, not aligning\n");
+		return 0;
+	}
+	*trb_buff_len = new_buff_len;
+
+	cache_buf->len = new_buff_len;
+	cache_buf->offs = enqd_len;
+
+	xhci_dbg(xhci, "cache buf align, new buff len %d\n", *trb_buff_len);
+
+	return cache_buf->dma;
+}
+#endif /* USB_PATCH_BY_RTK */
 
 static int xhci_align_td(struct xhci_hcd *xhci, struct urb *urb, u32 enqd_len,
 			 u32 *trb_buff_len, struct xhci_segment *seg)
@@ -3596,6 +3722,24 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 	int sent_len, ret;
 	u32 field, length_field, remainder;
 	u64 addr, send_addr;
+#if 1 /* USB_PATCH_BY_RTK */
+	int max_hw_limit_num_trbs, hw_limit_num_trbs = 0;
+	int max_hw_limit_buf_len, hw_limit_buf_len = 0;
+
+	max_hw_limit_buf_len = usb_endpoint_maxp(&urb->ep->desc);
+	if (urb->dev->speed >= USB_SPEED_SUPER)
+		max_hw_limit_num_trbs = xhci->usb3_trb_cache_size;
+	else
+		max_hw_limit_num_trbs = xhci->usb2_trb_cache_size;
+
+	/* If max_hw_limit_num_trbs is zero, disable max_hw_limit_num_trbs */
+	if (!max_hw_limit_num_trbs)
+		max_hw_limit_num_trbs = INT_MAX;
+
+	/* A safe limit is trb cache size minus 3 */
+	max_hw_limit_num_trbs -= 3;
+
+#endif /* USB_PATCH_BY_RTK */
 
 	ring = xhci_urb_to_transfer_ring(xhci, urb);
 	if (!ring)
@@ -3662,6 +3806,28 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		 */
 		if (enqd_len + trb_buff_len < full_len) {
 			field |= TRB_CHAIN;
+
+#if 1 /* USB_PATCH_BY_RTK */
+			hw_limit_num_trbs++;
+			hw_limit_buf_len += trb_buff_len;
+
+			if (hw_limit_buf_len >= max_hw_limit_buf_len) {
+				hw_limit_buf_len = (enqd_len + trb_buff_len) %
+					    max_hw_limit_buf_len;
+				hw_limit_num_trbs = 0;
+			} else if (hw_limit_num_trbs >= max_hw_limit_num_trbs) {
+				send_addr = xhci_align_cache_buf(xhci, urb,
+					    enqd_len, hw_limit_buf_len,
+					    &trb_buff_len, td);
+				if (send_addr <= 0)
+					return send_addr;
+
+				hw_limit_buf_len = (enqd_len + trb_buff_len) %
+					    max_hw_limit_buf_len;
+				hw_limit_num_trbs = 0;
+			}
+#endif /* USB_PATCH_BY_RTK */
+
 			if (trb_is_link(ring->enqueue + 1)) {
 				if (xhci_align_td(xhci, urb, enqd_len,
 						  &trb_buff_len,
@@ -3669,6 +3835,12 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 					send_addr = ring->enq_seg->bounce_dma;
 					/* assuming TD won't span 2 segs */
 					td->bounce_seg = ring->enq_seg;
+#if 1 /* USB_PATCH_BY_RTK */
+					hw_limit_buf_len = (enqd_len +
+						    trb_buff_len) %
+						    max_hw_limit_buf_len;
+					hw_limit_num_trbs = 0;
+#endif /* USB_PATCH_BY_RTK */
 				}
 			}
 		}
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 77184805e974..919733112960 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1557,6 +1557,17 @@ enum xhci_cancelled_td_status {
 	TD_CLEARED,
 };
 
+#if 1 /* USB_PATCH_BY_RTK */
+struct xhci_cache_buf {
+	dma_addr_t		dma;
+	void			*buf;
+	unsigned int		offs;
+	unsigned int		len;
+
+	struct list_head list;
+};
+#endif /* USB_PATCH_BY_RTK */
+
 struct xhci_td {
 	struct list_head	td_list;
 	struct list_head	cancelled_td_list;
@@ -1571,6 +1582,9 @@ struct xhci_td {
 	/* actual_length of the URB has already been set */
 	bool			urb_length_set;
 	unsigned int		num_trbs;
+#if 1 /* USB_PATCH_BY_RTK */
+	struct list_head cache_buf_list;
+#endif /* USB_PATCH_BY_RTK */
 };
 
 /* xHCI command default timeout value */
@@ -1929,6 +1943,13 @@ struct xhci_hcd {
 /* Compliance Mode Timer Triggered every 2 seconds */
 #define COMP_MODE_RCVRY_MSECS 2000
 
+#if 1 /* USB_PATCH_BY_RTK */
+	int usb3_trb_cache_size;
+	int usb2_trb_cache_size;
+#define DEFAULT_USB3_TRB_CACHE_SZIE 16
+#define DEFAULT_USB2_TRB_CACHE_SZIE 10
+#endif /* USB_PATCH_BY_RTK */
+
 	struct dentry		*debugfs_root;
 	struct dentry		*debugfs_slots;
 	struct list_head	regset_list;
-- 
2.45.2

