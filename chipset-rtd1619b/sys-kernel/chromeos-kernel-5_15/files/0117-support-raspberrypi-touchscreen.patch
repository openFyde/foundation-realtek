From feebdc1df207501e7252a1747c65a83f2694a9da Mon Sep 17 00:00:00 2001
From: yaozenhu <yaozenhu@realtek.com>
Date: Mon, 7 Oct 2024 13:51:25 +0800
Subject: [PATCH] support raspberrypi touchscreen

---
 .../drm/panel/panel-raspberrypi-touchscreen.c |  61 +++--
 drivers/input/touchscreen/Kconfig             |  12 +
 drivers/input/touchscreen/Makefile            |   1 +
 drivers/input/touchscreen/dfr0550-ts.c        | 225 ++++++++++++++++++
 4 files changed, 274 insertions(+), 25 deletions(-)
 create mode 100644 drivers/input/touchscreen/dfr0550-ts.c

Index: kernel-5_15/drivers/gpu/drm/panel/panel-raspberrypi-touchscreen.c
===================================================================
--- kernel-5_15.orig/drivers/gpu/drm/panel/panel-raspberrypi-touchscreen.c
+++ kernel-5_15/drivers/gpu/drm/panel/panel-raspberrypi-touchscreen.c
@@ -218,10 +218,10 @@ static struct rpi_touchscreen *panel_to_
 	return container_of(panel, struct rpi_touchscreen, base);
 }
 
-static int rpi_touchscreen_i2c_read(struct rpi_touchscreen *ts, u8 reg)
-{
-	return i2c_smbus_read_byte_data(ts->i2c, reg);
-}
+// static int rpi_touchscreen_i2c_read(struct rpi_touchscreen *ts, u8 reg)
+// {
+// 	return i2c_smbus_read_byte_data(ts->i2c, reg);
+// }
 
 static void rpi_touchscreen_i2c_write(struct rpi_touchscreen *ts,
 				      u8 reg, u8 val)
@@ -269,14 +269,16 @@ static int rpi_touchscreen_noop(struct d
 static int rpi_touchscreen_prepare(struct drm_panel *panel)
 {
 	struct rpi_touchscreen *ts = panel_to_ts(panel);
-	int i;
 
 	rpi_touchscreen_i2c_write(ts, REG_POWERON, 1);
 	/* Wait for nPWRDWN to go low to indicate poweron is done. */
-	for (i = 0; i < 100; i++) {
-		if (rpi_touchscreen_i2c_read(ts, REG_PORTB) & 1)
-			break;
-	}
+	// for (i = 0; i < 100; i++) {
+	// 	if (rpi_touchscreen_i2c_read(ts, REG_PORTB) & 1)
+	// 		break;
+	// }
+
+	msleep(100);
+	rpi_touchscreen_i2c_write(ts, REG_PWM, 0);
 
 	rpi_touchscreen_write(ts, DSI_LANEENABLE,
 			      DSI_LANEENABLE_CLOCK |
@@ -288,7 +290,16 @@ static int rpi_touchscreen_prepare(struc
 	rpi_touchscreen_write(ts, PPI_LPTXTIMECNT, 0x03);
 
 	rpi_touchscreen_write(ts, SPICMR, 0x00);
+
+#if 1
+	rpi_touchscreen_write(ts, HSR, 0x2c0002);
+	rpi_touchscreen_write(ts, VSR, 0x150002);
+	rpi_touchscreen_write(ts, HDISPR, 0x3d0320);
+	rpi_touchscreen_write(ts, VDISPR, 0x0701e0);
+	rpi_touchscreen_write(ts, LCDCTRL, 0x00100152);
+#else
 	rpi_touchscreen_write(ts, LCDCTRL, 0x00100150);
+#endif
 	rpi_touchscreen_write(ts, SYSCTRL, 0x040f);
 	msleep(100);
 
@@ -311,7 +322,7 @@ static int rpi_touchscreen_enable(struct
 	 * configuration will be supported using VC4's plane
 	 * orientation bits.
 	 */
-	rpi_touchscreen_i2c_write(ts, REG_PORTA, BIT(2));
+	// rpi_touchscreen_i2c_write(ts, REG_PORTA, BIT(2));
 
 	return 0;
 }
@@ -369,7 +380,7 @@ static int rpi_touchscreen_probe(struct
 	struct rpi_touchscreen *ts;
 	struct device_node *endpoint, *dsi_host_node;
 	struct mipi_dsi_host *host;
-	int ver;
+
 	struct mipi_dsi_device_info info = {
 		.type = RPI_DSI_DRIVER_NAME,
 		.channel = 0,
@@ -384,20 +395,20 @@ static int rpi_touchscreen_probe(struct
 
 	ts->i2c = i2c;
 
-	ver = rpi_touchscreen_i2c_read(ts, REG_ID);
-	if (ver < 0) {
-		dev_err(dev, "Atmel I2C read failed: %d\n", ver);
-		return -ENODEV;
-	}
-
-	switch (ver) {
-	case 0xde: /* ver 1 */
-	case 0xc3: /* ver 2 */
-		break;
-	default:
-		dev_err(dev, "Unknown Atmel firmware revision: 0x%02x\n", ver);
-		return -ENODEV;
-	}
+	// ver = rpi_touchscreen_i2c_read(ts, REG_ID);
+	// if (ver < 0) {
+	// 	dev_err(dev, "Atmel I2C read failed: %d\n", ver);
+	// 	return -ENODEV;
+	// }
+
+	// switch (ver) {
+	// case 0xde: /* ver 1 */
+	// case 0xc3: /* ver 2 */
+	// 	break;
+	// default:
+	// 	dev_err(dev, "Unknown Atmel firmware revision: 0x%02x\n", ver);
+	// 	return -ENODEV;
+	// }
 
 	/* Turn off at boot, so we can cleanly sequence powering on. */
 	rpi_touchscreen_i2c_write(ts, REG_POWERON, 0);
Index: kernel-5_15/drivers/input/touchscreen/Kconfig
===================================================================
--- kernel-5_15.orig/drivers/input/touchscreen/Kconfig
+++ kernel-5_15/drivers/input/touchscreen/Kconfig
@@ -309,6 +309,18 @@ config TOUCHSCREEN_DA9052
 	  To compile this driver as a module, choose M here: the
 	  module will be called da9052_tsi.
 
+config TOUCHSCREEN_DFR0550
+	tristate "DFROBOT DFR0550 touchscreen"
+	depends on I2C
+	help
+	  Say Y here to enable the support for the touchscreen found
+	  on DFROBOT DFR0550 and DFR0678 displays.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called dfr0550.
+
 config TOUCHSCREEN_DYNAPRO
 	tristate "Dynapro serial touchscreen"
 	select SERIO
Index: kernel-5_15/drivers/input/touchscreen/Makefile
===================================================================
--- kernel-5_15.orig/drivers/input/touchscreen/Makefile
+++ kernel-5_15/drivers/input/touchscreen/Makefile
@@ -31,6 +31,7 @@ obj-$(CONFIG_TOUCHSCREEN_CYTTSP4_I2C)	+=
 obj-$(CONFIG_TOUCHSCREEN_CYTTSP4_SPI)	+= cyttsp4_spi.o
 obj-$(CONFIG_TOUCHSCREEN_DA9034)	+= da9034-ts.o
 obj-$(CONFIG_TOUCHSCREEN_DA9052)	+= da9052_tsi.o
+obj-$(CONFIG_TOUCHSCREEN_DFR0550)	+= dfr0550-ts.o
 obj-$(CONFIG_TOUCHSCREEN_DYNAPRO)	+= dynapro.o
 obj-$(CONFIG_TOUCHSCREEN_EDT_FT5X06)	+= edt-ft5x06.o
 obj-$(CONFIG_TOUCHSCREEN_HAMPSHIRE)	+= hampshire.o
Index: kernel-5_15/drivers/input/touchscreen/dfr0550-ts.c
===================================================================
--- /dev/null
+++ kernel-5_15/drivers/input/touchscreen/dfr0550-ts.c
@@ -0,0 +1,225 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * DFROBOT DFR0550 touchscreen driver
+ *
+ * These touchscreen displays are intended to be compatible with the official
+ * Raspberry Pi 7in display which has an FTx06 touch controller directly
+ * attached to the 15pin connector to the host processor. However these
+ * displays have an FTx06 touch controller that connected to an I2C master
+ * on a STM32F103 micro controller which polls the FTx06 and emulates a
+ * virtual I2C device connected to the 15pin connector to the host processor.
+ * The emulated FTx06 implements a subset of the FTx06 register set but
+ * must be read with individual transactions between reading the number
+ * of points and the point data itself.
+ *
+ * Additionally there is no IRQ made available so this is a polling driver.
+ *
+ * Copyright (C) 2015, 2017 Raspberry Pi
+ * Copyright (C) 2018 Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
+ */
+#include <linux/of.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+// #include <linux/input-polldev.h>
+#include <linux/input/touchscreen.h>
+#include <linux/i2c.h>
+
+#define TS_DEFAULT_WIDTH 800
+#define TS_DEFAULT_HEIGHT 480
+#define TS_MAX_SUPPORTED_POINTS 5
+#define TS_FTS_TOUCH_DOWN 0
+#define TS_FTS_TOUCH_CONTACT 2
+#define TS_POLL_INTERVAL 17	/* 60fps */
+#define TS_NPOINTS_REG_INVALIDATE 99
+
+struct dfr0550_ts {
+	struct i2c_client *i2c;
+	struct input_dev *input;
+	struct touchscreen_properties prop;
+	unsigned int rotate;
+	int known_ids;
+};
+
+static int dfr0550_i2c_read(struct i2c_client *client, u8 reg, u8 *buf, int len)
+{
+	struct i2c_msg msgs[2];
+	int ret;
+	msgs[0].flags = 0;
+	msgs[0].addr = client->addr;
+	msgs[0].len = 1;
+	msgs[0].buf = &reg;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].addr = client->addr;
+	msgs[1].len = len;
+	msgs[1].buf = buf;
+	ret = i2c_transfer(client->adapter, msgs, 2);
+	return reg < 0 ? ret : (ret != ARRAY_SIZE(msgs) ? -EIO : 0);
+}
+
+static void dfr0550_ts_poll(struct input_dev *input)
+{
+	struct dfr0550_ts *ts = input_get_drvdata(input);
+	// struct input_dev *input = dev->input;
+	// struct dfr0550_ts *ts = dev->private;
+	int modified_ids = 0;
+	long released_ids;
+	int points, i;
+	int event_type;
+	int touchid;
+	int x, y;
+	u8 buf[4];
+
+	dfr0550_i2c_read(ts->i2c, 0x2, buf, 1);
+
+	if (buf[0] == 0xff)
+		return;
+
+	points = min(buf[0] & 0xf, 5);
+
+	for (i = 0; i < points; i++) {
+		dfr0550_i2c_read(ts->i2c, 3+6*i, buf, 4);
+		x = ((((int)buf[0] & 0xf) << 8) + buf[1]);
+		y = ((((int)buf[2] & 0xf) << 8) + buf[3]);
+		if (ts->rotate == 180) {
+			x = TS_DEFAULT_WIDTH - x;
+			y = TS_DEFAULT_HEIGHT - y;
+		}
+		touchid = (buf[2] >> 4) & 0xf;
+		event_type = (buf[0] >> 6) & 0x03;
+		modified_ids |= BIT(touchid);
+		if (event_type == TS_FTS_TOUCH_DOWN ||
+		    event_type == TS_FTS_TOUCH_CONTACT) {
+			input_mt_slot(input, touchid);
+			input_mt_report_slot_state(input, MT_TOOL_FINGER, 1);
+			touchscreen_report_pos(input, &ts->prop, x, y, true);
+		}
+		dev_dbg(&ts->i2c->dev, "rotate: %d, point[%d]: %d, %d\n", ts->rotate, i, x, y);
+	}
+
+	released_ids = ts->known_ids & ~modified_ids;
+	for_each_set_bit(i, &released_ids, TS_MAX_SUPPORTED_POINTS) {
+		input_mt_slot(input, i);
+		input_mt_report_slot_state(input, MT_TOOL_FINGER, 0);
+		modified_ids &= ~(BIT(i));
+	}
+
+	ts->known_ids = modified_ids;
+	input_mt_sync_frame(input);
+	input_sync(input);
+}
+
+static int dfr0550_ts_i2c_probe(struct i2c_client *i2c,
+						const struct i2c_device_id *id)
+{
+	struct device *dev = &i2c->dev;
+	// struct input_polled_dev *poll_dev;
+	struct input_dev *input;
+	struct dfr0550_ts *ts;
+	int error;
+
+	ts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);
+	if (!ts)
+		return -ENOMEM;
+
+	ts->i2c = i2c;
+
+	i2c_set_clientdata(i2c, ts);
+
+	input = devm_input_allocate_device(dev);
+	if (!input) {
+		dev_err(dev, "Failed to allocate input device\n");
+		return -ENOMEM;
+	}
+
+	ts->input = input;
+	input_set_drvdata(input, ts);
+
+	// input = poll_dev->input;
+
+	input->name = "dfr0550-ts";
+	input->id.bustype = BUS_HOST;
+
+	// poll_dev->poll_interval = TS_POLL_INTERVAL;
+	// poll_dev->poll = dfr0550_ts_poll;
+	// poll_dev->private = ts;
+
+	input_set_abs_params(input, ABS_MT_POSITION_X, 0,
+			     TS_DEFAULT_WIDTH, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, 0,
+			     TS_DEFAULT_HEIGHT, 0, 0);
+	touchscreen_parse_properties(input, true, &ts->prop);
+
+	error = input_mt_init_slots(input, TS_MAX_SUPPORTED_POINTS,
+				    INPUT_MT_DIRECT);
+	if (error) {
+		dev_err(dev, "could not init mt slots, %d\n", error);
+		return error;
+	}
+
+	error = input_setup_polling(input, dfr0550_ts_poll);
+	if (error) {
+		dev_err(dev, "could not set up polling mode, %d\n", error);
+		return error;
+	}
+
+	input_set_poll_interval(input, TS_POLL_INTERVAL);
+
+	of_property_read_u32(dev->of_node, "rotate", &ts->rotate);
+	if (ts->rotate != 0 && ts->rotate != 180) {
+		dev_err(dev, "can't support rotate %d, only support 180\n", ts->rotate);
+		ts->rotate = 0;
+	}
+
+	error = input_register_device(input);
+	if (error) {
+		dev_err(dev, "could not register input device, %d\n", error);
+		return error;
+	}
+
+	return 0;
+}
+
+static int dfr0550_ts_i2c_remove(struct i2c_client *i2c)
+{
+	return 0;
+}
+
+static const struct of_device_id dfr0550_ts_dt_ids[] = {
+	{ .compatible = "realtek,dfr0550_ts", },
+	{},
+};
+
+static struct i2c_driver dfr0550_ts_i2c_driver = {
+	.driver = {
+		.name = "dfr0550_ts_i2c",
+		.of_match_table =  of_match_ptr(dfr0550_ts_dt_ids),
+	},
+	.probe = dfr0550_ts_i2c_probe,
+	.remove = dfr0550_ts_i2c_remove,
+};
+
+static int __init dfr0550_ts_init(void)
+{
+	int err;
+
+	err = i2c_add_driver(&dfr0550_ts_i2c_driver);
+	if (err != 0) {
+		pr_err("rtk dsi add i2c driver fail\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static void __exit dfr0550_ts_exit(void)
+{
+	i2c_del_driver(&dfr0550_ts_i2c_driver);
+}
+
+module_init(dfr0550_ts_init);
+module_exit(dfr0550_ts_exit);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("DFR0550 touchscreen kernel module");
