Index: minigbm/external/realtek_drm.h
===================================================================
--- /dev/null
+++ minigbm/external/realtek_drm.h
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2019 Realtek Inc.
+ * Author: Simon Hsu <simon_hsu@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI_REALTEK_DRM_H
+#define _UAPI_REALTEK_DRM_H
+
+#include <drm/drm.h>
+
+/**
+ * User-desired buffer creation information structure.
+ *
+ * @size: user-desired memory allocation size.
+ *	- this size value would be page-aligned internally.
+ * @flags: user request for setting memory type or cache attributes.
+ * @handle: returned a handle to created gem object.
+ *	- this handle will be set by gem module of kernel side.
+ */
+struct drm_rtk_gem_create {
+	uint64_t size;
+	uint32_t flags;
+	uint32_t handle;
+};
+
+/**
+ * A structure for getting buffer offset.
+ *
+ * @handle: a pointer to gem object created.
+ * @pad: just padding to be 64-bit aligned.
+ * @offset: relatived offset value of the memory region allocated.
+ *     - this value should be set by user.
+ */
+struct drm_rtk_gem_map_off {
+	uint32_t handle;
+	uint32_t pad;
+	uint64_t offset;
+};
+
+#define DRM_RTK_GEM_CREATE		0x00
+#define DRM_RTK_GEM_MAP_OFFSET		0x01
+
+#define DRM_IOCTL_RTK_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_RTK_GEM_CREATE, struct drm_rtk_gem_create)
+
+#define DRM_IOCTL_RTK_GEM_MAP_OFFSET	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_RTK_GEM_MAP_OFFSET, struct drm_rtk_gem_map_off)
+
+
+#endif /* _UAPI_REALTEK_DRM_H */
Index: minigbm/realtek.c
===================================================================
--- /dev/null
+++ minigbm/realtek.c
@@ -0,0 +1,100 @@
+#ifdef DRV_REALTEK
+
+#include <errno.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <xf86drm.h>
+
+#include "drv_helpers.h"
+#include "drv_priv.h"
+#include "util.h"
+#include "external/realtek_drm.h"
+
+static const uint32_t scanout_render_formats[] = { DRM_FORMAT_ARGB8888, DRM_FORMAT_XRGB8888,
+               DRM_FORMAT_ABGR8888, DRM_FORMAT_XBGR8888,
+               DRM_FORMAT_BGR888, DRM_FORMAT_RGB565 };
+
+static const uint32_t texture_only_formats[] = { DRM_FORMAT_R8, DRM_FORMAT_NV12, DRM_FORMAT_NV21,
+             DRM_FORMAT_YVU420, DRM_FORMAT_YVU420_ANDROID };
+
+
+static int realtek_driver_init(struct driver *drv)
+{
+  drv_add_combinations(drv, scanout_render_formats, ARRAY_SIZE(scanout_render_formats),
+           &LINEAR_METADATA, BO_USE_RENDER_MASK | BO_USE_SCANOUT);
+
+  drv_add_combinations(drv, texture_only_formats, ARRAY_SIZE(texture_only_formats),
+           &LINEAR_METADATA, BO_USE_TEXTURE_MASK);
+
+  drv_modify_combination(drv, DRM_FORMAT_R8, &LINEAR_METADATA,
+             BO_USE_HW_VIDEO_ENCODER | BO_USE_HW_VIDEO_DECODER |
+           BO_USE_CAMERA_READ | BO_USE_CAMERA_WRITE |
+           BO_USE_GPU_DATA_BUFFER | BO_USE_SENSOR_DIRECT_DATA);
+  drv_modify_combination(drv, DRM_FORMAT_NV12, &LINEAR_METADATA,
+             BO_USE_HW_VIDEO_ENCODER | BO_USE_HW_VIDEO_DECODER |
+           BO_USE_CAMERA_READ | BO_USE_CAMERA_WRITE);
+  drv_modify_combination(drv, DRM_FORMAT_NV21, &LINEAR_METADATA, BO_USE_HW_VIDEO_ENCODER);
+
+  return drv_modify_linear_combinations(drv);
+}
+
+static int realtek_bo_create(struct bo *bo, uint32_t width, uint32_t height, uint32_t format,
+					uint64_t use_flags)
+{
+	int ret;
+	struct drm_rtk_gem_create args = { 0 };
+	uint32_t stride;
+	stride = drv_stride_from_format(format, width, 0);
+	drv_bo_from_format(bo, stride, 1, height, format);
+	bo->meta.total_size = ALIGN(bo->meta.total_size, 4096);
+	args.size = bo->meta.total_size;
+	ret = drmIoctl(bo->drv->fd, DRM_RTK_GEM_CREATE , &args);
+	if (ret) {
+    drv_loge("DRM_RTK_GEM_CREATE failed (size=%zu)\n", bo->meta.total_size);
+    return -errno;
+  }
+	bo->handle.u32 = args.handle;
+	return 0;
+}
+
+static int realtek_bo_create_with_modifiers(struct bo *bo, uint32_t width, uint32_t height,
+           uint32_t format, const uint64_t *modifiers, uint32_t count)
+{
+  for (uint32_t i = 0; i < count; i++) {
+    if (modifiers[i] == DRM_FORMAT_MOD_LINEAR) {
+      return realtek_bo_create(bo, width, height, format, 0);
+    }
+  }
+
+  return -EINVAL;
+}
+
+static void * realtek_bo_map(struct bo *bo, struct vma *vma, uint32_t map_flags)
+{
+	int ret;
+	struct drm_rtk_gem_map_off args = { 0 };
+	args.handle = bo->handle.u32;
+	ret = drmIoctl(bo->drv->fd, DRM_RTK_GEM_MAP_OFFSET, &args);
+	if (ret) {
+    drv_loge("DRM_RTK_GEM_MAP_OFFSET failed\n");
+    return MAP_FAILED;
+  }
+	vma->length = bo->meta.total_size;
+	return mmap(NULL, bo->meta.total_size, drv_get_prot(map_flags), MAP_SHARED, bo->drv->fd,
+							args.offset);
+}
+
+const struct backend backend_realtek = {
+	.name = "realtek",
+	.init = realtek_driver_init,
+	.bo_create = realtek_bo_create,
+	.bo_create_with_modifiers = realtek_bo_create_with_modifiers,
+	.bo_destroy = drv_gem_bo_destroy,
+	.bo_import = drv_prime_bo_import,
+	.bo_map = realtek_bo_map,
+	.bo_unmap = drv_bo_munmap,
+	.resolve_format_and_use_flags = drv_resolve_format_and_use_flags_helper,
+};
+#endif //DRV_REALTEK
